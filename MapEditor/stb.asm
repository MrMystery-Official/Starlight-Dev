; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0M@MHDBFHD@unsupported@			; `string'
PUBLIC	??_C@_0O@DEFOLMLB@bad?5size?5list@		; `string'
PUBLIC	??_C@_0BB@FOKGPEKG@bad?5code?5lengths@		; `string'
PUBLIC	??_C@_0BB@IIMLINA@bad?5huffman?5code@		; `string'
PUBLIC	??_C@_0BD@CBEDEJPH@unknown?5image?5type@	; `string'
PUBLIC	??_C@_08NOGIMCHF@outofmem@			; `string'
PUBLIC	??_C@_0M@JPDHFAGK@can?8t?5fopen@		; `string'
PUBLIC	??_C@_0N@BOFJCHAP@bad?5DQT?5type@		; `string'
PUBLIC	??_C@_0O@CNHKKDIM@bad?5DQT?5table@		; `string'
PUBLIC	??_C@_0P@JLGKOCGN@bad?5DHT?5header@		; `string'
PUBLIC	??_C@_0M@CICAFFCH@bad?5COM?5len@		; `string'
PUBLIC	??_C@_09IFDKCGFO@bad?5delta@			; `string'
PUBLIC	??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@	; `string'
PUBLIC	??_C@_0BA@KLNDOKJD@expected?5marker@		; `string'
PUBLIC	??_C@_0M@LPHNODCG@bad?5DRI?5len@		; `string'
PUBLIC	??_C@_0M@NOCCBFAC@bad?5DC?5huff@		; `string'
PUBLIC	??_C@_0M@JGMCBLGG@bad?5AC?5huff@		; `string'
PUBLIC	??_C@_07EEJOMGGP@bad?5SOS@			; `string'
PUBLIC	??_C@_0M@DOFMJEMP@bad?5SOF?5len@		; `string'
PUBLIC	??_C@_0M@EENLKPDI@bad?5APP?5len@		; `string'
PUBLIC	??_C@_0P@NNGPHMMK@unknown?5marker@		; `string'
PUBLIC	??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count@	; `string'
PUBLIC	??_C@_0M@GNEHAHOH@bad?5SOS?5len@		; `string'
PUBLIC	??_C@_0BE@DAPHADHL@bad?5component?5count@	; `string'
PUBLIC	??_C@_05BLPKENEJ@bad?5H@			; `string'
PUBLIC	??_C@_05MPLLHCJG@bad?5V@			; `string'
PUBLIC	??_C@_06LJIHDFHI@bad?5TQ@			; `string'
PUBLIC	??_C@_0L@BCINMEBJ@only?58?9bit@			; `string'
PUBLIC	??_C@_0BB@LNEGOMA@no?5header?5height@		; `string'
PUBLIC	??_C@_07BIDACDEF@0?5width@			; `string'
PUBLIC	??_C@_09OJDLMMBJ@too?5large@			; `string'
PUBLIC	??_C@_0N@KBPNPPBJ@bad?5req_comp@		; `string'
PUBLIC	??_C@_09EOHLEIKL@bad?5sizes@			; `string'
PUBLIC	??_C@_0BA@MDNKOBMC@bad?5codelengths@		; `string'
PUBLIC	??_C@_0BE@IBFIPFO@output?5buffer?5limit@	; `string'
PUBLIC	??_C@_06CLMBLEP@no?5SOI@			; `string'
PUBLIC	??_C@_06IFCEAHIA@no?5SOF@			; `string'
PUBLIC	??_C@_0M@EPMOIECP@bad?5DNL?5len@		; `string'
PUBLIC	??_C@_0P@PNCLKCLJ@bad?5DNL?5height@		; `string'
PUBLIC	??_C@_0P@DOGMHEBI@no?5preset?5dict@		; `string'
PUBLIC	??_C@_0BA@MCNBDLPD@bad?5compression@		; `string'
PUBLIC	??_C@_0M@DMDNBACF@bad?5png?5sig@		; `string'
PUBLIC	??_C@_0BC@BHMPBBMG@not?5enough?5pixels@		; `string'
PUBLIC	??_C@_08DIAPIMGJ@bad?5dist@			; `string'
PUBLIC	??_C@_0N@IECDHMDI@zlib?5corrupt@		; `string'
PUBLIC	??_C@_0BB@PIPBCKIA@read?5past?5buffer@		; `string'
PUBLIC	??_C@_0BA@OBKOPAFL@bad?5zlib?5header@		; `string'
PUBLIC	??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only@	; `string'
PUBLIC	??_C@_09MBBNGCKB@bad?5ctype@			; `string'
PUBLIC	??_C@_0BA@MDMBDDFG@bad?5comp?5method@		; `string'
PUBLIC	??_C@_0BC@GHLIKKMD@bad?5filter?5method@		; `string'
PUBLIC	??_C@_0P@FBBCPGMN@invalid?5filter@		; `string'
PUBLIC	??_C@_0O@MKGNGALN@invalid?5width@		; `string'
PUBLIC	??_C@_0O@KBHBNJOK@multiple?5IHDR@		; `string'
PUBLIC	??_C@_0N@POJLKMKK@bad?5IHDR?5len@		; `string'
PUBLIC	??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT@		; `string'
PUBLIC	??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE@		; `string'
PUBLIC	??_C@_0N@KDLCCKCH@bad?5tRNS?5len@		; `string'
PUBLIC	??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha@		; `string'
PUBLIC	??_C@_0BF@JCGDPBAA@bad?5interlace?5method@	; `string'
PUBLIC	??_C@_0O@FNFBHCOO@0?9pixel?5image@		; `string'
PUBLIC	??_C@_0P@JEAFOMAF@first?5not?5IHDR@		; `string'
PUBLIC	??_C@_0N@JCPAJAKB@invalid?5PLTE@		; `string'
PUBLIC	??_C@_0BF@NOEEEFMF@bad?5bits_per_channel@	; `string'
PUBLIC	??_C@_07IANEBNLB@not?5BMP@			; `string'
PUBLIC	??_C@_07IEJCHBDI@bad?5BMP@			; `string'
PUBLIC	??_C@_0M@KHBIBJBG@unknown?5BMP@			; `string'
PUBLIC	??_C@_07CKIELOEH@no?5PLTE@			; `string'
PUBLIC	??_C@_0BA@PLHGLONG@IDAT?5size?5limit@		; `string'
PUBLIC	??_C@_09MNNCNKEO@outofdata@			; `string'
PUBLIC	??_C@_07MLPECBNA@no?5IDAT@			; `string'
PUBLIC	??_C@_07MALOAKCI@invalid@			; `string'
PUBLIC	??_C@_07JNJHIMGH@bad?5bpp@			; `string'
PUBLIC	??_C@_09DAEBACAB@bad?5masks@			; `string'
PUBLIC	??_C@_0L@DMAPJJO@bad?5format@			; `string'
PUBLIC	??_C@_07IMHMNOIB@BMP?5RLE@			; `string'
PUBLIC	??_C@_0N@ODCBCBFN@BMP?5JPEG?1PNG@		; `string'
PUBLIC	??_C@_0L@PJHPAMCH@bad?5header@			; `string'
PUBLIC	??_C@_0L@JDPIFELH@bad?5offset@			; `string'
PUBLIC	??_C@_0BG@NOLDLPP@unsupported?5bit?5depth@	; `string'
PUBLIC	??_C@_0BD@IOGGBMNK@wrong?5color?5format@	; `string'
PUBLIC	??_C@_07DPPMCAKL@corrupt@			; `string'
PUBLIC	??_C@_04KBFEPHFH@S?$IA?v4@			; `string'
PUBLIC	??_C@_0M@ILLOCNCO@bad?5palette@			; `string'
PUBLIC	??_C@_07ECNCNLIK@not?5PSD@			; `string'
PUBLIC	??_C@_0O@CHBCDKKC@wrong?5version@		; `string'
PUBLIC	??_C@_0BE@PJBNGDBE@wrong?5channel?5count@	; `string'
PUBLIC	??_C@_0P@GJNJCPDJ@too?5many?5codes@		; `string'
PUBLIC	??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@	; `string'
PUBLIC	??_C@_0BF@GIAALCNJ@bad?5Image?5Descriptor@	; `string'
PUBLIC	??_C@_0BE@NAMJKDNF@missing?5color?5table@	; `string'
PUBLIC	??_C@_04ELNJHLFH@PICT@				; `string'
PUBLIC	??_C@_08GGMBIFE@bad?5file@			; `string'
PUBLIC	??_C@_07KMJLPAII@not?5GIF@			; `string'
PUBLIC	??_C@_0O@MGDACKOJ@no?5clear?5code@		; `string'
PUBLIC	??_C@_06NDOKKIDJ@?$CD?$DPRGBE@			; `string'
PUBLIC	??_C@_07NCIOKENI@not?5HDR@			; `string'
PUBLIC	??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@	; `string'
PUBLIC	??_C@_0BD@NKJFFLKL@unsupported?5format@		; `string'
PUBLIC	??_C@_0N@DJABBOOH@unknown?5code@		; `string'
PUBLIC	??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@		; `string'
PUBLIC	??_C@_07KFDJIKCK@?$CD?$DPRGBE?6@		; `string'
PUBLIC	??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@		; `string'
PUBLIC	??_C@_07IDKIDMGJ@bad?5PNM@			; `string'
PUBLIC	??_C@_0BH@OBINMOBC@integer?5parse?5overflow@	; `string'
PUBLIC	??_C@_0BC@CNFMOKHC@max?5value?5?$DO?565535@	; `string'
PUBLIC	??_C@_0BI@JMCBNFKL@11?54?522?544?544?522?5444444@ ; `string'
PUBLIC	??_C@_03HKAKGGJN@?9Y?5@				; `string'
PUBLIC	??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@	; `string'
PUBLIC	??_C@_03FOKDFDHG@?$CLX?5@			; `string'
PUBLIC	??_C@_0CA@JBEOCDFN@invalid?5decoded?5scanline?5length@ ; `string'
PUBLIC	??_C@_04MNIAFIMC@IHDR@				; `string'
PUBLIC	??_C@_04NHMHICBH@IDAT@				; `string'
PUBLIC	??_C@_04COOFLABO@IEND@				; `string'
PUBLIC	??_C@_0CP@CIFMJOPF@11?54?522?544?544?522?5444444?54444?54?5@ ; `string'
PUBLIC	??_C@_0BA@BIJKEPCF@111?5221?52222?511@		; `string'
PUBLIC	??_C@_0EC@HFFFEKFH@?$CD?$DPRADIANCE?6?$CD?5Written?5by?5stb_ima@ ; `string'
PUBLIC	??_C@_0DB@NJMBBANC@EXPOSURE?$DN?5?5?5?5?5?5?5?5?5?51?40000000000@ ; `string'
PUBLIC	stbi_write_tga_with_rle
PUBLIC	stbi_write_force_png_filter
PUBLIC	stbi_write_png_compression_level
EXTRN	__imp_ldexp:PROC
EXTRN	__imp_feof:PROC
EXTRN	__imp_frexp:PROC
EXTRN	__imp_realloc:PROC
EXTRN	__imp_ferror:PROC
?stbi__unpremultiply_on_load_global@@3HA DD 01H DUP (?)	; stbi__unpremultiply_on_load_global
?stbi__vertically_flip_on_load_global@@3HA DD 01H DUP (?) ; stbi__vertically_flip_on_load_global
?stbi__flip_vertically_on_write@@3HA DD 01H DUP (?)	; stbi__flip_vertically_on_write
?stbi__de_iphone_flag_global@@3HA DD 01H DUP (?)	; stbi__de_iphone_flag_global
_BSS	ENDS
;	COMDAT ?shift_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA
CONST	SEGMENT
?shift_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA DD 00H ; `stbi__shiftsigned'::`2'::shift_table
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	04H
	DD	06H
	DD	00H
CONST	ENDS
;	COMDAT ?YAC_HT@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QAY01$$CBGA
CONST	SEGMENT
?YAC_HT@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QAY01$$CBGA DW 0aH ; `stbi_write_jpg_core'::`2'::YAC_HT
	DW	04H
	DW	00H
	DW	02H
	DW	01H
	DW	02H
	DW	04H
	DW	03H
	DW	0bH
	DW	04H
	DW	01aH
	DW	05H
	DW	078H
	DW	07H
	DW	0f8H
	DW	08H
	DW	03f6H
	DW	0aH
	DW	0ff82H
	DW	010H
	DW	0ff83H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0cH
	DW	04H
	DW	01bH
	DW	05H
	DW	079H
	DW	07H
	DW	01f6H
	DW	09H
	DW	07f6H
	DW	0bH
	DW	0ff84H
	DW	010H
	DW	0ff85H
	DW	010H
	DW	0ff86H
	DW	010H
	DW	0ff87H
	DW	010H
	DW	0ff88H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01cH
	DW	05H
	DW	0f9H
	DW	08H
	DW	03f7H
	DW	0aH
	DW	0ff4H
	DW	0cH
	DW	0ff89H
	DW	010H
	DW	0ff8aH
	DW	010H
	DW	0ff8bH
	DW	010H
	DW	0ff8cH
	DW	010H
	DW	0ff8dH
	DW	010H
	DW	0ff8eH
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	03aH
	DW	06H
	DW	01f7H
	DW	09H
	DW	0ff5H
	DW	0cH
	DW	0ff8fH
	DW	010H
	DW	0ff90H
	DW	010H
	DW	0ff91H
	DW	010H
	DW	0ff92H
	DW	010H
	DW	0ff93H
	DW	010H
	DW	0ff94H
	DW	010H
	DW	0ff95H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	03bH
	DW	06H
	DW	03f8H
	DW	0aH
	DW	0ff96H
	DW	010H
	DW	0ff97H
	DW	010H
	DW	0ff98H
	DW	010H
	DW	0ff99H
	DW	010H
	DW	0ff9aH
	DW	010H
	DW	0ff9bH
	DW	010H
	DW	0ff9cH
	DW	010H
	DW	0ff9dH
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	07aH
	DW	07H
	DW	07f7H
	DW	0bH
	DW	0ff9eH
	DW	010H
	DW	0ff9fH
	DW	010H
	DW	0ffa0H
	DW	010H
	DW	0ffa1H
	DW	010H
	DW	0ffa2H
	DW	010H
	DW	0ffa3H
	DW	010H
	DW	0ffa4H
	DW	010H
	DW	0ffa5H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	07bH
	DW	07H
	DW	0ff6H
	DW	0cH
	DW	0ffa6H
	DW	010H
	DW	0ffa7H
	DW	010H
	DW	0ffa8H
	DW	010H
	DW	0ffa9H
	DW	010H
	DW	0ffaaH
	DW	010H
	DW	0ffabH
	DW	010H
	DW	0ffacH
	DW	010H
	DW	0ffadH
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0faH
	DW	08H
	DW	0ff7H
	DW	0cH
	DW	0ffaeH
	DW	010H
	DW	0ffafH
	DW	010H
	DW	0ffb0H
	DW	010H
	DW	0ffb1H
	DW	010H
	DW	0ffb2H
	DW	010H
	DW	0ffb3H
	DW	010H
	DW	0ffb4H
	DW	010H
	DW	0ffb5H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01f8H
	DW	09H
	DW	07fc0H
	DW	0fH
	DW	0ffb6H
	DW	010H
	DW	0ffb7H
	DW	010H
	DW	0ffb8H
	DW	010H
	DW	0ffb9H
	DW	010H
	DW	0ffbaH
	DW	010H
	DW	0ffbbH
	DW	010H
	DW	0ffbcH
	DW	010H
	DW	0ffbdH
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01f9H
	DW	09H
	DW	0ffbeH
	DW	010H
	DW	0ffbfH
	DW	010H
	DW	0ffc0H
	DW	010H
	DW	0ffc1H
	DW	010H
	DW	0ffc2H
	DW	010H
	DW	0ffc3H
	DW	010H
	DW	0ffc4H
	DW	010H
	DW	0ffc5H
	DW	010H
	DW	0ffc6H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01faH
	DW	09H
	DW	0ffc7H
	DW	010H
	DW	0ffc8H
	DW	010H
	DW	0ffc9H
	DW	010H
	DW	0ffcaH
	DW	010H
	DW	0ffcbH
	DW	010H
	DW	0ffccH
	DW	010H
	DW	0ffcdH
	DW	010H
	DW	0ffceH
	DW	010H
	DW	0ffcfH
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	03f9H
	DW	0aH
	DW	0ffd0H
	DW	010H
	DW	0ffd1H
	DW	010H
	DW	0ffd2H
	DW	010H
	DW	0ffd3H
	DW	010H
	DW	0ffd4H
	DW	010H
	DW	0ffd5H
	DW	010H
	DW	0ffd6H
	DW	010H
	DW	0ffd7H
	DW	010H
	DW	0ffd8H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	03faH
	DW	0aH
	DW	0ffd9H
	DW	010H
	DW	0ffdaH
	DW	010H
	DW	0ffdbH
	DW	010H
	DW	0ffdcH
	DW	010H
	DW	0ffddH
	DW	010H
	DW	0ffdeH
	DW	010H
	DW	0ffdfH
	DW	010H
	DW	0ffe0H
	DW	010H
	DW	0ffe1H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	07f8H
	DW	0bH
	DW	0ffe2H
	DW	010H
	DW	0ffe3H
	DW	010H
	DW	0ffe4H
	DW	010H
	DW	0ffe5H
	DW	010H
	DW	0ffe6H
	DW	010H
	DW	0ffe7H
	DW	010H
	DW	0ffe8H
	DW	010H
	DW	0ffe9H
	DW	010H
	DW	0ffeaH
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0ffebH
	DW	010H
	DW	0ffecH
	DW	010H
	DW	0ffedH
	DW	010H
	DW	0ffeeH
	DW	010H
	DW	0ffefH
	DW	010H
	DW	0fff0H
	DW	010H
	DW	0fff1H
	DW	010H
	DW	0fff2H
	DW	010H
	DW	0fff3H
	DW	010H
	DW	0fff4H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	07f9H
	DW	0bH
	DW	0fff5H
	DW	010H
	DW	0fff6H
	DW	010H
	DW	0fff7H
	DW	010H
	DW	0fff8H
	DW	010H
	DW	0fff9H
	DW	010H
	DW	0fffaH
	DW	010H
	DW	0fffbH
	DW	010H
	DW	0fffcH
	DW	010H
	DW	0fffdH
	DW	010H
	DW	0fffeH
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
CONST	ENDS
;	COMDAT ?head0@?M@??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB
CONST	SEGMENT
?head0@?M@??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB DB 0ffH ; `stbi_write_jpg_core'::`12'::head0
	DB	0d8H
	DB	0ffH
	DB	0e0H
	DB	00H
	DB	010H
	DB	04aH
	DB	046H
	DB	049H
	DB	046H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0dbH
	DB	00H
	DB	084H
	DB	00H
CONST	ENDS
;	COMDAT ?lengtheb@?1??stbi_zlib_compress@@9@4PAEA
CONST	SEGMENT
?lengtheb@?1??stbi_zlib_compress@@9@4PAEA DB 00H	; `stbi_zlib_compress'::`2'::lengtheb
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	00H
CONST	ENDS
;	COMDAT ?YDC_HT@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QAY01$$CBGA
CONST	SEGMENT
?YDC_HT@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QAY01$$CBGA DW 00H ; `stbi_write_jpg_core'::`2'::YDC_HT
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	03H
	DW	04H
	DW	03H
	DW	05H
	DW	03H
	DW	06H
	DW	03H
	DW	0eH
	DW	04H
	DW	01eH
	DW	05H
	DW	03eH
	DW	06H
	DW	07eH
	DW	07H
	DW	0feH
	DW	08H
	DW	01feH
	DW	09H
	ORG $+976
CONST	ENDS
;	COMDAT ?std_ac_luminance_values@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB
CONST	SEGMENT
?std_ac_luminance_values@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB DB 01H ; `stbi_write_jpg_core'::`2'::std_ac_luminance_values
	DB	02H
	DB	03H
	DB	00H
	DB	04H
	DB	011H
	DB	05H
	DB	012H
	DB	021H
	DB	031H
	DB	041H
	DB	06H
	DB	013H
	DB	051H
	DB	061H
	DB	07H
	DB	022H
	DB	071H
	DB	014H
	DB	032H
	DB	081H
	DB	091H
	DB	0a1H
	DB	08H
	DB	023H
	DB	042H
	DB	0b1H
	DB	0c1H
	DB	015H
	DB	052H
	DB	0d1H
	DB	0f0H
	DB	024H
	DB	033H
	DB	062H
	DB	072H
	DB	082H
	DB	09H
	DB	0aH
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	083H
	DB	084H
	DB	085H
	DB	086H
	DB	087H
	DB	088H
	DB	089H
	DB	08aH
	DB	092H
	DB	093H
	DB	094H
	DB	095H
	DB	096H
	DB	097H
	DB	098H
	DB	099H
	DB	09aH
	DB	0a2H
	DB	0a3H
	DB	0a4H
	DB	0a5H
	DB	0a6H
	DB	0a7H
	DB	0a8H
	DB	0a9H
	DB	0aaH
	DB	0b2H
	DB	0b3H
	DB	0b4H
	DB	0b5H
	DB	0b6H
	DB	0b7H
	DB	0b8H
	DB	0b9H
	DB	0baH
	DB	0c2H
	DB	0c3H
	DB	0c4H
	DB	0c5H
	DB	0c6H
	DB	0c7H
	DB	0c8H
	DB	0c9H
	DB	0caH
	DB	0d2H
	DB	0d3H
	DB	0d4H
	DB	0d5H
	DB	0d6H
	DB	0d7H
	DB	0d8H
	DB	0d9H
	DB	0daH
	DB	0e1H
	DB	0e2H
	DB	0e3H
	DB	0e4H
	DB	0e5H
	DB	0e6H
	DB	0e7H
	DB	0e8H
	DB	0e9H
	DB	0eaH
	DB	0f1H
	DB	0f2H
	DB	0f3H
	DB	0f4H
	DB	0f5H
	DB	0f6H
	DB	0f7H
	DB	0f8H
	DB	0f9H
	DB	0faH
CONST	ENDS
;	COMDAT ?disteb@?1??stbi_zlib_compress@@9@4PAEA
CONST	SEGMENT
?disteb@?1??stbi_zlib_compress@@9@4PAEA DB 00H		; `stbi_zlib_compress'::`2'::disteb
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT ?rgb@?BG@??stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z@4QBEB
CONST	SEGMENT
?rgb@?BG@??stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z@4QBEB DB 052H ; `stbi__process_frame_header'::`22'::rgb
	DB	047H
	DB	042H
CONST	ENDS
;	COMDAT ?std_dc_luminance_nrcodes@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB
CONST	SEGMENT
?std_dc_luminance_nrcodes@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB DB 00H ; `stbi_write_jpg_core'::`2'::std_dc_luminance_nrcodes
	DB	00H
	DB	01H
	DB	05H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ?png_sig@?1??stbi__check_png_header@@YAHPEAUstbi__context@@@Z@4QBEB
CONST	SEGMENT
?png_sig@?1??stbi__check_png_header@@YAHPEAUstbi__context@@@Z@4QBEB DB 089H ; `stbi__check_png_header'::`2'::png_sig
	DB	050H
	DB	04eH
	DB	047H
	DB	0dH
	DB	0aH
	DB	01aH
	DB	0aH
CONST	ENDS
;	COMDAT ?mapping@?1??stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z@4PAHA
_DATA	SEGMENT
?mapping@?1??stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z@4PAHA DD 00H ; `stbiw__encode_png_line'::`2'::mapping
	DD	01H
	DD	02H
	DD	03H
	DD	04H
_DATA	ENDS
;	COMDAT ?std_ac_chrominance_nrcodes@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB
CONST	SEGMENT
?std_ac_chrominance_nrcodes@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB DB 00H ; `stbi_write_jpg_core'::`2'::std_ac_chrominance_nrcodes
	DB	00H
	DB	02H
	DB	01H
	DB	02H
	DB	04H
	DB	04H
	DB	03H
	DB	04H
	DB	07H
	DB	05H
	DB	04H
	DB	04H
	DB	00H
	DB	01H
	DB	02H
	DB	077H
CONST	ENDS
;	COMDAT ?UVQT@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBHB
CONST	SEGMENT
?UVQT@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBHB DD 011H ; `stbi_write_jpg_core'::`2'::UVQT
	DD	012H
	DD	018H
	DD	02fH
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	012H
	DD	015H
	DD	01aH
	DD	042H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	018H
	DD	01aH
	DD	038H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	02fH
	DD	042H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
	DD	063H
CONST	ENDS
;	COMDAT ?YQT@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBHB
CONST	SEGMENT
?YQT@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBHB DD 010H ; `stbi_write_jpg_core'::`2'::YQT
	DD	0bH
	DD	0aH
	DD	010H
	DD	018H
	DD	028H
	DD	033H
	DD	03dH
	DD	0cH
	DD	0cH
	DD	0eH
	DD	013H
	DD	01aH
	DD	03aH
	DD	03cH
	DD	037H
	DD	0eH
	DD	0dH
	DD	010H
	DD	018H
	DD	028H
	DD	039H
	DD	045H
	DD	038H
	DD	0eH
	DD	011H
	DD	016H
	DD	01dH
	DD	033H
	DD	057H
	DD	050H
	DD	03eH
	DD	012H
	DD	016H
	DD	025H
	DD	038H
	DD	044H
	DD	06dH
	DD	067H
	DD	04dH
	DD	018H
	DD	023H
	DD	037H
	DD	040H
	DD	051H
	DD	068H
	DD	071H
	DD	05cH
	DD	031H
	DD	040H
	DD	04eH
	DD	057H
	DD	067H
	DD	079H
	DD	078H
	DD	065H
	DD	048H
	DD	05cH
	DD	05fH
	DD	062H
	DD	070H
	DD	064H
	DD	067H
	DD	063H
CONST	ENDS
;	COMDAT ?std_dc_chrominance_values@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB
CONST	SEGMENT
?std_dc_chrominance_values@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB DB 00H ; `stbi_write_jpg_core'::`2'::std_dc_chrominance_values
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
CONST	ENDS
;	COMDAT ?std_dc_chrominance_nrcodes@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB
CONST	SEGMENT
?std_dc_chrominance_nrcodes@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB DB 00H ; `stbi_write_jpg_core'::`2'::std_dc_chrominance_nrcodes
	DB	00H
	DB	03H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ?aasf@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBMB
CONST	SEGMENT
?aasf@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBMB DD 0403504f3r ; 2.82843 ; `stbi_write_jpg_core'::`2'::aasf
	DD	0407b14bfr			; 3.92314
	DD	0406c835fr			; 3.69552
	DD	04054db30r			; 3.32588
	DD	0403504f3r			; 2.82843
	DD	0400e39dar			; 2.22228
	DD	03fc3ef15r			; 1.53073
	DD	03f47c5c2r			; 0.780361
CONST	ENDS
;	COMDAT ?crc_table@?1??stbiw__crc32@@YAIPEAEH@Z@4PAIA
CONST	SEGMENT
?crc_table@?1??stbiw__crc32@@YAIPEAEH@Z@4PAIA DD 00H	; `stbiw__crc32'::`2'::crc_table
	DD	077073096H
	DD	0ee0e612cH
	DD	0990951baH
	DD	076dc419H
	DD	0706af48fH
	DD	0e963a535H
	DD	09e6495a3H
	DD	0edb8832H
	DD	079dcb8a4H
	DD	0e0d5e91eH
	DD	097d2d988H
	DD	09b64c2bH
	DD	07eb17cbdH
	DD	0e7b82d07H
	DD	090bf1d91H
	DD	01db71064H
	DD	06ab020f2H
	DD	0f3b97148H
	DD	084be41deH
	DD	01adad47dH
	DD	06ddde4ebH
	DD	0f4d4b551H
	DD	083d385c7H
	DD	0136c9856H
	DD	0646ba8c0H
	DD	0fd62f97aH
	DD	08a65c9ecH
	DD	014015c4fH
	DD	063066cd9H
	DD	0fa0f3d63H
	DD	08d080df5H
	DD	03b6e20c8H
	DD	04c69105eH
	DD	0d56041e4H
	DD	0a2677172H
	DD	03c03e4d1H
	DD	04b04d447H
	DD	0d20d85fdH
	DD	0a50ab56bH
	DD	035b5a8faH
	DD	042b2986cH
	DD	0dbbbc9d6H
	DD	0acbcf940H
	DD	032d86ce3H
	DD	045df5c75H
	DD	0dcd60dcfH
	DD	0abd13d59H
	DD	026d930acH
	DD	051de003aH
	DD	0c8d75180H
	DD	0bfd06116H
	DD	021b4f4b5H
	DD	056b3c423H
	DD	0cfba9599H
	DD	0b8bda50fH
	DD	02802b89eH
	DD	05f058808H
	DD	0c60cd9b2H
	DD	0b10be924H
	DD	02f6f7c87H
	DD	058684c11H
	DD	0c1611dabH
	DD	0b6662d3dH
	DD	076dc4190H
	DD	01db7106H
	DD	098d220bcH
	DD	0efd5102aH
	DD	071b18589H
	DD	06b6b51fH
	DD	09fbfe4a5H
	DD	0e8b8d433H
	DD	07807c9a2H
	DD	0f00f934H
	DD	09609a88eH
	DD	0e10e9818H
	DD	07f6a0dbbH
	DD	086d3d2dH
	DD	091646c97H
	DD	0e6635c01H
	DD	06b6b51f4H
	DD	01c6c6162H
	DD	0856530d8H
	DD	0f262004eH
	DD	06c0695edH
	DD	01b01a57bH
	DD	08208f4c1H
	DD	0f50fc457H
	DD	065b0d9c6H
	DD	012b7e950H
	DD	08bbeb8eaH
	DD	0fcb9887cH
	DD	062dd1ddfH
	DD	015da2d49H
	DD	08cd37cf3H
	DD	0fbd44c65H
	DD	04db26158H
	DD	03ab551ceH
	DD	0a3bc0074H
	DD	0d4bb30e2H
	DD	04adfa541H
	DD	03dd895d7H
	DD	0a4d1c46dH
	DD	0d3d6f4fbH
	DD	04369e96aH
	DD	0346ed9fcH
	DD	0ad678846H
	DD	0da60b8d0H
	DD	044042d73H
	DD	033031de5H
	DD	0aa0a4c5fH
	DD	0dd0d7cc9H
	DD	05005713cH
	DD	0270241aaH
	DD	0be0b1010H
	DD	0c90c2086H
	DD	05768b525H
	DD	0206f85b3H
	DD	0b966d409H
	DD	0ce61e49fH
	DD	05edef90eH
	DD	029d9c998H
	DD	0b0d09822H
	DD	0c7d7a8b4H
	DD	059b33d17H
	DD	02eb40d81H
	DD	0b7bd5c3bH
	DD	0c0ba6cadH
	DD	0edb88320H
	DD	09abfb3b6H
	DD	03b6e20cH
	DD	074b1d29aH
	DD	0ead54739H
	DD	09dd277afH
	DD	04db2615H
	DD	073dc1683H
	DD	0e3630b12H
	DD	094643b84H
	DD	0d6d6a3eH
	DD	07a6a5aa8H
	DD	0e40ecf0bH
	DD	09309ff9dH
	DD	0a00ae27H
	DD	07d079eb1H
	DD	0f00f9344H
	DD	08708a3d2H
	DD	01e01f268H
	DD	06906c2feH
	DD	0f762575dH
	DD	0806567cbH
	DD	0196c3671H
	DD	06e6b06e7H
	DD	0fed41b76H
	DD	089d32be0H
	DD	010da7a5aH
	DD	067dd4accH
	DD	0f9b9df6fH
	DD	08ebeeff9H
	DD	017b7be43H
	DD	060b08ed5H
	DD	0d6d6a3e8H
	DD	0a1d1937eH
	DD	038d8c2c4H
	DD	04fdff252H
	DD	0d1bb67f1H
	DD	0a6bc5767H
	DD	03fb506ddH
	DD	048b2364bH
	DD	0d80d2bdaH
	DD	0af0a1b4cH
	DD	036034af6H
	DD	041047a60H
	DD	0df60efc3H
	DD	0a867df55H
	DD	0316e8eefH
	DD	04669be79H
	DD	0cb61b38cH
	DD	0bc66831aH
	DD	0256fd2a0H
	DD	05268e236H
	DD	0cc0c7795H
	DD	0bb0b4703H
	DD	0220216b9H
	DD	05505262fH
	DD	0c5ba3bbeH
	DD	0b2bd0b28H
	DD	02bb45a92H
	DD	05cb36a04H
	DD	0c2d7ffa7H
	DD	0b5d0cf31H
	DD	02cd99e8bH
	DD	05bdeae1dH
	DD	09b64c2b0H
	DD	0ec63f226H
	DD	0756aa39cH
	DD	026d930aH
	DD	09c0906a9H
	DD	0eb0e363fH
	DD	072076785H
	DD	05005713H
	DD	095bf4a82H
	DD	0e2b87a14H
	DD	07bb12baeH
	DD	0cb61b38H
	DD	092d28e9bH
	DD	0e5d5be0dH
	DD	07cdcefb7H
	DD	0bdbdf21H
	DD	086d3d2d4H
	DD	0f1d4e242H
	DD	068ddb3f8H
	DD	01fda836eH
	DD	081be16cdH
	DD	0f6b9265bH
	DD	06fb077e1H
	DD	018b74777H
	DD	088085ae6H
	DD	0ff0f6a70H
	DD	066063bcaH
	DD	011010b5cH
	DD	08f659effH
	DD	0f862ae69H
	DD	0616bffd3H
	DD	0166ccf45H
	DD	0a00ae278H
	DD	0d70dd2eeH
	DD	04e048354H
	DD	03903b3c2H
	DD	0a7672661H
	DD	0d06016f7H
	DD	04969474dH
	DD	03e6e77dbH
	DD	0aed16a4aH
	DD	0d9d65adcH
	DD	040df0b66H
	DD	037d83bf0H
	DD	0a9bcae53H
	DD	0debb9ec5H
	DD	047b2cf7fH
	DD	030b5ffe9H
	DD	0bdbdf21cH
	DD	0cabac28aH
	DD	053b39330H
	DD	024b4a3a6H
	DD	0bad03605H
	DD	0cdd70693H
	DD	054de5729H
	DD	023d967bfH
	DD	0b3667a2eH
	DD	0c4614ab8H
	DD	05d681b02H
	DD	02a6f2b94H
	DD	0b40bbe37H
	DD	0c30c8ea1H
	DD	05a05df1bH
	DD	02d02ef8dH
CONST	ENDS
;	COMDAT ?length_dezigzag@?1??stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z@4QBEB
CONST	SEGMENT
?length_dezigzag@?1??stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z@4QBEB DB 010H ; `stbi__compute_huffman_codes'::`2'::length_dezigzag
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
CONST	ENDS
;	COMDAT ?distc@?1??stbi_zlib_compress@@9@4PAGA
CONST	SEGMENT
?distc@?1??stbi_zlib_compress@@9@4PAGA DW 01H		; `stbi_zlib_compress'::`2'::distc
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	08000H
CONST	ENDS
;	COMDAT ?head2@?M@??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB
CONST	SEGMENT
?head2@?M@??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB DB 0ffH ; `stbi_write_jpg_core'::`12'::head2
	DB	0daH
	DB	00H
	DB	0cH
	DB	03H
	DB	01H
	DB	00H
	DB	02H
	DB	011H
	DB	03H
	DB	011H
	DB	00H
	DB	03fH
	DB	00H
CONST	ENDS
;	COMDAT ?std_ac_chrominance_values@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB
CONST	SEGMENT
?std_ac_chrominance_values@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB DB 00H ; `stbi_write_jpg_core'::`2'::std_ac_chrominance_values
	DB	01H
	DB	02H
	DB	03H
	DB	011H
	DB	04H
	DB	05H
	DB	021H
	DB	031H
	DB	06H
	DB	012H
	DB	041H
	DB	051H
	DB	07H
	DB	061H
	DB	071H
	DB	013H
	DB	022H
	DB	032H
	DB	081H
	DB	08H
	DB	014H
	DB	042H
	DB	091H
	DB	0a1H
	DB	0b1H
	DB	0c1H
	DB	09H
	DB	023H
	DB	033H
	DB	052H
	DB	0f0H
	DB	015H
	DB	062H
	DB	072H
	DB	0d1H
	DB	0aH
	DB	016H
	DB	024H
	DB	034H
	DB	0e1H
	DB	025H
	DB	0f1H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	082H
	DB	083H
	DB	084H
	DB	085H
	DB	086H
	DB	087H
	DB	088H
	DB	089H
	DB	08aH
	DB	092H
	DB	093H
	DB	094H
	DB	095H
	DB	096H
	DB	097H
	DB	098H
	DB	099H
	DB	09aH
	DB	0a2H
	DB	0a3H
	DB	0a4H
	DB	0a5H
	DB	0a6H
	DB	0a7H
	DB	0a8H
	DB	0a9H
	DB	0aaH
	DB	0b2H
	DB	0b3H
	DB	0b4H
	DB	0b5H
	DB	0b6H
	DB	0b7H
	DB	0b8H
	DB	0b9H
	DB	0baH
	DB	0c2H
	DB	0c3H
	DB	0c4H
	DB	0c5H
	DB	0c6H
	DB	0c7H
	DB	0c8H
	DB	0c9H
	DB	0caH
	DB	0d2H
	DB	0d3H
	DB	0d4H
	DB	0d5H
	DB	0d6H
	DB	0d7H
	DB	0d8H
	DB	0d9H
	DB	0daH
	DB	0e2H
	DB	0e3H
	DB	0e4H
	DB	0e5H
	DB	0e6H
	DB	0e7H
	DB	0e8H
	DB	0e9H
	DB	0eaH
	DB	0f2H
	DB	0f3H
	DB	0f4H
	DB	0f5H
	DB	0f6H
	DB	0f7H
	DB	0f8H
	DB	0f9H
	DB	0faH
CONST	ENDS
;	COMDAT ?fillBits@?N@??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBGB
CONST	SEGMENT
?fillBits@?N@??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBGB DW 07fH ; `stbi_write_jpg_core'::`13'::fillBits
	DW	07H
CONST	ENDS
;	COMDAT ?firstmap@?1??stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z@4PAHA
_DATA	SEGMENT
?firstmap@?1??stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z@4PAHA DD 00H ; `stbiw__encode_png_line'::`2'::firstmap
	DD	01H
	DD	00H
	DD	05H
	DD	06H
_DATA	ENDS
;	COMDAT ?UVAC_HT@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QAY01$$CBGA
CONST	SEGMENT
?UVAC_HT@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QAY01$$CBGA DW 00H ; `stbi_write_jpg_core'::`2'::UVAC_HT
	DW	02H
	DW	01H
	DW	02H
	DW	04H
	DW	03H
	DW	0aH
	DW	04H
	DW	018H
	DW	05H
	DW	019H
	DW	05H
	DW	038H
	DW	06H
	DW	078H
	DW	07H
	DW	01f4H
	DW	09H
	DW	03f6H
	DW	0aH
	DW	0ff4H
	DW	0cH
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0bH
	DW	04H
	DW	039H
	DW	06H
	DW	0f6H
	DW	08H
	DW	01f5H
	DW	09H
	DW	07f6H
	DW	0bH
	DW	0ff5H
	DW	0cH
	DW	0ff88H
	DW	010H
	DW	0ff89H
	DW	010H
	DW	0ff8aH
	DW	010H
	DW	0ff8bH
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01aH
	DW	05H
	DW	0f7H
	DW	08H
	DW	03f7H
	DW	0aH
	DW	0ff6H
	DW	0cH
	DW	07fc2H
	DW	0fH
	DW	0ff8cH
	DW	010H
	DW	0ff8dH
	DW	010H
	DW	0ff8eH
	DW	010H
	DW	0ff8fH
	DW	010H
	DW	0ff90H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01bH
	DW	05H
	DW	0f8H
	DW	08H
	DW	03f8H
	DW	0aH
	DW	0ff7H
	DW	0cH
	DW	0ff91H
	DW	010H
	DW	0ff92H
	DW	010H
	DW	0ff93H
	DW	010H
	DW	0ff94H
	DW	010H
	DW	0ff95H
	DW	010H
	DW	0ff96H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	03aH
	DW	06H
	DW	01f6H
	DW	09H
	DW	0ff97H
	DW	010H
	DW	0ff98H
	DW	010H
	DW	0ff99H
	DW	010H
	DW	0ff9aH
	DW	010H
	DW	0ff9bH
	DW	010H
	DW	0ff9cH
	DW	010H
	DW	0ff9dH
	DW	010H
	DW	0ff9eH
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	03bH
	DW	06H
	DW	03f9H
	DW	0aH
	DW	0ff9fH
	DW	010H
	DW	0ffa0H
	DW	010H
	DW	0ffa1H
	DW	010H
	DW	0ffa2H
	DW	010H
	DW	0ffa3H
	DW	010H
	DW	0ffa4H
	DW	010H
	DW	0ffa5H
	DW	010H
	DW	0ffa6H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	079H
	DW	07H
	DW	07f7H
	DW	0bH
	DW	0ffa7H
	DW	010H
	DW	0ffa8H
	DW	010H
	DW	0ffa9H
	DW	010H
	DW	0ffaaH
	DW	010H
	DW	0ffabH
	DW	010H
	DW	0ffacH
	DW	010H
	DW	0ffadH
	DW	010H
	DW	0ffaeH
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	07aH
	DW	07H
	DW	07f8H
	DW	0bH
	DW	0ffafH
	DW	010H
	DW	0ffb0H
	DW	010H
	DW	0ffb1H
	DW	010H
	DW	0ffb2H
	DW	010H
	DW	0ffb3H
	DW	010H
	DW	0ffb4H
	DW	010H
	DW	0ffb5H
	DW	010H
	DW	0ffb6H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0f9H
	DW	08H
	DW	0ffb7H
	DW	010H
	DW	0ffb8H
	DW	010H
	DW	0ffb9H
	DW	010H
	DW	0ffbaH
	DW	010H
	DW	0ffbbH
	DW	010H
	DW	0ffbcH
	DW	010H
	DW	0ffbdH
	DW	010H
	DW	0ffbeH
	DW	010H
	DW	0ffbfH
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01f7H
	DW	09H
	DW	0ffc0H
	DW	010H
	DW	0ffc1H
	DW	010H
	DW	0ffc2H
	DW	010H
	DW	0ffc3H
	DW	010H
	DW	0ffc4H
	DW	010H
	DW	0ffc5H
	DW	010H
	DW	0ffc6H
	DW	010H
	DW	0ffc7H
	DW	010H
	DW	0ffc8H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01f8H
	DW	09H
	DW	0ffc9H
	DW	010H
	DW	0ffcaH
	DW	010H
	DW	0ffcbH
	DW	010H
	DW	0ffccH
	DW	010H
	DW	0ffcdH
	DW	010H
	DW	0ffceH
	DW	010H
	DW	0ffcfH
	DW	010H
	DW	0ffd0H
	DW	010H
	DW	0ffd1H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01f9H
	DW	09H
	DW	0ffd2H
	DW	010H
	DW	0ffd3H
	DW	010H
	DW	0ffd4H
	DW	010H
	DW	0ffd5H
	DW	010H
	DW	0ffd6H
	DW	010H
	DW	0ffd7H
	DW	010H
	DW	0ffd8H
	DW	010H
	DW	0ffd9H
	DW	010H
	DW	0ffdaH
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01faH
	DW	09H
	DW	0ffdbH
	DW	010H
	DW	0ffdcH
	DW	010H
	DW	0ffddH
	DW	010H
	DW	0ffdeH
	DW	010H
	DW	0ffdfH
	DW	010H
	DW	0ffe0H
	DW	010H
	DW	0ffe1H
	DW	010H
	DW	0ffe2H
	DW	010H
	DW	0ffe3H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	07f9H
	DW	0bH
	DW	0ffe4H
	DW	010H
	DW	0ffe5H
	DW	010H
	DW	0ffe6H
	DW	010H
	DW	0ffe7H
	DW	010H
	DW	0ffe8H
	DW	010H
	DW	0ffe9H
	DW	010H
	DW	0ffeaH
	DW	010H
	DW	0ffebH
	DW	010H
	DW	0ffecH
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	03fe0H
	DW	0eH
	DW	0ffedH
	DW	010H
	DW	0ffeeH
	DW	010H
	DW	0ffefH
	DW	010H
	DW	0fff0H
	DW	010H
	DW	0fff1H
	DW	010H
	DW	0fff2H
	DW	010H
	DW	0fff3H
	DW	010H
	DW	0fff4H
	DW	010H
	DW	0fff5H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	03faH
	DW	0aH
	DW	07fc3H
	DW	0fH
	DW	0fff6H
	DW	010H
	DW	0fff7H
	DW	010H
	DW	0fff8H
	DW	010H
	DW	0fff9H
	DW	010H
	DW	0fffaH
	DW	010H
	DW	0fffbH
	DW	010H
	DW	0fffcH
	DW	010H
	DW	0fffdH
	DW	010H
	DW	0fffeH
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
CONST	ENDS
;	COMDAT ?UVDC_HT@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QAY01$$CBGA
CONST	SEGMENT
?UVDC_HT@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QAY01$$CBGA DW 00H ; `stbi_write_jpg_core'::`2'::UVDC_HT
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	06H
	DW	03H
	DW	0eH
	DW	04H
	DW	01eH
	DW	05H
	DW	03eH
	DW	06H
	DW	07eH
	DW	07H
	DW	0feH
	DW	08H
	DW	01feH
	DW	09H
	DW	03feH
	DW	0aH
	DW	07feH
	DW	0bH
	ORG $+976
CONST	ENDS
;	COMDAT ?lengthc@?1??stbi_zlib_compress@@9@4PAGA
CONST	SEGMENT
?lengthc@?1??stbi_zlib_compress@@9@4PAGA DW 03H		; `stbi_zlib_compress'::`2'::lengthc
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	0103H
CONST	ENDS
;	COMDAT ?std_dc_luminance_values@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB
CONST	SEGMENT
?std_dc_luminance_values@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB DB 00H ; `stbi_write_jpg_core'::`2'::std_dc_luminance_values
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
CONST	ENDS
;	COMDAT ?mul_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA
CONST	SEGMENT
?mul_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA DD 00H	; `stbi__shiftsigned'::`2'::mul_table
	DD	0ffH
	DD	055H
	DD	049H
	DD	011H
	DD	021H
	DD	041H
	DD	081H
	DD	01H
CONST	ENDS
;	COMDAT ?tag@?DG@??stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z@4QBEB
CONST	SEGMENT
?tag@?DG@??stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z@4QBEB DB 041H ; `stbi__process_marker'::`54'::tag
	DB	064H
	DB	06fH
	DB	062H
	DB	065H
	DB	00H
CONST	ENDS
;	COMDAT ?std_ac_luminance_nrcodes@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB
CONST	SEGMENT
?std_ac_luminance_nrcodes@?1??stbi_write_jpg_core@@YAHPEAUstbi__write_context@@HHHPEBXH@Z@4QBEB DB 00H ; `stbi_write_jpg_core'::`2'::std_ac_luminance_nrcodes
	DB	00H
	DB	02H
	DB	01H
	DB	03H
	DB	03H
	DB	02H
	DB	04H
	DB	03H
	DB	05H
	DB	05H
	DB	04H
	DB	04H
	DB	00H
	DB	00H
	DB	01H
	DB	07dH
CONST	ENDS
;	COMDAT ?invalid_chunk@?JM@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA
_DATA	SEGMENT
?invalid_chunk@?JM@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA DB 'X'
	DB	'XXX PNG chunk not known', 00H		; `stbi__parse_png_file'::`156'::invalid_chunk
_DATA	ENDS
;	COMDAT ?tag@?CN@??stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z@4QBEB
CONST	SEGMENT
?tag@?CN@??stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z@4QBEB DB 04aH ; `stbi__process_marker'::`45'::tag
	DB	046H
	DB	049H
	DB	046H
	DB	00H
CONST	ENDS
;	COMDAT ??_C@_0DB@NJMBBANC@EXPOSURE?$DN?5?5?5?5?5?5?5?5?5?51?40000000000@
CONST	SEGMENT
??_C@_0DB@NJMBBANC@EXPOSURE?$DN?5?5?5?5?5?5?5?5?5?51?40000000000@ DB 'EXP'
	DB	'OSURE=          1.0000000000000', 0aH, 0aH, '-Y %d +X %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@HFFFEKFH@?$CD?$DPRADIANCE?6?$CD?5Written?5by?5stb_ima@
CONST	SEGMENT
??_C@_0EC@HFFFEKFH@?$CD?$DPRADIANCE?6?$CD?5Written?5by?5stb_ima@ DB '#?RA'
	DB	'DIANCE', 0aH, '# Written by stb_image_write.h', 0aH, 'FORMAT='
	DB	'32-bit_rle_rgbe', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BIJKEPCF@111?5221?52222?511@
CONST	SEGMENT
??_C@_0BA@BIJKEPCF@111?5221?52222?511@ DB '111 221 2222 11', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@CIFMJOPF@11?54?522?544?544?522?5444444?54444?54?5@
CONST	SEGMENT
??_C@_0CP@CIFMJOPF@11?54?522?544?544?522?5444444?54444?54?5@ DB '11 4 22 '
	DB	'44 44 22 444444 4444 4 444 444 444 444', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04COOFLABO@IEND@
CONST	SEGMENT
??_C@_04COOFLABO@IEND@ DB 'IEND', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NHMHICBH@IDAT@
CONST	SEGMENT
??_C@_04NHMHICBH@IDAT@ DB 'IDAT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MNIAFIMC@IHDR@
CONST	SEGMENT
??_C@_04MNIAFIMC@IHDR@ DB 'IHDR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JBEOCDFN@invalid?5decoded?5scanline?5length@
CONST	SEGMENT
??_C@_0CA@JBEOCDFN@invalid?5decoded?5scanline?5length@ DB 'invalid decode'
	DB	'd scanline length', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FOKDFDHG@?$CLX?5@
CONST	SEGMENT
??_C@_03FOKDFDHG@?$CLX?5@ DB '+X ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@
CONST	SEGMENT
??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@ DB 'unsupported data layout'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03HKAKGGJN@?9Y?5@
CONST	SEGMENT
??_C@_03HKAKGGJN@?9Y?5@ DB '-Y ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JMCBNFKL@11?54?522?544?544?522?5444444@
CONST	SEGMENT
??_C@_0BI@JMCBNFKL@11?54?522?544?544?522?5444444@ DB '11 4 22 44 44 22 44'
	DB	'4444', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CNFMOKHC@max?5value?5?$DO?565535@
CONST	SEGMENT
??_C@_0BC@CNFMOKHC@max?5value?5?$DO?565535@ DB 'max value > 65535', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OBINMOBC@integer?5parse?5overflow@
CONST	SEGMENT
??_C@_0BH@OBINMOBC@integer?5parse?5overflow@ DB 'integer parse overflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IDKIDMGJ@bad?5PNM@
CONST	SEGMENT
??_C@_07IDKIDMGJ@bad?5PNM@ DB 'bad PNM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@
CONST	SEGMENT
??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@ DB '#?RADIANCE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KFDJIKCK@?$CD?$DPRGBE?6@
CONST	SEGMENT
??_C@_07KFDJIKCK@?$CD?$DPRGBE?6@ DB '#?RGBE', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@
CONST	SEGMENT
??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@ DB '#?RADIANCE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DJABBOOH@unknown?5code@
CONST	SEGMENT
??_C@_0N@DJABBOOH@unknown?5code@ DB 'unknown code', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NKJFFLKL@unsupported?5format@
CONST	SEGMENT
??_C@_0BD@NKJFFLKL@unsupported?5format@ DB 'unsupported format', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@
CONST	SEGMENT
??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@ DB 'FORMAT=32-bit_rle_rgbe'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07NCIOKENI@not?5HDR@
CONST	SEGMENT
??_C@_07NCIOKENI@not?5HDR@ DB 'not HDR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NDOKKIDJ@?$CD?$DPRGBE@
CONST	SEGMENT
??_C@_06NDOKKIDJ@?$CD?$DPRGBE@ DB '#?RGBE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MGDACKOJ@no?5clear?5code@
CONST	SEGMENT
??_C@_0O@MGDACKOJ@no?5clear?5code@ DB 'no clear code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KMJLPAII@not?5GIF@
CONST	SEGMENT
??_C@_07KMJLPAII@not?5GIF@ DB 'not GIF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GGMBIFE@bad?5file@
CONST	SEGMENT
??_C@_08GGMBIFE@bad?5file@ DB 'bad file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04ELNJHLFH@PICT@
CONST	SEGMENT
??_C@_04ELNJHLFH@PICT@ DB 'PICT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NAMJKDNF@missing?5color?5table@
CONST	SEGMENT
??_C@_0BE@NAMJKDNF@missing?5color?5table@ DB 'missing color table', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GIAALCNJ@bad?5Image?5Descriptor@
CONST	SEGMENT
??_C@_0BF@GIAALCNJ@bad?5Image?5Descriptor@ DB 'bad Image Descriptor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@
CONST	SEGMENT
??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@ DB 'illegal code in raster', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GJNJCPDJ@too?5many?5codes@
CONST	SEGMENT
??_C@_0P@GJNJCPDJ@too?5many?5codes@ DB 'too many codes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PJBNGDBE@wrong?5channel?5count@
CONST	SEGMENT
??_C@_0BE@PJBNGDBE@wrong?5channel?5count@ DB 'wrong channel count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CHBCDKKC@wrong?5version@
CONST	SEGMENT
??_C@_0O@CHBCDKKC@wrong?5version@ DB 'wrong version', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07ECNCNLIK@not?5PSD@
CONST	SEGMENT
??_C@_07ECNCNLIK@not?5PSD@ DB 'not PSD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ILLOCNCO@bad?5palette@
CONST	SEGMENT
??_C@_0M@ILLOCNCO@bad?5palette@ DB 'bad palette', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04KBFEPHFH@S?$IA?v4@
CONST	SEGMENT
??_C@_04KBFEPHFH@S?$IA?v4@ DB 'S', 080H, 0f6H, '4', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DPPMCAKL@corrupt@
CONST	SEGMENT
??_C@_07DPPMCAKL@corrupt@ DB 'corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IOGGBMNK@wrong?5color?5format@
CONST	SEGMENT
??_C@_0BD@IOGGBMNK@wrong?5color?5format@ DB 'wrong color format', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NOLDLPP@unsupported?5bit?5depth@
CONST	SEGMENT
??_C@_0BG@NOLDLPP@unsupported?5bit?5depth@ DB 'unsupported bit depth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JDPIFELH@bad?5offset@
CONST	SEGMENT
??_C@_0L@JDPIFELH@bad?5offset@ DB 'bad offset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PJHPAMCH@bad?5header@
CONST	SEGMENT
??_C@_0L@PJHPAMCH@bad?5header@ DB 'bad header', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ODCBCBFN@BMP?5JPEG?1PNG@
CONST	SEGMENT
??_C@_0N@ODCBCBFN@BMP?5JPEG?1PNG@ DB 'BMP JPEG/PNG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IMHMNOIB@BMP?5RLE@
CONST	SEGMENT
??_C@_07IMHMNOIB@BMP?5RLE@ DB 'BMP RLE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DMAPJJO@bad?5format@
CONST	SEGMENT
??_C@_0L@DMAPJJO@bad?5format@ DB 'bad format', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DAEBACAB@bad?5masks@
CONST	SEGMENT
??_C@_09DAEBACAB@bad?5masks@ DB 'bad masks', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JNJHIMGH@bad?5bpp@
CONST	SEGMENT
??_C@_07JNJHIMGH@bad?5bpp@ DB 'bad bpp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MALOAKCI@invalid@
CONST	SEGMENT
??_C@_07MALOAKCI@invalid@ DB 'invalid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MLPECBNA@no?5IDAT@
CONST	SEGMENT
??_C@_07MLPECBNA@no?5IDAT@ DB 'no IDAT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MNNCNKEO@outofdata@
CONST	SEGMENT
??_C@_09MNNCNKEO@outofdata@ DB 'outofdata', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PLHGLONG@IDAT?5size?5limit@
CONST	SEGMENT
??_C@_0BA@PLHGLONG@IDAT?5size?5limit@ DB 'IDAT size limit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CKIELOEH@no?5PLTE@
CONST	SEGMENT
??_C@_07CKIELOEH@no?5PLTE@ DB 'no PLTE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KHBIBJBG@unknown?5BMP@
CONST	SEGMENT
??_C@_0M@KHBIBJBG@unknown?5BMP@ DB 'unknown BMP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IEJCHBDI@bad?5BMP@
CONST	SEGMENT
??_C@_07IEJCHBDI@bad?5BMP@ DB 'bad BMP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IANEBNLB@not?5BMP@
CONST	SEGMENT
??_C@_07IANEBNLB@not?5BMP@ DB 'not BMP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NOEEEFMF@bad?5bits_per_channel@
CONST	SEGMENT
??_C@_0BF@NOEEEFMF@bad?5bits_per_channel@ DB 'bad bits_per_channel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JCPAJAKB@invalid?5PLTE@
CONST	SEGMENT
??_C@_0N@JCPAJAKB@invalid?5PLTE@ DB 'invalid PLTE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JEAFOMAF@first?5not?5IHDR@
CONST	SEGMENT
??_C@_0P@JEAFOMAF@first?5not?5IHDR@ DB 'first not IHDR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FNFBHCOO@0?9pixel?5image@
CONST	SEGMENT
??_C@_0O@FNFBHCOO@0?9pixel?5image@ DB '0-pixel image', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JCGDPBAA@bad?5interlace?5method@
CONST	SEGMENT
??_C@_0BF@JCGDPBAA@bad?5interlace?5method@ DB 'bad interlace method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha@
CONST	SEGMENT
??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha@ DB 'tRNS with alpha', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KDLCCKCH@bad?5tRNS?5len@
CONST	SEGMENT
??_C@_0N@KDLCCKCH@bad?5tRNS?5len@ DB 'bad tRNS len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE@
CONST	SEGMENT
??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE@ DB 'tRNS before PLTE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT@
CONST	SEGMENT
??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT@ DB 'tRNS after IDAT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@POJLKMKK@bad?5IHDR?5len@
CONST	SEGMENT
??_C@_0N@POJLKMKK@bad?5IHDR?5len@ DB 'bad IHDR len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KBHBNJOK@multiple?5IHDR@
CONST	SEGMENT
??_C@_0O@KBHBNJOK@multiple?5IHDR@ DB 'multiple IHDR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MKGNGALN@invalid?5width@
CONST	SEGMENT
??_C@_0O@MKGNGALN@invalid?5width@ DB 'invalid width', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FBBCPGMN@invalid?5filter@
CONST	SEGMENT
??_C@_0P@FBBCPGMN@invalid?5filter@ DB 'invalid filter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GHLIKKMD@bad?5filter?5method@
CONST	SEGMENT
??_C@_0BC@GHLIKKMD@bad?5filter?5method@ DB 'bad filter method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MDMBDDFG@bad?5comp?5method@
CONST	SEGMENT
??_C@_0BA@MDMBDDFG@bad?5comp?5method@ DB 'bad comp method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MBBNGCKB@bad?5ctype@
CONST	SEGMENT
??_C@_09MBBNGCKB@bad?5ctype@ DB 'bad ctype', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only@
CONST	SEGMENT
??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only@ DB '1/2/4/8/16-bit only', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OBKOPAFL@bad?5zlib?5header@
CONST	SEGMENT
??_C@_0BA@OBKOPAFL@bad?5zlib?5header@ DB 'bad zlib header', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PIPBCKIA@read?5past?5buffer@
CONST	SEGMENT
??_C@_0BB@PIPBCKIA@read?5past?5buffer@ DB 'read past buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IECDHMDI@zlib?5corrupt@
CONST	SEGMENT
??_C@_0N@IECDHMDI@zlib?5corrupt@ DB 'zlib corrupt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DIAPIMGJ@bad?5dist@
CONST	SEGMENT
??_C@_08DIAPIMGJ@bad?5dist@ DB 'bad dist', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BHMPBBMG@not?5enough?5pixels@
CONST	SEGMENT
??_C@_0BC@BHMPBBMG@not?5enough?5pixels@ DB 'not enough pixels', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DMDNBACF@bad?5png?5sig@
CONST	SEGMENT
??_C@_0M@DMDNBACF@bad?5png?5sig@ DB 'bad png sig', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MCNBDLPD@bad?5compression@
CONST	SEGMENT
??_C@_0BA@MCNBDLPD@bad?5compression@ DB 'bad compression', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DOGMHEBI@no?5preset?5dict@
CONST	SEGMENT
??_C@_0P@DOGMHEBI@no?5preset?5dict@ DB 'no preset dict', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PNCLKCLJ@bad?5DNL?5height@
CONST	SEGMENT
??_C@_0P@PNCLKCLJ@bad?5DNL?5height@ DB 'bad DNL height', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EPMOIECP@bad?5DNL?5len@
CONST	SEGMENT
??_C@_0M@EPMOIECP@bad?5DNL?5len@ DB 'bad DNL len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IFCEAHIA@no?5SOF@
CONST	SEGMENT
??_C@_06IFCEAHIA@no?5SOF@ DB 'no SOF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CLMBLEP@no?5SOI@
CONST	SEGMENT
??_C@_06CLMBLEP@no?5SOI@ DB 'no SOI', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IBFIPFO@output?5buffer?5limit@
CONST	SEGMENT
??_C@_0BE@IBFIPFO@output?5buffer?5limit@ DB 'output buffer limit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MDNKOBMC@bad?5codelengths@
CONST	SEGMENT
??_C@_0BA@MDNKOBMC@bad?5codelengths@ DB 'bad codelengths', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EOHLEIKL@bad?5sizes@
CONST	SEGMENT
??_C@_09EOHLEIKL@bad?5sizes@ DB 'bad sizes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KBPNPPBJ@bad?5req_comp@
CONST	SEGMENT
??_C@_0N@KBPNPPBJ@bad?5req_comp@ DB 'bad req_comp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OJDLMMBJ@too?5large@
CONST	SEGMENT
??_C@_09OJDLMMBJ@too?5large@ DB 'too large', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07BIDACDEF@0?5width@
CONST	SEGMENT
??_C@_07BIDACDEF@0?5width@ DB '0 width', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LNEGOMA@no?5header?5height@
CONST	SEGMENT
??_C@_0BB@LNEGOMA@no?5header?5height@ DB 'no header height', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BCINMEBJ@only?58?9bit@
CONST	SEGMENT
??_C@_0L@BCINMEBJ@only?58?9bit@ DB 'only 8-bit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LJIHDFHI@bad?5TQ@
CONST	SEGMENT
??_C@_06LJIHDFHI@bad?5TQ@ DB 'bad TQ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MPLLHCJG@bad?5V@
CONST	SEGMENT
??_C@_05MPLLHCJG@bad?5V@ DB 'bad V', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BLPKENEJ@bad?5H@
CONST	SEGMENT
??_C@_05BLPKENEJ@bad?5H@ DB 'bad H', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DAPHADHL@bad?5component?5count@
CONST	SEGMENT
??_C@_0BE@DAPHADHL@bad?5component?5count@ DB 'bad component count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GNEHAHOH@bad?5SOS?5len@
CONST	SEGMENT
??_C@_0M@GNEHAHOH@bad?5SOS?5len@ DB 'bad SOS len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count@
CONST	SEGMENT
??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count@ DB 'bad SOS component coun'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NNGPHMMK@unknown?5marker@
CONST	SEGMENT
??_C@_0P@NNGPHMMK@unknown?5marker@ DB 'unknown marker', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EENLKPDI@bad?5APP?5len@
CONST	SEGMENT
??_C@_0M@EENLKPDI@bad?5APP?5len@ DB 'bad APP len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DOFMJEMP@bad?5SOF?5len@
CONST	SEGMENT
??_C@_0M@DOFMJEMP@bad?5SOF?5len@ DB 'bad SOF len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07EEJOMGGP@bad?5SOS@
CONST	SEGMENT
??_C@_07EEJOMGGP@bad?5SOS@ DB 'bad SOS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JGMCBLGG@bad?5AC?5huff@
CONST	SEGMENT
??_C@_0M@JGMCBLGG@bad?5AC?5huff@ DB 'bad AC huff', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NOCCBFAC@bad?5DC?5huff@
CONST	SEGMENT
??_C@_0M@NOCCBFAC@bad?5DC?5huff@ DB 'bad DC huff', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LPHNODCG@bad?5DRI?5len@
CONST	SEGMENT
??_C@_0M@LPHNODCG@bad?5DRI?5len@ DB 'bad DRI len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KLNDOKJD@expected?5marker@
CONST	SEGMENT
??_C@_0BA@KLNDOKJD@expected?5marker@ DB 'expected marker', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
CONST	SEGMENT
??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@ DB 'can''t merge dc and ac'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09IFDKCGFO@bad?5delta@
CONST	SEGMENT
??_C@_09IFDKCGFO@bad?5delta@ DB 'bad delta', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CICAFFCH@bad?5COM?5len@
CONST	SEGMENT
??_C@_0M@CICAFFCH@bad?5COM?5len@ DB 'bad COM len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JLGKOCGN@bad?5DHT?5header@
CONST	SEGMENT
??_C@_0P@JLGKOCGN@bad?5DHT?5header@ DB 'bad DHT header', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CNHKKDIM@bad?5DQT?5table@
CONST	SEGMENT
??_C@_0O@CNHKKDIM@bad?5DQT?5table@ DB 'bad DQT table', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BOFJCHAP@bad?5DQT?5type@
CONST	SEGMENT
??_C@_0N@BOFJCHAP@bad?5DQT?5type@ DB 'bad DQT type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JPDHFAGK@can?8t?5fopen@
CONST	SEGMENT
??_C@_0M@JPDHFAGK@can?8t?5fopen@ DB 'can''t fopen', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NOGIMCHF@outofmem@
CONST	SEGMENT
??_C@_08NOGIMCHF@outofmem@ DB 'outofmem', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CBEDEJPH@unknown?5image?5type@
CONST	SEGMENT
??_C@_0BD@CBEDEJPH@unknown?5image?5type@ DB 'unknown image type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IIMLINA@bad?5huffman?5code@
CONST	SEGMENT
??_C@_0BB@IIMLINA@bad?5huffman?5code@ DB 'bad huffman code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FOKGPEKG@bad?5code?5lengths@
CONST	SEGMENT
??_C@_0BB@FOKGPEKG@bad?5code?5lengths@ DB 'bad code lengths', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DEFOLMLB@bad?5size?5list@
CONST	SEGMENT
??_C@_0O@DEFOLMLB@bad?5size?5list@ DB 'bad size list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MHDBFHD@unsupported@
CONST	SEGMENT
??_C@_0M@MHDBFHD@unsupported@ DB 'unsupported', 00H	; `string'
stbi_write_tga_with_rle DD 01H
stbi_write_force_png_filter DD 0ffffffffH
stbi_write_png_compression_level DD 08H
?stbi__h2l_gamma_i@@3MA DD 03ee8ba2er		; 0.454545 ; stbi__h2l_gamma_i
	ORG $+4
?stbi__jbias@@3QBHB DD 00H				; stbi__jbias
	DD	0ffffffffH
	DD	0fffffffdH
	DD	0fffffff9H
	DD	0fffffff1H
	DD	0ffffffe1H
	DD	0ffffffc1H
	DD	0ffffff81H
	DD	0ffffff01H
	DD	0fffffe01H
	DD	0fffffc01H
	DD	0fffff801H
	DD	0fffff001H
	DD	0ffffe001H
	DD	0ffffc001H
	DD	0ffff8001H
?stbi__zdefault_length@@3QBEB DB 08H			; stbi__zdefault_length
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
?stbi__jpeg_dezigzag@@3QBEB DB 00H			; stbi__jpeg_dezigzag
	DB	01H
	DB	08H
	DB	010H
	DB	09H
	DB	02H
	DB	03H
	DB	0aH
	DB	011H
	DB	018H
	DB	020H
	DB	019H
	DB	012H
	DB	0bH
	DB	04H
	DB	05H
	DB	0cH
	DB	013H
	DB	01aH
	DB	021H
	DB	028H
	DB	030H
	DB	029H
	DB	022H
	DB	01bH
	DB	014H
	DB	0dH
	DB	06H
	DB	07H
	DB	0eH
	DB	015H
	DB	01cH
	DB	023H
	DB	02aH
	DB	031H
	DB	038H
	DB	039H
	DB	032H
	DB	02bH
	DB	024H
	DB	01dH
	DB	016H
	DB	0fH
	DB	017H
	DB	01eH
	DB	025H
	DB	02cH
	DB	033H
	DB	03aH
	DB	03bH
	DB	034H
	DB	02dH
	DB	026H
	DB	01fH
	DB	027H
	DB	02eH
	DB	035H
	DB	03cH
	DB	03dH
	DB	036H
	DB	02fH
	DB	037H
	DB	03eH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	ORG $+1
?stbi__zdist_base@@3QBHB DD 01H				; stbi__zdist_base
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	07H
	DD	09H
	DD	0dH
	DD	011H
	DD	019H
	DD	021H
	DD	031H
	DD	041H
	DD	061H
	DD	081H
	DD	0c1H
	DD	0101H
	DD	0181H
	DD	0201H
	DD	0301H
	DD	0401H
	DD	0601H
	DD	0801H
	DD	0c01H
	DD	01001H
	DD	01801H
	DD	02001H
	DD	03001H
	DD	04001H
	DD	06001H
	DD	00H
	DD	00H
?stbi__bmask@@3QBIB DD 00H				; stbi__bmask
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	01ffH
	DD	03ffH
	DD	07ffH
	DD	0fffH
	DD	01fffH
	DD	03fffH
	DD	07fffH
	DD	0ffffH
?stbi__h2l_scale_i@@3MA DD 03f800000r		; 1	; stbi__h2l_scale_i
	ORG $+4
?stbi__zlength_base@@3QBHB DD 03H			; stbi__zlength_base
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0dH
	DD	0fH
	DD	011H
	DD	013H
	DD	017H
	DD	01bH
	DD	01fH
	DD	023H
	DD	02bH
	DD	033H
	DD	03bH
	DD	043H
	DD	053H
	DD	063H
	DD	073H
	DD	083H
	DD	0a3H
	DD	0c3H
	DD	0e3H
	DD	0102H
	DD	00H
	DD	00H
	ORG $+4
?stbi__zlength_extra@@3QBHB DD 00H			; stbi__zlength_extra
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
?stbiw__jpg_ZigZag@@3QBEB DB 00H			; stbiw__jpg_ZigZag
	DB	01H
	DB	05H
	DB	06H
	DB	0eH
	DB	0fH
	DB	01bH
	DB	01cH
	DB	02H
	DB	04H
	DB	07H
	DB	0dH
	DB	010H
	DB	01aH
	DB	01dH
	DB	02aH
	DB	03H
	DB	08H
	DB	0cH
	DB	011H
	DB	019H
	DB	01eH
	DB	029H
	DB	02bH
	DB	09H
	DB	0bH
	DB	012H
	DB	018H
	DB	01fH
	DB	028H
	DB	02cH
	DB	035H
	DB	0aH
	DB	013H
	DB	017H
	DB	020H
	DB	027H
	DB	02dH
	DB	034H
	DB	036H
	DB	014H
	DB	016H
	DB	021H
	DB	026H
	DB	02eH
	DB	033H
	DB	037H
	DB	03cH
	DB	015H
	DB	022H
	DB	025H
	DB	02fH
	DB	032H
	DB	038H
	DB	03bH
	DB	03dH
	DB	023H
	DB	024H
	DB	030H
	DB	031H
	DB	039H
	DB	03aH
	DB	03eH
	DB	03fH
?first_row_filter@@3PAEA DB 00H				; first_row_filter
	DB	01H
	DB	00H
	DB	05H
	DB	06H
	ORG $+11
?stbi__zdefault_distance@@3QBEB DB 05H			; stbi__zdefault_distance
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
?stbi__depth_scale_table@@3QBEB DB 00H			; stbi__depth_scale_table
	DB	0ffH
	DB	055H
	DB	00H
	DB	011H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	ORG $+7
?stbi__zdist_extra@@3QBHB DD 00H			; stbi__zdist_extra
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
	ORG $+8
PUBLIC	stbi_write_png_to_mem
PUBLIC	stbi_zlib_compress
PUBLIC	stbi_zlib_decode_malloc_guesssize_headerflag
PUBLIC	stbi_load_from_memory
PUBLIC	stbi_load_from_file
PUBLIC	stbi_load
PUBLIC	stbi_image_free
PUBLIC	stbi_write_png_to_mem_forward
?stbi__vertically_flip_on_load_local@@3HA DD 01H DUP (?) ; stbi__vertically_flip_on_load_local
	ALIGN	8

?stbi__g_failure_reason@@3PEBDEB DQ 01H DUP (?)		; stbi__g_failure_reason
?stbi__unpremultiply_on_load_set@@3HA DD 01H DUP (?)	; stbi__unpremultiply_on_load_set
?stbi__de_iphone_flag_local@@3HA DD 01H DUP (?)		; stbi__de_iphone_flag_local
?stbi__de_iphone_flag_set@@3HA DD 01H DUP (?)		; stbi__de_iphone_flag_set
?stbi__unpremultiply_on_load_local@@3HA DD 01H DUP (?)	; stbi__unpremultiply_on_load_local
?stbi__vertically_flip_on_load_set@@3HA DD 01H DUP (?)	; stbi__vertically_flip_on_load_set
_TLS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_write_png_to_mem DD imagerel $LN121
	DD	imagerel $LN121+243
	DD	imagerel $unwind$stbi_write_png_to_mem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$stbi_write_png_to_mem DD imagerel $LN121+243
	DD	imagerel $LN121+774
	DD	imagerel $chain$1$stbi_write_png_to_mem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$stbi_write_png_to_mem DD imagerel $LN121+774
	DD	imagerel $LN121+1517
	DD	imagerel $chain$2$stbi_write_png_to_mem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z DD imagerel ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z
	DD	imagerel ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z+129
	DD	imagerel $unwind$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z DD imagerel ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z+129
	DD	imagerel ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z+148
	DD	imagerel $chain$1$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z DD imagerel ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z+148
	DD	imagerel ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z+301
	DD	imagerel $chain$4$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z DD imagerel ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z+301
	DD	imagerel ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z+788
	DD	imagerel $chain$5$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z DD imagerel ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z+788
	DD	imagerel ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z+836
	DD	imagerel $chain$6$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbiw__paeth@@YAEHHH@Z DD imagerel ?stbiw__paeth@@YAEHHH@Z
	DD	imagerel ?stbiw__paeth@@YAEHHH@Z+117
	DD	imagerel $unwind$?stbiw__paeth@@YAEHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbiw__crc32@@YAIPEAEH@Z DD imagerel ?stbiw__crc32@@YAIPEAEH@Z
	DD	imagerel ?stbiw__crc32@@YAIPEAEH@Z+16
	DD	imagerel $unwind$?stbiw__crc32@@YAIPEAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbiw__crc32@@YAIPEAEH@Z DD imagerel ?stbiw__crc32@@YAIPEAEH@Z+16
	DD	imagerel ?stbiw__crc32@@YAIPEAEH@Z+63
	DD	imagerel $chain$0$?stbiw__crc32@@YAIPEAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbiw__crc32@@YAIPEAEH@Z DD imagerel ?stbiw__crc32@@YAIPEAEH@Z+63
	DD	imagerel ?stbiw__crc32@@YAIPEAEH@Z+70
	DD	imagerel $chain$1$?stbiw__crc32@@YAIPEAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_zlib_compress DD imagerel $LN898
	DD	imagerel $LN898+84
	DD	imagerel $unwind$stbi_zlib_compress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$stbi_zlib_compress DD imagerel $LN898+84
	DD	imagerel $LN898+4533
	DD	imagerel $chain$3$stbi_zlib_compress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$stbi_zlib_compress DD imagerel $LN898+4533
	DD	imagerel $LN898+4862
	DD	imagerel $chain$4$stbi_zlib_compress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z DD imagerel ?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z
	DD	imagerel ?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z+28
	DD	imagerel $unwind$?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z DD imagerel ?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z+28
	DD	imagerel ?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z+190
	DD	imagerel $chain$3$?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z DD imagerel ?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z+190
	DD	imagerel ?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z+202
	DD	imagerel $chain$4$?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbiw__sbgrowf@@YAPEAXPEAPEAXHH@Z DD imagerel ?stbiw__sbgrowf@@YAPEAXPEAPEAXHH@Z
	DD	imagerel ?stbiw__sbgrowf@@YAPEAXPEAPEAXHH@Z+130
	DD	imagerel $unwind$?stbiw__sbgrowf@@YAPEAXPEAPEAXHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z+582
	DD	imagerel $unwind$?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z DD imagerel ?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z
	DD	imagerel ?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z+289
	DD	imagerel $unwind$?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z DD imagerel ?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z
	DD	imagerel ?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z+440
	DD	imagerel $unwind$?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+403
	DD	imagerel $unwind$?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__pnm_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__pnm_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__pnm_test@@YAHPEAUstbi__context@@@Z+225
	DD	imagerel $unwind$?stbi__pnm_test@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+437
	DD	imagerel $unwind$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+437
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+594
	DD	imagerel $chain$0$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+594
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+1613
	DD	imagerel $chain$1$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+1613
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+1621
	DD	imagerel $chain$2$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+1621
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+1653
	DD	imagerel $chain$3$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+1653
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+1956
	DD	imagerel $chain$4$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+1956
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+1991
	DD	imagerel $chain$5$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+1991
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+2026
	DD	imagerel $chain$6$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__hdr_convert@@YAXPEAMPEAEH@Z DD imagerel ?stbi__hdr_convert@@YAXPEAMPEAEH@Z
	DD	imagerel ?stbi__hdr_convert@@YAXPEAMPEAEH@Z+302
	DD	imagerel $unwind$?stbi__hdr_convert@@YAXPEAMPEAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z DD imagerel ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z
	DD	imagerel ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z+419
	DD	imagerel $unwind$?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__hdr_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z+211
	DD	imagerel $unwind$?stbi__hdr_test@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z DD imagerel ?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z
	DD	imagerel ?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z+178
	DD	imagerel $unwind$?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+196
	DD	imagerel $unwind$?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z DD imagerel ?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z
	DD	imagerel ?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z+1766
	DD	imagerel $unwind$?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z DD imagerel ?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z
	DD	imagerel ?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z+1160
	DD	imagerel $unwind$?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z DD imagerel ?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z
	DD	imagerel ?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z+279
	DD	imagerel $unwind$?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z DD imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
	DD	imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z+392
	DD	imagerel $unwind$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z DD imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z+392
	DD	imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z+739
	DD	imagerel $chain$0$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z DD imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z+739
	DD	imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z+761
	DD	imagerel $chain$1$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z DD imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z+761
	DD	imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z+775
	DD	imagerel $chain$2$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z DD imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z+775
	DD	imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z+807
	DD	imagerel $chain$3$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z DD imagerel ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z
	DD	imagerel ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z+31
	DD	imagerel $unwind$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z DD imagerel ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z+31
	DD	imagerel ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z+334
	DD	imagerel $chain$0$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z DD imagerel ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z+334
	DD	imagerel ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z+335
	DD	imagerel $chain$1$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__gif_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__gif_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__gif_test@@YAHPEAUstbi__context@@@Z+48
	DD	imagerel $unwind$?stbi__gif_test@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z+367
	DD	imagerel $unwind$?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__pic_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__pic_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__pic_test@@YAHPEAUstbi__context@@@Z+30
	DD	imagerel $unwind$?stbi__pic_test@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbi__pic_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__pic_test@@YAHPEAUstbi__context@@@Z+30
	DD	imagerel ?stbi__pic_test@@YAHPEAUstbi__context@@@Z+127
	DD	imagerel $chain$0$?stbi__pic_test@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbi__pic_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__pic_test@@YAHPEAUstbi__context@@@Z+127
	DD	imagerel ?stbi__pic_test@@YAHPEAUstbi__context@@@Z+174
	DD	imagerel $chain$1$?stbi__pic_test@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+321
	DD	imagerel $unwind$?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+321
	DD	imagerel ?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+544
	DD	imagerel $chain$1$?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+544
	DD	imagerel ?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+571
	DD	imagerel $chain$2$?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z DD imagerel ?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z
	DD	imagerel ?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z+1527
	DD	imagerel $unwind$?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z DD imagerel ?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z
	DD	imagerel ?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z+265
	DD	imagerel $unwind$?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z+25
	DD	imagerel $unwind$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z+25
	DD	imagerel ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z+138
	DD	imagerel $chain$0$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z+138
	DD	imagerel ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z+146
	DD	imagerel $chain$1$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z DD imagerel ?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z
	DD	imagerel ?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z+154
	DD	imagerel $unwind$?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+143
	DD	imagerel $unwind$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+143
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+588
	DD	imagerel $chain$2$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+588
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+669
	DD	imagerel $chain$4$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+669
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+826
	DD	imagerel $chain$5$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+826
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+836
	DD	imagerel $chain$6$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+836
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+858
	DD	imagerel $chain$7$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+858
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+2682
	DD	imagerel $chain$9$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+2682
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+2717
	DD	imagerel $chain$10$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+2717
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+2759
	DD	imagerel $chain$11$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z DD imagerel ?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z
	DD	imagerel ?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z+418
	DD	imagerel $unwind$?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__psd_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__psd_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__psd_test@@YAHPEAUstbi__context@@@Z+84
	DD	imagerel $unwind$?stbi__psd_test@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+2438
	DD	imagerel $unwind$?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z DD imagerel ?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z
	DD	imagerel ?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z+130
	DD	imagerel $unwind$?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__tga_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__tga_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__tga_test@@YAHPEAUstbi__context@@@Z+156
	DD	imagerel $unwind$?stbi__tga_test@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__tga_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__tga_test@@YAHPEAUstbi__context@@@Z+156
	DD	imagerel ?stbi__tga_test@@YAHPEAUstbi__context@@@Z+643
	DD	imagerel $chain$2$?stbi__tga_test@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbi__tga_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__tga_test@@YAHPEAUstbi__context@@@Z+643
	DD	imagerel ?stbi__tga_test@@YAHPEAUstbi__context@@@Z+693
	DD	imagerel $chain$3$?stbi__tga_test@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+175
	DD	imagerel $unwind$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+175
	DD	imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+508
	DD	imagerel $chain$2$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+508
	DD	imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+1959
	DD	imagerel $chain$3$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+1959
	DD	imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+1997
	DD	imagerel $chain$4$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+1997
	DD	imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+4001
	DD	imagerel $chain$6$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+4001
	DD	imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+4106
	DD	imagerel $chain$7$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z DD imagerel ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z
	DD	imagerel ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z+140
	DD	imagerel $unwind$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z DD imagerel ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z+140
	DD	imagerel ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z+336
	DD	imagerel $chain$0$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z DD imagerel ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z+336
	DD	imagerel ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z+891
	DD	imagerel $chain$2$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z DD imagerel ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z+891
	DD	imagerel ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z+937
	DD	imagerel $chain$3$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__bmp_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__bmp_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__bmp_test@@YAHPEAUstbi__context@@@Z+275
	DD	imagerel $unwind$?stbi__bmp_test@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z+256
	DD	imagerel $unwind$?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__png_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__png_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__png_test@@YAHPEAUstbi__context@@@Z+48
	DD	imagerel $unwind$?stbi__png_test@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+325
	DD	imagerel $unwind$?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z+290
	DD	imagerel $unwind$?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z DD imagerel ?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z
	DD	imagerel ?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z+3562
	DD	imagerel $unwind$?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z DD imagerel ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z
	DD	imagerel ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z+130
	DD	imagerel $unwind$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z DD imagerel ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z+130
	DD	imagerel ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z+252
	DD	imagerel $chain$0$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z DD imagerel ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z+252
	DD	imagerel ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z+283
	DD	imagerel $chain$1$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z DD imagerel ?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z
	DD	imagerel ?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z+300
	DD	imagerel $unwind$?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z DD imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+139
	DD	imagerel $unwind$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z DD imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+139
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+247
	DD	imagerel $chain$0$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z DD imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+247
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+1003
	DD	imagerel $chain$2$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z DD imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+1003
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+1026
	DD	imagerel $chain$3$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z DD imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+1026
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+1041
	DD	imagerel $chain$5$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z DD imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+1041
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+1073
	DD	imagerel $chain$6$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z DD imagerel ?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z
	DD	imagerel ?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z+4496
	DD	imagerel $unwind$?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__paeth@@YAHHHH@Z DD imagerel ?stbi__paeth@@YAHHHH@Z
	DD	imagerel ?stbi__paeth@@YAHHHH@Z+103
	DD	imagerel $unwind$?stbi__paeth@@YAHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__check_png_header@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__check_png_header@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__check_png_header@@YAHPEAUstbi__context@@@Z+182
	DD	imagerel $unwind$?stbi__check_png_header@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z DD imagerel ?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z
	DD	imagerel ?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z+84
	DD	imagerel $unwind$?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_zlib_decode_malloc_guesssize_headerflag DD imagerel $LN16
	DD	imagerel $LN16+185
	DD	imagerel $unwind$stbi_zlib_decode_malloc_guesssize_headerflag
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z DD imagerel ?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z
	DD	imagerel ?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z+457
	DD	imagerel $unwind$?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z+245
	DD	imagerel $unwind$?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z+245
	DD	imagerel ?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z+303
	DD	imagerel $chain$0$?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z+303
	DD	imagerel ?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z+367
	DD	imagerel $chain$2$?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z+269
	DD	imagerel $unwind$?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z+269
	DD	imagerel ?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z+755
	DD	imagerel $chain$1$?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z+669
	DD	imagerel $unwind$?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z DD imagerel ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z
	DD	imagerel ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z+150
	DD	imagerel $unwind$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z DD imagerel ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z+150
	DD	imagerel ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z+221
	DD	imagerel $chain$0$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z DD imagerel ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z+221
	DD	imagerel ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z+263
	DD	imagerel $chain$2$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z DD imagerel ?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z
	DD	imagerel ?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z+100
	DD	imagerel $unwind$?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z DD imagerel ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z
	DD	imagerel ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z+57
	DD	imagerel $unwind$?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z DD imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
	DD	imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z+177
	DD	imagerel $unwind$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z DD imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z+177
	DD	imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z+563
	DD	imagerel $chain$0$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z DD imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z+563
	DD	imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z+594
	DD	imagerel $chain$1$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z DD imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z+594
	DD	imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z+626
	DD	imagerel $chain$2$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z DD imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z+626
	DD	imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z+658
	DD	imagerel $chain$3$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z+233
	DD	imagerel $unwind$?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+184
	DD	imagerel $unwind$?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z DD imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
	DD	imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z+247
	DD	imagerel $unwind$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z DD imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z+247
	DD	imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z+444
	DD	imagerel $chain$1$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z DD imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z+444
	DD	imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z+546
	DD	imagerel $chain$2$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z DD imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z+546
	DD	imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z+2022
	DD	imagerel $chain$3$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z DD imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z+2022
	DD	imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z+2055
	DD	imagerel $chain$4$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z+114
	DD	imagerel $unwind$?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z DD imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+59
	DD	imagerel $unwind$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z DD imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+59
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+140
	DD	imagerel $chain$4$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z DD imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+140
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+339
	DD	imagerel $chain$5$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z DD imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+339
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+367
	DD	imagerel $chain$6$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z DD imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+367
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+382
	DD	imagerel $chain$7$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z DD imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+382
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+630
	DD	imagerel $chain$9$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z DD imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+630
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+647
	DD	imagerel $chain$10$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z DD imagerel ?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z
	DD	imagerel ?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z+36
	DD	imagerel $unwind$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z DD imagerel ?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z+36
	DD	imagerel ?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z+278
	DD	imagerel $chain$1$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z DD imagerel ?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z+278
	DD	imagerel ?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z+292
	DD	imagerel $chain$2$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z+89
	DD	imagerel $unwind$?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z+89
	DD	imagerel ?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z+335
	DD	imagerel $chain$3$?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z+335
	DD	imagerel ?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z+507
	DD	imagerel $chain$4$?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z+192
	DD	imagerel $unwind$?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z+226
	DD	imagerel $unwind$?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z+88
	DD	imagerel $unwind$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z+88
	DD	imagerel ?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z+444
	DD	imagerel $chain$2$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z+444
	DD	imagerel ?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z+523
	DD	imagerel $chain$3$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z+656
	DD	imagerel $unwind$?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__skip_jpeg_junk_at_end@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__skip_jpeg_junk_at_end@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__skip_jpeg_junk_at_end@@YAHPEAUstbi__jpeg@@@Z+295
	DD	imagerel $unwind$?stbi__skip_jpeg_junk_at_end@@YAHPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z+112
	DD	imagerel $unwind$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z+112
	DD	imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z+306
	DD	imagerel $chain$0$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z+306
	DD	imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z+338
	DD	imagerel $chain$2$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z+338
	DD	imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z+359
	DD	imagerel $chain$3$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z+465
	DD	imagerel $unwind$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z+465
	DD	imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z+1321
	DD	imagerel $chain$2$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z+1321
	DD	imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z+1690
	DD	imagerel $chain$4$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z+1690
	DD	imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z+1772
	DD	imagerel $chain$5$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z DD imagerel ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z
	DD	imagerel ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z+13
	DD	imagerel $unwind$?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z DD imagerel ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z+13
	DD	imagerel ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z+127
	DD	imagerel $chain$2$?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z DD imagerel ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z+127
	DD	imagerel ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z+135
	DD	imagerel $chain$3$?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z+190
	DD	imagerel $unwind$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z+190
	DD	imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z+843
	DD	imagerel $chain$1$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z+843
	DD	imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z+924
	DD	imagerel $chain$3$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z+924
	DD	imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z+970
	DD	imagerel $chain$4$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z+2658
	DD	imagerel $unwind$?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z+28
	DD	imagerel $unwind$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z+28
	DD	imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z+45
	DD	imagerel $chain$0$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z+45
	DD	imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z+456
	DD	imagerel $chain$6$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z+456
	DD	imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z+461
	DD	imagerel $chain$7$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z+461
	DD	imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z+468
	DD	imagerel $chain$8$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z+2061
	DD	imagerel $unwind$?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z DD imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z+33
	DD	imagerel $unwind$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z DD imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z+33
	DD	imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z+168
	DD	imagerel $chain$0$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z DD imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z+168
	DD	imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z+184
	DD	imagerel $chain$2$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z DD imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z+184
	DD	imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z+197
	DD	imagerel $chain$4$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__idct_simd@@YAXPEAEHQEAF@Z DD imagerel ?stbi__idct_simd@@YAXPEAEHQEAF@Z
	DD	imagerel ?stbi__idct_simd@@YAXPEAEHQEAF@Z+2084
	DD	imagerel $unwind$?stbi__idct_simd@@YAXPEAEHQEAF@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__idct_block@@YAXPEAEHQEAF@Z DD imagerel ?stbi__idct_block@@YAXPEAEHQEAF@Z
	DD	imagerel ?stbi__idct_block@@YAXPEAEHQEAF@Z+1555
	DD	imagerel $unwind$?stbi__idct_block@@YAXPEAEHQEAF@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z DD imagerel ?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z
	DD	imagerel ?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z+1798
	DD	imagerel $unwind$?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z DD imagerel ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z
	DD	imagerel ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z+97
	DD	imagerel $unwind$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z DD imagerel ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z+97
	DD	imagerel ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z+732
	DD	imagerel $chain$0$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z DD imagerel ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z+732
	DD	imagerel ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z+753
	DD	imagerel $chain$1$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z DD imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z
	DD	imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z+607
	DD	imagerel $unwind$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z DD imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z+607
	DD	imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z+696
	DD	imagerel $chain$0$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z DD imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z+696
	DD	imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z+1294
	DD	imagerel $chain$4$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z DD imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z+1294
	DD	imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z+1336
	DD	imagerel $chain$6$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z+77
	DD	imagerel $unwind$?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z+109
	DD	imagerel $unwind$?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z+149
	DD	imagerel $unwind$?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z DD imagerel ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z
	DD	imagerel ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z+278
	DD	imagerel $unwind$?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z+381
	DD	imagerel $unwind$?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z DD imagerel ?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z
	DD	imagerel ?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z+218
	DD	imagerel $unwind$?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z DD imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z
	DD	imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z+96
	DD	imagerel $unwind$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z DD imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z+96
	DD	imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z+414
	DD	imagerel $chain$1$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z DD imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z+414
	DD	imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z+461
	DD	imagerel $chain$2$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z DD imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z+461
	DD	imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z+493
	DD	imagerel $chain$3$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z DD imagerel ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z
	DD	imagerel ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z+164
	DD	imagerel $unwind$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z DD imagerel ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z+164
	DD	imagerel ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z+504
	DD	imagerel $chain$7$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z DD imagerel ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z+504
	DD	imagerel ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z+579
	DD	imagerel $chain$8$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__convert_format16@@YAPEAGPEAGHHII@Z DD imagerel ?stbi__convert_format16@@YAPEAGPEAGHHII@Z
	DD	imagerel ?stbi__convert_format16@@YAPEAGPEAGHHII@Z+37
	DD	imagerel $unwind$?stbi__convert_format16@@YAPEAGPEAGHHII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stbi__convert_format16@@YAPEAGPEAGHHII@Z DD imagerel ?stbi__convert_format16@@YAPEAGPEAGHHII@Z+37
	DD	imagerel ?stbi__convert_format16@@YAPEAGPEAGHHII@Z+117
	DD	imagerel $chain$0$?stbi__convert_format16@@YAPEAGPEAGHHII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?stbi__convert_format16@@YAPEAGPEAGHHII@Z DD imagerel ?stbi__convert_format16@@YAPEAGPEAGHHII@Z+117
	DD	imagerel ?stbi__convert_format16@@YAPEAGPEAGHHII@Z+1083
	DD	imagerel $chain$5$?stbi__convert_format16@@YAPEAGPEAGHHII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?stbi__convert_format16@@YAPEAGPEAGHHII@Z DD imagerel ?stbi__convert_format16@@YAPEAGPEAGHHII@Z+1083
	DD	imagerel ?stbi__convert_format16@@YAPEAGPEAGHHII@Z+1240
	DD	imagerel $chain$7$?stbi__convert_format16@@YAPEAGPEAGHHII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__convert_format@@YAPEAEPEAEHHII@Z DD imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z
	DD	imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z+49
	DD	imagerel $unwind$?stbi__convert_format@@YAPEAEPEAEHHII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stbi__convert_format@@YAPEAEPEAEHHII@Z DD imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z+49
	DD	imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z+1046
	DD	imagerel $chain$2$?stbi__convert_format@@YAPEAEPEAEHHII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbi__convert_format@@YAPEAEPEAEHHII@Z DD imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z+1046
	DD	imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z+1096
	DD	imagerel $chain$4$?stbi__convert_format@@YAPEAEPEAEHHII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?stbi__convert_format@@YAPEAEPEAEHHII@Z DD imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z+1096
	DD	imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z+1152
	DD	imagerel $chain$5$?stbi__convert_format@@YAPEAEPEAEHHII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?stbi__convert_format@@YAPEAEPEAEHHII@Z DD imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z+1152
	DD	imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z+1256
	DD	imagerel $chain$6$?stbi__convert_format@@YAPEAEPEAEHHII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__get32le@@YAIPEAUstbi__context@@@Z DD imagerel ?stbi__get32le@@YAIPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get32le@@YAIPEAUstbi__context@@@Z+44
	DD	imagerel $unwind$?stbi__get32le@@YAIPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__get16le@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__get16le@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get16le@@YAHPEAUstbi__context@@@Z+177
	DD	imagerel $unwind$?stbi__get16le@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__get32be@@YAIPEAUstbi__context@@@Z DD imagerel ?stbi__get32be@@YAIPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get32be@@YAIPEAUstbi__context@@@Z+44
	DD	imagerel $unwind$?stbi__get32be@@YAIPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__get16be@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__get16be@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get16be@@YAHPEAUstbi__context@@@Z+177
	DD	imagerel $unwind$?stbi__get16be@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z DD imagerel ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z
	DD	imagerel ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z+200
	DD	imagerel $unwind$?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__at_eof@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__at_eof@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__at_eof@@YAHPEAUstbi__context@@@Z+78
	DD	imagerel $unwind$?stbi__at_eof@@YAHPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__get8@@YAEPEAUstbi__context@@@Z DD imagerel ?stbi__get8@@YAEPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get8@@YAEPEAUstbi__context@@@Z+89
	DD	imagerel $unwind$?stbi__get8@@YAEPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z DD imagerel ?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z
	DD	imagerel ?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z+119
	DD	imagerel $unwind$?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_load_from_memory DD imagerel $LN6
	DD	imagerel $LN6+135
	DD	imagerel $unwind$stbi_load_from_memory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_load_from_file DD imagerel $LN17
	DD	imagerel $LN17+273
	DD	imagerel $unwind$stbi_load_from_file
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stbi_load DD imagerel $LN27
	DD	imagerel $LN27+361
	DD	imagerel $unwind$stbi_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z DD imagerel ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z
	DD	imagerel ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z+87
	DD	imagerel $unwind$?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z+72
	DD	imagerel $unwind$?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z+72
	DD	imagerel ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z+437
	DD	imagerel $chain$3$?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z+437
	DD	imagerel ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z+529
	DD	imagerel $chain$4$?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__vertical_flip@@YAXPEAXHHH@Z DD imagerel ?stbi__vertical_flip@@YAXPEAXHHH@Z
	DD	imagerel ?stbi__vertical_flip@@YAXPEAXHHH@Z+58
	DD	imagerel $unwind$?stbi__vertical_flip@@YAXPEAXHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?stbi__vertical_flip@@YAXPEAXHHH@Z DD imagerel ?stbi__vertical_flip@@YAXPEAXHHH@Z+58
	DD	imagerel ?stbi__vertical_flip@@YAXPEAXHHH@Z+257
	DD	imagerel $chain$5$?stbi__vertical_flip@@YAXPEAXHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?stbi__vertical_flip@@YAXPEAXHHH@Z DD imagerel ?stbi__vertical_flip@@YAXPEAXHHH@Z+257
	DD	imagerel ?stbi__vertical_flip@@YAXPEAXHHH@Z+285
	DD	imagerel $chain$6$?stbi__vertical_flip@@YAXPEAXHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z DD imagerel ?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z
	DD	imagerel ?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z+353
	DD	imagerel $unwind$?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD imagerel ?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
	DD	imagerel ?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+1654
	DD	imagerel $unwind$?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__stdio_eof@@YAHPEAX@Z DD imagerel ?stbi__stdio_eof@@YAHPEAX@Z
	DD	imagerel ?stbi__stdio_eof@@YAHPEAX@Z+49
	DD	imagerel $unwind$?stbi__stdio_eof@@YAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__stdio_skip@@YAXPEAXH@Z DD imagerel ?stbi__stdio_skip@@YAXPEAXH@Z
	DD	imagerel ?stbi__stdio_skip@@YAXPEAXH@Z+58
	DD	imagerel $unwind$?stbi__stdio_skip@@YAXPEAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z DD imagerel ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z
	DD	imagerel ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z+104
	DD	imagerel $unwind$?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__sse2_available@@YAHXZ DD imagerel ?stbi__sse2_available@@YAHXZ
	DD	imagerel ?stbi__sse2_available@@YAHXZ+29
	DD	imagerel $unwind$?stbi__sse2_available@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stbi__cpuid3@@YAHXZ DD imagerel ?stbi__cpuid3@@YAHXZ
	DD	imagerel ?stbi__cpuid3@@YAHXZ+23
	DD	imagerel $unwind$?stbi__cpuid3@@YAHXZ
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__cpuid3@@YAHXZ DD 020601H
	DD	030021206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__sse2_available@@YAHXZ DD 020601H
	DD	030021206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__stdio_skip@@YAXPEAXH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__stdio_eof@@YAHPEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD 0a2619H
	DD	0130114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	088H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?stbi__vertical_flip@@YAXPEAXHHH@Z DD 021H
	DD	imagerel ?stbi__vertical_flip@@YAXPEAXHHH@Z
	DD	imagerel ?stbi__vertical_flip@@YAXPEAXHHH@Z+58
	DD	imagerel $unwind$?stbi__vertical_flip@@YAXPEAXHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?stbi__vertical_flip@@YAXPEAXHHH@Z DD 0c2321H
	DD	0107e423H
	DD	0108d418H
	DD	01097414H
	DD	010a6410H
	DD	010b540cH
	DD	010c3404H
	DD	imagerel ?stbi__vertical_flip@@YAXPEAXHHH@Z
	DD	imagerel ?stbi__vertical_flip@@YAXPEAXHHH@Z+58
	DD	imagerel $unwind$?stbi__vertical_flip@@YAXPEAXHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__vertical_flip@@YAXPEAXHHH@Z DD 042019H
	DD	010d010eH
	DD	0c005f007H
	DD	imagerel __GSHandlerCheck
	DD	0820H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD 021H
	DD	imagerel ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z+72
	DD	imagerel $unwind$?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD 081b21H
	DD	0cc41bH
	DD	0d740fH
	DD	0e640aH
	DD	0f5405H
	DD	imagerel ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z+72
	DD	imagerel $unwind$?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD 041c19H
	DD	0f006f20dH
	DD	03002e004H
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z DD 011319H
	DD	06204H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_load DD 072219H
	DD	02d3414H
	DD	0260114H
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0120H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_load_from_file DD 072219H
	DD	02b3414H
	DD	0240114H
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0110H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_load_from_memory DD 021919H
	DD	0250107H
	DD	imagerel __GSHandlerCheck
	DD	0110H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__get8@@YAEPEAUstbi__context@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__at_eof@@YAHPEAUstbi__context@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__get16be@@YAHPEAUstbi__context@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__get32be@@YAIPEAUstbi__context@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__get16le@@YAHPEAUstbi__context@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__get32le@@YAIPEAUstbi__context@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?stbi__convert_format@@YAPEAEPEAEHHII@Z DD 021H
	DD	imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z
	DD	imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z+49
	DD	imagerel $unwind$?stbi__convert_format@@YAPEAEPEAEHHII@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?stbi__convert_format@@YAPEAEPEAEHHII@Z DD 020021H
	DD	0ce400H
	DD	imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z
	DD	imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z+49
	DD	imagerel $unwind$?stbi__convert_format@@YAPEAEPEAEHHII@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbi__convert_format@@YAPEAEPEAEHHII@Z DD 060021H
	DD	0ce400H
	DD	0bc400H
	DD	0a7400H
	DD	imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z
	DD	imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z+49
	DD	imagerel $unwind$?stbi__convert_format@@YAPEAEPEAEHHII@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__convert_format@@YAPEAEPEAEHHII@Z DD 067721H
	DD	0bc477H
	DD	0a7470H
	DD	0ce405H
	DD	imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z
	DD	imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z+49
	DD	imagerel $unwind$?stbi__convert_format@@YAPEAEPEAEHHII@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__convert_format@@YAPEAEPEAEHHII@Z DD 060c01H
	DD	0f008320cH
	DD	06004d006H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?stbi__convert_format16@@YAPEAGPEAGHHII@Z DD 080021H
	DD	0be400H
	DD	0ad400H
	DD	095400H
	DD	083400H
	DD	imagerel ?stbi__convert_format16@@YAPEAGPEAGHHII@Z
	DD	imagerel ?stbi__convert_format16@@YAPEAGPEAGHHII@Z+37
	DD	imagerel $unwind$?stbi__convert_format16@@YAPEAGPEAGHHII@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?stbi__convert_format16@@YAPEAGPEAGHHII@Z DD 081121H
	DD	0ad411H
	DD	09540cH
	DD	083405H
	DD	0be400H
	DD	imagerel ?stbi__convert_format16@@YAPEAGPEAGHHII@Z
	DD	imagerel ?stbi__convert_format16@@YAPEAGPEAGHHII@Z+37
	DD	imagerel $unwind$?stbi__convert_format16@@YAPEAGPEAGHHII@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbi__convert_format16@@YAPEAGPEAGHHII@Z DD 020521H
	DD	0be405H
	DD	imagerel ?stbi__convert_format16@@YAPEAGPEAGHHII@Z
	DD	imagerel ?stbi__convert_format16@@YAPEAGPEAGHHII@Z+37
	DD	imagerel $unwind$?stbi__convert_format16@@YAPEAGPEAGHHII@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__convert_format16@@YAPEAGPEAGHHII@Z DD 040901H
	DD	0f0053209H
	DD	060027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z DD 021H
	DD	imagerel ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z
	DD	imagerel ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z+164
	DD	imagerel $unwind$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z DD 0105821H
	DD	048858H
	DD	057848H
	DD	06683bH
	DD	0ef433H
	DD	0fe42bH
	DD	017d423H
	DD	016c418H
	DD	0155408H
	DD	imagerel ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z
	DD	imagerel ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z+164
	DD	imagerel $unwind$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z DD 040f01H
	DD	07008f20fH
	DD	030066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z DD 040021H
	DD	077400H
	DD	066400H
	DD	imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z
	DD	imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z+96
	DD	imagerel $unwind$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z DD 021H
	DD	imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z
	DD	imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z+96
	DD	imagerel $unwind$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z DD 041021H
	DD	077410H
	DD	066405H
	DD	imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z
	DD	imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z+96
	DD	imagerel $unwind$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z DD 061001H
	DD	095410H
	DD	083410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z DD 071501H
	DD	037415H
	DD	02340dH
	DD	045406H
	DD	06006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z DD 061201H
	DD	066412H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z DD 060021H
	DD	0cd400H
	DD	0bc400H
	DD	0a6400H
	DD	imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z
	DD	imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z+607
	DD	imagerel $unwind$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z DD 061b21H
	DD	0a641bH
	DD	0cd405H
	DD	0bc400H
	DD	imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z
	DD	imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z+607
	DD	imagerel $unwind$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z DD 020521H
	DD	0bc405H
	DD	imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z
	DD	imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z+607
	DD	imagerel $unwind$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z DD 060c01H
	DD	0f008320cH
	DD	07004e006H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z DD 021H
	DD	imagerel ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z
	DD	imagerel ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z+97
	DD	imagerel $unwind$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z DD 020521H
	DD	06e405H
	DD	imagerel ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z
	DD	imagerel ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z+97
	DD	imagerel $unwind$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z DD 0d7001H
	DD	04e470H
	DD	0dc46bH
	DD	0c6466H
	DD	0a5461H
	DD	0f00b420fH
	DD	07007d009H
	DD	03006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__idct_block@@YAXPEAEHQEAF@Z DD 0b2919H
	DD	0303417H
	DD	0260117H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0120H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__idct_simd@@YAXPEAEHQEAF@Z DD 0169a01H
	DD	08f89aH
	DD	09e892H
	DD	0ad88aH
	DD	0bc882H
	DD	0cb87dH
	DD	0da86dH
	DD	0e9868H
	DD	0f8839H
	DD	010782eH
	DD	0116829H
	DD	025010aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z DD 020021H
	DD	063400H
	DD	imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z+33
	DD	imagerel $unwind$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z DD 020021H
	DD	063400H
	DD	imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z+33
	DD	imagerel $unwind$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z DD 020521H
	DD	063405H
	DD	imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z+33
	DD	imagerel $unwind$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z DD 0d3119H
	DD	025641fH
	DD	024541fH
	DD	023341fH
	DD	01c011fH
	DD	0e016f018H
	DD	0c012d014H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z DD 021H
	DD	imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z+28
	DD	imagerel $unwind$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z DD 021H
	DD	imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z+28
	DD	imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z+45
	DD	imagerel $chain$0$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z DD 0c1f21H
	DD	04f41fH
	DD	06c41bH
	DD	077417H
	DD	0c6413H
	DD	0b540fH
	DD	0a3404H
	DD	imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z+28
	DD	imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z+45
	DD	imagerel $chain$0$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z DD 020421H
	DD	05d404H
	DD	imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z+28
	DD	imagerel $unwind$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z DD 020901H
	DD	0e0057209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z DD 0c2e19H
	DD	019641fH
	DD	018541fH
	DD	017341fH
	DD	0f018f21fH
	DD	0d014e016H
	DD	07010c012H
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z DD 021H
	DD	imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z+190
	DD	imagerel $unwind$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z DD 040021H
	DD	07e400H
	DD	065400H
	DD	imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z+190
	DD	imagerel $unwind$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z DD 040c21H
	DD	07e40cH
	DD	065405H
	DD	imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z+190
	DD	imagerel $unwind$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z DD 021H
	DD	imagerel ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z
	DD	imagerel ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z+13
	DD	imagerel $unwind$?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z DD 061821H
	DD	087418H
	DD	075411H
	DD	063405H
	DD	imagerel ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z
	DD	imagerel ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z+13
	DD	imagerel $unwind$?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z DD 020601H
	DD	060023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z DD 021H
	DD	imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z+465
	DD	imagerel $unwind$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z DD 060021H
	DD	0de400H
	DD	0cd400H
	DD	0ac400H
	DD	imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z+465
	DD	imagerel $unwind$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z DD 061d21H
	DD	0de41dH
	DD	0cd40aH
	DD	0ac405H
	DD	imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z+465
	DD	imagerel $unwind$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z DD 060e01H
	DD	0f00a320eH
	DD	060077008H
	DD	030055006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z DD 021H
	DD	imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z+112
	DD	imagerel $unwind$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z DD 020021H
	DD	063400H
	DD	imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z+112
	DD	imagerel $unwind$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z DD 020521H
	DD	063405H
	DD	imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z+112
	DD	imagerel $unwind$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z DD 060f01H
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__skip_jpeg_junk_at_end@@YAHPEAUstbi__jpeg@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z DD 021H
	DD	imagerel ?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z+88
	DD	imagerel $unwind$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z DD 060f21H
	DD	04e40fH
	DD	03740aH
	DD	026405H
	DD	imagerel ?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z+88
	DD	imagerel $unwind$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z DD 010201H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z DD 074001H
	DD	07440H
	DD	036434H
	DD	02342cH
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z DD 053e01H
	DD	02743eH
	DD	033406H
	DD	06006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z DD 021H
	DD	imagerel ?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z+89
	DD	imagerel $unwind$?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z DD 061c21H
	DD	06f41cH
	DD	05e40cH
	DD	045405H
	DD	imagerel ?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z+89
	DD	imagerel $unwind$?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z DD 043901H
	DD	033439H
	DD	060027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z DD 021H
	DD	imagerel ?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z
	DD	imagerel ?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z+36
	DD	imagerel $unwind$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z DD 041921H
	DD	04f419H
	DD	036405H
	DD	imagerel ?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z
	DD	imagerel ?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z+36
	DD	imagerel $unwind$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z DD 060d01H
	DD	06540dH
	DD	05340dH
	DD	0700be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z DD 021H
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+367
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+382
	DD	imagerel $chain$7$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z DD 041721H
	DD	011e417H
	DD	0103408H
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+367
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+382
	DD	imagerel $chain$7$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z DD 021H
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+59
	DD	imagerel $unwind$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z DD 021H
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+59
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+140
	DD	imagerel $chain$4$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z DD 020521H
	DD	056805H
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+59
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+140
	DD	imagerel $chain$4$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z DD 0a3f21H
	DD	0b83fH
	DD	01a831H
	DD	029822H
	DD	038813H
	DD	047805H
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+59
	DD	imagerel $unwind$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z DD 060d01H
	DD	012540dH
	DD	0f009b20dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z DD 020601H
	DD	030021206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z DD 021H
	DD	imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
	DD	imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z+247
	DD	imagerel $unwind$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z DD 040021H
	DD	02dd400H
	DD	02e6400H
	DD	imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
	DD	imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z+247
	DD	imagerel $unwind$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z DD 021H
	DD	imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
	DD	imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z+247
	DD	imagerel $unwind$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z DD 041321H
	DD	02dd413H
	DD	02e6408H
	DD	imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
	DD	imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z+247
	DD	imagerel $unwind$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z DD 082319H
	DD	02f0111H
	DD	0e008f00aH
	DD	07004c006H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	0150H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0e016521aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z DD 065201H
	DD	066452H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z DD 021H
	DD	imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
	DD	imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z+177
	DD	imagerel $unwind$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z DD 020021H
	DD	0206400H
	DD	imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
	DD	imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z+177
	DD	imagerel $unwind$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z DD 021H
	DD	imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
	DD	imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z+177
	DD	imagerel $unwind$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z DD 020821H
	DD	0206408H
	DD	imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
	DD	imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z+177
	DD	imagerel $unwind$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z DD 072319H
	DD	0180111H
	DD	0e008f00aH
	DD	050057006H
	DD	03004H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z DD 020021H
	DD	066400H
	DD	imagerel ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z
	DD	imagerel ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z+150
	DD	imagerel $unwind$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z DD 020521H
	DD	066405H
	DD	imagerel ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z
	DD	imagerel ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z+150
	DD	imagerel $unwind$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z DD 0c2b01H
	DD	09e42bH
	DD	085423H
	DD	0b6413H
	DD	0a3413H
	DD	0f00f3213H
	DD	0700bc00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z DD 020821H
	DD	01496408H
	DD	imagerel ?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z+269
	DD	imagerel $unwind$?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z DD 099f19H
	DD	014a749fH
	DD	01420110H
	DD	0e007f009H
	DD	05003c005H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0a00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z DD 020021H
	DD	077400H
	DD	imagerel ?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z+245
	DD	imagerel $unwind$?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z DD 020521H
	DD	077405H
	DD	imagerel ?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z+245
	DD	imagerel $unwind$?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_zlib_decode_malloc_guesssize_headerflag DD 062419H
	DD	02070112H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	01020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__check_png_header@@YAHPEAUstbi__context@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__paeth@@YAHHHH@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z DD 0b1c01H
	DD	01b341cH
	DD	012011cH
	DD	0e013f015H
	DD	0c00fd011H
	DD	0600c700dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z DD 020021H
	DD	0236400H
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+139
	DD	imagerel $unwind$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z DD 060021H
	DD	021f400H
	DD	022d400H
	DD	0236400H
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+139
	DD	imagerel $unwind$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z DD 021H
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+139
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+247
	DD	imagerel $chain$0$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z DD 041321H
	DD	021f413H
	DD	022d408H
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+139
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+247
	DD	imagerel $chain$0$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z DD 020821H
	DD	0236408H
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+139
	DD	imagerel $unwind$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z DD 072201H
	DD	0240122H
	DD	0c019e01bH
	DD	050167017H
	DD	03015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z DD 021H
	DD	imagerel ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z
	DD	imagerel ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z+130
	DD	imagerel $unwind$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z DD 020421H
	DD	03404H
	DD	imagerel ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z
	DD	imagerel ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z+130
	DD	imagerel $unwind$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z DD 0d3e19H
	DD	029b742dH
	DD	029a642dH
	DD	0299342dH
	DD	0292012dH
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	01480H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z DD 0a1801H
	DD	0c6418H
	DD	0b5418H
	DD	0a3418H
	DD	0f0145218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 061b19H
	DD	0f008b20cH
	DD	07004e006H
	DD	030026003H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__png_test@@YAHPEAUstbi__context@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__bmp_test@@YAHPEAUstbi__context@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z DD 021H
	DD	imagerel ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z
	DD	imagerel ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z+140
	DD	imagerel $unwind$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z DD 020021H
	DD	065400H
	DD	imagerel ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z
	DD	imagerel ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z+140
	DD	imagerel $unwind$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z DD 020521H
	DD	065405H
	DD	imagerel ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z
	DD	imagerel ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z+140
	DD	imagerel $unwind$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 060021H
	DD	09af400H
	DD	09be400H
	DD	09c7400H
	DD	imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+175
	DD	imagerel $unwind$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 080021H
	DD	09af400H
	DD	09be400H
	DD	09c7400H
	DD	0a26400H
	DD	imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+175
	DD	imagerel $unwind$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 021H
	DD	imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+175
	DD	imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+508
	DD	imagerel $chain$2$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 020821H
	DD	0a26408H
	DD	imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+175
	DD	imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+508
	DD	imagerel $chain$2$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 062f21H
	DD	09af42fH
	DD	09be41aH
	DD	09c7408H
	DD	imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+175
	DD	imagerel $unwind$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 062401H
	DD	09d0124H
	DD	0c013d015H
	DD	050103011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbi__tga_test@@YAHPEAUstbi__context@@@Z DD 021H
	DD	imagerel ?stbi__tga_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__tga_test@@YAHPEAUstbi__context@@@Z+156
	DD	imagerel $unwind$?stbi__tga_test@@YAHPEAUstbi__context@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__tga_test@@YAHPEAUstbi__context@@@Z DD 020521H
	DD	0af405H
	DD	imagerel ?stbi__tga_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__tga_test@@YAHPEAUstbi__context@@@Z+156
	DD	imagerel $unwind$?stbi__tga_test@@YAHPEAUstbi__context@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__tga_test@@YAHPEAUstbi__context@@@Z DD 085101H
	DD	096451H
	DD	08544cH
	DD	0e0053209H
	DD	030027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 0b8919H
	DD	0156489H
	DD	0160113H
	DD	0e00af00cH
	DD	0c006d008H
	DD	050037004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__psd_test@@YAHPEAUstbi__context@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD 020021H
	DD	08d400H
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+143
	DD	imagerel $unwind$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD 060021H
	DD	06f400H
	DD	07e400H
	DD	08d400H
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+143
	DD	imagerel $unwind$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD 0c0021H
	DD	06f400H
	DD	07e400H
	DD	08d400H
	DD	09c400H
	DD	0a6400H
	DD	0e5400H
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+143
	DD	imagerel $unwind$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD 021H
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+143
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+588
	DD	imagerel $chain$2$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD 021H
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+588
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+669
	DD	imagerel $chain$4$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD 020521H
	DD	0a6405H
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+588
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+669
	DD	imagerel $chain$4$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD 041121H
	DD	09c411H
	DD	0e5405H
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+143
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+588
	DD	imagerel $chain$2$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD 065f21H
	DD	06f45fH
	DD	07e457H
	DD	08d405H
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+143
	DD	imagerel $unwind$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD 031501H
	DD	07011a215H
	DD	03010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z DD 021H
	DD	imagerel ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z+25
	DD	imagerel $unwind$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z DD 020521H
	DD	067405H
	DD	imagerel ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z+25
	DD	imagerel $unwind$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z DD 0e4c19H
	DD	010c44cH
	DD	0117446H
	DD	0126437H
	DD	01a3430H
	DD	0130111H
	DD	0e008f00aH
	DD	05004d006H
	DD	imagerel __GSHandlerCheck
	DD	078H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 021H
	DD	imagerel ?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+321
	DD	imagerel $unwind$?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 040d21H
	DD	09e40dH
	DD	0a5405H
	DD	imagerel ?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+321
	DD	imagerel $unwind$?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 071d19H
	DD	0f00aa20eH
	DD	0c006d008H
	DD	060037004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbi__pic_test@@YAHPEAUstbi__context@@@Z DD 021H
	DD	imagerel ?stbi__pic_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__pic_test@@YAHPEAUstbi__context@@@Z+30
	DD	imagerel $unwind$?stbi__pic_test@@YAHPEAUstbi__context@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbi__pic_test@@YAHPEAUstbi__context@@@Z DD 020521H
	DD	067405H
	DD	imagerel ?stbi__pic_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__pic_test@@YAHPEAUstbi__context@@@Z+30
	DD	imagerel $unwind$?stbi__pic_test@@YAHPEAUstbi__context@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__pic_test@@YAHPEAUstbi__context@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__gif_test@@YAHPEAUstbi__context@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z DD 021H
	DD	imagerel ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z
	DD	imagerel ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z+31
	DD	imagerel $unwind$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z DD 020521H
	DD	087405H
	DD	imagerel ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z
	DD	imagerel ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z+31
	DD	imagerel $unwind$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z DD 081c01H
	DD	0a541cH
	DD	09341cH
	DD	0f018321cH
	DD	06014e016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z DD 021H
	DD	imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
	DD	imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z+392
	DD	imagerel $unwind$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z DD 020021H
	DD	06e400H
	DD	imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
	DD	imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z+392
	DD	imagerel $unwind$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z DD 021H
	DD	imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
	DD	imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z+392
	DD	imagerel $unwind$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z DD 020521H
	DD	06e405H
	DD	imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
	DD	imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z+392
	DD	imagerel $unwind$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z DD 081501H
	DD	097415H
	DD	086415H
	DD	073415H
	DD	0f0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z DD 0f9001H
	DD	06f490H
	DD	07e47cH
	DD	08d470H
	DD	09746bH
	DD	0a6464H
	DD	0f5453H
	DD	0c004a208H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z DD 0c2101H
	DD	0c6421H
	DD	0b5421H
	DD	0a3421H
	DD	0f01d3221H
	DD	0d019e01bH
	DD	07015c017H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 072719H
	DD	011160115H
	DD	0e006f008H
	DD	060037004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	088a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__hdr_test@@YAHPEAUstbi__context@@@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__hdr_convert@@YAXPEAMPEAEH@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 021H
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+437
	DD	imagerel $unwind$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 020021H
	DD	08fd400H
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+437
	DD	imagerel $unwind$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 040021H
	DD	08fd400H
	DD	090c400H
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+437
	DD	imagerel $unwind$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 021H
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+437
	DD	imagerel $unwind$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 021H
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+437
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+594
	DD	imagerel $chain$0$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 020821H
	DD	090c408H
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+437
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+594
	DD	imagerel $chain$0$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 020821H
	DD	08fd408H
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+437
	DD	imagerel $unwind$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 082219H
	DD	0910110H
	DD	0e007f009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	0460H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__pnm_test@@YAHPEAUstbi__context@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 0c1e01H
	DD	0d741eH
	DD	0c641eH
	DD	0b541eH
	DD	0a341eH
	DD	0f01a521eH
	DD	0c016e018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z DD 0c1c01H
	DD	0d641cH
	DD	0c541cH
	DD	0b341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z DD 071c19H
	DD	0f009620dH
	DD	07005e007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbiw__sbgrowf@@YAPEAXPEAPEAXHH@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z DD 021H
	DD	imagerel ?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z
	DD	imagerel ?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z+28
	DD	imagerel $unwind$?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z DD 081a21H
	DD	06741aH
	DD	04e411H
	DD	05c40cH
	DD	075405H
	DD	imagerel ?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z
	DD	imagerel ?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z+28
	DD	imagerel $unwind$?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z DD 040901H
	DD	0f0057209H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$stbi_zlib_compress DD 020021H
	DD	0ee400H
	DD	imagerel $LN898
	DD	imagerel $LN898+84
	DD	imagerel $unwind$stbi_zlib_compress
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$stbi_zlib_compress DD 061421H
	DD	0ee414H
	DD	0fd40fH
	DD	010c408H
	DD	imagerel $LN898
	DD	imagerel $LN898+84
	DD	imagerel $unwind$stbi_zlib_compress
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_zlib_compress DD 084f01H
	DD	019744fH
	DD	011010dH
	DD	06004f006H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbiw__crc32@@YAIPEAEH@Z DD 021H
	DD	imagerel ?stbiw__crc32@@YAIPEAEH@Z
	DD	imagerel ?stbiw__crc32@@YAIPEAEH@Z+16
	DD	imagerel $unwind$?stbiw__crc32@@YAIPEAEH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stbiw__crc32@@YAIPEAEH@Z DD 020421H
	DD	03404H
	DD	imagerel ?stbiw__crc32@@YAIPEAEH@Z
	DD	imagerel ?stbiw__crc32@@YAIPEAEH@Z+16
	DD	imagerel $unwind$?stbiw__crc32@@YAIPEAEH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbiw__crc32@@YAIPEAEH@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbiw__paeth@@YAEHHH@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z DD 021H
	DD	imagerel ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z
	DD	imagerel ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z+129
	DD	imagerel $unwind$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z DD 040021H
	DD	04f400H
	DD	05e400H
	DD	imagerel ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z+129
	DD	imagerel ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z+148
	DD	imagerel $chain$1$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z DD 061b21H
	DD	04f41bH
	DD	05e40dH
	DD	0dd405H
	DD	imagerel ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z+129
	DD	imagerel ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z+148
	DD	imagerel $chain$1$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z DD 041121H
	DD	0c7411H
	DD	0b6405H
	DD	imagerel ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z
	DD	imagerel ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z+129
	DD	imagerel $unwind$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z DD 040901H
	DD	0c0055209H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$stbi_write_png_to_mem DD 021H
	DD	imagerel $LN121
	DD	imagerel $LN121+243
	DD	imagerel $unwind$stbi_write_png_to_mem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$stbi_write_png_to_mem DD 020821H
	DD	013d408H
	DD	imagerel $LN121
	DD	imagerel $LN121+243
	DD	imagerel $unwind$stbi_write_png_to_mem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stbi_write_png_to_mem DD 0a7219H
	DD	0147472H
	DD	0150111H
	DD	0e008f00aH
	DD	06004c006H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	080H
?stbi__stdio_callbacks@@3Ustbi_io_callbacks@@A DQ FLAT:?stbi__stdio_read@@YAHPEAXPEADH@Z ; stbi__stdio_callbacks
	DQ	FLAT:?stbi__stdio_skip@@YAXPEAXH@Z
	DQ	FLAT:?stbi__stdio_eof@@YAHPEAX@Z
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image_write.h
;	COMDAT stbi_write_png_to_mem_forward
_TEXT	SEGMENT
pixels$ = 8
stride_bytes$ = 16
x$ = 24
y$ = 32
n$dead$ = 40
out_len$ = 48
stbi_write_png_to_mem_forward PROC			; COMDAT

; 1233 :     return stbi_write_png_to_mem(pixels, stride_bytes, x, y, n, out_len);

	jmp	stbi_write_png_to_mem
stbi_write_png_to_mem_forward ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__cpuid3@@YAHXZ
_TEXT	SEGMENT
?stbi__cpuid3@@YAHXZ PROC				; stbi__cpuid3, COMDAT

; 731  : {

	push	rbx
	sub	rsp, 16

; 732  :    int info[4];
; 733  :    __cpuid(info,1);

	mov	eax, 1
	xor	ecx, ecx
	cpuid

; 734  :    return info[3];

	mov	eax, edx

; 735  : }

	add	rsp, 16
	pop	rbx
	ret	0
?stbi__cpuid3@@YAHXZ ENDP				; stbi__cpuid3
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__sse2_available@@YAHXZ
_TEXT	SEGMENT
?stbi__sse2_available@@YAHXZ PROC			; stbi__sse2_available, COMDAT

; 753  : {

	push	rbx
	sub	rsp, 16

; 733  :    __cpuid(info,1);

	xor	ecx, ecx
	mov	eax, 1
	cpuid

; 754  :    int info3 = stbi__cpuid3();
; 755  :    return ((info3 >> 26) & 1) != 0;

	sar	edx, 26
	and	edx, 1
	mov	eax, edx

; 756  : }

	add	rsp, 16
	pop	rbx
	ret	0
?stbi__sse2_available@@YAHXZ ENDP			; stbi__sse2_available
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z
_TEXT	SEGMENT
s$ = 8
buffer$ = 16
len$ = 24
?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z PROC	; stbi__start_mem, COMDAT

; 826  :    s->io.read = NULL;

	xor	eax, eax

; 827  :    s->read_from_callbacks = 0;
; 828  :    s->callback_already_read = 0;
; 829  :    s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;

	mov	QWORD PTR [rcx+208], rdx
	mov	QWORD PTR [rcx+16], rax
	mov	DWORD PTR [rcx+48], eax
	mov	DWORD PTR [rcx+184], eax

; 830  :    s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;

	movsxd	rax, r8d
	mov	QWORD PTR [rcx+192], rdx
	add	rdx, rax
	mov	QWORD PTR [rcx+216], rdx
	mov	QWORD PTR [rcx+200], rdx

; 831  : }

	ret	0
?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ENDP	; stbi__start_mem
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z
_TEXT	SEGMENT
s$ = 48
c$dead$ = 56
user$ = 64
?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z PROC ; stbi__start_callbacks, COMDAT

; 835  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 836  :    s->io = *c;

	movups	xmm0, XMMWORD PTR ?stbi__stdio_callbacks@@3Ustbi_io_callbacks@@A

; 837  :    s->io_user_data = user;
; 838  :    s->buflen = sizeof(s->buffer_start);
; 839  :    s->read_from_callbacks = 1;
; 840  :    s->callback_already_read = 0;
; 841  :    s->img_buffer = s->img_buffer_original = s->buffer_start;

	lea	rax, QWORD PTR [rcx+56]
	mov	rbx, rcx
	movups	XMMWORD PTR [rcx+16], xmm0
	movsd	xmm0, QWORD PTR ?stbi__stdio_callbacks@@3Ustbi_io_callbacks@@A+16
	movsd	QWORD PTR [rcx+32], xmm0
	mov	QWORD PTR [rcx+40], r8
	mov	DWORD PTR [rcx+52], 128			; 00000080H
	mov	DWORD PTR [rcx+48], 1
	mov	DWORD PTR [rcx+184], 0
	mov	QWORD PTR [rcx+208], rax
	mov	QWORD PTR [rcx+192], rax

; 842  :    stbi__refill_buffer(s);

	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 843  :    s->img_buffer_original_end = s->img_buffer_end;

	mov	rax, QWORD PTR [rbx+200]
	mov	QWORD PTR [rbx+216], rax

; 844  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ENDP ; stbi__start_callbacks
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__stdio_read@@YAHPEAXPEADH@Z
_TEXT	SEGMENT
user$ = 8
data$ = 16
size$ = 24
?stbi__stdio_read@@YAHPEAXPEADH@Z PROC			; stbi__stdio_read, COMDAT

; 849  : {

	mov	rax, rdx

; 850  :    return (int) fread(data,1,size,(FILE*) user);

	movsxd	r8, r8d
	mov	r9, rcx
	mov	edx, 1
	mov	rcx, rax
	rex_jmp	QWORD PTR __imp_fread
?stbi__stdio_read@@YAHPEAXPEADH@Z ENDP			; stbi__stdio_read
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__stdio_skip@@YAXPEAXH@Z
_TEXT	SEGMENT
user$ = 48
n$ = 56
?stbi__stdio_skip@@YAXPEAXH@Z PROC			; stbi__stdio_skip, COMDAT

; 854  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 855  :    int ch;
; 856  :    fseek((FILE*) user, n, SEEK_CUR);

	mov	r8d, 1
	mov	rbx, rcx
	call	QWORD PTR __imp_fseek

; 857  :    ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */

	mov	rcx, rbx
	call	QWORD PTR __imp_fgetc

; 858  :    if (ch != EOF) {

	cmp	eax, -1
	je	SHORT $LN2@stbi__stdi

; 859  :       ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */

	mov	rdx, rbx
	mov	ecx, eax

; 860  :    }
; 861  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 859  :       ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */

	rex_jmp	QWORD PTR __imp_ungetc
$LN2@stbi__stdi:

; 860  :    }
; 861  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stbi__stdio_skip@@YAXPEAXH@Z ENDP			; stbi__stdio_skip
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__stdio_eof@@YAHPEAX@Z
_TEXT	SEGMENT
user$ = 48
?stbi__stdio_eof@@YAHPEAX@Z PROC			; stbi__stdio_eof, COMDAT

; 864  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 865  :    return feof((FILE*) user) || ferror((FILE *) user);

	call	QWORD PTR __imp_feof
	test	eax, eax
	jne	SHORT $LN3@stbi__stdi
	mov	rcx, rbx
	call	QWORD PTR __imp_ferror
	test	eax, eax
	jne	SHORT $LN3@stbi__stdi

; 866  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@stbi__stdi:

; 865  :    return feof((FILE*) user) || ferror((FILE *) user);

	mov	eax, 1

; 866  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stbi__stdio_eof@@YAHPEAX@Z ENDP			; stbi__stdio_eof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z
_TEXT	SEGMENT
s$ = 8
f$ = 16
?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z PROC ; stbi__start_file, COMDAT

; 877  :    stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);

	mov	r8, rdx
	jmp	?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks
?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ENDP ; stbi__start_file
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__rewind@@YAXPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 8
?stbi__rewind@@YAXPEAUstbi__context@@@Z PROC		; stbi__rewind, COMDAT

; 886  :    // conceptually rewind SHOULD rewind to the beginning of the stream,
; 887  :    // but we just rewind to the beginning of the initial buffer, because
; 888  :    // we only use it after doing 'test', which only ever looks at at most 92 bytes
; 889  :    s->img_buffer = s->img_buffer_original;

	mov	rax, QWORD PTR [rcx+208]
	mov	QWORD PTR [rcx+192], rax

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	rax, QWORD PTR [rcx+216]
	mov	QWORD PTR [rcx+200], rax

; 891  : }

	ret	0
?stbi__rewind@@YAXPEAUstbi__context@@@Z ENDP		; stbi__rewind
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__err@@YAHPEBD@Z
_TEXT	SEGMENT
str$ = 8
?stbi__err@@YAHPEBD@Z PROC				; stbi__err, COMDAT

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	r8d, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rdx, QWORD PTR [rax]

; 979  :    return 0;

	xor	eax, eax
	mov	QWORD PTR [r8+rdx], rcx

; 980  : }

	ret	0
?stbi__err@@YAHPEBD@Z ENDP				; stbi__err
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__malloc@@YAPEAX_K@Z
_TEXT	SEGMENT
size$ = 8
?stbi__malloc@@YAPEAX_K@Z PROC				; stbi__malloc, COMDAT

; 985  :     return STBI_MALLOC(size);

	rex_jmp	QWORD PTR __imp_malloc
?stbi__malloc@@YAPEAX_K@Z ENDP				; stbi__malloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__addsizes_valid@@YAHHH@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
?stbi__addsizes_valid@@YAHHH@Z PROC			; stbi__addsizes_valid, COMDAT

; 1002 :    if (b < 0) return 0;

	xor	eax, eax
	mov	r8d, ecx
	test	edx, edx
	js	SHORT $LN1@stbi__adds

; 1003 :    // now 0 <= b <= INT_MAX, hence also
; 1004 :    // 0 <= INT_MAX - b <= INTMAX.
; 1005 :    // And "a + b <= INT_MAX" (which might overflow) is the
; 1006 :    // same as a <= INT_MAX - b (no overflow)
; 1007 :    return a <= INT_MAX - b;

	mov	ecx, 2147483647				; 7fffffffH
	sub	ecx, edx
	cmp	r8d, ecx
	setle	al
$LN1@stbi__adds:

; 1008 : }

	ret	0
?stbi__addsizes_valid@@YAHHH@Z ENDP			; stbi__addsizes_valid
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__mul2sizes_valid@@YAHHH@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
?stbi__mul2sizes_valid@@YAHHH@Z PROC			; stbi__mul2sizes_valid, COMDAT

; 1013 : {

	mov	r8d, edx
	mov	r9d, ecx

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	SHORT $LN3@stbi__mul2
	test	edx, edx
	js	SHORT $LN3@stbi__mul2

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	jne	SHORT $LN4@stbi__mul2
	mov	eax, 1

; 1018 : }

	ret	0
$LN4@stbi__mul2:

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	xor	ecx, ecx
	mov	eax, 2147483647				; 7fffffffH
	div	r8d
	cmp	r9d, eax
	setle	cl
	mov	eax, ecx

; 1018 : }

	ret	0
$LN3@stbi__mul2:

; 1014 :    if (a < 0 || b < 0) return 0;

	xor	eax, eax

; 1018 : }

	ret	0
?stbi__mul2sizes_valid@@YAHHH@Z ENDP			; stbi__mul2sizes_valid
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__mad2sizes_valid@@YAHHHH@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
add$ = 24
?stbi__mad2sizes_valid@@YAHHHH@Z PROC			; stbi__mad2sizes_valid, COMDAT

; 1023 : {

	mov	r10d, edx

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	SHORT $LN3@stbi__mad2
	test	edx, edx
	js	SHORT $LN3@stbi__mad2

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	mov	r9d, 2147483647				; 7fffffffH
	je	SHORT $LN13@stbi__mad2

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, r9d
	div	r10d

; 1024 :    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);

	cmp	ecx, eax
	jg	SHORT $LN3@stbi__mad2
$LN13@stbi__mad2:

; 1002 :    if (b < 0) return 0;

	test	r8d, r8d
	js	SHORT $LN3@stbi__mad2

; 1024 :    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);

	imul	ecx, r10d

; 1007 :    return a <= INT_MAX - b;

	sub	r9d, r8d

; 1024 :    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);

	cmp	ecx, r9d
	jg	SHORT $LN3@stbi__mad2
	mov	eax, 1

; 1025 : }

	ret	0
$LN3@stbi__mad2:

; 1024 :    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);

	xor	eax, eax

; 1025 : }

	ret	0
?stbi__mad2sizes_valid@@YAHHHH@Z ENDP			; stbi__mad2sizes_valid
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__mad3sizes_valid@@YAHHHHH@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
c$ = 24
add$ = 32
?stbi__mad3sizes_valid@@YAHHHHH@Z PROC			; stbi__mad3sizes_valid, COMDAT

; 1030 : {

	mov	r11d, edx

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	SHORT $LN3@stbi__mad3
	test	edx, edx
	js	SHORT $LN3@stbi__mad3

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	mov	r10d, 2147483647			; 7fffffffH
	je	SHORT $LN19@stbi__mad3

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, r10d
	div	r11d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	SHORT $LN3@stbi__mad3
$LN19@stbi__mad3:
	imul	ecx, r11d

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	SHORT $LN3@stbi__mad3
	test	r8d, r8d
	js	SHORT $LN3@stbi__mad3

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN18@stbi__mad3

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, r10d
	div	r8d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	SHORT $LN3@stbi__mad3
$LN18@stbi__mad3:

; 1002 :    if (b < 0) return 0;

	test	r9d, r9d
	js	SHORT $LN3@stbi__mad3

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	imul	ecx, r8d

; 1007 :    return a <= INT_MAX - b;

	sub	r10d, r9d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, r10d
	jg	SHORT $LN3@stbi__mad3
	mov	eax, 1

; 1032 :       stbi__addsizes_valid(a*b*c, add);
; 1033 : }

	ret	0
$LN3@stbi__mad3:

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	xor	eax, eax

; 1032 :       stbi__addsizes_valid(a*b*c, add);
; 1033 : }

	ret	0
?stbi__mad3sizes_valid@@YAHHHHH@Z ENDP			; stbi__mad3sizes_valid
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__mad4sizes_valid@@YAHHHHHH@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
c$ = 24
d$ = 32
add$dead$ = 40
?stbi__mad4sizes_valid@@YAHHHHHH@Z PROC			; stbi__mad4sizes_valid, COMDAT

; 1038 : {

	mov	r10d, edx

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	SHORT $LN3@stbi__mad4
	test	edx, edx
	js	SHORT $LN3@stbi__mad4

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN25@stbi__mad4

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, 2147483647				; 7fffffffH
	div	r10d

; 1039 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	SHORT $LN3@stbi__mad4
$LN25@stbi__mad4:
	imul	ecx, r10d

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	SHORT $LN3@stbi__mad4
	test	r8d, r8d
	js	SHORT $LN3@stbi__mad4

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN24@stbi__mad4

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, 2147483647				; 7fffffffH
	div	r8d

; 1039 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	SHORT $LN3@stbi__mad4
$LN24@stbi__mad4:
	imul	ecx, r8d

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	SHORT $LN3@stbi__mad4
	test	r9d, r9d
	js	SHORT $LN3@stbi__mad4

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN23@stbi__mad4

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, 2147483647				; 7fffffffH
	div	r9d

; 1039 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	SHORT $LN3@stbi__mad4
$LN23@stbi__mad4:
	mov	eax, 1

; 1040 :       stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
; 1041 : }

	ret	0
$LN3@stbi__mad4:

; 1039 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	xor	eax, eax

; 1040 :       stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
; 1041 : }

	ret	0
?stbi__mad4sizes_valid@@YAHHHHHH@Z ENDP			; stbi__mad4sizes_valid
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__malloc_mad2@@YAPEAXHHH@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
add$ = 24
?stbi__malloc_mad2@@YAPEAXHHH@Z PROC			; stbi__malloc_mad2, COMDAT

; 1047 : {

	mov	r9d, edx
	mov	r11d, ecx

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	SHORT $LN19@stbi__mall
	test	edx, edx
	js	SHORT $LN19@stbi__mall

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	mov	r10d, 2147483647			; 7fffffffH
	jne	SHORT $LN11@stbi__mall
	imul	r9d, r11d
	mov	ecx, r9d
	jmp	SHORT $LN20@stbi__mall
$LN11@stbi__mall:

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, r10d
	div	r9d

; 1024 :    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);

	mov	ecx, r9d
	imul	ecx, r11d
	cmp	r11d, eax
	jg	SHORT $LN19@stbi__mall
$LN20@stbi__mall:

; 1002 :    if (b < 0) return 0;

	test	r8d, r8d
	js	SHORT $LN19@stbi__mall

; 1003 :    // now 0 <= b <= INT_MAX, hence also
; 1004 :    // 0 <= INT_MAX - b <= INTMAX.
; 1005 :    // And "a + b <= INT_MAX" (which might overflow) is the
; 1006 :    // same as a <= INT_MAX - b (no overflow)
; 1007 :    return a <= INT_MAX - b;

	sub	r10d, r8d

; 1024 :    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);

	cmp	ecx, r10d
	jg	SHORT $LN19@stbi__mall

; 1049 :    return stbi__malloc(a*b + add);

	lea	eax, DWORD PTR [rcx+r8]
	movsxd	rcx, eax

; 985  :     return STBI_MALLOC(size);

	rex_jmp	QWORD PTR __imp_malloc
$LN19@stbi__mall:

; 1048 :    if (!stbi__mad2sizes_valid(a, b, add)) return NULL;

	xor	eax, eax

; 1050 : }

	ret	0
?stbi__malloc_mad2@@YAPEAXHHH@Z ENDP			; stbi__malloc_mad2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__malloc_mad3@@YAPEAXHHHH@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
c$ = 24
add$ = 32
?stbi__malloc_mad3@@YAPEAXHHHH@Z PROC			; stbi__malloc_mad3, COMDAT

; 1054 : {

	mov	r11d, edx

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	SHORT $LN23@stbi__mall
	test	edx, edx
	js	SHORT $LN23@stbi__mall

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	mov	r10d, 2147483647			; 7fffffffH
	je	SHORT $LN25@stbi__mall

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, r10d
	div	r11d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	SHORT $LN23@stbi__mall
$LN25@stbi__mall:
	imul	ecx, r11d

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	SHORT $LN23@stbi__mall
	test	r8d, r8d
	js	SHORT $LN23@stbi__mall

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN24@stbi__mall

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, r10d
	div	r8d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	SHORT $LN23@stbi__mall
$LN24@stbi__mall:

; 1002 :    if (b < 0) return 0;

	test	r9d, r9d
	js	SHORT $LN23@stbi__mall

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	mov	eax, ecx

; 1007 :    return a <= INT_MAX - b;

	sub	r10d, r9d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	imul	eax, r8d
	cmp	eax, r10d
	jg	SHORT $LN23@stbi__mall

; 1056 :    return stbi__malloc(a*b*c + add);

	imul	ecx, r8d
	add	ecx, r9d
	movsxd	rcx, ecx

; 985  :     return STBI_MALLOC(size);

	rex_jmp	QWORD PTR __imp_malloc
$LN23@stbi__mall:

; 1055 :    if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;

	xor	eax, eax

; 1057 : }

	ret	0
?stbi__malloc_mad3@@YAPEAXHHHH@Z ENDP			; stbi__malloc_mad3
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__malloc_mad4@@YAPEAXHHHHH@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
c$ = 24
d$ = 32
add$dead$ = 40
?stbi__malloc_mad4@@YAPEAXHHHHH@Z PROC			; stbi__malloc_mad4, COMDAT

; 1061 : {

	mov	r11d, r9d
	mov	r10d, edx

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	SHORT $LN28@stbi__mall
	test	edx, edx
	js	SHORT $LN28@stbi__mall

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN31@stbi__mall

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, 2147483647				; 7fffffffH
	div	r10d

; 1039 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	SHORT $LN28@stbi__mall
$LN31@stbi__mall:
	imul	ecx, r10d

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	SHORT $LN28@stbi__mall
	test	r8d, r8d
	js	SHORT $LN28@stbi__mall

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN30@stbi__mall

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, 2147483647				; 7fffffffH
	div	r8d

; 1039 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	SHORT $LN28@stbi__mall
$LN30@stbi__mall:
	mov	r9d, ecx
	imul	r9d, r8d

; 1014 :    if (a < 0 || b < 0) return 0;

	test	r9d, r9d
	js	SHORT $LN28@stbi__mall
	test	r11d, r11d
	js	SHORT $LN28@stbi__mall

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN29@stbi__mall

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, 2147483647				; 7fffffffH
	div	r11d

; 1039 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	r9d, eax
	jg	SHORT $LN28@stbi__mall
$LN29@stbi__mall:

; 1063 :    return stbi__malloc(a*b*c*d + add);

	imul	ecx, r8d
	imul	ecx, r11d
	movsxd	rcx, ecx

; 985  :     return STBI_MALLOC(size);

	rex_jmp	QWORD PTR __imp_malloc
$LN28@stbi__mall:

; 1062 :    if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;

	xor	eax, eax

; 1064 : }

	ret	0
?stbi__malloc_mad4@@YAPEAXHHHHH@Z ENDP			; stbi__malloc_mad4
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__addints_valid@@YAHHH@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
?stbi__addints_valid@@YAHHH@Z PROC			; stbi__addints_valid, COMDAT

; 1070 :    if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow

	mov	r8d, ecx
	mov	eax, edx
	not	r8d
	not	eax
	xor	r8d, eax
	mov	r9d, ecx
	jns	SHORT $LN2@stbi__addi
	mov	eax, 1

; 1073 : }

	ret	0
$LN2@stbi__addi:

; 1071 :    if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.

	test	r9d, r9d
	jns	SHORT $LN3@stbi__addi
	test	edx, edx
	jns	SHORT $LN3@stbi__addi
	mov	eax, -2147483648			; ffffffff80000000H
	sub	eax, edx
	xor	edx, edx
	cmp	r9d, eax
	setge	dl

; 1073 : }

	mov	eax, edx
	ret	0
$LN3@stbi__addi:

; 1072 :    return a <= INT_MAX - b;

	mov	ecx, 2147483647				; 7fffffffH
	sub	ecx, edx
	xor	edx, edx
	cmp	r9d, ecx
	setle	dl

; 1073 : }

	mov	eax, edx
	ret	0
?stbi__addints_valid@@YAHHH@Z ENDP			; stbi__addints_valid
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__mul2shorts_valid@@YAHFF@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
?stbi__mul2shorts_valid@@YAHFF@Z PROC			; stbi__mul2shorts_valid, COMDAT

; 1077 : {

	movsx	r8d, dx

; 1078 :    if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow

	lea	eax, DWORD PTR [r8+1]
	cmp	ax, 1
	jbe	SHORT $LN3@stbi__mul2

; 1079 :    if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX/b; // product is positive, so similar to mul2sizes_valid

	movsx	r9d, cx
	mov	r10d, r8d
	xor	cx, r8w
	bt	cx, 15
	jb	SHORT $LN4@stbi__mul2
	mov	eax, 32767				; 00007fffH
	cdq
	idiv	r10d
	xor	ecx, ecx
$LN8@stbi__mul2:

; 1082 : }

	cmp	r9d, eax
	setle	cl
	mov	eax, ecx
	ret	0
$LN4@stbi__mul2:

; 1080 :    if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN

	mov	eax, -32768				; ffffffffffff8000H
	xor	ecx, ecx
	cdq
	idiv	r10d
	test	r8w, r8w
	js	SHORT $LN8@stbi__mul2

; 1081 :    return a >= SHRT_MIN / b;

	cmp	r9d, eax
	setge	cl
	mov	eax, ecx

; 1082 : }

	ret	0
$LN3@stbi__mul2:

; 1078 :    if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow

	mov	eax, 1

; 1082 : }

	ret	0
?stbi__mul2shorts_valid@@YAHFF@Z ENDP			; stbi__mul2shorts_valid
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT stbi_image_free
_TEXT	SEGMENT
retval_from_stbi_load$ = 8
stbi_image_free PROC					; COMDAT

; 1101 :    STBI_FREE(retval_from_stbi_load);

	rex_jmp	QWORD PTR __imp_free
stbi_image_free ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
_TEXT	SEGMENT
y$GSCopy$1$ = 64
ri$GSCopy$1$ = 72
$T1 = 80
tv1032 = 88
p$2 = 96
__$ArrayPad$ = 136
s$ = 224
x$ = 232
y$ = 240
comp$ = 248
req_comp$dead$ = 256
ri$ = 264
bpc$dead$ = 272
?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z PROC ; stbi__load_main, COMDAT

; 1136 : {

	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 152				; 00000098H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rax, QWORD PTR ri$[rsp]
	mov	rbx, r8

; 1137 :    memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
; 1138 :    ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed

	mov	r15d, 8
	mov	QWORD PTR y$GSCopy$1$[rsp], rbx

; 1139 :    ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order

	xor	ebp, ebp
	mov	QWORD PTR ri$GSCopy$1$[rsp], rax
	mov	r12, r9
	mov	r13, rdx
	mov	QWORD PTR [rax], r15
	mov	rdi, rcx
	mov	DWORD PTR [rax+8], ebp

; 5304 :    r = stbi__check_png_header(s);

	call	?stbi__check_png_header@@YAHPEAUstbi__context@@@Z ; stbi__check_png_header

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	rcx, QWORD PTR [rdi+208]
	lea	rsi, QWORD PTR [rdi+192]

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	rdx, QWORD PTR [rdi+216]
	lea	r14, QWORD PTR [rdi+200]
	mov	QWORD PTR [rsi], rcx
	mov	QWORD PTR [r14], rdx

; 1140 :    ri->num_channels = 0;
; 1141 : 
; 1142 :    // test the formats with a very explicit header first (at least a FOURCC
; 1143 :    // or distinctive magic number first)
; 1144 :    #ifndef STBI_NO_PNG
; 1145 :    if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);

	test	eax, eax
	je	$LN2@stbi__load

; 5266 :    if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {

	xor	edx, edx

; 5297 :    p.s = s;

	mov	QWORD PTR p$2[rsp], rdi

; 5266 :    if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {

	lea	r8d, QWORD PTR [r15-4]
	mov	ebx, ebp
	lea	rcx, QWORD PTR p$2[rsp]
	call	?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z ; stbi__parse_png_file
	test	eax, eax
	je	$LN151@stbi__load

; 5267 :       if (p->depth <= 8)

	mov	eax, DWORD PTR p$2[rsp+32]
	cmp	eax, r15d
	jle	SHORT $LN27@stbi__load

; 5268 :          ri->bits_per_channel = 8;
; 5269 :       else if (p->depth == 16)

	cmp	eax, 16
	jne	$LN26@stbi__load

; 5270 :          ri->bits_per_channel = 16;

	mov	r15d, eax
$LN27@stbi__load:

; 5271 :       else
; 5272 :          return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
; 5273 :       result = p->out;

	mov	rax, QWORD PTR ri$GSCopy$1$[rsp]
	mov	DWORD PTR [rax], r15d

; 5274 :       p->out = NULL;
; 5275 :       if (req_comp && req_comp != p->s->img_out_n) {

	mov	rcx, QWORD PTR p$2[rsp]
	mov	rbx, QWORD PTR p$2[rsp+24]
	mov	QWORD PTR p$2[rsp+24], rbp
	mov	edx, DWORD PTR [rcx+12]
	cmp	edx, 4
	je	SHORT $LN31@stbi__load

; 5276 :          if (ri->bits_per_channel == 8)

	mov	eax, DWORD PTR [rcx+4]
	mov	r9d, DWORD PTR [rcx]
	mov	rcx, rbx
	mov	DWORD PTR [rsp+32], eax
	cmp	r15d, 8
	jne	SHORT $LN29@stbi__load

; 5277 :             result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

	lea	r8d, QWORD PTR [r15-4]
	call	?stbi__convert_format@@YAPEAEPEAEHHII@Z	; stbi__convert_format
	jmp	SHORT $LN190@stbi__load
$LN29@stbi__load:

; 5278 :          else
; 5279 :             result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

	call	?stbi__convert_format16@@YAPEAGPEAGHHII@Z ; stbi__convert_format16
$LN190@stbi__load:

; 5280 :          p->s->img_out_n = req_comp;

	mov	rbx, rax
	mov	rax, QWORD PTR p$2[rsp]
	mov	DWORD PTR [rax+12], 4

; 5281 :          if (result == NULL) return result;

	test	rbx, rbx
	je	SHORT $LN20@stbi__load
	mov	rcx, QWORD PTR p$2[rsp]
$LN31@stbi__load:

; 5282 :       }
; 5283 :       *x = p->s->img_x;

	mov	eax, DWORD PTR [rcx]

; 5284 :       *y = p->s->img_y;

	mov	rsi, QWORD PTR y$GSCopy$1$[rsp]
	mov	DWORD PTR [r13], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rsi], eax

; 5285 :       if (n) *n = p->s->img_n;

	test	r12, r12
	je	SHORT $LN151@stbi__load
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [r12], eax
$LN151@stbi__load:

; 5286 :    }
; 5287 :    STBI_FREE(p->out);      p->out      = NULL;

	mov	rcx, QWORD PTR p$2[rsp+24]
	call	QWORD PTR __imp_free

; 5288 :    STBI_FREE(p->expanded); p->expanded = NULL;

	mov	rcx, QWORD PTR p$2[rsp+16]
	mov	QWORD PTR p$2[rsp+24], rbp
	call	QWORD PTR __imp_free

; 5289 :    STBI_FREE(p->idata);    p->idata    = NULL;

	mov	rcx, QWORD PTR p$2[rsp+8]
	mov	QWORD PTR p$2[rsp+16], rbp
	call	QWORD PTR __imp_free

; 5290 : 
; 5291 :    return result;

	mov	rbp, rbx
$LN20@stbi__load:

; 1140 :    ri->num_channels = 0;
; 1141 : 
; 1142 :    // test the formats with a very explicit header first (at least a FOURCC
; 1143 :    // or distinctive magic number first)
; 1144 :    #ifndef STBI_NO_PNG
; 1145 :    if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);

	mov	rax, rbp
	jmp	$LN1@stbi__load
$LN26@stbi__load:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BF@NOEEEFMF@bad?5bits_per_channel@
	mov	QWORD PTR [rdx+rcx], rax

; 1140 :    ri->num_channels = 0;
; 1141 : 
; 1142 :    // test the formats with a very explicit header first (at least a FOURCC
; 1143 :    // or distinctive magic number first)
; 1144 :    #ifndef STBI_NO_PNG
; 1145 :    if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);

	mov	rax, rbp
	jmp	$LN1@stbi__load
$LN2@stbi__load:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	DWORD PTR $T1[rsp], 1
	cmp	rcx, rdx
	jae	SHORT $LN47@stbi__load

; 1615 :       return *s->img_buffer++;

	movzx	edx, BYTE PTR [rcx]
	lea	rax, QWORD PTR [rcx+1]
	jmp	SHORT $LN191@stbi__load
$LN47@stbi__load:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], ebp
	je	$LN143@stbi__load

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rsi]
	movzx	edx, BYTE PTR [rax]
	inc	rax
$LN191@stbi__load:

; 5349 :    if (stbi__get8(s) != 'B') return 0;

	mov	QWORD PTR [rsi], rax
	cmp	dl, 66					; 00000042H
	jne	$LN143@stbi__load

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [r14]
	jb	SHORT $LN192@stbi__load

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], ebp
	je	$LN143@stbi__load

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rsi]
$LN192@stbi__load:

; 5350 :    if (stbi__get8(s) != 'M') return 0;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rsi], rax
	cmp	cl, 77					; 0000004dH
	jne	$LN143@stbi__load

; 1722 :    stbi__uint32 z = stbi__get16le(s);

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5352 :    stbi__get16le(s); // discard reserved

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5353 :    stbi__get16le(s); // discard reserved

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1722 :    stbi__uint32 z = stbi__get16le(s);

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1722 :    stbi__uint32 z = stbi__get16le(s);

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;

	mov	rcx, rdi
	mov	ebx, eax
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	shl	eax, 16
	add	eax, ebx

; 5356 :    r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);

	cmp	eax, 56					; 00000038H
	ja	SHORT $LN147@stbi__load
	mov	rdx, 72058693549559808			; 0100010000001000H
	bt	rdx, rax
	jb	SHORT $LN44@stbi__load
$LN147@stbi__load:
	cmp	eax, 108				; 0000006cH
	je	SHORT $LN44@stbi__load
	mov	ecx, ebp
	cmp	eax, 124				; 0000007cH
	jne	SHORT $LN45@stbi__load
$LN44@stbi__load:
	mov	ecx, 1
$LN45@stbi__load:

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	rax, QWORD PTR [rdi+208]
	mov	QWORD PTR [rsi], rax

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	rax, QWORD PTR [rdi+216]
	mov	QWORD PTR [r14], rax

; 1146 :    #endif
; 1147 :    #ifndef STBI_NO_BMP
; 1148 :    if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);

	test	ecx, ecx
	je	SHORT $LN152@stbi__load
	mov	rax, QWORD PTR ri$GSCopy$1$[rsp]
	mov	r9, r12
	mov	r8, QWORD PTR y$GSCopy$1$[rsp]
	mov	rdx, r13
	mov	QWORD PTR [rsp+40], rax
	mov	rcx, rdi
	mov	DWORD PTR [rsp+32], 4
	call	?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__bmp_load
	jmp	$LN1@stbi__load
$LN143@stbi__load:

; 6591 :    int r = stbi__gif_test_raw(s);

	mov	rax, QWORD PTR [rdi+208]
	mov	QWORD PTR [rsi], rax
	mov	rax, QWORD PTR [rdi+216]
	mov	QWORD PTR [r14], rax
	jmp	SHORT $LN3@stbi__load
$LN152@stbi__load:

; 1146 :    #endif
; 1147 :    #ifndef STBI_NO_BMP
; 1148 :    if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);

	mov	rbx, QWORD PTR y$GSCopy$1$[rsp]
$LN3@stbi__load:

; 6591 :    int r = stbi__gif_test_raw(s);

	mov	rcx, rdi
	call	?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z ; stbi__gif_test_raw

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	rcx, QWORD PTR [rdi+208]
	mov	QWORD PTR [rsi], rcx

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	rcx, QWORD PTR [rdi+216]
	mov	QWORD PTR [r14], rcx

; 1149 :    #endif
; 1150 :    #ifndef STBI_NO_GIF
; 1151 :    if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);

	mov	rcx, rdi
	test	eax, eax
	je	SHORT $LN4@stbi__load
	mov	r9, r12
	mov	r8, rbx
	mov	rdx, r13
	call	?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__gif_load
	jmp	$LN1@stbi__load
$LN4@stbi__load:

; 1704 :    stbi__uint32 z = stbi__get16be(s);

	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 1705 :    return (z << 16) + stbi__get16be(s);

	mov	rcx, rdi
	mov	ebx, eax
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	rcx, QWORD PTR [rdi+208]

; 1705 :    return (z << 16) + stbi__get16be(s);

	shl	ebx, 16

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	QWORD PTR [rsi], rcx

; 1705 :    return (z << 16) + stbi__get16be(s);

	add	eax, ebx

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	rcx, QWORD PTR [rdi+216]
	mov	QWORD PTR [r14], rcx

; 1152 :    #endif
; 1153 :    #ifndef STBI_NO_PSD
; 1154 :    if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);

	mov	rcx, rdi
	cmp	eax, 943870035				; 38425053H
	jne	SHORT $LN5@stbi__load
	mov	rax, QWORD PTR ri$GSCopy$1$[rsp]
	mov	r9, r12
	mov	r8, QWORD PTR y$GSCopy$1$[rsp]
	mov	rdx, r13
	mov	QWORD PTR [rsp+40], rax
	call	?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z ; stbi__psd_load
	jmp	$LN1@stbi__load
$LN5@stbi__load:

; 6349 :    if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))

	lea	rdx, OFFSET FLAT:??_C@_04KBFEPHFH@S?$IA?v4@
	call	?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ; stbi__pic_is4
	test	eax, eax
	je	SHORT $LN193@stbi__load

; 6350 :       return 0;
; 6351 : 
; 6352 :    for(i=0;i<84;++i)

	mov	ebx, 84					; 00000054H
$LL77@stbi__load:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rsi]
	cmp	rax, QWORD PTR [r14]
	jae	SHORT $LN82@stbi__load

; 1615 :       return *s->img_buffer++;

	inc	rax
	mov	QWORD PTR [rsi], rax
	jmp	SHORT $LN75@stbi__load
$LN82@stbi__load:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], ebp
	je	SHORT $LN75@stbi__load

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	inc	QWORD PTR [rsi]
$LN75@stbi__load:

; 6352 :    for(i=0;i<84;++i)

	sub	rbx, 1
	jne	SHORT $LL77@stbi__load

; 6353 :       stbi__get8(s);
; 6354 : 
; 6355 :    if (!stbi__pic_is4(s,"PICT"))

	lea	rdx, OFFSET FLAT:??_C@_04ELNJHLFH@PICT@
	mov	rcx, rdi
	call	?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ; stbi__pic_is4
	test	eax, eax
	jne	$LN79@stbi__load
$LN193@stbi__load:

; 985  :     return STBI_MALLOC(size);

	mov	rdx, QWORD PTR [rdi+208]
	mov	rcx, r14
	mov	rax, QWORD PTR [rdi+216]
	mov	r8, rsi
	mov	QWORD PTR [rsi], rdx
	mov	QWORD PTR [rcx], rax
	mov	ecx, 18568				; 00004888H
	call	QWORD PTR __imp_malloc

; 4043 :    stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));

	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB

; 985  :     return STBI_MALLOC(size);

	mov	rbx, rax

; 4043 :    stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));

	mov	QWORD PTR tv1032[rsp], rdx

; 4044 :    if (!j) return stbi__err("outofmem", "Out of memory");

	test	rax, rax
	jne	SHORT $LN88@stbi__load

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	mov	QWORD PTR [rdx+rcx], rax
$LN7@stbi__load:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rsi]
	cmp	rax, QWORD PTR [r14]
	jae	$LN128@stbi__load

; 1615 :       return *s->img_buffer++;

	movzx	ebx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rsi], rax
	jmp	$LN127@stbi__load
$LN88@stbi__load:

; 4045 :    memset(j, 0, sizeof(stbi__jpeg));

	lea	rcx, QWORD PTR [rax+8]
	xor	edx, edx
	mov	r8d, 18560				; 00004880H
	call	memset

; 4046 :    j->s = s;
; 4047 :    stbi__setup_jpeg(j);

	mov	rcx, rbx
	mov	QWORD PTR [rbx], rdi
	call	?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__setup_jpeg

; 3369 :    m = stbi__get_marker(z);

	mov	rcx, rbx
	mov	DWORD PTR [rbx+18504], ebp
	mov	DWORD PTR [rbx+18508], -1
	mov	BYTE PTR [rbx+18472], 255		; 000000ffH
	call	?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker

; 3370 :    if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");

	cmp	al, 216					; 000000d8H
	je	SHORT $LN99@stbi__load

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	lea	rdx, OFFSET FLAT:??_C@_06CLMBLEP@no?5SOI@

; 3370 :    if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");

	mov	DWORD PTR $T1[rsp], ebp

; 978  :    stbi__g_failure_reason = str;

	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR tv1032[rsp]
	mov	QWORD PTR [rax+rcx], rdx
$LN99@stbi__load:

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	rax, QWORD PTR [rdi+208]

; 4050 :    STBI_FREE(j);

	mov	rcx, rbx

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	QWORD PTR [rsi], rax

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	rax, QWORD PTR [rdi+216]
	mov	QWORD PTR [r14], rax

; 4050 :    STBI_FREE(j);

	call	QWORD PTR __imp_free

; 1160 :    #endif
; 1161 : 
; 1162 :    // then the formats that can end up attempting to load with just 1 or 2
; 1163 :    // bytes matching expectations; these are prone to false positives, so
; 1164 :    // try them later
; 1165 :    #ifndef STBI_NO_JPEG
; 1166 :    if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);

	cmp	DWORD PTR $T1[rsp], ebp
	je	$LN7@stbi__load

; 985  :     return STBI_MALLOC(size);

	mov	ecx, 18568				; 00004888H
	call	QWORD PTR __imp_malloc
	mov	rbx, rax

; 4030 :    if (!j) return stbi__errpuc("outofmem", "Out of memory");

	test	rax, rax
	jne	SHORT $LN117@stbi__load

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR tv1032[rsp]
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	mov	QWORD PTR [rdx+rcx], rax

; 1140 :    ri->num_channels = 0;
; 1141 : 
; 1142 :    // test the formats with a very explicit header first (at least a FOURCC
; 1143 :    // or distinctive magic number first)
; 1144 :    #ifndef STBI_NO_PNG
; 1145 :    if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);

	mov	rax, rbp
	jmp	$LN1@stbi__load
$LN117@stbi__load:

; 4031 :    memset(j, 0, sizeof(stbi__jpeg));

	lea	rcx, QWORD PTR [rax+8]
	xor	edx, edx
	mov	r8d, 18560				; 00004880H
	call	memset

; 4032 :    STBI_NOTUSED(ri);
; 4033 :    j->s = s;
; 4034 :    stbi__setup_jpeg(j);

	mov	rcx, rbx
	mov	QWORD PTR [rbx], rdi
	call	?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__setup_jpeg

; 4035 :    result = load_jpeg_image(j, x,y,comp,req_comp);

	mov	r8, QWORD PTR y$GSCopy$1$[rsp]
	mov	rdx, r13
	mov	rcx, rbx
	mov	DWORD PTR [rsp+32], 4
	mov	r9, r12
	call	?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z ; load_jpeg_image

; 4036 :    STBI_FREE(j);

	mov	rcx, rbx
	mov	rbp, rax
	call	QWORD PTR __imp_free

; 1160 :    #endif
; 1161 : 
; 1162 :    // then the formats that can end up attempting to load with just 1 or 2
; 1163 :    // bytes matching expectations; these are prone to false positives, so
; 1164 :    // try them later
; 1165 :    #ifndef STBI_NO_JPEG
; 1166 :    if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);

	mov	rax, rbp
	jmp	$LN1@stbi__load
$LN128@stbi__load:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], ebp
	je	SHORT $LN129@stbi__load

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rsi]
	movzx	ebx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rsi], rax
	jmp	SHORT $LN127@stbi__load
$LN129@stbi__load:

; 1619 :    }
; 1620 :    return 0;

	xor	bl, bl
$LN127@stbi__load:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [r14]
	jae	SHORT $LN132@stbi__load

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rsi], rax
	jmp	SHORT $LN131@stbi__load
$LN132@stbi__load:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], ebp
	je	SHORT $LN133@stbi__load

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rsi]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rsi], rax
	jmp	SHORT $LN131@stbi__load
$LN133@stbi__load:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN131@stbi__load:

; 7498 :    if (p != 'P' || (t != '5' && t != '6')) {

	cmp	bl, 80					; 00000050H
	jne	SHORT $LN125@stbi__load
	sub	cl, 53					; 00000035H
	cmp	cl, 1
	ja	SHORT $LN125@stbi__load

; 1167 :    #endif
; 1168 :    #ifndef STBI_NO_PNM
; 1169 :    if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);

	mov	rax, QWORD PTR ri$GSCopy$1$[rsp]
	mov	r9, r12
	mov	r8, QWORD PTR y$GSCopy$1$[rsp]
	mov	rdx, r13
	mov	rcx, rdi
	mov	QWORD PTR [rsp+40], rax
	call	?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__pnm_load
	jmp	$LN1@stbi__load
$LN125@stbi__load:

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	rax, QWORD PTR [rdi+208]

; 1170 :    #endif
; 1171 : 
; 1172 :    #ifndef STBI_NO_HDR
; 1173 :    if (stbi__hdr_test(s)) {

	mov	rcx, rdi

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	QWORD PTR [rsi], rax

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	rax, QWORD PTR [rdi+216]
	mov	QWORD PTR [r14], rax

; 1170 :    #endif
; 1171 : 
; 1172 :    #ifndef STBI_NO_HDR
; 1173 :    if (stbi__hdr_test(s)) {

	call	?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test
	mov	rcx, rdi
	test	eax, eax
	je	SHORT $LN9@stbi__load

; 1174 :       float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);

	mov	rax, QWORD PTR ri$GSCopy$1$[rsp]
	mov	r9, r12
	mov	rsi, QWORD PTR y$GSCopy$1$[rsp]
	mov	rdx, r13
	mov	QWORD PTR [rsp+40], rax
	mov	r8, rsi
	mov	DWORD PTR [rsp+32], 4
	call	?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__hdr_load

; 1175 :       return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);

	mov	r8d, DWORD PTR [rsi]
	mov	r9d, 4
	mov	edx, DWORD PTR [r13]
	mov	rcx, rax
	call	?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z	; stbi__hdr_to_ldr
	jmp	SHORT $LN1@stbi__load
$LN9@stbi__load:

; 1176 :    }
; 1177 :    #endif
; 1178 : 
; 1179 :    #ifndef STBI_NO_TGA
; 1180 :    // test tga last because it's a crappy test!
; 1181 :    if (stbi__tga_test(s))

	call	?stbi__tga_test@@YAHPEAUstbi__context@@@Z ; stbi__tga_test
	test	eax, eax
	je	SHORT $LN10@stbi__load

; 1182 :       return stbi__tga_load(s,x,y,comp,req_comp, ri);

	mov	rax, QWORD PTR ri$GSCopy$1$[rsp]
	mov	r9, r12
	mov	r8, QWORD PTR y$GSCopy$1$[rsp]
	mov	rdx, r13
	mov	QWORD PTR [rsp+40], rax
	mov	rcx, rdi
	mov	DWORD PTR [rsp+32], 4
	call	?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__tga_load
	jmp	SHORT $LN1@stbi__load
$LN10@stbi__load:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	lea	rdx, OFFSET FLAT:??_C@_0BD@CBEDEJPH@unknown?5image?5type@
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR tv1032[rsp]
	mov	QWORD PTR [rax+rcx], rdx

; 1183 :    #endif
; 1184 : 
; 1185 :    return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");

	xor	eax, eax
	jmp	SHORT $LN1@stbi__load
$LN79@stbi__load:

; 6358 :    return 1;

	mov	rax, QWORD PTR [rdi+208]

; 1155 :    #else
; 1156 :    STBI_NOTUSED(bpc);
; 1157 :    #endif
; 1158 :    #ifndef STBI_NO_PIC
; 1159 :    if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);

	mov	r9, r12
	mov	r8, QWORD PTR y$GSCopy$1$[rsp]
	mov	rdx, r13

; 6358 :    return 1;

	mov	QWORD PTR [rsi], rax

; 1155 :    #else
; 1156 :    STBI_NOTUSED(bpc);
; 1157 :    #endif
; 1158 :    #ifndef STBI_NO_PIC
; 1159 :    if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);

	mov	rcx, rdi

; 6358 :    return 1;

	mov	rax, QWORD PTR [rdi+216]
	mov	QWORD PTR [r14], rax

; 1155 :    #else
; 1156 :    STBI_NOTUSED(bpc);
; 1157 :    #endif
; 1158 :    #ifndef STBI_NO_PIC
; 1159 :    if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);

	call	?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__pic_load
$LN1@stbi__load:

; 1186 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 152				; 00000098H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z ENDP ; stbi__load_main
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z
_TEXT	SEGMENT
orig$ = 48
w$ = 56
h$ = 64
channels$ = 72
?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z PROC		; stbi__convert_16_to_8, COMDAT

; 1189 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, edx
	mov	rsi, rcx

; 1190 :    int i;
; 1191 :    int img_len = w * h * channels;

	imul	ebx, r8d
	imul	ebx, r9d

; 1192 :    stbi_uc *reduced;
; 1193 : 
; 1194 :    reduced = (stbi_uc *) stbi__malloc(img_len);

	movsxd	rbp, ebx

; 985  :     return STBI_MALLOC(size);

	mov	rcx, rbp
	call	QWORD PTR __imp_malloc
	mov	rdi, rax

; 1195 :    if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

	test	rax, rax
	jne	SHORT $LN5@stbi__conv

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	mov	QWORD PTR [rdx+rcx], rax

; 1195 :    if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

	xor	eax, eax
	jmp	$LN1@stbi__conv
$LN5@stbi__conv:

; 1196 : 
; 1197 :    for (i = 0; i < img_len; ++i)

	xor	edx, edx
	mov	r8d, edx
	test	ebx, ebx
	jle	$LN14@stbi__conv
	cmp	ebx, 32					; 00000020H
	jb	$LN14@stbi__conv
	lea	eax, DWORD PTR [rbx-1]
	movsxd	rcx, eax
	lea	rax, QWORD PTR [rsi+rcx*2]
	lea	r9, QWORD PTR [rcx+rdi]
	cmp	rdi, rax
	ja	SHORT $LN15@stbi__conv
	cmp	r9, rsi
	jae	$LN14@stbi__conv
$LN15@stbi__conv:

; 1198 :       reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

	mov	eax, ebx
	and	eax, -2147483617			; ffffffff8000001fH
	jge	SHORT $LN23@stbi__conv
	dec	eax
	or	eax, -32				; ffffffffffffffe0H
	inc	eax
$LN23@stbi__conv:
	sub	ebx, eax
	mov	eax, 8
	movsxd	rcx, ebx
	movd	xmm2, eax
	lea	rax, QWORD PTR [rsi+32]
	npad	4
$LL4@stbi__conv:
	movdqu	xmm0, XMMWORD PTR [rax-32]
	add	r8d, 32					; 00000020H
	movdqu	xmm1, XMMWORD PTR [rax-16]
	lea	rax, QWORD PTR [rax+64]
	psrlw	xmm0, xmm2
	psrlw	xmm1, xmm2
	andps	xmm0, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	andps	xmm1, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	packuswb xmm0, xmm0
	movq	QWORD PTR [rdx+rdi], xmm0
	movdqu	xmm0, XMMWORD PTR [rax-64]
	packuswb xmm1, xmm1
	movq	QWORD PTR [rdx+rdi+8], xmm1
	movdqu	xmm1, XMMWORD PTR [rax-48]
	psrlw	xmm0, xmm2
	psrlw	xmm1, xmm2
	andps	xmm0, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	andps	xmm1, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	packuswb xmm0, xmm0
	movq	QWORD PTR [rdx+rdi+16], xmm0
	packuswb xmm1, xmm1
	movq	QWORD PTR [rdx+rdi+24], xmm1
	add	rdx, 32					; 00000020H
	cmp	rdx, rcx
	jl	SHORT $LL4@stbi__conv
$LN14@stbi__conv:

; 1196 : 
; 1197 :    for (i = 0; i < img_len; ++i)

	movsxd	rax, r8d
	cmp	rax, rbp
	jge	SHORT $LN3@stbi__conv
$LL13@stbi__conv:

; 1198 :       reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

	movzx	ecx, BYTE PTR [rsi+rax*2+1]
	mov	BYTE PTR [rax+rdi], cl
	inc	rax
	cmp	rax, rbp
	jl	SHORT $LL13@stbi__conv
$LN3@stbi__conv:

; 1199 : 
; 1200 :    STBI_FREE(orig);

	mov	rcx, rsi
	call	QWORD PTR __imp_free

; 1201 :    return reduced;

	mov	rax, rdi
$LN1@stbi__conv:

; 1202 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z ENDP		; stbi__convert_16_to_8
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__vertical_flip@@YAXPEAXHHH@Z
_TEXT	SEGMENT
temp$ = 32
__$ArrayPad$ = 2080
image$ = 2176
w$ = 2184
h$ = 2192
bytes_per_pixel$ = 2200
?stbi__vertical_flip@@YAXPEAXHHH@Z PROC			; stbi__vertical_flip, COMDAT

; 1221 : {

	mov	r11, rsp
	push	r12
	push	r15
	sub	rsp, 2152				; 00000868H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r12, rcx

; 1222 :    int row;
; 1223 :    size_t bytes_per_row = (size_t)w * bytes_per_pixel;

	movsxd	r15, r9d

; 1224 :    stbi_uc temp[2048];
; 1225 :    stbi_uc *bytes = (stbi_uc *)image;
; 1226 : 
; 1227 :    for (row = 0; row < (h>>1); row++) {

	mov	ecx, r8d
	movsxd	rax, edx
	sar	ecx, 1
	imul	r15, rax
	test	ecx, ecx
	jle	$LN3@stbi__vert
	mov	QWORD PTR [r11-24], rbx
	lea	eax, DWORD PTR [r8-1]
	mov	QWORD PTR [r11-32], rbp
	mov	QWORD PTR [r11-40], rsi
	mov	QWORD PTR [r11-48], rdi
	mov	QWORD PTR [r11-56], r13
	movsxd	rbx, eax
	imul	rbx, r15
	mov	QWORD PTR [r11-64], r14
	add	rbx, r12
	mov	r13d, ecx
	npad	13
$LL4@stbi__vert:

; 1228 :       stbi_uc *row0 = bytes + row*bytes_per_row;

	mov	rsi, r12

; 1229 :       stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;

	mov	rbp, rbx

; 1230 :       // swap row0 with row1
; 1231 :       size_t bytes_left = bytes_per_row;

	mov	r14, r15

; 1232 :       while (bytes_left) {

	test	r15, r15
	je	SHORT $LN2@stbi__vert
	npad	2
$LL5@stbi__vert:

; 1233 :          size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);

	mov	edi, 2048				; 00000800H

; 1234 :          memcpy(temp, row0, bytes_copy);

	lea	rcx, QWORD PTR temp$[rsp]
	cmp	r14, rdi
	mov	rdx, rsi
	cmovb	rdi, r14
	mov	r8, rdi
	call	memcpy

; 1235 :          memcpy(row0, row1, bytes_copy);

	mov	r8, rdi
	mov	rdx, rbp
	mov	rcx, rsi
	call	memcpy

; 1236 :          memcpy(row1, temp, bytes_copy);

	mov	r8, rdi
	lea	rdx, QWORD PTR temp$[rsp]
	mov	rcx, rbp
	call	memcpy

; 1237 :          row0 += bytes_copy;

	add	rsi, rdi

; 1238 :          row1 += bytes_copy;

	add	rbp, rdi

; 1239 :          bytes_left -= bytes_copy;

	sub	r14, rdi
	jne	SHORT $LL5@stbi__vert
$LN2@stbi__vert:

; 1224 :    stbi_uc temp[2048];
; 1225 :    stbi_uc *bytes = (stbi_uc *)image;
; 1226 : 
; 1227 :    for (row = 0; row < (h>>1); row++) {

	add	r12, r15
	sub	rbx, r15
	sub	r13, 1
	jne	SHORT $LL4@stbi__vert
	mov	r14, QWORD PTR [rsp+2104]
	mov	r13, QWORD PTR [rsp+2112]
	mov	rdi, QWORD PTR [rsp+2120]
	mov	rsi, QWORD PTR [rsp+2128]
	mov	rbp, QWORD PTR [rsp+2136]
	mov	rbx, QWORD PTR [rsp+2144]
$LN3@stbi__vert:

; 1240 :       }
; 1241 :    }
; 1242 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 2152				; 00000868H
	pop	r15
	pop	r12
	ret	0
?stbi__vertical_flip@@YAXPEAXHHH@Z ENDP			; stbi__vertical_flip
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z
_TEXT	SEGMENT
ri$ = 64
__$ArrayPad$ = 80
s$ = 160
x$ = 168
y$ = 176
comp$ = 184
req_comp$dead$ = 192
?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z PROC ; stbi__load_and_postprocess_8bit, COMDAT

; 1259 : {

	push	rbx
	push	r14
	push	r15
	sub	rsp, 128				; 00000080H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1260 :    stbi__result_info ri;
; 1261 :    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

	lea	rax, QWORD PTR ri$[rsp]
	mov	r15, r8
	mov	QWORD PTR [rsp+40], rax
	mov	r14, rdx
	call	?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z ; stbi__load_main
	mov	rbx, rax

; 1262 : 
; 1263 :    if (result == NULL)

	test	rax, rax
	je	$LN1@stbi__load
$LN2@stbi__load:

; 1264 :       return NULL;
; 1265 : 
; 1266 :    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1267 :    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
; 1268 : 
; 1269 :    if (ri.bits_per_channel != 8) {

	cmp	DWORD PTR ri$[rsp], 8
	je	$LN3@stbi__load
	mov	QWORD PTR [rsp+120], rbp
	mov	QWORD PTR [rsp+112], rsi
	mov	QWORD PTR [rsp+104], rdi

; 1191 :    int img_len = w * h * channels;

	mov	edi, DWORD PTR [r14]
	imul	edi, DWORD PTR [r15]

; 1264 :       return NULL;
; 1265 : 
; 1266 :    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1267 :    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
; 1268 : 
; 1269 :    if (ri.bits_per_channel != 8) {

	mov	QWORD PTR [rsp+96], r12

; 1191 :    int img_len = w * h * channels;

	shl	edi, 2

; 1192 :    stbi_uc *reduced;
; 1193 : 
; 1194 :    reduced = (stbi_uc *) stbi__malloc(img_len);

	movsxd	rbp, edi

; 985  :     return STBI_MALLOC(size);

	mov	rcx, rbp
	call	QWORD PTR __imp_malloc
	mov	rsi, rax

; 1195 :    if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

	mov	r12d, 8
	test	rax, rax
	jne	SHORT $LN16@stbi__load

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	mov	QWORD PTR [rdx+rcx], rax

; 1195 :    if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

	xor	edx, edx
	mov	ebx, edx
	jmp	$LN12@stbi__load
$LN16@stbi__load:

; 1196 : 
; 1197 :    for (i = 0; i < img_len; ++i)

	xor	edx, edx
	mov	r8d, edx
	test	edi, edi
	jle	$LN25@stbi__load
	cmp	edi, 32					; 00000020H
	jb	$LN25@stbi__load
	lea	eax, DWORD PTR [rdi-1]
	movsxd	rcx, eax
	lea	rax, QWORD PTR [rbx+rcx*2]
	lea	r9, QWORD PTR [rcx+rsi]
	cmp	rsi, rax
	ja	SHORT $LN26@stbi__load
	cmp	r9, rbx
	jae	$LN25@stbi__load
$LN26@stbi__load:

; 1198 :       reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

	mov	eax, edi
	and	eax, -2147483617			; ffffffff8000001fH
	jge	SHORT $LN34@stbi__load
	dec	eax
	or	eax, -32				; ffffffffffffffe0H
	inc	eax
$LN34@stbi__load:
	sub	edi, eax
	movd	xmm2, r12d

; 1196 : 
; 1197 :    for (i = 0; i < img_len; ++i)

	movsxd	rcx, edi

; 1198 :       reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

	lea	rax, QWORD PTR [rbx+32]
	npad	11
$LL15@stbi__load:
	movdqu	xmm0, XMMWORD PTR [rax-32]
	add	r8d, 32					; 00000020H
	movdqu	xmm1, XMMWORD PTR [rax-16]
	lea	rax, QWORD PTR [rax+64]
	psrlw	xmm0, xmm2
	psrlw	xmm1, xmm2
	andps	xmm0, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	andps	xmm1, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	packuswb xmm0, xmm0
	movq	QWORD PTR [rdx+rsi], xmm0
	movdqu	xmm0, XMMWORD PTR [rax-64]
	packuswb xmm1, xmm1
	movq	QWORD PTR [rdx+rsi+8], xmm1
	movdqu	xmm1, XMMWORD PTR [rax-48]
	psrlw	xmm0, xmm2
	psrlw	xmm1, xmm2
	andps	xmm0, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	andps	xmm1, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	packuswb xmm0, xmm0
	movq	QWORD PTR [rdx+rsi+16], xmm0
	packuswb xmm1, xmm1
	movq	QWORD PTR [rdx+rsi+24], xmm1
	add	rdx, 32					; 00000020H
	cmp	rdx, rcx
	jl	SHORT $LL15@stbi__load
$LN25@stbi__load:

; 1196 : 
; 1197 :    for (i = 0; i < img_len; ++i)

	movsxd	rax, r8d
	cmp	rax, rbp
	jge	SHORT $LN14@stbi__load
$LL24@stbi__load:

; 1198 :       reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

	movzx	ecx, BYTE PTR [rbx+rax*2+1]
	mov	BYTE PTR [rax+rsi], cl
	inc	rax
	cmp	rax, rbp
	jl	SHORT $LL24@stbi__load
$LN14@stbi__load:

; 1199 : 
; 1200 :    STBI_FREE(orig);

	mov	rcx, rbx
	call	QWORD PTR __imp_free

; 1201 :    return reduced;

	mov	rbx, rsi
$LN12@stbi__load:

; 1270 :       result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
; 1271 :       ri.bits_per_channel = 8;

	mov	rdi, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+120]
	mov	DWORD PTR ri$[rsp], r12d
	mov	r12, QWORD PTR [rsp+96]
$LN3@stbi__load:

; 1272 :    }
; 1273 : 
; 1274 :    // @TODO: move stbi__convert_format to here
; 1275 : 
; 1276 :    if (stbi__vertically_flip_on_load) {

	mov	rax, QWORD PTR gs:88
	mov	ecx, OFFSET FLAT:?stbi__vertically_flip_on_load_set@@3HA
	mov	rax, QWORD PTR [rax]
	cmp	DWORD PTR [rcx+rax], 0
	je	SHORT $LN8@stbi__load
	mov	ecx, OFFSET FLAT:?stbi__vertically_flip_on_load_local@@3HA
	mov	eax, DWORD PTR [rcx+rax]
	jmp	SHORT $LN9@stbi__load
$LN8@stbi__load:
	mov	eax, DWORD PTR ?stbi__vertically_flip_on_load_global@@3HA
$LN9@stbi__load:
	test	eax, eax
	je	SHORT $LN4@stbi__load

; 1277 :       int channels = req_comp ? req_comp : *comp;
; 1278 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));

	mov	r8d, DWORD PTR [r15]
	mov	r9d, 4
	mov	edx, DWORD PTR [r14]
	mov	rcx, rbx
	call	?stbi__vertical_flip@@YAXPEAXHHH@Z	; stbi__vertical_flip
$LN4@stbi__load:

; 1279 :    }
; 1280 : 
; 1281 :    return (unsigned char *) result;

	mov	rax, rbx
$LN1@stbi__load:

; 1282 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 128				; 00000080H
	pop	r15
	pop	r14
	pop	rbx
	ret	0
?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__load_and_postprocess_8bit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z
_TEXT	SEGMENT
f$ = 32
__$ArrayPad$ = 40
filename$ = 64
mode$dead$ = 72
?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z PROC		; stbi__fopen, COMDAT

; 1336 : {

	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1337 :    FILE *f;
; 1338 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1339 :    wchar_t wMode[64];
; 1340 :    wchar_t wFilename[1024];
; 1341 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
; 1342 :       return 0;
; 1343 : 
; 1344 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
; 1345 :       return 0;
; 1346 : 
; 1347 : #if defined(_MSC_VER) && _MSC_VER >= 1400
; 1348 : 	if (0 != _wfopen_s(&f, wFilename, wMode))
; 1349 : 		f = 0;
; 1350 : #else
; 1351 :    f = _wfopen(wFilename, wMode);
; 1352 : #endif
; 1353 : 
; 1354 : #elif defined(_MSC_VER) && _MSC_VER >= 1400
; 1355 :    if (0 != fopen_s(&f, filename, mode))

	mov	rdx, rcx
	lea	r8, OFFSET FLAT:??_C@_02JDPG@rb@
	lea	rcx, QWORD PTR f$[rsp]
	call	QWORD PTR __imp_fopen_s
	test	eax, eax
	je	SHORT $LN4@stbi__fope

; 1356 :       f=0;
; 1357 : #else
; 1358 :    f = fopen(filename, mode);
; 1359 : #endif
; 1360 :    return f;

	xor	eax, eax

; 1361 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	ret	0
$LN4@stbi__fope:

; 1356 :       f=0;
; 1357 : #else
; 1358 :    f = fopen(filename, mode);
; 1359 : #endif
; 1360 :    return f;

	mov	rax, QWORD PTR f$[rsp]

; 1361 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	ret	0
?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z ENDP		; stbi__fopen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT stbi_load
_TEXT	SEGMENT
f$1 = 48
s$2 = 64
__$ArrayPad$ = 288
filename$ = 336
x$ = 344
y$ = 352
comp$dead$ = 360
req_comp$dead$ = 368
stbi_load PROC						; COMDAT

; 1365 : {

$LN27:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	lea	rbp, QWORD PTR [rsp-48]
	sub	rsp, 304				; 00000130H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rdi, rdx
	mov	rsi, r8

; 1355 :    if (0 != fopen_s(&f, filename, mode))

	mov	rdx, rcx
	lea	r8, OFFSET FLAT:??_C@_02JDPG@rb@
	lea	rcx, QWORD PTR f$1[rsp]
	call	QWORD PTR __imp_fopen_s
	test	eax, eax
	je	SHORT $LN20@stbi_load

; 1356 :       f=0;

	xor	ebx, ebx
	mov	QWORD PTR f$1[rsp], rbx
	jmp	SHORT $LN5@stbi_load
$LN20@stbi_load:

; 979  :    return 0;
; 980  : }
; 981  : #endif
; 982  : 
; 983  : static void *stbi__malloc(size_t size)
; 984  : {
; 985  :     return STBI_MALLOC(size);
; 986  : }
; 987  : 
; 988  : // stb_image uses ints pervasively, including for offset calculations.
; 989  : // therefore the largest decoded image size we can support with the
; 990  : // current code, even on 64-bit targets, is INT_MAX. this is not a
; 991  : // significant limitation for the intended use case.
; 992  : //
; 993  : // we do, however, need to make sure our size calculations don't
; 994  : // overflow. hence a few helper functions for size calculations that
; 995  : // multiply integers together, making sure that they're non-negative
; 996  : // and no overflow occurs.
; 997  : 
; 998  : // return 1 if the sum is valid, 0 on overflow.
; 999  : // negative terms are considered invalid.
; 1000 : static int stbi__addsizes_valid(int a, int b)
; 1001 : {
; 1002 :    if (b < 0) return 0;
; 1003 :    // now 0 <= b <= INT_MAX, hence also
; 1004 :    // 0 <= INT_MAX - b <= INTMAX.
; 1005 :    // And "a + b <= INT_MAX" (which might overflow) is the
; 1006 :    // same as a <= INT_MAX - b (no overflow)
; 1007 :    return a <= INT_MAX - b;
; 1008 : }
; 1009 : 
; 1010 : // returns 1 if the product is valid, 0 on overflow.
; 1011 : // negative factors are considered invalid.
; 1012 : static int stbi__mul2sizes_valid(int a, int b)
; 1013 : {
; 1014 :    if (a < 0 || b < 0) return 0;
; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe
; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;
; 1018 : }
; 1019 : 
; 1020 : #if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
; 1021 : // returns 1 if "a*b + add" has no negative terms/factors and doesn't overflow
; 1022 : static int stbi__mad2sizes_valid(int a, int b, int add)
; 1023 : {
; 1024 :    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
; 1025 : }
; 1026 : #endif
; 1027 : 
; 1028 : // returns 1 if "a*b*c + add" has no negative terms/factors and doesn't overflow
; 1029 : static int stbi__mad3sizes_valid(int a, int b, int c, int add)
; 1030 : {
; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
; 1032 :       stbi__addsizes_valid(a*b*c, add);
; 1033 : }
; 1034 : 
; 1035 : // returns 1 if "a*b*c*d + add" has no negative terms/factors and doesn't overflow
; 1036 : #if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
; 1037 : static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
; 1038 : {
; 1039 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
; 1040 :       stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
; 1041 : }
; 1042 : #endif
; 1043 : 
; 1044 : #if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
; 1045 : // mallocs with size overflow checking
; 1046 : static void *stbi__malloc_mad2(int a, int b, int add)
; 1047 : {
; 1048 :    if (!stbi__mad2sizes_valid(a, b, add)) return NULL;
; 1049 :    return stbi__malloc(a*b + add);
; 1050 : }
; 1051 : #endif
; 1052 : 
; 1053 : static void *stbi__malloc_mad3(int a, int b, int c, int add)
; 1054 : {
; 1055 :    if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
; 1056 :    return stbi__malloc(a*b*c + add);
; 1057 : }
; 1058 : 
; 1059 : #if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
; 1060 : static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
; 1061 : {
; 1062 :    if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
; 1063 :    return stbi__malloc(a*b*c*d + add);
; 1064 : }
; 1065 : #endif
; 1066 : 
; 1067 : // returns 1 if the sum of two signed ints is valid (between -2^31 and 2^31-1 inclusive), 0 on overflow.
; 1068 : static int stbi__addints_valid(int a, int b)
; 1069 : {
; 1070 :    if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow
; 1071 :    if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.
; 1072 :    return a <= INT_MAX - b;
; 1073 : }
; 1074 : 
; 1075 : // returns 1 if the product of two signed shorts is valid, 0 on overflow.
; 1076 : static int stbi__mul2shorts_valid(short a, short b)
; 1077 : {
; 1078 :    if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow
; 1079 :    if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX/b; // product is positive, so similar to mul2sizes_valid
; 1080 :    if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN
; 1081 :    return a >= SHRT_MIN / b;
; 1082 : }
; 1083 : 
; 1084 : // stbi__err - error
; 1085 : // stbi__errpf - error returning pointer to float
; 1086 : // stbi__errpuc - error returning pointer to unsigned char
; 1087 : 
; 1088 : #ifdef STBI_NO_FAILURE_STRINGS
; 1089 :    #define stbi__err(x,y)  0
; 1090 : #elif defined(STBI_FAILURE_USERMSG)
; 1091 :    #define stbi__err(x,y)  stbi__err(y)
; 1092 : #else
; 1093 :    #define stbi__err(x,y)  stbi__err(x)
; 1094 : #endif
; 1095 : 
; 1096 : #define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
; 1097 : #define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))
; 1098 : 
; 1099 : STBIDEF void stbi_image_free(void *retval_from_stbi_load)
; 1100 : {
; 1101 :    STBI_FREE(retval_from_stbi_load);
; 1102 : }
; 1103 : 
; 1104 : #ifndef STBI_NO_LINEAR
; 1105 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
; 1106 : #endif
; 1107 : 
; 1108 : #ifndef STBI_NO_HDR
; 1109 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
; 1110 : #endif
; 1111 : 
; 1112 : static int stbi__vertically_flip_on_load_global = 0;
; 1113 : 
; 1114 : STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
; 1115 : {
; 1116 :    stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
; 1117 : }
; 1118 : 
; 1119 : #ifndef STBI_THREAD_LOCAL
; 1120 : #define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global
; 1121 : #else
; 1122 : static STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;
; 1123 : 
; 1124 : STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
; 1125 : {
; 1126 :    stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
; 1127 :    stbi__vertically_flip_on_load_set = 1;
; 1128 : }
; 1129 : 
; 1130 : #define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \
; 1131 :                                          ? stbi__vertically_flip_on_load_local  \
; 1132 :                                          : stbi__vertically_flip_on_load_global)
; 1133 : #endif // STBI_THREAD_LOCAL
; 1134 : 
; 1135 : static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
; 1136 : {
; 1137 :    memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
; 1138 :    ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
; 1139 :    ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
; 1140 :    ri->num_channels = 0;
; 1141 : 
; 1142 :    // test the formats with a very explicit header first (at least a FOURCC
; 1143 :    // or distinctive magic number first)
; 1144 :    #ifndef STBI_NO_PNG
; 1145 :    if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
; 1146 :    #endif
; 1147 :    #ifndef STBI_NO_BMP
; 1148 :    if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
; 1149 :    #endif
; 1150 :    #ifndef STBI_NO_GIF
; 1151 :    if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
; 1152 :    #endif
; 1153 :    #ifndef STBI_NO_PSD
; 1154 :    if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
; 1155 :    #else
; 1156 :    STBI_NOTUSED(bpc);
; 1157 :    #endif
; 1158 :    #ifndef STBI_NO_PIC
; 1159 :    if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
; 1160 :    #endif
; 1161 : 
; 1162 :    // then the formats that can end up attempting to load with just 1 or 2
; 1163 :    // bytes matching expectations; these are prone to false positives, so
; 1164 :    // try them later
; 1165 :    #ifndef STBI_NO_JPEG
; 1166 :    if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
; 1167 :    #endif
; 1168 :    #ifndef STBI_NO_PNM
; 1169 :    if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
; 1170 :    #endif
; 1171 : 
; 1172 :    #ifndef STBI_NO_HDR
; 1173 :    if (stbi__hdr_test(s)) {
; 1174 :       float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
; 1175 :       return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
; 1176 :    }
; 1177 :    #endif
; 1178 : 
; 1179 :    #ifndef STBI_NO_TGA
; 1180 :    // test tga last because it's a crappy test!
; 1181 :    if (stbi__tga_test(s))
; 1182 :       return stbi__tga_load(s,x,y,comp,req_comp, ri);
; 1183 :    #endif
; 1184 : 
; 1185 :    return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
; 1186 : }
; 1187 : 
; 1188 : static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
; 1189 : {
; 1190 :    int i;
; 1191 :    int img_len = w * h * channels;
; 1192 :    stbi_uc *reduced;
; 1193 : 
; 1194 :    reduced = (stbi_uc *) stbi__malloc(img_len);
; 1195 :    if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");
; 1196 : 
; 1197 :    for (i = 0; i < img_len; ++i)
; 1198 :       reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling
; 1199 : 
; 1200 :    STBI_FREE(orig);
; 1201 :    return reduced;
; 1202 : }
; 1203 : 
; 1204 : static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
; 1205 : {
; 1206 :    int i;
; 1207 :    int img_len = w * h * channels;
; 1208 :    stbi__uint16 *enlarged;
; 1209 : 
; 1210 :    enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
; 1211 :    if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1212 : 
; 1213 :    for (i = 0; i < img_len; ++i)
; 1214 :       enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff
; 1215 : 
; 1216 :    STBI_FREE(orig);
; 1217 :    return enlarged;
; 1218 : }
; 1219 : 
; 1220 : static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
; 1221 : {
; 1222 :    int row;
; 1223 :    size_t bytes_per_row = (size_t)w * bytes_per_pixel;
; 1224 :    stbi_uc temp[2048];
; 1225 :    stbi_uc *bytes = (stbi_uc *)image;
; 1226 : 
; 1227 :    for (row = 0; row < (h>>1); row++) {
; 1228 :       stbi_uc *row0 = bytes + row*bytes_per_row;
; 1229 :       stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
; 1230 :       // swap row0 with row1
; 1231 :       size_t bytes_left = bytes_per_row;
; 1232 :       while (bytes_left) {
; 1233 :          size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
; 1234 :          memcpy(temp, row0, bytes_copy);
; 1235 :          memcpy(row0, row1, bytes_copy);
; 1236 :          memcpy(row1, temp, bytes_copy);
; 1237 :          row0 += bytes_copy;
; 1238 :          row1 += bytes_copy;
; 1239 :          bytes_left -= bytes_copy;
; 1240 :       }
; 1241 :    }
; 1242 : }
; 1243 : 
; 1244 : #ifndef STBI_NO_GIF
; 1245 : static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
; 1246 : {
; 1247 :    int slice;
; 1248 :    int slice_size = w * h * bytes_per_pixel;
; 1249 : 
; 1250 :    stbi_uc *bytes = (stbi_uc *)image;
; 1251 :    for (slice = 0; slice < z; ++slice) {
; 1252 :       stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
; 1253 :       bytes += slice_size;
; 1254 :    }
; 1255 : }
; 1256 : #endif
; 1257 : 
; 1258 : static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
; 1259 : {
; 1260 :    stbi__result_info ri;
; 1261 :    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);
; 1262 : 
; 1263 :    if (result == NULL)
; 1264 :       return NULL;
; 1265 : 
; 1266 :    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1267 :    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
; 1268 : 
; 1269 :    if (ri.bits_per_channel != 8) {
; 1270 :       result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
; 1271 :       ri.bits_per_channel = 8;
; 1272 :    }
; 1273 : 
; 1274 :    // @TODO: move stbi__convert_format to here
; 1275 : 
; 1276 :    if (stbi__vertically_flip_on_load) {
; 1277 :       int channels = req_comp ? req_comp : *comp;
; 1278 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
; 1279 :    }
; 1280 : 
; 1281 :    return (unsigned char *) result;
; 1282 : }
; 1283 : 
; 1284 : static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
; 1285 : {
; 1286 :    stbi__result_info ri;
; 1287 :    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);
; 1288 : 
; 1289 :    if (result == NULL)
; 1290 :       return NULL;
; 1291 : 
; 1292 :    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1293 :    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
; 1294 : 
; 1295 :    if (ri.bits_per_channel != 16) {
; 1296 :       result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
; 1297 :       ri.bits_per_channel = 16;
; 1298 :    }
; 1299 : 
; 1300 :    // @TODO: move stbi__convert_format16 to here
; 1301 :    // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision
; 1302 : 
; 1303 :    if (stbi__vertically_flip_on_load) {
; 1304 :       int channels = req_comp ? req_comp : *comp;
; 1305 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
; 1306 :    }
; 1307 : 
; 1308 :    return (stbi__uint16 *) result;
; 1309 : }
; 1310 : 
; 1311 : #if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)
; 1312 : static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
; 1313 : {
; 1314 :    if (stbi__vertically_flip_on_load && result != NULL) {
; 1315 :       int channels = req_comp ? req_comp : *comp;
; 1316 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
; 1317 :    }
; 1318 : }
; 1319 : #endif
; 1320 : 
; 1321 : #ifndef STBI_NO_STDIO
; 1322 : 
; 1323 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1324 : STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
; 1325 : STBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);
; 1326 : #endif
; 1327 : 
; 1328 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1329 : STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
; 1330 : {
; 1331 : 	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
; 1332 : }
; 1333 : #endif
; 1334 : 
; 1335 : static FILE *stbi__fopen(char const *filename, char const *mode)
; 1336 : {
; 1337 :    FILE *f;
; 1338 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1339 :    wchar_t wMode[64];
; 1340 :    wchar_t wFilename[1024];
; 1341 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
; 1342 :       return 0;
; 1343 : 
; 1344 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
; 1345 :       return 0;
; 1346 : 
; 1347 : #if defined(_MSC_VER) && _MSC_VER >= 1400
; 1348 : 	if (0 != _wfopen_s(&f, wFilename, wMode))
; 1349 : 		f = 0;
; 1350 : #else
; 1351 :    f = _wfopen(wFilename, wMode);
; 1352 : #endif
; 1353 : 
; 1354 : #elif defined(_MSC_VER) && _MSC_VER >= 1400
; 1355 :    if (0 != fopen_s(&f, filename, mode))

	mov	rbx, QWORD PTR f$1[rsp]
$LN5@stbi_load:

; 1366 :    FILE *f = stbi__fopen(filename, "rb");

	test	rbx, rbx

; 1367 :    unsigned char *result;
; 1368 :    if (!f) return stbi__errpuc("can't fopen", "Unable to open file");

	jne	SHORT $LN2@stbi_load

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0M@JPDHFAGK@can?8t?5fopen@
	mov	QWORD PTR [rdx+rcx], rax

; 1367 :    unsigned char *result;
; 1368 :    if (!f) return stbi__errpuc("can't fopen", "Unable to open file");

	xor	eax, eax
	jmp	$LN1@stbi_load
$LN2@stbi_load:

; 836  :    s->io = *c;

	movups	xmm0, XMMWORD PTR ?stbi__stdio_callbacks@@3Ustbi_io_callbacks@@A+8
	lea	rax, OFFSET FLAT:?stbi__stdio_read@@YAHPEAXPEADH@Z ; stbi__stdio_read

; 837  :    s->io_user_data = user;

	mov	QWORD PTR s$2[rsp+40], rbx
	mov	QWORD PTR s$2[rsp+16], rax

; 1597 :    int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);

	lea	rdx, QWORD PTR s$2[rsp+56]

; 841  :    s->img_buffer = s->img_buffer_original = s->buffer_start;

	lea	rax, QWORD PTR s$2[rsp+56]
	mov	DWORD PTR s$2[rsp+52], 128		; 00000080H
	mov	QWORD PTR s$2[rbp-48], rax

; 1597 :    int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);

	mov	r8d, 128				; 00000080H

; 841  :    s->img_buffer = s->img_buffer_original = s->buffer_start;

	lea	rax, QWORD PTR s$2[rsp+56]
	mov	DWORD PTR s$2[rsp+48], 1

; 1597 :    int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);

	mov	rcx, rbx

; 841  :    s->img_buffer = s->img_buffer_original = s->buffer_start;

	mov	QWORD PTR s$2[rbp-64], rax
	movups	XMMWORD PTR s$2[rsp+24], xmm0
	mov	DWORD PTR s$2[rbp-72], 0

; 1597 :    int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);

	call	?stbi__stdio_read@@YAHPEAXPEADH@Z	; stbi__stdio_read

; 1598 :    s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);

	mov	ecx, DWORD PTR s$2[rbp-64]
	sub	ecx, DWORD PTR s$2[rbp-48]
	add	DWORD PTR s$2[rbp-72], ecx

; 1599 :    if (n == 0) {

	test	eax, eax
	jne	SHORT $LN17@stbi_load

; 1600 :       // at end of file, treat same as if from memory, but need to handle case
; 1601 :       // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
; 1602 :       s->read_from_callbacks = 0;

	mov	DWORD PTR s$2[rsp+48], eax

; 1603 :       s->img_buffer = s->buffer_start;

	lea	rax, QWORD PTR s$2[rsp+56]
	mov	QWORD PTR s$2[rbp-64], rax

; 1604 :       s->img_buffer_end = s->buffer_start+1;

	lea	rax, QWORD PTR s$2[rsp+57]

; 1605 :       *s->img_buffer = 0;

	mov	BYTE PTR s$2[rsp+56], 0

; 1606 :    } else {

	jmp	SHORT $LN25@stbi_load
$LN17@stbi_load:

; 1607 :       s->img_buffer = s->buffer_start;
; 1608 :       s->img_buffer_end = s->buffer_start + n;

	cdqe
	lea	rcx, QWORD PTR s$2[rsp+56]
	mov	QWORD PTR s$2[rbp-64], rcx
	lea	rax, QWORD PTR s$2[rsp+rax+56]
$LN25@stbi_load:

; 1379 :    result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

	xor	r9d, r9d

; 843  :    s->img_buffer_original_end = s->img_buffer_end;

	mov	QWORD PTR s$2[rbp-56], rax

; 1379 :    result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

	mov	r8, rsi

; 843  :    s->img_buffer_original_end = s->img_buffer_end;

	mov	QWORD PTR s$2[rbp-40], rax

; 1379 :    result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

	mov	rdx, rdi
	lea	rcx, QWORD PTR s$2[rsp]
	call	?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__load_and_postprocess_8bit
	mov	rdi, rax

; 1380 :    if (result) {

	test	rax, rax
	je	SHORT $LN10@stbi_load

; 1381 :       // need to 'unget' all the characters in the IO buffer
; 1382 :       fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);

	mov	edx, DWORD PTR s$2[rbp-64]
	mov	r8d, 1
	sub	edx, DWORD PTR s$2[rbp-56]
	mov	rcx, rbx
	call	QWORD PTR __imp_fseek
$LN10@stbi_load:

; 1369 :    result = stbi_load_from_file(f,x,y,comp,req_comp);
; 1370 :    fclose(f);

	mov	rcx, rbx
	call	QWORD PTR __imp_fclose

; 1371 :    return result;

	mov	rax, rdi
$LN1@stbi_load:

; 1372 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+360]
	add	rsp, 304				; 00000130H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
stbi_load ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT stbi_load_from_file
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
f$ = 320
x$ = 328
y$ = 336
comp$dead$ = 344
req_comp$dead$ = 352
stbi_load_from_file PROC				; COMDAT

; 1375 : {

$LN17:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	lea	rbp, QWORD PTR [rsp-32]
	sub	rsp, 288				; 00000120H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 836  :    s->io = *c;

	movups	xmm0, XMMWORD PTR ?stbi__stdio_callbacks@@3Ustbi_io_callbacks@@A+8
	lea	rax, OFFSET FLAT:?stbi__stdio_read@@YAHPEAXPEADH@Z ; stbi__stdio_read

; 837  :    s->io_user_data = user;

	mov	QWORD PTR s$[rsp+40], rcx
	mov	QWORD PTR s$[rsp+16], rax

; 1375 : {

	mov	rsi, r8

; 841  :    s->img_buffer = s->img_buffer_original = s->buffer_start;

	lea	rax, QWORD PTR s$[rsp+56]
	mov	DWORD PTR s$[rsp+52], 128		; 00000080H
	mov	QWORD PTR s$[rbp-48], rax

; 1375 : {

	mov	rbx, rdx

; 841  :    s->img_buffer = s->img_buffer_original = s->buffer_start;

	lea	rax, QWORD PTR s$[rsp+56]
	mov	DWORD PTR s$[rsp+48], 1

; 1597 :    int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);

	mov	r8d, 128				; 00000080H

; 841  :    s->img_buffer = s->img_buffer_original = s->buffer_start;

	mov	QWORD PTR s$[rbp-64], rax

; 1597 :    int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);

	lea	rdx, QWORD PTR s$[rsp+56]

; 840  :    s->callback_already_read = 0;

	mov	DWORD PTR s$[rbp-72], 0

; 1375 : {

	mov	rdi, rcx

; 836  :    s->io = *c;

	movups	XMMWORD PTR s$[rsp+24], xmm0

; 1597 :    int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);

	call	?stbi__stdio_read@@YAHPEAXPEADH@Z	; stbi__stdio_read

; 1598 :    s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);

	mov	ecx, DWORD PTR s$[rbp-64]
	sub	ecx, DWORD PTR s$[rbp-48]
	add	DWORD PTR s$[rbp-72], ecx

; 1599 :    if (n == 0) {

	test	eax, eax
	jne	SHORT $LN9@stbi_load_

; 1600 :       // at end of file, treat same as if from memory, but need to handle case
; 1601 :       // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
; 1602 :       s->read_from_callbacks = 0;

	mov	DWORD PTR s$[rsp+48], eax

; 1603 :       s->img_buffer = s->buffer_start;

	lea	rax, QWORD PTR s$[rsp+56]
	mov	QWORD PTR s$[rbp-64], rax

; 1604 :       s->img_buffer_end = s->buffer_start+1;

	lea	rax, QWORD PTR s$[rsp+57]

; 1605 :       *s->img_buffer = 0;

	mov	BYTE PTR s$[rsp+56], 0

; 1606 :    } else {

	jmp	SHORT $LN15@stbi_load_
$LN9@stbi_load_:

; 1607 :       s->img_buffer = s->buffer_start;
; 1608 :       s->img_buffer_end = s->buffer_start + n;

	cdqe
	lea	rcx, QWORD PTR s$[rsp+56]
	mov	QWORD PTR s$[rbp-64], rcx
	lea	rax, QWORD PTR s$[rsp+rax+56]
$LN15@stbi_load_:

; 1376 :    unsigned char *result;
; 1377 :    stbi__context s;
; 1378 :    stbi__start_file(&s,f);
; 1379 :    result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

	xor	r9d, r9d

; 843  :    s->img_buffer_original_end = s->img_buffer_end;

	mov	QWORD PTR s$[rbp-56], rax

; 1376 :    unsigned char *result;
; 1377 :    stbi__context s;
; 1378 :    stbi__start_file(&s,f);
; 1379 :    result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

	mov	r8, rsi

; 843  :    s->img_buffer_original_end = s->img_buffer_end;

	mov	QWORD PTR s$[rbp-40], rax

; 1376 :    unsigned char *result;
; 1377 :    stbi__context s;
; 1378 :    stbi__start_file(&s,f);
; 1379 :    result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

	mov	rdx, rbx
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__load_and_postprocess_8bit
	mov	rbx, rax

; 1380 :    if (result) {

	test	rax, rax
	je	SHORT $LN2@stbi_load_

; 1381 :       // need to 'unget' all the characters in the IO buffer
; 1382 :       fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);

	mov	edx, DWORD PTR s$[rbp-64]
	mov	r8d, 1
	sub	edx, DWORD PTR s$[rbp-56]
	mov	rcx, rdi
	call	QWORD PTR __imp_fseek

; 1383 :    }
; 1384 :    return result;

	mov	rax, rbx
$LN2@stbi_load_:

; 1385 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+344]
	add	rsp, 288				; 00000120H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
stbi_load_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT stbi_load_from_memory
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
buffer$ = 304
len$ = 312
x$ = 320
y$ = 328
comp$ = 336
req_comp$dead$ = 344
stbi_load_from_memory PROC				; COMDAT

; 1428 : {

$LN6:
	sub	rsp, 296				; 00000128H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 826  :    s->io.read = NULL;

	xor	eax, eax

; 829  :    s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;

	mov	QWORD PTR s$[rsp+208], rcx
	mov	QWORD PTR s$[rsp+192], rcx

; 1428 : {

	mov	r11, r9
	mov	r9, QWORD PTR comp$[rsp]
	mov	r10, r8

; 826  :    s->io.read = NULL;

	mov	QWORD PTR s$[rsp+16], rax

; 1429 :    stbi__context s;
; 1430 :    stbi__start_mem(&s,buffer,len);
; 1431 :    return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

	mov	r8, r11

; 827  :    s->read_from_callbacks = 0;

	mov	DWORD PTR s$[rsp+48], eax

; 828  :    s->callback_already_read = 0;

	mov	DWORD PTR s$[rsp+184], eax

; 830  :    s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;

	movsxd	rax, edx

; 1429 :    stbi__context s;
; 1430 :    stbi__start_mem(&s,buffer,len);
; 1431 :    return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

	mov	rdx, r10

; 830  :    s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;

	add	rcx, rax
	mov	QWORD PTR s$[rsp+216], rcx
	mov	QWORD PTR s$[rsp+200], rcx

; 1429 :    stbi__context s;
; 1430 :    stbi__start_mem(&s,buffer,len);
; 1431 :    return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__load_and_postprocess_8bit

; 1432 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 296				; 00000128H
	ret	0
stbi_load_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z PROC	; stbi__refill_buffer, COMDAT

; 1596 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1597 :    int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);

	mov	rax, QWORD PTR [rcx+16]
	lea	rdi, QWORD PTR [rcx+56]
	mov	r8d, DWORD PTR [rcx+52]
	mov	rbx, rcx
	mov	rcx, QWORD PTR [rcx+40]
	mov	rdx, rdi
	call	rax

; 1598 :    s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);

	mov	edx, DWORD PTR [rbx+192]
	sub	edx, DWORD PTR [rbx+208]
	add	DWORD PTR [rbx+184], edx
	mov	QWORD PTR [rbx+192], rdi

; 1599 :    if (n == 0) {

	test	eax, eax
	jne	SHORT $LN2@stbi__refi

; 1600 :       // at end of file, treat same as if from memory, but need to handle case
; 1601 :       // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
; 1602 :       s->read_from_callbacks = 0;

	mov	DWORD PTR [rbx+48], eax

; 1603 :       s->img_buffer = s->buffer_start;
; 1604 :       s->img_buffer_end = s->buffer_start+1;

	lea	rax, QWORD PTR [rbx+57]
	mov	QWORD PTR [rbx+200], rax

; 1605 :       *s->img_buffer = 0;

	mov	BYTE PTR [rdi], 0

; 1609 :    }
; 1610 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@stbi__refi:

; 1606 :    } else {
; 1607 :       s->img_buffer = s->buffer_start;
; 1608 :       s->img_buffer_end = s->buffer_start + n;

	movsxd	rcx, eax
	add	rcx, 56					; 00000038H
	add	rcx, rbx
	mov	QWORD PTR [rbx+200], rcx

; 1609 :    }
; 1610 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ENDP	; stbi__refill_buffer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__get8@@YAEPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__get8@@YAEPEAUstbi__context@@@Z PROC		; stbi__get8, COMDAT

; 1613 : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rdx, QWORD PTR [rcx+192]
	mov	rbx, rcx
	cmp	rdx, QWORD PTR [rcx+200]
	jae	SHORT $LN2@stbi__get8

; 1615 :       return *s->img_buffer++;

	movzx	eax, BYTE PTR [rdx]
	inc	rdx
	mov	QWORD PTR [rcx+192], rdx

; 1621 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@stbi__get8:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rcx+48], 0
	je	SHORT $LN3@stbi__get8

; 1617 :       stbi__refill_buffer(s);

	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rcx, QWORD PTR [rbx+192]
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	mov	QWORD PTR [rbx+192], rcx

; 1621 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@stbi__get8:

; 1619 :    }
; 1620 :    return 0;

	xor	al, al

; 1621 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stbi__get8@@YAEPEAUstbi__context@@@Z ENDP		; stbi__get8
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__at_eof@@YAHPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__at_eof@@YAHPEAUstbi__context@@@Z PROC		; stbi__at_eof, COMDAT

; 1627 : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 1628 :    if (s->io.read) {

	cmp	QWORD PTR [rcx+16], 0
	mov	rbx, rcx
	je	SHORT $LN4@stbi__at_e

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	rax, QWORD PTR [rcx+32]
	mov	rcx, QWORD PTR [rcx+40]
	call	rax
	test	eax, eax
	jne	SHORT $LN3@stbi__at_e

; 1636 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@stbi__at_e:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

	cmp	DWORD PTR [rbx+48], 0
	jne	SHORT $LN4@stbi__at_e
	mov	eax, 1

; 1636 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@stbi__at_e:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;

	mov	rcx, QWORD PTR [rbx+200]
	xor	eax, eax
	cmp	QWORD PTR [rbx+192], rcx
	setae	al

; 1636 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stbi__at_eof@@YAHPEAUstbi__context@@@Z ENDP		; stbi__at_eof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__skip@@YAXPEAUstbi__context@@H@Z
_TEXT	SEGMENT
s$ = 8
n$ = 16
?stbi__skip@@YAXPEAUstbi__context@@H@Z PROC		; stbi__skip, COMDAT

; 1643 : {

	mov	r8, rcx

; 1644 :    if (n == 0) return;  // already there!

	test	edx, edx
	je	SHORT $LN1@stbi__skip

; 1645 :    if (n < 0) {

	jns	SHORT $LN3@stbi__skip

; 1646 :       s->img_buffer = s->img_buffer_end;

	mov	rax, QWORD PTR [rcx+200]
	mov	QWORD PTR [rcx+192], rax

; 1658 : }

	ret	0
$LN3@stbi__skip:

; 1647 :       return;
; 1648 :    }
; 1649 :    if (s->io.read) {

	cmp	QWORD PTR [rcx+16], 0
	je	SHORT $LN5@stbi__skip

; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);

	mov	ecx, DWORD PTR [rcx+200]
	sub	ecx, DWORD PTR [r8+192]

; 1651 :       if (blen < n) {

	cmp	ecx, edx
	jge	SHORT $LN5@stbi__skip

; 1652 :          s->img_buffer = s->img_buffer_end;

	mov	rax, QWORD PTR [r8+200]

; 1653 :          (s->io.skip)(s->io_user_data, n - blen);

	sub	edx, ecx
	mov	rcx, QWORD PTR [r8+40]
	mov	QWORD PTR [r8+192], rax
	rex_jmp	QWORD PTR [r8+24]
$LN5@stbi__skip:

; 1654 :          return;
; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;

	movsxd	rax, edx
	add	QWORD PTR [r8+192], rax
$LN1@stbi__skip:

; 1658 : }

	ret	0
?stbi__skip@@YAXPEAUstbi__context@@H@Z ENDP		; stbi__skip
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z
_TEXT	SEGMENT
s$ = 48
buffer$ = 56
n$ = 64
?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z PROC		; stbi__getn, COMDAT

; 1665 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1666 :    if (s->io.read) {

	cmp	QWORD PTR [rcx+16], 0
	mov	r14, rdx
	movsxd	rsi, r8d
	mov	rdi, rcx
	je	SHORT $LN7@stbi__getn

; 1667 :       int blen = (int) (s->img_buffer_end - s->img_buffer);

	mov	ebp, DWORD PTR [rcx+200]
	sub	ebp, DWORD PTR [rcx+192]

; 1668 :       if (blen < n) {

	cmp	ebp, esi
	jge	SHORT $LN7@stbi__getn

; 1669 :          int res, count;
; 1670 : 
; 1671 :          memcpy(buffer, s->img_buffer, blen);

	mov	rdx, QWORD PTR [rcx+192]
	mov	rcx, r14
	movsxd	rbx, ebp
	mov	r8, rbx
	call	memcpy

; 1672 : 
; 1673 :          count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);

	mov	rax, QWORD PTR [rdi+16]
	lea	rdx, QWORD PTR [rbx+r14]
	mov	rcx, QWORD PTR [rdi+40]
	sub	esi, ebp
	mov	r8d, esi
	call	rax

; 1674 :          res = (count == (n-blen));
; 1675 :          s->img_buffer = s->img_buffer_end;

	mov	rcx, QWORD PTR [rdi+200]
	xor	edx, edx
	cmp	eax, esi
	mov	QWORD PTR [rdi+192], rcx
	sete	dl

; 1676 :          return res;

	mov	eax, edx
	jmp	SHORT $LN5@stbi__getn
$LN7@stbi__getn:

; 1677 :       }
; 1678 :    }
; 1679 : 
; 1680 :    if (s->img_buffer+n <= s->img_buffer_end) {

	mov	rdx, QWORD PTR [rcx+192]
	mov	rbx, rsi
	lea	rax, QWORD PTR [rsi+rdx]
	cmp	rax, QWORD PTR [rcx+200]
	ja	SHORT $LN4@stbi__getn

; 1681 :       memcpy(buffer, s->img_buffer, n);

	mov	r8, rbx
	mov	rcx, r14
	call	memcpy

; 1682 :       s->img_buffer += n;

	add	QWORD PTR [rdi+192], rbx

; 1683 :       return 1;

	mov	eax, 1
	jmp	SHORT $LN5@stbi__getn
$LN4@stbi__getn:

; 1684 :    } else
; 1685 :       return 0;

	xor	eax, eax
$LN5@stbi__getn:

; 1686 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ENDP		; stbi__getn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__get16be@@YAHPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__get16be@@YAHPEAUstbi__context@@@Z PROC		; stbi__get16be, COMDAT

; 1693 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rcx+192]

; 1693 : {

	mov	rbx, rcx

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rcx+200]
	jae	SHORT $LN4@stbi__get1

; 1615 :       return *s->img_buffer++;

	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rcx+192], rax
	jmp	SHORT $LN15@stbi__get1
$LN4@stbi__get1:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rcx+48], 0
	je	SHORT $LN5@stbi__get1

; 1617 :       stbi__refill_buffer(s);

	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN15@stbi__get1
$LN5@stbi__get1:

; 1619 :    }
; 1620 :    return 0;

	xor	dl, dl
$LN15@stbi__get1:

; 1694 :    int z = stbi__get8(s);

	mov	ecx, 48					; 00000030H
	mov	r8, rbx
	movzx	edi, dl
	lea	r9, QWORD PTR [rcx+rbx]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN16@stbi__get1

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r9], 0
	je	SHORT $LN9@stbi__get1

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN16@stbi__get1:

; 1695 :    return (z << 8) + stbi__get8(s);

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	movzx	eax, cl
	shl	edi, 8
	add	eax, edi

; 1696 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN9@stbi__get1:
	mov	rbx, QWORD PTR [rsp+48]

; 1620 :    return 0;

	xor	cl, cl

; 1695 :    return (z << 8) + stbi__get8(s);

	movzx	eax, cl
	shl	edi, 8
	add	eax, edi

; 1696 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__get16be@@YAHPEAUstbi__context@@@Z ENDP		; stbi__get16be
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__get32be@@YAIPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__get32be@@YAIPEAUstbi__context@@@Z PROC		; stbi__get32be, COMDAT

; 1703 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1704 :    stbi__uint32 z = stbi__get16be(s);

	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 1705 :    return (z << 16) + stbi__get16be(s);

	mov	rcx, rbx
	mov	edi, eax
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 1706 : }

	mov	rbx, QWORD PTR [rsp+48]
	shl	edi, 16
	add	eax, edi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__get32be@@YAIPEAUstbi__context@@@Z ENDP		; stbi__get32be
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__get16le@@YAHPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__get16le@@YAHPEAUstbi__context@@@Z PROC		; stbi__get16le, COMDAT

; 1713 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rcx+192]

; 1713 : {

	mov	rbx, rcx

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rcx+200]
	jae	SHORT $LN4@stbi__get1

; 1615 :       return *s->img_buffer++;

	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rcx+192], rax
	jmp	SHORT $LN15@stbi__get1
$LN4@stbi__get1:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rcx+48], 0
	je	SHORT $LN5@stbi__get1

; 1617 :       stbi__refill_buffer(s);

	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN15@stbi__get1
$LN5@stbi__get1:

; 1619 :    }
; 1620 :    return 0;

	xor	dl, dl
$LN15@stbi__get1:

; 1714 :    int z = stbi__get8(s);

	mov	ecx, 48					; 00000030H
	mov	r8, rbx
	movzx	edi, dl
	lea	r9, QWORD PTR [rcx+rbx]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN16@stbi__get1

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r9], 0
	je	SHORT $LN9@stbi__get1

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN16@stbi__get1:

; 1715 :    return z + (stbi__get8(s) << 8);

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	movzx	eax, cl
	shl	eax, 8
	add	eax, edi

; 1716 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN9@stbi__get1:
	mov	rbx, QWORD PTR [rsp+48]

; 1620 :    return 0;

	xor	cl, cl

; 1715 :    return z + (stbi__get8(s) << 8);

	movzx	eax, cl
	shl	eax, 8
	add	eax, edi

; 1716 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__get16le@@YAHPEAUstbi__context@@@Z ENDP		; stbi__get16le
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__get32le@@YAIPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__get32le@@YAIPEAUstbi__context@@@Z PROC		; stbi__get32le, COMDAT

; 1721 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1722 :    stbi__uint32 z = stbi__get16le(s);

	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;

	mov	rcx, rbx
	mov	edi, eax
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1724 :    return z;
; 1725 : }

	mov	rbx, QWORD PTR [rsp+48]
	shl	eax, 16
	add	eax, edi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__get32le@@YAIPEAUstbi__context@@@Z ENDP		; stbi__get32le
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__compute_y@@YAEHHH@Z
_TEXT	SEGMENT
r$ = 8
g$ = 16
b$ = 24
?stbi__compute_y@@YAEHHH@Z PROC				; stbi__compute_y, COMDAT

; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	ecx, ecx, 77				; 0000004dH
	imul	eax, edx, 150				; 00000096H
	add	eax, ecx
	imul	ecx, r8d, 29
	add	eax, ecx
	sar	eax, 8

; 1747 : }

	ret	0
?stbi__compute_y@@YAEHHH@Z ENDP				; stbi__compute_y
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__convert_format@@YAPEAEPEAEHHII@Z
_TEXT	SEGMENT
data$ = 80
img_n$ = 88
req_comp$ = 96
x$ = 104
y$ = 112
?stbi__convert_format@@YAPEAEPEAEHHII@Z PROC		; stbi__convert_format, COMDAT

; 1754 : {

	push	rbx
	push	rbp
	push	rsi
	push	r13
	push	r15
	sub	rsp, 32					; 00000020H
	mov	r15d, DWORD PTR y$[rsp]
	mov	ebx, r9d
	mov	ebp, r8d
	mov	r13d, edx
	mov	rsi, rcx

; 1755 :    int i,j;
; 1756 :    unsigned char *good;
; 1757 : 
; 1758 :    if (req_comp == img_n) return data;

	cmp	r8d, edx
	jne	SHORT $LN43@stbi__conv
	mov	rax, rcx

; 1795 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r13
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN43@stbi__conv:
	mov	QWORD PTR [rsp+96], r14

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ebp, ebp
	js	$LN145@stbi__conv
	test	ebx, ebx
	js	$LN145@stbi__conv

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN149@stbi__conv

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, 2147483647				; 7fffffffH
	div	ebx

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ebp, eax
	jg	$LN145@stbi__conv
$LN149@stbi__conv:
	mov	ecx, ebp
	imul	ecx, ebx

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	$LN145@stbi__conv
	test	r15d, r15d
	js	$LN145@stbi__conv

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN60@stbi__conv

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, 2147483647				; 7fffffffH
	div	r15d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	$LN145@stbi__conv
$LN60@stbi__conv:

; 1056 :    return stbi__malloc(a*b*c + add);

	imul	ecx, r15d
	movsxd	rcx, ecx

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc
	mov	r14, rax

; 1759 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1760 : 
; 1761 :    good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
; 1762 :    if (good == NULL) {

	test	rax, rax
	je	$LN145@stbi__conv
	mov	QWORD PTR [rsp+80], rdi

; 1765 :    }
; 1766 : 
; 1767 :    for (j=0; j < (int) y; ++j) {

	xor	edi, edi
	mov	QWORD PTR [rsp+88], r12
	test	r15d, r15d
	jle	$LN3@stbi__conv
	lea	r12d, DWORD PTR [r13*8-10]
	add	r12d, ebp
	lea	r11d, DWORD PTR [rbx-1]
	lea	r8, OFFSET FLAT:__ImageBase
	npad	9
$LL4@stbi__conv:

; 1768 :       unsigned char *src  = data + j * x * img_n   ;

	mov	r9d, edi

; 1769 :       unsigned char *dest = good + j * x * req_comp;

	mov	eax, edi
	imul	r9d, r13d
	imul	eax, ebp
	imul	r9d, ebx
	imul	eax, ebx
	add	r9, rsi
	add	rax, r14

; 1770 : 
; 1771 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1772 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1773 :       // convert source image with img_n components to one with req_comp components;
; 1774 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1775 :       switch (STBI__COMBO(img_n, req_comp)) {

	cmp	r12d, 25
	ja	$LN57@stbi__conv
	movsxd	rcx, r12d
	mov	edx, DWORD PTR $LN150@stbi__conv[r8+rcx*4]
	add	rdx, r8
	jmp	rdx
$LN45@stbi__conv:

; 1776 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;

	mov	edx, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
	npad	1
$LL9@stbi__conv:
	sub	edx, 1
	movzx	ecx, BYTE PTR [r9]
	mov	BYTE PTR [rax], cl
	lea	r9, QWORD PTR [r9+1]
	mov	BYTE PTR [rax+1], 255			; 000000ffH
	lea	rax, QWORD PTR [rax+2]
	jns	SHORT $LL9@stbi__conv
	jmp	$LN2@stbi__conv
$LN46@stbi__conv:

; 1777 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;

	mov	edx, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
	npad	8
$LL12@stbi__conv:
	sub	edx, 1
	movzx	ecx, BYTE PTR [r9]
	mov	BYTE PTR [rax+2], cl
	lea	r9, QWORD PTR [r9+1]
	mov	BYTE PTR [rax+1], cl
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+3]
	jns	SHORT $LL12@stbi__conv
	jmp	$LN2@stbi__conv
$LN47@stbi__conv:

; 1778 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;

	mov	edx, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
	npad	6
$LL15@stbi__conv:
	sub	edx, 1
	movzx	ecx, BYTE PTR [r9]
	mov	BYTE PTR [rax+2], cl
	lea	r9, QWORD PTR [r9+1]
	mov	BYTE PTR [rax+1], cl
	mov	BYTE PTR [rax], cl
	mov	BYTE PTR [rax+3], 255			; 000000ffH
	lea	rax, QWORD PTR [rax+4]
	jns	SHORT $LL15@stbi__conv
	jmp	$LN2@stbi__conv
$LN48@stbi__conv:

; 1779 :          STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;

	mov	edx, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
	npad	2
$LL18@stbi__conv:
	sub	edx, 1
	movzx	ecx, BYTE PTR [r9]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	lea	r9, QWORD PTR [r9+2]
	jns	SHORT $LL18@stbi__conv
	jmp	$LN2@stbi__conv
$LN49@stbi__conv:

; 1780 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;

	mov	edx, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
	npad	12
$LL21@stbi__conv:
	sub	edx, 1
	movzx	ecx, BYTE PTR [r9]
	mov	BYTE PTR [rax+2], cl
	lea	r9, QWORD PTR [r9+2]
	mov	BYTE PTR [rax+1], cl
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+3]
	jns	SHORT $LL21@stbi__conv
	jmp	$LN2@stbi__conv
$LN50@stbi__conv:

; 1781 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;

	mov	edx, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
	npad	6
$LL24@stbi__conv:
	sub	edx, 1
	movzx	ecx, BYTE PTR [r9]
	mov	BYTE PTR [rax+2], cl
	lea	r9, QWORD PTR [r9+2]
	mov	BYTE PTR [rax+1], cl
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+4]
	movzx	ecx, BYTE PTR [r9-1]
	mov	BYTE PTR [rax-1], cl
	jns	SHORT $LL24@stbi__conv
	jmp	$LN2@stbi__conv
$LN51@stbi__conv:

; 1782 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;

	mov	edx, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
$LL27@stbi__conv:
	sub	edx, 1
	movzx	ecx, BYTE PTR [r9]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+4]
	movzx	ecx, BYTE PTR [r9+1]
	lea	r9, QWORD PTR [r9+3]
	mov	BYTE PTR [rax-3], cl
	movzx	ecx, BYTE PTR [r9-1]
	mov	BYTE PTR [rax-2], cl
	mov	BYTE PTR [rax-1], 255			; 000000ffH
	jns	SHORT $LL27@stbi__conv
	jmp	$LN2@stbi__conv
$LN52@stbi__conv:

; 1783 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;

	mov	r10d, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
	npad	6
$LL30@stbi__conv:
	movzx	ecx, BYTE PTR [r9+1]
	lea	rax, QWORD PTR [rax+1]

; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	r8d, ecx, 150				; 00000096H

; 1783 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;

	movzx	ecx, BYTE PTR [r9+2]
	lea	r9, QWORD PTR [r9+3]

; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	edx, ecx, 29

; 1783 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;

	movzx	ecx, BYTE PTR [r9-3]

; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);

	add	r8d, edx
	imul	edx, ecx, 77				; 0000004dH
	add	r8d, edx
	shr	r8d, 8

; 1783 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;

	sub	r10d, 1
	mov	BYTE PTR [rax-1], r8b
	jns	SHORT $LL30@stbi__conv
	lea	r8, OFFSET FLAT:__ImageBase
	jmp	$LN2@stbi__conv
$LN53@stbi__conv:

; 1784 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;

	mov	r10d, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
$LL33@stbi__conv:
	movzx	ecx, BYTE PTR [r9+1]
	lea	rax, QWORD PTR [rax+2]

; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	r8d, ecx, 150				; 00000096H

; 1784 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;

	movzx	ecx, BYTE PTR [r9+2]
	lea	r9, QWORD PTR [r9+3]

; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	edx, ecx, 29

; 1784 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;

	movzx	ecx, BYTE PTR [r9-3]
	mov	BYTE PTR [rax-1], 255			; 000000ffH

; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);

	add	r8d, edx
	imul	edx, ecx, 77				; 0000004dH
	add	r8d, edx
	shr	r8d, 8

; 1784 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;

	sub	r10d, 1
	mov	BYTE PTR [rax-2], r8b
	jns	SHORT $LL33@stbi__conv
	lea	r8, OFFSET FLAT:__ImageBase
	jmp	$LN2@stbi__conv
$LN54@stbi__conv:

; 1785 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;

	mov	r10d, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
	npad	12
$LL36@stbi__conv:
	movzx	ecx, BYTE PTR [r9+1]
	lea	rax, QWORD PTR [rax+1]

; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	r8d, ecx, 150				; 00000096H

; 1785 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;

	movzx	ecx, BYTE PTR [r9+2]
	lea	r9, QWORD PTR [r9+4]

; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	edx, ecx, 29

; 1785 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;

	movzx	ecx, BYTE PTR [r9-4]

; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);

	add	r8d, edx
	imul	edx, ecx, 77				; 0000004dH
	add	r8d, edx
	shr	r8d, 8

; 1785 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;

	sub	r10d, 1
	mov	BYTE PTR [rax-1], r8b
	jns	SHORT $LL36@stbi__conv
	lea	r8, OFFSET FLAT:__ImageBase
	jmp	$LN2@stbi__conv
$LN55@stbi__conv:

; 1786 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;

	mov	r10d, r11d
	test	r11d, r11d
	js	SHORT $LN2@stbi__conv
	npad	4
$LL39@stbi__conv:
	movzx	ecx, BYTE PTR [r9+1]
	lea	rax, QWORD PTR [rax+2]

; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	r8d, ecx, 150				; 00000096H

; 1786 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;

	movzx	ecx, BYTE PTR [r9+2]
	lea	r9, QWORD PTR [r9+4]

; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	edx, ecx, 29

; 1786 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;

	movzx	ecx, BYTE PTR [r9-4]

; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);

	add	r8d, edx
	imul	edx, ecx, 77				; 0000004dH
	add	r8d, edx
	shr	r8d, 8

; 1786 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;

	sub	r10d, 1
	mov	BYTE PTR [rax-2], r8b
	movzx	ecx, BYTE PTR [r9-1]
	mov	BYTE PTR [rax-1], cl
	jns	SHORT $LL39@stbi__conv
	lea	r8, OFFSET FLAT:__ImageBase
	jmp	SHORT $LN2@stbi__conv
$LN56@stbi__conv:

; 1787 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;

	mov	edx, r11d
	test	r11d, r11d
	js	SHORT $LN2@stbi__conv
$LL42@stbi__conv:
	sub	edx, 1
	movzx	ecx, BYTE PTR [r9]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+3]
	movzx	ecx, BYTE PTR [r9+1]
	lea	r9, QWORD PTR [r9+4]
	mov	BYTE PTR [rax-2], cl
	movzx	ecx, BYTE PTR [r9-2]
	mov	BYTE PTR [rax-1], cl
	jns	SHORT $LL42@stbi__conv
$LN2@stbi__conv:

; 1765 :    }
; 1766 : 
; 1767 :    for (j=0; j < (int) y; ++j) {

	inc	edi
	cmp	edi, r15d
	jl	$LL4@stbi__conv
$LN3@stbi__conv:

; 1789 :       }
; 1790 :       #undef STBI__CASE
; 1791 :    }
; 1792 : 
; 1793 :    STBI_FREE(data);

	mov	rcx, rsi
	call	QWORD PTR __imp_free

; 1794 :    return good;

	mov	rax, r14
$LN179@stbi__conv:
	mov	r12, QWORD PTR [rsp+88]
	mov	rdi, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+96]

; 1795 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r13
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN57@stbi__conv:

; 1788 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");

	mov	rcx, rsi
	call	QWORD PTR __imp_free
	mov	rcx, r14
	call	QWORD PTR __imp_free

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0M@MHDBFHD@unsupported@
	mov	QWORD PTR [rdx+rcx], rax

; 1788 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");

	xor	eax, eax
	jmp	SHORT $LN179@stbi__conv
$LN145@stbi__conv:

; 1763 :       STBI_FREE(data);

	mov	rcx, rsi
	call	QWORD PTR __imp_free

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	r14, QWORD PTR [rsp+96]
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	mov	QWORD PTR [rdx+rcx], rax

; 1764 :       return stbi__errpuc("outofmem", "Out of memory");

	xor	eax, eax

; 1795 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r13
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN150@stbi__conv:
	DD	$LN45@stbi__conv
	DD	$LN46@stbi__conv
	DD	$LN47@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN48@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN49@stbi__conv
	DD	$LN50@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN52@stbi__conv
	DD	$LN53@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN51@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN54@stbi__conv
	DD	$LN55@stbi__conv
	DD	$LN56@stbi__conv
?stbi__convert_format@@YAPEAEPEAEHHII@Z ENDP		; stbi__convert_format
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__compute_y_16@@YAGHHH@Z
_TEXT	SEGMENT
r$ = 8
g$ = 16
b$ = 24
?stbi__compute_y_16@@YAGHHH@Z PROC			; stbi__compute_y_16, COMDAT

; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	ecx, ecx, 77				; 0000004dH
	imul	eax, edx, 150				; 00000096H
	add	eax, ecx
	imul	ecx, r8d, 29
	add	eax, ecx
	sar	eax, 8

; 1804 : }

	ret	0
?stbi__compute_y_16@@YAGHHH@Z ENDP			; stbi__compute_y_16
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__convert_format16@@YAPEAGPEAGHHII@Z
_TEXT	SEGMENT
data$ = 64
img_n$ = 72
req_comp$dead$ = 80
x$ = 88
y$ = 96
?stbi__convert_format16@@YAPEAGPEAGHHII@Z PROC		; stbi__convert_format16, COMDAT

; 1811 : {

	push	rsi
	push	rdi
	push	r15
	sub	rsp, 32					; 00000020H
	mov	esi, r9d
	mov	r15d, edx
	mov	rdi, rcx

; 1812 :    int i,j;
; 1813 :    stbi__uint16 *good;
; 1814 : 
; 1815 :    if (req_comp == img_n) return data;

	cmp	edx, 4
	jne	SHORT $LN43@stbi__conv
	mov	rax, rcx

; 1852 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rsi
	ret	0
$LN43@stbi__conv:

; 1816 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1817 : 
; 1818 :    good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);

	mov	ecx, esi
	mov	QWORD PTR [rsp+88], r14
	imul	ecx, DWORD PTR y$[rsp]
	shl	ecx, 3

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc
	mov	r14, rax

; 1819 :    if (good == NULL) {

	test	rax, rax
	jne	SHORT $LN44@stbi__conv

; 1820 :       STBI_FREE(data);

	mov	rcx, rdi
	call	QWORD PTR __imp_free

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	r14, QWORD PTR [rsp+88]
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	mov	QWORD PTR [rdx+rcx], rax

; 1821 :       return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");

	xor	eax, eax

; 1852 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rsi
	ret	0
$LN44@stbi__conv:
	mov	QWORD PTR [rsp+64], rbx

; 1822 :    }
; 1823 : 
; 1824 :    for (j=0; j < (int) y; ++j) {

	xor	ebx, ebx
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+80], r13
	cmp	DWORD PTR y$[rsp], ebx
	jle	$LN3@stbi__conv
	lea	r11d, DWORD PTR [rsi-1]
	mov	r13d, 65535				; 0000ffffH
	lea	ebp, DWORD PTR [r15*8-6]
	lea	r8, OFFSET FLAT:__ImageBase
	npad	7
$LL4@stbi__conv:

; 1825 :       stbi__uint16 *src  = data + j * x * img_n   ;

	mov	eax, ebx
	imul	eax, r15d
	imul	eax, esi
	lea	r9, QWORD PTR [rdi+rax*2]

; 1826 :       stbi__uint16 *dest = good + j * x * req_comp;

	mov	eax, ebx
	imul	eax, esi
	shl	eax, 2
	lea	rax, QWORD PTR [r14+rax*2]

; 1827 : 
; 1828 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1829 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1830 :       // convert source image with img_n components to one with req_comp components;
; 1831 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1832 :       switch (STBI__COMBO(img_n, req_comp)) {

	cmp	ebp, 25
	ja	$LN57@stbi__conv
	movsxd	rcx, ebp
	mov	edx, DWORD PTR $LN125@stbi__conv[r8+rcx*4]
	add	rdx, r8
	jmp	rdx
$LN45@stbi__conv:

; 1833 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;

	mov	edx, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
	npad	2
$LL9@stbi__conv:
	sub	edx, 1
	movzx	ecx, WORD PTR [r9]
	mov	WORD PTR [rax], cx
	lea	r9, QWORD PTR [r9+2]
	mov	WORD PTR [rax+2], r13w
	lea	rax, QWORD PTR [rax+4]
	jns	SHORT $LL9@stbi__conv
	jmp	$LN2@stbi__conv
$LN46@stbi__conv:

; 1834 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;

	mov	edx, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
	npad	6
$LL12@stbi__conv:
	sub	edx, 1
	movzx	ecx, WORD PTR [r9]
	mov	WORD PTR [rax+4], cx
	lea	r9, QWORD PTR [r9+2]
	mov	WORD PTR [rax+2], cx
	mov	WORD PTR [rax], cx
	lea	rax, QWORD PTR [rax+6]
	jns	SHORT $LL12@stbi__conv
	jmp	$LN2@stbi__conv
$LN47@stbi__conv:

; 1835 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;

	mov	edx, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
	npad	3
$LL15@stbi__conv:
	sub	edx, 1
	movzx	ecx, WORD PTR [r9]
	mov	WORD PTR [rax+4], cx
	lea	r9, QWORD PTR [r9+2]
	mov	WORD PTR [rax+2], cx
	mov	WORD PTR [rax], cx
	mov	WORD PTR [rax+6], r13w
	lea	rax, QWORD PTR [rax+8]
	jns	SHORT $LL15@stbi__conv
	jmp	$LN2@stbi__conv
$LN48@stbi__conv:

; 1836 :          STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;

	mov	edx, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
$LL18@stbi__conv:
	sub	edx, 1
	movzx	ecx, WORD PTR [r9]
	mov	WORD PTR [rax], cx
	lea	rax, QWORD PTR [rax+2]
	lea	r9, QWORD PTR [r9+4]
	jns	SHORT $LL18@stbi__conv
	jmp	$LN2@stbi__conv
$LN49@stbi__conv:

; 1837 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;

	mov	edx, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
	npad	9
$LL21@stbi__conv:
	sub	edx, 1
	movzx	ecx, WORD PTR [r9]
	mov	WORD PTR [rax+4], cx
	lea	r9, QWORD PTR [r9+4]
	mov	WORD PTR [rax+2], cx
	mov	WORD PTR [rax], cx
	lea	rax, QWORD PTR [rax+6]
	jns	SHORT $LL21@stbi__conv
	jmp	$LN2@stbi__conv
$LN50@stbi__conv:

; 1838 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;

	mov	edx, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
	npad	3
$LL24@stbi__conv:
	sub	edx, 1
	movzx	ecx, WORD PTR [r9]
	mov	WORD PTR [rax+4], cx
	lea	r9, QWORD PTR [r9+4]
	mov	WORD PTR [rax+2], cx
	mov	WORD PTR [rax], cx
	lea	rax, QWORD PTR [rax+8]
	movzx	ecx, WORD PTR [r9-2]
	mov	WORD PTR [rax-2], cx
	jns	SHORT $LL24@stbi__conv
	jmp	$LN2@stbi__conv
$LN51@stbi__conv:

; 1839 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;

	mov	edx, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
	npad	10
$LL27@stbi__conv:
	sub	edx, 1
	movzx	ecx, WORD PTR [r9]
	mov	WORD PTR [rax], cx
	lea	rax, QWORD PTR [rax+8]
	movzx	ecx, WORD PTR [r9+2]
	lea	r9, QWORD PTR [r9+6]
	mov	WORD PTR [rax-6], cx
	movzx	ecx, WORD PTR [r9-2]
	mov	WORD PTR [rax-4], cx
	mov	WORD PTR [rax-2], r13w
	jns	SHORT $LL27@stbi__conv
	jmp	$LN2@stbi__conv
$LN52@stbi__conv:

; 1840 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;

	mov	r10d, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
	npad	4
$LL30@stbi__conv:
	movzx	ecx, WORD PTR [r9+2]
	lea	rax, QWORD PTR [rax+2]

; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	r8d, ecx, 150				; 00000096H

; 1840 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;

	movzx	ecx, WORD PTR [r9+4]
	lea	r9, QWORD PTR [r9+6]

; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	edx, ecx, 29

; 1840 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;

	movzx	ecx, WORD PTR [r9-6]

; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);

	add	r8d, edx
	imul	edx, ecx, 77				; 0000004dH
	add	r8d, edx
	shr	r8d, 8

; 1840 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;

	sub	r10d, 1
	mov	WORD PTR [rax-2], r8w
	jns	SHORT $LL30@stbi__conv
	lea	r8, OFFSET FLAT:__ImageBase
	jmp	$LN2@stbi__conv
$LN53@stbi__conv:

; 1841 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;

	mov	r10d, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
	npad	15
$LL33@stbi__conv:
	movzx	ecx, WORD PTR [r9+2]
	lea	rax, QWORD PTR [rax+4]

; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	r8d, ecx, 150				; 00000096H

; 1841 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;

	movzx	ecx, WORD PTR [r9+4]
	lea	r9, QWORD PTR [r9+6]

; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	edx, ecx, 29

; 1841 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;

	movzx	ecx, WORD PTR [r9-6]
	mov	WORD PTR [rax-2], r13w

; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);

	add	r8d, edx
	imul	edx, ecx, 77				; 0000004dH
	add	r8d, edx
	shr	r8d, 8

; 1841 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;

	sub	r10d, 1
	mov	WORD PTR [rax-4], r8w
	jns	SHORT $LL33@stbi__conv
	lea	r8, OFFSET FLAT:__ImageBase
	jmp	$LN2@stbi__conv
$LN54@stbi__conv:

; 1842 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;

	mov	r10d, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
	npad	10
$LL36@stbi__conv:
	movzx	ecx, WORD PTR [r9+2]
	lea	rax, QWORD PTR [rax+2]

; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	r8d, ecx, 150				; 00000096H

; 1842 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;

	movzx	ecx, WORD PTR [r9+4]
	lea	r9, QWORD PTR [r9+8]

; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	edx, ecx, 29

; 1842 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;

	movzx	ecx, WORD PTR [r9-8]

; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);

	add	r8d, edx
	imul	edx, ecx, 77				; 0000004dH
	add	r8d, edx
	shr	r8d, 8

; 1842 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;

	sub	r10d, 1
	mov	WORD PTR [rax-2], r8w
	jns	SHORT $LL36@stbi__conv
	lea	r8, OFFSET FLAT:__ImageBase
	jmp	$LN2@stbi__conv
$LN55@stbi__conv:

; 1843 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;

	mov	r10d, r11d
	test	r11d, r11d
	js	$LN2@stbi__conv
	npad	15
$LL39@stbi__conv:
	movzx	ecx, WORD PTR [r9+2]
	lea	rax, QWORD PTR [rax+4]

; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	r8d, ecx, 150				; 00000096H

; 1843 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;

	movzx	ecx, WORD PTR [r9+4]
	lea	r9, QWORD PTR [r9+8]

; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);

	imul	edx, ecx, 29

; 1843 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;

	movzx	ecx, WORD PTR [r9-8]

; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);

	add	r8d, edx
	imul	edx, ecx, 77				; 0000004dH
	add	r8d, edx
	shr	r8d, 8

; 1843 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;

	sub	r10d, 1
	mov	WORD PTR [rax-4], r8w
	movzx	ecx, WORD PTR [r9-2]
	mov	WORD PTR [rax-2], cx
	jns	SHORT $LL39@stbi__conv
	lea	r8, OFFSET FLAT:__ImageBase
	jmp	SHORT $LN2@stbi__conv
$LN56@stbi__conv:

; 1844 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;

	mov	edx, r11d
	test	r11d, r11d
	js	SHORT $LN2@stbi__conv
	npad	13
$LL42@stbi__conv:
	sub	edx, 1
	movzx	ecx, WORD PTR [r9]
	mov	WORD PTR [rax], cx
	lea	rax, QWORD PTR [rax+6]
	movzx	ecx, WORD PTR [r9+2]
	lea	r9, QWORD PTR [r9+8]
	mov	WORD PTR [rax-4], cx
	movzx	ecx, WORD PTR [r9-4]
	mov	WORD PTR [rax-2], cx
	jns	SHORT $LL42@stbi__conv
$LN2@stbi__conv:

; 1822 :    }
; 1823 : 
; 1824 :    for (j=0; j < (int) y; ++j) {

	inc	ebx
	cmp	ebx, DWORD PTR y$[rsp]
	jl	$LL4@stbi__conv
$LN3@stbi__conv:

; 1846 :       }
; 1847 :       #undef STBI__CASE
; 1848 :    }
; 1849 : 
; 1850 :    STBI_FREE(data);

	mov	rcx, rdi
	call	QWORD PTR __imp_free

; 1851 :    return good;

	mov	rax, r14
$LN149@stbi__conv:
	mov	r13, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]
	mov	r14, QWORD PTR [rsp+88]

; 1852 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rsi
	ret	0
$LN57@stbi__conv:

; 1845 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");

	mov	rcx, rdi
	call	QWORD PTR __imp_free
	mov	rcx, r14
	call	QWORD PTR __imp_free

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0M@MHDBFHD@unsupported@
	mov	QWORD PTR [rdx+rcx], rax

; 1845 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");

	xor	eax, eax
	jmp	SHORT $LN149@stbi__conv
	npad	3
$LN125@stbi__conv:

; 1852 : }

	DD	$LN45@stbi__conv
	DD	$LN46@stbi__conv
	DD	$LN47@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN48@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN49@stbi__conv
	DD	$LN50@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN52@stbi__conv
	DD	$LN53@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN51@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN54@stbi__conv
	DD	$LN55@stbi__conv
	DD	$LN56@stbi__conv
?stbi__convert_format16@@YAPEAGPEAGHHII@Z ENDP		; stbi__convert_format16
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z
_TEXT	SEGMENT
tv688 = 32
tv689 = 40
output$1$ = 48
tv693 = 56
data$ = 160
x$ = 168
y$ = 176
comp$ = 184
?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z PROC			; stbi__hdr_to_ldr, COMDAT

; 1883 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 128				; 00000080H
	movsxd	rsi, r9d
	mov	ebx, edx
	mov	rdi, rcx

; 1884 :    int i,k,n;
; 1885 :    stbi_uc *output;
; 1886 :    if (!data) return NULL;

	test	rcx, rcx
	je	$LN67@stbi__hdr_

; 1014 :    if (a < 0 || b < 0) return 0;

	test	edx, edx
	js	$LN50@stbi__hdr_
	test	r8d, r8d
	js	$LN50@stbi__hdr_

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN54@stbi__hdr_

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, 2147483647				; 7fffffffH
	div	r8d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ebx, eax
	jg	$LN50@stbi__hdr_
$LN54@stbi__hdr_:
	imul	ebx, r8d

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ebx, ebx
	js	$LN50@stbi__hdr_
	test	r9d, r9d
	js	$LN50@stbi__hdr_

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN53@stbi__hdr_

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, 2147483647				; 7fffffffH
	div	esi

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ebx, eax
	jg	$LN50@stbi__hdr_
$LN53@stbi__hdr_:

; 1056 :    return stbi__malloc(a*b*c + add);

	mov	eax, ebx
	imul	eax, esi
	movsxd	rcx, eax

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc
	mov	QWORD PTR output$1$[rsp], rax
	mov	r8, rax

; 1887 :    output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
; 1888 :    if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }

	test	rax, rax
	je	$LN50@stbi__hdr_

; 1889 :    // compute number of non-alpha components
; 1890 :    if (comp & 1) n = comp; else n = comp-1;

	test	sil, 1

; 1891 :    for (i=0; i < x*y; ++i) {

	lea	ecx, DWORD PTR [rsi-1]
	mov	eax, esi
	cmove	eax, ecx
	mov	DWORD PTR tv688[rsp], eax
	test	ebx, ebx
	jle	$LN3@stbi__hdr_
	mov	QWORD PTR [rsp+168], rbp
	lea	r10, QWORD PTR [rsi*4]
	mov	QWORD PTR [rsp+176], r12
	mov	r9, rsi
	mov	QWORD PTR [rsp+184], r13
	xor	r13d, r13d
	mov	QWORD PTR [rsp+120], r14
	mov	r14, r8
	mov	QWORD PTR [rsp+112], r15
	mov	r15, rdi
	movaps	XMMWORD PTR [rsp+96], xmm6
	movss	xmm6, DWORD PTR __real@437f0000
	movaps	XMMWORD PTR [rsp+80], xmm7
	movss	xmm7, DWORD PTR __real@3f000000
	mov	edx, ebx
	movaps	XMMWORD PTR [rsp+64], xmm8
	movsd	xmm8, QWORD PTR __real@3fdd1745c0000000
	movsxd	r12, eax
	mov	QWORD PTR tv693[rsp], r10
	mov	QWORD PTR tv689[rsp], rdx
$LL4@stbi__hdr_:

; 1892 :       for (k=0; k < n; ++k) {

	xor	ebp, ebp
	test	r12, r12
	jle	SHORT $LN6@stbi__hdr_

; 1893 :          float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;

	xor	ebx, ebx
	mov	rdi, r15
	mov	ebp, eax
$LL7@stbi__hdr_:
	movss	xmm0, DWORD PTR [rdi]
	movaps	xmm1, xmm8
	cvtps2pd xmm0, xmm0
	call	pow
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	cvtsd2ss xmm2, xmm0
	add	rdi, 4

; 1894 :          if (z < 0) z = 0;
; 1895 :          if (z > 255) z = 255;

	movaps	xmm0, xmm6
	mulss	xmm2, xmm6
	addss	xmm2, xmm7
	maxss	xmm1, xmm2
	minss	xmm0, xmm1

; 1896 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);

	cvttss2si eax, xmm0
	mov	BYTE PTR [r14+rbx], al
	inc	rbx
	cmp	rbx, r12
	jl	SHORT $LL7@stbi__hdr_
	mov	rdx, QWORD PTR tv689[rsp]
	mov	r9, rsi
	mov	rdi, QWORD PTR data$[rsp]
	mov	r8, QWORD PTR output$1$[rsp]
	mov	r10, QWORD PTR tv693[rsp]
$LN6@stbi__hdr_:

; 1897 :       }
; 1898 :       if (k < comp) {

	cmp	ebp, esi
	jge	SHORT $LN2@stbi__hdr_

; 1899 :          float z = data[i*comp+k] * 255 + 0.5f;

	mov	eax, r13d
	xorps	xmm1, xmm1
	add	eax, ebp
	movsxd	rcx, eax
	movss	xmm0, DWORD PTR [rdi+rcx*4]
	mulss	xmm0, xmm6
	addss	xmm0, xmm7

; 1900 :          if (z < 0) z = 0;

	maxss	xmm1, xmm0

; 1901 :          if (z > 255) z = 255;

	movaps	xmm0, xmm6
	minss	xmm0, xmm1

; 1902 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);

	cvttss2si eax, xmm0
	mov	BYTE PTR [rcx+r8], al
$LN2@stbi__hdr_:

; 1891 :    for (i=0; i < x*y; ++i) {

	mov	eax, DWORD PTR tv688[rsp]
	add	r13d, esi
	add	r15, r10
	add	r14, r9
	sub	rdx, 1
	mov	QWORD PTR tv689[rsp], rdx
	jne	$LL4@stbi__hdr_
	movaps	xmm8, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+80]
	movaps	xmm6, XMMWORD PTR [rsp+96]
	mov	r15, QWORD PTR [rsp+112]
	mov	r14, QWORD PTR [rsp+120]
	mov	r13, QWORD PTR [rsp+184]
	mov	r12, QWORD PTR [rsp+176]
	mov	rbp, QWORD PTR [rsp+168]
$LN3@stbi__hdr_:

; 1903 :       }
; 1904 :    }
; 1905 :    STBI_FREE(data);

	mov	rcx, rdi
	call	QWORD PTR __imp_free

; 1906 :    return output;

	mov	rax, QWORD PTR output$1$[rsp]

; 1907 : }

	add	rsp, 128				; 00000080H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN50@stbi__hdr_:

; 1887 :    output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
; 1888 :    if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }

	mov	rcx, rdi
	call	QWORD PTR __imp_free

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	mov	QWORD PTR [rdx+rcx], rax
$LN67@stbi__hdr_:

; 1907 : }

	xor	eax, eax
	add	rsp, 128				; 00000080H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z ENDP			; stbi__hdr_to_ldr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z
_TEXT	SEGMENT
h$ = 48
count$ = 56
?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z PROC	; stbi__build_huffman, COMDAT

; 2002 : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	r14
	sub	rsp, 32					; 00000020H

; 2003 :    int i,j,k=0;

	xor	ebp, ebp
	mov	r14, rcx
	mov	r10d, ebp

; 2004 :    unsigned int code;
; 2005 :    // build size list for each symbol (from JPEG spec)
; 2006 :    for (i=0; i < 16; ++i) {

	mov	ebx, ebp
	mov	eax, ebp
	npad	4
$LL4@stbi__buil:

; 2007 :       for (j=0; j < count[i]; ++j) {

	movsxd	r8, ebx
	mov	r9d, ebp
	mov	r11d, DWORD PTR [rdx+r8*4]
	test	r11d, r11d
	jle	SHORT $LN2@stbi__buil
	lea	ecx, DWORD PTR [rbx+1]
$LL7@stbi__buil:

; 2008 :          h->size[k++] = (stbi_uc) (i+1);

	mov	BYTE PTR [r14+rax+1280], cl
	inc	r10d
	inc	rax

; 2009 :          if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");

	cmp	rax, 257				; 00000101H
	jge	$LN34@stbi__buil

; 2007 :       for (j=0; j < count[i]; ++j) {

	inc	r9d
	cmp	r9d, r11d
	jl	SHORT $LL7@stbi__buil
$LN2@stbi__buil:

; 2004 :    unsigned int code;
; 2005 :    // build size list for each symbol (from JPEG spec)
; 2006 :    for (i=0; i < 16; ++i) {

	inc	ebx
	cmp	ebx, 16
	jl	SHORT $LL4@stbi__buil

; 2010 :       }
; 2011 :    }
; 2012 :    h->size[k] = 0;

	movsxd	rax, r10d

; 2013 : 
; 2014 :    // compute actual symbols (from jpeg spec)
; 2015 :    code = 0;

	mov	edx, ebp
	mov	QWORD PTR [rsp+48], rsi

; 2016 :    k = 0;
; 2017 :    for(j=1; j <= 16; ++j) {

	mov	r10d, 1
	mov	QWORD PTR [rsp+56], rdi
	lea	rsi, QWORD PTR [r14+1544]
	mov	ebx, ebp
	mov	r9, rbp
	mov	BYTE PTR [rax+r14+1280], bpl
	lea	edi, QWORD PTR [r10+14]
	npad	8
$LL10@stbi__buil:

; 2020 :       if (h->size[k] == j) {

	lea	rcx, QWORD PTR [r14+1280]
	mov	eax, ebx
	sub	eax, edx
	add	rcx, r9
	mov	DWORD PTR [rsi+72], eax
	movzx	eax, BYTE PTR [rcx]
	cmp	eax, r10d
	jne	SHORT $LN21@stbi__buil

; 2018 :       // compute delta to add to code to compute symbol id
; 2019 :       h->delta[j] = k - code;

	lea	r8, QWORD PTR [r14+512]
	lea	r8, QWORD PTR [r8+r9*2]
	npad	12
$LL11@stbi__buil:

; 2021 :          while (h->size[k] == j)
; 2022 :             h->code[k++] = (stbi__uint16) (code++);

	movzx	eax, dx
	lea	rcx, QWORD PTR [rcx+1]
	mov	WORD PTR [r8], ax
	lea	r8, QWORD PTR [r8+2]
	movzx	eax, BYTE PTR [rcx]
	mov	r11d, edx
	inc	edx
	inc	ebx
	inc	r9
	cmp	eax, r10d
	je	SHORT $LL11@stbi__buil

; 2023 :          if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");

	mov	ecx, r10d
	mov	eax, 1
	shl	eax, cl
	cmp	r11d, eax
	jae	$LN35@stbi__buil
$LN21@stbi__buil:

; 2024 :       }
; 2025 :       // compute largest code + 1 for this size, preshifted as needed later
; 2026 :       h->maxcode[j] = code << (16-j);

	mov	ecx, edi
	mov	eax, edx
	shl	eax, cl

; 2027 :       code <<= 1;

	add	edx, edx
	mov	DWORD PTR [rsi], eax
	inc	r10d
	add	rsi, 4
	sub	edi, 1
	jns	SHORT $LL10@stbi__buil

; 2028 :    }
; 2029 :    h->maxcode[j] = 0xffffffff;

	movsxd	rax, r10d

; 2030 : 
; 2031 :    // build non-spec acceleration table; 255 is flag for not-accelerated
; 2032 :    memset(h->fast, 255, 1 << FAST_BITS);

	mov	edx, 255				; 000000ffH
	mov	r8d, 512				; 00000200H
	mov	rcx, r14
	mov	DWORD PTR [r14+rax*4+1540], -1		; ffffffffH
	call	memset

; 2033 :    for (i=0; i < k; ++i) {

	test	ebx, ebx
	jle	SHORT $LN14@stbi__buil

; 2028 :    }
; 2029 :    h->maxcode[j] = 0xffffffff;

	lea	rdi, QWORD PTR [r14+1280]
	lea	rsi, QWORD PTR [r14+512]
	npad	2
$LL15@stbi__buil:

; 2034 :       int s = h->size[i];

	movzx	eax, BYTE PTR [rdi]

; 2035 :       if (s <= FAST_BITS) {

	cmp	eax, 9
	ja	SHORT $LN13@stbi__buil

; 2036 :          int c = h->code[i] << (FAST_BITS-s);

	movzx	edx, WORD PTR [rsi]
	mov	ecx, 9
	sub	ecx, eax

; 2037 :          int m = 1 << (FAST_BITS-s);

	mov	eax, 1
	shl	eax, cl
	shl	edx, cl

; 2038 :          for (j=0; j < m; ++j) {

	test	eax, eax
	jle	SHORT $LN13@stbi__buil

; 2039 :             h->fast[c+j] = (stbi_uc) i;

	movsxd	rcx, edx
	movzx	edx, bpl
	add	rcx, r14
	movsxd	r8, eax
	call	memset
$LN13@stbi__buil:

; 2033 :    for (i=0; i < k; ++i) {

	inc	ebp
	add	rsi, 2
	inc	rdi
	cmp	ebp, ebx
	jl	SHORT $LL15@stbi__buil
$LN14@stbi__buil:

; 2040 :          }
; 2041 :       }
; 2042 :    }
; 2043 :    return 1;

	mov	eax, 1
$LN68@stbi__buil:
	mov	rsi, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+56]

; 2044 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN34@stbi__buil:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88

; 2044 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]

; 978  :    stbi__g_failure_reason = str;

	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0O@DEFOLMLB@bad?5size?5list@
	mov	QWORD PTR [rdx+rcx], rax

; 2009 :          if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");

	xor	eax, eax

; 2044 : }

	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN35@stbi__buil:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BB@FOKGPEKG@bad?5code?5lengths@
	mov	QWORD PTR [rdx+rcx], rax

; 2023 :          if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");

	xor	eax, eax
	jmp	SHORT $LN68@stbi__buil
?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z ENDP	; stbi__build_huffman
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z
_TEXT	SEGMENT
fast_ac$ = 16
h$ = 24
?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z PROC	; stbi__build_fast_ac, COMDAT

; 2049 : {

	mov	QWORD PTR [rsp+24], rbp
	push	rsi

; 2050 :    int i;
; 2051 :    for (i=0; i < (1 << FAST_BITS); ++i) {

	xor	ebp, ebp
	mov	QWORD PTR [rsp+16], rbx
	mov	r10d, ebp
	mov	QWORD PTR [rsp+24], rdi
	mov	rsi, rdx
	mov	r9, rcx
	mov	r11, rdx
	npad	2
$LL4@stbi__buil:

; 2052 :       stbi_uc fast = h->fast[i];

	movzx	eax, BYTE PTR [r11]

; 2053 :       fast_ac[i] = 0;

	mov	WORD PTR [r9], bp

; 2054 :       if (fast < 255) {

	cmp	al, 255					; 000000ffH
	jae	$LN2@stbi__buil

; 2055 :          int rs = h->values[fast];

	movzx	r8d, BYTE PTR [rax+rsi+1024]

; 2056 :          int run = (rs >> 4) & 15;
; 2057 :          int magbits = rs & 15;
; 2058 :          int len = h->size[fast];

	movzx	ebx, BYTE PTR [rax+rsi+1280]
	mov	edi, r8d
	shr	edi, 4
	and	r8d, 15

; 2059 : 
; 2060 :          if (magbits && len + magbits <= FAST_BITS) {

	je	SHORT $LN2@stbi__buil
	lea	eax, DWORD PTR [rbx+r8]
	cmp	eax, 9
	ja	SHORT $LN2@stbi__buil

; 2061 :             // magnitude code followed by receive_extend code
; 2062 :             int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);

	mov	ecx, ebx
	mov	eax, r10d
	shl	eax, cl

; 2063 :             int m = 1 << (magbits - 1);

	mov	edx, 1
	and	eax, 511				; 000001ffH
	mov	ecx, 9
	sub	ecx, r8d
	sar	eax, cl
	lea	ecx, DWORD PTR [r8-1]
	shl	edx, cl

; 2064 :             if (k < m) k += (~0U << magbits) + 1;

	cmp	eax, edx
	jge	SHORT $LN7@stbi__buil
	mov	ecx, r8d
	mov	edx, 1
	shl	edx, cl
	mov	ecx, 1
	sub	ecx, edx
	add	eax, ecx
$LN7@stbi__buil:

; 2065 :             // if the result is small enough, we can fit it in fast_ac table
; 2066 :             if (k >= -128 && k <= 127)

	lea	ecx, DWORD PTR [rax+128]
	cmp	ecx, 255				; 000000ffH
	ja	SHORT $LN2@stbi__buil

; 2067 :                fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));

	shl	ax, 4
	add	ax, di
	shl	ax, 4
	add	ax, bx
	add	ax, r8w
	mov	WORD PTR [r9], ax
$LN2@stbi__buil:

; 2050 :    int i;
; 2051 :    for (i=0; i < (1 << FAST_BITS); ++i) {

	inc	r10d
	inc	r11
	add	r9, 2
	cmp	r10d, 512				; 00000200H
	jl	$LL4@stbi__buil
	mov	rdi, QWORD PTR [rsp+24]
	mov	rbx, QWORD PTR [rsp+16]

; 2068 :          }
; 2069 :       }
; 2070 :    }
; 2071 : }

	mov	rbp, QWORD PTR [rsp+32]
	pop	rsi
	ret	0
?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z ENDP	; stbi__build_fast_ac
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z
_TEXT	SEGMENT
j$ = 48
?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z PROC	; stbi__grow_buffer_unsafe, COMDAT

; 2074 : {

	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	QWORD PTR [rsp+48], rsi
$LL4@stbi__grow:

; 2075 :    do {
; 2076 :       unsigned int b = j->nomore ? 0 : stbi__get8(j->s);

	cmp	DWORD PTR [rdi+18476], 0
	je	SHORT $LN10@stbi__grow
	xor	esi, esi
	jmp	$LN8@stbi__grow
$LN10@stbi__grow:
	mov	rbx, QWORD PTR [rdi]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN13@stbi__grow

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN12@stbi__grow
$LN13@stbi__grow:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN14@stbi__grow

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN12@stbi__grow
$LN14@stbi__grow:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN12@stbi__grow:

; 2075 :    do {
; 2076 :       unsigned int b = j->nomore ? 0 : stbi__get8(j->s);

	movzx	esi, cl

; 2077 :       if (b == 0xff) {

	cmp	esi, 255				; 000000ffH
	jne	$LN8@stbi__grow

; 2078 :          int c = stbi__get8(j->s);

	mov	rbx, QWORD PTR [rdi]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN17@stbi__grow

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN16@stbi__grow
$LN17@stbi__grow:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN18@stbi__grow

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN16@stbi__grow
$LN18@stbi__grow:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN16@stbi__grow:

; 2078 :          int c = stbi__get8(j->s);

	movzx	eax, cl

; 2079 :          while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes

	cmp	eax, 255				; 000000ffH
	jne	SHORT $LN6@stbi__grow
	npad	5
$LL5@stbi__grow:
	mov	rbx, QWORD PTR [rdi]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN21@stbi__grow

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN20@stbi__grow
$LN21@stbi__grow:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN22@stbi__grow

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN20@stbi__grow
$LN22@stbi__grow:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN20@stbi__grow:

; 2079 :          while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes

	movzx	eax, cl
	cmp	eax, 255				; 000000ffH
	je	SHORT $LL5@stbi__grow
$LN6@stbi__grow:

; 2080 :          if (c != 0) {

	test	eax, eax
	jne	SHORT $LN26@stbi__grow
$LN8@stbi__grow:

; 2081 :             j->marker = (unsigned char) c;
; 2082 :             j->nomore = 1;
; 2083 :             return;
; 2084 :          }
; 2085 :       }
; 2086 :       j->code_buffer |= b << (24 - j->code_bits);

	mov	eax, DWORD PTR [rdi+18468]
	mov	ecx, 24
	sub	ecx, eax

; 2087 :       j->code_bits += 8;

	add	eax, 8
	shl	esi, cl
	or	DWORD PTR [rdi+18464], esi
	mov	DWORD PTR [rdi+18468], eax

; 2088 :    } while (j->code_bits <= 24);

	cmp	eax, 24
	jle	$LL4@stbi__grow
	mov	rsi, QWORD PTR [rsp+48]

; 2089 : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN26@stbi__grow:
	mov	rsi, QWORD PTR [rsp+48]
	mov	rbx, QWORD PTR [rsp+56]
	mov	BYTE PTR [rdi+18472], al
	mov	DWORD PTR [rdi+18476], 1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ENDP	; stbi__grow_buffer_unsafe
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z
_TEXT	SEGMENT
j$ = 48
h$ = 56
?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z PROC ; stbi__jpeg_huff_decode, COMDAT

; 2096 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2097 :    unsigned int temp;
; 2098 :    int c,k;
; 2099 : 
; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	cmp	DWORD PTR [rcx+18468], 16
	mov	rdi, rdx
	mov	rbx, rcx
	jge	SHORT $LN5@stbi__jpeg
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN5@stbi__jpeg:

; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

	mov	r9d, DWORD PTR [rbx+18464]
	mov	eax, r9d
	shr	rax, 23

; 2105 :    k = h->fast[c];

	movzx	ecx, BYTE PTR [rax+rdi]

; 2106 :    if (k < 255) {

	cmp	cl, 255					; 000000ffH
	jae	SHORT $LN6@stbi__jpeg

; 2107 :       int s = h->size[k];
; 2108 :       if (s > j->code_bits)

	mov	eax, DWORD PTR [rbx+18468]
	mov	edx, ecx
	movzx	ecx, BYTE PTR [rcx+rdi+1280]
	cmp	ecx, eax
	jg	SHORT $LN12@stbi__jpeg

; 2109 :          return -1;
; 2110 :       j->code_buffer <<= s;

	shl	r9d, cl

; 2111 :       j->code_bits -= s;

	sub	eax, ecx
	mov	DWORD PTR [rbx+18464], r9d
	mov	DWORD PTR [rbx+18468], eax

; 2112 :       return h->values[k];

	movzx	eax, BYTE PTR [rdx+rdi+1024]

; 2144 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@stbi__jpeg:

; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;

	mov	ecx, r9d

; 2123 :       if (temp < h->maxcode[k])

	lea	rax, QWORD PTR [rdi+1580]
	shr	ecx, 16
	mov	r8d, 10
	cmp	ecx, DWORD PTR [rax]
	jb	SHORT $LN16@stbi__jpeg
$LL4@stbi__jpeg:

; 2122 :    for (k=FAST_BITS+1 ; ; ++k)

	inc	r8d
	lea	rax, QWORD PTR [rax+4]

; 2123 :       if (temp < h->maxcode[k])

	cmp	ecx, DWORD PTR [rax]
	jae	SHORT $LL4@stbi__jpeg
$LN16@stbi__jpeg:

; 2124 :          break;
; 2125 :    if (k == 17) {

	mov	r10d, DWORD PTR [rbx+18468]
	cmp	r8d, 17
	jne	SHORT $LN9@stbi__jpeg

; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;

	lea	eax, DWORD PTR [r10-16]
	mov	DWORD PTR [rbx+18468], eax
$LN12@stbi__jpeg:

; 2144 : }

	mov	eax, -1
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN9@stbi__jpeg:

; 2128 :       return -1;
; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)

	cmp	r8d, r10d
	jg	SHORT $LN12@stbi__jpeg

; 2132 :       return -1;
; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];

	mov	ecx, 32					; 00000020H
	movsxd	rax, r8d
	sub	ecx, r8d
	mov	r11d, r9d
	shr	r11d, cl
	lea	rcx, OFFSET FLAT:?stbi__bmask@@3QBIB
	and	r11d, DWORD PTR [rcx+rax*4]
	add	r11d, DWORD PTR [rdi+rax*4+1612]

; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!

	cmp	r11d, 255				; 000000ffH
	ja	SHORT $LN12@stbi__jpeg

; 2137 :        return -1;
; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;

	sub	r10d, r8d

; 2142 :    j->code_buffer <<= k;
; 2143 :    return h->values[c];

	movsxd	rax, r11d
	mov	DWORD PTR [rbx+18468], r10d
	mov	ecx, r8d
	shl	r9d, cl
	mov	DWORD PTR [rbx+18464], r9d
	movzx	eax, BYTE PTR [rax+rdi+1024]

; 2144 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ENDP ; stbi__jpeg_huff_decode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z
_TEXT	SEGMENT
j$ = 48
n$ = 56
?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z PROC	; stbi__extend_receive, COMDAT

; 2152 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx

; 2153 :    unsigned int k;
; 2154 :    int sgn;
; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

	cmp	DWORD PTR [rcx+18468], edi
	jge	SHORT $LN2@stbi__exte
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN2@stbi__exte:

; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

	mov	r10d, DWORD PTR [rbx+18468]
	cmp	r10d, edi
	jge	SHORT $LN3@stbi__exte
	xor	eax, eax

; 2164 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@stbi__exte:

; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)

	mov	r9d, DWORD PTR [rbx+18464]

; 2159 :    k = stbi_lrot(j->code_buffer, n);
; 2160 :    j->code_buffer = k & ~stbi__bmask[n];

	lea	r11, OFFSET FLAT:__ImageBase
	mov	r8d, r9d
	mov	ecx, edi
	rol	r8d, cl

; 2161 :    k &= stbi__bmask[n];
; 2162 :    j->code_bits -= n;

	sub	r10d, edi
	lea	rcx, QWORD PTR [rdi*4]
	shr	r9d, 31
	mov	edx, DWORD PTR ?stbi__bmask@@3QBIB[rcx+r11]

; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));

	dec	r9d
	mov	eax, edx
	mov	DWORD PTR [rbx+18468], r10d
	not	eax
	and	edx, r8d
	and	eax, r8d
	mov	DWORD PTR [rbx+18464], eax
	mov	eax, DWORD PTR ?stbi__jbias@@3QBHB[rcx+r11]

; 2164 : }

	mov	rbx, QWORD PTR [rsp+48]
	and	eax, r9d
	add	eax, edx
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z ENDP	; stbi__extend_receive
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z
_TEXT	SEGMENT
j$ = 48
n$ = 56
?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z PROC	; stbi__jpeg_get_bits, COMDAT

; 2168 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx

; 2169 :    unsigned int k;
; 2170 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

	cmp	DWORD PTR [rcx+18468], edi
	jge	SHORT $LN2@stbi__jpeg
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN2@stbi__jpeg:

; 2171 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

	mov	r8d, DWORD PTR [rbx+18468]
	cmp	r8d, edi
	jge	SHORT $LN3@stbi__jpeg
	xor	eax, eax

; 2176 :    return k;
; 2177 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@stbi__jpeg:

; 2172 :    k = stbi_lrot(j->code_buffer, n);

	mov	edx, DWORD PTR [rbx+18464]
	mov	ecx, edi
	rol	edx, cl

; 2173 :    j->code_buffer = k & ~stbi__bmask[n];
; 2174 :    k &= stbi__bmask[n];
; 2175 :    j->code_bits -= n;

	sub	r8d, edi
	lea	rcx, OFFSET FLAT:?stbi__bmask@@3QBIB
	mov	DWORD PTR [rbx+18468], r8d
	mov	eax, DWORD PTR [rcx+rdi*4]
	mov	ecx, eax
	not	ecx
	and	ecx, edx
	mov	DWORD PTR [rbx+18464], ecx
	and	eax, edx

; 2176 :    return k;
; 2177 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z ENDP	; stbi__jpeg_get_bits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z
_TEXT	SEGMENT
j$ = 48
?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z PROC		; stbi__jpeg_get_bit, COMDAT

; 2180 : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 2181 :    unsigned int k;
; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);

	cmp	DWORD PTR [rcx+18468], 1
	mov	rbx, rcx
	jge	SHORT $LN2@stbi__jpeg
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN2@stbi__jpeg:

; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing

	mov	edx, DWORD PTR [rbx+18468]
	cmp	edx, 1
	jge	SHORT $LN3@stbi__jpeg
	xor	eax, eax

; 2188 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@stbi__jpeg:

; 2184 :    k = j->code_buffer;

	mov	eax, DWORD PTR [rbx+18464]

; 2185 :    j->code_buffer <<= 1;

	lea	ecx, DWORD PTR [rax+rax]

; 2186 :    --j->code_bits;
; 2187 :    return k & 0x80000000;

	and	eax, -2147483648			; 80000000H
	mov	DWORD PTR [rbx+18464], ecx
	lea	ecx, DWORD PTR [rdx-1]
	mov	DWORD PTR [rbx+18468], ecx

; 2188 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z ENDP		; stbi__jpeg_get_bit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z
_TEXT	SEGMENT
j$ = 80
data$ = 88
hdc$ = 96
hac$ = 104
fac$ = 112
b$ = 120
dequant$ = 128
?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z PROC ; stbi__jpeg_decode_block, COMDAT

; 2209 : {

	push	rbx
	push	rbp
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2210 :    int diff,dc,k;
; 2211 :    int t;
; 2212 : 
; 2213 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	cmp	DWORD PTR [rcx+18468], 16
	mov	r14, r9
	mov	rdi, r8
	mov	r15, rdx
	mov	rbx, rcx
	jge	SHORT $LN5@stbi__jpeg
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN5@stbi__jpeg:

; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	cmp	DWORD PTR [rbx+18468], 16
	jge	SHORT $LN25@stbi__jpeg
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN25@stbi__jpeg:

; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

	mov	r9d, DWORD PTR [rbx+18464]

; 2106 :    if (k < 255) {

	lea	rbp, OFFSET FLAT:__ImageBase
	mov	eax, r9d
	shr	rax, 23
	movzx	ecx, BYTE PTR [rax+rdi]
	cmp	cl, 255					; 000000ffH
	jae	SHORT $LN26@stbi__jpeg

; 2107 :       int s = h->size[k];
; 2108 :       if (s > j->code_bits)

	mov	eax, DWORD PTR [rbx+18468]
	mov	edx, ecx
	movzx	ecx, BYTE PTR [rcx+rdi+1280]
	cmp	ecx, eax
	jg	SHORT $LN7@stbi__jpeg

; 2109 :          return -1;
; 2110 :       j->code_buffer <<= s;

	shl	r9d, cl

; 2111 :       j->code_bits -= s;

	sub	eax, ecx
	mov	DWORD PTR [rbx+18464], r9d
	mov	DWORD PTR [rbx+18468], eax

; 2112 :       return h->values[k];

	movzx	eax, BYTE PTR [rdx+rdi+1024]
	jmp	$LN21@stbi__jpeg
$LN26@stbi__jpeg:

; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;

	mov	ecx, r9d

; 2123 :       if (temp < h->maxcode[k])

	lea	rax, QWORD PTR [rdi+1580]
	shr	ecx, 16
	mov	r8d, 10
	cmp	ecx, DWORD PTR [rax]
	jb	SHORT $LN74@stbi__jpeg
	npad	1
$LL24@stbi__jpeg:

; 2122 :    for (k=FAST_BITS+1 ; ; ++k)

	inc	r8d
	lea	rax, QWORD PTR [rax+4]

; 2123 :       if (temp < h->maxcode[k])

	cmp	ecx, DWORD PTR [rax]
	jae	SHORT $LL24@stbi__jpeg
$LN74@stbi__jpeg:

; 2124 :          break;
; 2125 :    if (k == 17) {

	mov	r10d, DWORD PTR [rbx+18468]
	cmp	r8d, 17
	jne	SHORT $LN29@stbi__jpeg

; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;

	lea	eax, DWORD PTR [r10-16]
	mov	DWORD PTR [rbx+18468], eax
$LN7@stbi__jpeg:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
	mov	QWORD PTR [rdx+rcx], rax

; 2214 :    t = stbi__jpeg_huff_decode(j, hdc);
; 2215 :    if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");

	xor	eax, eax

; 2261 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN29@stbi__jpeg:

; 2131 :    if (k > j->code_bits)

	cmp	r8d, r10d
	jg	SHORT $LN7@stbi__jpeg

; 2132 :       return -1;
; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];

	movsxd	rax, r8d
	mov	ecx, 32					; 00000020H
	sub	ecx, r8d
	mov	r11d, r9d
	shr	r11d, cl
	and	r11d, DWORD PTR ?stbi__bmask@@3QBIB[rbp+rax*4]
	add	r11d, DWORD PTR [rdi+rax*4+1612]

; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!

	cmp	r11d, 255				; 000000ffH
	ja	SHORT $LN7@stbi__jpeg

; 2137 :        return -1;
; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;

	sub	r10d, r8d

; 2142 :    j->code_buffer <<= k;
; 2143 :    return h->values[c];

	movsxd	rax, r11d
	mov	ecx, r8d
	mov	DWORD PTR [rbx+18468], r10d
	shl	r9d, cl
	mov	DWORD PTR [rbx+18464], r9d
	movzx	eax, BYTE PTR [rax+rdi+1024]
$LN21@stbi__jpeg:

; 2214 :    t = stbi__jpeg_huff_decode(j, hdc);
; 2215 :    if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");

	movzx	edi, al
	cmp	edi, 15
	ja	$LN7@stbi__jpeg

; 2216 : 
; 2217 :    // 0 all the ac values now so we can do it 32-bits at a time
; 2218 :    memset(data,0,64*sizeof(data[0]));

	xorps	xmm0, xmm0
	movups	XMMWORD PTR [r15], xmm0
	movups	XMMWORD PTR [r15+16], xmm0
	movups	XMMWORD PTR [r15+32], xmm0
	movups	XMMWORD PTR [r15+48], xmm0
	movups	XMMWORD PTR [r15+64], xmm0
	movups	XMMWORD PTR [r15+80], xmm0
	movups	XMMWORD PTR [r15+96], xmm0
	movups	XMMWORD PTR [r15+112], xmm0

; 2219 : 
; 2220 :    diff = t ? stbi__extend_receive(j, t) : 0;

	test	al, al
	je	SHORT $LN19@stbi__jpeg

; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

	cmp	DWORD PTR [rbx+18468], edi
	jge	SHORT $LN37@stbi__jpeg
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN37@stbi__jpeg:

; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

	mov	r10d, DWORD PTR [rbx+18468]
	cmp	r10d, edi
	jl	SHORT $LN19@stbi__jpeg

; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)

	mov	r9d, DWORD PTR [rbx+18464]

; 2159 :    k = stbi_lrot(j->code_buffer, n);

	mov	ecx, edi
	mov	r8d, r9d

; 2161 :    k &= stbi__bmask[n];
; 2162 :    j->code_bits -= n;

	sub	r10d, edi
	rol	r8d, cl
	lea	rcx, QWORD PTR [rdi*4]
	mov	edx, DWORD PTR ?stbi__bmask@@3QBIB[rcx+rbp]
	mov	eax, edx
	shr	r9d, 31
	not	eax

; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));

	dec	r9d
	mov	DWORD PTR [rbx+18468], r10d
	and	r9d, DWORD PTR ?stbi__jbias@@3QBHB[rcx+rbp]
	and	eax, r8d
	and	edx, r8d
	mov	DWORD PTR [rbx+18464], eax
	add	r9d, edx

; 2164 : }

	jmp	SHORT $LN20@stbi__jpeg
$LN19@stbi__jpeg:

; 2221 :    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");

	xor	r9d, r9d
$LN20@stbi__jpeg:
	movsxd	rax, DWORD PTR b$[rsp]
	lea	r8, QWORD PTR [rax+rax*2]

; 1070 :    if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow

	mov	eax, r9d

; 2221 :    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");

	shl	r8, 5

; 1070 :    if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow

	not	eax

; 2221 :    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");

	mov	edx, DWORD PTR [r8+rbx+18104]

; 1070 :    if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow

	mov	ecx, edx
	not	ecx
	xor	ecx, eax
	js	SHORT $LN8@stbi__jpeg

; 1071 :    if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.

	test	edx, edx
	jns	SHORT $LN42@stbi__jpeg
	test	r9d, r9d
	jns	SHORT $LN42@stbi__jpeg
	xor	ecx, ecx
	mov	eax, -2147483648			; ffffffff80000000H
	sub	eax, r9d
	cmp	edx, eax
	setge	cl
	jmp	SHORT $LN40@stbi__jpeg
$LN42@stbi__jpeg:

; 1072 :    return a <= INT_MAX - b;

	xor	ecx, ecx
	mov	eax, 2147483647				; 7fffffffH
	sub	eax, r9d
	cmp	edx, eax
	setle	cl
$LN40@stbi__jpeg:

; 2221 :    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");

	test	ecx, ecx
	jne	SHORT $LN8@stbi__jpeg

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_09IFDKCGFO@bad?5delta@
	mov	QWORD PTR [rdx+rcx], rax

; 2221 :    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");

	xor	eax, eax

; 2261 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN8@stbi__jpeg:

; 2222 :    dc = j->img_comp[b].dc_pred + diff;

	lea	r11d, DWORD PTR [rdx+r9]
	mov	QWORD PTR [rsp+88], r12

; 2223 :    j->img_comp[b].dc_pred = dc;
; 2224 :    if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	mov	r12, QWORD PTR dequant$[rsp]
	movzx	ecx, r11w
	mov	DWORD PTR [r8+rbx+18104], r11d
	movsx	edi, WORD PTR [r12]
	movzx	edx, di
	call	?stbi__mul2shorts_valid@@YAHFF@Z	; stbi__mul2shorts_valid
	test	eax, eax
	jne	SHORT $LN9@stbi__jpeg

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	r12, QWORD PTR [rsp+88]
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
	mov	QWORD PTR [rdx+rcx], rax

; 2223 :    j->img_comp[b].dc_pred = dc;
; 2224 :    if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	xor	eax, eax

; 2261 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN9@stbi__jpeg:
	mov	QWORD PTR [rsp+96], r13

; 2225 :    data[0] = (short) (dc * dequant[0]);
; 2226 : 
; 2227 :    // decode AC components, see JPEG spec
; 2228 :    k = 1;

	mov	r13, QWORD PTR fac$[rsp]
	movsx	ecx, r11w
	imul	ecx, edi
	mov	edi, 1
	mov	QWORD PTR [rsp+80], rsi
	mov	WORD PTR [r15], cx
$LL4@stbi__jpeg:

; 2229 :    do {
; 2230 :       unsigned int zig;
; 2231 :       int c,r,s;
; 2232 :       if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	cmp	DWORD PTR [rbx+18468], 16
	jge	SHORT $LN10@stbi__jpeg
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN10@stbi__jpeg:

; 2233 :       c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

	mov	r9d, DWORD PTR [rbx+18464]

; 2234 :       r = fac[c];

	mov	edx, DWORD PTR [rbx+18468]
	mov	eax, r9d
	shr	rax, 23
	movsx	r8d, WORD PTR [r13+rax*2]

; 2235 :       if (r) { // fast-AC path

	test	r8d, r8d
	je	SHORT $LN11@stbi__jpeg

; 2236 :          k += (r >> 4) & 15; // run

	mov	eax, r8d

; 2237 :          s = r & 15; // combined length

	mov	ecx, r8d
	sar	eax, 4
	and	ecx, 15
	and	eax, 15
	add	edi, eax

; 2238 :          if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");

	cmp	ecx, edx
	jg	$LN77@stbi__jpeg

; 2239 :          j->code_buffer <<= s;
; 2240 :          j->code_bits -= s;

	sub	edx, ecx

; 2241 :          // decode into unzigzag'd location
; 2242 :          zig = stbi__jpeg_dezigzag[k++];

	movsxd	rax, edi
	mov	DWORD PTR [rbx+18468], edx
	inc	edi
	shl	r9d, cl
	mov	DWORD PTR [rbx+18464], r9d

; 2243 :          data[zig] = (short) ((r >> 8) * dequant[zig]);

	movzx	edx, BYTE PTR ?stbi__jpeg_dezigzag@@3QBEB[rax+rbp]
	add	rdx, rdx
	sar	r8d, 8
	movsx	eax, r8w

; 2244 :       } else {

	jmp	$LN127@stbi__jpeg
$LN11@stbi__jpeg:

; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	cmp	edx, 16
	jge	SHORT $LN54@stbi__jpeg
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN54@stbi__jpeg:

; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

	mov	r11d, DWORD PTR [rbx+18464]
	mov	eax, r11d
	shr	rax, 23

; 2105 :    k = h->fast[c];

	movzx	ecx, BYTE PTR [rax+r14]

; 2106 :    if (k < 255) {

	cmp	cl, 255					; 000000ffH
	jae	SHORT $LN55@stbi__jpeg

; 2107 :       int s = h->size[k];
; 2108 :       if (s > j->code_bits)

	mov	r10d, DWORD PTR [rbx+18468]
	mov	eax, ecx
	movzx	ecx, BYTE PTR [rcx+r14+1280]
	cmp	ecx, r10d
	jg	$LN77@stbi__jpeg

; 2109 :          return -1;
; 2110 :       j->code_buffer <<= s;

	shl	r11d, cl

; 2111 :       j->code_bits -= s;

	sub	r10d, ecx

; 2112 :       return h->values[k];

	jmp	SHORT $LN128@stbi__jpeg
$LN55@stbi__jpeg:

; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;

	mov	ecx, r11d

; 2123 :       if (temp < h->maxcode[k])

	lea	rax, QWORD PTR [r14+1580]
	shr	ecx, 16
	mov	r8d, 10
	mov	r9d, r8d
	cmp	ecx, DWORD PTR [rax]
	jb	SHORT $LN75@stbi__jpeg
$LL53@stbi__jpeg:

; 2122 :    for (k=FAST_BITS+1 ; ; ++k)

	inc	r8d
	lea	rax, QWORD PTR [rax+4]
	inc	r9

; 2123 :       if (temp < h->maxcode[k])

	cmp	ecx, DWORD PTR [rax]
	jae	SHORT $LL53@stbi__jpeg
$LN75@stbi__jpeg:

; 2124 :          break;
; 2125 :    if (k == 17) {

	mov	r10d, DWORD PTR [rbx+18468]
	cmp	r8d, 17
	je	$LN89@stbi__jpeg

; 2128 :       return -1;
; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)

	cmp	r8d, r10d
	jg	$LN77@stbi__jpeg

; 2132 :       return -1;
; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];

	mov	ecx, 32					; 00000020H
	mov	edx, r11d
	sub	ecx, r8d
	shr	edx, cl
	and	edx, DWORD PTR ?stbi__bmask@@3QBIB[rbp+r9*4]
	mov	r9d, DWORD PTR [r14+r9*4+1612]
	add	r9d, edx

; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!

	cmp	r9d, 255				; 000000ffH
	ja	$LN77@stbi__jpeg

; 2137 :        return -1;
; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;

	sub	r10d, r8d

; 2142 :    j->code_buffer <<= k;
; 2143 :    return h->values[c];

	movsxd	rax, r9d
	mov	ecx, r8d
	shl	r11d, cl
$LN128@stbi__jpeg:

; 2247 :          s = rs & 15;

	mov	DWORD PTR [rbx+18468], r10d
	mov	DWORD PTR [rbx+18464], r11d
	movzx	eax, BYTE PTR [rax+r14+1024]
	mov	esi, eax
	and	esi, 15

; 2249 :          if (s == 0) {

	jne	SHORT $LN15@stbi__jpeg

; 2250 :             if (rs != 0xf0) break; // end block

	cmp	eax, 240				; 000000f0H
	jne	$LN3@stbi__jpeg

; 2251 :             k += 16;

	add	edi, 16

; 2252 :          } else {

	jmp	$LN2@stbi__jpeg
$LN15@stbi__jpeg:

; 2248 :          r = rs >> 4;

	shr	eax, 4

; 2253 :             k += r;

	add	edi, eax

; 2254 :             // decode into unzigzag'd location
; 2255 :             zig = stbi__jpeg_dezigzag[k++];

	movsxd	rax, edi
	inc	edi
	movzx	ebp, BYTE PTR ?stbi__jpeg_dezigzag@@3QBEB[rax+rbp]

; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

	cmp	r10d, esi
	jge	SHORT $LN66@stbi__jpeg
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN66@stbi__jpeg:

; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

	mov	r10d, DWORD PTR [rbx+18468]
	cmp	r10d, esi
	jge	SHORT $LN67@stbi__jpeg
	xor	r9d, r9d
	jmp	SHORT $LN65@stbi__jpeg
$LN67@stbi__jpeg:

; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)

	mov	r9d, DWORD PTR [rbx+18464]

; 2160 :    j->code_buffer = k & ~stbi__bmask[n];

	lea	r11, OFFSET FLAT:__ImageBase
	mov	r8d, r9d
	mov	ecx, esi
	rol	r8d, cl

; 2161 :    k &= stbi__bmask[n];
; 2162 :    j->code_bits -= n;

	sub	r10d, esi
	shr	r9d, 31
	lea	rcx, QWORD PTR [rsi*4]
	mov	edx, DWORD PTR ?stbi__bmask@@3QBIB[rcx+r11]

; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));

	dec	r9d
	and	r9d, DWORD PTR ?stbi__jbias@@3QBHB[rcx+r11]
	mov	eax, edx
	not	eax
	mov	DWORD PTR [rbx+18468], r10d
	and	eax, r8d
	and	edx, r8d
	mov	DWORD PTR [rbx+18464], eax
	add	r9d, edx
$LN65@stbi__jpeg:

; 2256 :             data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);

	lea	rdx, QWORD PTR [rbp*2]
	movsx	eax, r9w
	lea	rbp, OFFSET FLAT:__ImageBase
$LN127@stbi__jpeg:

; 2257 :          }
; 2258 :       }
; 2259 :    } while (k < 64);

	movsx	ecx, WORD PTR [rdx+r12]
	imul	ecx, eax
	mov	WORD PTR [rdx+r15], cx
$LN2@stbi__jpeg:
	cmp	edi, 64					; 00000040H
	jl	$LL4@stbi__jpeg
$LN3@stbi__jpeg:

; 2260 :    return 1;

	mov	eax, 1
$LN126@stbi__jpeg:
	mov	rsi, QWORD PTR [rsp+80]
	mov	r13, QWORD PTR [rsp+96]
	mov	r12, QWORD PTR [rsp+88]

; 2261 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN89@stbi__jpeg:

; 2127 :       j->code_bits -= 16;

	lea	eax, DWORD PTR [r10-16]
	mov	DWORD PTR [rbx+18468], eax
$LN77@stbi__jpeg:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
	mov	QWORD PTR [rdx+rcx], rax

; 2245 :          int rs = stbi__jpeg_huff_decode(j, hac);
; 2246 :          if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");

	xor	eax, eax
	jmp	SHORT $LN126@stbi__jpeg
?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z ENDP ; stbi__jpeg_decode_block
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z
_TEXT	SEGMENT
j$ = 48
data$ = 56
hdc$ = 64
b$ = 72
?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z PROC ; stbi__jpeg_decode_block_prog_dc, COMDAT

; 2264 : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 2265 :    int diff,dc;
; 2266 :    int t;
; 2267 :    if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	cmp	DWORD PTR [rcx+18488], 0
	mov	rsi, r8
	movsxd	rbp, r9d
	mov	rdi, rdx
	mov	rbx, rcx
	je	SHORT $LN2@stbi__jpeg

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
	mov	QWORD PTR [rdx+rcx], rax

; 2265 :    int diff,dc;
; 2266 :    int t;
; 2267 :    if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	xor	eax, eax
	jmp	$LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 2268 : 
; 2269 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	cmp	DWORD PTR [rcx+18468], 16
	jge	SHORT $LN3@stbi__jpeg
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN3@stbi__jpeg:

; 2270 : 
; 2271 :    if (j->succ_high == 0) {

	cmp	DWORD PTR [rbx+18492], 0
	mov	QWORD PTR [rsp+48], r14
	jne	$LN4@stbi__jpeg

; 2272 :       // first scan for DC coefficient, must be first
; 2273 :       memset(data,0,64*sizeof(data[0])); // 0 all the ac values now

	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rdi], xmm0
	movups	XMMWORD PTR [rdi+16], xmm0
	movups	XMMWORD PTR [rdi+32], xmm0
	movups	XMMWORD PTR [rdi+48], xmm0
	movups	XMMWORD PTR [rdi+64], xmm0
	movups	XMMWORD PTR [rdi+80], xmm0
	movups	XMMWORD PTR [rdi+96], xmm0
	movups	XMMWORD PTR [rdi+112], xmm0

; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	cmp	DWORD PTR [rbx+18468], 16
	jge	SHORT $LN20@stbi__jpeg
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN20@stbi__jpeg:

; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

	mov	r10d, DWORD PTR [rbx+18464]

; 2105 :    k = h->fast[c];
; 2106 :    if (k < 255) {

	lea	r14, OFFSET FLAT:__ImageBase
	mov	eax, r10d
	shr	rax, 23
	movzx	ecx, BYTE PTR [rax+rsi]
	cmp	cl, 255					; 000000ffH
	jae	SHORT $LN21@stbi__jpeg

; 2107 :       int s = h->size[k];
; 2108 :       if (s > j->code_bits)

	mov	r9d, DWORD PTR [rbx+18468]
	mov	eax, ecx
	movzx	ecx, BYTE PTR [rcx+rsi+1280]
	cmp	ecx, r9d
	jg	SHORT $LN7@stbi__jpeg

; 2109 :          return -1;
; 2110 :       j->code_buffer <<= s;

	shl	r10d, cl

; 2111 :       j->code_bits -= s;

	sub	r9d, ecx

; 2112 :       return h->values[k];

	jmp	$LN68@stbi__jpeg
$LN21@stbi__jpeg:

; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;

	mov	ecx, r10d

; 2123 :       if (temp < h->maxcode[k])

	lea	rax, QWORD PTR [rsi+1580]
	shr	ecx, 16
	mov	r8d, 10
	cmp	ecx, DWORD PTR [rax]
	jb	SHORT $LN44@stbi__jpeg
$LL19@stbi__jpeg:

; 2122 :    for (k=FAST_BITS+1 ; ; ++k)

	inc	r8d
	lea	rax, QWORD PTR [rax+4]

; 2123 :       if (temp < h->maxcode[k])

	cmp	ecx, DWORD PTR [rax]
	jae	SHORT $LL19@stbi__jpeg
$LN44@stbi__jpeg:

; 2124 :          break;
; 2125 :    if (k == 17) {

	mov	r9d, DWORD PTR [rbx+18468]
	cmp	r8d, 17
	jne	SHORT $LN24@stbi__jpeg

; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;

	lea	eax, DWORD PTR [r9-16]
	mov	DWORD PTR [rbx+18468], eax
$LN7@stbi__jpeg:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
	mov	QWORD PTR [rdx+rcx], rax

; 2274 :       t = stbi__jpeg_huff_decode(j, hdc);
; 2275 :       if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	xor	eax, eax
	jmp	$LN67@stbi__jpeg
$LN24@stbi__jpeg:

; 2131 :    if (k > j->code_bits)

	cmp	r8d, r9d
	jg	SHORT $LN7@stbi__jpeg

; 2132 :       return -1;
; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];

	movsxd	rax, r8d
	mov	ecx, 32					; 00000020H
	sub	ecx, r8d
	mov	r11d, r10d
	shr	r11d, cl
	and	r11d, DWORD PTR ?stbi__bmask@@3QBIB[r14+rax*4]
	add	r11d, DWORD PTR [rsi+rax*4+1612]

; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!

	cmp	r11d, 255				; 000000ffH
	ja	SHORT $LN7@stbi__jpeg

; 2137 :        return -1;
; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;

	sub	r9d, r8d

; 2142 :    j->code_buffer <<= k;
; 2143 :    return h->values[c];

	movsxd	rax, r11d
	mov	ecx, r8d
	shl	r10d, cl
$LN68@stbi__jpeg:

; 2274 :       t = stbi__jpeg_huff_decode(j, hdc);
; 2275 :       if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	mov	DWORD PTR [rbx+18468], r9d
	mov	DWORD PTR [rbx+18464], r10d
	movzx	eax, BYTE PTR [rax+rsi+1024]
	movzx	esi, al
	cmp	esi, 15
	ja	SHORT $LN7@stbi__jpeg

; 2276 :       diff = t ? stbi__extend_receive(j, t) : 0;

	test	al, al
	je	SHORT $LN12@stbi__jpeg

; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

	cmp	r9d, esi
	jge	SHORT $LN32@stbi__jpeg
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN32@stbi__jpeg:

; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

	mov	r9d, DWORD PTR [rbx+18468]
	cmp	r9d, esi
	jl	SHORT $LN12@stbi__jpeg

; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)

	mov	r10d, DWORD PTR [rbx+18464]

; 2159 :    k = stbi_lrot(j->code_buffer, n);

	mov	ecx, esi
	mov	r8d, r10d

; 2160 :    j->code_buffer = k & ~stbi__bmask[n];
; 2161 :    k &= stbi__bmask[n];
; 2162 :    j->code_bits -= n;

	sub	r9d, esi
	rol	r8d, cl
	lea	rcx, QWORD PTR [rsi*4]
	mov	edx, DWORD PTR ?stbi__bmask@@3QBIB[rcx+r14]
	mov	eax, edx
	shr	r10d, 31
	not	eax

; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));

	dec	r10d
	mov	DWORD PTR [rbx+18468], r9d
	and	r10d, DWORD PTR ?stbi__jbias@@3QBHB[rcx+r14]
	and	eax, r8d
	and	edx, r8d
	mov	DWORD PTR [rbx+18464], eax
	add	r10d, edx

; 2164 : }

	jmp	SHORT $LN13@stbi__jpeg
$LN12@stbi__jpeg:

; 2277 : 
; 2278 :       if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");

	xor	r10d, r10d
$LN13@stbi__jpeg:
	lea	r11, QWORD PTR [rbp*2]
	mov	edx, r10d
	add	r11, rbp
	shl	r11, 5
	mov	esi, DWORD PTR [r11+rbx+18104]
	mov	ecx, esi
	call	?stbi__addints_valid@@YAHHH@Z		; stbi__addints_valid
	test	eax, eax
	jne	SHORT $LN8@stbi__jpeg

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_09IFDKCGFO@bad?5delta@
	mov	QWORD PTR [rdx+rcx], rax

; 2277 : 
; 2278 :       if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");

	xor	eax, eax
	jmp	$LN67@stbi__jpeg
$LN8@stbi__jpeg:

; 2279 :       dc = j->img_comp[b].dc_pred + diff;

	add	esi, r10d

; 2280 :       j->img_comp[b].dc_pred = dc;

	mov	DWORD PTR [r11+rbx+18104], esi

; 2281 :       if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	mov	r11d, 1
	mov	ecx, DWORD PTR [rbx+18496]
	shl	r11w, cl
	movzx	ecx, si
	movzx	edx, r11w
	call	?stbi__mul2shorts_valid@@YAHFF@Z	; stbi__mul2shorts_valid
	test	eax, eax
	je	$LN7@stbi__jpeg

; 2282 :       data[0] = (short) (dc * (1 << j->succ_low));

	movsx	eax, si
	movsx	ecx, r11w
	imul	ecx, eax
	mov	WORD PTR [rdi], cx

; 2283 :    } else {

	jmp	SHORT $LN10@stbi__jpeg
$LN4@stbi__jpeg:

; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);

	cmp	DWORD PTR [rbx+18468], 1
	jge	SHORT $LN40@stbi__jpeg
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN40@stbi__jpeg:

; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing

	mov	r8d, DWORD PTR [rbx+18468]
	cmp	r8d, 1
	jl	SHORT $LN10@stbi__jpeg

; 2184 :    k = j->code_buffer;

	mov	edx, DWORD PTR [rbx+18464]

; 2185 :    j->code_buffer <<= 1;

	lea	ecx, DWORD PTR [rdx+rdx]
	mov	DWORD PTR [rbx+18464], ecx

; 2186 :    --j->code_bits;

	lea	ecx, DWORD PTR [r8-1]
	mov	DWORD PTR [rbx+18468], ecx

; 2284 :       // refinement scan for DC coefficient
; 2285 :       if (stbi__jpeg_get_bit(j))

	test	edx, edx
	jns	SHORT $LN10@stbi__jpeg

; 2286 :          data[0] += (short) (1 << j->succ_low);

	mov	ecx, DWORD PTR [rbx+18496]
	mov	edx, 1
	shl	dx, cl
	add	WORD PTR [rdi], dx
$LN10@stbi__jpeg:

; 2287 :    }
; 2288 :    return 1;

	mov	eax, 1
$LN67@stbi__jpeg:
	mov	r14, QWORD PTR [rsp+48]
$LN1@stbi__jpeg:

; 2289 : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z ENDP ; stbi__jpeg_decode_block_prog_dc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z
_TEXT	SEGMENT
j$ = 80
data$ = 88
hac$ = 96
fac$ = 104
?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z PROC ; stbi__jpeg_decode_block_prog_ac, COMDAT

; 2294 : {

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rdi
	push	r13
	push	r15
	sub	rsp, 40					; 00000028H

; 2295 :    int k;
; 2296 :    if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	movsxd	rdi, DWORD PTR [rcx+18484]
	mov	r15, r9
	mov	r13, r8
	mov	r10, rdx
	mov	rbx, rcx
	test	edi, edi
	jne	SHORT $LN13@stbi__jpeg

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
	mov	QWORD PTR [rdx+rcx], rax

; 2295 :    int k;
; 2296 :    if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	xor	eax, eax

; 2411 : }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r13
	pop	rdi
	pop	rbx
	ret	0
$LN13@stbi__jpeg:

; 2297 : 
; 2298 :    if (j->succ_high == 0) {

	cmp	DWORD PTR [rcx+18492], 0
	mov	eax, DWORD PTR [rcx+18500]
	mov	QWORD PTR [rsp+80], rbp
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+104], r12
	mov	QWORD PTR [rsp+32], r14
	mov	r14d, DWORD PTR [rcx+18496]
	jne	$LN14@stbi__jpeg

; 2299 :       int shift = j->succ_low;
; 2300 : 
; 2301 :       if (j->eob_run) {

	test	eax, eax
	je	SHORT $LN16@stbi__jpeg

; 2302 :          --j->eob_run;

	dec	eax
	mov	DWORD PTR [rcx+18500], eax

; 2303 :          return 1;

	mov	eax, 1
	jmp	$LN210@stbi__jpeg
$LN16@stbi__jpeg:

; 2304 :       }
; 2305 : 
; 2306 :       k = j->spec_start;

	lea	r12, OFFSET FLAT:__ImageBase
	npad	6
$LL4@stbi__jpeg:

; 2307 :       do {
; 2308 :          unsigned int zig;
; 2309 :          int c,r,s;
; 2310 :          if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	cmp	DWORD PTR [rbx+18468], 16
	jge	SHORT $LN17@stbi__jpeg
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	mov	r10, QWORD PTR data$[rsp]
$LN17@stbi__jpeg:

; 2311 :          c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

	mov	r9d, DWORD PTR [rbx+18464]

; 2312 :          r = fac[c];

	mov	r8d, DWORD PTR [rbx+18468]
	mov	eax, r9d
	shr	rax, 23
	movsx	edx, WORD PTR [r15+rax*2]

; 2313 :          if (r) { // fast-AC path

	test	edx, edx
	je	SHORT $LN18@stbi__jpeg

; 2314 :             k += (r >> 4) & 15; // run

	mov	eax, edx

; 2315 :             s = r & 15; // combined length

	mov	ecx, edx
	sar	eax, 4
	and	ecx, 15
	and	eax, 15
	add	edi, eax

; 2316 :             if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");

	cmp	ecx, r8d
	jg	$LN149@stbi__jpeg

; 2317 :             j->code_buffer <<= s;
; 2318 :             j->code_bits -= s;

	sub	r8d, ecx
	shl	r9d, cl

; 2319 :             zig = stbi__jpeg_dezigzag[k++];
; 2320 :             data[zig] = (short) ((r >> 8) * (1 << shift));

	mov	ecx, r14d
	mov	DWORD PTR [rbx+18468], r8d
	mov	eax, 1
	movsxd	r8, edi
	shl	ax, cl
	inc	edi
	sar	edx, 8
	movsx	ecx, ax
	movzx	eax, BYTE PTR ?stbi__jpeg_dezigzag@@3QBEB[r8+r12]
	movsx	edx, dx
	imul	edx, ecx
	mov	DWORD PTR [rbx+18464], r9d
	mov	WORD PTR [r10+rax*2], dx

; 2321 :          } else {

	jmp	$LN2@stbi__jpeg
$LN18@stbi__jpeg:

; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	cmp	r8d, 16
	jge	SHORT $LN58@stbi__jpeg
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN58@stbi__jpeg:

; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

	mov	r11d, DWORD PTR [rbx+18464]
	mov	eax, r11d
	shr	rax, 23

; 2105 :    k = h->fast[c];

	movzx	ecx, BYTE PTR [rax+r13]

; 2106 :    if (k < 255) {

	cmp	cl, 255					; 000000ffH
	jae	SHORT $LN59@stbi__jpeg

; 2107 :       int s = h->size[k];
; 2108 :       if (s > j->code_bits)

	mov	r10d, DWORD PTR [rbx+18468]
	mov	eax, ecx
	movzx	ecx, BYTE PTR [rcx+r13+1280]
	cmp	ecx, r10d
	jg	$LN149@stbi__jpeg

; 2109 :          return -1;
; 2110 :       j->code_buffer <<= s;

	shl	r11d, cl

; 2111 :       j->code_bits -= s;

	sub	r10d, ecx

; 2112 :       return h->values[k];

	jmp	SHORT $LN211@stbi__jpeg
$LN59@stbi__jpeg:

; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;

	mov	ecx, r11d

; 2123 :       if (temp < h->maxcode[k])

	lea	rax, QWORD PTR [r13+1580]
	shr	ecx, 16
	mov	r8d, 10
	mov	r9d, r8d
	cmp	ecx, DWORD PTR [rax]
	jb	SHORT $LN119@stbi__jpeg
$LL57@stbi__jpeg:

; 2122 :    for (k=FAST_BITS+1 ; ; ++k)

	inc	r8d
	lea	rax, QWORD PTR [rax+4]
	inc	r9

; 2123 :       if (temp < h->maxcode[k])

	cmp	ecx, DWORD PTR [rax]
	jae	SHORT $LL57@stbi__jpeg
$LN119@stbi__jpeg:

; 2124 :          break;
; 2125 :    if (k == 17) {

	mov	r10d, DWORD PTR [rbx+18468]
	cmp	r8d, 17
	je	$LN145@stbi__jpeg

; 2128 :       return -1;
; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)

	cmp	r8d, r10d
	jg	$LN149@stbi__jpeg

; 2132 :       return -1;
; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];

	mov	ecx, 32					; 00000020H
	mov	edx, r11d
	sub	ecx, r8d
	shr	edx, cl
	and	edx, DWORD PTR ?stbi__bmask@@3QBIB[r12+r9*4]
	mov	r9d, DWORD PTR [r13+r9*4+1612]
	add	r9d, edx

; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!

	cmp	r9d, 255				; 000000ffH
	ja	$LN149@stbi__jpeg

; 2137 :        return -1;
; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;

	sub	r10d, r8d

; 2142 :    j->code_buffer <<= k;
; 2143 :    return h->values[c];

	movsxd	rax, r9d
	mov	ecx, r8d
	shl	r11d, cl
$LN211@stbi__jpeg:

; 2324 :             s = rs & 15;

	mov	DWORD PTR [rbx+18468], r10d
	mov	DWORD PTR [rbx+18464], r11d
	movzx	esi, BYTE PTR [rax+r13+1024]
	mov	ebp, esi

; 2325 :             r = rs >> 4;

	shr	esi, 4
	and	ebp, 15

; 2326 :             if (s == 0) {

	jne	SHORT $LN22@stbi__jpeg

; 2327 :                if (r < 15) {

	cmp	esi, 15
	jb	$LN122@stbi__jpeg

; 2332 :                   break;
; 2333 :                }
; 2334 :                k += 16;
; 2335 :             } else {

	mov	r10, QWORD PTR data$[rsp]
	add	edi, 16
	jmp	$LN2@stbi__jpeg
$LN22@stbi__jpeg:

; 2336 :                k += r;

	add	edi, esi

; 2337 :                zig = stbi__jpeg_dezigzag[k++];

	movsxd	rax, edi
	inc	edi
	movzx	esi, BYTE PTR ?stbi__jpeg_dezigzag@@3QBEB[rax+r12]

; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

	cmp	r10d, ebp
	jge	SHORT $LN74@stbi__jpeg
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN74@stbi__jpeg:

; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

	mov	r10d, DWORD PTR [rbx+18468]
	cmp	r10d, ebp
	jge	SHORT $LN75@stbi__jpeg
	xor	r9d, r9d
	jmp	SHORT $LN73@stbi__jpeg
$LN75@stbi__jpeg:

; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)

	mov	r9d, DWORD PTR [rbx+18464]

; 2159 :    k = stbi_lrot(j->code_buffer, n);

	mov	ecx, ebp
	mov	r8d, r9d

; 2160 :    j->code_buffer = k & ~stbi__bmask[n];
; 2161 :    k &= stbi__bmask[n];
; 2162 :    j->code_bits -= n;

	sub	r10d, ebp
	rol	r8d, cl
	lea	rcx, QWORD PTR [rbp*4]
	mov	edx, DWORD PTR ?stbi__bmask@@3QBIB[rcx+r12]
	mov	eax, edx
	shr	r9d, 31
	not	eax

; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));

	dec	r9d
	mov	DWORD PTR [rbx+18468], r10d
	and	r9d, DWORD PTR ?stbi__jbias@@3QBHB[rcx+r12]
	and	eax, r8d
	and	edx, r8d
	mov	DWORD PTR [rbx+18464], eax
	add	r9d, edx
$LN73@stbi__jpeg:

; 2338 :                data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));

	mov	r10, QWORD PTR data$[rsp]
	mov	ecx, r14d
	mov	edx, 1
	movsx	eax, r9w
	shl	dx, cl
	movsx	ecx, dx
	imul	ecx, eax
	mov	WORD PTR [r10+rsi*2], cx
$LN2@stbi__jpeg:

; 2339 :             }
; 2340 :          }
; 2341 :       } while (k <= j->spec_end);

	cmp	edi, DWORD PTR [rbx+18488]
	jle	$LL4@stbi__jpeg

; 2408 :       }
; 2409 :    }
; 2410 :    return 1;

	mov	eax, 1
	jmp	$LN210@stbi__jpeg
$LN122@stbi__jpeg:

; 2328 :                   j->eob_run = (1 << r);

	mov	ecx, esi
	mov	r8d, 1
	shl	r8d, cl
	mov	DWORD PTR [rbx+18500], r8d

; 2329 :                   if (r)

	test	esi, esi
	je	SHORT $LN25@stbi__jpeg

; 2170 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

	cmp	r10d, esi
	jge	SHORT $LN70@stbi__jpeg
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	mov	r8d, DWORD PTR [rbx+18500]
$LN70@stbi__jpeg:

; 2171 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

	mov	r9d, DWORD PTR [rbx+18468]
	cmp	r9d, esi
	jge	SHORT $LN71@stbi__jpeg
	xor	ecx, ecx

; 2330 :                      j->eob_run += stbi__jpeg_get_bits(j, r);

	add	r8d, ecx

; 2331 :                   --j->eob_run;

	lea	eax, DWORD PTR [r8-1]
	mov	DWORD PTR [rbx+18500], eax

; 2408 :       }
; 2409 :    }
; 2410 :    return 1;

	lea	eax, QWORD PTR [rcx+1]
	jmp	$LN210@stbi__jpeg
$LN71@stbi__jpeg:

; 2172 :    k = stbi_lrot(j->code_buffer, n);

	mov	edx, DWORD PTR [rbx+18464]
	mov	ecx, esi
	rol	edx, cl

; 2173 :    j->code_buffer = k & ~stbi__bmask[n];
; 2174 :    k &= stbi__bmask[n];
; 2175 :    j->code_bits -= n;

	sub	r9d, esi
	mov	ecx, DWORD PTR ?stbi__bmask@@3QBIB[r12+rsi*4]
	mov	eax, ecx
	not	eax
	mov	DWORD PTR [rbx+18468], r9d
	and	eax, edx
	and	ecx, edx
	mov	DWORD PTR [rbx+18464], eax

; 2330 :                      j->eob_run += stbi__jpeg_get_bits(j, r);

	add	r8d, ecx
$LN25@stbi__jpeg:

; 2331 :                   --j->eob_run;

	lea	eax, DWORD PTR [r8-1]
	mov	DWORD PTR [rbx+18500], eax

; 2408 :       }
; 2409 :    }
; 2410 :    return 1;

	mov	eax, 1
	jmp	$LN210@stbi__jpeg
$LN145@stbi__jpeg:

; 2127 :       j->code_bits -= 16;

	lea	eax, DWORD PTR [r10-16]

; 2322 :             int rs = stbi__jpeg_huff_decode(j, hac);
; 2323 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");

	jmp	$LN212@stbi__jpeg
$LN14@stbi__jpeg:

; 2342 :    } else {
; 2343 :       // refinement scan for these AC coefficients
; 2344 : 
; 2345 :       short bit = (short) (1 << j->succ_low);

	mov	ebp, 1
	mov	ecx, r14d
	shl	bp, cl

; 2346 : 
; 2347 :       if (j->eob_run) {

	test	eax, eax
	je	$LN26@stbi__jpeg

; 2348 :          --j->eob_run;

	dec	eax
	mov	DWORD PTR [rbx+18500], eax

; 2349 :          for (k = j->spec_start; k <= j->spec_end; ++k) {

	cmp	edi, DWORD PTR [rbx+18488]
	jg	$LN9@stbi__jpeg
	lea	r12, OFFSET FLAT:__ImageBase
	lea	r14, QWORD PTR ?stbi__jpeg_dezigzag@@3QBEB[r12]
	add	r14, rdi
	npad	8
$LL7@stbi__jpeg:

; 2350 :             short *p = &data[stbi__jpeg_dezigzag[k]];

	movzx	eax, BYTE PTR [r14]

; 2351 :             if (*p != 0)

	cmp	WORD PTR [r10+rax*2], 0
	lea	rsi, QWORD PTR [r10+rax*2]
	je	SHORT $LN5@stbi__jpeg

; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);

	cmp	DWORD PTR [rbx+18468], 1
	jge	SHORT $LN78@stbi__jpeg
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	mov	r10, QWORD PTR data$[rsp]
$LN78@stbi__jpeg:

; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing

	mov	edx, DWORD PTR [rbx+18468]
	cmp	edx, 1
	jl	SHORT $LN5@stbi__jpeg

; 2184 :    k = j->code_buffer;

	mov	ecx, DWORD PTR [rbx+18464]

; 2185 :    j->code_buffer <<= 1;

	lea	eax, DWORD PTR [rcx+rcx]
	mov	DWORD PTR [rbx+18464], eax

; 2186 :    --j->code_bits;

	lea	eax, DWORD PTR [rdx-1]
	mov	DWORD PTR [rbx+18468], eax

; 2352 :                if (stbi__jpeg_get_bit(j))

	test	ecx, ecx
	jns	SHORT $LN5@stbi__jpeg

; 2353 :                   if ((*p & bit)==0) {

	movzx	eax, WORD PTR [rsi]
	test	ax, bp
	jne	SHORT $LN5@stbi__jpeg

; 2354 :                      if (*p > 0)

	test	ax, ax
	jle	SHORT $LN31@stbi__jpeg

; 2355 :                         *p += bit;

	add	ax, bp
	jmp	SHORT $LN213@stbi__jpeg
$LN31@stbi__jpeg:

; 2356 :                      else
; 2357 :                         *p -= bit;

	sub	ax, bp
$LN213@stbi__jpeg:

; 2349 :          for (k = j->spec_start; k <= j->spec_end; ++k) {

	mov	WORD PTR [rsi], ax
$LN5@stbi__jpeg:
	inc	edi
	inc	r14
	cmp	edi, DWORD PTR [rbx+18488]
	jle	SHORT $LL7@stbi__jpeg

; 2408 :       }
; 2409 :    }
; 2410 :    return 1;

	mov	eax, 1
	jmp	$LN210@stbi__jpeg
$LN26@stbi__jpeg:

; 2358 :                   }
; 2359 :          }
; 2360 :       } else {
; 2361 :          k = j->spec_start;

	mov	r12, rdi
	lea	r14, OFFSET FLAT:__ImageBase
$LL10@stbi__jpeg:

; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	cmp	DWORD PTR [rbx+18468], 16
	jge	SHORT $LN85@stbi__jpeg
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN85@stbi__jpeg:

; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

	mov	r11d, DWORD PTR [rbx+18464]
	mov	eax, r11d
	shr	rax, 23

; 2105 :    k = h->fast[c];

	movzx	ecx, BYTE PTR [rax+r13]

; 2106 :    if (k < 255) {

	cmp	cl, 255					; 000000ffH
	jae	SHORT $LN86@stbi__jpeg

; 2107 :       int s = h->size[k];
; 2108 :       if (s > j->code_bits)

	mov	r9d, DWORD PTR [rbx+18468]
	mov	eax, ecx
	movzx	ecx, BYTE PTR [rcx+r13+1280]
	cmp	ecx, r9d
	jg	$LN149@stbi__jpeg

; 2109 :          return -1;
; 2110 :       j->code_buffer <<= s;

	shl	r11d, cl

; 2111 :       j->code_bits -= s;

	sub	r9d, ecx

; 2112 :       return h->values[k];

	jmp	SHORT $LN214@stbi__jpeg
$LN86@stbi__jpeg:

; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;

	mov	ecx, r11d

; 2123 :       if (temp < h->maxcode[k])

	lea	rax, QWORD PTR [r13+1580]
	shr	ecx, 16
	mov	r8d, 10
	mov	r10d, r8d
	cmp	ecx, DWORD PTR [rax]
	jb	SHORT $LN123@stbi__jpeg
	npad	4
$LL84@stbi__jpeg:

; 2122 :    for (k=FAST_BITS+1 ; ; ++k)

	inc	r8d
	lea	rax, QWORD PTR [rax+4]
	inc	r10

; 2123 :       if (temp < h->maxcode[k])

	cmp	ecx, DWORD PTR [rax]
	jae	SHORT $LL84@stbi__jpeg
$LN123@stbi__jpeg:

; 2124 :          break;
; 2125 :    if (k == 17) {

	mov	r9d, DWORD PTR [rbx+18468]
	cmp	r8d, 17
	je	$LN148@stbi__jpeg

; 2128 :       return -1;
; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)

	cmp	r8d, r9d
	jg	$LN149@stbi__jpeg

; 2132 :       return -1;
; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];

	mov	ecx, 32					; 00000020H
	mov	edx, r11d
	sub	ecx, r8d
	shr	edx, cl
	and	edx, DWORD PTR ?stbi__bmask@@3QBIB[r14+r10*4]
	mov	r10d, DWORD PTR [r13+r10*4+1612]
	add	r10d, edx

; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!

	cmp	r10d, 255				; 000000ffH
	ja	$LN149@stbi__jpeg

; 2137 :        return -1;
; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;

	sub	r9d, r8d

; 2142 :    j->code_buffer <<= k;
; 2143 :    return h->values[c];

	movsxd	rax, r10d
	mov	ecx, r8d
	shl	r11d, cl
$LN214@stbi__jpeg:

; 2366 :             s = rs & 15;

	mov	DWORD PTR [rbx+18468], r9d
	mov	DWORD PTR [rbx+18464], r11d
	movzx	esi, BYTE PTR [rax+r13+1024]
	mov	r15d, esi

; 2367 :             r = rs >> 4;

	shr	esi, 4
	and	r15d, 15

; 2368 :             if (s == 0) {

	jne	$LN34@stbi__jpeg

; 2369 :                if (r < 15) {

	cmp	esi, 15
	jae	$LN116@stbi__jpeg

; 2370 :                   j->eob_run = (1 << r) - 1;

	mov	ecx, esi
	mov	r10d, 1
	shl	r10d, cl
	dec	r10d
	mov	DWORD PTR [rbx+18500], r10d

; 2371 :                   if (r)

	test	esi, esi
	je	SHORT $LN150@stbi__jpeg

; 2170 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

	cmp	r9d, esi
	jge	SHORT $LN97@stbi__jpeg
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	mov	r10d, DWORD PTR [rbx+18500]
$LN97@stbi__jpeg:

; 2171 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

	mov	r8d, DWORD PTR [rbx+18468]
	cmp	r8d, esi
	jge	SHORT $LN98@stbi__jpeg
	xor	ecx, ecx

; 2372 :                      j->eob_run += stbi__jpeg_get_bits(j, r);

	lea	eax, DWORD PTR [r10+rcx]
	mov	DWORD PTR [rbx+18500], eax

; 2373 :                   r = 64; // force end of block

	lea	esi, QWORD PTR [rcx+64]

; 2374 :                } else {
; 2375 :                   // r=15 s=0 should write 16 0s, so we just do
; 2376 :                   // a run of 15 0s and then write s (which is 0),
; 2377 :                   // so we don't have to do anything special here
; 2378 :                }
; 2379 :             } else {

	jmp	$LN116@stbi__jpeg
$LN98@stbi__jpeg:

; 2172 :    k = stbi_lrot(j->code_buffer, n);

	mov	edx, DWORD PTR [rbx+18464]
	mov	ecx, esi
	rol	edx, cl

; 2173 :    j->code_buffer = k & ~stbi__bmask[n];
; 2174 :    k &= stbi__bmask[n];
; 2175 :    j->code_bits -= n;

	sub	r8d, esi
	mov	ecx, DWORD PTR ?stbi__bmask@@3QBIB[r14+rsi*4]
	mov	eax, ecx
	not	eax
	mov	DWORD PTR [rbx+18468], r8d
	and	eax, edx
	and	ecx, edx
	mov	DWORD PTR [rbx+18464], eax

; 2372 :                      j->eob_run += stbi__jpeg_get_bits(j, r);

	lea	eax, DWORD PTR [r10+rcx]
	mov	DWORD PTR [rbx+18500], eax
$LN150@stbi__jpeg:

; 2373 :                   r = 64; // force end of block

	mov	esi, 64					; 00000040H

; 2374 :                } else {
; 2375 :                   // r=15 s=0 should write 16 0s, so we just do
; 2376 :                   // a run of 15 0s and then write s (which is 0),
; 2377 :                   // so we don't have to do anything special here
; 2378 :                }
; 2379 :             } else {

	jmp	SHORT $LN116@stbi__jpeg
$LN34@stbi__jpeg:

; 2380 :                if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");

	cmp	r15d, 1
	jne	$LN149@stbi__jpeg

; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);

	cmp	r9d, r15d
	jge	SHORT $LN103@stbi__jpeg
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN103@stbi__jpeg:

; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing

	mov	edx, DWORD PTR [rbx+18468]
	movsx	r15d, bp
	cmp	edx, 1
	jl	SHORT $LN40@stbi__jpeg

; 2184 :    k = j->code_buffer;

	mov	ecx, DWORD PTR [rbx+18464]

; 2185 :    j->code_buffer <<= 1;

	lea	eax, DWORD PTR [rcx+rcx]
	mov	DWORD PTR [rbx+18464], eax

; 2186 :    --j->code_bits;

	lea	eax, DWORD PTR [rdx-1]
	mov	DWORD PTR [rbx+18468], eax

; 2381 :                // sign bit
; 2382 :                if (stbi__jpeg_get_bit(j))

	test	ecx, ecx
	js	SHORT $LN116@stbi__jpeg
$LN40@stbi__jpeg:

; 2383 :                   s = bit;
; 2384 :                else
; 2385 :                   s = -bit;

	neg	r15d
$LN116@stbi__jpeg:

; 2386 :             }
; 2387 : 
; 2388 :             // advance by r
; 2389 :             while (k <= j->spec_end) {

	cmp	edi, DWORD PTR [rbx+18488]
	jg	$LN9@stbi__jpeg
	npad	6
$LL11@stbi__jpeg:

; 2390 :                short *p = &data[stbi__jpeg_dezigzag[k++]];

	movzx	eax, BYTE PTR ?stbi__jpeg_dezigzag@@3QBEB[r12+r14]
	inc	edi
	mov	rcx, QWORD PTR data$[rsp]
	inc	r12

; 2391 :                if (*p != 0) {

	cmp	WORD PTR [rcx+rax*2], 0
	lea	r14, QWORD PTR [rcx+rax*2]
	je	SHORT $LN42@stbi__jpeg

; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);

	cmp	DWORD PTR [rbx+18468], 1
	jge	SHORT $LN107@stbi__jpeg
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN107@stbi__jpeg:

; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing

	mov	edx, DWORD PTR [rbx+18468]
	cmp	edx, 1
	jl	SHORT $LN43@stbi__jpeg

; 2184 :    k = j->code_buffer;

	mov	ecx, DWORD PTR [rbx+18464]

; 2185 :    j->code_buffer <<= 1;

	lea	eax, DWORD PTR [rcx+rcx]
	mov	DWORD PTR [rbx+18464], eax

; 2186 :    --j->code_bits;

	lea	eax, DWORD PTR [rdx-1]
	mov	DWORD PTR [rbx+18468], eax

; 2392 :                   if (stbi__jpeg_get_bit(j))

	test	ecx, ecx
	jns	SHORT $LN43@stbi__jpeg

; 2393 :                      if ((*p & bit)==0) {

	movzx	eax, WORD PTR [r14]
	test	ax, bp
	jne	SHORT $LN43@stbi__jpeg

; 2394 :                         if (*p > 0)

	test	ax, ax
	jle	SHORT $LN46@stbi__jpeg

; 2395 :                            *p += bit;

	add	ax, bp
	mov	WORD PTR [r14], ax
	jmp	SHORT $LN43@stbi__jpeg
$LN46@stbi__jpeg:

; 2396 :                         else
; 2397 :                            *p -= bit;

	sub	ax, bp
	mov	WORD PTR [r14], ax

; 2398 :                      }
; 2399 :                } else {

	jmp	SHORT $LN43@stbi__jpeg
$LN42@stbi__jpeg:

; 2400 :                   if (r == 0) {

	test	esi, esi
	je	SHORT $LN124@stbi__jpeg

; 2402 :                      break;
; 2403 :                   }
; 2404 :                   --r;

	dec	esi
$LN43@stbi__jpeg:

; 2386 :             }
; 2387 : 
; 2388 :             // advance by r
; 2389 :             while (k <= j->spec_end) {

	lea	r14, OFFSET FLAT:__ImageBase
	cmp	edi, DWORD PTR [rbx+18488]
	jle	$LL11@stbi__jpeg

; 2405 :                }
; 2406 :             }
; 2407 :          } while (k <= j->spec_end);

	jmp	SHORT $LN216@stbi__jpeg
$LN124@stbi__jpeg:

; 2401 :                      *p = (short) s;

	mov	WORD PTR [r14], r15w
$LN216@stbi__jpeg:

; 2405 :                }
; 2406 :             }
; 2407 :          } while (k <= j->spec_end);

	lea	r14, OFFSET FLAT:__ImageBase
	cmp	edi, DWORD PTR [rbx+18488]
	jle	$LL10@stbi__jpeg
$LN9@stbi__jpeg:

; 2408 :       }
; 2409 :    }
; 2410 :    return 1;

	mov	eax, 1
	jmp	SHORT $LN210@stbi__jpeg
$LN148@stbi__jpeg:

; 2127 :       j->code_bits -= 16;

	lea	eax, DWORD PTR [r9-16]
$LN212@stbi__jpeg:
	mov	DWORD PTR [rbx+18468], eax
$LN149@stbi__jpeg:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
	mov	QWORD PTR [rdx+rcx], rax

; 2362 :          do {
; 2363 :             int r,s;
; 2364 :             int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
; 2365 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");

	xor	eax, eax
$LN210@stbi__jpeg:
	mov	r12, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+32]

; 2411 : }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r13
	pop	rdi
	pop	rbx
	ret	0
?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z ENDP ; stbi__jpeg_decode_block_prog_ac
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__clamp@@YAEH@Z
_TEXT	SEGMENT
x$ = 8
?stbi__clamp@@YAEH@Z PROC				; stbi__clamp, COMDAT

; 2416 :    // trick to use a single test to catch both cases
; 2417 :    if ((unsigned int) x > 255) {

	mov	edx, 255				; 000000ffH
	cmp	ecx, edx
	jbe	SHORT $LN4@stbi__clam

; 2418 :       if (x < 0) return 0;

	test	ecx, ecx
	jns	SHORT $LN3@stbi__clam
	xor	al, al

; 2422 : }

	ret	0
$LN3@stbi__clam:

; 2419 :       if (x > 255) return 255;

	cmp	ecx, edx
	movzx	eax, cl
	cmovg	eax, edx

; 2422 : }

	ret	0
$LN4@stbi__clam:

; 2420 :    }
; 2421 :    return (stbi_uc) x;

	movzx	eax, cl

; 2422 : }

	ret	0
?stbi__clamp@@YAEH@Z ENDP				; stbi__clamp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__idct_block@@YAXPEAEHQEAF@Z
_TEXT	SEGMENT
$T1 = 0
$T2 = 0
t3$3$ = 0
tv2372 = 8
tv2371 = 8
out$GSCopy$1$ = 16
tv2369 = 16
out_stride$GSCopy$1$ = 24
val$ = 32
__$ArrayPad$ = 288
out$ = 368
out_stride$ = 376
data$ = 384
?stbi__idct_block@@YAXPEAEHQEAF@Z PROC			; stbi__idct_block, COMDAT

; 2466 : {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 304				; 00000130H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR out_stride$GSCopy$1$[rsp], edx
	lea	rbp, QWORD PTR val$[rsp+32]
	mov	QWORD PTR out$GSCopy$1$[rsp], rcx
	lea	rax, QWORD PTR [r8+32]
	mov	QWORD PTR tv2372[rsp], 4
$LL4@stbi__idct:

; 2467 :    int i,val[64],*v=val;
; 2468 :    stbi_uc *o;
; 2469 :    short *d = data;
; 2470 : 
; 2471 :    // columns
; 2472 :    for (i=0; i < 8; ++i,++d, ++v) {
; 2473 :       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2474 :       if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2475 :            && d[40]==0 && d[48]==0 && d[56]==0) {

	movsx	ebx, WORD PTR [rax-16]
	test	bx, bx
	jne	SHORT $LN8@stbi__idct
	cmp	WORD PTR [rax], bx
	jne	SHORT $LN8@stbi__idct
	cmp	WORD PTR [rax+16], bx
	jne	SHORT $LN8@stbi__idct
	cmp	WORD PTR [rax+32], bx
	jne	SHORT $LN8@stbi__idct
	cmp	WORD PTR [rax+48], bx
	jne	SHORT $LN8@stbi__idct
	cmp	WORD PTR [rax+64], bx
	jne	SHORT $LN8@stbi__idct
	cmp	WORD PTR [rax+80], bx
	jne	SHORT $LN8@stbi__idct

; 2476 :          //    no shortcut                 0     seconds
; 2477 :          //    (1|2|3|4|5|6|7)==0          0     seconds
; 2478 :          //    all separate               -0.047 seconds
; 2479 :          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2480 :          int dcterm = d[0]*4;

	movsx	ecx, WORD PTR [rax-32]
	shl	ecx, 2

; 2481 :          v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;

	mov	DWORD PTR [rbp+192], ecx
	mov	r13d, ecx
	mov	DWORD PTR [rbp+160], ecx
	mov	edx, ecx
	mov	DWORD PTR [rbp+32], ecx
	mov	DWORD PTR [rbp], ecx
	mov	DWORD PTR [rbp-32], ecx

; 2482 :       } else {

	jmp	$LN2@stbi__idct
$LN8@stbi__idct:

; 2483 :          STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])

	movsx	r11d, WORD PTR [rax+16]
	movsx	r9d, WORD PTR [rax]
	movsx	edx, WORD PTR [rax+64]
	movsx	r14d, WORD PTR [rax+80]
	movsx	esi, WORD PTR [rax+48]
	movsx	r13d, WORD PTR [rax-32]
	lea	ecx, DWORD PTR [rdx+r9]
	imul	r8d, ecx, 2217				; 000008a9H
	imul	ecx, edx, 7567				; 00001d8fH
	imul	edx, r9d, 3135				; 00000c3fH
	lea	r9d, DWORD PTR [rsi+rbx]
	mov	r10d, r8d
	sub	r10d, ecx
	movsx	ecx, WORD PTR [rax+32]
	add	edx, r8d
	lea	r8d, DWORD PTR [rcx+r13]
	sub	r13d, ecx
	shl	r8d, 12
	shl	r13d, 12
	lea	r15d, DWORD PTR [r8+rdx]
	sub	r8d, edx
	lea	r12d, DWORD PTR [r10+r13]
	mov	DWORD PTR $T1[rsp], r8d
	sub	r13d, r10d
	lea	r8d, DWORD PTR [r14+r11]
	lea	ecx, DWORD PTR [r9+r8]
	mov	r10d, ebx
	imul	edi, ecx, 4816				; 000012d0H

; 2484 :          // constants scaled things up by 1<<12; let's bring them back
; 2485 :          // down, but keep 2 extra bits of precision
; 2486 :          x0 += 512; x1 += 512; x2 += 512; x3 += 512;

	add	r15d, 512				; 00000200H
	lea	ecx, DWORD PTR [r14+rbx]
	add	r12d, 512				; 00000200H
	imul	edx, ecx, 3685				; 00000e65H
	add	r13d, 512				; 00000200H
	lea	ecx, DWORD PTR [rsi+r11]
	mov	ebx, edi
	sub	ebx, edx
	imul	edx, ecx, 10497				; 00002901H
	imul	ecx, r9d, -1597				; fffffffffffff9c3H
	imul	r9d, r11d, 12586			; 0000312aH
	imul	r11d, r14d, 1223			; 000004c7H
	sub	edi, edx
	imul	edx, r8d, -8034				; ffffffffffffe09eH
	imul	r8d, r10d, 6149				; 00001805H
	imul	r10d, esi, 8410				; 000020daH
	add	r11d, ebx
	add	r9d, edx
	add	r11d, edx
	mov	edx, DWORD PTR $T1[rsp]
	add	r8d, ecx
	add	r10d, ecx
	add	r8d, ebx
	add	r9d, edi
	add	r10d, edi
	add	edx, 512				; 00000200H

; 2487 :          v[ 0] = (x0+t3) >> 10;

	lea	ecx, DWORD PTR [r15+r8]

; 2488 :          v[56] = (x0-t3) >> 10;

	sub	r15d, r8d
	sar	ecx, 10
	mov	DWORD PTR [rbp-32], ecx

; 2489 :          v[ 8] = (x1+t2) >> 10;

	lea	ecx, DWORD PTR [r12+r9]
	sar	ecx, 10

; 2490 :          v[48] = (x1-t2) >> 10;

	sub	r12d, r9d
	mov	DWORD PTR [rbp], ecx

; 2491 :          v[16] = (x2+t1) >> 10;

	lea	ecx, DWORD PTR [r10+r13]
	sar	ecx, 10

; 2492 :          v[40] = (x2-t1) >> 10;

	sub	r13d, r10d
	mov	DWORD PTR [rbp+32], ecx

; 2493 :          v[24] = (x3+t0) >> 10;

	lea	ecx, DWORD PTR [rdx+r11]
	sar	r15d, 10

; 2494 :          v[32] = (x3-t0) >> 10;

	sub	edx, r11d
	sar	r12d, 10
	sar	ecx, 10
	sar	r13d, 10
	sar	edx, 10
	mov	DWORD PTR [rbp+192], r15d
	mov	DWORD PTR [rbp+160], r12d
$LN2@stbi__idct:

; 2467 :    int i,val[64],*v=val;
; 2468 :    stbi_uc *o;
; 2469 :    short *d = data;
; 2470 : 
; 2471 :    // columns
; 2472 :    for (i=0; i < 8; ++i,++d, ++v) {
; 2473 :       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2474 :       if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2475 :            && d[40]==0 && d[48]==0 && d[56]==0) {

	mov	DWORD PTR [rbp+96], edx
	mov	DWORD PTR [rbp+128], r13d
	mov	DWORD PTR [rbp+64], ecx
	movsx	ebx, WORD PTR [rax-14]
	test	bx, bx
	jne	SHORT $LN56@stbi__idct
	cmp	WORD PTR [rax+2], bx
	jne	SHORT $LN56@stbi__idct
	cmp	WORD PTR [rax+18], bx
	jne	SHORT $LN56@stbi__idct
	cmp	WORD PTR [rax+34], bx
	jne	SHORT $LN56@stbi__idct
	cmp	WORD PTR [rax+50], bx
	jne	SHORT $LN56@stbi__idct
	cmp	WORD PTR [rax+66], bx
	jne	SHORT $LN56@stbi__idct
	cmp	WORD PTR [rax+82], bx
	jne	SHORT $LN56@stbi__idct

; 2476 :          //    no shortcut                 0     seconds
; 2477 :          //    (1|2|3|4|5|6|7)==0          0     seconds
; 2478 :          //    all separate               -0.047 seconds
; 2479 :          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2480 :          int dcterm = d[0]*4;

	movsx	ecx, WORD PTR [rax-30]
	shl	ecx, 2

; 2481 :          v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;

	mov	DWORD PTR [rbp+196], ecx
	mov	r13d, ecx
	mov	DWORD PTR [rbp+164], ecx
	mov	edx, ecx
	mov	DWORD PTR [rbp+36], ecx
	mov	DWORD PTR [rbp+4], ecx
	mov	DWORD PTR [rbp-28], ecx

; 2482 :       } else {

	jmp	$LN57@stbi__idct
$LN56@stbi__idct:

; 2483 :          STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])

	movsx	r11d, WORD PTR [rax+18]
	movsx	r9d, WORD PTR [rax+2]
	movsx	edx, WORD PTR [rax+66]
	movsx	r14d, WORD PTR [rax+82]
	movsx	esi, WORD PTR [rax+50]
	movsx	r13d, WORD PTR [rax-30]
	lea	ecx, DWORD PTR [rdx+r9]
	imul	r8d, ecx, 2217				; 000008a9H
	imul	ecx, edx, 7567				; 00001d8fH
	imul	edx, r9d, 3135				; 00000c3fH
	lea	r9d, DWORD PTR [rsi+rbx]
	mov	r10d, r8d
	sub	r10d, ecx
	movsx	ecx, WORD PTR [rax+34]
	add	edx, r8d
	lea	r8d, DWORD PTR [rcx+r13]
	sub	r13d, ecx
	shl	r8d, 12
	shl	r13d, 12
	lea	r15d, DWORD PTR [r8+rdx]
	sub	r8d, edx
	lea	r12d, DWORD PTR [r10+r13]
	mov	DWORD PTR $T2[rsp], r8d
	sub	r13d, r10d
	lea	r8d, DWORD PTR [r14+r11]
	lea	ecx, DWORD PTR [r9+r8]
	mov	r10d, ebx
	imul	edi, ecx, 4816				; 000012d0H

; 2484 :          // constants scaled things up by 1<<12; let's bring them back
; 2485 :          // down, but keep 2 extra bits of precision
; 2486 :          x0 += 512; x1 += 512; x2 += 512; x3 += 512;

	add	r15d, 512				; 00000200H
	lea	ecx, DWORD PTR [r14+rbx]
	add	r12d, 512				; 00000200H
	imul	edx, ecx, 3685				; 00000e65H
	add	r13d, 512				; 00000200H
	lea	ecx, DWORD PTR [rsi+r11]
	mov	ebx, edi
	sub	ebx, edx
	imul	edx, ecx, 10497				; 00002901H
	imul	ecx, r9d, -1597				; fffffffffffff9c3H
	imul	r9d, r11d, 12586			; 0000312aH
	imul	r11d, r14d, 1223			; 000004c7H
	sub	edi, edx
	imul	edx, r8d, -8034				; ffffffffffffe09eH
	imul	r8d, r10d, 6149				; 00001805H
	imul	r10d, esi, 8410				; 000020daH
	add	r11d, ebx
	add	r9d, edx
	add	r11d, edx
	mov	edx, DWORD PTR $T2[rsp]
	add	r8d, ecx
	add	r10d, ecx
	add	r8d, ebx
	add	r9d, edi
	add	r10d, edi
	add	edx, 512				; 00000200H

; 2487 :          v[ 0] = (x0+t3) >> 10;

	lea	ecx, DWORD PTR [r15+r8]

; 2488 :          v[56] = (x0-t3) >> 10;

	sub	r15d, r8d
	sar	ecx, 10
	mov	DWORD PTR [rbp-28], ecx

; 2489 :          v[ 8] = (x1+t2) >> 10;

	lea	ecx, DWORD PTR [r12+r9]
	sar	ecx, 10

; 2490 :          v[48] = (x1-t2) >> 10;

	sub	r12d, r9d
	mov	DWORD PTR [rbp+4], ecx

; 2491 :          v[16] = (x2+t1) >> 10;

	lea	ecx, DWORD PTR [r10+r13]
	sar	ecx, 10

; 2492 :          v[40] = (x2-t1) >> 10;

	sub	r13d, r10d
	mov	DWORD PTR [rbp+36], ecx

; 2493 :          v[24] = (x3+t0) >> 10;

	lea	ecx, DWORD PTR [rdx+r11]
	sar	r15d, 10

; 2494 :          v[32] = (x3-t0) >> 10;

	sub	edx, r11d
	sar	r12d, 10
	sar	ecx, 10
	sar	r13d, 10
	sar	edx, 10
	mov	DWORD PTR [rbp+196], r15d
	mov	DWORD PTR [rbp+164], r12d
$LN57@stbi__idct:
	mov	DWORD PTR [rbp+100], edx
	add	rax, 4
	mov	DWORD PTR [rbp+132], r13d
	mov	DWORD PTR [rbp+68], ecx
	add	rbp, 8
	sub	QWORD PTR tv2372[rsp], 1
	jne	$LL4@stbi__idct

; 2495 :       }
; 2496 :    }
; 2497 : 
; 2498 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {

	mov	r13, QWORD PTR out$GSCopy$1$[rsp]
	lea	r11, QWORD PTR val$[rsp+24]
	mov	QWORD PTR tv2371[rsp], r11
	inc	r13
	mov	QWORD PTR tv2369[rsp], 8
	npad	1
$LL7@stbi__idct:

; 2499 :       // no fast case since the first 1D IDCT spread components out
; 2500 :       STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])

	mov	r8d, DWORD PTR [r11-16]
	mov	ecx, DWORD PTR [r11]
	mov	esi, DWORD PTR [r11+4]
	mov	edi, DWORD PTR [r11-4]
	mov	r10d, DWORD PTR [r11-12]
	mov	r14d, DWORD PTR [r11-24]
	lea	eax, DWORD PTR [rcx+r8]
	imul	edx, eax, 2217				; 000008a9H
	imul	eax, ecx, 7567				; 00001d8fH
	imul	ecx, r8d, 3135				; 00000c3fH
	mov	r9d, edx
	sub	r9d, eax
	mov	eax, DWORD PTR [r11-8]
	add	ecx, edx
	lea	edx, DWORD PTR [rsi+r10]
	lea	r15d, DWORD PTR [rax+r14]
	sub	r14d, eax
	shl	r14d, 12
	shl	r15d, 12
	lea	r12d, DWORD PTR [r14+r9]
	sub	r14d, r9d
	mov	r9d, DWORD PTR [r11-20]
	lea	ebp, DWORD PTR [r15+rcx]
	sub	r15d, ecx

; 2501 :       // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2502 :       // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2503 :       // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2504 :       // so we want to round that, which means adding 0.5 * 1<<17,
; 2505 :       // aka 65536. Also, we'll end up with -128 to 127 that we want
; 2506 :       // to encode as 0..255 by adding 128, so we'll add that before the shift
; 2507 :       x0 += 65536 + (128<<17);

	add	ebp, 16842752				; 01010000H

; 2508 :       x1 += 65536 + (128<<17);

	add	r12d, 16842752				; 01010000H

; 2509 :       x2 += 65536 + (128<<17);

	add	r14d, 16842752				; 01010000H

; 2510 :       x3 += 65536 + (128<<17);

	add	r15d, 16842752				; 01010000H
	lea	r8d, DWORD PTR [rdi+r9]
	lea	eax, DWORD PTR [r8+rdx]
	imul	ebx, eax, 4816				; 000012d0H
	lea	eax, DWORD PTR [rsi+r9]
	imul	ecx, eax, 3685				; 00000e65H
	lea	eax, DWORD PTR [rdi+r10]
	mov	r11d, ebx
	sub	r11d, ecx
	imul	ecx, eax, 10497				; 00002901H
	imul	eax, r8d, -1597				; fffffffffffff9c3H
	imul	r8d, edi, 8410				; 000020daH
	sub	ebx, ecx
	imul	ecx, edx, -8034				; ffffffffffffe09eH
	imul	edx, r9d, 6149				; 00001805H
	add	r8d, eax
	imul	r9d, esi, 1223				; 000004c7H
	add	r8d, ebx
	add	edx, eax
	add	edx, r11d
	add	r9d, r11d
	mov	DWORD PTR t3$3$[rsp], edx
	add	r9d, ecx
	imul	edx, r10d, 12586			; 0000312aH
	add	edx, ecx

; 2511 :       // tried computing the shifts into temps, or'ing the temps to see
; 2512 :       // if any were out of range, but that was slower
; 2513 :       o[0] = stbi__clamp((x0+t3) >> 17);

	mov	ecx, DWORD PTR t3$3$[rsp]
	add	edx, ebx
	lea	eax, DWORD PTR [rcx+rbp]
	sar	eax, 17

; 2417 :    if ((unsigned int) x > 255) {

	cmp	eax, 255				; 000000ffH
	jbe	SHORT $LN14@stbi__idct

; 2418 :       if (x < 0) return 0;

	test	eax, eax
	jns	SHORT $LN13@stbi__idct
	xor	al, al
	jmp	SHORT $LN14@stbi__idct
$LN13@stbi__idct:

; 2419 :       if (x > 255) return 255;

	cmp	eax, 255				; 000000ffH
	jle	SHORT $LN14@stbi__idct
	mov	al, 255					; 000000ffH
$LN14@stbi__idct:

; 2514 :       o[7] = stbi__clamp((x0-t3) >> 17);

	sub	ebp, ecx
	mov	BYTE PTR [r13-1], al
	sar	ebp, 17

; 2417 :    if ((unsigned int) x > 255) {

	cmp	ebp, 255				; 000000ffH
	jbe	SHORT $LN19@stbi__idct

; 2418 :       if (x < 0) return 0;

	test	ebp, ebp
	jns	SHORT $LN18@stbi__idct
	xor	bpl, bpl
	jmp	SHORT $LN19@stbi__idct
$LN18@stbi__idct:

; 2419 :       if (x > 255) return 255;

	cmp	ebp, 255				; 000000ffH
	jle	SHORT $LN19@stbi__idct
	mov	bpl, 255				; 000000ffH
$LN19@stbi__idct:

; 2515 :       o[1] = stbi__clamp((x1+t2) >> 17);

	lea	eax, DWORD PTR [r12+rdx]
	mov	BYTE PTR [r13+6], bpl
	sar	eax, 17

; 2417 :    if ((unsigned int) x > 255) {

	cmp	eax, 255				; 000000ffH
	jbe	SHORT $LN24@stbi__idct

; 2418 :       if (x < 0) return 0;

	test	eax, eax
	jns	SHORT $LN23@stbi__idct
	xor	al, al
	jmp	SHORT $LN24@stbi__idct
$LN23@stbi__idct:

; 2419 :       if (x > 255) return 255;

	cmp	eax, 255				; 000000ffH
	jle	SHORT $LN24@stbi__idct
	mov	al, 255					; 000000ffH
$LN24@stbi__idct:

; 2516 :       o[6] = stbi__clamp((x1-t2) >> 17);

	sub	r12d, edx
	mov	BYTE PTR [r13], al
	sar	r12d, 17

; 2417 :    if ((unsigned int) x > 255) {

	cmp	r12d, 255				; 000000ffH
	jbe	SHORT $LN29@stbi__idct

; 2418 :       if (x < 0) return 0;

	test	r12d, r12d
	jns	SHORT $LN28@stbi__idct
	xor	r12b, r12b
	jmp	SHORT $LN29@stbi__idct
$LN28@stbi__idct:

; 2419 :       if (x > 255) return 255;

	cmp	r12d, 255				; 000000ffH
	jle	SHORT $LN29@stbi__idct
	mov	r12b, 255				; 000000ffH
$LN29@stbi__idct:

; 2517 :       o[2] = stbi__clamp((x2+t1) >> 17);

	lea	eax, DWORD PTR [r14+r8]
	mov	BYTE PTR [r13+5], r12b
	sar	eax, 17

; 2417 :    if ((unsigned int) x > 255) {

	cmp	eax, 255				; 000000ffH
	jbe	SHORT $LN34@stbi__idct

; 2418 :       if (x < 0) return 0;

	test	eax, eax
	jns	SHORT $LN33@stbi__idct
	xor	al, al
	jmp	SHORT $LN34@stbi__idct
$LN33@stbi__idct:

; 2419 :       if (x > 255) return 255;

	cmp	eax, 255				; 000000ffH
	jle	SHORT $LN34@stbi__idct
	mov	al, 255					; 000000ffH
$LN34@stbi__idct:

; 2518 :       o[5] = stbi__clamp((x2-t1) >> 17);

	sub	r14d, r8d
	mov	BYTE PTR [r13+1], al
	sar	r14d, 17

; 2417 :    if ((unsigned int) x > 255) {

	cmp	r14d, 255				; 000000ffH
	jbe	SHORT $LN39@stbi__idct

; 2418 :       if (x < 0) return 0;

	test	r14d, r14d
	jns	SHORT $LN38@stbi__idct
	xor	r14b, r14b
	jmp	SHORT $LN39@stbi__idct
$LN38@stbi__idct:

; 2419 :       if (x > 255) return 255;

	cmp	r14d, 255				; 000000ffH
	jle	SHORT $LN39@stbi__idct
	mov	r14b, 255				; 000000ffH
$LN39@stbi__idct:

; 2519 :       o[3] = stbi__clamp((x3+t0) >> 17);

	lea	eax, DWORD PTR [r15+r9]
	mov	BYTE PTR [r13+4], r14b
	sar	eax, 17

; 2417 :    if ((unsigned int) x > 255) {

	cmp	eax, 255				; 000000ffH
	jbe	SHORT $LN44@stbi__idct

; 2418 :       if (x < 0) return 0;

	test	eax, eax
	jns	SHORT $LN43@stbi__idct
	xor	al, al
	jmp	SHORT $LN44@stbi__idct
$LN43@stbi__idct:

; 2419 :       if (x > 255) return 255;

	cmp	eax, 255				; 000000ffH
	jle	SHORT $LN44@stbi__idct
	mov	al, 255					; 000000ffH
$LN44@stbi__idct:

; 2520 :       o[4] = stbi__clamp((x3-t0) >> 17);

	sub	r15d, r9d
	mov	BYTE PTR [r13+2], al
	sar	r15d, 17

; 2417 :    if ((unsigned int) x > 255) {

	cmp	r15d, 255				; 000000ffH
	jbe	SHORT $LN49@stbi__idct

; 2418 :       if (x < 0) return 0;

	test	r15d, r15d
	jns	SHORT $LN48@stbi__idct
	xor	r15b, r15b
	jmp	SHORT $LN49@stbi__idct
$LN48@stbi__idct:

; 2419 :       if (x > 255) return 255;

	cmp	r15d, 255				; 000000ffH
	jle	SHORT $LN49@stbi__idct
	mov	r15b, 255				; 000000ffH
$LN49@stbi__idct:

; 2495 :       }
; 2496 :    }
; 2497 : 
; 2498 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {

	mov	r11, QWORD PTR tv2371[rsp]
	movsxd	rcx, DWORD PTR out_stride$GSCopy$1$[rsp]
	add	r11, 32					; 00000020H

; 2520 :       o[4] = stbi__clamp((x3-t0) >> 17);

	mov	BYTE PTR [r13+3], r15b
	add	r13, rcx
	sub	QWORD PTR tv2369[rsp], 1
	mov	QWORD PTR tv2371[rsp], r11
	jne	$LL7@stbi__idct

; 2521 :    }
; 2522 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+384]
	add	rsp, 304				; 00000130H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?stbi__idct_block@@YAXPEAEHQEAF@Z ENDP			; stbi__idct_block
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__idct_simd@@YAXPEAEHQEAF@Z
_TEXT	SEGMENT
y5o_h$1$ = 0
abiased_h$1$ = 16
abiased_h$1$ = 16
p2$1$ = 32
t3e_l$1$ = 32
abiased_l$1$ = 48
row4$2$ = 48
x7_h$1$ = 64
t3e_h$1$ = 64
x6_h$1$ = 80
row5$2$ = 80
x6_l$1$ = 96
t2e_h$1$ = 96
x7_l$1$ = 112
t2e_l$1$ = 112
out$ = 304
out_stride$ = 312
data$ = 320
?stbi__idct_simd@@YAXPEAEHQEAF@Z PROC			; stbi__idct_simd, COMDAT

; 2529 : {

	mov	r11, rsp
	sub	rsp, 296				; 00000128H

; 2530 :    // This is constructed to match our regular (generic) integer IDCT exactly.
; 2531 :    __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2532 :    __m128i tmp;
; 2533 : 
; 2534 :    // dot product constant: even elems=x, odd elems=y
; 2535 :    #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2536 : 
; 2537 :    // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2538 :    // out(1) = c1[even]*x + c1[odd]*y
; 2539 :    #define dct_rot(out0,out1, x,y,c0,c1) \
; 2540 :       __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2541 :       __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2542 :       __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2543 :       __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2544 :       __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2545 :       __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2546 : 
; 2547 :    // out = in << 12  (in 16-bit, out 32-bit)
; 2548 :    #define dct_widen(out, in) \
; 2549 :       __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2550 :       __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2551 : 
; 2552 :    // wide add
; 2553 :    #define dct_wadd(out, a, b) \
; 2554 :       __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2555 :       __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2556 : 
; 2557 :    // wide sub
; 2558 :    #define dct_wsub(out, a, b) \
; 2559 :       __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2560 :       __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2561 : 
; 2562 :    // butterfly a/b, add bias, then shift by "s" and pack
; 2563 :    #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2564 :       { \
; 2565 :          __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2566 :          __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2567 :          dct_wadd(sum, abiased, b); \
; 2568 :          dct_wsub(dif, abiased, b); \
; 2569 :          out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2570 :          out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2571 :       }
; 2572 : 
; 2573 :    // 8-bit interleave step (for transposes)
; 2574 :    #define dct_interleave8(a, b) \
; 2575 :       tmp = a; \
; 2576 :       a = _mm_unpacklo_epi8(a, b); \
; 2577 :       b = _mm_unpackhi_epi8(tmp, b)
; 2578 : 
; 2579 :    // 16-bit interleave step (for transposes)
; 2580 :    #define dct_interleave16(a, b) \
; 2581 :       tmp = a; \
; 2582 :       a = _mm_unpacklo_epi16(a, b); \
; 2583 :       b = _mm_unpackhi_epi16(tmp, b)
; 2584 : 
; 2585 :    #define dct_pass(bias,shift) \
; 2586 :       { \
; 2587 :          /* even part */ \
; 2588 :          dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2589 :          __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2590 :          __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2591 :          dct_widen(t0e, sum04); \
; 2592 :          dct_widen(t1e, dif04); \
; 2593 :          dct_wadd(x0, t0e, t3e); \
; 2594 :          dct_wsub(x3, t0e, t3e); \
; 2595 :          dct_wadd(x1, t1e, t2e); \
; 2596 :          dct_wsub(x2, t1e, t2e); \
; 2597 :          /* odd part */ \
; 2598 :          dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2599 :          dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2600 :          __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2601 :          __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2602 :          dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2603 :          dct_wadd(x4, y0o, y4o); \
; 2604 :          dct_wadd(x5, y1o, y5o); \
; 2605 :          dct_wadd(x6, y2o, y5o); \
; 2606 :          dct_wadd(x7, y3o, y4o); \
; 2607 :          dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2608 :          dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2609 :          dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2610 :          dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2611 :       }
; 2612 : 
; 2613 :    __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
; 2614 :    __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
; 2615 :    __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
; 2616 :    __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
; 2617 :    __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
; 2618 :    __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
; 2619 :    __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
; 2620 :    __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
; 2621 : 
; 2622 :    // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2623 :    __m128i bias_0 = _mm_set1_epi32(512);
; 2624 :    __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
; 2625 : 
; 2626 :    // load
; 2627 :    row0 = _mm_load_si128((const __m128i *) (data + 0*8));
; 2628 :    row1 = _mm_load_si128((const __m128i *) (data + 1*8));

	movdqu	xmm3, XMMWORD PTR [r8+16]
	xorps	xmm1, xmm1

; 2629 :    row2 = _mm_load_si128((const __m128i *) (data + 2*8));
; 2630 :    row3 = _mm_load_si128((const __m128i *) (data + 3*8));
; 2631 :    row4 = _mm_load_si128((const __m128i *) (data + 4*8));
; 2632 :    row5 = _mm_load_si128((const __m128i *) (data + 5*8));

	movdqu	xmm5, XMMWORD PTR [r8+80]
	movdqu	xmm4, XMMWORD PTR [r8+48]
	movdqu	xmm2, XMMWORD PTR [r8]
	movaps	XMMWORD PTR [r11-24], xmm6
	movaps	XMMWORD PTR [r11-40], xmm7
	movdqu	xmm7, XMMWORD PTR [r8+32]
	movaps	XMMWORD PTR [r11-56], xmm8

; 2633 :    row6 = _mm_load_si128((const __m128i *) (data + 6*8));
; 2634 :    row7 = _mm_load_si128((const __m128i *) (data + 7*8));
; 2635 : 
; 2636 :    // column pass
; 2637 :    dct_pass(bias_0, 10);

	movdqa	xmm6, xmm7
	punpckhwd xmm7, XMMWORD PTR [r8+96]
	punpcklwd xmm6, XMMWORD PTR [r8+96]
	movdqa	xmm0, xmm7
	pmaddwd	xmm0, XMMWORD PTR __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
	pmaddwd	xmm7, XMMWORD PTR __xmm@08a914e808a914e808a914e808a914e8
	movdqu	xmm8, XMMWORD PTR [r8+112]
	movaps	XMMWORD PTR [r11-72], xmm9
	movaps	XMMWORD PTR [r11-88], xmm10
	movdqa	xmm10, xmm8
	movdqa	XMMWORD PTR t2e_h$1$[rsp], xmm0
	movaps	XMMWORD PTR [r11-104], xmm11
	movaps	XMMWORD PTR [r11-120], xmm12
	movaps	XMMWORD PTR [r11-136], xmm13
	movaps	XMMWORD PTR [r11-152], xmm14
	movaps	XMMWORD PTR [r11-168], xmm15
	movdqa	xmm11, xmm8
	movdqu	xmm0, XMMWORD PTR [r8+64]
	paddw	xmm8, xmm3
	paddw	xmm0, xmm2
	punpcklwd xmm10, xmm4
	psubw	xmm2, XMMWORD PTR [r8+64]
	movdqa	xmm14, xmm6
	pmaddwd	xmm6, XMMWORD PTR __xmm@08a914e808a914e808a914e808a914e8
	movdqa	xmm13, xmm10
	pmaddwd	xmm14, XMMWORD PTR __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
	xorps	xmm15, xmm15
	pmaddwd	xmm13, XMMWORD PTR __xmm@e09ee565e09ee565e09ee565e09ee565
	pmaddwd	xmm10, XMMWORD PTR __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
	punpcklwd xmm1, xmm0
	psrad	xmm1, 4
	movdqa	XMMWORD PTR row4$2$[rsp], xmm1
	xorps	xmm1, xmm1
	punpckhwd xmm1, xmm0
	xorps	xmm0, xmm0
	punpcklwd xmm0, xmm2
	psrad	xmm0, 4
	movdqa	XMMWORD PTR row5$2$[rsp], xmm0
	movdqa	xmm0, xmm8
	psrad	xmm1, 4
	punpckhwd xmm15, xmm2
	movdqa	XMMWORD PTR t3e_l$1$[rsp], xmm6
	movdqa	xmm6, xmm5
	punpcklwd xmm6, xmm3
	movdqa	XMMWORD PTR t3e_h$1$[rsp], xmm7
	movdqa	xmm9, xmm6
	pmaddwd	xmm9, XMMWORD PTR __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
	movdqa	xmm7, xmm5
	punpckhwd xmm7, xmm3
	paddw	xmm5, xmm4
	punpcklwd xmm0, xmm5
	movdqa	xmm3, xmm7
	pmaddwd	xmm3, XMMWORD PTR __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
	punpckhwd xmm11, xmm4
	punpckhwd xmm8, xmm5
	movdqa	xmm12, xmm11
	pmaddwd	xmm12, XMMWORD PTR __xmm@e09ee565e09ee565e09ee565e09ee565
	movdqa	xmm2, xmm8
	pmaddwd	xmm2, XMMWORD PTR __xmm@12d0046b12d0046b12d0046b12d0046b
	pmaddwd	xmm8, XMMWORD PTR __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
	pmaddwd	xmm11, XMMWORD PTR __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
	movdqa	XMMWORD PTR abiased_h$1$[rsp], xmm1
	movdqa	xmm1, xmm0
	pmaddwd	xmm0, XMMWORD PTR __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
	pmaddwd	xmm1, XMMWORD PTR __xmm@12d0046b12d0046b12d0046b12d0046b
	paddd	xmm12, xmm2
	movdqa	XMMWORD PTR t2e_l$1$[rsp], xmm14
	paddd	xmm3, xmm8
	psrad	xmm15, 4
	paddd	xmm9, xmm0
	paddd	xmm10, xmm0
	paddd	xmm13, xmm1
	pmaddwd	xmm6, XMMWORD PTR __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
	paddd	xmm11, xmm8
	movdqa	xmm4, XMMWORD PTR __xmm@00000200000002000000020000000200
	pmaddwd	xmm7, XMMWORD PTR __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
	movdqa	xmm8, XMMWORD PTR row4$2$[rsp]
	paddd	xmm8, XMMWORD PTR t3e_l$1$[rsp]
	paddd	xmm6, xmm1
	paddd	xmm8, xmm4
	movdqa	xmm1, XMMWORD PTR abiased_h$1$[rsp]
	paddd	xmm1, XMMWORD PTR t3e_h$1$[rsp]
	paddd	xmm7, xmm2
	paddd	xmm1, xmm4
	movdqa	xmm2, xmm8
	paddd	xmm2, xmm6
	movdqa	xmm0, xmm1
	psubd	xmm1, xmm7
	psrad	xmm2, 10
	paddd	xmm0, xmm7
	psrad	xmm1, 10
	psrad	xmm0, 10
	psubd	xmm8, xmm6
	movdqa	xmm6, XMMWORD PTR row5$2$[rsp]
	packssdw xmm2, xmm0
	movdqa	xmm5, xmm6
	psubd	xmm6, XMMWORD PTR t2e_l$1$[rsp]
	paddd	xmm5, xmm14
	paddd	xmm5, xmm4
	movdqa	XMMWORD PTR y5o_h$1$[rsp], xmm2
	movdqa	xmm2, XMMWORD PTR row4$2$[rsp]
	paddd	xmm6, xmm4
	psubd	xmm2, XMMWORD PTR t3e_l$1$[rsp]
	movdqa	xmm14, xmm5
	paddd	xmm2, XMMWORD PTR __xmm@00000200000002000000020000000200
	paddd	xmm14, xmm10
	psubd	xmm5, xmm10
	psrad	xmm8, 10
	packssdw xmm8, xmm1
	movdqa	xmm1, xmm15
	paddd	xmm1, XMMWORD PTR t2e_h$1$[rsp]
	psubd	xmm15, XMMWORD PTR t2e_h$1$[rsp]
	paddd	xmm1, xmm4
	movdqa	xmm0, xmm1
	psrad	xmm14, 10
	paddd	xmm0, xmm11
	psrad	xmm5, 10
	psrad	xmm0, 10
	paddd	xmm15, xmm4
	packssdw xmm14, xmm0
	psubd	xmm1, xmm11
	psrad	xmm1, 10
	movdqa	xmm4, xmm6
	packssdw xmm5, xmm1
	movdqa	xmm0, xmm15
	movdqa	xmm1, XMMWORD PTR abiased_h$1$[rsp]
	paddd	xmm0, xmm3
	psubd	xmm1, XMMWORD PTR t3e_h$1$[rsp]
	psubd	xmm15, xmm3
	paddd	xmm1, XMMWORD PTR __xmm@00000200000002000000020000000200
	movdqa	xmm3, xmm2
	psrad	xmm0, 10
	paddd	xmm4, xmm9
	paddd	xmm3, xmm13
	psrad	xmm4, 10
	packssdw xmm4, xmm0
	psubd	xmm2, xmm13
	movdqa	xmm0, xmm1
	psrad	xmm3, 10
	paddd	xmm0, xmm12
	psrad	xmm2, 10
	psrad	xmm0, 10
	psubd	xmm6, xmm9
	psubd	xmm1, xmm12
	packssdw xmm3, xmm0

; 2638 : 
; 2639 :    {
; 2640 :       // 16bit 8x8 transpose pass 1
; 2641 :       dct_interleave16(row0, row4);

	movdqa	xmm0, XMMWORD PTR y5o_h$1$[rsp]
	psrad	xmm1, 10
	movdqa	xmm7, xmm0
	psrad	xmm6, 10
	psrad	xmm15, 10
	packssdw xmm2, xmm1
	punpcklwd xmm7, xmm2
	packssdw xmm6, xmm15
	punpckhwd xmm0, xmm2

; 2642 :       dct_interleave16(row1, row5);
; 2643 :       dct_interleave16(row2, row6);
; 2644 :       dct_interleave16(row3, row7);

	movdqa	xmm1, xmm3
	movdqa	XMMWORD PTR y5o_h$1$[rsp], xmm0
	movdqa	xmm2, xmm14
	punpcklwd xmm1, xmm8
	movdqa	xmm0, xmm4
	punpcklwd xmm0, xmm5
	punpcklwd xmm2, xmm6
	punpckhwd xmm3, xmm8

; 2645 : 
; 2646 :       // transpose pass 2
; 2647 :       dct_interleave16(row0, row2);
; 2648 :       dct_interleave16(row1, row3);
; 2649 :       dct_interleave16(row4, row6);

	movdqa	xmm8, XMMWORD PTR y5o_h$1$[rsp]
	punpckhwd xmm14, xmm6
	movdqa	xmm6, xmm7
	punpcklwd xmm6, xmm0
	punpckhwd xmm7, xmm0
	movdqa	xmm0, xmm2
	punpcklwd xmm0, xmm1

; 2650 :       dct_interleave16(row5, row7);
; 2651 : 
; 2652 :       // transpose pass 3
; 2653 :       dct_interleave16(row0, row1);
; 2654 :       dct_interleave16(row2, row3);

	movdqa	xmm15, xmm7
	punpckhwd xmm2, xmm1
	movdqa	xmm1, xmm14
	punpcklwd xmm1, xmm3
	punpckhwd xmm14, xmm3
	movdqa	xmm3, xmm6
	punpcklwd xmm3, xmm0
	punpckhwd xmm6, xmm0
	punpcklwd xmm15, xmm2
	punpckhwd xmm7, xmm2

; 2655 :       dct_interleave16(row4, row5);
; 2656 :       dct_interleave16(row6, row7);
; 2657 :    }
; 2658 : 
; 2659 :    // row pass
; 2660 :    dct_pass(bias_1, 17);

	movdqa	xmm13, xmm15
	punpckhwd xmm4, xmm5
	movdqa	xmm5, xmm8
	punpckhwd xmm8, xmm4
	punpcklwd xmm5, xmm4
	movdqa	xmm0, xmm8
	punpcklwd xmm0, xmm14
	movdqa	xmm2, xmm5
	punpcklwd xmm2, xmm1
	punpcklwd xmm13, xmm0
	punpckhwd xmm15, xmm0
	movdqa	xmm9, xmm13
	pmaddwd	xmm9, XMMWORD PTR __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
	movdqa	xmm0, xmm2
	pmaddwd	xmm13, XMMWORD PTR __xmm@08a914e808a914e808a914e808a914e8
	paddw	xmm0, xmm3
	punpckhwd xmm5, xmm1
	psubw	xmm3, xmm2
	punpckhwd xmm8, xmm14
	xorps	xmm1, xmm1
	punpcklwd xmm1, xmm0
	xorps	xmm2, xmm2
	punpckhwd xmm2, xmm3
	movdqa	xmm4, xmm8
	psrad	xmm1, 4
	xorps	xmm14, xmm14
	punpckhwd xmm14, xmm0
	movdqa	xmm11, xmm5
	xorps	xmm0, xmm0
	psrad	xmm2, 4
	punpcklwd xmm0, xmm3
	movdqa	xmm12, xmm5
	psrad	xmm0, 4
	movdqa	xmm3, xmm8
	movdqa	XMMWORD PTR abiased_l$1$[rsp], xmm0
	paddw	xmm8, xmm6
	movdqa	xmm0, xmm8
	movdqa	XMMWORD PTR p2$1$[rsp], xmm1
	paddw	xmm5, xmm7
	movdqa	XMMWORD PTR abiased_h$1$[rsp], xmm2
	punpcklwd xmm0, xmm5
	movdqa	xmm10, xmm15
	pmaddwd	xmm10, XMMWORD PTR __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
	movdqa	xmm1, xmm0
	pmaddwd	xmm1, XMMWORD PTR __xmm@12d0046b12d0046b12d0046b12d0046b
	pmaddwd	xmm15, XMMWORD PTR __xmm@08a914e808a914e808a914e808a914e8
	pmaddwd	xmm0, XMMWORD PTR __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
	punpckhwd xmm8, xmm5
	movdqa	xmm2, xmm8
	psrad	xmm14, 4
	pmaddwd	xmm2, XMMWORD PTR __xmm@12d0046b12d0046b12d0046b12d0046b
	punpcklwd xmm3, xmm7
	punpckhwd xmm4, xmm7
	punpcklwd xmm11, xmm6
	punpckhwd xmm12, xmm6
	pmaddwd	xmm8, XMMWORD PTR __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
	movdqa	xmm5, xmm4
	pmaddwd	xmm4, XMMWORD PTR __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
	movdqa	xmm7, xmm12
	pmaddwd	xmm12, XMMWORD PTR __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
	movdqa	xmm6, xmm3
	pmaddwd	xmm3, XMMWORD PTR __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
	pmaddwd	xmm5, XMMWORD PTR __xmm@e09ee565e09ee565e09ee565e09ee565
	pmaddwd	xmm6, XMMWORD PTR __xmm@e09ee565e09ee565e09ee565e09ee565
	pmaddwd	xmm7, XMMWORD PTR __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
	paddd	xmm12, xmm2
	movdqa	XMMWORD PTR y5o_h$1$[rsp], xmm8
	paddd	xmm4, XMMWORD PTR y5o_h$1$[rsp]
	paddd	xmm3, xmm0
	paddd	xmm5, xmm2
	movdqa	XMMWORD PTR x7_h$1$[rsp], xmm12
	movdqa	xmm2, XMMWORD PTR abiased_l$1$[rsp]
	paddd	xmm6, xmm1
	paddd	xmm7, XMMWORD PTR y5o_h$1$[rsp]
	movdqa	xmm8, xmm11
	pmaddwd	xmm11, XMMWORD PTR __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
	movdqa	xmm12, xmm2
	pmaddwd	xmm8, XMMWORD PTR __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
	psubd	xmm2, xmm9
	paddd	xmm12, xmm9
	movdqa	XMMWORD PTR x6_h$1$[rsp], xmm4
	movdqa	xmm9, XMMWORD PTR abiased_h$1$[rsp]
	movdqa	xmm4, xmm14
	psubd	xmm9, xmm10
	movdqa	XMMWORD PTR x6_l$1$[rsp], xmm3
	movdqa	xmm3, XMMWORD PTR abiased_h$1$[rsp]
	paddd	xmm11, xmm1
	movdqa	xmm1, XMMWORD PTR __xmm@01010000010100000101000001010000
	paddd	xmm8, xmm0
	movdqa	xmm0, XMMWORD PTR p2$1$[rsp]
	paddd	xmm9, xmm1
	paddd	xmm2, xmm1
	movdqa	XMMWORD PTR abiased_h$1$[rsp], xmm9
	paddd	xmm12, xmm1
	movdqa	XMMWORD PTR x7_l$1$[rsp], xmm11
	movdqa	xmm11, xmm0
	movdqa	XMMWORD PTR abiased_l$1$[rsp], xmm2
	psubd	xmm0, xmm13
	paddd	xmm2, xmm8
	paddd	xmm0, xmm1
	psrad	xmm2, 17
	movdqa	XMMWORD PTR p2$1$[rsp], xmm0
	paddd	xmm11, xmm13
	paddd	xmm11, xmm1
	paddd	xmm4, xmm15
	paddd	xmm4, xmm1
	movdqa	xmm9, xmm11
	paddd	xmm9, XMMWORD PTR x7_l$1$[rsp]
	movdqa	xmm0, xmm4
	paddd	xmm0, XMMWORD PTR x7_h$1$[rsp]
	paddd	xmm3, xmm10
	psrad	xmm0, 17
	paddd	xmm3, xmm1
	psrad	xmm9, 17
	psubd	xmm14, xmm15
	packssdw xmm9, xmm0
	paddd	xmm14, xmm1
	movdqa	xmm0, xmm3
	movdqa	xmm1, xmm12
	paddd	xmm0, XMMWORD PTR x6_h$1$[rsp]
	paddd	xmm1, XMMWORD PTR x6_l$1$[rsp]
	psrad	xmm0, 17
	psrad	xmm1, 17
	packssdw xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR abiased_h$1$[rsp]
	paddd	xmm0, xmm7

; 2661 : 
; 2662 :    {
; 2663 :       // pack
; 2664 :       __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7

	packuswb xmm9, xmm1
	movdqa	xmm1, XMMWORD PTR p2$1$[rsp]
	psrad	xmm0, 17
	paddd	xmm1, xmm6
	packssdw xmm2, xmm0
	movdqa	xmm0, xmm14
	paddd	xmm0, xmm5
	psrad	xmm1, 17
	psrad	xmm0, 17
	packssdw xmm1, xmm0

; 2665 :       __m128i p1 = _mm_packus_epi16(row2, row3);
; 2666 :       __m128i p2 = _mm_packus_epi16(row4, row5);
; 2667 :       __m128i p3 = _mm_packus_epi16(row6, row7);
; 2668 : 
; 2669 :       // 8bit 8x8 transpose pass 1
; 2670 :       dct_interleave8(p0, p2); // a0e0a1e1...
; 2671 :       dct_interleave8(p1, p3); // c0g0c1g1...
; 2672 : 
; 2673 :       // transpose pass 2
; 2674 :       dct_interleave8(p0, p1); // a0c0e0g0...
; 2675 :       dct_interleave8(p2, p3); // b0d0f0h0...
; 2676 : 
; 2677 :       // transpose pass 3
; 2678 :       dct_interleave8(p0, p2); // a0b0c0d0...
; 2679 :       dct_interleave8(p1, p3); // a4b4c4d4...
; 2680 : 
; 2681 :       // store
; 2682 :       _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
; 2683 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
; 2684 :       _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
; 2685 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
; 2686 :       _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
; 2687 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
; 2688 :       _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
; 2689 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
; 2690 :    }
; 2691 : 
; 2692 : #undef dct_const
; 2693 : #undef dct_rot
; 2694 : #undef dct_widen
; 2695 : #undef dct_wadd
; 2696 : #undef dct_wsub
; 2697 : #undef dct_bfly32o
; 2698 : #undef dct_interleave8
; 2699 : #undef dct_interleave16
; 2700 : #undef dct_pass
; 2701 : }

	psubd	xmm4, XMMWORD PTR x7_h$1$[rsp]
	lea	r11, QWORD PTR [r11]
	psubd	xmm12, XMMWORD PTR x6_l$1$[rsp]
	psubd	xmm14, xmm5
	psubd	xmm3, XMMWORD PTR x6_h$1$[rsp]
	psubd	xmm11, XMMWORD PTR x7_l$1$[rsp]
	movdqa	xmm5, XMMWORD PTR abiased_h$1$[rsp]
	movdqa	xmm0, XMMWORD PTR abiased_l$1$[rsp]
	psubd	xmm5, xmm7
	movaps	xmm7, XMMWORD PTR [r11-40]
	psubd	xmm0, xmm8
	movaps	xmm8, XMMWORD PTR [r11-56]
	movaps	xmm10, XMMWORD PTR [r11-88]
	movaps	xmm13, XMMWORD PTR [r11-136]
	movaps	xmm15, XMMWORD PTR [r11-168]
	packuswb xmm2, xmm1
	movdqa	xmm1, XMMWORD PTR p2$1$[rsp]
	psrad	xmm0, 17
	psubd	xmm1, xmm6
	movaps	xmm6, XMMWORD PTR [r11-24]
	movsxd	rax, edx
	psrad	xmm4, 17
	psrad	xmm1, 17
	psrad	xmm3, 17
	psrad	xmm12, 17
	packssdw xmm12, xmm3
	psrad	xmm14, 17
	packssdw xmm1, xmm14
	movaps	xmm14, XMMWORD PTR [r11-152]
	psrad	xmm11, 17
	packssdw xmm11, xmm4
	movdqa	xmm4, xmm9
	packuswb xmm12, xmm11
	movaps	xmm11, XMMWORD PTR [r11-104]
	psrad	xmm5, 17
	packssdw xmm0, xmm5
	packuswb xmm1, xmm0
	movdqa	xmm0, xmm2
	punpcklbw xmm0, xmm12
	punpcklbw xmm4, xmm1
	punpckhbw xmm9, xmm1
	movdqa	xmm3, xmm4
	punpcklbw xmm3, xmm0
	punpckhbw xmm4, xmm0
	movdqa	xmm1, xmm3
	punpckhbw xmm2, xmm12
	movdqa	xmm0, xmm9
	movaps	xmm12, XMMWORD PTR [r11-120]
	punpcklbw xmm0, xmm2
	punpcklbw xmm1, xmm0
	movq	QWORD PTR [rcx], xmm1
	add	rcx, rax
	punpckhbw xmm3, xmm0
	punpckhbw xmm9, xmm2
	movdqa	xmm2, xmm4
	punpcklbw xmm2, xmm9
	punpckhbw xmm4, xmm9
	movaps	xmm9, XMMWORD PTR [r11-72]
	pshufd	xmm0, xmm1, 78				; 0000004eH
	movq	QWORD PTR [rcx], xmm0
	add	rcx, rax
	pshufd	xmm0, xmm3, 78				; 0000004eH
	movq	QWORD PTR [rcx], xmm3
	add	rcx, rax
	movq	QWORD PTR [rcx], xmm0
	add	rcx, rax
	pshufd	xmm0, xmm2, 78				; 0000004eH
	movq	QWORD PTR [rcx], xmm2
	add	rcx, rax
	movq	QWORD PTR [rcx], xmm0
	add	rcx, rax
	pshufd	xmm0, xmm4, 78				; 0000004eH
	movq	QWORD PTR [rcx], xmm4
	movq	QWORD PTR [rax+rcx], xmm0
	mov	rsp, r11
	ret	0
?stbi__idct_simd@@YAXPEAEHQEAF@Z ENDP			; stbi__idct_simd
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z
_TEXT	SEGMENT
j$ = 48
?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z PROC		; stbi__get_marker, COMDAT

; 2918 : {

	push	rdi
	sub	rsp, 32					; 00000020H

; 2919 :    stbi_uc x;
; 2920 :    if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }

	movzx	eax, BYTE PTR [rcx+18472]
	mov	rdi, rcx
	cmp	al, 255					; 000000ffH
	je	SHORT $LN4@stbi__get_
	mov	BYTE PTR [rcx+18472], 255		; 000000ffH

; 2926 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@stbi__get_:
	mov	QWORD PTR [rsp+48], rbx

; 2921 :    x = stbi__get8(j->s);

	mov	rbx, QWORD PTR [rcx]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN29@stbi__get_

; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN18@stbi__get_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN29@stbi__get_:

; 2922 :    if (x != 0xff) return STBI__MARKER_none;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 255					; 000000ffH
	jne	SHORT $LN18@stbi__get_
$LL2@stbi__get_:

; 2924 :       x = stbi__get8(j->s); // consume repeated 0xff fill bytes

	mov	rbx, QWORD PTR [rdi]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN30@stbi__get_

; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN13@stbi__get_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN30@stbi__get_:

; 2923 :    while (x == 0xff)

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 255					; 000000ffH
	je	SHORT $LL2@stbi__get_

; 2925 :    return x;

	mov	rbx, QWORD PTR [rsp+48]
	movzx	eax, cl

; 2926 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN13@stbi__get_:
	mov	rbx, QWORD PTR [rsp+48]

; 1620 :    return 0;

	xor	cl, cl

; 2925 :    return x;

	movzx	eax, cl

; 2926 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN18@stbi__get_:
	mov	rbx, QWORD PTR [rsp+48]

; 2922 :    if (x != 0xff) return STBI__MARKER_none;

	mov	al, 255					; 000000ffH

; 2926 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ENDP		; stbi__get_marker
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z
_TEXT	SEGMENT
j$ = 8
?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z PROC		; stbi__jpeg_reset, COMDAT

; 2936 :    j->code_bits = 0;

	xor	r8d, r8d

; 2937 :    j->code_buffer = 0;
; 2938 :    j->nomore = 0;
; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
; 2940 :    j->marker = STBI__MARKER_none;

	mov	BYTE PTR [rcx+18472], 255		; 000000ffH
	mov	DWORD PTR [rcx+18392], r8d

; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;

	mov	edx, 2147483647				; 7fffffffH
	mov	DWORD PTR [rcx+18296], r8d
	mov	DWORD PTR [rcx+18200], r8d
	mov	DWORD PTR [rcx+18104], r8d
	mov	eax, DWORD PTR [rcx+18536]
	test	eax, eax
	mov	QWORD PTR [rcx+18464], r8
	cmovne	edx, eax
	mov	DWORD PTR [rcx+18476], r8d
	mov	DWORD PTR [rcx+18540], edx

; 2942 :    j->eob_run = 0;

	mov	DWORD PTR [rcx+18500], r8d

; 2943 :    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2944 :    // since we don't even allow 1<<30 pixels
; 2945 : }

	ret	0
?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ENDP		; stbi__jpeg_reset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z
_TEXT	SEGMENT
k$1$ = 64
j$1$ = 68
tv1852 = 72
tv1851 = 72
data$1 = 80
data$2 = 80
__$ArrayPad$ = 208
z$ = 272
?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z PROC ; stbi__parse_entropy_coded_data, COMDAT

; 2948 : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 224				; 000000e0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;

	mov	DWORD PTR [rcx+18392], 0

; 2948 : {

	mov	rbx, rcx

; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;

	mov	DWORD PTR [rcx+18296], 0
	mov	DWORD PTR [rcx+18200], 0
	mov	DWORD PTR [rcx+18104], 0

; 2940 :    j->marker = STBI__MARKER_none;
; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;

	mov	eax, DWORD PTR [rcx+18536]
	test	eax, eax
	mov	QWORD PTR [rcx+18464], 0
	mov	DWORD PTR [rcx+18476], 0
	mov	BYTE PTR [rcx+18472], 255		; 000000ffH
	mov	ecx, 2147483647				; 7fffffffH
	cmovne	ecx, eax

; 2942 :    j->eob_run = 0;

	mov	DWORD PTR [rbx+18500], 0

; 2949 :    stbi__jpeg_reset(z);
; 2950 :    if (!z->progressive) {

	cmp	DWORD PTR [rbx+18480], 0
	mov	eax, DWORD PTR [rbx+18516]

; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;

	mov	DWORD PTR [rbx+18540], ecx

; 2949 :    stbi__jpeg_reset(z);
; 2950 :    if (!z->progressive) {

	jne	$LN44@stbi__pars

; 2951 :       if (z->scan_n == 1) {

	cmp	eax, 1
	jne	$LN46@stbi__pars

; 2952 :          int i,j;
; 2953 :          STBI_SIMD_ALIGN(short, data[64]);
; 2954 :          int n = z->order[0];

	movsxd	r12, DWORD PTR [rbx+18520]

; 2955 :          // non-interleaved data, we just need to process one block at a time,
; 2956 :          // in trivial scanline order
; 2957 :          // number of blocks to do just depends on how many actual "pixels" this
; 2958 :          // component has, independent of interleaved MCU blocking and such
; 2959 :          int w = (z->img_comp[n].x+7) >> 3;
; 2960 :          int h = (z->img_comp[n].y+7) >> 3;
; 2961 :          for (j=0; j < h; ++j) {

	xor	r14d, r14d
	lea	rsi, QWORD PTR [r12+r12*2]
	shl	rsi, 5
	add	rsi, rbx
	mov	r15d, DWORD PTR [rsi+18108]
	mov	r13d, DWORD PTR [rsi+18112]
	add	r15d, 7
	add	r13d, 7
	sar	r15d, 3
	sar	r13d, 3
	test	r13d, r13d
	jle	$LN271@stbi__pars
$LL4@stbi__pars:

; 2962 :             for (i=0; i < w; ++i) {

	xor	edi, edi
	test	r15d, r15d
	jle	$LN2@stbi__pars
	xor	ebp, ebp
	npad	3
$LL7@stbi__pars:

; 2963 :                int ha = z->img_comp[n].ha;
; 2964 :                if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;

	movsxd	rcx, DWORD PTR [rsi+18100]
	movsxd	rax, DWORD PTR [rsi+18096]
	mov	rdx, rcx
	movsxd	r10, DWORD PTR [rsi+18092]
	shl	rdx, 10
	imul	r9, rcx, 1680				; 00000690H
	imul	r8, rax, 1680				; 00000690H
	shl	r10, 7
	add	rdx, 13960				; 00003688H
	add	rdx, rbx
	add	r10, 13448				; 00003488H
	add	r10, rbx
	add	r9, 6728				; 00001a48H
	mov	QWORD PTR [rsp+48], r10
	add	r9, rbx
	mov	DWORD PTR [rsp+40], r12d
	mov	rcx, rbx
	add	r8, 8
	mov	QWORD PTR [rsp+32], rdx
	add	r8, rbx
	lea	rdx, QWORD PTR data$2[rsp]
	call	?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z ; stbi__jpeg_decode_block
	test	eax, eax
	je	$LN224@stbi__pars

; 2965 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);

	mov	edx, DWORD PTR [rsi+18116]
	lea	r8, QWORD PTR data$2[rsp]
	mov	eax, edx
	imul	eax, r14d
	shl	eax, 3
	movsxd	rcx, eax
	add	rcx, QWORD PTR [rsi+18128]
	movsxd	rax, ebp
	add	rcx, rax
	call	QWORD PTR [rbx+18544]

; 2966 :                // every data block is an MCU, so countdown the restart interval
; 2967 :                if (--z->todo <= 0) {

	dec	DWORD PTR [rbx+18540]
	cmp	DWORD PTR [rbx+18540], 0
	jg	$LN5@stbi__pars

; 2968 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

	cmp	DWORD PTR [rbx+18468], 24
	jge	SHORT $LN50@stbi__pars
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN50@stbi__pars:

; 2969 :                   // if it's NOT a restart, then just bail, so we get corrupt data
; 2970 :                   // rather than no data
; 2971 :                   if (!STBI__RESTART(z->marker)) return 1;

	movzx	eax, BYTE PTR [rbx+18472]
	add	al, 48					; 00000030H
	cmp	al, 7
	ja	SHORT $LN271@stbi__pars

; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;

	mov	DWORD PTR [rbx+18392], 0

; 2940 :    j->marker = STBI__MARKER_none;
; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;

	mov	ecx, 2147483647				; 7fffffffH
	mov	DWORD PTR [rbx+18296], 0
	mov	DWORD PTR [rbx+18200], 0
	mov	DWORD PTR [rbx+18104], 0
	mov	eax, DWORD PTR [rbx+18536]
	test	eax, eax
	mov	QWORD PTR [rbx+18464], 0
	cmovne	ecx, eax
	mov	DWORD PTR [rbx+18476], 0
	mov	DWORD PTR [rbx+18540], ecx
	mov	BYTE PTR [rbx+18472], 255		; 000000ffH

; 2942 :    j->eob_run = 0;

	mov	DWORD PTR [rbx+18500], 0
$LN5@stbi__pars:

; 2962 :             for (i=0; i < w; ++i) {

	inc	edi
	add	ebp, 8
	cmp	edi, r15d
	jl	$LL7@stbi__pars
$LN2@stbi__pars:

; 2955 :          // non-interleaved data, we just need to process one block at a time,
; 2956 :          // in trivial scanline order
; 2957 :          // number of blocks to do just depends on how many actual "pixels" this
; 2958 :          // component has, independent of interleaved MCU blocking and such
; 2959 :          int w = (z->img_comp[n].x+7) >> 3;
; 2960 :          int h = (z->img_comp[n].y+7) >> 3;
; 2961 :          for (j=0; j < h; ++j) {

	inc	r14d
	cmp	r14d, r13d
	jl	$LL4@stbi__pars
$LN271@stbi__pars:

; 3062 :                   stbi__jpeg_reset(z);
; 3063 :                }
; 3064 :             }
; 3065 :          }
; 3066 :          return 1;

	mov	eax, 1
$LN59@stbi__pars:

; 3067 :       }
; 3068 :    }
; 3069 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN46@stbi__pars:

; 2972 :                   stbi__jpeg_reset(z);
; 2973 :                }
; 2974 :             }
; 2975 :          }
; 2976 :          return 1;
; 2977 :       } else { // interleaved
; 2978 :          int i,j,k,x,y;
; 2979 :          STBI_SIMD_ALIGN(short, data[64]);
; 2980 :          for (j=0; j < z->img_mcu_y; ++j) {

	xor	ebp, ebp
	mov	DWORD PTR j$1$[rsp], ebp
	cmp	DWORD PTR [rbx+18068], ebp
	jle	SHORT $LN271@stbi__pars
	npad	12
$LL10@stbi__pars:

; 2981 :             for (i=0; i < z->img_mcu_x; ++i) {

	xor	r13d, r13d
	cmp	DWORD PTR [rbx+18064], r13d
	jle	$LN8@stbi__pars
$LL13@stbi__pars:

; 2982 :                // scan an interleaved mcu... process scan_n components in order
; 2983 :                for (k=0; k < z->scan_n; ++k) {

	xor	edx, edx
	mov	DWORD PTR k$1$[rsp], edx
	cmp	DWORD PTR [rbx+18516], edx
	jle	$LN15@stbi__pars
	lea	rax, QWORD PTR [rbx+18520]
	mov	QWORD PTR tv1852[rsp], rax
	npad	2
$LL16@stbi__pars:

; 2984 :                   int n = z->order[k];

	movsxd	r12, DWORD PTR [rax]

; 2985 :                   // scan out an mcu's worth of this component; that's just determined
; 2986 :                   // by the basic H and V specified for the component
; 2987 :                   for (y=0; y < z->img_comp[n].v; ++y) {

	xor	r15d, r15d
	lea	rsi, QWORD PTR [r12+r12*2]
	shl	rsi, 5
	add	rsi, rbx
	cmp	DWORD PTR [rsi+18088], r15d
	jle	$LN14@stbi__pars
	npad	2
$LL19@stbi__pars:

; 2988 :                      for (x=0; x < z->img_comp[n].h; ++x) {

	mov	edi, DWORD PTR [rsi+18084]
	xor	r14d, r14d
	test	edi, edi
	jle	$LN17@stbi__pars
$LL22@stbi__pars:

; 2989 :                         int x2 = (i*z->img_comp[n].h + x)*8;
; 2990 :                         int y2 = (j*z->img_comp[n].v + y)*8;
; 2991 :                         int ha = z->img_comp[n].ha;
; 2992 :                         if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;

	movsxd	rcx, DWORD PTR [rsi+18100]
	movsxd	rax, DWORD PTR [rsi+18096]
	mov	rdx, rcx
	movsxd	r10, DWORD PTR [rsi+18092]
	imul	ebp, DWORD PTR [rsi+18088]
	shl	rdx, 10
	imul	r9, rcx, 1680				; 00000690H
	imul	r8, rax, 1680				; 00000690H
	shl	r10, 7
	add	rdx, 13960				; 00003688H
	add	rdx, rbx
	add	r10, 13448				; 00003488H
	add	r10, rbx
	add	r9, 6728				; 00001a48H
	mov	QWORD PTR [rsp+48], r10
	add	r9, rbx
	mov	DWORD PTR [rsp+40], r12d
	mov	rcx, rbx
	add	r8, 8
	mov	QWORD PTR [rsp+32], rdx
	add	r8, rbx
	lea	rdx, QWORD PTR data$1[rsp]
	add	ebp, r15d
	call	?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z ; stbi__jpeg_decode_block
	test	eax, eax
	je	$LN224@stbi__pars

; 2993 :                         z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);

	mov	edx, DWORD PTR [rsi+18116]
	lea	r8, QWORD PTR data$1[rsp]
	mov	eax, edx
	imul	edi, r13d
	imul	eax, ebp
	add	edi, r14d
	shl	eax, 3
	cdqe
	shl	edi, 3
	movsxd	rcx, edi
	add	rcx, rax
	add	rcx, QWORD PTR [rsi+18128]
	call	QWORD PTR [rbx+18544]
	mov	edi, DWORD PTR [rsi+18084]
	inc	r14d
	mov	ebp, DWORD PTR j$1$[rsp]
	cmp	r14d, edi
	jl	$LL22@stbi__pars
$LN17@stbi__pars:

; 2985 :                   // scan out an mcu's worth of this component; that's just determined
; 2986 :                   // by the basic H and V specified for the component
; 2987 :                   for (y=0; y < z->img_comp[n].v; ++y) {

	inc	r15d
	cmp	r15d, DWORD PTR [rsi+18088]
	jl	$LL19@stbi__pars
	mov	edx, DWORD PTR k$1$[rsp]
$LN14@stbi__pars:

; 2982 :                // scan an interleaved mcu... process scan_n components in order
; 2983 :                for (k=0; k < z->scan_n; ++k) {

	mov	rax, QWORD PTR tv1852[rsp]
	inc	edx
	add	rax, 4
	mov	DWORD PTR k$1$[rsp], edx
	mov	QWORD PTR tv1852[rsp], rax
	cmp	edx, DWORD PTR [rbx+18516]
	jl	$LL16@stbi__pars
$LN15@stbi__pars:

; 2994 :                      }
; 2995 :                   }
; 2996 :                }
; 2997 :                // after all interleaved components, that's an interleaved MCU,
; 2998 :                // so now count down the restart interval
; 2999 :                if (--z->todo <= 0) {

	dec	DWORD PTR [rbx+18540]
	cmp	DWORD PTR [rbx+18540], 0
	jg	$LN11@stbi__pars

; 3000 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

	cmp	DWORD PTR [rbx+18468], 24
	jge	SHORT $LN55@stbi__pars
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN55@stbi__pars:

; 3001 :                   if (!STBI__RESTART(z->marker)) return 1;

	movzx	eax, BYTE PTR [rbx+18472]
	add	al, 48					; 00000030H
	cmp	al, 7
	ja	$LN271@stbi__pars

; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;

	mov	DWORD PTR [rbx+18392], 0

; 2940 :    j->marker = STBI__MARKER_none;
; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;

	mov	ecx, 2147483647				; 7fffffffH
	mov	DWORD PTR [rbx+18296], 0
	mov	DWORD PTR [rbx+18200], 0
	mov	DWORD PTR [rbx+18104], 0
	mov	eax, DWORD PTR [rbx+18536]
	test	eax, eax
	mov	QWORD PTR [rbx+18464], 0
	cmovne	ecx, eax
	mov	DWORD PTR [rbx+18476], 0
	mov	DWORD PTR [rbx+18540], ecx
	mov	BYTE PTR [rbx+18472], 255		; 000000ffH

; 2942 :    j->eob_run = 0;

	mov	DWORD PTR [rbx+18500], 0
$LN11@stbi__pars:

; 2981 :             for (i=0; i < z->img_mcu_x; ++i) {

	inc	r13d
	cmp	r13d, DWORD PTR [rbx+18064]
	jl	$LL13@stbi__pars
$LN8@stbi__pars:

; 2972 :                   stbi__jpeg_reset(z);
; 2973 :                }
; 2974 :             }
; 2975 :          }
; 2976 :          return 1;
; 2977 :       } else { // interleaved
; 2978 :          int i,j,k,x,y;
; 2979 :          STBI_SIMD_ALIGN(short, data[64]);
; 2980 :          for (j=0; j < z->img_mcu_y; ++j) {

	inc	ebp
	mov	DWORD PTR j$1$[rsp], ebp
	cmp	ebp, DWORD PTR [rbx+18068]
	jl	$LL10@stbi__pars

; 3061 :                   if (!STBI__RESTART(z->marker)) return 1;

	jmp	$LN271@stbi__pars
$LN44@stbi__pars:

; 3002 :                   stbi__jpeg_reset(z);
; 3003 :                }
; 3004 :             }
; 3005 :          }
; 3006 :          return 1;
; 3007 :       }
; 3008 :    } else {
; 3009 :       if (z->scan_n == 1) {

	cmp	eax, 1
	jne	$LN58@stbi__pars

; 3010 :          int i,j;
; 3011 :          int n = z->order[0];

	movsxd	r15, DWORD PTR [rbx+18520]

; 3012 :          // non-interleaved data, we just need to process one block at a time,
; 3013 :          // in trivial scanline order
; 3014 :          // number of blocks to do just depends on how many actual "pixels" this
; 3015 :          // component has, independent of interleaved MCU blocking and such
; 3016 :          int w = (z->img_comp[n].x+7) >> 3;
; 3017 :          int h = (z->img_comp[n].y+7) >> 3;
; 3018 :          for (j=0; j < h; ++j) {

	xor	ebp, ebp
	lea	rsi, QWORD PTR [r15+r15*2]
	shl	rsi, 5
	add	rsi, rbx
	mov	r14d, DWORD PTR [rsi+18108]
	mov	r12d, DWORD PTR [rsi+18112]
	add	r14d, 7
	add	r12d, 7
	sar	r14d, 3
	sar	r12d, 3
	test	r12d, r12d
	jle	$LN271@stbi__pars
$LL25@stbi__pars:

; 3019 :             for (i=0; i < w; ++i) {

	xor	edi, edi
	test	r14d, r14d
	jle	$LN23@stbi__pars
	npad	3
$LL28@stbi__pars:

; 3020 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);

	mov	eax, ebp
	imul	eax, DWORD PTR [rsi+18168]
	add	eax, edi
	shl	eax, 6

; 3021 :                if (z->spec_start == 0) {

	cmp	DWORD PTR [rbx+18484], 0
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rsi+18160]
	lea	rdx, QWORD PTR [rax+rcx*2]
	jne	SHORT $LN60@stbi__pars

; 3022 :                   if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))

	movsxd	rax, DWORD PTR [rsi+18096]
	mov	r9d, r15d
	imul	r8, rax, 1680				; 00000690H
	mov	rcx, rbx
	add	r8, 8
	add	r8, rbx
	call	?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z ; stbi__jpeg_decode_block_prog_dc

; 3023 :                      return 0;
; 3024 :                } else {

	jmp	SHORT $LN310@stbi__pars
$LN60@stbi__pars:

; 3025 :                   int ha = z->img_comp[n].ha;
; 3026 :                   if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))

	movsxd	rcx, DWORD PTR [rsi+18100]
	imul	r8, rcx, 1680				; 00000690H
	mov	r9, rcx
	mov	rcx, rbx
	shl	r9, 10
	add	r8, 6728				; 00001a48H
	add	r9, 13960				; 00003688H
	add	r8, rbx
	add	r9, rbx
	call	?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z ; stbi__jpeg_decode_block_prog_ac
$LN310@stbi__pars:

; 3027 :                      return 0;
; 3028 :                }
; 3029 :                // every data block is an MCU, so countdown the restart interval
; 3030 :                if (--z->todo <= 0) {

	test	eax, eax
	je	$LN224@stbi__pars
	dec	DWORD PTR [rbx+18540]
	cmp	DWORD PTR [rbx+18540], 0
	jg	$LN26@stbi__pars

; 3031 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

	cmp	DWORD PTR [rbx+18468], 24
	jge	SHORT $LN65@stbi__pars
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN65@stbi__pars:

; 3032 :                   if (!STBI__RESTART(z->marker)) return 1;

	movzx	eax, BYTE PTR [rbx+18472]
	add	al, 48					; 00000030H
	cmp	al, 7
	ja	$LN271@stbi__pars

; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;

	mov	DWORD PTR [rbx+18392], 0

; 2940 :    j->marker = STBI__MARKER_none;
; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;

	mov	ecx, 2147483647				; 7fffffffH
	mov	DWORD PTR [rbx+18296], 0
	mov	DWORD PTR [rbx+18200], 0
	mov	DWORD PTR [rbx+18104], 0
	mov	eax, DWORD PTR [rbx+18536]
	test	eax, eax
	mov	QWORD PTR [rbx+18464], 0
	cmovne	ecx, eax
	mov	DWORD PTR [rbx+18476], 0
	mov	DWORD PTR [rbx+18540], ecx
	mov	BYTE PTR [rbx+18472], 255		; 000000ffH

; 2942 :    j->eob_run = 0;

	mov	DWORD PTR [rbx+18500], 0
$LN26@stbi__pars:

; 3019 :             for (i=0; i < w; ++i) {

	inc	edi
	cmp	edi, r14d
	jl	$LL28@stbi__pars
$LN23@stbi__pars:

; 3012 :          // non-interleaved data, we just need to process one block at a time,
; 3013 :          // in trivial scanline order
; 3014 :          // number of blocks to do just depends on how many actual "pixels" this
; 3015 :          // component has, independent of interleaved MCU blocking and such
; 3016 :          int w = (z->img_comp[n].x+7) >> 3;
; 3017 :          int h = (z->img_comp[n].y+7) >> 3;
; 3018 :          for (j=0; j < h; ++j) {

	inc	ebp
	cmp	ebp, r12d
	jl	$LL25@stbi__pars

; 3061 :                   if (!STBI__RESTART(z->marker)) return 1;

	jmp	$LN271@stbi__pars
$LN58@stbi__pars:

; 3033 :                   stbi__jpeg_reset(z);
; 3034 :                }
; 3035 :             }
; 3036 :          }
; 3037 :          return 1;
; 3038 :       } else { // interleaved
; 3039 :          int i,j,k,x,y;
; 3040 :          for (j=0; j < z->img_mcu_y; ++j) {

	xor	r12d, r12d
	cmp	DWORD PTR [rbx+18068], r12d
	jle	$LN271@stbi__pars
	npad	12
$LL31@stbi__pars:

; 3041 :             for (i=0; i < z->img_mcu_x; ++i) {

	xor	r15d, r15d
	cmp	DWORD PTR [rbx+18064], r15d
	jle	$LN29@stbi__pars
$LL34@stbi__pars:

; 3042 :                // scan an interleaved mcu... process scan_n components in order
; 3043 :                for (k=0; k < z->scan_n; ++k) {

	xor	r13d, r13d
	cmp	DWORD PTR [rbx+18516], r13d
	jle	$LN269@stbi__pars
	lea	rax, QWORD PTR [rbx+18520]
	mov	QWORD PTR tv1851[rsp], rax
	npad	4
$LL37@stbi__pars:

; 3044 :                   int n = z->order[k];

	movsxd	r14, DWORD PTR [rax]

; 3045 :                   // scan out an mcu's worth of this component; that's just determined
; 3046 :                   // by the basic H and V specified for the component
; 3047 :                   for (y=0; y < z->img_comp[n].v; ++y) {

	xor	ebp, ebp
	lea	rsi, QWORD PTR [r14+r14*2]
	shl	rsi, 5
	add	rsi, rbx
	cmp	DWORD PTR [rsi+18088], ebp
	jle	$LN35@stbi__pars
	npad	4
$LL40@stbi__pars:

; 3048 :                      for (x=0; x < z->img_comp[n].h; ++x) {

	mov	eax, DWORD PTR [rsi+18084]
	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN38@stbi__pars
	npad	4
$LL43@stbi__pars:

; 3049 :                         int x2 = (i*z->img_comp[n].h + x);
; 3050 :                         int y2 = (j*z->img_comp[n].v + y);
; 3051 :                         short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);

	imul	eax, r15d
	mov	ecx, r12d
	imul	ecx, DWORD PTR [rsi+18088]

; 3052 :                         if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))

	mov	r9d, r14d
	add	ecx, ebp
	imul	ecx, DWORD PTR [rsi+18168]
	add	ecx, edi
	add	eax, ecx
	shl	eax, 6
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rsi+18160]
	lea	rdx, QWORD PTR [rax+rcx*2]
	movsxd	rax, DWORD PTR [rsi+18096]
	imul	r8, rax, 1680				; 00000690H
	mov	rcx, rbx
	add	r8, 8
	add	r8, rbx
	call	?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z ; stbi__jpeg_decode_block_prog_dc
	test	eax, eax
	je	$LN224@stbi__pars

; 3048 :                      for (x=0; x < z->img_comp[n].h; ++x) {

	mov	eax, DWORD PTR [rsi+18084]
	inc	edi
	cmp	edi, eax
	jl	SHORT $LL43@stbi__pars
$LN38@stbi__pars:

; 3045 :                   // scan out an mcu's worth of this component; that's just determined
; 3046 :                   // by the basic H and V specified for the component
; 3047 :                   for (y=0; y < z->img_comp[n].v; ++y) {

	inc	ebp
	cmp	ebp, DWORD PTR [rsi+18088]
	jl	SHORT $LL40@stbi__pars
$LN35@stbi__pars:

; 3042 :                // scan an interleaved mcu... process scan_n components in order
; 3043 :                for (k=0; k < z->scan_n; ++k) {

	mov	rax, QWORD PTR tv1851[rsp]
	inc	r13d
	add	rax, 4
	mov	QWORD PTR tv1851[rsp], rax
	cmp	r13d, DWORD PTR [rbx+18516]
	jl	$LL37@stbi__pars
$LN269@stbi__pars:

; 3054 :                      }
; 3055 :                   }
; 3056 :                }
; 3057 :                // after all interleaved components, that's an interleaved MCU,
; 3058 :                // so now count down the restart interval
; 3059 :                if (--z->todo <= 0) {

	dec	DWORD PTR [rbx+18540]
	cmp	DWORD PTR [rbx+18540], 0
	jg	$LN32@stbi__pars

; 3060 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

	cmp	DWORD PTR [rbx+18468], 24
	jge	SHORT $LN70@stbi__pars
	mov	rcx, rbx
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN70@stbi__pars:

; 3061 :                   if (!STBI__RESTART(z->marker)) return 1;

	movzx	eax, BYTE PTR [rbx+18472]
	add	al, 48					; 00000030H
	cmp	al, 7
	ja	$LN271@stbi__pars

; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;

	mov	DWORD PTR [rbx+18392], 0

; 2940 :    j->marker = STBI__MARKER_none;
; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;

	mov	ecx, 2147483647				; 7fffffffH
	mov	DWORD PTR [rbx+18296], 0
	mov	DWORD PTR [rbx+18200], 0
	mov	DWORD PTR [rbx+18104], 0
	mov	eax, DWORD PTR [rbx+18536]
	test	eax, eax
	mov	QWORD PTR [rbx+18464], 0
	cmovne	ecx, eax
	mov	DWORD PTR [rbx+18476], 0
	mov	DWORD PTR [rbx+18540], ecx
	mov	BYTE PTR [rbx+18472], 255		; 000000ffH

; 2942 :    j->eob_run = 0;

	mov	DWORD PTR [rbx+18500], 0
$LN32@stbi__pars:

; 3041 :             for (i=0; i < z->img_mcu_x; ++i) {

	inc	r15d
	cmp	r15d, DWORD PTR [rbx+18064]
	jl	$LL34@stbi__pars
$LN29@stbi__pars:

; 3033 :                   stbi__jpeg_reset(z);
; 3034 :                }
; 3035 :             }
; 3036 :          }
; 3037 :          return 1;
; 3038 :       } else { // interleaved
; 3039 :          int i,j,k,x,y;
; 3040 :          for (j=0; j < z->img_mcu_y; ++j) {

	inc	r12d
	cmp	r12d, DWORD PTR [rbx+18068]
	jl	$LL31@stbi__pars
	jmp	$LN271@stbi__pars
$LN224@stbi__pars:

; 3053 :                            return 0;

	xor	eax, eax
	jmp	$LN59@stbi__pars
?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z ENDP ; stbi__parse_entropy_coded_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z
_TEXT	SEGMENT
data$ = 8
dequant$ = 16
?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z PROC		; stbi__jpeg_dequantize, COMDAT

; 3072 : {

	mov	r8, rdx

; 3073 :    int i;
; 3074 :    for (i=0; i < 64; ++i)

	lea	rdx, QWORD PTR [rcx+126]
	lea	rax, QWORD PTR [r8+126]
	cmp	rcx, rax
	ja	SHORT $LN10@stbi__jpeg
	cmp	rdx, r8
	jb	SHORT $LN10@stbi__jpeg
	sub	r8, rcx
	mov	r9d, 64					; 00000040H
	npad	2
$LL8@stbi__jpeg:

; 3075 :       data[i] *= dequant[i];

	movsx	eax, WORD PTR [r8+rcx]
	movsx	edx, WORD PTR [rcx]
	lea	rcx, QWORD PTR [rcx+2]
	imul	edx, eax
	mov	WORD PTR [rcx-2], dx
	sub	r9, 1
	jne	SHORT $LL8@stbi__jpeg

; 3076 : }

	ret	0
$LN10@stbi__jpeg:

; 3073 :    int i;
; 3074 :    for (i=0; i < 64; ++i)

	lea	rax, QWORD PTR [rcx+16]
	sub	r8, rcx
	mov	ecx, 2
	npad	10
$LL4@stbi__jpeg:

; 3075 :       data[i] *= dequant[i];

	movdqu	xmm0, XMMWORD PTR [rax-16]
	movdqu	xmm1, XMMWORD PTR [r8+rax-16]
	movdqu	xmm2, XMMWORD PTR [r8+rax]
	lea	rax, QWORD PTR [rax+64]
	pmullw	xmm1, xmm0
	movdqu	XMMWORD PTR [rax-80], xmm1
	movdqu	xmm0, XMMWORD PTR [rax-64]
	movdqu	xmm1, XMMWORD PTR [r8+rax-48]
	pmullw	xmm2, xmm0
	movdqu	XMMWORD PTR [rax-64], xmm2
	movdqu	xmm0, XMMWORD PTR [rax-48]
	pmullw	xmm1, xmm0
	movdqu	XMMWORD PTR [rax-48], xmm1
	movdqu	xmm0, XMMWORD PTR [rax-32]
	movdqu	xmm1, XMMWORD PTR [r8+rax-32]
	pmullw	xmm1, xmm0
	movdqu	XMMWORD PTR [rax-32], xmm1
	sub	rcx, 1
	jne	SHORT $LL4@stbi__jpeg

; 3076 : }

	ret	0
?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z ENDP		; stbi__jpeg_dequantize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
_TEXT	SEGMENT
z$ = 80
?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z PROC		; stbi__jpeg_finish, COMDAT

; 3079 : {

	mov	r11, rsp
	push	r14
	sub	rsp, 64					; 00000040H

; 3080 :    if (z->progressive) {

	cmp	DWORD PTR [rcx+18480], 0
	mov	r14, rcx
	je	$LN3@stbi__jpeg

; 3081 :       // dequantize and idct the data
; 3082 :       int i,j,n;
; 3083 :       for (n=0; n < z->s->img_n; ++n) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [r11-32], r13
	xor	r13d, r13d
	cmp	DWORD PTR [rax+8], r13d
	jle	$LN54@stbi__jpeg
	mov	QWORD PTR [r11+8], rbx
	lea	rbx, QWORD PTR [rcx+18160]
	mov	QWORD PTR [r11+16], rbp
	mov	QWORD PTR [r11+24], rsi
	mov	QWORD PTR [r11-16], rdi
	mov	QWORD PTR [r11-24], r12
	mov	QWORD PTR [r11-40], r15
	npad	4
$LL4@stbi__jpeg:

; 3084 :          int w = (z->img_comp[n].x+7) >> 3;

	mov	r15d, DWORD PTR [rbx-52]
	xor	ebp, ebp

; 3085 :          int h = (z->img_comp[n].y+7) >> 3;

	mov	r12d, DWORD PTR [rbx-48]
	add	r15d, 7
	add	r12d, 7
	sar	r15d, 3
	sar	r12d, 3

; 3086 :          for (j=0; j < h; ++j) {

	test	r12d, r12d
	jle	$LN2@stbi__jpeg
$LL7@stbi__jpeg:

; 3087 :             for (i=0; i < w; ++i) {

	xor	edi, edi
	test	r15d, r15d
	jle	$LN5@stbi__jpeg
	xor	esi, esi
$LL10@stbi__jpeg:

; 3089 :                stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);

	movsxd	r8, DWORD PTR [rbx-68]
	mov	eax, ebp
	imul	eax, DWORD PTR [rbx+8]
	shl	r8, 7
	add	r8, 13448				; 00003488H
	add	r8, r14
	add	eax, edi
	shl	eax, 6
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbx]
	lea	r10, QWORD PTR [rax+rcx*2]
	lea	rax, QWORD PTR [r8+126]
	lea	rcx, QWORD PTR [r10+126]
	cmp	r10, rax
	ja	SHORT $LN28@stbi__jpeg

; 3088 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);

	cmp	rcx, r8
	jb	SHORT $LN28@stbi__jpeg
	mov	rax, r10
	sub	r8, r10
	mov	r9d, 64					; 00000040H
	npad	11
$LL42@stbi__jpeg:

; 3075 :       data[i] *= dequant[i];

	movsx	ecx, WORD PTR [rax+r8]
	movsx	edx, WORD PTR [rax]
	lea	rax, QWORD PTR [rax+2]
	imul	edx, ecx
	mov	WORD PTR [rax-2], dx
	sub	r9, 1
	jne	SHORT $LL42@stbi__jpeg

; 3074 :    for (i=0; i < 64; ++i)

	jmp	SHORT $LN15@stbi__jpeg
$LN28@stbi__jpeg:

; 3088 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);

	lea	rax, QWORD PTR [r10+16]
	sub	r8, r10
	mov	ecx, 2
	npad	9
$LL16@stbi__jpeg:

; 3075 :       data[i] *= dequant[i];

	movdqu	xmm0, XMMWORD PTR [rax-16]
	movdqu	xmm1, XMMWORD PTR [r8+rax-16]
	movdqu	xmm2, XMMWORD PTR [rax+r8]
	lea	rax, QWORD PTR [rax+64]
	pmullw	xmm1, xmm0
	movdqu	XMMWORD PTR [rax-80], xmm1
	movdqu	xmm0, XMMWORD PTR [rax-64]
	movdqu	xmm1, XMMWORD PTR [r8+rax-48]
	pmullw	xmm2, xmm0
	movdqu	XMMWORD PTR [rax-64], xmm2
	movdqu	xmm0, XMMWORD PTR [rax-48]
	pmullw	xmm1, xmm0
	movdqu	XMMWORD PTR [rax-48], xmm1
	movdqu	xmm0, XMMWORD PTR [rax-32]
	movdqu	xmm1, XMMWORD PTR [r8+rax-32]
	pmullw	xmm1, xmm0
	movdqu	XMMWORD PTR [rax-32], xmm1
	sub	rcx, 1
	jne	SHORT $LL16@stbi__jpeg
$LN15@stbi__jpeg:

; 3090 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);

	mov	edx, DWORD PTR [rbx-44]
	mov	r8, r10
	mov	eax, edx
	imul	eax, ebp
	shl	eax, 3
	movsxd	rcx, eax
	add	rcx, rsi
	add	rcx, QWORD PTR [rbx-32]
	call	QWORD PTR [r14+18544]
	inc	edi
	add	rsi, 8
	cmp	edi, r15d
	jl	$LL10@stbi__jpeg
$LN5@stbi__jpeg:

; 3086 :          for (j=0; j < h; ++j) {

	inc	ebp
	cmp	ebp, r12d
	jl	$LL7@stbi__jpeg
$LN2@stbi__jpeg:

; 3081 :       // dequantize and idct the data
; 3082 :       int i,j,n;
; 3083 :       for (n=0; n < z->s->img_n; ++n) {

	mov	rax, QWORD PTR [r14]
	inc	r13d
	add	rbx, 96					; 00000060H
	cmp	r13d, DWORD PTR [rax+8]
	jl	$LL4@stbi__jpeg
	mov	r15, QWORD PTR [rsp+32]
	mov	r12, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]
$LN54@stbi__jpeg:
	mov	r13, QWORD PTR [rsp+40]
$LN3@stbi__jpeg:

; 3091 :             }
; 3092 :          }
; 3093 :       }
; 3094 :    }
; 3095 : }

	add	rsp, 64					; 00000040H
	pop	r14
	ret	0
?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z ENDP		; stbi__jpeg_finish
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z
_TEXT	SEGMENT
L$3$ = 32
n$1$ = 36
h$1$ = 40
sizes$1 = 48
__$ArrayPad$ = 112
z$ = 176
m$ = 184
?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z PROC	; stbi__process_marker, COMDAT

; 3098 : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 128				; 00000080H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, rcx
	mov	edi, edx

; 3099 :    int L;
; 3100 :    switch (m) {

	mov	ecx, edx
	sub	ecx, 196				; 000000c4H
	je	$LN29@stbi__proc
	sub	ecx, 23
	je	$LN26@stbi__proc
	sub	ecx, 2
	je	$LN24@stbi__proc
	cmp	ecx, 34					; 00000022H
	je	$LN23@stbi__proc

; 3153 :    }
; 3154 : 
; 3155 :    // check for comment block or APP blocks
; 3156 :    if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {

	lea	eax, DWORD PTR [rdx-224]
	cmp	eax, 15
	jbe	SHORT $LN39@stbi__proc
	cmp	edx, 254				; 000000feH
	je	SHORT $LN39@stbi__proc

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0P@NNGPHMMK@unknown?5marker@
	mov	QWORD PTR [rdx+rcx], rax

; 3195 :    }
; 3196 : 
; 3197 :    return stbi__err("unknown marker","Corrupt JPEG");

	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN39@stbi__proc:

; 3157 :       L = stbi__get16be(z->s);

	mov	rcx, QWORD PTR [rsi]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	ebx, eax

; 3158 :       if (L < 2) {

	cmp	eax, 2
	jge	SHORT $LN43@stbi__proc

; 3159 :          if (m == 0xFE)

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	cmp	edi, 254				; 000000feH
	jne	SHORT $LN42@stbi__proc

; 978  :    stbi__g_failure_reason = str;

	lea	rax, OFFSET FLAT:??_C@_0M@CICAFFCH@bad?5COM?5len@
	mov	QWORD PTR [rdx+rcx], rax

; 3160 :             return stbi__err("bad COM len","Corrupt JPEG");

	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN42@stbi__proc:

; 978  :    stbi__g_failure_reason = str;

	lea	rax, OFFSET FLAT:??_C@_0M@EENLKPDI@bad?5APP?5len@
	mov	QWORD PTR [rdx+rcx], rax

; 3161 :          else
; 3162 :             return stbi__err("bad APP len","Corrupt JPEG");

	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN43@stbi__proc:

; 3163 :       }
; 3164 :       L -= 2;

	sub	ebx, 2

; 3165 : 
; 3166 :       if (m == 0xE0 && L >= 5) { // JFIF APP0 segment

	cmp	edi, 224				; 000000e0H
	jne	$LN44@stbi__proc
	cmp	ebx, 5
	jl	$LN50@stbi__proc

; 3167 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3168 :          int ok = 1;
; 3169 :          int i;
; 3170 :          for (i=0; i < 5; ++i)
; 3171 :             if (stbi__get8(z->s) != tag[i])

	mov	rdi, QWORD PTR [rsi]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rdi+192]
	cmp	rax, QWORD PTR [rdi+200]
	jae	SHORT $LN96@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN95@stbi__proc
$LN96@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], 0
	je	SHORT $LN97@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN95@stbi__proc
$LN97@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN95@stbi__proc:

; 3167 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3168 :          int ok = 1;
; 3169 :          int i;
; 3170 :          for (i=0; i < 5; ++i)
; 3171 :             if (stbi__get8(z->s) != tag[i])

	mov	rdi, QWORD PTR [rsi]
	xor	r13d, r13d
	cmp	cl, 74					; 0000004aH
	mov	r14d, r13d
	sete	r14b

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rdi+192]
	cmp	rax, QWORD PTR [rdi+200]
	jae	SHORT $LN140@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN142@stbi__proc
$LN140@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], r13d
	je	SHORT $LN141@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN142@stbi__proc
$LN141@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN142@stbi__proc:

; 3167 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3168 :          int ok = 1;
; 3169 :          int i;
; 3170 :          for (i=0; i < 5; ++i)
; 3171 :             if (stbi__get8(z->s) != tag[i])

	mov	rdi, QWORD PTR [rsi]
	cmp	cl, 70					; 00000046H
	mov	ebp, r13d
	cmove	ebp, r14d

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rdi+192]
	cmp	rax, QWORD PTR [rdi+200]
	jae	SHORT $LN145@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN147@stbi__proc
$LN145@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], r13d
	je	SHORT $LN146@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN147@stbi__proc
$LN146@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN147@stbi__proc:

; 3167 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3168 :          int ok = 1;
; 3169 :          int i;
; 3170 :          for (i=0; i < 5; ++i)
; 3171 :             if (stbi__get8(z->s) != tag[i])

	mov	rdi, QWORD PTR [rsi]
	cmp	cl, 73					; 00000049H
	mov	r14d, r13d
	cmove	r14d, ebp

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rdi+192]
	cmp	rax, QWORD PTR [rdi+200]
	jae	SHORT $LN150@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN152@stbi__proc
$LN150@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], r13d
	je	SHORT $LN151@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN152@stbi__proc
$LN151@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN152@stbi__proc:

; 3167 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3168 :          int ok = 1;
; 3169 :          int i;
; 3170 :          for (i=0; i < 5; ++i)
; 3171 :             if (stbi__get8(z->s) != tag[i])

	mov	rdi, QWORD PTR [rsi]
	cmp	cl, 70					; 00000046H
	mov	ebp, r13d
	cmove	ebp, r14d

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rdi+192]
	cmp	rax, QWORD PTR [rdi+200]
	jae	SHORT $LN155@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN157@stbi__proc
$LN155@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], r13d
	je	SHORT $LN156@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN157@stbi__proc
$LN156@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN157@stbi__proc:

; 3172 :                ok = 0;
; 3173 :          L -= 5;

	sub	ebx, 5
	test	cl, cl
	cmove	r13d, ebp

; 3174 :          if (ok)

	test	r13d, r13d
	je	$LN50@stbi__proc

; 3190 :          }
; 3191 :       }
; 3192 : 
; 3193 :       stbi__skip(z->s, L);

	mov	rcx, QWORD PTR [rsi]
	mov	edx, ebx
	mov	DWORD PTR [rsi+18504], 1
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 3194 :       return 1;

	mov	eax, 1
	jmp	$LN1@stbi__proc
$LN44@stbi__proc:

; 3175 :             z->jfif = 1;
; 3176 :       } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment

	cmp	edi, 238				; 000000eeH
	jne	$LN50@stbi__proc
	cmp	ebx, 12
	jl	$LN50@stbi__proc

; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;
; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)
; 3181 :             if (stbi__get8(z->s) != tag[i])

	mov	rdi, QWORD PTR [rsi]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rdi+192]
	cmp	rax, QWORD PTR [rdi+200]
	jae	SHORT $LN102@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN101@stbi__proc
$LN102@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], 0
	je	SHORT $LN103@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN101@stbi__proc
$LN103@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN101@stbi__proc:

; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;
; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)
; 3181 :             if (stbi__get8(z->s) != tag[i])

	mov	rdi, QWORD PTR [rsi]
	xor	r13d, r13d
	cmp	cl, 65					; 00000041H
	mov	r14d, r13d
	sete	r14b

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rdi+192]
	cmp	rax, QWORD PTR [rdi+200]
	jae	SHORT $LN160@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN162@stbi__proc
$LN160@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], r13d
	je	SHORT $LN161@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN162@stbi__proc
$LN161@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN162@stbi__proc:

; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;
; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)
; 3181 :             if (stbi__get8(z->s) != tag[i])

	mov	rdi, QWORD PTR [rsi]
	cmp	cl, 100					; 00000064H
	mov	ebp, r13d
	cmove	ebp, r14d

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rdi+192]
	cmp	rax, QWORD PTR [rdi+200]
	jae	SHORT $LN165@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN167@stbi__proc
$LN165@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], r13d
	je	SHORT $LN166@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN167@stbi__proc
$LN166@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN167@stbi__proc:

; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;
; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)
; 3181 :             if (stbi__get8(z->s) != tag[i])

	mov	rdi, QWORD PTR [rsi]
	cmp	cl, 111					; 0000006fH
	mov	r14d, r13d
	cmove	r14d, ebp

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rdi+192]
	cmp	rax, QWORD PTR [rdi+200]
	jae	SHORT $LN170@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN172@stbi__proc
$LN170@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], r13d
	je	SHORT $LN171@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN172@stbi__proc
$LN171@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN172@stbi__proc:

; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;
; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)
; 3181 :             if (stbi__get8(z->s) != tag[i])

	mov	rdi, QWORD PTR [rsi]
	cmp	cl, 98					; 00000062H
	mov	r15d, r13d
	cmove	r15d, r14d

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rdi+192]
	cmp	rax, QWORD PTR [rdi+200]
	jae	SHORT $LN175@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN177@stbi__proc
$LN175@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], r13d
	je	SHORT $LN176@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN177@stbi__proc
$LN176@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN177@stbi__proc:

; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;
; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)
; 3181 :             if (stbi__get8(z->s) != tag[i])

	mov	rdi, QWORD PTR [rsi]
	cmp	cl, 101					; 00000065H
	mov	ebp, r13d
	cmove	ebp, r15d

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rdi+192]
	cmp	rax, QWORD PTR [rdi+200]
	jae	SHORT $LN180@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN182@stbi__proc
$LN180@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], r13d
	je	SHORT $LN181@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN182@stbi__proc
$LN181@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN182@stbi__proc:

; 3182 :                ok = 0;
; 3183 :          L -= 6;

	sub	ebx, 6
	test	cl, cl
	cmove	r13d, ebp

; 3184 :          if (ok) {

	test	r13d, r13d
	je	$LN50@stbi__proc

; 3185 :             stbi__get8(z->s); // version

	mov	rdi, QWORD PTR [rsi]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rdi+192]
	cmp	rax, QWORD PTR [rdi+200]
	jae	SHORT $LN110@stbi__proc

; 1615 :       return *s->img_buffer++;

	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN111@stbi__proc
$LN110@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], 0
	je	SHORT $LN111@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	inc	QWORD PTR [rdi+192]
$LN111@stbi__proc:

; 3186 :             stbi__get16be(z->s); // flags0

	mov	rcx, QWORD PTR [rsi]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 3187 :             stbi__get16be(z->s); // flags1

	mov	rcx, QWORD PTR [rsi]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 3188 :             z->app14_color_transform = stbi__get8(z->s); // color transform

	mov	rdi, QWORD PTR [rsi]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rdi+192]
	cmp	rax, QWORD PTR [rdi+200]
	jb	SHORT $LN277@stbi__proc

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], 0
	je	SHORT $LN115@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi+192]
$LN277@stbi__proc:

; 3188 :             z->app14_color_transform = stbi__get8(z->s); // color transform

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN113@stbi__proc
$LN115@stbi__proc:

; 1620 :    return 0;

	xor	cl, cl
$LN113@stbi__proc:

; 3188 :             z->app14_color_transform = stbi__get8(z->s); // color transform

	movzx	edx, cl

; 3189 :             L -= 6;

	sub	ebx, 6
	mov	DWORD PTR [rsi+18508], edx
$LN50@stbi__proc:

; 3190 :          }
; 3191 :       }
; 3192 : 
; 3193 :       stbi__skip(z->s, L);

	mov	rcx, QWORD PTR [rsi]
	mov	edx, ebx
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 3194 :       return 1;

	mov	eax, 1
	jmp	$LN1@stbi__proc
$LN23@stbi__proc:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BA@KLNDOKJD@expected?5marker@
	mov	QWORD PTR [rdx+rcx], rax
$LN130@stbi__proc:

; 3198 : }

	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN24@stbi__proc:

; 3101 :       case STBI__MARKER_none: // no marker found
; 3102 :          return stbi__err("expected marker","Corrupt JPEG");
; 3103 : 
; 3104 :       case 0xDD: // DRI - specify restart interval
; 3105 :          if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");

	mov	rcx, QWORD PTR [rsi]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	cmp	eax, 4
	je	SHORT $LN25@stbi__proc

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0M@LPHNODCG@bad?5DRI?5len@
	mov	QWORD PTR [rdx+rcx], rax

; 3101 :       case STBI__MARKER_none: // no marker found
; 3102 :          return stbi__err("expected marker","Corrupt JPEG");
; 3103 : 
; 3104 :       case 0xDD: // DRI - specify restart interval
; 3105 :          if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");

	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN25@stbi__proc:

; 3106 :          z->restart_interval = stbi__get16be(z->s);

	mov	rcx, QWORD PTR [rsi]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	DWORD PTR [rsi+18536], eax

; 3107 :          return 1;

	mov	eax, 1
	jmp	$LN1@stbi__proc
$LN26@stbi__proc:

; 3108 : 
; 3109 :       case 0xDB: // DQT - define quantization table
; 3110 :          L = stbi__get16be(z->s)-2;

	mov	rcx, QWORD PTR [rsi]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 3111 :          while (L > 0) {

	xor	r13d, r13d
	lea	r15d, DWORD PTR [rax-2]
	test	r15d, r15d
	jle	$LN278@stbi__proc
	lea	r12, OFFSET FLAT:?stbi__jpeg_dezigzag@@3QBEB
	npad	4
$LL4@stbi__proc:

; 3112 :             int q = stbi__get8(z->s);

	mov	rbx, QWORD PTR [rsi]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN63@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN62@stbi__proc
$LN63@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], r13d
	je	SHORT $LN64@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN62@stbi__proc
$LN64@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN62@stbi__proc:

; 3112 :             int q = stbi__get8(z->s);

	movzx	eax, cl

; 3113 :             int p = q >> 4, sixteen = (p != 0);

	mov	ebp, eax

; 3114 :             int t = q & 15,i;

	and	eax, 15
	shr	ebp, 4

; 3115 :             if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");

	cmp	ebp, 1
	ja	$LN125@stbi__proc

; 3116 :             if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");

	cmp	eax, 3
	ja	$LN126@stbi__proc

; 3117 : 
; 3118 :             for (i=0; i < 64; ++i)
; 3119 :                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));

	mov	r14d, eax
	mov	rdi, r13
	shl	r14, 6
	npad	1
$LL8@stbi__proc:
	mov	rbx, QWORD PTR [rsi]
	test	ebp, ebp
	je	SHORT $LN52@stbi__proc
	mov	rcx, rbx
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	ecx, eax
	jmp	SHORT $LN53@stbi__proc
$LN52@stbi__proc:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN71@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN70@stbi__proc
$LN71@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], r13d
	je	SHORT $LN72@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN70@stbi__proc
$LN72@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN70@stbi__proc:

; 3117 : 
; 3118 :             for (i=0; i < 64; ++i)
; 3119 :                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));

	movzx	ecx, cl
$LN53@stbi__proc:
	movzx	eax, BYTE PTR [rdi+r12]
	inc	rdi
	add	rax, r14
	mov	WORD PTR [rsi+rax*2+13448], cx
	cmp	rdi, 64					; 00000040H
	jl	SHORT $LL8@stbi__proc

; 3120 :             L -= (sixteen ? 129 : 65);

	test	ebp, ebp
	mov	eax, 65					; 00000041H
	mov	ecx, 129				; 00000081H
	cmovne	eax, ecx
	sub	r15d, eax
	test	r15d, r15d
	jg	$LL4@stbi__proc

; 3121 :          }
; 3122 :          return L==0;

	test	r15d, r15d
	jmp	$LN278@stbi__proc
$LN126@stbi__proc:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0O@CNHKKDIM@bad?5DQT?5table@
	mov	QWORD PTR [rdx+rcx], rax

; 3116 :             if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");

	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN125@stbi__proc:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0N@BOFJCHAP@bad?5DQT?5type@
	mov	QWORD PTR [rdx+rcx], rax

; 3115 :             if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");

	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN29@stbi__proc:

; 3123 : 
; 3124 :       case 0xC4: // DHT - define huffman table
; 3125 :          L = stbi__get16be(z->s)-2;

	mov	rcx, QWORD PTR [rsi]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	sub	eax, 2

; 3126 :          while (L > 0) {

	xor	r13d, r13d
	mov	DWORD PTR L$3$[rsp], eax
	test	eax, eax
	jle	$LN278@stbi__proc
	npad	9
$LL9@stbi__proc:

; 3127 :             stbi_uc *v;
; 3128 :             int sizes[16],i,n=0;
; 3129 :             int q = stbi__get8(z->s);

	mov	rbx, QWORD PTR [rsi]
	mov	r15d, r13d

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN67@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN66@stbi__proc
$LN67@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], r13d
	je	SHORT $LN68@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN66@stbi__proc
$LN68@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN66@stbi__proc:

; 3127 :             stbi_uc *v;
; 3128 :             int sizes[16],i,n=0;
; 3129 :             int q = stbi__get8(z->s);

	movzx	r14d, cl

; 3130 :             int tc = q >> 4;

	mov	r12d, r14d

; 3131 :             int th = q & 15;

	and	r14d, 15
	shr	r12d, 4

; 3132 :             if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");

	cmp	r12d, 1
	ja	$LN31@stbi__proc
	cmp	r14d, 3
	ja	$LN31@stbi__proc

; 3133 :             for (i=0; i < 16; ++i) {

	lea	rdi, QWORD PTR sizes$1[rsp]
	mov	ebp, 16
	npad	8
$LL13@stbi__proc:

; 3134 :                sizes[i] = stbi__get8(z->s);

	mov	rbx, QWORD PTR [rsi]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN59@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN58@stbi__proc
$LN59@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], r13d
	je	SHORT $LN60@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN58@stbi__proc
$LN60@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN58@stbi__proc:

; 3134 :                sizes[i] = stbi__get8(z->s);

	movzx	eax, cl
	mov	DWORD PTR [rdi], eax

; 3135 :                n += sizes[i];

	add	r15d, eax
	add	rdi, 4
	sub	rbp, 1
	jne	SHORT $LL13@stbi__proc

; 3136 :             }
; 3137 :             if(n > 256) return stbi__err("bad DHT header","Corrupt JPEG"); // Loop over i < n would write past end of values!

	mov	DWORD PTR n$1$[rsp], r15d
	cmp	r15d, 256				; 00000100H
	jg	$LN31@stbi__proc

; 3138 :             L -= 17;

	sub	DWORD PTR L$3$[rsp], 17

; 3139 :             if (tc == 0) {

	lea	rdx, QWORD PTR sizes$1[rsp]
	mov	r15d, r14d
	imul	rbx, r15, 1680				; 00000690H
	add	rbx, rsi
	test	r12d, r12d
	jne	SHORT $LN33@stbi__proc

; 3140 :                if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;

	lea	rcx, QWORD PTR [rbx+8]
	call	?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z ; stbi__build_huffman
	test	eax, eax
	je	$LN130@stbi__proc

; 3141 :                v = z->huff_dc[th].values;

	lea	rcx, QWORD PTR [rbx+6728]
	mov	eax, 1032				; 00000408H
	mov	QWORD PTR h$1$[rsp], rcx

; 3142 :             } else {

	jmp	SHORT $LN34@stbi__proc
$LN33@stbi__proc:

; 3143 :                if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;

	lea	rcx, QWORD PTR [rbx+6728]
	mov	QWORD PTR h$1$[rsp], rcx
	call	?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z ; stbi__build_huffman
	test	eax, eax
	je	$LN130@stbi__proc

; 3144 :                v = z->huff_ac[th].values;

	mov	eax, 7752				; 00001e48H
$LN34@stbi__proc:

; 3145 :             }
; 3146 :             for (i=0; i < n; ++i)

	movsxd	rbp, DWORD PTR n$1$[rsp]
	lea	r14, QWORD PTR [rax+rbx]
	mov	rdi, r13
	test	rbp, rbp
	jle	SHORT $LN15@stbi__proc
	npad	5
$LL16@stbi__proc:

; 3147 :                v[i] = stbi__get8(z->s);

	mov	rbx, QWORD PTR [rsi]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN55@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN54@stbi__proc
$LN55@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], r13d
	je	SHORT $LN56@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN54@stbi__proc
$LN56@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN54@stbi__proc:

; 3147 :                v[i] = stbi__get8(z->s);

	mov	BYTE PTR [rdi+r14], cl
	inc	rdi
	cmp	rdi, rbp
	jl	SHORT $LL16@stbi__proc
$LN15@stbi__proc:

; 3148 :             if (tc != 0)

	test	r12d, r12d
	je	$LN76@stbi__proc

; 3149 :                stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);

	mov	rcx, QWORD PTR h$1$[rsp]
	lea	r10, QWORD PTR [rsi+13960]
	shl	r15, 10
	mov	rbx, rcx
	add	r10, r15
	mov	r11d, r13d
	npad	10
$LL77@stbi__proc:

; 2052 :       stbi_uc fast = h->fast[i];

	movzx	eax, BYTE PTR [rbx]

; 2053 :       fast_ac[i] = 0;

	mov	WORD PTR [r10], r13w

; 2054 :       if (fast < 255) {

	cmp	al, 255					; 000000ffH
	jae	$LN75@stbi__proc

; 2055 :          int rs = h->values[fast];

	movzx	r9d, BYTE PTR [rax+rcx+1024]

; 2056 :          int run = (rs >> 4) & 15;
; 2057 :          int magbits = rs & 15;
; 2058 :          int len = h->size[fast];

	movzx	edi, BYTE PTR [rax+rcx+1280]
	mov	ebp, r9d
	shr	ebp, 4
	and	r9d, 15

; 2059 : 
; 2060 :          if (magbits && len + magbits <= FAST_BITS) {

	je	SHORT $LN75@stbi__proc
	lea	eax, DWORD PTR [rdi+r9]
	cmp	eax, 9
	ja	SHORT $LN75@stbi__proc

; 2061 :             // magnitude code followed by receive_extend code
; 2062 :             int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);

	mov	ecx, edi
	mov	r8d, r11d
	shl	r8d, cl

; 2063 :             int m = 1 << (magbits - 1);

	mov	eax, 1
	and	r8d, 511				; 000001ffH
	mov	ecx, 9
	sub	ecx, r9d
	sar	r8d, cl
	lea	ecx, DWORD PTR [r9-1]
	shl	eax, cl

; 2064 :             if (k < m) k += (~0U << magbits) + 1;

	cmp	r8d, eax
	jge	SHORT $LN80@stbi__proc
	mov	ecx, r9d
	mov	edx, 1
	shl	edx, cl
	mov	eax, 1
	sub	eax, edx
	add	r8d, eax
$LN80@stbi__proc:

; 2065 :             // if the result is small enough, we can fit it in fast_ac table
; 2066 :             if (k >= -128 && k <= 127)

	mov	rcx, QWORD PTR h$1$[rsp]
	lea	eax, DWORD PTR [r8+128]
	cmp	eax, 255				; 000000ffH
	ja	SHORT $LN75@stbi__proc

; 2067 :                fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));

	shl	r8w, 4
	add	r8w, bp
	shl	r8w, 4
	add	r8w, di
	add	r8w, r9w
	mov	WORD PTR [r10], r8w
$LN75@stbi__proc:

; 1621 : }
; 1622 : 
; 1623 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1624 : // nothing
; 1625 : #else
; 1626 : stbi_inline static int stbi__at_eof(stbi__context *s)
; 1627 : {
; 1628 :    if (s->io.read) {
; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;
; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;
; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;
; 1636 : }
; 1637 : #endif
; 1638 : 
; 1639 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
; 1640 : // nothing
; 1641 : #else
; 1642 : static void stbi__skip(stbi__context *s, int n)
; 1643 : {
; 1644 :    if (n == 0) return;  // already there!
; 1645 :    if (n < 0) {
; 1646 :       s->img_buffer = s->img_buffer_end;
; 1647 :       return;
; 1648 :    }
; 1649 :    if (s->io.read) {
; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1651 :       if (blen < n) {
; 1652 :          s->img_buffer = s->img_buffer_end;
; 1653 :          (s->io.skip)(s->io_user_data, n - blen);
; 1654 :          return;
; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;
; 1658 : }
; 1659 : #endif
; 1660 : 
; 1661 : #if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
; 1662 : // nothing
; 1663 : #else
; 1664 : static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
; 1665 : {
; 1666 :    if (s->io.read) {
; 1667 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1668 :       if (blen < n) {
; 1669 :          int res, count;
; 1670 : 
; 1671 :          memcpy(buffer, s->img_buffer, blen);
; 1672 : 
; 1673 :          count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
; 1674 :          res = (count == (n-blen));
; 1675 :          s->img_buffer = s->img_buffer_end;
; 1676 :          return res;
; 1677 :       }
; 1678 :    }
; 1679 : 
; 1680 :    if (s->img_buffer+n <= s->img_buffer_end) {
; 1681 :       memcpy(buffer, s->img_buffer, n);
; 1682 :       s->img_buffer += n;
; 1683 :       return 1;
; 1684 :    } else
; 1685 :       return 0;
; 1686 : }
; 1687 : #endif
; 1688 : 
; 1689 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1690 : // nothing
; 1691 : #else
; 1692 : static int stbi__get16be(stbi__context *s)
; 1693 : {
; 1694 :    int z = stbi__get8(s);
; 1695 :    return (z << 8) + stbi__get8(s);
; 1696 : }
; 1697 : #endif
; 1698 : 
; 1699 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1700 : // nothing
; 1701 : #else
; 1702 : static stbi__uint32 stbi__get32be(stbi__context *s)
; 1703 : {
; 1704 :    stbi__uint32 z = stbi__get16be(s);
; 1705 :    return (z << 16) + stbi__get16be(s);
; 1706 : }
; 1707 : #endif
; 1708 : 
; 1709 : #if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
; 1710 : // nothing
; 1711 : #else
; 1712 : static int stbi__get16le(stbi__context *s)
; 1713 : {
; 1714 :    int z = stbi__get8(s);
; 1715 :    return z + (stbi__get8(s) << 8);
; 1716 : }
; 1717 : #endif
; 1718 : 
; 1719 : #ifndef STBI_NO_BMP
; 1720 : static stbi__uint32 stbi__get32le(stbi__context *s)
; 1721 : {
; 1722 :    stbi__uint32 z = stbi__get16le(s);
; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;
; 1724 :    return z;
; 1725 : }
; 1726 : #endif
; 1727 : 
; 1728 : #define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
; 1729 : 
; 1730 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1731 : // nothing
; 1732 : #else
; 1733 : //////////////////////////////////////////////////////////////////////////////
; 1734 : //
; 1735 : //  generic converter from built-in img_n to req_comp
; 1736 : //    individual types do this automatically as much as possible (e.g. jpeg
; 1737 : //    does all cases internally since it needs to colorspace convert anyway,
; 1738 : //    and it never has alpha, so very few cases ). png can automatically
; 1739 : //    interleave an alpha=255 channel, but falls back to this for other cases
; 1740 : //
; 1741 : //  assume data buffer is malloced, so malloc a new one and free that one
; 1742 : //  only failure mode is malloc failing
; 1743 : 
; 1744 : static stbi_uc stbi__compute_y(int r, int g, int b)
; 1745 : {
; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1747 : }
; 1748 : #endif
; 1749 : 
; 1750 : #if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1751 : // nothing
; 1752 : #else
; 1753 : static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1754 : {
; 1755 :    int i,j;
; 1756 :    unsigned char *good;
; 1757 : 
; 1758 :    if (req_comp == img_n) return data;
; 1759 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1760 : 
; 1761 :    good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
; 1762 :    if (good == NULL) {
; 1763 :       STBI_FREE(data);
; 1764 :       return stbi__errpuc("outofmem", "Out of memory");
; 1765 :    }
; 1766 : 
; 1767 :    for (j=0; j < (int) y; ++j) {
; 1768 :       unsigned char *src  = data + j * x * img_n   ;
; 1769 :       unsigned char *dest = good + j * x * req_comp;
; 1770 : 
; 1771 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1772 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1773 :       // convert source image with img_n components to one with req_comp components;
; 1774 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1775 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1776 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
; 1777 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1778 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
; 1779 :          STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
; 1780 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1781 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
; 1782 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
; 1783 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1784 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
; 1785 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1786 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1787 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
; 1788 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
; 1789 :       }
; 1790 :       #undef STBI__CASE
; 1791 :    }
; 1792 : 
; 1793 :    STBI_FREE(data);
; 1794 :    return good;
; 1795 : }
; 1796 : #endif
; 1797 : 
; 1798 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1799 : // nothing
; 1800 : #else
; 1801 : static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
; 1802 : {
; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1804 : }
; 1805 : #endif
; 1806 : 
; 1807 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1808 : // nothing
; 1809 : #else
; 1810 : static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1811 : {
; 1812 :    int i,j;
; 1813 :    stbi__uint16 *good;
; 1814 : 
; 1815 :    if (req_comp == img_n) return data;
; 1816 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1817 : 
; 1818 :    good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
; 1819 :    if (good == NULL) {
; 1820 :       STBI_FREE(data);
; 1821 :       return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1822 :    }
; 1823 : 
; 1824 :    for (j=0; j < (int) y; ++j) {
; 1825 :       stbi__uint16 *src  = data + j * x * img_n   ;
; 1826 :       stbi__uint16 *dest = good + j * x * req_comp;
; 1827 : 
; 1828 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1829 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1830 :       // convert source image with img_n components to one with req_comp components;
; 1831 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1832 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1833 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
; 1834 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1835 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
; 1836 :          STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
; 1837 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1838 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
; 1839 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
; 1840 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1841 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
; 1842 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1843 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1844 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
; 1845 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
; 1846 :       }
; 1847 :       #undef STBI__CASE
; 1848 :    }
; 1849 : 
; 1850 :    STBI_FREE(data);
; 1851 :    return good;
; 1852 : }
; 1853 : #endif
; 1854 : 
; 1855 : #ifndef STBI_NO_LINEAR
; 1856 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
; 1857 : {
; 1858 :    int i,k,n;
; 1859 :    float *output;
; 1860 :    if (!data) return NULL;
; 1861 :    output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
; 1862 :    if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
; 1863 :    // compute number of non-alpha components
; 1864 :    if (comp & 1) n = comp; else n = comp-1;
; 1865 :    for (i=0; i < x*y; ++i) {
; 1866 :       for (k=0; k < n; ++k) {
; 1867 :          output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
; 1868 :       }
; 1869 :    }
; 1870 :    if (n < comp) {
; 1871 :       for (i=0; i < x*y; ++i) {
; 1872 :          output[i*comp + n] = data[i*comp + n]/255.0f;
; 1873 :       }
; 1874 :    }
; 1875 :    STBI_FREE(data);
; 1876 :    return output;
; 1877 : }
; 1878 : #endif
; 1879 : 
; 1880 : #ifndef STBI_NO_HDR
; 1881 : #define stbi__float2int(x)   ((int) (x))
; 1882 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
; 1883 : {
; 1884 :    int i,k,n;
; 1885 :    stbi_uc *output;
; 1886 :    if (!data) return NULL;
; 1887 :    output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
; 1888 :    if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
; 1889 :    // compute number of non-alpha components
; 1890 :    if (comp & 1) n = comp; else n = comp-1;
; 1891 :    for (i=0; i < x*y; ++i) {
; 1892 :       for (k=0; k < n; ++k) {
; 1893 :          float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
; 1894 :          if (z < 0) z = 0;
; 1895 :          if (z > 255) z = 255;
; 1896 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1897 :       }
; 1898 :       if (k < comp) {
; 1899 :          float z = data[i*comp+k] * 255 + 0.5f;
; 1900 :          if (z < 0) z = 0;
; 1901 :          if (z > 255) z = 255;
; 1902 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1903 :       }
; 1904 :    }
; 1905 :    STBI_FREE(data);
; 1906 :    return output;
; 1907 : }
; 1908 : #endif
; 1909 : 
; 1910 : //////////////////////////////////////////////////////////////////////////////
; 1911 : //
; 1912 : //  "baseline" JPEG/JFIF decoder
; 1913 : //
; 1914 : //    simple implementation
; 1915 : //      - doesn't support delayed output of y-dimension
; 1916 : //      - simple interface (only one output format: 8-bit interleaved RGB)
; 1917 : //      - doesn't try to recover corrupt jpegs
; 1918 : //      - doesn't allow partial loading, loading multiple at once
; 1919 : //      - still fast on x86 (copying globals into locals doesn't help x86)
; 1920 : //      - allocates lots of intermediate memory (full size of all components)
; 1921 : //        - non-interleaved case requires this anyway
; 1922 : //        - allows good upsampling (see next)
; 1923 : //    high-quality
; 1924 : //      - upsampled channels are bilinearly interpolated, even across blocks
; 1925 : //      - quality integer IDCT derived from IJG's 'slow'
; 1926 : //    performance
; 1927 : //      - fast huffman; reasonable integer IDCT
; 1928 : //      - some SIMD kernels for common paths on targets with SSE2/NEON
; 1929 : //      - uses a lot of intermediate memory, could cache poorly
; 1930 : 
; 1931 : #ifndef STBI_NO_JPEG
; 1932 : 
; 1933 : // huffman decoding acceleration
; 1934 : #define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
; 1935 : 
; 1936 : typedef struct
; 1937 : {
; 1938 :    stbi_uc  fast[1 << FAST_BITS];
; 1939 :    // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
; 1940 :    stbi__uint16 code[256];
; 1941 :    stbi_uc  values[256];
; 1942 :    stbi_uc  size[257];
; 1943 :    unsigned int maxcode[18];
; 1944 :    int    delta[17];   // old 'firstsymbol' - old 'firstcode'
; 1945 : } stbi__huffman;
; 1946 : 
; 1947 : typedef struct
; 1948 : {
; 1949 :    stbi__context *s;
; 1950 :    stbi__huffman huff_dc[4];
; 1951 :    stbi__huffman huff_ac[4];
; 1952 :    stbi__uint16 dequant[4][64];
; 1953 :    stbi__int16 fast_ac[4][1 << FAST_BITS];
; 1954 : 
; 1955 : // sizes for components, interleaved MCUs
; 1956 :    int img_h_max, img_v_max;
; 1957 :    int img_mcu_x, img_mcu_y;
; 1958 :    int img_mcu_w, img_mcu_h;
; 1959 : 
; 1960 : // definition of jpeg image component
; 1961 :    struct
; 1962 :    {
; 1963 :       int id;
; 1964 :       int h,v;
; 1965 :       int tq;
; 1966 :       int hd,ha;
; 1967 :       int dc_pred;
; 1968 : 
; 1969 :       int x,y,w2,h2;
; 1970 :       stbi_uc *data;
; 1971 :       void *raw_data, *raw_coeff;
; 1972 :       stbi_uc *linebuf;
; 1973 :       short   *coeff;   // progressive only
; 1974 :       int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
; 1975 :    } img_comp[4];
; 1976 : 
; 1977 :    stbi__uint32   code_buffer; // jpeg entropy-coded buffer
; 1978 :    int            code_bits;   // number of valid bits
; 1979 :    unsigned char  marker;      // marker seen while filling entropy buffer
; 1980 :    int            nomore;      // flag if we saw a marker so must stop
; 1981 : 
; 1982 :    int            progressive;
; 1983 :    int            spec_start;
; 1984 :    int            spec_end;
; 1985 :    int            succ_high;
; 1986 :    int            succ_low;
; 1987 :    int            eob_run;
; 1988 :    int            jfif;
; 1989 :    int            app14_color_transform; // Adobe APP14 tag
; 1990 :    int            rgb;
; 1991 : 
; 1992 :    int scan_n, order[4];
; 1993 :    int restart_interval, todo;
; 1994 : 
; 1995 : // kernels
; 1996 :    void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
; 1997 :    void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
; 1998 :    stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
; 1999 : } stbi__jpeg;
; 2000 : 
; 2001 : static int stbi__build_huffman(stbi__huffman *h, int *count)
; 2002 : {
; 2003 :    int i,j,k=0;
; 2004 :    unsigned int code;
; 2005 :    // build size list for each symbol (from JPEG spec)
; 2006 :    for (i=0; i < 16; ++i) {
; 2007 :       for (j=0; j < count[i]; ++j) {
; 2008 :          h->size[k++] = (stbi_uc) (i+1);
; 2009 :          if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");
; 2010 :       }
; 2011 :    }
; 2012 :    h->size[k] = 0;
; 2013 : 
; 2014 :    // compute actual symbols (from jpeg spec)
; 2015 :    code = 0;
; 2016 :    k = 0;
; 2017 :    for(j=1; j <= 16; ++j) {
; 2018 :       // compute delta to add to code to compute symbol id
; 2019 :       h->delta[j] = k - code;
; 2020 :       if (h->size[k] == j) {
; 2021 :          while (h->size[k] == j)
; 2022 :             h->code[k++] = (stbi__uint16) (code++);
; 2023 :          if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
; 2024 :       }
; 2025 :       // compute largest code + 1 for this size, preshifted as needed later
; 2026 :       h->maxcode[j] = code << (16-j);
; 2027 :       code <<= 1;
; 2028 :    }
; 2029 :    h->maxcode[j] = 0xffffffff;
; 2030 : 
; 2031 :    // build non-spec acceleration table; 255 is flag for not-accelerated
; 2032 :    memset(h->fast, 255, 1 << FAST_BITS);
; 2033 :    for (i=0; i < k; ++i) {
; 2034 :       int s = h->size[i];
; 2035 :       if (s <= FAST_BITS) {
; 2036 :          int c = h->code[i] << (FAST_BITS-s);
; 2037 :          int m = 1 << (FAST_BITS-s);
; 2038 :          for (j=0; j < m; ++j) {
; 2039 :             h->fast[c+j] = (stbi_uc) i;
; 2040 :          }
; 2041 :       }
; 2042 :    }
; 2043 :    return 1;
; 2044 : }
; 2045 : 
; 2046 : // build a table that decodes both magnitude and value of small ACs in
; 2047 : // one go.
; 2048 : static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
; 2049 : {
; 2050 :    int i;
; 2051 :    for (i=0; i < (1 << FAST_BITS); ++i) {

	inc	r11d
	inc	rbx
	add	r10, 2
	cmp	r11d, 512				; 00000200H
	jl	$LL77@stbi__proc
$LN76@stbi__proc:

; 3150 :             L -= n;

	mov	eax, DWORD PTR L$3$[rsp]
	sub	eax, DWORD PTR n$1$[rsp]
	mov	DWORD PTR L$3$[rsp], eax
	test	eax, eax
	jg	$LL9@stbi__proc

; 3151 :          }
; 3152 :          return L==0;

	test	eax, eax
$LN278@stbi__proc:

; 3198 : }

	sete	r13b
	mov	eax, r13d
$LN1@stbi__proc:
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN31@stbi__proc:
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0P@JLGKOCGN@bad?5DHT?5header@
	mov	QWORD PTR [rdx+rcx], rax
	xor	eax, eax
	jmp	SHORT $LN1@stbi__proc
?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z ENDP	; stbi__process_marker
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z
_TEXT	SEGMENT
z$ = 48
?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z PROC	; stbi__process_scan_header, COMDAT

; 3202 : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 3203 :    int i;
; 3204 :    int Ls = stbi__get16be(z->s);

	mov	rcx, QWORD PTR [rcx]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 3205 :    z->scan_n = stbi__get8(z->s);

	mov	rbx, QWORD PTR [rdi]
	mov	esi, eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rdx, QWORD PTR [rbx+192]
	cmp	rdx, QWORD PTR [rbx+200]
	jae	SHORT $LN24@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rdx]
	inc	rdx
	mov	QWORD PTR [rbx+192], rdx
	jmp	SHORT $LN23@stbi__proc
$LN24@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN25@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN23@stbi__proc
$LN25@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN23@stbi__proc:

; 3205 :    z->scan_n = stbi__get8(z->s);

	movzx	ecx, cl
	mov	DWORD PTR [rdi+18516], ecx

; 3206 :    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");

	lea	eax, DWORD PTR [rcx-1]
	cmp	eax, 3
	ja	$LN9@stbi__proc
	mov	rax, QWORD PTR [rdi]
	cmp	ecx, DWORD PTR [rax+8]
	jg	$LN9@stbi__proc

; 3207 :    if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");

	lea	eax, DWORD PTR [rcx*2+6]
	cmp	esi, eax
	je	SHORT $LN10@stbi__proc

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0M@GNEHAHOH@bad?5SOS?5len@
	mov	QWORD PTR [rdx+rcx], rax

; 3207 :    if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");

	xor	eax, eax

; 3238 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN10@stbi__proc:
	mov	QWORD PTR [rsp+48], rbp

; 3208 :    for (i=0; i < z->scan_n; ++i) {

	xor	ebp, ebp
	mov	QWORD PTR [rsp+56], r14
	lea	r14, QWORD PTR [rdi+18520]
$LL4@stbi__proc:

; 3209 :       int id = stbi__get8(z->s), which;

	mov	rbx, QWORD PTR [rdi]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN32@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN31@stbi__proc
$LN32@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN33@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN31@stbi__proc
$LN33@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN31@stbi__proc:

; 3210 :       int q = stbi__get8(z->s);

	mov	rbx, QWORD PTR [rdi]
	movzx	esi, cl

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN36@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN35@stbi__proc
$LN36@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN37@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN35@stbi__proc
$LN37@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN35@stbi__proc:

; 3211 :       for (which = 0; which < z->s->img_n; ++which)

	mov	rax, QWORD PTR [rdi]
	xor	edx, edx
	movzx	r9d, cl
	xor	r8d, r8d
	mov	ecx, DWORD PTR [rax+8]
	test	ecx, ecx
	jle	SHORT $LN73@stbi__proc

; 3210 :       int q = stbi__get8(z->s);

	lea	rax, QWORD PTR [rdi+18080]
	npad	2
$LL7@stbi__proc:

; 3212 :          if (z->img_comp[which].id == id)

	cmp	DWORD PTR [rax], esi
	je	SHORT $LN73@stbi__proc

; 3211 :       for (which = 0; which < z->s->img_n; ++which)

	inc	edx
	inc	r8
	add	rax, 96					; 00000060H
	cmp	edx, ecx
	jl	SHORT $LL7@stbi__proc
$LN73@stbi__proc:

; 3213 :             break;
; 3214 :       if (which == z->s->img_n) return 0; // no match

	cmp	edx, ecx
	je	$LN64@stbi__proc

; 3215 :       z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");

	lea	rax, QWORD PTR [r8+r8*2]
	mov	ecx, r9d
	shl	rax, 5
	shr	ecx, 4
	mov	DWORD PTR [rax+rdi+18096], ecx
	cmp	ecx, 3
	ja	$LN65@stbi__proc

; 3216 :       z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");

	and	r9d, 15
	mov	DWORD PTR [rax+rdi+18100], r9d
	cmp	r9d, 3
	ja	$LN66@stbi__proc

; 3217 :       z->order[i] = which;

	mov	DWORD PTR [r14], edx
	inc	ebp
	add	r14, 4
	cmp	ebp, DWORD PTR [rdi+18516]
	jl	$LL4@stbi__proc

; 3218 :    }
; 3219 : 
; 3220 :    {
; 3221 :       int aa;
; 3222 :       z->spec_start = stbi__get8(z->s);

	mov	rbx, QWORD PTR [rdi]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN44@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN43@stbi__proc
$LN44@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN45@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN43@stbi__proc
$LN45@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN43@stbi__proc:

; 3223 :       z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0

	mov	rbx, QWORD PTR [rdi]
	movzx	eax, cl
	mov	DWORD PTR [rdi+18484], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN48@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN47@stbi__proc
$LN48@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN49@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN47@stbi__proc
$LN49@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN47@stbi__proc:

; 3224 :       aa = stbi__get8(z->s);

	mov	rbx, QWORD PTR [rdi]
	movzx	eax, cl
	mov	DWORD PTR [rdi+18488], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN52@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN51@stbi__proc
$LN52@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN53@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN51@stbi__proc
$LN53@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN51@stbi__proc:

; 3225 :       z->succ_high = (aa >> 4);
; 3226 :       z->succ_low  = (aa & 15);
; 3227 :       if (z->progressive) {

	mov	edx, DWORD PTR [rdi+18484]
	movzx	eax, cl
	mov	ecx, eax
	and	eax, 15
	shr	ecx, 4
	cmp	DWORD PTR [rdi+18480], 0
	mov	DWORD PTR [rdi+18492], ecx
	mov	DWORD PTR [rdi+18496], eax
	je	SHORT $LN15@stbi__proc

; 3228 :          if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)

	cmp	edx, 63					; 0000003fH
	jg	SHORT $LN21@stbi__proc
	mov	r8d, DWORD PTR [rdi+18488]
	cmp	r8d, 63					; 0000003fH
	jg	SHORT $LN21@stbi__proc
	cmp	edx, r8d
	jg	SHORT $LN21@stbi__proc
	cmp	ecx, 13
	ja	SHORT $LN21@stbi__proc
	cmp	eax, 13
	jbe	SHORT $LN16@stbi__proc
$LN21@stbi__proc:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_07EEJOMGGP@bad?5SOS@
$LN105@stbi__proc:
	mov	QWORD PTR [rdx+rcx], rax
$LN64@stbi__proc:

; 3216 :       z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");

	xor	eax, eax
$LN104@stbi__proc:
	mov	rbp, QWORD PTR [rsp+48]
	mov	r14, QWORD PTR [rsp+56]

; 3238 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN15@stbi__proc:

; 3229 :             return stbi__err("bad SOS", "Corrupt JPEG");
; 3230 :       } else {
; 3231 :          if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");

	test	edx, edx
	jne	SHORT $LN21@stbi__proc

; 3232 :          if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");

	test	ecx, ecx
	jne	SHORT $LN21@stbi__proc
	test	eax, eax
	jne	SHORT $LN21@stbi__proc

; 3233 :          z->spec_end = 63;

	mov	DWORD PTR [rdi+18488], 63		; 0000003fH
$LN16@stbi__proc:

; 3234 :       }
; 3235 :    }
; 3236 : 
; 3237 :    return 1;

	mov	eax, 1
	jmp	SHORT $LN104@stbi__proc
$LN66@stbi__proc:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0M@JGMCBLGG@bad?5AC?5huff@

; 3216 :       z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");

	jmp	SHORT $LN105@stbi__proc
$LN65@stbi__proc:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0M@NOCCBFAC@bad?5DC?5huff@

; 3215 :       z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");

	jmp	SHORT $LN105@stbi__proc
$LN9@stbi__proc:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88

; 3238 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]

; 978  :    stbi__g_failure_reason = str;

	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count@
	mov	QWORD PTR [rdx+rcx], rax

; 3206 :    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");

	xor	eax, eax

; 3238 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z ENDP	; stbi__process_scan_header
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z
_TEXT	SEGMENT
z$ = 48
ncomp$ = 56
why$ = 64
?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z PROC ; stbi__free_jpeg_components, COMDAT

; 3241 : {

	push	rsi
	sub	rsp, 32					; 00000020H
	mov	esi, r8d

; 3242 :    int i;
; 3243 :    for (i=0; i < ncomp; ++i) {

	test	edx, edx
	jle	SHORT $LN13@stbi__free
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rcx+18136]
	mov	QWORD PTR [rsp+56], rbp
	xor	ebp, ebp
	mov	QWORD PTR [rsp+64], rdi
	mov	edi, edx
$LL4@stbi__free:

; 3244 :       if (z->img_comp[i].raw_data) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN5@stbi__free

; 3245 :          STBI_FREE(z->img_comp[i].raw_data);

	call	QWORD PTR __imp_free

; 3246 :          z->img_comp[i].raw_data = NULL;

	mov	QWORD PTR [rbx], rbp

; 3247 :          z->img_comp[i].data = NULL;

	mov	QWORD PTR [rbx-8], rbp
$LN5@stbi__free:

; 3248 :       }
; 3249 :       if (z->img_comp[i].raw_coeff) {

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN6@stbi__free

; 3250 :          STBI_FREE(z->img_comp[i].raw_coeff);

	call	QWORD PTR __imp_free

; 3251 :          z->img_comp[i].raw_coeff = 0;

	mov	QWORD PTR [rbx+8], rbp

; 3252 :          z->img_comp[i].coeff = 0;

	mov	QWORD PTR [rbx+24], rbp
$LN6@stbi__free:

; 3253 :       }
; 3254 :       if (z->img_comp[i].linebuf) {

	mov	rcx, QWORD PTR [rbx+16]
	test	rcx, rcx
	je	SHORT $LN2@stbi__free

; 3255 :          STBI_FREE(z->img_comp[i].linebuf);

	call	QWORD PTR __imp_free

; 3256 :          z->img_comp[i].linebuf = NULL;

	mov	QWORD PTR [rbx+16], rbp
$LN2@stbi__free:

; 3242 :    int i;
; 3243 :    for (i=0; i < ncomp; ++i) {

	add	rbx, 96					; 00000060H
	sub	rdi, 1
	jne	SHORT $LL4@stbi__free
	mov	rdi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
$LN13@stbi__free:

; 3257 :       }
; 3258 :    }
; 3259 :    return why;
; 3260 : }

	mov	eax, esi
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z ENDP ; stbi__free_jpeg_components
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z
_TEXT	SEGMENT
z$ = 80
scan$ = 88
?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z PROC ; stbi__process_frame_header, COMDAT

; 3263 : {

	mov	DWORD PTR [rsp+16], edx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r15
	sub	rsp, 32					; 00000020H

; 3264 :    stbi__context *s = z->s;

	mov	rbx, QWORD PTR [rcx]
	mov	r15, rcx

; 3265 :    int Lf,p,i,q, h_max=1,v_max=1,c;

	mov	esi, 1

; 3266 :    Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG

	mov	rcx, rbx
	mov	ebp, esi
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	edi, eax
	cmp	eax, 11
	jge	SHORT $LN17@stbi__proc
$LN251@stbi__proc:

; 3352 : }

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0M@DOFMJEMP@bad?5SOF?5len@
	mov	QWORD PTR [rdx+rcx], rax
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN17@stbi__proc:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN249@stbi__proc

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	$LN177@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN249@stbi__proc:

; 3267 :    p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 8
	jne	$LN177@stbi__proc

; 3268 :    s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG

	mov	rcx, rbx
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	DWORD PTR [rbx+4], eax
	test	eax, eax
	jne	SHORT $LN19@stbi__proc

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BB@LNEGOMA@no?5header?5height@
	mov	QWORD PTR [rdx+rcx], rax

; 3268 :    s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG

	xor	eax, eax

; 3352 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN19@stbi__proc:

; 3269 :    s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires

	mov	rcx, rbx
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	DWORD PTR [rbx], eax
	test	eax, eax
	jne	SHORT $LN20@stbi__proc

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_07BIDACDEF@0?5width@
	mov	QWORD PTR [rdx+rcx], rax

; 3269 :    s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires

	xor	eax, eax

; 3352 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN20@stbi__proc:

; 3270 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

	cmp	DWORD PTR [rbx+4], 16777216		; 01000000H
	jbe	SHORT $LN21@stbi__proc
$LN252@stbi__proc:

; 3352 : }

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
	mov	QWORD PTR [rdx+rcx], rax
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN21@stbi__proc:

; 3271 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

	cmp	eax, 16777216				; 01000000H
	ja	SHORT $LN252@stbi__proc

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN138@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN137@stbi__proc
$LN138@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN139@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN137@stbi__proc
$LN139@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN137@stbi__proc:

; 3272 :    c = stbi__get8(s);

	movzx	ecx, cl

; 3273 :    if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");

	lea	eax, DWORD PTR [rcx-1]
	test	eax, -4					; fffffffcH
	jne	$LN189@stbi__proc
	cmp	ecx, 2
	je	$LN189@stbi__proc

; 3274 :    s->img_n = c;
; 3275 :    for (i=0; i < c; ++i) {

	xor	r10d, r10d
	mov	DWORD PTR [rbx+8], ecx
	test	rcx, rcx
	je	SHORT $LN3@stbi__proc
	lea	rax, QWORD PTR [r15+18152]
	npad	5
$LL4@stbi__proc:

; 3276 :       z->img_comp[i].data = NULL;

	mov	QWORD PTR [rax-24], r10

; 3277 :       z->img_comp[i].linebuf = NULL;

	mov	QWORD PTR [rax], r10
	lea	rax, QWORD PTR [rax+96]
	sub	rcx, rsi
	jne	SHORT $LL4@stbi__proc
$LN3@stbi__proc:

; 3278 :    }
; 3279 : 
; 3280 :    if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");

	mov	eax, DWORD PTR [rbx+8]
	lea	ecx, DWORD PTR [rax+4]
	lea	ecx, DWORD PTR [rax+rcx*2]
	cmp	edi, ecx
	jne	$LN251@stbi__proc

; 3281 : 
; 3282 :    z->rgb = 0;
; 3283 :    for (i=0; i < s->img_n; ++i) {

	mov	QWORD PTR [rsp+80], r12
	mov	QWORD PTR [rsp+96], r13
	mov	r13d, r10d
	mov	DWORD PTR [r15+18512], r10d
	mov	r8d, DWORD PTR [rbx+8]
	mov	QWORD PTR [rsp+104], r14
	test	r8d, r8d
	jle	$LN6@stbi__proc
	lea	r12, OFFSET FLAT:?rgb@?BG@??stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z@4QBEB
	lea	r14, QWORD PTR [r15+18084]
	lea	rdi, QWORD PTR [rbx+48]
	npad	7
$LL7@stbi__proc:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN97@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN96@stbi__proc
$LN97@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi], 0
	je	SHORT $LN98@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN96@stbi__proc
$LN98@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN96@stbi__proc:

; 3284 :       static const unsigned char rgb[3] = { 'R', 'G', 'B' };
; 3285 :       z->img_comp[i].id = stbi__get8(s);

	movzx	edx, cl
	mov	DWORD PTR [r14-4], edx

; 3286 :       if (s->img_n == 3 && z->img_comp[i].id == rgb[i])

	cmp	DWORD PTR [rbx+8], 3
	jne	SHORT $LN25@stbi__proc
	movzx	eax, BYTE PTR [r12]
	cmp	edx, eax
	jne	SHORT $LN25@stbi__proc

; 3287 :          ++z->rgb;

	inc	DWORD PTR [r15+18512]
$LN25@stbi__proc:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN101@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN100@stbi__proc
$LN101@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi], 0
	je	SHORT $LN102@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN100@stbi__proc
$LN102@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN100@stbi__proc:

; 3288 :       q = stbi__get8(s);

	movzx	ecx, cl

; 3289 :       z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");

	mov	eax, ecx
	shr	eax, 4
	mov	DWORD PTR [r14], eax
	dec	eax
	cmp	eax, 3
	ja	$LN157@stbi__proc

; 3290 :       z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");

	and	ecx, 15
	mov	DWORD PTR [r14+4], ecx
	lea	eax, DWORD PTR [rcx-1]
	cmp	eax, 3
	ja	$LN158@stbi__proc

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN142@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	lea	rdi, QWORD PTR [rbx+48]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN141@stbi__proc
$LN142@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi], 0
	je	SHORT $LN143@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN141@stbi__proc
$LN143@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN141@stbi__proc:

; 3291 :       z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");

	movzx	eax, cl
	mov	DWORD PTR [r14+8], eax
	cmp	eax, 3
	ja	$LN156@stbi__proc

; 3281 : 
; 3282 :    z->rgb = 0;
; 3283 :    for (i=0; i < s->img_n; ++i) {

	mov	r8d, DWORD PTR [rbx+8]
	inc	r13d
	inc	r12
	add	r14, 96					; 00000060H
	cmp	r13d, r8d
	jl	$LL7@stbi__proc

; 3345 :          if (z->img_comp[i].raw_coeff == NULL)

	xor	r10d, r10d
$LN6@stbi__proc:

; 3292 :    }
; 3293 : 
; 3294 :    if (scan != STBI__SCAN_load) return 1;

	cmp	DWORD PTR scan$[rsp], 0
	jne	$LN15@stbi__proc

; 3295 : 
; 3296 :    if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");

	mov	ecx, DWORD PTR [rbx]
	mov	r9d, DWORD PTR [rbx+4]

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	$LN183@stbi__proc
	test	r9d, r9d
	js	$LN183@stbi__proc

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN185@stbi__proc

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	r9d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	$LN183@stbi__proc
$LN185@stbi__proc:
	imul	ecx, r9d

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	$LN183@stbi__proc
	test	r8d, r8d
	js	$LN183@stbi__proc

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN12@stbi__proc

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	r8d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	$LN183@stbi__proc

; 3297 : 
; 3298 :    for (i=0; i < s->img_n; ++i) {

	test	r8d, r8d
	jle	SHORT $LN12@stbi__proc
	lea	rcx, QWORD PTR [r15+18088]
	mov	edx, r8d
	npad	4
$LL10@stbi__proc:

; 3299 :       if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;

	mov	eax, DWORD PTR [rcx-4]
	lea	rcx, QWORD PTR [rcx+96]

; 3300 :       if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;

	cmp	eax, esi
	cmovle	eax, esi
	mov	esi, eax
	mov	eax, DWORD PTR [rcx-96]
	cmp	eax, ebp
	cmovle	eax, ebp
	mov	ebp, eax
	sub	rdx, 1
	jne	SHORT $LL10@stbi__proc
	mov	r9d, r10d
	lea	rcx, QWORD PTR [r15+18088]
	npad	8
$LL13@stbi__proc:

; 3306 :       if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");

	mov	eax, esi
	cdq
	idiv	DWORD PTR [rcx-4]
	test	edx, edx
	jne	$LN157@stbi__proc

; 3307 :       if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");

	mov	eax, ebp
	cdq
	idiv	DWORD PTR [rcx]
	test	edx, edx
	jne	$LN158@stbi__proc

; 3301 :    }
; 3302 : 
; 3303 :    // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
; 3304 :    // and I've never seen a non-corrupted JPEG file actually use them
; 3305 :    for (i=0; i < s->img_n; ++i) {

	inc	r9d
	add	rcx, 96					; 00000060H
	cmp	r9d, r8d
	jl	SHORT $LL13@stbi__proc
$LN12@stbi__proc:

; 3308 :    }
; 3309 : 
; 3310 :    // compute interleaved mcu info
; 3311 :    z->img_h_max = h_max;
; 3312 :    z->img_v_max = v_max;
; 3313 :    z->img_mcu_w = h_max * 8;
; 3314 :    z->img_mcu_h = v_max * 8;
; 3315 :    // these sizes can't be more than 17 bits
; 3316 :    z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;

	xor	edx, edx
	mov	DWORD PTR [r15+18056], esi
	lea	ecx, DWORD PTR [rsi*8]
	mov	DWORD PTR [r15+18060], ebp
	lea	r8d, DWORD PTR [rbp*8]
	mov	DWORD PTR [r15+18072], ecx
	mov	DWORD PTR [r15+18076], r8d

; 3317 :    z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;
; 3318 : 
; 3319 :    for (i=0; i < s->img_n; ++i) {

	mov	r14d, r10d
	mov	eax, DWORD PTR [rbx]
	dec	eax
	add	eax, ecx
	div	ecx
	xor	edx, edx
	mov	DWORD PTR [r15+18064], eax
	mov	eax, DWORD PTR [rbx+4]
	dec	eax
	add	eax, r8d
	div	r8d
	mov	DWORD PTR [r15+18068], eax
	cmp	DWORD PTR [rbx+8], 0
	jle	$LN15@stbi__proc
	lea	rdi, QWORD PTR [r15+18108]
	npad	5
$LL16@stbi__proc:

; 3320 :       // number of effective pixels (e.g. for non-interleaved MCU)
; 3321 :       z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;

	mov	r9d, DWORD PTR [rdi-24]
	xor	edx, edx

; 3322 :       z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;

	mov	ecx, DWORD PTR [rdi-20]
	mov	eax, r9d
	imul	eax, DWORD PTR [rbx]
	dec	eax
	add	eax, esi
	div	esi
	xor	edx, edx
	mov	DWORD PTR [rdi], eax
	mov	eax, ecx
	imul	eax, DWORD PTR [rbx+4]
	dec	eax
	add	eax, ebp
	div	ebp
	mov	DWORD PTR [rdi+4], eax

; 3323 :       // to simplify generation, we'll allocate enough memory to decode
; 3324 :       // the bogus oversized data from using interleaved MCUs and their
; 3325 :       // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
; 3326 :       // discard the extra data until colorspace conversion
; 3327 :       //
; 3328 :       // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
; 3329 :       // so these muls can't overflow with 32-bit ints (which we require)
; 3330 :       z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;

	imul	r9d, DWORD PTR [r15+18064]
	shl	r9d, 3
	mov	DWORD PTR [rdi+8], r9d

; 3331 :       z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;

	imul	ecx, DWORD PTR [r15+18068]

; 3332 :       z->img_comp[i].coeff = 0;

	mov	QWORD PTR [rdi+52], r10

; 3333 :       z->img_comp[i].raw_coeff = 0;

	mov	QWORD PTR [rdi+36], r10

; 3334 :       z->img_comp[i].linebuf = NULL;

	mov	QWORD PTR [rdi+44], r10
	shl	ecx, 3
	mov	DWORD PTR [rdi+12], ecx

; 1014 :    if (a < 0 || b < 0) return 0;

	test	r9d, r9d
	js	$LN181@stbi__proc
	test	ecx, ecx
	js	$LN181@stbi__proc

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	jne	SHORT $LN51@stbi__proc
	imul	ecx, r9d
	mov	r8d, ecx
	jmp	$LN182@stbi__proc
$LN156@stbi__proc:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_06LJIHDFHI@bad?5TQ@
$LN250@stbi__proc:
	mov	QWORD PTR [rdx+rcx], rax

; 3306 :       if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");

	xor	eax, eax
$LN248@stbi__proc:
	mov	r13, QWORD PTR [rsp+96]
	mov	r12, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+104]

; 3352 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN158@stbi__proc:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_05MPLLHCJG@bad?5V@

; 3307 :       if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");

	jmp	SHORT $LN250@stbi__proc
$LN157@stbi__proc:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_05BLPKENEJ@bad?5H@

; 3306 :       if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");

	jmp	SHORT $LN250@stbi__proc
$LN51@stbi__proc:

; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH

; 1024 :    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);

	mov	r8d, ecx

; 1017 :    return a <= INT_MAX/b;

	cdq

; 1024 :    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);

	imul	r8d, r9d

; 1017 :    return a <= INT_MAX/b;

	idiv	ecx

; 1024 :    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);

	cmp	r9d, eax
	jg	$LN181@stbi__proc
$LN182@stbi__proc:

; 1049 :    return stbi__malloc(a*b + add);

	lea	eax, DWORD PTR [r8+15]
	movsxd	rcx, eax

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc

; 3335 :       z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);

	mov	QWORD PTR [rdi+28], rax

; 3336 :       if (z->img_comp[i].raw_data == NULL)

	test	rax, rax
	je	$LN159@stbi__proc

; 3338 :       // align blocks for idct using mmx/sse
; 3339 :       z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);

	add	rax, 15
	and	rax, -16
	mov	QWORD PTR [rdi+20], rax

; 3340 :       if (z->progressive) {

	cmp	DWORD PTR [r15+18480], 0
	je	SHORT $LN14@stbi__proc

; 3341 :          // w2, h2 are multiples of 8 (see above)
; 3342 :          z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;

	mov	ecx, DWORD PTR [rdi+8]
	mov	eax, ecx

; 3343 :          z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;

	mov	r8d, DWORD PTR [rdi+12]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR [rdi+60], eax
	mov	eax, r8d
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR [rdi+64], eax

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	SHORT $LN179@stbi__proc
	test	r8d, r8d
	js	SHORT $LN179@stbi__proc

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN180@stbi__proc

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	r8d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	SHORT $LN179@stbi__proc
$LN180@stbi__proc:
	imul	ecx, r8d

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	SHORT $LN179@stbi__proc

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, 1073741823				; 3fffffffH
	jg	SHORT $LN179@stbi__proc
	lea	eax, DWORD PTR [rcx+rcx]

; 1007 :    return a <= INT_MAX - b;

	cmp	eax, 2147483632				; 7ffffff0H

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	jg	SHORT $LN179@stbi__proc

; 1056 :    return stbi__malloc(a*b*c + add);

	lea	eax, DWORD PTR [rcx*2+15]
	movsxd	rcx, eax

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc

; 3344 :          z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);

	mov	QWORD PTR [rdi+36], rax

; 3345 :          if (z->img_comp[i].raw_coeff == NULL)

	test	rax, rax
	je	SHORT $LN159@stbi__proc

; 3347 :          z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);

	add	rax, 15
	and	rax, -16
	mov	QWORD PTR [rdi+52], rax
$LN14@stbi__proc:

; 3317 :    z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;
; 3318 : 
; 3319 :    for (i=0; i < s->img_n; ++i) {

	inc	r14d
	add	rdi, 96					; 00000060H
	cmp	r14d, DWORD PTR [rbx+8]
	jge	SHORT $LN15@stbi__proc
	xor	r10d, r10d
	jmp	$LL16@stbi__proc
$LN179@stbi__proc:

; 1055 :    if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;

	mov	QWORD PTR [rdi+36], 0

; 3346 :             return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));

	jmp	SHORT $LN159@stbi__proc
$LN181@stbi__proc:

; 1048 :    if (!stbi__mad2sizes_valid(a, b, add)) return NULL;

	mov	QWORD PTR [rdi+28], r10
$LN159@stbi__proc:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88

; 3337 :          return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));

	xor	r8d, r8d

; 978  :    stbi__g_failure_reason = str;

	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	mov	QWORD PTR [rdx+rcx], rax

; 3337 :          return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));

	lea	edx, DWORD PTR [r14+1]
	mov	rcx, r15
	call	?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z ; stbi__free_jpeg_components
	jmp	$LN248@stbi__proc
$LN183@stbi__proc:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@

; 3295 : 
; 3296 :    if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");

	jmp	$LN250@stbi__proc
$LN15@stbi__proc:

; 3348 :       }
; 3349 :    }
; 3350 : 
; 3351 :    return 1;

	mov	eax, 1
	jmp	$LN248@stbi__proc
$LN189@stbi__proc:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BE@DAPHADHL@bad?5component?5count@
	mov	QWORD PTR [rdx+rcx], rax

; 3273 :    if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");

	xor	eax, eax

; 3352 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN177@stbi__proc:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0L@BCINMEBJ@only?58?9bit@
	mov	QWORD PTR [rdx+rcx], rax

; 3267 :    p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline

	xor	eax, eax

; 3352 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z ENDP ; stbi__process_frame_header
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z
_TEXT	SEGMENT
z$ = 48
scan$ = 56
?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z PROC	; stbi__decode_jpeg_header, COMDAT

; 3364 : {

	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 3365 :    int m;
; 3366 :    z->jfif = 0;

	xor	esi, esi

; 3367 :    z->app14_color_transform = -1; // valid values are 0,1,2

	mov	DWORD PTR [rcx+18508], -1
	mov	DWORD PTR [rcx+18504], esi
	mov	ebp, edx
	mov	rdi, rcx

; 3368 :    z->marker = STBI__MARKER_none; // initialize cached marker to empty

	mov	BYTE PTR [rcx+18472], 255		; 000000ffH

; 3369 :    m = stbi__get_marker(z);

	call	?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker

; 3370 :    if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");

	cmp	al, 216					; 000000d8H
	je	SHORT $LN6@stbi__deco

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_06CLMBLEP@no?5SOI@
	mov	QWORD PTR [rdx+rcx], rax

; 3370 :    if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");

	xor	eax, eax

; 3384 :    return 1;
; 3385 : }

	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@stbi__deco:

; 3371 :    if (scan == STBI__SCAN_type) return 1;

	cmp	ebp, 1
	je	$LN10@stbi__deco

; 3372 :    m = stbi__get_marker(z);

	mov	rcx, rdi
	mov	QWORD PTR [rsp+48], rbx
	call	?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
	movzx	edx, al

; 3373 :    while (!stbi__SOF(m)) {

	cmp	edx, 192				; 000000c0H
	je	SHORT $LN3@stbi__deco
$LL2@stbi__deco:
	lea	eax, DWORD PTR [rdx-193]
	cmp	eax, 1
	jbe	SHORT $LN3@stbi__deco

; 3374 :       if (!stbi__process_marker(z,m)) return 0;

	mov	rcx, rdi
	call	?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z ; stbi__process_marker
	test	eax, eax
	je	$LN31@stbi__deco

; 3375 :       m = stbi__get_marker(z);

	mov	rcx, rdi
	call	?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
	movzx	edx, al

; 3376 :       while (m == STBI__MARKER_none) {

	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN34@stbi__deco
$LL4@stbi__deco:

; 3377 :          // some files have extra padding after their blocks, so ok, we'll scan
; 3378 :          if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");

	mov	rbx, QWORD PTR [rdi]

; 1628 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], rsi
	je	SHORT $LN17@stbi__deco

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	rax, QWORD PTR [rbx+32]
	mov	rcx, QWORD PTR [rbx+40]
	call	rax
	test	eax, eax
	je	SHORT $LN30@stbi__deco

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

	cmp	DWORD PTR [rbx+48], esi
	je	SHORT $LN33@stbi__deco
$LN17@stbi__deco:

; 3377 :          // some files have extra padding after their blocks, so ok, we'll scan
; 3378 :          if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");

	mov	rax, QWORD PTR [rbx+200]
	cmp	QWORD PTR [rbx+192], rax
	jae	SHORT $LN33@stbi__deco
$LN30@stbi__deco:

; 3379 :          m = stbi__get_marker(z);

	mov	rcx, rdi
	call	?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
	movzx	edx, al
	cmp	edx, 255				; 000000ffH
	je	SHORT $LL4@stbi__deco
$LN34@stbi__deco:

; 3373 :    while (!stbi__SOF(m)) {

	cmp	edx, 192				; 000000c0H
	jne	SHORT $LL2@stbi__deco
$LN3@stbi__deco:

; 3380 :       }
; 3381 :    }
; 3382 :    z->progressive = stbi__SOF_progressive(m);

	cmp	edx, 194				; 000000c2H
	mov	ecx, esi

; 3383 :    if (!stbi__process_frame_header(z, scan)) return 0;

	mov	edx, ebp
	sete	cl
	mov	DWORD PTR [rdi+18480], ecx
	mov	rcx, rdi
	call	?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z ; stbi__process_frame_header
	test	eax, eax
	setne	sil
	mov	eax, esi
$LN45@stbi__deco:
	mov	rbx, QWORD PTR [rsp+48]

; 3384 :    return 1;
; 3385 : }

	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN33@stbi__deco:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_06IFCEAHIA@no?5SOF@
	mov	QWORD PTR [rdx+rcx], rax
$LN31@stbi__deco:

; 3377 :          // some files have extra padding after their blocks, so ok, we'll scan
; 3378 :          if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");

	xor	eax, eax
	jmp	SHORT $LN45@stbi__deco
$LN10@stbi__deco:

; 3384 :    return 1;
; 3385 : }

	mov	rbp, QWORD PTR [rsp+56]
	mov	eax, 1
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z ENDP	; stbi__decode_jpeg_header
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__skip_jpeg_junk_at_end@@YAHPEAUstbi__jpeg@@@Z
_TEXT	SEGMENT
j$ = 48
?stbi__skip_jpeg_junk_at_end@@YAHPEAUstbi__jpeg@@@Z PROC ; stbi__skip_jpeg_junk_at_end, COMDAT

; 3388 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	npad	3
$LL2@stbi__skip:

; 3389 :    // some JPEGs have junk at end, skip over it but if we find what looks
; 3390 :    // like a valid marker, resume there
; 3391 :    while (!stbi__at_eof(j->s)) {

	mov	rbx, QWORD PTR [rdi]

; 1628 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], 0
	je	SHORT $LN12@stbi__skip

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	rax, QWORD PTR [rbx+32]
	mov	rcx, QWORD PTR [rbx+40]
	call	rax
	test	eax, eax
	je	SHORT $LN36@stbi__skip

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

	cmp	DWORD PTR [rbx+48], 0
	je	$LN3@stbi__skip
$LN12@stbi__skip:

; 3389 :    // some JPEGs have junk at end, skip over it but if we find what looks
; 3390 :    // like a valid marker, resume there
; 3391 :    while (!stbi__at_eof(j->s)) {

	mov	rax, QWORD PTR [rbx+200]
	cmp	QWORD PTR [rbx+192], rax
	jae	$LN3@stbi__skip
$LN36@stbi__skip:

; 3392 :       int x = stbi__get8(j->s);

	mov	rbx, QWORD PTR [rdi]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN52@stbi__skip

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LL2@stbi__skip

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN52@stbi__skip:

; 3393 :       while (x == 255) { // might be a marker

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 255					; 000000ffH
	jne	SHORT $LL2@stbi__skip
$LL4@stbi__skip:

; 3394 :          if (stbi__at_eof(j->s)) return STBI__MARKER_none;

	mov	rbx, QWORD PTR [rdi]

; 1628 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], 0
	je	SHORT $LN21@stbi__skip

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	rax, QWORD PTR [rbx+32]
	mov	rcx, QWORD PTR [rbx+40]
	call	rax
	test	eax, eax
	je	SHORT $LN35@stbi__skip

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN3@stbi__skip
$LN21@stbi__skip:

; 3394 :          if (stbi__at_eof(j->s)) return STBI__MARKER_none;

	mov	rax, QWORD PTR [rbx+200]
	cmp	QWORD PTR [rbx+192], rax
	jae	SHORT $LN3@stbi__skip
$LN35@stbi__skip:

; 3395 :          x = stbi__get8(j->s);

	mov	rbx, QWORD PTR [rdi]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN24@stbi__skip

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN23@stbi__skip
$LN24@stbi__skip:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN25@stbi__skip

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN23@stbi__skip
$LN25@stbi__skip:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN23@stbi__skip:

; 3395 :          x = stbi__get8(j->s);

	movzx	eax, cl

; 3396 :          if (x != 0x00 && x != 0xff) {

	test	cl, cl
	je	$LL2@stbi__skip
	cmp	eax, 255				; 000000ffH
	je	$LL4@stbi__skip

; 3397 :             // not a stuffed zero or lead-in to another marker, looks
; 3398 :             // like an actual marker, return it
; 3399 :             return x;
; 3400 :          }
; 3401 :          // stuffed zero has x=0 now which ends the loop, meaning we go
; 3402 :          // back to regular scan loop.
; 3403 :          // repeated 0xff keeps trying to read the next byte of the marker.
; 3404 :       }
; 3405 :    }
; 3406 :    return STBI__MARKER_none;
; 3407 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@stbi__skip:
	mov	rbx, QWORD PTR [rsp+48]
	mov	eax, 255				; 000000ffH
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__skip_jpeg_junk_at_end@@YAHPEAUstbi__jpeg@@@Z ENDP ; stbi__skip_jpeg_junk_at_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z
_TEXT	SEGMENT
j$ = 48
?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z PROC	; stbi__decode_jpeg_image, COMDAT

; 3411 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 3412 :    int m;
; 3413 :    for (m = 0; m < 4; m++) {
; 3414 :       j->img_comp[m].raw_data = NULL;

	xor	eax, eax

; 3415 :       j->img_comp[m].raw_coeff = NULL;
; 3416 :    }
; 3417 :    j->restart_interval = 0;
; 3418 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;

	xor	edx, edx
	mov	QWORD PTR [rcx+18136], rax
	mov	rdi, rcx
	mov	QWORD PTR [rcx+18144], rax
	mov	QWORD PTR [rcx+18232], rax
	mov	QWORD PTR [rcx+18240], rax
	mov	QWORD PTR [rcx+18328], rax
	mov	QWORD PTR [rcx+18336], rax
	mov	QWORD PTR [rcx+18424], rax
	mov	QWORD PTR [rcx+18432], rax
	mov	DWORD PTR [rcx+18536], eax
	call	?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z ; stbi__decode_jpeg_header
	test	eax, eax
	je	$LN58@stbi__deco

; 3419 :    m = stbi__get_marker(j);

	mov	rcx, rdi
	call	?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
	movzx	ecx, al

; 3420 :    while (!stbi__EOI(m)) {

	cmp	ecx, 217				; 000000d9H
	je	$LN79@stbi__deco
$LL5@stbi__deco:

; 3421 :       if (stbi__SOS(m)) {

	cmp	ecx, 218				; 000000daH
	jne	$LN8@stbi__deco

; 3422 :          if (!stbi__process_scan_header(j)) return 0;

	mov	rcx, rdi
	call	?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z ; stbi__process_scan_header
	test	eax, eax
	je	$LN58@stbi__deco

; 3423 :          if (!stbi__parse_entropy_coded_data(j)) return 0;

	mov	rcx, rdi
	call	?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z ; stbi__parse_entropy_coded_data
	test	eax, eax
	je	$LN58@stbi__deco

; 3424 :          if (j->marker == STBI__MARKER_none ) {

	cmp	BYTE PTR [rdi+18472], 255		; 000000ffH
	jne	$LN12@stbi__deco
	npad	4
$LL22@stbi__deco:

; 3391 :    while (!stbi__at_eof(j->s)) {

	mov	rbx, QWORD PTR [rdi]

; 1628 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], 0
	je	SHORT $LN32@stbi__deco

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	rax, QWORD PTR [rbx+32]
	mov	rcx, QWORD PTR [rbx+40]
	call	rax
	test	eax, eax
	je	SHORT $LN75@stbi__deco

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

	cmp	DWORD PTR [rbx+48], 0
	je	$LN23@stbi__deco
$LN32@stbi__deco:

; 3391 :    while (!stbi__at_eof(j->s)) {

	mov	rax, QWORD PTR [rbx+200]
	cmp	QWORD PTR [rbx+192], rax
	jae	$LN23@stbi__deco
$LN75@stbi__deco:

; 3392 :       int x = stbi__get8(j->s);

	mov	rbx, QWORD PTR [rdi]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN105@stbi__deco

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LL22@stbi__deco

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN105@stbi__deco:

; 3393 :       while (x == 255) { // might be a marker

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 255					; 000000ffH
	jne	SHORT $LL22@stbi__deco
$LL24@stbi__deco:

; 3394 :          if (stbi__at_eof(j->s)) return STBI__MARKER_none;

	mov	rbx, QWORD PTR [rdi]

; 1628 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], 0
	je	SHORT $LN41@stbi__deco

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	rax, QWORD PTR [rbx+32]
	mov	rcx, QWORD PTR [rbx+40]
	call	rax
	test	eax, eax
	je	SHORT $LN74@stbi__deco

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN23@stbi__deco
$LN41@stbi__deco:

; 3394 :          if (stbi__at_eof(j->s)) return STBI__MARKER_none;

	mov	rax, QWORD PTR [rbx+200]
	cmp	QWORD PTR [rbx+192], rax
	jae	SHORT $LN23@stbi__deco
$LN74@stbi__deco:

; 3395 :          x = stbi__get8(j->s);

	mov	rbx, QWORD PTR [rdi]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN44@stbi__deco

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN43@stbi__deco
$LN44@stbi__deco:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN45@stbi__deco

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN43@stbi__deco
$LN45@stbi__deco:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN43@stbi__deco:

; 3395 :          x = stbi__get8(j->s);

	movzx	eax, cl

; 3396 :          if (x != 0x00 && x != 0xff) {

	test	cl, cl
	je	$LL22@stbi__deco
	cmp	eax, 255				; 000000ffH
	je	$LL24@stbi__deco

; 3397 :             // not a stuffed zero or lead-in to another marker, looks
; 3398 :             // like an actual marker, return it
; 3399 :             return x;

	jmp	SHORT $LN21@stbi__deco
$LN23@stbi__deco:

; 3425 :          j->marker = stbi__skip_jpeg_junk_at_end(j);

	mov	eax, 255				; 000000ffH
$LN21@stbi__deco:
	mov	BYTE PTR [rdi+18472], al
$LN12@stbi__deco:

; 3426 :             // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
; 3427 :          }
; 3428 :          m = stbi__get_marker(j);

	mov	rcx, rdi
	call	?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
	movzx	ecx, al

; 3429 :          if (STBI__RESTART(m))

	lea	eax, DWORD PTR [rcx-208]
	cmp	eax, 7
	ja	SHORT $LN15@stbi__deco

; 3430 :             m = stbi__get_marker(j);

	jmp	SHORT $LN106@stbi__deco
$LN8@stbi__deco:

; 3431 :       } else if (stbi__DNL(m)) {

	cmp	ecx, 220				; 000000dcH
	jne	SHORT $LN14@stbi__deco

; 3432 :          int Ld = stbi__get16be(j->s);

	mov	rcx, QWORD PTR [rdi]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 3433 :          stbi__uint32 NL = stbi__get16be(j->s);

	mov	rcx, QWORD PTR [rdi]
	mov	ebx, eax
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 3434 :          if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");

	cmp	ebx, 4
	jne	SHORT $LN59@stbi__deco

; 3435 :          if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");

	mov	rcx, QWORD PTR [rdi]
	cmp	eax, DWORD PTR [rcx+4]
	je	SHORT $LN106@stbi__deco

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0P@PNCLKCLJ@bad?5DNL?5height@

; 3445 : }

	mov	QWORD PTR [rdx+rcx], rax
$LN58@stbi__deco:
	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN14@stbi__deco:

; 3436 :          m = stbi__get_marker(j);
; 3437 :       } else {
; 3438 :          if (!stbi__process_marker(j, m)) return 1;

	mov	edx, ecx
	mov	rcx, rdi
	call	?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z ; stbi__process_marker
	test	eax, eax
	je	SHORT $LN19@stbi__deco
$LN106@stbi__deco:

; 3420 :    while (!stbi__EOI(m)) {

	mov	rcx, rdi
	call	?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
	movzx	ecx, al
$LN15@stbi__deco:
	cmp	ecx, 217				; 000000d9H
	jne	$LL5@stbi__deco
$LN79@stbi__deco:

; 3439 :          m = stbi__get_marker(j);
; 3440 :       }
; 3441 :    }
; 3442 :    if (j->progressive)

	cmp	DWORD PTR [rdi+18480], 0
	je	SHORT $LN19@stbi__deco

; 3443 :       stbi__jpeg_finish(j);

	mov	rcx, rdi
	call	?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_finish
$LN19@stbi__deco:

; 3444 :    return 1;

	mov	eax, 1

; 3445 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN59@stbi__deco:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88

; 3445 : }

	mov	rbx, QWORD PTR [rsp+48]

; 978  :    stbi__g_failure_reason = str;

	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0M@EPMOIECP@bad?5DNL?5len@

; 3445 : }

	mov	QWORD PTR [rdx+rcx], rax
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z ENDP	; stbi__decode_jpeg_image
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?resample_row_1@@YAPEAEPEAE00HH@Z
_TEXT	SEGMENT
out$ = 8
in_near$ = 16
in_far$ = 24
w$ = 32
hs$ = 40
?resample_row_1@@YAPEAEPEAE00HH@Z PROC			; resample_row_1, COMDAT

; 3456 :    STBI_NOTUSED(out);
; 3457 :    STBI_NOTUSED(in_far);
; 3458 :    STBI_NOTUSED(w);
; 3459 :    STBI_NOTUSED(hs);
; 3460 :    return in_near;

	mov	rax, rdx

; 3461 : }

	ret	0
?resample_row_1@@YAPEAEPEAE00HH@Z ENDP			; resample_row_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z
_TEXT	SEGMENT
out$ = 16
in_near$ = 24
in_far$ = 32
w$ = 40
hs$ = 48
?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z PROC		; stbi__resample_row_v_2, COMDAT

; 3464 : {

	push	rbx

; 3465 :    // need to generate two samples vertically for every one in input
; 3466 :    int i;
; 3467 :    STBI_NOTUSED(hs);
; 3468 :    for (i=0; i < w; ++i)

	xor	ebx, ebx
	mov	r10, rdx
	mov	r11, rcx
	test	r9d, r9d
	jle	$LN9@stbi__resa
	cmp	r9d, 16
	jb	$LN9@stbi__resa
	cmp	DWORD PTR __isa_available, 2
	jl	$LN9@stbi__resa
	movsxd	rcx, r9d
	dec	rcx
	lea	rax, QWORD PTR [rcx+r8]
	lea	rdx, QWORD PTR [rcx+r11]
	cmp	r11, rax
	ja	SHORT $LN10@stbi__resa
	cmp	rdx, r8
	jae	$LN9@stbi__resa
$LN10@stbi__resa:
	lea	rax, QWORD PTR [rcx+r10]
	cmp	r11, rax
	ja	SHORT $LN11@stbi__resa
	cmp	rdx, r10
	jae	$LN9@stbi__resa
$LN11@stbi__resa:
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	mov	QWORD PTR [rsp+32], r14

; 3469 :       out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);

	movdqa	xmm3, XMMWORD PTR __xmm@00000003000000030000000300000003
	lea	rdi, QWORD PTR [r8+4]
	movdqa	xmm4, XMMWORD PTR __xmm@00000002000000020000000200000002
	mov	eax, 2
	movsxd	rsi, r9d
	mov	rcx, r10
	mov	rdx, r11
	and	rsi, -16
	sub	rcx, r8
	sub	rdx, r8
	mov	r14, -4
	movd	xmm5, eax
	sub	r14, r8
$LL4@stbi__resa:
	pmovzxbd xmm1, DWORD PTR [rdi-4]
	pmovzxbd xmm2, DWORD PTR [rcx+rdi-4]
	pmulld	xmm2, xmm3
	paddd	xmm2, xmm1
	lea	rdi, QWORD PTR [rdi+16]
	paddd	xmm2, xmm4
	lea	rax, QWORD PTR [r14+rdi]
	psrad	xmm2, xmm5
	add	ebx, 16
	pshuflw	xmm0, xmm2, 216				; 000000d8H
	pshufhw	xmm1, xmm0, 216				; 000000d8H
	pshufd	xmm2, xmm1, 216				; 000000d8H
	andps	xmm2, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	packuswb xmm2, xmm2
	movd	DWORD PTR [rdx+rdi-20], xmm2
	pmovzxbd xmm1, DWORD PTR [rdi-16]
	pmovzxbd xmm2, DWORD PTR [rdi+rcx-16]
	pmulld	xmm2, xmm3
	paddd	xmm2, xmm1
	paddd	xmm2, xmm4
	psrad	xmm2, xmm5
	pshuflw	xmm0, xmm2, 216				; 000000d8H
	pshufhw	xmm1, xmm0, 216				; 000000d8H
	pshufd	xmm2, xmm1, 216				; 000000d8H
	andps	xmm2, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	packuswb xmm2, xmm2
	movd	DWORD PTR [rdi+rdx-16], xmm2
	pmovzxbd xmm1, DWORD PTR [rdi-12]
	pmovzxbd xmm2, DWORD PTR [rcx+rdi-12]
	pmulld	xmm2, xmm3
	paddd	xmm2, xmm1
	paddd	xmm2, xmm4
	psrad	xmm2, xmm5
	pshuflw	xmm0, xmm2, 216				; 000000d8H
	pshufhw	xmm1, xmm0, 216				; 000000d8H
	pshufd	xmm2, xmm1, 216				; 000000d8H
	andps	xmm2, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	packuswb xmm2, xmm2
	movd	DWORD PTR [rdx+rdi-12], xmm2
	pmovzxbd xmm1, DWORD PTR [rdi-8]
	pmovzxbd xmm2, DWORD PTR [rcx+rdi-8]
	pmulld	xmm2, xmm3
	paddd	xmm2, xmm1
	paddd	xmm2, xmm4
	psrad	xmm2, xmm5
	pshuflw	xmm0, xmm2, 216				; 000000d8H
	pshufhw	xmm1, xmm0, 216				; 000000d8H
	pshufd	xmm2, xmm1, 216				; 000000d8H
	andps	xmm2, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	packuswb xmm2, xmm2
	movd	DWORD PTR [rdx+rdi-8], xmm2
	cmp	rax, rsi
	jl	$LL4@stbi__resa

; 3465 :    // need to generate two samples vertically for every one in input
; 3466 :    int i;
; 3467 :    STBI_NOTUSED(hs);
; 3468 :    for (i=0; i < w; ++i)

	mov	r14, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+24]
	mov	rsi, QWORD PTR [rsp+16]
$LN9@stbi__resa:
	movsxd	rcx, ebx
	movsxd	r9, r9d
	cmp	rcx, r9
	jge	SHORT $LN19@stbi__resa
	mov	rbx, r11
	lea	rax, QWORD PTR [rcx+r8]
	sub	rbx, r8
	sub	r10, r8
	sub	r9, rcx
	npad	9
$LL8@stbi__resa:

; 3469 :       out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);

	movzx	ecx, BYTE PTR [r10+rax]
	movzx	r8d, BYTE PTR [rax]
	lea	rax, QWORD PTR [rax+1]
	add	r8d, 2
	lea	edx, DWORD PTR [rcx+rcx*2]
	add	r8d, edx
	shr	r8d, 2
	mov	BYTE PTR [rbx+rax-1], r8b
	sub	r9, 1
	jne	SHORT $LL8@stbi__resa
$LN19@stbi__resa:

; 3470 :    return out;
; 3471 : }

	mov	rax, r11
	pop	rbx
	ret	0
?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z ENDP		; stbi__resample_row_v_2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z
_TEXT	SEGMENT
out$ = 16
in_near$ = 24
in_far$ = 32
w$ = 40
hs$ = 48
?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z PROC		; stbi__resample_row_h_2, COMDAT

; 3474 : {

	sub	rsp, 8

; 3475 :    // need to generate two samples horizontally for every one in input
; 3476 :    int i;
; 3477 :    stbi_uc *input = in_near;

	movzx	eax, BYTE PTR [rdx]
	mov	r11, rdx
	mov	BYTE PTR [rcx], al
	mov	r10, rcx

; 3478 : 
; 3479 :    if (w == 1) {

	cmp	r9d, 1
	jne	SHORT $LN5@stbi__resa

; 3480 :       // if only one sample, can't do any interpolation
; 3481 :       out[0] = out[1] = input[0];

	mov	BYTE PTR [rcx+1], al

; 3499 : }

	mov	rax, rcx
	add	rsp, 8
	ret	0
$LN5@stbi__resa:

; 3482 :       return out;
; 3483 :    }
; 3484 : 
; 3485 :    out[0] = input[0];
; 3486 :    out[1] = stbi__div4(input[0]*3 + input[1] + 2);

	movzx	eax, BYTE PTR [rdx]
	movzx	edx, BYTE PTR [rdx+1]
	mov	QWORD PTR [rsp+16], rbx
	add	edx, 2
	mov	QWORD PTR [rsp+24], rsi

; 3487 :    for (i=1; i < w-1; ++i) {

	movsxd	rsi, r9d
	lea	ecx, DWORD PTR [rax+rax*2]
	add	edx, ecx
	mov	QWORD PTR [rsp], rdi
	shr	edx, 2
	mov	edi, 1
	mov	BYTE PTR [r10+1], dl
	lea	rbx, QWORD PTR [rsi-1]
	cmp	rbx, rdi
	jle	SHORT $LN3@stbi__resa
	lea	r9, QWORD PTR [rbx-1]
	lea	edi, DWORD PTR [r9+1]
	lea	r8, QWORD PTR [r10+2]
	lea	rdx, QWORD PTR [r11+2]
	npad	11
$LL4@stbi__resa:

; 3488 :       int n = 3*input[i]+2;

	movzx	eax, BYTE PTR [rdx-1]
	lea	r8, QWORD PTR [r8+2]
	lea	rdx, QWORD PTR [rdx+1]
	lea	ecx, DWORD PTR [rax+1]
	lea	ecx, DWORD PTR [rax+rcx*2]

; 3489 :       out[i*2+0] = stbi__div4(n+input[i-1]);

	movzx	eax, BYTE PTR [rdx-3]
	add	eax, ecx
	shr	eax, 2
	mov	BYTE PTR [r8-2], al

; 3490 :       out[i*2+1] = stbi__div4(n+input[i+1]);

	movzx	eax, BYTE PTR [rdx-1]
	add	eax, ecx
	shr	eax, 2
	mov	BYTE PTR [r8-1], al
	sub	r9, 1
	jne	SHORT $LL4@stbi__resa
$LN3@stbi__resa:

; 3491 :    }
; 3492 :    out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);

	movzx	edx, BYTE PTR [rbx+r11]
	lea	eax, DWORD PTR [rdi+rdi]

; 3493 :    out[i*2+1] = input[w-1];
; 3494 : 
; 3495 :    STBI_NOTUSED(in_far);
; 3496 :    STBI_NOTUSED(hs);
; 3497 : 
; 3498 :    return out;

	mov	rdi, QWORD PTR [rsp]
	add	edx, 2
	movsxd	r8, eax
	movzx	eax, BYTE PTR [rsi+r11-2]
	mov	rsi, QWORD PTR [rsp+24]
	lea	ecx, DWORD PTR [rax+rax*2]
	add	edx, ecx
	shr	edx, 2
	mov	BYTE PTR [r8+r10], dl
	movzx	eax, BYTE PTR [rbx+r11]
	mov	rbx, QWORD PTR [rsp+16]
	mov	BYTE PTR [r8+r10+1], al

; 3499 : }

	mov	rax, r10
	add	rsp, 8
	ret	0
?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z ENDP		; stbi__resample_row_h_2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z
_TEXT	SEGMENT
out$ = 16
in_near$ = 24
in_far$ = 32
w$ = 40
hs$ = 48
?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z PROC		; stbi__resample_row_hv_2, COMDAT

; 3504 : {

	mov	QWORD PTR [rsp+16], rbx
	push	rsi
	movzx	eax, BYTE PTR [rdx]
	mov	rbx, rdx
	movzx	r10d, BYTE PTR [r8]
	mov	r11, rcx
	movsxd	rsi, r9d
	lea	eax, DWORD PTR [rax+rax*2]
	add	eax, r10d

; 3505 :    // need to generate 2x2 samples for every one in input
; 3506 :    int i,t0,t1;
; 3507 :    if (w == 1) {

	cmp	esi, 1
	jne	SHORT $LN5@stbi__resa

; 3508 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);

	add	eax, 2
	shr	eax, 2
	mov	BYTE PTR [rcx+1], al
	mov	BYTE PTR [rcx], al

; 3525 : }

	mov	rax, rcx
	mov	rbx, QWORD PTR [rsp+24]
	pop	rsi
	ret	0
$LN5@stbi__resa:

; 3509 :       return out;
; 3510 :    }
; 3511 : 
; 3512 :    t1 = 3*in_near[0] + in_far[0];
; 3513 :    out[0] = stbi__div4(t1+2);

	lea	ecx, DWORD PTR [rax+2]
	mov	QWORD PTR [rsp+16], rdi
	shr	ecx, 2

; 3514 :    for (i=1; i < w; ++i) {

	mov	rdi, rsi
	mov	BYTE PTR [r11], cl
	cmp	rsi, 1
	jle	SHORT $LN3@stbi__resa
	sub	rbx, r8
	lea	r9, QWORD PTR [r8+1]
	dec	rdi
	lea	r10, QWORD PTR [r11+2]
	npad	5
$LL4@stbi__resa:

; 3515 :       t0 = t1;
; 3516 :       t1 = 3*in_near[i]+in_far[i];

	movzx	ecx, BYTE PTR [r9]
	lea	r10, QWORD PTR [r10+2]
	mov	r8d, eax
	movzx	eax, BYTE PTR [rbx+r9]
	lea	r9, QWORD PTR [r9+1]
	lea	eax, DWORD PTR [rax+rax*2]
	add	eax, ecx

; 3517 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);

	lea	edx, DWORD PTR [r8+4]
	lea	edx, DWORD PTR [rax+rdx*2]
	add	edx, r8d
	shr	edx, 4
	mov	BYTE PTR [r10-3], dl

; 3518 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);

	lea	edx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [r8+rdx*2]
	add	edx, eax
	shr	edx, 4
	mov	BYTE PTR [r10-2], dl
	sub	rdi, 1
	jne	SHORT $LL4@stbi__resa
$LN3@stbi__resa:

; 3519 :    }
; 3520 :    out[w*2-1] = stbi__div4(t1+2);
; 3521 : 
; 3522 :    STBI_NOTUSED(hs);
; 3523 : 
; 3524 :    return out;

	mov	rdi, QWORD PTR [rsp+16]
	lea	edx, DWORD PTR [rax+2]

; 3525 : }

	mov	rbx, QWORD PTR [rsp+24]
	lea	eax, DWORD PTR [rsi+rsi]
	movsxd	rcx, eax
	mov	rax, r11
	shr	edx, 2
	mov	BYTE PTR [rcx+r11-1], dl
	pop	rsi
	ret	0
?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z ENDP		; stbi__resample_row_hv_2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z
_TEXT	SEGMENT
out$ = 24
in_near$ = 32
in_far$ = 40
w$ = 48
hs$ = 56
?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z PROC	; stbi__resample_row_hv_2_simd, COMDAT

; 3529 : {

	push	rsi
	push	rdi

; 3530 :    // need to generate 2x2 samples for every one in input
; 3531 :    int i=0,t0,t1;

	movzx	eax, BYTE PTR [rdx]
	mov	r10, r8
	movsxd	rsi, r9d
	mov	rdi, rcx
	xor	r9d, r9d
	lea	r8d, DWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR [r10]
	add	r8d, eax

; 3532 : 
; 3533 :    if (w == 1) {

	cmp	esi, 1
	jne	SHORT $LN8@stbi__resa

; 3534 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);

	lea	eax, DWORD PTR [r8+2]
	shr	eax, 2
	mov	BYTE PTR [rcx+1], al
	mov	BYTE PTR [rcx], al

; 3641 : }

	mov	rax, rcx
	pop	rdi
	pop	rsi
	ret	0
$LN8@stbi__resa:
	mov	QWORD PTR [rsp+24], rbx

; 3535 :       return out;
; 3536 :    }
; 3537 : 
; 3538 :    t1 = 3*in_near[0] + in_far[0];
; 3539 :    // process groups of 8 pixels for as long as we can.
; 3540 :    // note we can't handle the last pixel in a row in this loop
; 3541 :    // because we need to handle the filter boundary conditions.
; 3542 :    for (; i < ((w-1) & ~7); i += 8) {

	lea	eax, DWORD PTR [rsi-1]
	mov	rbx, rdx
	and	eax, -8
	sub	rbx, r10
	test	eax, eax
	jle	$LN18@stbi__resa

; 3543 : #if defined(STBI_SSE2)
; 3544 :       // load and perform the vertical filtering pass
; 3545 :       // this uses 3*x + y = 4*x + (y - x)
; 3546 :       __m128i zero  = _mm_setzero_si128();

	movdqa	xmm5, XMMWORD PTR __xmm@00080008000800080008000800080008
	lea	r11, QWORD PTR [r10+8]
	mov	QWORD PTR [rsp+32], rbp
	dec	eax
	mov	QWORD PTR [rsp+40], r14
	xorps	xmm4, xmm4
	shr	eax, 3
	mov	r14, rdi
	inc	eax
	mov	QWORD PTR [rsp+48], r15
	mov	rbp, r10
	mov	r15d, eax
	lea	r9d, DWORD PTR [rax*8]
	npad	13
$LL4@stbi__resa:

; 3547 :       __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
; 3548 :       __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
; 3549 :       __m128i farw  = _mm_unpacklo_epi8(farb, zero);
; 3550 :       __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
; 3551 :       __m128i diff  = _mm_sub_epi16(farw, nearw);
; 3552 :       __m128i nears = _mm_slli_epi16(nearw, 2);
; 3553 :       __m128i curr  = _mm_add_epi16(nears, diff); // current row
; 3554 : 
; 3555 :       // horizontal filter works the same based on shifted vers of current
; 3556 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3557 :       // insert the previous pixel value (from t1).
; 3558 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3559 :       // of next block of 8 pixels added in.
; 3560 :       __m128i prv0 = _mm_slli_si128(curr, 2);
; 3561 :       __m128i nxt0 = _mm_srli_si128(curr, 2);
; 3562 :       __m128i prev = _mm_insert_epi16(prv0, t1, 0);
; 3563 :       __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

	movzx	eax, BYTE PTR [r11+rbx]
	lea	r14, QWORD PTR [r14+16]
	movq	xmm0, QWORD PTR [rbx+rbp]
	lea	r11, QWORD PTR [r11+8]
	movq	xmm3, QWORD PTR [rbp]
	lea	rbp, QWORD PTR [rbp+8]
	punpcklbw xmm0, xmm4
	lea	ecx, DWORD PTR [rax+rax*2]
	punpcklbw xmm3, xmm4
	movzx	eax, BYTE PTR [r11-8]
	psubw	xmm3, xmm0
	psllw	xmm0, 2
	add	ecx, eax
	paddw	xmm3, xmm0
	movdqa	xmm2, xmm3
	movdqa	xmm1, xmm3
	pslldq	xmm2, 2

; 3564 : 
; 3565 :       // horizontal filter, polyphase implementation since it's convenient:
; 3566 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3567 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3568 :       // note the shared term.
; 3569 :       __m128i bias  = _mm_set1_epi16(8);
; 3570 :       __m128i curs = _mm_slli_epi16(curr, 2);

	movdqa	xmm0, xmm3
	pinsrw	xmm2, r8d, 0
	psllw	xmm0, 2

; 3571 :       __m128i prvd = _mm_sub_epi16(prev, curr);

	psubw	xmm2, xmm3

; 3572 :       __m128i nxtd = _mm_sub_epi16(next, curr);
; 3573 :       __m128i curb = _mm_add_epi16(curs, bias);

	paddw	xmm0, xmm5
	psrldq	xmm1, 2

; 3574 :       __m128i even = _mm_add_epi16(prvd, curb);

	paddw	xmm2, xmm0
	pinsrw	xmm1, ecx, 7
	psubw	xmm1, xmm3

; 3575 :       __m128i odd  = _mm_add_epi16(nxtd, curb);

	paddw	xmm1, xmm0

; 3576 : 
; 3577 :       // interleave even and odd pixels, then undo scaling.
; 3578 :       __m128i int0 = _mm_unpacklo_epi16(even, odd);

	movdqa	xmm0, xmm2
	punpcklwd xmm0, xmm1

; 3579 :       __m128i int1 = _mm_unpackhi_epi16(even, odd);

	punpckhwd xmm2, xmm1

; 3580 :       __m128i de0  = _mm_srli_epi16(int0, 4);

	psrlw	xmm0, 4

; 3581 :       __m128i de1  = _mm_srli_epi16(int1, 4);

	psrlw	xmm2, 4

; 3582 : 
; 3583 :       // pack and write output
; 3584 :       __m128i outv = _mm_packus_epi16(de0, de1);

	packuswb xmm0, xmm2

; 3585 :       _mm_storeu_si128((__m128i *) (out + i*2), outv);

	movdqu	XMMWORD PTR [r14-16], xmm0

; 3586 : #elif defined(STBI_NEON)
; 3587 :       // load and perform the vertical filtering pass
; 3588 :       // this uses 3*x + y = 4*x + (y - x)
; 3589 :       uint8x8_t farb  = vld1_u8(in_far + i);
; 3590 :       uint8x8_t nearb = vld1_u8(in_near + i);
; 3591 :       int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
; 3592 :       int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
; 3593 :       int16x8_t curr  = vaddq_s16(nears, diff); // current row
; 3594 : 
; 3595 :       // horizontal filter works the same based on shifted vers of current
; 3596 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3597 :       // insert the previous pixel value (from t1).
; 3598 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3599 :       // of next block of 8 pixels added in.
; 3600 :       int16x8_t prv0 = vextq_s16(curr, curr, 7);
; 3601 :       int16x8_t nxt0 = vextq_s16(curr, curr, 1);
; 3602 :       int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
; 3603 :       int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);
; 3604 : 
; 3605 :       // horizontal filter, polyphase implementation since it's convenient:
; 3606 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3607 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3608 :       // note the shared term.
; 3609 :       int16x8_t curs = vshlq_n_s16(curr, 2);
; 3610 :       int16x8_t prvd = vsubq_s16(prev, curr);
; 3611 :       int16x8_t nxtd = vsubq_s16(next, curr);
; 3612 :       int16x8_t even = vaddq_s16(curs, prvd);
; 3613 :       int16x8_t odd  = vaddq_s16(curs, nxtd);
; 3614 : 
; 3615 :       // undo scaling and round, then store with even/odd phases interleaved
; 3616 :       uint8x8x2_t o;
; 3617 :       o.val[0] = vqrshrun_n_s16(even, 4);
; 3618 :       o.val[1] = vqrshrun_n_s16(odd,  4);
; 3619 :       vst2_u8(out + i*2, o);
; 3620 : #endif
; 3621 : 
; 3622 :       // "previous" value for next iter
; 3623 :       t1 = 3*in_near[i+7] + in_far[i+7];

	movzx	eax, BYTE PTR [rbx+r11-9]
	lea	r8d, DWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR [r11-9]
	add	r8d, eax
	sub	r15, 1
	jne	$LL4@stbi__resa
	mov	r15, QWORD PTR [rsp+48]
	mov	r14, QWORD PTR [rsp+40]
	mov	rbp, QWORD PTR [rsp+32]
$LN18@stbi__resa:

; 3627 :    t1 = 3*in_near[i] + in_far[i];

	movsxd	rcx, r9d

; 3628 :    out[i*2] = stbi__div16(3*t1 + t0 + 8);
; 3629 : 
; 3630 :    for (++i; i < w; ++i) {

	mov	r11, rsi
	movzx	eax, BYTE PTR [rcx+rdx]
	movzx	ecx, BYTE PTR [rcx+r10]
	lea	eax, DWORD PTR [rax+rax*2]
	add	eax, ecx
	lea	ecx, DWORD PTR [r9+r9]
	movsxd	rdx, ecx
	lea	ecx, DWORD PTR [r9+1]
	lea	r8d, DWORD PTR [r8+rax*2]
	add	r8d, 8
	add	r8d, eax
	shr	r8d, 4
	mov	BYTE PTR [rdx+rdi], r8b
	movsxd	rdx, ecx
	cmp	rdx, rsi
	jge	SHORT $LN6@stbi__resa

; 3624 :    }
; 3625 : 
; 3626 :    t0 = t1;

	lea	r9, QWORD PTR [rdx+r10]
	sub	r11, rdx
	lea	r10, QWORD PTR [rdi+rdx*2]
	npad	12
$LL7@stbi__resa:

; 3631 :       t0 = t1;
; 3632 :       t1 = 3*in_near[i]+in_far[i];

	movzx	ecx, BYTE PTR [r9]
	lea	r10, QWORD PTR [r10+2]
	mov	r8d, eax
	movzx	eax, BYTE PTR [rbx+r9]
	lea	r9, QWORD PTR [r9+1]
	lea	eax, DWORD PTR [rax+rax*2]
	add	eax, ecx

; 3633 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);

	lea	edx, DWORD PTR [r8+4]
	lea	edx, DWORD PTR [rax+rdx*2]
	add	edx, r8d
	shr	edx, 4
	mov	BYTE PTR [r10-3], dl

; 3634 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);

	lea	edx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [r8+rdx*2]
	add	edx, eax
	shr	edx, 4
	mov	BYTE PTR [r10-2], dl
	sub	r11, 1
	jne	SHORT $LL7@stbi__resa
$LN6@stbi__resa:

; 3635 :    }
; 3636 :    out[w*2-1] = stbi__div4(t1+2);
; 3637 : 
; 3638 :    STBI_NOTUSED(hs);
; 3639 : 
; 3640 :    return out;

	mov	rbx, QWORD PTR [rsp+24]
	lea	edx, DWORD PTR [rax+2]
	lea	eax, DWORD PTR [rsi+rsi]
	shr	edx, 2
	movsxd	rcx, eax

; 3641 : }

	mov	rax, rdi
	mov	BYTE PTR [rcx+rdi-1], dl
	pop	rdi
	pop	rsi
	ret	0
?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z ENDP	; stbi__resample_row_hv_2_simd
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z
_TEXT	SEGMENT
out$ = 8
in_near$ = 16
in_far$ = 24
w$ = 32
hs$ = 40
?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z PROC	; stbi__resample_row_generic, COMDAT

; 3645 : {

	mov	r11, rcx

; 3646 :    // resample with nearest-neighbor
; 3647 :    int i,j;
; 3648 :    STBI_NOTUSED(in_far);
; 3649 :    for (i=0; i < w; ++i)

	test	r9d, r9d
	jle	SHORT $LN17@stbi__resa
	movsxd	r8, DWORD PTR hs$[rsp]
	mov	r10, rcx
	mov	r9d, r9d
$LL4@stbi__resa:

; 3650 :       for (j=0; j < hs; ++j)

	test	r8, r8
	jle	SHORT $LN2@stbi__resa

; 3651 :          out[i*hs+j] = in_near[i];

	xor	eax, eax
	npad	6
$LL7@stbi__resa:
	movzx	ecx, BYTE PTR [rdx]
	mov	BYTE PTR [r10+rax], cl
	inc	rax
	cmp	rax, r8
	jl	SHORT $LL7@stbi__resa
$LN2@stbi__resa:

; 3646 :    // resample with nearest-neighbor
; 3647 :    int i,j;
; 3648 :    STBI_NOTUSED(in_far);
; 3649 :    for (i=0; i < w; ++i)

	add	r10, r8
	inc	rdx
	sub	r9, 1
	jne	SHORT $LL4@stbi__resa
$LN17@stbi__resa:

; 3652 :    return out;
; 3653 : }

	mov	rax, r11
	ret	0
?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z ENDP	; stbi__resample_row_generic
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z
_TEXT	SEGMENT
out$ = 24
y$ = 32
pcb$ = 40
pcr$ = 48
count$ = 56
step$ = 64
?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z PROC		; stbi__YCbCr_to_RGB_row, COMDAT

; 3659 : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rdi
	push	r14

; 3660 :    int i;
; 3661 :    for (i=0; i < count; ++i) {

	movsxd	rdi, DWORD PTR count$[rsp]
	mov	rbx, r9
	mov	rbp, r8
	mov	r14, rdx
	test	rdi, rdi
	jle	$LN3@stbi__YCbC
	mov	QWORD PTR [rsp+24], rsi
	lea	rax, QWORD PTR [rcx+2]
	movsxd	rsi, DWORD PTR step$[rsp]
	sub	r14, rbx

; 3662 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding

	sub	rbp, rbx
	mov	QWORD PTR [rsp+32], r15
	xor	r15d, r15d
$LL4@stbi__YCbC:

; 3663 :       int r,g,b;
; 3664 :       int cr = pcr[i] - 128;

	movzx	r8d, BYTE PTR [rbx]

; 3665 :       int cb = pcb[i] - 128;

	movzx	r9d, BYTE PTR [rbx+rbp]
	movzx	r10d, BYTE PTR [r14+rbx]
	shl	r10d, 20

; 3666 :       r = y_fixed +  cr* stbi__float2fixed(1.40200f);

	lea	ecx, DWORD PTR [r8-128]
	add	r10d, 524288				; 00080000H
	imul	r11d, ecx, 1470208			; 00166f00H

; 3667 :       g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);

	mov	ecx, 128				; 00000080H
	sub	ecx, r9d
	imul	edx, ecx, 360960			; 00058200H
	mov	ecx, 128				; 00000080H
	sub	ecx, r8d
	imul	r8d, ecx, 748800			; 000b6d00H
	add	r11d, r10d

; 3668 :       b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
; 3669 :       r >>= 20;

	sar	r11d, 20
	and	edx, -65536				; ffffffffffff0000H
	lea	ecx, DWORD PTR [r10+rdx]
	add	r8d, ecx
	lea	ecx, DWORD PTR [r9-128]
	imul	edx, ecx, 1858048			; 001c5a00H

; 3670 :       g >>= 20;

	sar	r8d, 20
	add	edx, r10d

; 3671 :       b >>= 20;

	sar	edx, 20

; 3672 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }

	cmp	r11d, 255				; 000000ffH
	jbe	SHORT $LN6@stbi__YCbC
	test	r11d, r11d
	mov	ecx, 255				; 000000ffH
	cmovs	ecx, r15d
	mov	r11d, ecx
$LN6@stbi__YCbC:

; 3673 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }

	cmp	r8d, 255				; 000000ffH
	jbe	SHORT $LN9@stbi__YCbC
	test	r8d, r8d
	mov	ecx, 255				; 000000ffH
	cmovs	ecx, r15d
	mov	r8d, ecx
$LN9@stbi__YCbC:

; 3674 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }

	cmp	edx, 255				; 000000ffH
	jbe	SHORT $LN12@stbi__YCbC
	test	edx, edx
	mov	ecx, 255				; 000000ffH
	cmovs	ecx, r15d
	mov	edx, ecx
$LN12@stbi__YCbC:

; 3675 :       out[0] = (stbi_uc)r;

	mov	BYTE PTR [rax-2], r11b
	inc	rbx

; 3676 :       out[1] = (stbi_uc)g;

	mov	BYTE PTR [rax-1], r8b

; 3677 :       out[2] = (stbi_uc)b;

	mov	BYTE PTR [rax], dl

; 3678 :       out[3] = 255;

	mov	BYTE PTR [rax+1], 255			; 000000ffH

; 3679 :       out += step;

	add	rax, rsi
	sub	rdi, 1
	jne	$LL4@stbi__YCbC

; 3660 :    int i;
; 3661 :    for (i=0; i < count; ++i) {

	mov	r15, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+24]
$LN3@stbi__YCbC:

; 3680 :    }
; 3681 : }

	mov	rbx, QWORD PTR [rsp+40]
	mov	rbp, QWORD PTR [rsp+48]
	pop	r14
	pop	rdi
	ret	0
?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z ENDP		; stbi__YCbCr_to_RGB_row
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
_TEXT	SEGMENT
out$ = 128
y$ = 136
pcb$ = 144
pcr$ = 152
count$ = 160
step$ = 168
?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z PROC	; stbi__YCbCr_to_RGB_simd, COMDAT

; 3685 : {

	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r15
	sub	rsp, 96					; 00000060H

; 3686 :    int i = 0;
; 3687 : 
; 3688 : #ifdef STBI_SSE2
; 3689 :    // step == 3 is pretty ugly on the final interleave, and i'm not convinced
; 3690 :    // it's useful in practice (you wouldn't use it for textures, for example).
; 3691 :    // so just accelerate step == 4 case.
; 3692 :    if (step == 4) {

	movsxd	r10, DWORD PTR step$[rsp]
	xor	r15d, r15d
	mov	rsi, r8
	mov	rbp, rdx
	movsxd	rdx, DWORD PTR count$[rsp]
	mov	r8d, r15d
	cmp	r10d, 4
	jne	$LN3@stbi__YCbC

; 3693 :       // this is a fairly straightforward implementation and not super-optimized.
; 3694 :       __m128i signflip  = _mm_set1_epi8(-0x80);

	movdqa	xmm5, XMMWORD PTR __xmm@80808080808080808080808080808080
	movaps	XMMWORD PTR [rsp+64], xmm7

; 3695 :       __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));

	movdqa	xmm7, XMMWORD PTR __xmm@166f166f166f166f166f166f166f166f
	movaps	XMMWORD PTR [rsp+48], xmm8

; 3696 :       __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));

	movdqa	xmm8, XMMWORD PTR __xmm@f493f493f493f493f493f493f493f493
	movaps	XMMWORD PTR [rsp+32], xmm9

; 3697 :       __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));

	movdqa	xmm9, XMMWORD PTR __xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
	movaps	XMMWORD PTR [rsp+16], xmm10

; 3698 :       __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));

	movdqa	xmm10, XMMWORD PTR __xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
	movaps	XMMWORD PTR [rsp], xmm11

; 3699 :       __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
; 3700 :       __m128i xw = _mm_set1_epi16(255); // alpha channel

	movdqa	xmm11, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff

; 3701 : 
; 3702 :       for (; i+7 < count; i += 8) {

	cmp	edx, 7
	jle	$LN37@stbi__YCbC
	movaps	XMMWORD PTR [rsp+80], xmm6
	xorps	xmm6, xmm6
	npad	12
$LL4@stbi__YCbC:

; 3703 :          // load
; 3704 :          __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
; 3705 :          __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));

	movsxd	rax, r8d

; 3706 :          __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
; 3707 :          __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
; 3708 :          __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128
; 3709 : 
; 3710 :          // unpack to short (and left-shift cr, cb by 8)
; 3711 :          __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
; 3712 :          __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);

	movdqa	xmm2, xmm6
	add	r8d, 8

; 3713 :          __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

	movdqa	xmm4, xmm6
	movdqa	xmm1, xmm5
	movq	xmm0, QWORD PTR [rax+r9]
	xorps	xmm0, xmm5
	punpcklbw xmm2, xmm0
	movq	xmm0, QWORD PTR [rax+rsi]

; 3714 : 
; 3715 :          // color transform
; 3716 :          __m128i yws = _mm_srli_epi16(yw, 4);
; 3717 :          __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);

	movdqa	xmm3, xmm2
	xorps	xmm0, xmm5
	pmulhw	xmm3, xmm7
	punpcklbw xmm4, xmm0
	movq	xmm0, QWORD PTR [rax+rbp]
	lea	eax, DWORD PTR [r8+7]
	punpcklbw xmm1, xmm0

; 3718 :          __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
; 3719 :          __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);

	movdqa	xmm0, xmm4
	psrlw	xmm1, 4

; 3720 :          __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
; 3721 :          __m128i rws = _mm_add_epi16(cr0, yws);

	paddw	xmm3, xmm1
	pmulhw	xmm0, xmm10
	pmulhw	xmm4, xmm9

; 3722 :          __m128i gwt = _mm_add_epi16(cb0, yws);
; 3723 :          __m128i bws = _mm_add_epi16(yws, cb1);
; 3724 :          __m128i gws = _mm_add_epi16(gwt, cr1);
; 3725 : 
; 3726 :          // descale
; 3727 :          __m128i rw = _mm_srai_epi16(rws, 4);

	psraw	xmm3, 4
	pmulhw	xmm2, xmm8
	paddw	xmm0, xmm1
	paddw	xmm4, xmm1

; 3728 :          __m128i bw = _mm_srai_epi16(bws, 4);

	psraw	xmm0, 4

; 3729 :          __m128i gw = _mm_srai_epi16(gws, 4);
; 3730 : 
; 3731 :          // back to byte, set up for transpose
; 3732 :          __m128i brb = _mm_packus_epi16(rw, bw);

	packuswb xmm3, xmm0
	paddw	xmm4, xmm2

; 3733 :          __m128i gxb = _mm_packus_epi16(gw, xw);
; 3734 : 
; 3735 :          // transpose to interleave channels
; 3736 :          __m128i t0 = _mm_unpacklo_epi8(brb, gxb);

	movdqa	xmm1, xmm3
	psraw	xmm4, 4
	packuswb xmm4, xmm11
	punpcklbw xmm1, xmm4

; 3737 :          __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
; 3738 :          __m128i o0 = _mm_unpacklo_epi16(t0, t1);

	movdqa	xmm0, xmm1
	punpckhbw xmm3, xmm4
	punpcklwd xmm0, xmm3

; 3739 :          __m128i o1 = _mm_unpackhi_epi16(t0, t1);

	punpckhwd xmm1, xmm3

; 3740 : 
; 3741 :          // store
; 3742 :          _mm_storeu_si128((__m128i *) (out + 0), o0);

	movdqu	XMMWORD PTR [rcx], xmm0

; 3743 :          _mm_storeu_si128((__m128i *) (out + 16), o1);

	movdqu	XMMWORD PTR [rcx+16], xmm1

; 3744 :          out += 32;

	add	rcx, 32					; 00000020H
	cmp	eax, edx
	jl	$LL4@stbi__YCbC

; 3701 : 
; 3702 :       for (; i+7 < count; i += 8) {

	movaps	xmm6, XMMWORD PTR [rsp+80]
$LN37@stbi__YCbC:
	movaps	xmm10, XMMWORD PTR [rsp+16]
	movaps	xmm9, XMMWORD PTR [rsp+32]
	movaps	xmm8, XMMWORD PTR [rsp+48]
	movaps	xmm7, XMMWORD PTR [rsp+64]
	movaps	xmm11, XMMWORD PTR [rsp]
$LN3@stbi__YCbC:

; 3745 :       }
; 3746 :    }
; 3747 : #endif
; 3748 : 
; 3749 : #ifdef STBI_NEON
; 3750 :    // in this version, step=3 support would be easy to add. but is there demand?
; 3751 :    if (step == 4) {
; 3752 :       // this is a fairly straightforward implementation and not super-optimized.
; 3753 :       uint8x8_t signflip = vdup_n_u8(0x80);
; 3754 :       int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3755 :       int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3756 :       int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3757 :       int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3758 : 
; 3759 :       for (; i+7 < count; i += 8) {
; 3760 :          // load
; 3761 :          uint8x8_t y_bytes  = vld1_u8(y + i);
; 3762 :          uint8x8_t cr_bytes = vld1_u8(pcr + i);
; 3763 :          uint8x8_t cb_bytes = vld1_u8(pcb + i);
; 3764 :          int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
; 3765 :          int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
; 3766 : 
; 3767 :          // expand to s16
; 3768 :          int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
; 3769 :          int16x8_t crw = vshll_n_s8(cr_biased, 7);
; 3770 :          int16x8_t cbw = vshll_n_s8(cb_biased, 7);
; 3771 : 
; 3772 :          // color transform
; 3773 :          int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
; 3774 :          int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
; 3775 :          int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
; 3776 :          int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
; 3777 :          int16x8_t rws = vaddq_s16(yws, cr0);
; 3778 :          int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
; 3779 :          int16x8_t bws = vaddq_s16(yws, cb1);
; 3780 : 
; 3781 :          // undo scaling, round, convert to byte
; 3782 :          uint8x8x4_t o;
; 3783 :          o.val[0] = vqrshrun_n_s16(rws, 4);
; 3784 :          o.val[1] = vqrshrun_n_s16(gws, 4);
; 3785 :          o.val[2] = vqrshrun_n_s16(bws, 4);
; 3786 :          o.val[3] = vdup_n_u8(255);
; 3787 : 
; 3788 :          // store, interleaving r/g/b/a
; 3789 :          vst4_u8(out, o);
; 3790 :          out += 8*4;
; 3791 :       }
; 3792 :    }
; 3793 : #endif
; 3794 : 
; 3795 :    for (; i < count; ++i) {

	movsxd	rax, r8d
	mov	rdi, rdx
	cmp	rax, rdx
	jge	$LN6@stbi__YCbC
	mov	QWORD PTR [rsp+128], rbx
	lea	r11, QWORD PTR [rcx+2]
	sub	rbp, r9
	mov	QWORD PTR [rsp+136], r14
	sub	rsi, r9
	lea	rbx, QWORD PTR [rax+r9]
	mov	r14, r10
	sub	rdi, rax
$LL7@stbi__YCbC:

; 3796 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding
; 3797 :       int r,g,b;
; 3798 :       int cr = pcr[i] - 128;

	movzx	edx, BYTE PTR [rbx]

; 3799 :       int cb = pcb[i] - 128;

	movzx	r8d, BYTE PTR [rsi+rbx]
	movzx	r9d, BYTE PTR [rbx+rbp]
	shl	r9d, 20

; 3800 :       r = y_fixed + cr* stbi__float2fixed(1.40200f);

	lea	eax, DWORD PTR [rdx-128]
	add	r9d, 524288				; 00080000H
	imul	r10d, eax, 1470208			; 00166f00H

; 3801 :       g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);

	mov	eax, 128				; 00000080H
	sub	eax, r8d
	imul	ecx, eax, 360960			; 00058200H
	mov	eax, 128				; 00000080H
	sub	eax, edx
	imul	edx, eax, 748800			; 000b6d00H
	add	r10d, r9d

; 3802 :       b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
; 3803 :       r >>= 20;

	sar	r10d, 20
	and	ecx, -65536				; ffffffffffff0000H
	lea	eax, DWORD PTR [r9+rcx]
	add	edx, eax
	lea	eax, DWORD PTR [r8-128]
	imul	eax, eax, 1858048			; 001c5a00H

; 3804 :       g >>= 20;

	sar	edx, 20
	add	eax, r9d

; 3805 :       b >>= 20;

	sar	eax, 20

; 3806 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }

	cmp	r10d, 255				; 000000ffH
	jbe	SHORT $LN10@stbi__YCbC
	test	r10d, r10d
	mov	ecx, 255				; 000000ffH
	cmovs	ecx, r15d
	mov	r10d, ecx
$LN10@stbi__YCbC:

; 3807 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }

	cmp	edx, 255				; 000000ffH
	jbe	SHORT $LN13@stbi__YCbC
	test	edx, edx
	mov	ecx, 255				; 000000ffH
	cmovs	ecx, r15d
	mov	edx, ecx
$LN13@stbi__YCbC:

; 3808 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }

	cmp	eax, 255				; 000000ffH
	jbe	SHORT $LN16@stbi__YCbC
	test	eax, eax
	mov	ecx, 255				; 000000ffH
	cmovs	ecx, r15d
	mov	eax, ecx
$LN16@stbi__YCbC:

; 3809 :       out[0] = (stbi_uc)r;

	mov	BYTE PTR [r11-2], r10b
	inc	rbx

; 3810 :       out[1] = (stbi_uc)g;

	mov	BYTE PTR [r11-1], dl

; 3811 :       out[2] = (stbi_uc)b;

	mov	BYTE PTR [r11], al

; 3812 :       out[3] = 255;

	mov	BYTE PTR [r11+1], 255			; 000000ffH

; 3813 :       out += step;

	add	r11, r14
	sub	rdi, 1
	jne	$LL7@stbi__YCbC

; 3745 :       }
; 3746 :    }
; 3747 : #endif
; 3748 : 
; 3749 : #ifdef STBI_NEON
; 3750 :    // in this version, step=3 support would be easy to add. but is there demand?
; 3751 :    if (step == 4) {
; 3752 :       // this is a fairly straightforward implementation and not super-optimized.
; 3753 :       uint8x8_t signflip = vdup_n_u8(0x80);
; 3754 :       int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3755 :       int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3756 :       int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3757 :       int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3758 : 
; 3759 :       for (; i+7 < count; i += 8) {
; 3760 :          // load
; 3761 :          uint8x8_t y_bytes  = vld1_u8(y + i);
; 3762 :          uint8x8_t cr_bytes = vld1_u8(pcr + i);
; 3763 :          uint8x8_t cb_bytes = vld1_u8(pcb + i);
; 3764 :          int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
; 3765 :          int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
; 3766 : 
; 3767 :          // expand to s16
; 3768 :          int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
; 3769 :          int16x8_t crw = vshll_n_s8(cr_biased, 7);
; 3770 :          int16x8_t cbw = vshll_n_s8(cb_biased, 7);
; 3771 : 
; 3772 :          // color transform
; 3773 :          int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
; 3774 :          int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
; 3775 :          int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
; 3776 :          int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
; 3777 :          int16x8_t rws = vaddq_s16(yws, cr0);
; 3778 :          int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
; 3779 :          int16x8_t bws = vaddq_s16(yws, cb1);
; 3780 : 
; 3781 :          // undo scaling, round, convert to byte
; 3782 :          uint8x8x4_t o;
; 3783 :          o.val[0] = vqrshrun_n_s16(rws, 4);
; 3784 :          o.val[1] = vqrshrun_n_s16(gws, 4);
; 3785 :          o.val[2] = vqrshrun_n_s16(bws, 4);
; 3786 :          o.val[3] = vdup_n_u8(255);
; 3787 : 
; 3788 :          // store, interleaving r/g/b/a
; 3789 :          vst4_u8(out, o);
; 3790 :          out += 8*4;
; 3791 :       }
; 3792 :    }
; 3793 : #endif
; 3794 : 
; 3795 :    for (; i < count; ++i) {

	mov	r14, QWORD PTR [rsp+136]
	mov	rbx, QWORD PTR [rsp+128]
$LN6@stbi__YCbC:

; 3814 :    }
; 3815 : }

	mov	rbp, QWORD PTR [rsp+144]
	add	rsp, 96					; 00000060H
	pop	r15
	pop	rdi
	pop	rsi
	ret	0
?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z ENDP	; stbi__YCbCr_to_RGB_simd
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z
_TEXT	SEGMENT
j$ = 32
?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z PROC		; stbi__setup_jpeg, COMDAT

; 3820 : {

	push	rbx
	sub	rsp, 16

; 3821 :    j->idct_block_kernel = stbi__idct_block;

	lea	rax, OFFSET FLAT:?stbi__idct_block@@YAXPEAEHQEAF@Z ; stbi__idct_block
	mov	r8, rcx
	mov	QWORD PTR [rcx+18544], rax

; 3822 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;

	lea	rax, OFFSET FLAT:?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z ; stbi__YCbCr_to_RGB_row
	mov	QWORD PTR [rcx+18552], rax

; 3823 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

	lea	rax, OFFSET FLAT:?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z ; stbi__resample_row_hv_2
	mov	QWORD PTR [rcx+18560], rax

; 733  :    __cpuid(info,1);

	xor	ecx, ecx
	mov	eax, 1
	cpuid

; 3824 : 
; 3825 : #ifdef STBI_SSE2
; 3826 :    if (stbi__sse2_available()) {

	bt	edx, 26
	jae	SHORT $LN2@stbi__setu

; 3827 :       j->idct_block_kernel = stbi__idct_simd;

	lea	rax, OFFSET FLAT:?stbi__idct_simd@@YAXPEAEHQEAF@Z ; stbi__idct_simd
	mov	QWORD PTR [r8+18544], rax

; 3828 :       j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;

	lea	rax, OFFSET FLAT:?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z ; stbi__YCbCr_to_RGB_simd
	mov	QWORD PTR [r8+18552], rax

; 3829 :       j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;

	lea	rax, OFFSET FLAT:?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z ; stbi__resample_row_hv_2_simd
	mov	QWORD PTR [r8+18560], rax
$LN2@stbi__setu:

; 3830 :    }
; 3831 : #endif
; 3832 : 
; 3833 : #ifdef STBI_NEON
; 3834 :    j->idct_block_kernel = stbi__idct_simd;
; 3835 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3836 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3837 : #endif
; 3838 : }

	add	rsp, 16
	pop	rbx
	ret	0
?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z ENDP		; stbi__setup_jpeg
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z
_TEXT	SEGMENT
j$ = 8
?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z PROC		; stbi__cleanup_jpeg, COMDAT

; 3843 :    stbi__free_jpeg_components(j, j->s->img_n, 0);

	mov	rdx, QWORD PTR [rcx]
	xor	r8d, r8d
	mov	edx, DWORD PTR [rdx+8]
	jmp	?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z ; stbi__free_jpeg_components
?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z ENDP		; stbi__cleanup_jpeg
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__blinn_8x8@@YAEEE@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
?stbi__blinn_8x8@@YAEEE@Z PROC				; stbi__blinn_8x8, COMDAT

; 3859 :    unsigned int t = x*y + 128;

	movzx	eax, dl
	movzx	r8d, cl
	imul	r8d, eax
	sub	r8d, -128				; ffffffffffffff80H

; 3860 :    return (stbi_uc) ((t + (t >>8)) >> 8);

	mov	eax, r8d
	shr	eax, 8
	add	eax, r8d
	shr	eax, 8

; 3861 : }

	ret	0
?stbi__blinn_8x8@@YAEEE@Z ENDP				; stbi__blinn_8x8
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
_TEXT	SEGMENT
j$1$ = 48
tv5439 = 56
output$2$ = 64
coutput$1 = 72
z$GSCopy$1$ = 104
out$1$ = 112
comp$GSCopy$1$ = 120
out_x$GSCopy$1$ = 128
out_y$GSCopy$1$ = 136
res_comp$2 = 144
__$ArrayPad$ = 336
z$ = 432
out_x$ = 440
out_y$ = 448
comp$ = 456
req_comp$dead$ = 464
?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z PROC	; load_jpeg_image, COMDAT

; 3864 : {

	push	rbx
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 376				; 00000178H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3865 :    int n, decode_n, is_rgb;
; 3866 :    z->s->img_n = 0; // make stbi__cleanup_jpeg safe

	mov	rax, QWORD PTR [rcx]
	xor	ebp, ebp
	mov	r15, r9
	mov	QWORD PTR comp$GSCopy$1$[rsp], r9
	mov	QWORD PTR out_y$GSCopy$1$[rsp], r8
	mov	rdi, rcx
	mov	QWORD PTR out_x$GSCopy$1$[rsp], rdx
	mov	DWORD PTR [rax+8], ebp
	mov	QWORD PTR z$GSCopy$1$[rsp], rcx

; 3867 : 
; 3868 :    // validate req_comp
; 3869 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
; 3870 : 
; 3871 :    // load a jpeg image from whichever source, but leave in YCbCr format
; 3872 :    if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

	call	?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z ; stbi__decode_jpeg_image
	mov	rcx, QWORD PTR [rdi]
	movsxd	rdx, DWORD PTR [rcx+8]
	test	eax, eax
	jne	SHORT $LN43@load_jpeg_

; 3243 :    for (i=0; i < ncomp; ++i) {

	mov	rbx, rdx
	test	edx, edx
	jle	$LN193@load_jpeg_
	add	rdi, 18136				; 000046d8H
	npad	3
$LL184@load_jpeg_:

; 3244 :       if (z->img_comp[i].raw_data) {

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN185@load_jpeg_

; 3245 :          STBI_FREE(z->img_comp[i].raw_data);

	call	QWORD PTR __imp_free

; 3246 :          z->img_comp[i].raw_data = NULL;

	mov	QWORD PTR [rdi], rbp

; 3247 :          z->img_comp[i].data = NULL;

	mov	QWORD PTR [rdi-8], rbp
$LN185@load_jpeg_:

; 3248 :       }
; 3249 :       if (z->img_comp[i].raw_coeff) {

	mov	rcx, QWORD PTR [rdi+8]
	test	rcx, rcx
	je	SHORT $LN186@load_jpeg_

; 3250 :          STBI_FREE(z->img_comp[i].raw_coeff);

	call	QWORD PTR __imp_free

; 3251 :          z->img_comp[i].raw_coeff = 0;

	mov	QWORD PTR [rdi+8], rbp

; 3252 :          z->img_comp[i].coeff = 0;

	mov	QWORD PTR [rdi+24], rbp
$LN186@load_jpeg_:

; 3253 :       }
; 3254 :       if (z->img_comp[i].linebuf) {

	mov	rcx, QWORD PTR [rdi+16]
	test	rcx, rcx
	je	SHORT $LN182@load_jpeg_

; 3255 :          STBI_FREE(z->img_comp[i].linebuf);

	call	QWORD PTR __imp_free

; 3256 :          z->img_comp[i].linebuf = NULL;

	mov	QWORD PTR [rdi+16], rbp
$LN182@load_jpeg_:

; 1057 : }
; 1058 : 
; 1059 : #if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
; 1060 : static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
; 1061 : {
; 1062 :    if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
; 1063 :    return stbi__malloc(a*b*c*d + add);
; 1064 : }
; 1065 : #endif
; 1066 : 
; 1067 : // returns 1 if the sum of two signed ints is valid (between -2^31 and 2^31-1 inclusive), 0 on overflow.
; 1068 : static int stbi__addints_valid(int a, int b)
; 1069 : {
; 1070 :    if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow
; 1071 :    if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.
; 1072 :    return a <= INT_MAX - b;
; 1073 : }
; 1074 : 
; 1075 : // returns 1 if the product of two signed shorts is valid, 0 on overflow.
; 1076 : static int stbi__mul2shorts_valid(short a, short b)
; 1077 : {
; 1078 :    if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow
; 1079 :    if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX/b; // product is positive, so similar to mul2sizes_valid
; 1080 :    if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN
; 1081 :    return a >= SHRT_MIN / b;
; 1082 : }
; 1083 : 
; 1084 : // stbi__err - error
; 1085 : // stbi__errpf - error returning pointer to float
; 1086 : // stbi__errpuc - error returning pointer to unsigned char
; 1087 : 
; 1088 : #ifdef STBI_NO_FAILURE_STRINGS
; 1089 :    #define stbi__err(x,y)  0
; 1090 : #elif defined(STBI_FAILURE_USERMSG)
; 1091 :    #define stbi__err(x,y)  stbi__err(y)
; 1092 : #else
; 1093 :    #define stbi__err(x,y)  stbi__err(x)
; 1094 : #endif
; 1095 : 
; 1096 : #define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
; 1097 : #define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))
; 1098 : 
; 1099 : STBIDEF void stbi_image_free(void *retval_from_stbi_load)
; 1100 : {
; 1101 :    STBI_FREE(retval_from_stbi_load);
; 1102 : }
; 1103 : 
; 1104 : #ifndef STBI_NO_LINEAR
; 1105 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
; 1106 : #endif
; 1107 : 
; 1108 : #ifndef STBI_NO_HDR
; 1109 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
; 1110 : #endif
; 1111 : 
; 1112 : static int stbi__vertically_flip_on_load_global = 0;
; 1113 : 
; 1114 : STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
; 1115 : {
; 1116 :    stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
; 1117 : }
; 1118 : 
; 1119 : #ifndef STBI_THREAD_LOCAL
; 1120 : #define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global
; 1121 : #else
; 1122 : static STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;
; 1123 : 
; 1124 : STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
; 1125 : {
; 1126 :    stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
; 1127 :    stbi__vertically_flip_on_load_set = 1;
; 1128 : }
; 1129 : 
; 1130 : #define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \
; 1131 :                                          ? stbi__vertically_flip_on_load_local  \
; 1132 :                                          : stbi__vertically_flip_on_load_global)
; 1133 : #endif // STBI_THREAD_LOCAL
; 1134 : 
; 1135 : static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
; 1136 : {
; 1137 :    memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
; 1138 :    ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
; 1139 :    ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
; 1140 :    ri->num_channels = 0;
; 1141 : 
; 1142 :    // test the formats with a very explicit header first (at least a FOURCC
; 1143 :    // or distinctive magic number first)
; 1144 :    #ifndef STBI_NO_PNG
; 1145 :    if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
; 1146 :    #endif
; 1147 :    #ifndef STBI_NO_BMP
; 1148 :    if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
; 1149 :    #endif
; 1150 :    #ifndef STBI_NO_GIF
; 1151 :    if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
; 1152 :    #endif
; 1153 :    #ifndef STBI_NO_PSD
; 1154 :    if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
; 1155 :    #else
; 1156 :    STBI_NOTUSED(bpc);
; 1157 :    #endif
; 1158 :    #ifndef STBI_NO_PIC
; 1159 :    if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
; 1160 :    #endif
; 1161 : 
; 1162 :    // then the formats that can end up attempting to load with just 1 or 2
; 1163 :    // bytes matching expectations; these are prone to false positives, so
; 1164 :    // try them later
; 1165 :    #ifndef STBI_NO_JPEG
; 1166 :    if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
; 1167 :    #endif
; 1168 :    #ifndef STBI_NO_PNM
; 1169 :    if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
; 1170 :    #endif
; 1171 : 
; 1172 :    #ifndef STBI_NO_HDR
; 1173 :    if (stbi__hdr_test(s)) {
; 1174 :       float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
; 1175 :       return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
; 1176 :    }
; 1177 :    #endif
; 1178 : 
; 1179 :    #ifndef STBI_NO_TGA
; 1180 :    // test tga last because it's a crappy test!
; 1181 :    if (stbi__tga_test(s))
; 1182 :       return stbi__tga_load(s,x,y,comp,req_comp, ri);
; 1183 :    #endif
; 1184 : 
; 1185 :    return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
; 1186 : }
; 1187 : 
; 1188 : static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
; 1189 : {
; 1190 :    int i;
; 1191 :    int img_len = w * h * channels;
; 1192 :    stbi_uc *reduced;
; 1193 : 
; 1194 :    reduced = (stbi_uc *) stbi__malloc(img_len);
; 1195 :    if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");
; 1196 : 
; 1197 :    for (i = 0; i < img_len; ++i)
; 1198 :       reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling
; 1199 : 
; 1200 :    STBI_FREE(orig);
; 1201 :    return reduced;
; 1202 : }
; 1203 : 
; 1204 : static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
; 1205 : {
; 1206 :    int i;
; 1207 :    int img_len = w * h * channels;
; 1208 :    stbi__uint16 *enlarged;
; 1209 : 
; 1210 :    enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
; 1211 :    if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1212 : 
; 1213 :    for (i = 0; i < img_len; ++i)
; 1214 :       enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff
; 1215 : 
; 1216 :    STBI_FREE(orig);
; 1217 :    return enlarged;
; 1218 : }
; 1219 : 
; 1220 : static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
; 1221 : {
; 1222 :    int row;
; 1223 :    size_t bytes_per_row = (size_t)w * bytes_per_pixel;
; 1224 :    stbi_uc temp[2048];
; 1225 :    stbi_uc *bytes = (stbi_uc *)image;
; 1226 : 
; 1227 :    for (row = 0; row < (h>>1); row++) {
; 1228 :       stbi_uc *row0 = bytes + row*bytes_per_row;
; 1229 :       stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
; 1230 :       // swap row0 with row1
; 1231 :       size_t bytes_left = bytes_per_row;
; 1232 :       while (bytes_left) {
; 1233 :          size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
; 1234 :          memcpy(temp, row0, bytes_copy);
; 1235 :          memcpy(row0, row1, bytes_copy);
; 1236 :          memcpy(row1, temp, bytes_copy);
; 1237 :          row0 += bytes_copy;
; 1238 :          row1 += bytes_copy;
; 1239 :          bytes_left -= bytes_copy;
; 1240 :       }
; 1241 :    }
; 1242 : }
; 1243 : 
; 1244 : #ifndef STBI_NO_GIF
; 1245 : static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
; 1246 : {
; 1247 :    int slice;
; 1248 :    int slice_size = w * h * bytes_per_pixel;
; 1249 : 
; 1250 :    stbi_uc *bytes = (stbi_uc *)image;
; 1251 :    for (slice = 0; slice < z; ++slice) {
; 1252 :       stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
; 1253 :       bytes += slice_size;
; 1254 :    }
; 1255 : }
; 1256 : #endif
; 1257 : 
; 1258 : static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
; 1259 : {
; 1260 :    stbi__result_info ri;
; 1261 :    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);
; 1262 : 
; 1263 :    if (result == NULL)
; 1264 :       return NULL;
; 1265 : 
; 1266 :    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1267 :    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
; 1268 : 
; 1269 :    if (ri.bits_per_channel != 8) {
; 1270 :       result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
; 1271 :       ri.bits_per_channel = 8;
; 1272 :    }
; 1273 : 
; 1274 :    // @TODO: move stbi__convert_format to here
; 1275 : 
; 1276 :    if (stbi__vertically_flip_on_load) {
; 1277 :       int channels = req_comp ? req_comp : *comp;
; 1278 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
; 1279 :    }
; 1280 : 
; 1281 :    return (unsigned char *) result;
; 1282 : }
; 1283 : 
; 1284 : static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
; 1285 : {
; 1286 :    stbi__result_info ri;
; 1287 :    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);
; 1288 : 
; 1289 :    if (result == NULL)
; 1290 :       return NULL;
; 1291 : 
; 1292 :    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1293 :    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
; 1294 : 
; 1295 :    if (ri.bits_per_channel != 16) {
; 1296 :       result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
; 1297 :       ri.bits_per_channel = 16;
; 1298 :    }
; 1299 : 
; 1300 :    // @TODO: move stbi__convert_format16 to here
; 1301 :    // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision
; 1302 : 
; 1303 :    if (stbi__vertically_flip_on_load) {
; 1304 :       int channels = req_comp ? req_comp : *comp;
; 1305 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
; 1306 :    }
; 1307 : 
; 1308 :    return (stbi__uint16 *) result;
; 1309 : }
; 1310 : 
; 1311 : #if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)
; 1312 : static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
; 1313 : {
; 1314 :    if (stbi__vertically_flip_on_load && result != NULL) {
; 1315 :       int channels = req_comp ? req_comp : *comp;
; 1316 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
; 1317 :    }
; 1318 : }
; 1319 : #endif
; 1320 : 
; 1321 : #ifndef STBI_NO_STDIO
; 1322 : 
; 1323 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1324 : STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
; 1325 : STBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);
; 1326 : #endif
; 1327 : 
; 1328 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1329 : STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
; 1330 : {
; 1331 : 	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
; 1332 : }
; 1333 : #endif
; 1334 : 
; 1335 : static FILE *stbi__fopen(char const *filename, char const *mode)
; 1336 : {
; 1337 :    FILE *f;
; 1338 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1339 :    wchar_t wMode[64];
; 1340 :    wchar_t wFilename[1024];
; 1341 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
; 1342 :       return 0;
; 1343 : 
; 1344 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
; 1345 :       return 0;
; 1346 : 
; 1347 : #if defined(_MSC_VER) && _MSC_VER >= 1400
; 1348 : 	if (0 != _wfopen_s(&f, wFilename, wMode))
; 1349 : 		f = 0;
; 1350 : #else
; 1351 :    f = _wfopen(wFilename, wMode);
; 1352 : #endif
; 1353 : 
; 1354 : #elif defined(_MSC_VER) && _MSC_VER >= 1400
; 1355 :    if (0 != fopen_s(&f, filename, mode))
; 1356 :       f=0;
; 1357 : #else
; 1358 :    f = fopen(filename, mode);
; 1359 : #endif
; 1360 :    return f;
; 1361 : }
; 1362 : 
; 1363 : 
; 1364 : STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
; 1365 : {
; 1366 :    FILE *f = stbi__fopen(filename, "rb");
; 1367 :    unsigned char *result;
; 1368 :    if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
; 1369 :    result = stbi_load_from_file(f,x,y,comp,req_comp);
; 1370 :    fclose(f);
; 1371 :    return result;
; 1372 : }
; 1373 : 
; 1374 : STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
; 1375 : {
; 1376 :    unsigned char *result;
; 1377 :    stbi__context s;
; 1378 :    stbi__start_file(&s,f);
; 1379 :    result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
; 1380 :    if (result) {
; 1381 :       // need to 'unget' all the characters in the IO buffer
; 1382 :       fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
; 1383 :    }
; 1384 :    return result;
; 1385 : }
; 1386 : 
; 1387 : STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
; 1388 : {
; 1389 :    stbi__uint16 *result;
; 1390 :    stbi__context s;
; 1391 :    stbi__start_file(&s,f);
; 1392 :    result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
; 1393 :    if (result) {
; 1394 :       // need to 'unget' all the characters in the IO buffer
; 1395 :       fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
; 1396 :    }
; 1397 :    return result;
; 1398 : }
; 1399 : 
; 1400 : STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
; 1401 : {
; 1402 :    FILE *f = stbi__fopen(filename, "rb");
; 1403 :    stbi__uint16 *result;
; 1404 :    if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");
; 1405 :    result = stbi_load_from_file_16(f,x,y,comp,req_comp);
; 1406 :    fclose(f);
; 1407 :    return result;
; 1408 : }
; 1409 : 
; 1410 : 
; 1411 : #endif //!STBI_NO_STDIO
; 1412 : 
; 1413 : STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
; 1414 : {
; 1415 :    stbi__context s;
; 1416 :    stbi__start_mem(&s,buffer,len);
; 1417 :    return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
; 1418 : }
; 1419 : 
; 1420 : STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
; 1421 : {
; 1422 :    stbi__context s;
; 1423 :    stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
; 1424 :    return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
; 1425 : }
; 1426 : 
; 1427 : STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
; 1428 : {
; 1429 :    stbi__context s;
; 1430 :    stbi__start_mem(&s,buffer,len);
; 1431 :    return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
; 1432 : }
; 1433 : 
; 1434 : STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
; 1435 : {
; 1436 :    stbi__context s;
; 1437 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
; 1438 :    return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
; 1439 : }
; 1440 : 
; 1441 : #ifndef STBI_NO_GIF
; 1442 : STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
; 1443 : {
; 1444 :    unsigned char *result;
; 1445 :    stbi__context s;
; 1446 :    stbi__start_mem(&s,buffer,len);
; 1447 : 
; 1448 :    result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
; 1449 :    if (stbi__vertically_flip_on_load) {
; 1450 :       stbi__vertical_flip_slices( result, *x, *y, *z, *comp );
; 1451 :    }
; 1452 : 
; 1453 :    return result;
; 1454 : }
; 1455 : #endif
; 1456 : 
; 1457 : #ifndef STBI_NO_LINEAR
; 1458 : static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
; 1459 : {
; 1460 :    unsigned char *data;
; 1461 :    #ifndef STBI_NO_HDR
; 1462 :    if (stbi__hdr_test(s)) {
; 1463 :       stbi__result_info ri;
; 1464 :       float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
; 1465 :       if (hdr_data)
; 1466 :          stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
; 1467 :       return hdr_data;
; 1468 :    }
; 1469 :    #endif
; 1470 :    data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
; 1471 :    if (data)
; 1472 :       return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
; 1473 :    return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
; 1474 : }
; 1475 : 
; 1476 : STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
; 1477 : {
; 1478 :    stbi__context s;
; 1479 :    stbi__start_mem(&s,buffer,len);
; 1480 :    return stbi__loadf_main(&s,x,y,comp,req_comp);
; 1481 : }
; 1482 : 
; 1483 : STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
; 1484 : {
; 1485 :    stbi__context s;
; 1486 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
; 1487 :    return stbi__loadf_main(&s,x,y,comp,req_comp);
; 1488 : }
; 1489 : 
; 1490 : #ifndef STBI_NO_STDIO
; 1491 : STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
; 1492 : {
; 1493 :    float *result;
; 1494 :    FILE *f = stbi__fopen(filename, "rb");
; 1495 :    if (!f) return stbi__errpf("can't fopen", "Unable to open file");
; 1496 :    result = stbi_loadf_from_file(f,x,y,comp,req_comp);
; 1497 :    fclose(f);
; 1498 :    return result;
; 1499 : }
; 1500 : 
; 1501 : STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
; 1502 : {
; 1503 :    stbi__context s;
; 1504 :    stbi__start_file(&s,f);
; 1505 :    return stbi__loadf_main(&s,x,y,comp,req_comp);
; 1506 : }
; 1507 : #endif // !STBI_NO_STDIO
; 1508 : 
; 1509 : #endif // !STBI_NO_LINEAR
; 1510 : 
; 1511 : // these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
; 1512 : // defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
; 1513 : // reports false!
; 1514 : 
; 1515 : STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
; 1516 : {
; 1517 :    #ifndef STBI_NO_HDR
; 1518 :    stbi__context s;
; 1519 :    stbi__start_mem(&s,buffer,len);
; 1520 :    return stbi__hdr_test(&s);
; 1521 :    #else
; 1522 :    STBI_NOTUSED(buffer);
; 1523 :    STBI_NOTUSED(len);
; 1524 :    return 0;
; 1525 :    #endif
; 1526 : }
; 1527 : 
; 1528 : #ifndef STBI_NO_STDIO
; 1529 : STBIDEF int      stbi_is_hdr          (char const *filename)
; 1530 : {
; 1531 :    FILE *f = stbi__fopen(filename, "rb");
; 1532 :    int result=0;
; 1533 :    if (f) {
; 1534 :       result = stbi_is_hdr_from_file(f);
; 1535 :       fclose(f);
; 1536 :    }
; 1537 :    return result;
; 1538 : }
; 1539 : 
; 1540 : STBIDEF int stbi_is_hdr_from_file(FILE *f)
; 1541 : {
; 1542 :    #ifndef STBI_NO_HDR
; 1543 :    long pos = ftell(f);
; 1544 :    int res;
; 1545 :    stbi__context s;
; 1546 :    stbi__start_file(&s,f);
; 1547 :    res = stbi__hdr_test(&s);
; 1548 :    fseek(f, pos, SEEK_SET);
; 1549 :    return res;
; 1550 :    #else
; 1551 :    STBI_NOTUSED(f);
; 1552 :    return 0;
; 1553 :    #endif
; 1554 : }
; 1555 : #endif // !STBI_NO_STDIO
; 1556 : 
; 1557 : STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
; 1558 : {
; 1559 :    #ifndef STBI_NO_HDR
; 1560 :    stbi__context s;
; 1561 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
; 1562 :    return stbi__hdr_test(&s);
; 1563 :    #else
; 1564 :    STBI_NOTUSED(clbk);
; 1565 :    STBI_NOTUSED(user);
; 1566 :    return 0;
; 1567 :    #endif
; 1568 : }
; 1569 : 
; 1570 : #ifndef STBI_NO_LINEAR
; 1571 : static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;
; 1572 : 
; 1573 : STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
; 1574 : STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
; 1575 : #endif
; 1576 : 
; 1577 : static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;
; 1578 : 
; 1579 : STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
; 1580 : STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }
; 1581 : 
; 1582 : 
; 1583 : //////////////////////////////////////////////////////////////////////////////
; 1584 : //
; 1585 : // Common code used by all image loaders
; 1586 : //
; 1587 : 
; 1588 : enum
; 1589 : {
; 1590 :    STBI__SCAN_load=0,
; 1591 :    STBI__SCAN_type,
; 1592 :    STBI__SCAN_header
; 1593 : };
; 1594 : 
; 1595 : static void stbi__refill_buffer(stbi__context *s)
; 1596 : {
; 1597 :    int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
; 1598 :    s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);
; 1599 :    if (n == 0) {
; 1600 :       // at end of file, treat same as if from memory, but need to handle case
; 1601 :       // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
; 1602 :       s->read_from_callbacks = 0;
; 1603 :       s->img_buffer = s->buffer_start;
; 1604 :       s->img_buffer_end = s->buffer_start+1;
; 1605 :       *s->img_buffer = 0;
; 1606 :    } else {
; 1607 :       s->img_buffer = s->buffer_start;
; 1608 :       s->img_buffer_end = s->buffer_start + n;
; 1609 :    }
; 1610 : }
; 1611 : 
; 1612 : stbi_inline static stbi_uc stbi__get8(stbi__context *s)
; 1613 : {
; 1614 :    if (s->img_buffer < s->img_buffer_end)
; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {
; 1617 :       stbi__refill_buffer(s);
; 1618 :       return *s->img_buffer++;
; 1619 :    }
; 1620 :    return 0;
; 1621 : }
; 1622 : 
; 1623 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1624 : // nothing
; 1625 : #else
; 1626 : stbi_inline static int stbi__at_eof(stbi__context *s)
; 1627 : {
; 1628 :    if (s->io.read) {
; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;
; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;
; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;
; 1636 : }
; 1637 : #endif
; 1638 : 
; 1639 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
; 1640 : // nothing
; 1641 : #else
; 1642 : static void stbi__skip(stbi__context *s, int n)
; 1643 : {
; 1644 :    if (n == 0) return;  // already there!
; 1645 :    if (n < 0) {
; 1646 :       s->img_buffer = s->img_buffer_end;
; 1647 :       return;
; 1648 :    }
; 1649 :    if (s->io.read) {
; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1651 :       if (blen < n) {
; 1652 :          s->img_buffer = s->img_buffer_end;
; 1653 :          (s->io.skip)(s->io_user_data, n - blen);
; 1654 :          return;
; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;
; 1658 : }
; 1659 : #endif
; 1660 : 
; 1661 : #if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
; 1662 : // nothing
; 1663 : #else
; 1664 : static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
; 1665 : {
; 1666 :    if (s->io.read) {
; 1667 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1668 :       if (blen < n) {
; 1669 :          int res, count;
; 1670 : 
; 1671 :          memcpy(buffer, s->img_buffer, blen);
; 1672 : 
; 1673 :          count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
; 1674 :          res = (count == (n-blen));
; 1675 :          s->img_buffer = s->img_buffer_end;
; 1676 :          return res;
; 1677 :       }
; 1678 :    }
; 1679 : 
; 1680 :    if (s->img_buffer+n <= s->img_buffer_end) {
; 1681 :       memcpy(buffer, s->img_buffer, n);
; 1682 :       s->img_buffer += n;
; 1683 :       return 1;
; 1684 :    } else
; 1685 :       return 0;
; 1686 : }
; 1687 : #endif
; 1688 : 
; 1689 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1690 : // nothing
; 1691 : #else
; 1692 : static int stbi__get16be(stbi__context *s)
; 1693 : {
; 1694 :    int z = stbi__get8(s);
; 1695 :    return (z << 8) + stbi__get8(s);
; 1696 : }
; 1697 : #endif
; 1698 : 
; 1699 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1700 : // nothing
; 1701 : #else
; 1702 : static stbi__uint32 stbi__get32be(stbi__context *s)
; 1703 : {
; 1704 :    stbi__uint32 z = stbi__get16be(s);
; 1705 :    return (z << 16) + stbi__get16be(s);
; 1706 : }
; 1707 : #endif
; 1708 : 
; 1709 : #if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
; 1710 : // nothing
; 1711 : #else
; 1712 : static int stbi__get16le(stbi__context *s)
; 1713 : {
; 1714 :    int z = stbi__get8(s);
; 1715 :    return z + (stbi__get8(s) << 8);
; 1716 : }
; 1717 : #endif
; 1718 : 
; 1719 : #ifndef STBI_NO_BMP
; 1720 : static stbi__uint32 stbi__get32le(stbi__context *s)
; 1721 : {
; 1722 :    stbi__uint32 z = stbi__get16le(s);
; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;
; 1724 :    return z;
; 1725 : }
; 1726 : #endif
; 1727 : 
; 1728 : #define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
; 1729 : 
; 1730 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1731 : // nothing
; 1732 : #else
; 1733 : //////////////////////////////////////////////////////////////////////////////
; 1734 : //
; 1735 : //  generic converter from built-in img_n to req_comp
; 1736 : //    individual types do this automatically as much as possible (e.g. jpeg
; 1737 : //    does all cases internally since it needs to colorspace convert anyway,
; 1738 : //    and it never has alpha, so very few cases ). png can automatically
; 1739 : //    interleave an alpha=255 channel, but falls back to this for other cases
; 1740 : //
; 1741 : //  assume data buffer is malloced, so malloc a new one and free that one
; 1742 : //  only failure mode is malloc failing
; 1743 : 
; 1744 : static stbi_uc stbi__compute_y(int r, int g, int b)
; 1745 : {
; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1747 : }
; 1748 : #endif
; 1749 : 
; 1750 : #if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1751 : // nothing
; 1752 : #else
; 1753 : static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1754 : {
; 1755 :    int i,j;
; 1756 :    unsigned char *good;
; 1757 : 
; 1758 :    if (req_comp == img_n) return data;
; 1759 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1760 : 
; 1761 :    good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
; 1762 :    if (good == NULL) {
; 1763 :       STBI_FREE(data);
; 1764 :       return stbi__errpuc("outofmem", "Out of memory");
; 1765 :    }
; 1766 : 
; 1767 :    for (j=0; j < (int) y; ++j) {
; 1768 :       unsigned char *src  = data + j * x * img_n   ;
; 1769 :       unsigned char *dest = good + j * x * req_comp;
; 1770 : 
; 1771 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1772 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1773 :       // convert source image with img_n components to one with req_comp components;
; 1774 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1775 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1776 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
; 1777 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1778 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
; 1779 :          STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
; 1780 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1781 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
; 1782 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
; 1783 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1784 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
; 1785 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1786 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1787 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
; 1788 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
; 1789 :       }
; 1790 :       #undef STBI__CASE
; 1791 :    }
; 1792 : 
; 1793 :    STBI_FREE(data);
; 1794 :    return good;
; 1795 : }
; 1796 : #endif
; 1797 : 
; 1798 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1799 : // nothing
; 1800 : #else
; 1801 : static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
; 1802 : {
; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1804 : }
; 1805 : #endif
; 1806 : 
; 1807 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1808 : // nothing
; 1809 : #else
; 1810 : static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1811 : {
; 1812 :    int i,j;
; 1813 :    stbi__uint16 *good;
; 1814 : 
; 1815 :    if (req_comp == img_n) return data;
; 1816 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1817 : 
; 1818 :    good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
; 1819 :    if (good == NULL) {
; 1820 :       STBI_FREE(data);
; 1821 :       return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1822 :    }
; 1823 : 
; 1824 :    for (j=0; j < (int) y; ++j) {
; 1825 :       stbi__uint16 *src  = data + j * x * img_n   ;
; 1826 :       stbi__uint16 *dest = good + j * x * req_comp;
; 1827 : 
; 1828 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1829 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1830 :       // convert source image with img_n components to one with req_comp components;
; 1831 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1832 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1833 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
; 1834 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1835 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
; 1836 :          STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
; 1837 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1838 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
; 1839 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
; 1840 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1841 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
; 1842 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1843 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1844 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
; 1845 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
; 1846 :       }
; 1847 :       #undef STBI__CASE
; 1848 :    }
; 1849 : 
; 1850 :    STBI_FREE(data);
; 1851 :    return good;
; 1852 : }
; 1853 : #endif
; 1854 : 
; 1855 : #ifndef STBI_NO_LINEAR
; 1856 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
; 1857 : {
; 1858 :    int i,k,n;
; 1859 :    float *output;
; 1860 :    if (!data) return NULL;
; 1861 :    output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
; 1862 :    if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
; 1863 :    // compute number of non-alpha components
; 1864 :    if (comp & 1) n = comp; else n = comp-1;
; 1865 :    for (i=0; i < x*y; ++i) {
; 1866 :       for (k=0; k < n; ++k) {
; 1867 :          output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
; 1868 :       }
; 1869 :    }
; 1870 :    if (n < comp) {
; 1871 :       for (i=0; i < x*y; ++i) {
; 1872 :          output[i*comp + n] = data[i*comp + n]/255.0f;
; 1873 :       }
; 1874 :    }
; 1875 :    STBI_FREE(data);
; 1876 :    return output;
; 1877 : }
; 1878 : #endif
; 1879 : 
; 1880 : #ifndef STBI_NO_HDR
; 1881 : #define stbi__float2int(x)   ((int) (x))
; 1882 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
; 1883 : {
; 1884 :    int i,k,n;
; 1885 :    stbi_uc *output;
; 1886 :    if (!data) return NULL;
; 1887 :    output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
; 1888 :    if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
; 1889 :    // compute number of non-alpha components
; 1890 :    if (comp & 1) n = comp; else n = comp-1;
; 1891 :    for (i=0; i < x*y; ++i) {
; 1892 :       for (k=0; k < n; ++k) {
; 1893 :          float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
; 1894 :          if (z < 0) z = 0;
; 1895 :          if (z > 255) z = 255;
; 1896 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1897 :       }
; 1898 :       if (k < comp) {
; 1899 :          float z = data[i*comp+k] * 255 + 0.5f;
; 1900 :          if (z < 0) z = 0;
; 1901 :          if (z > 255) z = 255;
; 1902 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1903 :       }
; 1904 :    }
; 1905 :    STBI_FREE(data);
; 1906 :    return output;
; 1907 : }
; 1908 : #endif
; 1909 : 
; 1910 : //////////////////////////////////////////////////////////////////////////////
; 1911 : //
; 1912 : //  "baseline" JPEG/JFIF decoder
; 1913 : //
; 1914 : //    simple implementation
; 1915 : //      - doesn't support delayed output of y-dimension
; 1916 : //      - simple interface (only one output format: 8-bit interleaved RGB)
; 1917 : //      - doesn't try to recover corrupt jpegs
; 1918 : //      - doesn't allow partial loading, loading multiple at once
; 1919 : //      - still fast on x86 (copying globals into locals doesn't help x86)
; 1920 : //      - allocates lots of intermediate memory (full size of all components)
; 1921 : //        - non-interleaved case requires this anyway
; 1922 : //        - allows good upsampling (see next)
; 1923 : //    high-quality
; 1924 : //      - upsampled channels are bilinearly interpolated, even across blocks
; 1925 : //      - quality integer IDCT derived from IJG's 'slow'
; 1926 : //    performance
; 1927 : //      - fast huffman; reasonable integer IDCT
; 1928 : //      - some SIMD kernels for common paths on targets with SSE2/NEON
; 1929 : //      - uses a lot of intermediate memory, could cache poorly
; 1930 : 
; 1931 : #ifndef STBI_NO_JPEG
; 1932 : 
; 1933 : // huffman decoding acceleration
; 1934 : #define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
; 1935 : 
; 1936 : typedef struct
; 1937 : {
; 1938 :    stbi_uc  fast[1 << FAST_BITS];
; 1939 :    // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
; 1940 :    stbi__uint16 code[256];
; 1941 :    stbi_uc  values[256];
; 1942 :    stbi_uc  size[257];
; 1943 :    unsigned int maxcode[18];
; 1944 :    int    delta[17];   // old 'firstsymbol' - old 'firstcode'
; 1945 : } stbi__huffman;
; 1946 : 
; 1947 : typedef struct
; 1948 : {
; 1949 :    stbi__context *s;
; 1950 :    stbi__huffman huff_dc[4];
; 1951 :    stbi__huffman huff_ac[4];
; 1952 :    stbi__uint16 dequant[4][64];
; 1953 :    stbi__int16 fast_ac[4][1 << FAST_BITS];
; 1954 : 
; 1955 : // sizes for components, interleaved MCUs
; 1956 :    int img_h_max, img_v_max;
; 1957 :    int img_mcu_x, img_mcu_y;
; 1958 :    int img_mcu_w, img_mcu_h;
; 1959 : 
; 1960 : // definition of jpeg image component
; 1961 :    struct
; 1962 :    {
; 1963 :       int id;
; 1964 :       int h,v;
; 1965 :       int tq;
; 1966 :       int hd,ha;
; 1967 :       int dc_pred;
; 1968 : 
; 1969 :       int x,y,w2,h2;
; 1970 :       stbi_uc *data;
; 1971 :       void *raw_data, *raw_coeff;
; 1972 :       stbi_uc *linebuf;
; 1973 :       short   *coeff;   // progressive only
; 1974 :       int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
; 1975 :    } img_comp[4];
; 1976 : 
; 1977 :    stbi__uint32   code_buffer; // jpeg entropy-coded buffer
; 1978 :    int            code_bits;   // number of valid bits
; 1979 :    unsigned char  marker;      // marker seen while filling entropy buffer
; 1980 :    int            nomore;      // flag if we saw a marker so must stop
; 1981 : 
; 1982 :    int            progressive;
; 1983 :    int            spec_start;
; 1984 :    int            spec_end;
; 1985 :    int            succ_high;
; 1986 :    int            succ_low;
; 1987 :    int            eob_run;
; 1988 :    int            jfif;
; 1989 :    int            app14_color_transform; // Adobe APP14 tag
; 1990 :    int            rgb;
; 1991 : 
; 1992 :    int scan_n, order[4];
; 1993 :    int restart_interval, todo;
; 1994 : 
; 1995 : // kernels
; 1996 :    void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
; 1997 :    void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
; 1998 :    stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
; 1999 : } stbi__jpeg;
; 2000 : 
; 2001 : static int stbi__build_huffman(stbi__huffman *h, int *count)
; 2002 : {
; 2003 :    int i,j,k=0;
; 2004 :    unsigned int code;
; 2005 :    // build size list for each symbol (from JPEG spec)
; 2006 :    for (i=0; i < 16; ++i) {
; 2007 :       for (j=0; j < count[i]; ++j) {
; 2008 :          h->size[k++] = (stbi_uc) (i+1);
; 2009 :          if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");
; 2010 :       }
; 2011 :    }
; 2012 :    h->size[k] = 0;
; 2013 : 
; 2014 :    // compute actual symbols (from jpeg spec)
; 2015 :    code = 0;
; 2016 :    k = 0;
; 2017 :    for(j=1; j <= 16; ++j) {
; 2018 :       // compute delta to add to code to compute symbol id
; 2019 :       h->delta[j] = k - code;
; 2020 :       if (h->size[k] == j) {
; 2021 :          while (h->size[k] == j)
; 2022 :             h->code[k++] = (stbi__uint16) (code++);
; 2023 :          if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
; 2024 :       }
; 2025 :       // compute largest code + 1 for this size, preshifted as needed later
; 2026 :       h->maxcode[j] = code << (16-j);
; 2027 :       code <<= 1;
; 2028 :    }
; 2029 :    h->maxcode[j] = 0xffffffff;
; 2030 : 
; 2031 :    // build non-spec acceleration table; 255 is flag for not-accelerated
; 2032 :    memset(h->fast, 255, 1 << FAST_BITS);
; 2033 :    for (i=0; i < k; ++i) {
; 2034 :       int s = h->size[i];
; 2035 :       if (s <= FAST_BITS) {
; 2036 :          int c = h->code[i] << (FAST_BITS-s);
; 2037 :          int m = 1 << (FAST_BITS-s);
; 2038 :          for (j=0; j < m; ++j) {
; 2039 :             h->fast[c+j] = (stbi_uc) i;
; 2040 :          }
; 2041 :       }
; 2042 :    }
; 2043 :    return 1;
; 2044 : }
; 2045 : 
; 2046 : // build a table that decodes both magnitude and value of small ACs in
; 2047 : // one go.
; 2048 : static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
; 2049 : {
; 2050 :    int i;
; 2051 :    for (i=0; i < (1 << FAST_BITS); ++i) {
; 2052 :       stbi_uc fast = h->fast[i];
; 2053 :       fast_ac[i] = 0;
; 2054 :       if (fast < 255) {
; 2055 :          int rs = h->values[fast];
; 2056 :          int run = (rs >> 4) & 15;
; 2057 :          int magbits = rs & 15;
; 2058 :          int len = h->size[fast];
; 2059 : 
; 2060 :          if (magbits && len + magbits <= FAST_BITS) {
; 2061 :             // magnitude code followed by receive_extend code
; 2062 :             int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
; 2063 :             int m = 1 << (magbits - 1);
; 2064 :             if (k < m) k += (~0U << magbits) + 1;
; 2065 :             // if the result is small enough, we can fit it in fast_ac table
; 2066 :             if (k >= -128 && k <= 127)
; 2067 :                fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
; 2068 :          }
; 2069 :       }
; 2070 :    }
; 2071 : }
; 2072 : 
; 2073 : static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
; 2074 : {
; 2075 :    do {
; 2076 :       unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
; 2077 :       if (b == 0xff) {
; 2078 :          int c = stbi__get8(j->s);
; 2079 :          while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
; 2080 :          if (c != 0) {
; 2081 :             j->marker = (unsigned char) c;
; 2082 :             j->nomore = 1;
; 2083 :             return;
; 2084 :          }
; 2085 :       }
; 2086 :       j->code_buffer |= b << (24 - j->code_bits);
; 2087 :       j->code_bits += 8;
; 2088 :    } while (j->code_bits <= 24);
; 2089 : }
; 2090 : 
; 2091 : // (1 << n) - 1
; 2092 : static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
; 2093 : 
; 2094 : // decode a jpeg huffman value from the bitstream
; 2095 : stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
; 2096 : {
; 2097 :    unsigned int temp;
; 2098 :    int c,k;
; 2099 : 
; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2105 :    k = h->fast[c];
; 2106 :    if (k < 255) {
; 2107 :       int s = h->size[k];
; 2108 :       if (s > j->code_bits)
; 2109 :          return -1;
; 2110 :       j->code_buffer <<= s;
; 2111 :       j->code_bits -= s;
; 2112 :       return h->values[k];
; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;
; 2122 :    for (k=FAST_BITS+1 ; ; ++k)
; 2123 :       if (temp < h->maxcode[k])
; 2124 :          break;
; 2125 :    if (k == 17) {
; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;
; 2128 :       return -1;
; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)
; 2132 :       return -1;
; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!
; 2137 :        return -1;
; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;
; 2142 :    j->code_buffer <<= k;
; 2143 :    return h->values[c];
; 2144 : }
; 2145 : 
; 2146 : // bias[n] = (-1<<n) + 1
; 2147 : static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};
; 2148 : 
; 2149 : // combined JPEG 'receive' and JPEG 'extend', since baseline
; 2150 : // always extends everything it receives.
; 2151 : stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
; 2152 : {
; 2153 :    unsigned int k;
; 2154 :    int sgn;
; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
; 2159 :    k = stbi_lrot(j->code_buffer, n);
; 2160 :    j->code_buffer = k & ~stbi__bmask[n];
; 2161 :    k &= stbi__bmask[n];
; 2162 :    j->code_bits -= n;
; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));
; 2164 : }
; 2165 : 
; 2166 : // get some unsigned bits
; 2167 : stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
; 2168 : {
; 2169 :    unsigned int k;
; 2170 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2171 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2172 :    k = stbi_lrot(j->code_buffer, n);
; 2173 :    j->code_buffer = k & ~stbi__bmask[n];
; 2174 :    k &= stbi__bmask[n];
; 2175 :    j->code_bits -= n;
; 2176 :    return k;
; 2177 : }
; 2178 : 
; 2179 : stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
; 2180 : {
; 2181 :    unsigned int k;
; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2184 :    k = j->code_buffer;
; 2185 :    j->code_buffer <<= 1;
; 2186 :    --j->code_bits;
; 2187 :    return k & 0x80000000;
; 2188 : }
; 2189 : 
; 2190 : // given a value that's at position X in the zigzag stream,
; 2191 : // where does it appear in the 8x8 matrix coded as row-major?
; 2192 : static const stbi_uc stbi__jpeg_dezigzag[64+15] =
; 2193 : {
; 2194 :     0,  1,  8, 16,  9,  2,  3, 10,
; 2195 :    17, 24, 32, 25, 18, 11,  4,  5,
; 2196 :    12, 19, 26, 33, 40, 48, 41, 34,
; 2197 :    27, 20, 13,  6,  7, 14, 21, 28,
; 2198 :    35, 42, 49, 56, 57, 50, 43, 36,
; 2199 :    29, 22, 15, 23, 30, 37, 44, 51,
; 2200 :    58, 59, 52, 45, 38, 31, 39, 46,
; 2201 :    53, 60, 61, 54, 47, 55, 62, 63,
; 2202 :    // let corrupt input sample past end
; 2203 :    63, 63, 63, 63, 63, 63, 63, 63,
; 2204 :    63, 63, 63, 63, 63, 63, 63
; 2205 : };
; 2206 : 
; 2207 : // decode one 64-entry block--
; 2208 : static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
; 2209 : {
; 2210 :    int diff,dc,k;
; 2211 :    int t;
; 2212 : 
; 2213 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2214 :    t = stbi__jpeg_huff_decode(j, hdc);
; 2215 :    if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");
; 2216 : 
; 2217 :    // 0 all the ac values now so we can do it 32-bits at a time
; 2218 :    memset(data,0,64*sizeof(data[0]));
; 2219 : 
; 2220 :    diff = t ? stbi__extend_receive(j, t) : 0;
; 2221 :    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");
; 2222 :    dc = j->img_comp[b].dc_pred + diff;
; 2223 :    j->img_comp[b].dc_pred = dc;
; 2224 :    if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2225 :    data[0] = (short) (dc * dequant[0]);
; 2226 : 
; 2227 :    // decode AC components, see JPEG spec
; 2228 :    k = 1;
; 2229 :    do {
; 2230 :       unsigned int zig;
; 2231 :       int c,r,s;
; 2232 :       if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2233 :       c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2234 :       r = fac[c];
; 2235 :       if (r) { // fast-AC path
; 2236 :          k += (r >> 4) & 15; // run
; 2237 :          s = r & 15; // combined length
; 2238 :          if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2239 :          j->code_buffer <<= s;
; 2240 :          j->code_bits -= s;
; 2241 :          // decode into unzigzag'd location
; 2242 :          zig = stbi__jpeg_dezigzag[k++];
; 2243 :          data[zig] = (short) ((r >> 8) * dequant[zig]);
; 2244 :       } else {
; 2245 :          int rs = stbi__jpeg_huff_decode(j, hac);
; 2246 :          if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2247 :          s = rs & 15;
; 2248 :          r = rs >> 4;
; 2249 :          if (s == 0) {
; 2250 :             if (rs != 0xf0) break; // end block
; 2251 :             k += 16;
; 2252 :          } else {
; 2253 :             k += r;
; 2254 :             // decode into unzigzag'd location
; 2255 :             zig = stbi__jpeg_dezigzag[k++];
; 2256 :             data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
; 2257 :          }
; 2258 :       }
; 2259 :    } while (k < 64);
; 2260 :    return 1;
; 2261 : }
; 2262 : 
; 2263 : static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
; 2264 : {
; 2265 :    int diff,dc;
; 2266 :    int t;
; 2267 :    if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2268 : 
; 2269 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2270 : 
; 2271 :    if (j->succ_high == 0) {
; 2272 :       // first scan for DC coefficient, must be first
; 2273 :       memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
; 2274 :       t = stbi__jpeg_huff_decode(j, hdc);
; 2275 :       if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2276 :       diff = t ? stbi__extend_receive(j, t) : 0;
; 2277 : 
; 2278 :       if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");
; 2279 :       dc = j->img_comp[b].dc_pred + diff;
; 2280 :       j->img_comp[b].dc_pred = dc;
; 2281 :       if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2282 :       data[0] = (short) (dc * (1 << j->succ_low));
; 2283 :    } else {
; 2284 :       // refinement scan for DC coefficient
; 2285 :       if (stbi__jpeg_get_bit(j))
; 2286 :          data[0] += (short) (1 << j->succ_low);
; 2287 :    }
; 2288 :    return 1;
; 2289 : }
; 2290 : 
; 2291 : // @OPTIMIZE: store non-zigzagged during the decode passes,
; 2292 : // and only de-zigzag when dequantizing
; 2293 : static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
; 2294 : {
; 2295 :    int k;
; 2296 :    if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2297 : 
; 2298 :    if (j->succ_high == 0) {
; 2299 :       int shift = j->succ_low;
; 2300 : 
; 2301 :       if (j->eob_run) {
; 2302 :          --j->eob_run;
; 2303 :          return 1;
; 2304 :       }
; 2305 : 
; 2306 :       k = j->spec_start;
; 2307 :       do {
; 2308 :          unsigned int zig;
; 2309 :          int c,r,s;
; 2310 :          if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2311 :          c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2312 :          r = fac[c];
; 2313 :          if (r) { // fast-AC path
; 2314 :             k += (r >> 4) & 15; // run
; 2315 :             s = r & 15; // combined length
; 2316 :             if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2317 :             j->code_buffer <<= s;
; 2318 :             j->code_bits -= s;
; 2319 :             zig = stbi__jpeg_dezigzag[k++];
; 2320 :             data[zig] = (short) ((r >> 8) * (1 << shift));
; 2321 :          } else {
; 2322 :             int rs = stbi__jpeg_huff_decode(j, hac);
; 2323 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2324 :             s = rs & 15;
; 2325 :             r = rs >> 4;
; 2326 :             if (s == 0) {
; 2327 :                if (r < 15) {
; 2328 :                   j->eob_run = (1 << r);
; 2329 :                   if (r)
; 2330 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2331 :                   --j->eob_run;
; 2332 :                   break;
; 2333 :                }
; 2334 :                k += 16;
; 2335 :             } else {
; 2336 :                k += r;
; 2337 :                zig = stbi__jpeg_dezigzag[k++];
; 2338 :                data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
; 2339 :             }
; 2340 :          }
; 2341 :       } while (k <= j->spec_end);
; 2342 :    } else {
; 2343 :       // refinement scan for these AC coefficients
; 2344 : 
; 2345 :       short bit = (short) (1 << j->succ_low);
; 2346 : 
; 2347 :       if (j->eob_run) {
; 2348 :          --j->eob_run;
; 2349 :          for (k = j->spec_start; k <= j->spec_end; ++k) {
; 2350 :             short *p = &data[stbi__jpeg_dezigzag[k]];
; 2351 :             if (*p != 0)
; 2352 :                if (stbi__jpeg_get_bit(j))
; 2353 :                   if ((*p & bit)==0) {
; 2354 :                      if (*p > 0)
; 2355 :                         *p += bit;
; 2356 :                      else
; 2357 :                         *p -= bit;
; 2358 :                   }
; 2359 :          }
; 2360 :       } else {
; 2361 :          k = j->spec_start;
; 2362 :          do {
; 2363 :             int r,s;
; 2364 :             int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
; 2365 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2366 :             s = rs & 15;
; 2367 :             r = rs >> 4;
; 2368 :             if (s == 0) {
; 2369 :                if (r < 15) {
; 2370 :                   j->eob_run = (1 << r) - 1;
; 2371 :                   if (r)
; 2372 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2373 :                   r = 64; // force end of block
; 2374 :                } else {
; 2375 :                   // r=15 s=0 should write 16 0s, so we just do
; 2376 :                   // a run of 15 0s and then write s (which is 0),
; 2377 :                   // so we don't have to do anything special here
; 2378 :                }
; 2379 :             } else {
; 2380 :                if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
; 2381 :                // sign bit
; 2382 :                if (stbi__jpeg_get_bit(j))
; 2383 :                   s = bit;
; 2384 :                else
; 2385 :                   s = -bit;
; 2386 :             }
; 2387 : 
; 2388 :             // advance by r
; 2389 :             while (k <= j->spec_end) {
; 2390 :                short *p = &data[stbi__jpeg_dezigzag[k++]];
; 2391 :                if (*p != 0) {
; 2392 :                   if (stbi__jpeg_get_bit(j))
; 2393 :                      if ((*p & bit)==0) {
; 2394 :                         if (*p > 0)
; 2395 :                            *p += bit;
; 2396 :                         else
; 2397 :                            *p -= bit;
; 2398 :                      }
; 2399 :                } else {
; 2400 :                   if (r == 0) {
; 2401 :                      *p = (short) s;
; 2402 :                      break;
; 2403 :                   }
; 2404 :                   --r;
; 2405 :                }
; 2406 :             }
; 2407 :          } while (k <= j->spec_end);
; 2408 :       }
; 2409 :    }
; 2410 :    return 1;
; 2411 : }
; 2412 : 
; 2413 : // take a -128..127 value and stbi__clamp it and convert to 0..255
; 2414 : stbi_inline static stbi_uc stbi__clamp(int x)
; 2415 : {
; 2416 :    // trick to use a single test to catch both cases
; 2417 :    if ((unsigned int) x > 255) {
; 2418 :       if (x < 0) return 0;
; 2419 :       if (x > 255) return 255;
; 2420 :    }
; 2421 :    return (stbi_uc) x;
; 2422 : }
; 2423 : 
; 2424 : #define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
; 2425 : #define stbi__fsh(x)  ((x) * 4096)
; 2426 : 
; 2427 : // derived from jidctint -- DCT_ISLOW
; 2428 : #define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
; 2429 :    int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
; 2430 :    p2 = s2;                                    \
; 2431 :    p3 = s6;                                    \
; 2432 :    p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
; 2433 :    t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
; 2434 :    t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
; 2435 :    p2 = s0;                                    \
; 2436 :    p3 = s4;                                    \
; 2437 :    t0 = stbi__fsh(p2+p3);                      \
; 2438 :    t1 = stbi__fsh(p2-p3);                      \
; 2439 :    x0 = t0+t3;                                 \
; 2440 :    x3 = t0-t3;                                 \
; 2441 :    x1 = t1+t2;                                 \
; 2442 :    x2 = t1-t2;                                 \
; 2443 :    t0 = s7;                                    \
; 2444 :    t1 = s5;                                    \
; 2445 :    t2 = s3;                                    \
; 2446 :    t3 = s1;                                    \
; 2447 :    p3 = t0+t2;                                 \
; 2448 :    p4 = t1+t3;                                 \
; 2449 :    p1 = t0+t3;                                 \
; 2450 :    p2 = t1+t2;                                 \
; 2451 :    p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
; 2452 :    t0 = t0*stbi__f2f( 0.298631336f);           \
; 2453 :    t1 = t1*stbi__f2f( 2.053119869f);           \
; 2454 :    t2 = t2*stbi__f2f( 3.072711026f);           \
; 2455 :    t3 = t3*stbi__f2f( 1.501321110f);           \
; 2456 :    p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
; 2457 :    p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
; 2458 :    p3 = p3*stbi__f2f(-1.961570560f);           \
; 2459 :    p4 = p4*stbi__f2f(-0.390180644f);           \
; 2460 :    t3 += p1+p4;                                \
; 2461 :    t2 += p2+p3;                                \
; 2462 :    t1 += p2+p4;                                \
; 2463 :    t0 += p1+p3;
; 2464 : 
; 2465 : static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
; 2466 : {
; 2467 :    int i,val[64],*v=val;
; 2468 :    stbi_uc *o;
; 2469 :    short *d = data;
; 2470 : 
; 2471 :    // columns
; 2472 :    for (i=0; i < 8; ++i,++d, ++v) {
; 2473 :       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2474 :       if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2475 :            && d[40]==0 && d[48]==0 && d[56]==0) {
; 2476 :          //    no shortcut                 0     seconds
; 2477 :          //    (1|2|3|4|5|6|7)==0          0     seconds
; 2478 :          //    all separate               -0.047 seconds
; 2479 :          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2480 :          int dcterm = d[0]*4;
; 2481 :          v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
; 2482 :       } else {
; 2483 :          STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
; 2484 :          // constants scaled things up by 1<<12; let's bring them back
; 2485 :          // down, but keep 2 extra bits of precision
; 2486 :          x0 += 512; x1 += 512; x2 += 512; x3 += 512;
; 2487 :          v[ 0] = (x0+t3) >> 10;
; 2488 :          v[56] = (x0-t3) >> 10;
; 2489 :          v[ 8] = (x1+t2) >> 10;
; 2490 :          v[48] = (x1-t2) >> 10;
; 2491 :          v[16] = (x2+t1) >> 10;
; 2492 :          v[40] = (x2-t1) >> 10;
; 2493 :          v[24] = (x3+t0) >> 10;
; 2494 :          v[32] = (x3-t0) >> 10;
; 2495 :       }
; 2496 :    }
; 2497 : 
; 2498 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
; 2499 :       // no fast case since the first 1D IDCT spread components out
; 2500 :       STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
; 2501 :       // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2502 :       // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2503 :       // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2504 :       // so we want to round that, which means adding 0.5 * 1<<17,
; 2505 :       // aka 65536. Also, we'll end up with -128 to 127 that we want
; 2506 :       // to encode as 0..255 by adding 128, so we'll add that before the shift
; 2507 :       x0 += 65536 + (128<<17);
; 2508 :       x1 += 65536 + (128<<17);
; 2509 :       x2 += 65536 + (128<<17);
; 2510 :       x3 += 65536 + (128<<17);
; 2511 :       // tried computing the shifts into temps, or'ing the temps to see
; 2512 :       // if any were out of range, but that was slower
; 2513 :       o[0] = stbi__clamp((x0+t3) >> 17);
; 2514 :       o[7] = stbi__clamp((x0-t3) >> 17);
; 2515 :       o[1] = stbi__clamp((x1+t2) >> 17);
; 2516 :       o[6] = stbi__clamp((x1-t2) >> 17);
; 2517 :       o[2] = stbi__clamp((x2+t1) >> 17);
; 2518 :       o[5] = stbi__clamp((x2-t1) >> 17);
; 2519 :       o[3] = stbi__clamp((x3+t0) >> 17);
; 2520 :       o[4] = stbi__clamp((x3-t0) >> 17);
; 2521 :    }
; 2522 : }
; 2523 : 
; 2524 : #ifdef STBI_SSE2
; 2525 : // sse2 integer IDCT. not the fastest possible implementation but it
; 2526 : // produces bit-identical results to the generic C version so it's
; 2527 : // fully "transparent".
; 2528 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2529 : {
; 2530 :    // This is constructed to match our regular (generic) integer IDCT exactly.
; 2531 :    __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2532 :    __m128i tmp;
; 2533 : 
; 2534 :    // dot product constant: even elems=x, odd elems=y
; 2535 :    #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2536 : 
; 2537 :    // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2538 :    // out(1) = c1[even]*x + c1[odd]*y
; 2539 :    #define dct_rot(out0,out1, x,y,c0,c1) \
; 2540 :       __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2541 :       __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2542 :       __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2543 :       __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2544 :       __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2545 :       __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2546 : 
; 2547 :    // out = in << 12  (in 16-bit, out 32-bit)
; 2548 :    #define dct_widen(out, in) \
; 2549 :       __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2550 :       __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2551 : 
; 2552 :    // wide add
; 2553 :    #define dct_wadd(out, a, b) \
; 2554 :       __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2555 :       __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2556 : 
; 2557 :    // wide sub
; 2558 :    #define dct_wsub(out, a, b) \
; 2559 :       __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2560 :       __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2561 : 
; 2562 :    // butterfly a/b, add bias, then shift by "s" and pack
; 2563 :    #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2564 :       { \
; 2565 :          __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2566 :          __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2567 :          dct_wadd(sum, abiased, b); \
; 2568 :          dct_wsub(dif, abiased, b); \
; 2569 :          out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2570 :          out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2571 :       }
; 2572 : 
; 2573 :    // 8-bit interleave step (for transposes)
; 2574 :    #define dct_interleave8(a, b) \
; 2575 :       tmp = a; \
; 2576 :       a = _mm_unpacklo_epi8(a, b); \
; 2577 :       b = _mm_unpackhi_epi8(tmp, b)
; 2578 : 
; 2579 :    // 16-bit interleave step (for transposes)
; 2580 :    #define dct_interleave16(a, b) \
; 2581 :       tmp = a; \
; 2582 :       a = _mm_unpacklo_epi16(a, b); \
; 2583 :       b = _mm_unpackhi_epi16(tmp, b)
; 2584 : 
; 2585 :    #define dct_pass(bias,shift) \
; 2586 :       { \
; 2587 :          /* even part */ \
; 2588 :          dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2589 :          __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2590 :          __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2591 :          dct_widen(t0e, sum04); \
; 2592 :          dct_widen(t1e, dif04); \
; 2593 :          dct_wadd(x0, t0e, t3e); \
; 2594 :          dct_wsub(x3, t0e, t3e); \
; 2595 :          dct_wadd(x1, t1e, t2e); \
; 2596 :          dct_wsub(x2, t1e, t2e); \
; 2597 :          /* odd part */ \
; 2598 :          dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2599 :          dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2600 :          __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2601 :          __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2602 :          dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2603 :          dct_wadd(x4, y0o, y4o); \
; 2604 :          dct_wadd(x5, y1o, y5o); \
; 2605 :          dct_wadd(x6, y2o, y5o); \
; 2606 :          dct_wadd(x7, y3o, y4o); \
; 2607 :          dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2608 :          dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2609 :          dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2610 :          dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2611 :       }
; 2612 : 
; 2613 :    __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
; 2614 :    __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
; 2615 :    __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
; 2616 :    __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
; 2617 :    __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
; 2618 :    __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
; 2619 :    __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
; 2620 :    __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
; 2621 : 
; 2622 :    // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2623 :    __m128i bias_0 = _mm_set1_epi32(512);
; 2624 :    __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
; 2625 : 
; 2626 :    // load
; 2627 :    row0 = _mm_load_si128((const __m128i *) (data + 0*8));
; 2628 :    row1 = _mm_load_si128((const __m128i *) (data + 1*8));
; 2629 :    row2 = _mm_load_si128((const __m128i *) (data + 2*8));
; 2630 :    row3 = _mm_load_si128((const __m128i *) (data + 3*8));
; 2631 :    row4 = _mm_load_si128((const __m128i *) (data + 4*8));
; 2632 :    row5 = _mm_load_si128((const __m128i *) (data + 5*8));
; 2633 :    row6 = _mm_load_si128((const __m128i *) (data + 6*8));
; 2634 :    row7 = _mm_load_si128((const __m128i *) (data + 7*8));
; 2635 : 
; 2636 :    // column pass
; 2637 :    dct_pass(bias_0, 10);
; 2638 : 
; 2639 :    {
; 2640 :       // 16bit 8x8 transpose pass 1
; 2641 :       dct_interleave16(row0, row4);
; 2642 :       dct_interleave16(row1, row5);
; 2643 :       dct_interleave16(row2, row6);
; 2644 :       dct_interleave16(row3, row7);
; 2645 : 
; 2646 :       // transpose pass 2
; 2647 :       dct_interleave16(row0, row2);
; 2648 :       dct_interleave16(row1, row3);
; 2649 :       dct_interleave16(row4, row6);
; 2650 :       dct_interleave16(row5, row7);
; 2651 : 
; 2652 :       // transpose pass 3
; 2653 :       dct_interleave16(row0, row1);
; 2654 :       dct_interleave16(row2, row3);
; 2655 :       dct_interleave16(row4, row5);
; 2656 :       dct_interleave16(row6, row7);
; 2657 :    }
; 2658 : 
; 2659 :    // row pass
; 2660 :    dct_pass(bias_1, 17);
; 2661 : 
; 2662 :    {
; 2663 :       // pack
; 2664 :       __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
; 2665 :       __m128i p1 = _mm_packus_epi16(row2, row3);
; 2666 :       __m128i p2 = _mm_packus_epi16(row4, row5);
; 2667 :       __m128i p3 = _mm_packus_epi16(row6, row7);
; 2668 : 
; 2669 :       // 8bit 8x8 transpose pass 1
; 2670 :       dct_interleave8(p0, p2); // a0e0a1e1...
; 2671 :       dct_interleave8(p1, p3); // c0g0c1g1...
; 2672 : 
; 2673 :       // transpose pass 2
; 2674 :       dct_interleave8(p0, p1); // a0c0e0g0...
; 2675 :       dct_interleave8(p2, p3); // b0d0f0h0...
; 2676 : 
; 2677 :       // transpose pass 3
; 2678 :       dct_interleave8(p0, p2); // a0b0c0d0...
; 2679 :       dct_interleave8(p1, p3); // a4b4c4d4...
; 2680 : 
; 2681 :       // store
; 2682 :       _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
; 2683 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
; 2684 :       _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
; 2685 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
; 2686 :       _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
; 2687 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
; 2688 :       _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
; 2689 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
; 2690 :    }
; 2691 : 
; 2692 : #undef dct_const
; 2693 : #undef dct_rot
; 2694 : #undef dct_widen
; 2695 : #undef dct_wadd
; 2696 : #undef dct_wsub
; 2697 : #undef dct_bfly32o
; 2698 : #undef dct_interleave8
; 2699 : #undef dct_interleave16
; 2700 : #undef dct_pass
; 2701 : }
; 2702 : 
; 2703 : #endif // STBI_SSE2
; 2704 : 
; 2705 : #ifdef STBI_NEON
; 2706 : 
; 2707 : // NEON integer IDCT. should produce bit-identical
; 2708 : // results to the generic C version.
; 2709 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2710 : {
; 2711 :    int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;
; 2712 : 
; 2713 :    int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
; 2714 :    int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
; 2715 :    int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
; 2716 :    int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
; 2717 :    int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
; 2718 :    int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
; 2719 :    int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
; 2720 :    int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
; 2721 :    int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
; 2722 :    int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
; 2723 :    int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
; 2724 :    int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));
; 2725 : 
; 2726 : #define dct_long_mul(out, inq, coeff) \
; 2727 :    int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
; 2728 :    int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)
; 2729 : 
; 2730 : #define dct_long_mac(out, acc, inq, coeff) \
; 2731 :    int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
; 2732 :    int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)
; 2733 : 
; 2734 : #define dct_widen(out, inq) \
; 2735 :    int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
; 2736 :    int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)
; 2737 : 
; 2738 : // wide add
; 2739 : #define dct_wadd(out, a, b) \
; 2740 :    int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
; 2741 :    int32x4_t out##_h = vaddq_s32(a##_h, b##_h)
; 2742 : 
; 2743 : // wide sub
; 2744 : #define dct_wsub(out, a, b) \
; 2745 :    int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
; 2746 :    int32x4_t out##_h = vsubq_s32(a##_h, b##_h)
; 2747 : 
; 2748 : // butterfly a/b, then shift using "shiftop" by "s" and pack
; 2749 : #define dct_bfly32o(out0,out1, a,b,shiftop,s) \
; 2750 :    { \
; 2751 :       dct_wadd(sum, a, b); \
; 2752 :       dct_wsub(dif, a, b); \
; 2753 :       out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
; 2754 :       out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
; 2755 :    }
; 2756 : 
; 2757 : #define dct_pass(shiftop, shift) \
; 2758 :    { \
; 2759 :       /* even part */ \
; 2760 :       int16x8_t sum26 = vaddq_s16(row2, row6); \
; 2761 :       dct_long_mul(p1e, sum26, rot0_0); \
; 2762 :       dct_long_mac(t2e, p1e, row6, rot0_1); \
; 2763 :       dct_long_mac(t3e, p1e, row2, rot0_2); \
; 2764 :       int16x8_t sum04 = vaddq_s16(row0, row4); \
; 2765 :       int16x8_t dif04 = vsubq_s16(row0, row4); \
; 2766 :       dct_widen(t0e, sum04); \
; 2767 :       dct_widen(t1e, dif04); \
; 2768 :       dct_wadd(x0, t0e, t3e); \
; 2769 :       dct_wsub(x3, t0e, t3e); \
; 2770 :       dct_wadd(x1, t1e, t2e); \
; 2771 :       dct_wsub(x2, t1e, t2e); \
; 2772 :       /* odd part */ \
; 2773 :       int16x8_t sum15 = vaddq_s16(row1, row5); \
; 2774 :       int16x8_t sum17 = vaddq_s16(row1, row7); \
; 2775 :       int16x8_t sum35 = vaddq_s16(row3, row5); \
; 2776 :       int16x8_t sum37 = vaddq_s16(row3, row7); \
; 2777 :       int16x8_t sumodd = vaddq_s16(sum17, sum35); \
; 2778 :       dct_long_mul(p5o, sumodd, rot1_0); \
; 2779 :       dct_long_mac(p1o, p5o, sum17, rot1_1); \
; 2780 :       dct_long_mac(p2o, p5o, sum35, rot1_2); \
; 2781 :       dct_long_mul(p3o, sum37, rot2_0); \
; 2782 :       dct_long_mul(p4o, sum15, rot2_1); \
; 2783 :       dct_wadd(sump13o, p1o, p3o); \
; 2784 :       dct_wadd(sump24o, p2o, p4o); \
; 2785 :       dct_wadd(sump23o, p2o, p3o); \
; 2786 :       dct_wadd(sump14o, p1o, p4o); \
; 2787 :       dct_long_mac(x4, sump13o, row7, rot3_0); \
; 2788 :       dct_long_mac(x5, sump24o, row5, rot3_1); \
; 2789 :       dct_long_mac(x6, sump23o, row3, rot3_2); \
; 2790 :       dct_long_mac(x7, sump14o, row1, rot3_3); \
; 2791 :       dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
; 2792 :       dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
; 2793 :       dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
; 2794 :       dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
; 2795 :    }
; 2796 : 
; 2797 :    // load
; 2798 :    row0 = vld1q_s16(data + 0*8);
; 2799 :    row1 = vld1q_s16(data + 1*8);
; 2800 :    row2 = vld1q_s16(data + 2*8);
; 2801 :    row3 = vld1q_s16(data + 3*8);
; 2802 :    row4 = vld1q_s16(data + 4*8);
; 2803 :    row5 = vld1q_s16(data + 5*8);
; 2804 :    row6 = vld1q_s16(data + 6*8);
; 2805 :    row7 = vld1q_s16(data + 7*8);
; 2806 : 
; 2807 :    // add DC bias
; 2808 :    row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));
; 2809 : 
; 2810 :    // column pass
; 2811 :    dct_pass(vrshrn_n_s32, 10);
; 2812 : 
; 2813 :    // 16bit 8x8 transpose
; 2814 :    {
; 2815 : // these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
; 2816 : // whether compilers actually get this is another story, sadly.
; 2817 : #define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
; 2818 : #define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
; 2819 : #define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }
; 2820 : 
; 2821 :       // pass 1
; 2822 :       dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
; 2823 :       dct_trn16(row2, row3);
; 2824 :       dct_trn16(row4, row5);
; 2825 :       dct_trn16(row6, row7);
; 2826 : 
; 2827 :       // pass 2
; 2828 :       dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
; 2829 :       dct_trn32(row1, row3);
; 2830 :       dct_trn32(row4, row6);
; 2831 :       dct_trn32(row5, row7);
; 2832 : 
; 2833 :       // pass 3
; 2834 :       dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
; 2835 :       dct_trn64(row1, row5);
; 2836 :       dct_trn64(row2, row6);
; 2837 :       dct_trn64(row3, row7);
; 2838 : 
; 2839 : #undef dct_trn16
; 2840 : #undef dct_trn32
; 2841 : #undef dct_trn64
; 2842 :    }
; 2843 : 
; 2844 :    // row pass
; 2845 :    // vrshrn_n_s32 only supports shifts up to 16, we need
; 2846 :    // 17. so do a non-rounding shift of 16 first then follow
; 2847 :    // up with a rounding shift by 1.
; 2848 :    dct_pass(vshrn_n_s32, 16);
; 2849 : 
; 2850 :    {
; 2851 :       // pack and round
; 2852 :       uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
; 2853 :       uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
; 2854 :       uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
; 2855 :       uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
; 2856 :       uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
; 2857 :       uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
; 2858 :       uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
; 2859 :       uint8x8_t p7 = vqrshrun_n_s16(row7, 1);
; 2860 : 
; 2861 :       // again, these can translate into one instruction, but often don't.
; 2862 : #define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
; 2863 : #define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
; 2864 : #define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }
; 2865 : 
; 2866 :       // sadly can't use interleaved stores here since we only write
; 2867 :       // 8 bytes to each scan line!
; 2868 : 
; 2869 :       // 8x8 8-bit transpose pass 1
; 2870 :       dct_trn8_8(p0, p1);
; 2871 :       dct_trn8_8(p2, p3);
; 2872 :       dct_trn8_8(p4, p5);
; 2873 :       dct_trn8_8(p6, p7);
; 2874 : 
; 2875 :       // pass 2
; 2876 :       dct_trn8_16(p0, p2);
; 2877 :       dct_trn8_16(p1, p3);
; 2878 :       dct_trn8_16(p4, p6);
; 2879 :       dct_trn8_16(p5, p7);
; 2880 : 
; 2881 :       // pass 3
; 2882 :       dct_trn8_32(p0, p4);
; 2883 :       dct_trn8_32(p1, p5);
; 2884 :       dct_trn8_32(p2, p6);
; 2885 :       dct_trn8_32(p3, p7);
; 2886 : 
; 2887 :       // store
; 2888 :       vst1_u8(out, p0); out += out_stride;
; 2889 :       vst1_u8(out, p1); out += out_stride;
; 2890 :       vst1_u8(out, p2); out += out_stride;
; 2891 :       vst1_u8(out, p3); out += out_stride;
; 2892 :       vst1_u8(out, p4); out += out_stride;
; 2893 :       vst1_u8(out, p5); out += out_stride;
; 2894 :       vst1_u8(out, p6); out += out_stride;
; 2895 :       vst1_u8(out, p7);
; 2896 : 
; 2897 : #undef dct_trn8_8
; 2898 : #undef dct_trn8_16
; 2899 : #undef dct_trn8_32
; 2900 :    }
; 2901 : 
; 2902 : #undef dct_long_mul
; 2903 : #undef dct_long_mac
; 2904 : #undef dct_widen
; 2905 : #undef dct_wadd
; 2906 : #undef dct_wsub
; 2907 : #undef dct_bfly32o
; 2908 : #undef dct_pass
; 2909 : }
; 2910 : 
; 2911 : #endif // STBI_NEON
; 2912 : 
; 2913 : #define STBI__MARKER_none  0xff
; 2914 : // if there's a pending marker from the entropy stream, return that
; 2915 : // otherwise, fetch from the stream and get a marker. if there's no
; 2916 : // marker, return 0xff, which is never a valid marker value
; 2917 : static stbi_uc stbi__get_marker(stbi__jpeg *j)
; 2918 : {
; 2919 :    stbi_uc x;
; 2920 :    if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
; 2921 :    x = stbi__get8(j->s);
; 2922 :    if (x != 0xff) return STBI__MARKER_none;
; 2923 :    while (x == 0xff)
; 2924 :       x = stbi__get8(j->s); // consume repeated 0xff fill bytes
; 2925 :    return x;
; 2926 : }
; 2927 : 
; 2928 : // in each scan, we'll have scan_n components, and the order
; 2929 : // of the components is specified by order[]
; 2930 : #define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
; 2931 : 
; 2932 : // after a restart interval, stbi__jpeg_reset the entropy decoder and
; 2933 : // the dc prediction
; 2934 : static void stbi__jpeg_reset(stbi__jpeg *j)
; 2935 : {
; 2936 :    j->code_bits = 0;
; 2937 :    j->code_buffer = 0;
; 2938 :    j->nomore = 0;
; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
; 2940 :    j->marker = STBI__MARKER_none;
; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
; 2942 :    j->eob_run = 0;
; 2943 :    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2944 :    // since we don't even allow 1<<30 pixels
; 2945 : }
; 2946 : 
; 2947 : static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
; 2948 : {
; 2949 :    stbi__jpeg_reset(z);
; 2950 :    if (!z->progressive) {
; 2951 :       if (z->scan_n == 1) {
; 2952 :          int i,j;
; 2953 :          STBI_SIMD_ALIGN(short, data[64]);
; 2954 :          int n = z->order[0];
; 2955 :          // non-interleaved data, we just need to process one block at a time,
; 2956 :          // in trivial scanline order
; 2957 :          // number of blocks to do just depends on how many actual "pixels" this
; 2958 :          // component has, independent of interleaved MCU blocking and such
; 2959 :          int w = (z->img_comp[n].x+7) >> 3;
; 2960 :          int h = (z->img_comp[n].y+7) >> 3;
; 2961 :          for (j=0; j < h; ++j) {
; 2962 :             for (i=0; i < w; ++i) {
; 2963 :                int ha = z->img_comp[n].ha;
; 2964 :                if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2965 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 2966 :                // every data block is an MCU, so countdown the restart interval
; 2967 :                if (--z->todo <= 0) {
; 2968 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 2969 :                   // if it's NOT a restart, then just bail, so we get corrupt data
; 2970 :                   // rather than no data
; 2971 :                   if (!STBI__RESTART(z->marker)) return 1;
; 2972 :                   stbi__jpeg_reset(z);
; 2973 :                }
; 2974 :             }
; 2975 :          }
; 2976 :          return 1;
; 2977 :       } else { // interleaved
; 2978 :          int i,j,k,x,y;
; 2979 :          STBI_SIMD_ALIGN(short, data[64]);
; 2980 :          for (j=0; j < z->img_mcu_y; ++j) {
; 2981 :             for (i=0; i < z->img_mcu_x; ++i) {
; 2982 :                // scan an interleaved mcu... process scan_n components in order
; 2983 :                for (k=0; k < z->scan_n; ++k) {
; 2984 :                   int n = z->order[k];
; 2985 :                   // scan out an mcu's worth of this component; that's just determined
; 2986 :                   // by the basic H and V specified for the component
; 2987 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 2988 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 2989 :                         int x2 = (i*z->img_comp[n].h + x)*8;
; 2990 :                         int y2 = (j*z->img_comp[n].v + y)*8;
; 2991 :                         int ha = z->img_comp[n].ha;
; 2992 :                         if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2993 :                         z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
; 2994 :                      }
; 2995 :                   }
; 2996 :                }
; 2997 :                // after all interleaved components, that's an interleaved MCU,
; 2998 :                // so now count down the restart interval
; 2999 :                if (--z->todo <= 0) {
; 3000 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3001 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3002 :                   stbi__jpeg_reset(z);
; 3003 :                }
; 3004 :             }
; 3005 :          }
; 3006 :          return 1;
; 3007 :       }
; 3008 :    } else {
; 3009 :       if (z->scan_n == 1) {
; 3010 :          int i,j;
; 3011 :          int n = z->order[0];
; 3012 :          // non-interleaved data, we just need to process one block at a time,
; 3013 :          // in trivial scanline order
; 3014 :          // number of blocks to do just depends on how many actual "pixels" this
; 3015 :          // component has, independent of interleaved MCU blocking and such
; 3016 :          int w = (z->img_comp[n].x+7) >> 3;
; 3017 :          int h = (z->img_comp[n].y+7) >> 3;
; 3018 :          for (j=0; j < h; ++j) {
; 3019 :             for (i=0; i < w; ++i) {
; 3020 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3021 :                if (z->spec_start == 0) {
; 3022 :                   if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3023 :                      return 0;
; 3024 :                } else {
; 3025 :                   int ha = z->img_comp[n].ha;
; 3026 :                   if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
; 3027 :                      return 0;
; 3028 :                }
; 3029 :                // every data block is an MCU, so countdown the restart interval
; 3030 :                if (--z->todo <= 0) {
; 3031 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3032 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3033 :                   stbi__jpeg_reset(z);
; 3034 :                }
; 3035 :             }
; 3036 :          }
; 3037 :          return 1;
; 3038 :       } else { // interleaved
; 3039 :          int i,j,k,x,y;
; 3040 :          for (j=0; j < z->img_mcu_y; ++j) {
; 3041 :             for (i=0; i < z->img_mcu_x; ++i) {
; 3042 :                // scan an interleaved mcu... process scan_n components in order
; 3043 :                for (k=0; k < z->scan_n; ++k) {
; 3044 :                   int n = z->order[k];
; 3045 :                   // scan out an mcu's worth of this component; that's just determined
; 3046 :                   // by the basic H and V specified for the component
; 3047 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 3048 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 3049 :                         int x2 = (i*z->img_comp[n].h + x);
; 3050 :                         int y2 = (j*z->img_comp[n].v + y);
; 3051 :                         short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
; 3052 :                         if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3053 :                            return 0;
; 3054 :                      }
; 3055 :                   }
; 3056 :                }
; 3057 :                // after all interleaved components, that's an interleaved MCU,
; 3058 :                // so now count down the restart interval
; 3059 :                if (--z->todo <= 0) {
; 3060 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3061 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3062 :                   stbi__jpeg_reset(z);
; 3063 :                }
; 3064 :             }
; 3065 :          }
; 3066 :          return 1;
; 3067 :       }
; 3068 :    }
; 3069 : }
; 3070 : 
; 3071 : static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
; 3072 : {
; 3073 :    int i;
; 3074 :    for (i=0; i < 64; ++i)
; 3075 :       data[i] *= dequant[i];
; 3076 : }
; 3077 : 
; 3078 : static void stbi__jpeg_finish(stbi__jpeg *z)
; 3079 : {
; 3080 :    if (z->progressive) {
; 3081 :       // dequantize and idct the data
; 3082 :       int i,j,n;
; 3083 :       for (n=0; n < z->s->img_n; ++n) {
; 3084 :          int w = (z->img_comp[n].x+7) >> 3;
; 3085 :          int h = (z->img_comp[n].y+7) >> 3;
; 3086 :          for (j=0; j < h; ++j) {
; 3087 :             for (i=0; i < w; ++i) {
; 3088 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3089 :                stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
; 3090 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 3091 :             }
; 3092 :          }
; 3093 :       }
; 3094 :    }
; 3095 : }
; 3096 : 
; 3097 : static int stbi__process_marker(stbi__jpeg *z, int m)
; 3098 : {
; 3099 :    int L;
; 3100 :    switch (m) {
; 3101 :       case STBI__MARKER_none: // no marker found
; 3102 :          return stbi__err("expected marker","Corrupt JPEG");
; 3103 : 
; 3104 :       case 0xDD: // DRI - specify restart interval
; 3105 :          if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
; 3106 :          z->restart_interval = stbi__get16be(z->s);
; 3107 :          return 1;
; 3108 : 
; 3109 :       case 0xDB: // DQT - define quantization table
; 3110 :          L = stbi__get16be(z->s)-2;
; 3111 :          while (L > 0) {
; 3112 :             int q = stbi__get8(z->s);
; 3113 :             int p = q >> 4, sixteen = (p != 0);
; 3114 :             int t = q & 15,i;
; 3115 :             if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
; 3116 :             if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");
; 3117 : 
; 3118 :             for (i=0; i < 64; ++i)
; 3119 :                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
; 3120 :             L -= (sixteen ? 129 : 65);
; 3121 :          }
; 3122 :          return L==0;
; 3123 : 
; 3124 :       case 0xC4: // DHT - define huffman table
; 3125 :          L = stbi__get16be(z->s)-2;
; 3126 :          while (L > 0) {
; 3127 :             stbi_uc *v;
; 3128 :             int sizes[16],i,n=0;
; 3129 :             int q = stbi__get8(z->s);
; 3130 :             int tc = q >> 4;
; 3131 :             int th = q & 15;
; 3132 :             if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
; 3133 :             for (i=0; i < 16; ++i) {
; 3134 :                sizes[i] = stbi__get8(z->s);
; 3135 :                n += sizes[i];
; 3136 :             }
; 3137 :             if(n > 256) return stbi__err("bad DHT header","Corrupt JPEG"); // Loop over i < n would write past end of values!
; 3138 :             L -= 17;
; 3139 :             if (tc == 0) {
; 3140 :                if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
; 3141 :                v = z->huff_dc[th].values;
; 3142 :             } else {
; 3143 :                if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
; 3144 :                v = z->huff_ac[th].values;
; 3145 :             }
; 3146 :             for (i=0; i < n; ++i)
; 3147 :                v[i] = stbi__get8(z->s);
; 3148 :             if (tc != 0)
; 3149 :                stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
; 3150 :             L -= n;
; 3151 :          }
; 3152 :          return L==0;
; 3153 :    }
; 3154 : 
; 3155 :    // check for comment block or APP blocks
; 3156 :    if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
; 3157 :       L = stbi__get16be(z->s);
; 3158 :       if (L < 2) {
; 3159 :          if (m == 0xFE)
; 3160 :             return stbi__err("bad COM len","Corrupt JPEG");
; 3161 :          else
; 3162 :             return stbi__err("bad APP len","Corrupt JPEG");
; 3163 :       }
; 3164 :       L -= 2;
; 3165 : 
; 3166 :       if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
; 3167 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3168 :          int ok = 1;
; 3169 :          int i;
; 3170 :          for (i=0; i < 5; ++i)
; 3171 :             if (stbi__get8(z->s) != tag[i])
; 3172 :                ok = 0;
; 3173 :          L -= 5;
; 3174 :          if (ok)
; 3175 :             z->jfif = 1;
; 3176 :       } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;
; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)
; 3181 :             if (stbi__get8(z->s) != tag[i])
; 3182 :                ok = 0;
; 3183 :          L -= 6;
; 3184 :          if (ok) {
; 3185 :             stbi__get8(z->s); // version
; 3186 :             stbi__get16be(z->s); // flags0
; 3187 :             stbi__get16be(z->s); // flags1
; 3188 :             z->app14_color_transform = stbi__get8(z->s); // color transform
; 3189 :             L -= 6;
; 3190 :          }
; 3191 :       }
; 3192 : 
; 3193 :       stbi__skip(z->s, L);
; 3194 :       return 1;
; 3195 :    }
; 3196 : 
; 3197 :    return stbi__err("unknown marker","Corrupt JPEG");
; 3198 : }
; 3199 : 
; 3200 : // after we see SOS
; 3201 : static int stbi__process_scan_header(stbi__jpeg *z)
; 3202 : {
; 3203 :    int i;
; 3204 :    int Ls = stbi__get16be(z->s);
; 3205 :    z->scan_n = stbi__get8(z->s);
; 3206 :    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
; 3207 :    if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
; 3208 :    for (i=0; i < z->scan_n; ++i) {
; 3209 :       int id = stbi__get8(z->s), which;
; 3210 :       int q = stbi__get8(z->s);
; 3211 :       for (which = 0; which < z->s->img_n; ++which)
; 3212 :          if (z->img_comp[which].id == id)
; 3213 :             break;
; 3214 :       if (which == z->s->img_n) return 0; // no match
; 3215 :       z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
; 3216 :       z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
; 3217 :       z->order[i] = which;
; 3218 :    }
; 3219 : 
; 3220 :    {
; 3221 :       int aa;
; 3222 :       z->spec_start = stbi__get8(z->s);
; 3223 :       z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
; 3224 :       aa = stbi__get8(z->s);
; 3225 :       z->succ_high = (aa >> 4);
; 3226 :       z->succ_low  = (aa & 15);
; 3227 :       if (z->progressive) {
; 3228 :          if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
; 3229 :             return stbi__err("bad SOS", "Corrupt JPEG");
; 3230 :       } else {
; 3231 :          if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3232 :          if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3233 :          z->spec_end = 63;
; 3234 :       }
; 3235 :    }
; 3236 : 
; 3237 :    return 1;
; 3238 : }
; 3239 : 
; 3240 : static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
; 3241 : {
; 3242 :    int i;
; 3243 :    for (i=0; i < ncomp; ++i) {

	add	rdi, 96					; 00000060H
	sub	rbx, 1
	jne	SHORT $LL184@load_jpeg_

; 3883 : 
; 3884 :    // nothing to do if no components requested; check this now to avoid
; 3885 :    // accessing uninitialized coutput[0] later
; 3886 :    if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }

	xor	eax, eax
	jmp	$LN1@load_jpeg_
$LN43@load_jpeg_:

; 3873 : 
; 3874 :    // determine actual number of components to generate
; 3875 :    n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;
; 3876 : 
; 3877 :    is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

	mov	r14d, 1
	cmp	edx, 3
	jne	$LN87@load_jpeg_
	cmp	DWORD PTR [rdi+18512], edx
	je	SHORT $LN86@load_jpeg_
	cmp	DWORD PTR [rdi+18508], ebp
	jne	$LN87@load_jpeg_
	cmp	DWORD PTR [rdi+18504], ebp
	jne	$LN87@load_jpeg_
$LN86@load_jpeg_:
	mov	QWORD PTR tv5439[rsp], r14
	mov	r12, rdx
$LN46@load_jpeg_:

; 3887 : 
; 3888 :    // resample and color-convert
; 3889 :    {
; 3890 :       int k;
; 3891 :       unsigned int i,j;
; 3892 :       stbi_uc *output;
; 3893 :       stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };

	mov	QWORD PTR [rsp+368], rsi
	xorps	xmm0, xmm0
	mov	QWORD PTR [rsp+360], r13
	xorps	xmm1, xmm1
	movdqu	XMMWORD PTR coutput$1[rsp], xmm0
	movdqu	XMMWORD PTR coutput$1[rsp+16], xmm1

; 3894 : 
; 3895 :       stbi__resample res_comp[4];
; 3896 : 
; 3897 :       for (k=0; k < decode_n; ++k) {

	test	r12, r12
	jle	$LN3@load_jpeg_
	lea	rbx, QWORD PTR res_comp$2[rsp+24]
	xor	r13d, r13d
	lea	rsi, QWORD PTR [rdi+18084]
	npad	12
$LL4@load_jpeg_:

; 3898 :          stbi__resample *r = &res_comp[k];
; 3899 : 
; 3900 :          // allocate line buffer big enough for upsampling off the edges
; 3901 :          // with upsample factor of 4
; 3902 :          z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);

	mov	rax, QWORD PTR [rdi]
	mov	ecx, DWORD PTR [rax]
	add	ecx, 3

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc

; 3898 :          stbi__resample *r = &res_comp[k];
; 3899 : 
; 3900 :          // allocate line buffer big enough for upsampling off the edges
; 3901 :          // with upsample factor of 4
; 3902 :          z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);

	mov	QWORD PTR [rsi+68], rax

; 3903 :          if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

	test	rax, rax
	je	$LN217@load_jpeg_

; 3904 : 
; 3905 :          r->hs      = z->img_h_max / z->img_comp[k].h;

	mov	eax, DWORD PTR [rdi+18056]
	cdq

; 3906 :          r->vs      = z->img_v_max / z->img_comp[k].v;
; 3907 :          r->ystep   = r->vs >> 1;
; 3908 :          r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
; 3909 :          r->ypos    = 0;

	mov	DWORD PTR [rbx+16], r13d
	idiv	DWORD PTR [rsi]
	mov	r9d, eax
	mov	DWORD PTR [rbx], eax
	mov	eax, DWORD PTR [rdi+18060]
	cdq
	idiv	DWORD PTR [rsi+4]
	xor	edx, edx
	mov	ecx, eax
	mov	DWORD PTR [rbx+4], eax
	sar	ecx, 1
	mov	r8d, eax
	mov	DWORD PTR [rbx+12], ecx
	mov	rcx, QWORD PTR [rdi]
	mov	eax, DWORD PTR [rcx]

; 3910 :          r->line0   = r->line1 = z->img_comp[k].data;

	mov	rcx, QWORD PTR [rsi+44]
	dec	eax
	add	eax, r9d
	mov	QWORD PTR [rbx-8], rcx
	div	r9d
	mov	QWORD PTR [rbx-16], rcx
	mov	DWORD PTR [rbx+8], eax

; 3911 : 
; 3912 :          if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;

	cmp	r9d, r14d
	jne	$LN278@load_jpeg_
	cmp	r8d, r14d
	jne	SHORT $LN277@load_jpeg_
	lea	rax, OFFSET FLAT:?resample_row_1@@YAPEAEPEAE00HH@Z ; resample_row_1
	jmp	$LN2@load_jpeg_
$LN87@load_jpeg_:

; 3878 : 
; 3879 :    if (z->s->img_n == 3 && n < 3 && !is_rgb)
; 3880 :       decode_n = 1;
; 3881 :    else
; 3882 :       decode_n = z->s->img_n;

	mov	QWORD PTR tv5439[rsp], rbp
	mov	r12, rdx

; 3883 : 
; 3884 :    // nothing to do if no components requested; check this now to avoid
; 3885 :    // accessing uninitialized coutput[0] later
; 3886 :    if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }

	test	edx, edx
	jg	$LN46@load_jpeg_
	xor	eax, eax
	jmp	$LN1@load_jpeg_
$LL194@load_jpeg_:

; 3244 :       if (z->img_comp[i].raw_data) {

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN195@load_jpeg_

; 3245 :          STBI_FREE(z->img_comp[i].raw_data);

	call	QWORD PTR __imp_free

; 3246 :          z->img_comp[i].raw_data = NULL;

	mov	QWORD PTR [rdi], rbp

; 3247 :          z->img_comp[i].data = NULL;

	mov	QWORD PTR [rdi-8], rbp
$LN195@load_jpeg_:

; 3248 :       }
; 3249 :       if (z->img_comp[i].raw_coeff) {

	mov	rcx, QWORD PTR [rdi+8]
	test	rcx, rcx
	je	SHORT $LN196@load_jpeg_

; 3250 :          STBI_FREE(z->img_comp[i].raw_coeff);

	call	QWORD PTR __imp_free

; 3251 :          z->img_comp[i].raw_coeff = 0;

	mov	QWORD PTR [rdi+8], rbp

; 3252 :          z->img_comp[i].coeff = 0;

	mov	QWORD PTR [rdi+24], rbp
$LN196@load_jpeg_:

; 3253 :       }
; 3254 :       if (z->img_comp[i].linebuf) {

	mov	rcx, QWORD PTR [rdi+16]
	test	rcx, rcx
	je	SHORT $LN192@load_jpeg_

; 3255 :          STBI_FREE(z->img_comp[i].linebuf);

	call	QWORD PTR __imp_free

; 3256 :          z->img_comp[i].linebuf = NULL;

	mov	QWORD PTR [rdi+16], rbp
$LN192@load_jpeg_:

; 1057 : }
; 1058 : 
; 1059 : #if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
; 1060 : static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
; 1061 : {
; 1062 :    if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
; 1063 :    return stbi__malloc(a*b*c*d + add);
; 1064 : }
; 1065 : #endif
; 1066 : 
; 1067 : // returns 1 if the sum of two signed ints is valid (between -2^31 and 2^31-1 inclusive), 0 on overflow.
; 1068 : static int stbi__addints_valid(int a, int b)
; 1069 : {
; 1070 :    if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow
; 1071 :    if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.
; 1072 :    return a <= INT_MAX - b;
; 1073 : }
; 1074 : 
; 1075 : // returns 1 if the product of two signed shorts is valid, 0 on overflow.
; 1076 : static int stbi__mul2shorts_valid(short a, short b)
; 1077 : {
; 1078 :    if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow
; 1079 :    if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX/b; // product is positive, so similar to mul2sizes_valid
; 1080 :    if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN
; 1081 :    return a >= SHRT_MIN / b;
; 1082 : }
; 1083 : 
; 1084 : // stbi__err - error
; 1085 : // stbi__errpf - error returning pointer to float
; 1086 : // stbi__errpuc - error returning pointer to unsigned char
; 1087 : 
; 1088 : #ifdef STBI_NO_FAILURE_STRINGS
; 1089 :    #define stbi__err(x,y)  0
; 1090 : #elif defined(STBI_FAILURE_USERMSG)
; 1091 :    #define stbi__err(x,y)  stbi__err(y)
; 1092 : #else
; 1093 :    #define stbi__err(x,y)  stbi__err(x)
; 1094 : #endif
; 1095 : 
; 1096 : #define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
; 1097 : #define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))
; 1098 : 
; 1099 : STBIDEF void stbi_image_free(void *retval_from_stbi_load)
; 1100 : {
; 1101 :    STBI_FREE(retval_from_stbi_load);
; 1102 : }
; 1103 : 
; 1104 : #ifndef STBI_NO_LINEAR
; 1105 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
; 1106 : #endif
; 1107 : 
; 1108 : #ifndef STBI_NO_HDR
; 1109 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
; 1110 : #endif
; 1111 : 
; 1112 : static int stbi__vertically_flip_on_load_global = 0;
; 1113 : 
; 1114 : STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
; 1115 : {
; 1116 :    stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
; 1117 : }
; 1118 : 
; 1119 : #ifndef STBI_THREAD_LOCAL
; 1120 : #define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global
; 1121 : #else
; 1122 : static STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;
; 1123 : 
; 1124 : STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
; 1125 : {
; 1126 :    stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
; 1127 :    stbi__vertically_flip_on_load_set = 1;
; 1128 : }
; 1129 : 
; 1130 : #define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \
; 1131 :                                          ? stbi__vertically_flip_on_load_local  \
; 1132 :                                          : stbi__vertically_flip_on_load_global)
; 1133 : #endif // STBI_THREAD_LOCAL
; 1134 : 
; 1135 : static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
; 1136 : {
; 1137 :    memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
; 1138 :    ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
; 1139 :    ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
; 1140 :    ri->num_channels = 0;
; 1141 : 
; 1142 :    // test the formats with a very explicit header first (at least a FOURCC
; 1143 :    // or distinctive magic number first)
; 1144 :    #ifndef STBI_NO_PNG
; 1145 :    if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
; 1146 :    #endif
; 1147 :    #ifndef STBI_NO_BMP
; 1148 :    if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
; 1149 :    #endif
; 1150 :    #ifndef STBI_NO_GIF
; 1151 :    if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
; 1152 :    #endif
; 1153 :    #ifndef STBI_NO_PSD
; 1154 :    if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
; 1155 :    #else
; 1156 :    STBI_NOTUSED(bpc);
; 1157 :    #endif
; 1158 :    #ifndef STBI_NO_PIC
; 1159 :    if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
; 1160 :    #endif
; 1161 : 
; 1162 :    // then the formats that can end up attempting to load with just 1 or 2
; 1163 :    // bytes matching expectations; these are prone to false positives, so
; 1164 :    // try them later
; 1165 :    #ifndef STBI_NO_JPEG
; 1166 :    if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
; 1167 :    #endif
; 1168 :    #ifndef STBI_NO_PNM
; 1169 :    if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
; 1170 :    #endif
; 1171 : 
; 1172 :    #ifndef STBI_NO_HDR
; 1173 :    if (stbi__hdr_test(s)) {
; 1174 :       float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
; 1175 :       return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
; 1176 :    }
; 1177 :    #endif
; 1178 : 
; 1179 :    #ifndef STBI_NO_TGA
; 1180 :    // test tga last because it's a crappy test!
; 1181 :    if (stbi__tga_test(s))
; 1182 :       return stbi__tga_load(s,x,y,comp,req_comp, ri);
; 1183 :    #endif
; 1184 : 
; 1185 :    return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
; 1186 : }
; 1187 : 
; 1188 : static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
; 1189 : {
; 1190 :    int i;
; 1191 :    int img_len = w * h * channels;
; 1192 :    stbi_uc *reduced;
; 1193 : 
; 1194 :    reduced = (stbi_uc *) stbi__malloc(img_len);
; 1195 :    if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");
; 1196 : 
; 1197 :    for (i = 0; i < img_len; ++i)
; 1198 :       reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling
; 1199 : 
; 1200 :    STBI_FREE(orig);
; 1201 :    return reduced;
; 1202 : }
; 1203 : 
; 1204 : static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
; 1205 : {
; 1206 :    int i;
; 1207 :    int img_len = w * h * channels;
; 1208 :    stbi__uint16 *enlarged;
; 1209 : 
; 1210 :    enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
; 1211 :    if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1212 : 
; 1213 :    for (i = 0; i < img_len; ++i)
; 1214 :       enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff
; 1215 : 
; 1216 :    STBI_FREE(orig);
; 1217 :    return enlarged;
; 1218 : }
; 1219 : 
; 1220 : static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
; 1221 : {
; 1222 :    int row;
; 1223 :    size_t bytes_per_row = (size_t)w * bytes_per_pixel;
; 1224 :    stbi_uc temp[2048];
; 1225 :    stbi_uc *bytes = (stbi_uc *)image;
; 1226 : 
; 1227 :    for (row = 0; row < (h>>1); row++) {
; 1228 :       stbi_uc *row0 = bytes + row*bytes_per_row;
; 1229 :       stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
; 1230 :       // swap row0 with row1
; 1231 :       size_t bytes_left = bytes_per_row;
; 1232 :       while (bytes_left) {
; 1233 :          size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
; 1234 :          memcpy(temp, row0, bytes_copy);
; 1235 :          memcpy(row0, row1, bytes_copy);
; 1236 :          memcpy(row1, temp, bytes_copy);
; 1237 :          row0 += bytes_copy;
; 1238 :          row1 += bytes_copy;
; 1239 :          bytes_left -= bytes_copy;
; 1240 :       }
; 1241 :    }
; 1242 : }
; 1243 : 
; 1244 : #ifndef STBI_NO_GIF
; 1245 : static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
; 1246 : {
; 1247 :    int slice;
; 1248 :    int slice_size = w * h * bytes_per_pixel;
; 1249 : 
; 1250 :    stbi_uc *bytes = (stbi_uc *)image;
; 1251 :    for (slice = 0; slice < z; ++slice) {
; 1252 :       stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
; 1253 :       bytes += slice_size;
; 1254 :    }
; 1255 : }
; 1256 : #endif
; 1257 : 
; 1258 : static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
; 1259 : {
; 1260 :    stbi__result_info ri;
; 1261 :    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);
; 1262 : 
; 1263 :    if (result == NULL)
; 1264 :       return NULL;
; 1265 : 
; 1266 :    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1267 :    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
; 1268 : 
; 1269 :    if (ri.bits_per_channel != 8) {
; 1270 :       result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
; 1271 :       ri.bits_per_channel = 8;
; 1272 :    }
; 1273 : 
; 1274 :    // @TODO: move stbi__convert_format to here
; 1275 : 
; 1276 :    if (stbi__vertically_flip_on_load) {
; 1277 :       int channels = req_comp ? req_comp : *comp;
; 1278 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
; 1279 :    }
; 1280 : 
; 1281 :    return (unsigned char *) result;
; 1282 : }
; 1283 : 
; 1284 : static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
; 1285 : {
; 1286 :    stbi__result_info ri;
; 1287 :    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);
; 1288 : 
; 1289 :    if (result == NULL)
; 1290 :       return NULL;
; 1291 : 
; 1292 :    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1293 :    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
; 1294 : 
; 1295 :    if (ri.bits_per_channel != 16) {
; 1296 :       result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
; 1297 :       ri.bits_per_channel = 16;
; 1298 :    }
; 1299 : 
; 1300 :    // @TODO: move stbi__convert_format16 to here
; 1301 :    // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision
; 1302 : 
; 1303 :    if (stbi__vertically_flip_on_load) {
; 1304 :       int channels = req_comp ? req_comp : *comp;
; 1305 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
; 1306 :    }
; 1307 : 
; 1308 :    return (stbi__uint16 *) result;
; 1309 : }
; 1310 : 
; 1311 : #if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)
; 1312 : static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
; 1313 : {
; 1314 :    if (stbi__vertically_flip_on_load && result != NULL) {
; 1315 :       int channels = req_comp ? req_comp : *comp;
; 1316 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
; 1317 :    }
; 1318 : }
; 1319 : #endif
; 1320 : 
; 1321 : #ifndef STBI_NO_STDIO
; 1322 : 
; 1323 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1324 : STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
; 1325 : STBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);
; 1326 : #endif
; 1327 : 
; 1328 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1329 : STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
; 1330 : {
; 1331 : 	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
; 1332 : }
; 1333 : #endif
; 1334 : 
; 1335 : static FILE *stbi__fopen(char const *filename, char const *mode)
; 1336 : {
; 1337 :    FILE *f;
; 1338 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1339 :    wchar_t wMode[64];
; 1340 :    wchar_t wFilename[1024];
; 1341 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
; 1342 :       return 0;
; 1343 : 
; 1344 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
; 1345 :       return 0;
; 1346 : 
; 1347 : #if defined(_MSC_VER) && _MSC_VER >= 1400
; 1348 : 	if (0 != _wfopen_s(&f, wFilename, wMode))
; 1349 : 		f = 0;
; 1350 : #else
; 1351 :    f = _wfopen(wFilename, wMode);
; 1352 : #endif
; 1353 : 
; 1354 : #elif defined(_MSC_VER) && _MSC_VER >= 1400
; 1355 :    if (0 != fopen_s(&f, filename, mode))
; 1356 :       f=0;
; 1357 : #else
; 1358 :    f = fopen(filename, mode);
; 1359 : #endif
; 1360 :    return f;
; 1361 : }
; 1362 : 
; 1363 : 
; 1364 : STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
; 1365 : {
; 1366 :    FILE *f = stbi__fopen(filename, "rb");
; 1367 :    unsigned char *result;
; 1368 :    if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
; 1369 :    result = stbi_load_from_file(f,x,y,comp,req_comp);
; 1370 :    fclose(f);
; 1371 :    return result;
; 1372 : }
; 1373 : 
; 1374 : STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
; 1375 : {
; 1376 :    unsigned char *result;
; 1377 :    stbi__context s;
; 1378 :    stbi__start_file(&s,f);
; 1379 :    result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
; 1380 :    if (result) {
; 1381 :       // need to 'unget' all the characters in the IO buffer
; 1382 :       fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
; 1383 :    }
; 1384 :    return result;
; 1385 : }
; 1386 : 
; 1387 : STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
; 1388 : {
; 1389 :    stbi__uint16 *result;
; 1390 :    stbi__context s;
; 1391 :    stbi__start_file(&s,f);
; 1392 :    result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
; 1393 :    if (result) {
; 1394 :       // need to 'unget' all the characters in the IO buffer
; 1395 :       fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
; 1396 :    }
; 1397 :    return result;
; 1398 : }
; 1399 : 
; 1400 : STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
; 1401 : {
; 1402 :    FILE *f = stbi__fopen(filename, "rb");
; 1403 :    stbi__uint16 *result;
; 1404 :    if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");
; 1405 :    result = stbi_load_from_file_16(f,x,y,comp,req_comp);
; 1406 :    fclose(f);
; 1407 :    return result;
; 1408 : }
; 1409 : 
; 1410 : 
; 1411 : #endif //!STBI_NO_STDIO
; 1412 : 
; 1413 : STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
; 1414 : {
; 1415 :    stbi__context s;
; 1416 :    stbi__start_mem(&s,buffer,len);
; 1417 :    return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
; 1418 : }
; 1419 : 
; 1420 : STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
; 1421 : {
; 1422 :    stbi__context s;
; 1423 :    stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
; 1424 :    return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
; 1425 : }
; 1426 : 
; 1427 : STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
; 1428 : {
; 1429 :    stbi__context s;
; 1430 :    stbi__start_mem(&s,buffer,len);
; 1431 :    return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
; 1432 : }
; 1433 : 
; 1434 : STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
; 1435 : {
; 1436 :    stbi__context s;
; 1437 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
; 1438 :    return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
; 1439 : }
; 1440 : 
; 1441 : #ifndef STBI_NO_GIF
; 1442 : STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
; 1443 : {
; 1444 :    unsigned char *result;
; 1445 :    stbi__context s;
; 1446 :    stbi__start_mem(&s,buffer,len);
; 1447 : 
; 1448 :    result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
; 1449 :    if (stbi__vertically_flip_on_load) {
; 1450 :       stbi__vertical_flip_slices( result, *x, *y, *z, *comp );
; 1451 :    }
; 1452 : 
; 1453 :    return result;
; 1454 : }
; 1455 : #endif
; 1456 : 
; 1457 : #ifndef STBI_NO_LINEAR
; 1458 : static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
; 1459 : {
; 1460 :    unsigned char *data;
; 1461 :    #ifndef STBI_NO_HDR
; 1462 :    if (stbi__hdr_test(s)) {
; 1463 :       stbi__result_info ri;
; 1464 :       float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
; 1465 :       if (hdr_data)
; 1466 :          stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
; 1467 :       return hdr_data;
; 1468 :    }
; 1469 :    #endif
; 1470 :    data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
; 1471 :    if (data)
; 1472 :       return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
; 1473 :    return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
; 1474 : }
; 1475 : 
; 1476 : STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
; 1477 : {
; 1478 :    stbi__context s;
; 1479 :    stbi__start_mem(&s,buffer,len);
; 1480 :    return stbi__loadf_main(&s,x,y,comp,req_comp);
; 1481 : }
; 1482 : 
; 1483 : STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
; 1484 : {
; 1485 :    stbi__context s;
; 1486 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
; 1487 :    return stbi__loadf_main(&s,x,y,comp,req_comp);
; 1488 : }
; 1489 : 
; 1490 : #ifndef STBI_NO_STDIO
; 1491 : STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
; 1492 : {
; 1493 :    float *result;
; 1494 :    FILE *f = stbi__fopen(filename, "rb");
; 1495 :    if (!f) return stbi__errpf("can't fopen", "Unable to open file");
; 1496 :    result = stbi_loadf_from_file(f,x,y,comp,req_comp);
; 1497 :    fclose(f);
; 1498 :    return result;
; 1499 : }
; 1500 : 
; 1501 : STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
; 1502 : {
; 1503 :    stbi__context s;
; 1504 :    stbi__start_file(&s,f);
; 1505 :    return stbi__loadf_main(&s,x,y,comp,req_comp);
; 1506 : }
; 1507 : #endif // !STBI_NO_STDIO
; 1508 : 
; 1509 : #endif // !STBI_NO_LINEAR
; 1510 : 
; 1511 : // these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
; 1512 : // defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
; 1513 : // reports false!
; 1514 : 
; 1515 : STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
; 1516 : {
; 1517 :    #ifndef STBI_NO_HDR
; 1518 :    stbi__context s;
; 1519 :    stbi__start_mem(&s,buffer,len);
; 1520 :    return stbi__hdr_test(&s);
; 1521 :    #else
; 1522 :    STBI_NOTUSED(buffer);
; 1523 :    STBI_NOTUSED(len);
; 1524 :    return 0;
; 1525 :    #endif
; 1526 : }
; 1527 : 
; 1528 : #ifndef STBI_NO_STDIO
; 1529 : STBIDEF int      stbi_is_hdr          (char const *filename)
; 1530 : {
; 1531 :    FILE *f = stbi__fopen(filename, "rb");
; 1532 :    int result=0;
; 1533 :    if (f) {
; 1534 :       result = stbi_is_hdr_from_file(f);
; 1535 :       fclose(f);
; 1536 :    }
; 1537 :    return result;
; 1538 : }
; 1539 : 
; 1540 : STBIDEF int stbi_is_hdr_from_file(FILE *f)
; 1541 : {
; 1542 :    #ifndef STBI_NO_HDR
; 1543 :    long pos = ftell(f);
; 1544 :    int res;
; 1545 :    stbi__context s;
; 1546 :    stbi__start_file(&s,f);
; 1547 :    res = stbi__hdr_test(&s);
; 1548 :    fseek(f, pos, SEEK_SET);
; 1549 :    return res;
; 1550 :    #else
; 1551 :    STBI_NOTUSED(f);
; 1552 :    return 0;
; 1553 :    #endif
; 1554 : }
; 1555 : #endif // !STBI_NO_STDIO
; 1556 : 
; 1557 : STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
; 1558 : {
; 1559 :    #ifndef STBI_NO_HDR
; 1560 :    stbi__context s;
; 1561 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
; 1562 :    return stbi__hdr_test(&s);
; 1563 :    #else
; 1564 :    STBI_NOTUSED(clbk);
; 1565 :    STBI_NOTUSED(user);
; 1566 :    return 0;
; 1567 :    #endif
; 1568 : }
; 1569 : 
; 1570 : #ifndef STBI_NO_LINEAR
; 1571 : static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;
; 1572 : 
; 1573 : STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
; 1574 : STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
; 1575 : #endif
; 1576 : 
; 1577 : static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;
; 1578 : 
; 1579 : STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
; 1580 : STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }
; 1581 : 
; 1582 : 
; 1583 : //////////////////////////////////////////////////////////////////////////////
; 1584 : //
; 1585 : // Common code used by all image loaders
; 1586 : //
; 1587 : 
; 1588 : enum
; 1589 : {
; 1590 :    STBI__SCAN_load=0,
; 1591 :    STBI__SCAN_type,
; 1592 :    STBI__SCAN_header
; 1593 : };
; 1594 : 
; 1595 : static void stbi__refill_buffer(stbi__context *s)
; 1596 : {
; 1597 :    int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
; 1598 :    s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);
; 1599 :    if (n == 0) {
; 1600 :       // at end of file, treat same as if from memory, but need to handle case
; 1601 :       // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
; 1602 :       s->read_from_callbacks = 0;
; 1603 :       s->img_buffer = s->buffer_start;
; 1604 :       s->img_buffer_end = s->buffer_start+1;
; 1605 :       *s->img_buffer = 0;
; 1606 :    } else {
; 1607 :       s->img_buffer = s->buffer_start;
; 1608 :       s->img_buffer_end = s->buffer_start + n;
; 1609 :    }
; 1610 : }
; 1611 : 
; 1612 : stbi_inline static stbi_uc stbi__get8(stbi__context *s)
; 1613 : {
; 1614 :    if (s->img_buffer < s->img_buffer_end)
; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {
; 1617 :       stbi__refill_buffer(s);
; 1618 :       return *s->img_buffer++;
; 1619 :    }
; 1620 :    return 0;
; 1621 : }
; 1622 : 
; 1623 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1624 : // nothing
; 1625 : #else
; 1626 : stbi_inline static int stbi__at_eof(stbi__context *s)
; 1627 : {
; 1628 :    if (s->io.read) {
; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;
; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;
; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;
; 1636 : }
; 1637 : #endif
; 1638 : 
; 1639 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
; 1640 : // nothing
; 1641 : #else
; 1642 : static void stbi__skip(stbi__context *s, int n)
; 1643 : {
; 1644 :    if (n == 0) return;  // already there!
; 1645 :    if (n < 0) {
; 1646 :       s->img_buffer = s->img_buffer_end;
; 1647 :       return;
; 1648 :    }
; 1649 :    if (s->io.read) {
; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1651 :       if (blen < n) {
; 1652 :          s->img_buffer = s->img_buffer_end;
; 1653 :          (s->io.skip)(s->io_user_data, n - blen);
; 1654 :          return;
; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;
; 1658 : }
; 1659 : #endif
; 1660 : 
; 1661 : #if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
; 1662 : // nothing
; 1663 : #else
; 1664 : static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
; 1665 : {
; 1666 :    if (s->io.read) {
; 1667 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1668 :       if (blen < n) {
; 1669 :          int res, count;
; 1670 : 
; 1671 :          memcpy(buffer, s->img_buffer, blen);
; 1672 : 
; 1673 :          count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
; 1674 :          res = (count == (n-blen));
; 1675 :          s->img_buffer = s->img_buffer_end;
; 1676 :          return res;
; 1677 :       }
; 1678 :    }
; 1679 : 
; 1680 :    if (s->img_buffer+n <= s->img_buffer_end) {
; 1681 :       memcpy(buffer, s->img_buffer, n);
; 1682 :       s->img_buffer += n;
; 1683 :       return 1;
; 1684 :    } else
; 1685 :       return 0;
; 1686 : }
; 1687 : #endif
; 1688 : 
; 1689 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1690 : // nothing
; 1691 : #else
; 1692 : static int stbi__get16be(stbi__context *s)
; 1693 : {
; 1694 :    int z = stbi__get8(s);
; 1695 :    return (z << 8) + stbi__get8(s);
; 1696 : }
; 1697 : #endif
; 1698 : 
; 1699 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1700 : // nothing
; 1701 : #else
; 1702 : static stbi__uint32 stbi__get32be(stbi__context *s)
; 1703 : {
; 1704 :    stbi__uint32 z = stbi__get16be(s);
; 1705 :    return (z << 16) + stbi__get16be(s);
; 1706 : }
; 1707 : #endif
; 1708 : 
; 1709 : #if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
; 1710 : // nothing
; 1711 : #else
; 1712 : static int stbi__get16le(stbi__context *s)
; 1713 : {
; 1714 :    int z = stbi__get8(s);
; 1715 :    return z + (stbi__get8(s) << 8);
; 1716 : }
; 1717 : #endif
; 1718 : 
; 1719 : #ifndef STBI_NO_BMP
; 1720 : static stbi__uint32 stbi__get32le(stbi__context *s)
; 1721 : {
; 1722 :    stbi__uint32 z = stbi__get16le(s);
; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;
; 1724 :    return z;
; 1725 : }
; 1726 : #endif
; 1727 : 
; 1728 : #define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
; 1729 : 
; 1730 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1731 : // nothing
; 1732 : #else
; 1733 : //////////////////////////////////////////////////////////////////////////////
; 1734 : //
; 1735 : //  generic converter from built-in img_n to req_comp
; 1736 : //    individual types do this automatically as much as possible (e.g. jpeg
; 1737 : //    does all cases internally since it needs to colorspace convert anyway,
; 1738 : //    and it never has alpha, so very few cases ). png can automatically
; 1739 : //    interleave an alpha=255 channel, but falls back to this for other cases
; 1740 : //
; 1741 : //  assume data buffer is malloced, so malloc a new one and free that one
; 1742 : //  only failure mode is malloc failing
; 1743 : 
; 1744 : static stbi_uc stbi__compute_y(int r, int g, int b)
; 1745 : {
; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1747 : }
; 1748 : #endif
; 1749 : 
; 1750 : #if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1751 : // nothing
; 1752 : #else
; 1753 : static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1754 : {
; 1755 :    int i,j;
; 1756 :    unsigned char *good;
; 1757 : 
; 1758 :    if (req_comp == img_n) return data;
; 1759 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1760 : 
; 1761 :    good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
; 1762 :    if (good == NULL) {
; 1763 :       STBI_FREE(data);
; 1764 :       return stbi__errpuc("outofmem", "Out of memory");
; 1765 :    }
; 1766 : 
; 1767 :    for (j=0; j < (int) y; ++j) {
; 1768 :       unsigned char *src  = data + j * x * img_n   ;
; 1769 :       unsigned char *dest = good + j * x * req_comp;
; 1770 : 
; 1771 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1772 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1773 :       // convert source image with img_n components to one with req_comp components;
; 1774 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1775 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1776 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
; 1777 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1778 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
; 1779 :          STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
; 1780 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1781 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
; 1782 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
; 1783 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1784 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
; 1785 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1786 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1787 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
; 1788 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
; 1789 :       }
; 1790 :       #undef STBI__CASE
; 1791 :    }
; 1792 : 
; 1793 :    STBI_FREE(data);
; 1794 :    return good;
; 1795 : }
; 1796 : #endif
; 1797 : 
; 1798 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1799 : // nothing
; 1800 : #else
; 1801 : static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
; 1802 : {
; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1804 : }
; 1805 : #endif
; 1806 : 
; 1807 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1808 : // nothing
; 1809 : #else
; 1810 : static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1811 : {
; 1812 :    int i,j;
; 1813 :    stbi__uint16 *good;
; 1814 : 
; 1815 :    if (req_comp == img_n) return data;
; 1816 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1817 : 
; 1818 :    good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
; 1819 :    if (good == NULL) {
; 1820 :       STBI_FREE(data);
; 1821 :       return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1822 :    }
; 1823 : 
; 1824 :    for (j=0; j < (int) y; ++j) {
; 1825 :       stbi__uint16 *src  = data + j * x * img_n   ;
; 1826 :       stbi__uint16 *dest = good + j * x * req_comp;
; 1827 : 
; 1828 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1829 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1830 :       // convert source image with img_n components to one with req_comp components;
; 1831 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1832 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1833 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
; 1834 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1835 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
; 1836 :          STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
; 1837 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1838 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
; 1839 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
; 1840 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1841 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
; 1842 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1843 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1844 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
; 1845 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
; 1846 :       }
; 1847 :       #undef STBI__CASE
; 1848 :    }
; 1849 : 
; 1850 :    STBI_FREE(data);
; 1851 :    return good;
; 1852 : }
; 1853 : #endif
; 1854 : 
; 1855 : #ifndef STBI_NO_LINEAR
; 1856 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
; 1857 : {
; 1858 :    int i,k,n;
; 1859 :    float *output;
; 1860 :    if (!data) return NULL;
; 1861 :    output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
; 1862 :    if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
; 1863 :    // compute number of non-alpha components
; 1864 :    if (comp & 1) n = comp; else n = comp-1;
; 1865 :    for (i=0; i < x*y; ++i) {
; 1866 :       for (k=0; k < n; ++k) {
; 1867 :          output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
; 1868 :       }
; 1869 :    }
; 1870 :    if (n < comp) {
; 1871 :       for (i=0; i < x*y; ++i) {
; 1872 :          output[i*comp + n] = data[i*comp + n]/255.0f;
; 1873 :       }
; 1874 :    }
; 1875 :    STBI_FREE(data);
; 1876 :    return output;
; 1877 : }
; 1878 : #endif
; 1879 : 
; 1880 : #ifndef STBI_NO_HDR
; 1881 : #define stbi__float2int(x)   ((int) (x))
; 1882 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
; 1883 : {
; 1884 :    int i,k,n;
; 1885 :    stbi_uc *output;
; 1886 :    if (!data) return NULL;
; 1887 :    output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
; 1888 :    if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
; 1889 :    // compute number of non-alpha components
; 1890 :    if (comp & 1) n = comp; else n = comp-1;
; 1891 :    for (i=0; i < x*y; ++i) {
; 1892 :       for (k=0; k < n; ++k) {
; 1893 :          float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
; 1894 :          if (z < 0) z = 0;
; 1895 :          if (z > 255) z = 255;
; 1896 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1897 :       }
; 1898 :       if (k < comp) {
; 1899 :          float z = data[i*comp+k] * 255 + 0.5f;
; 1900 :          if (z < 0) z = 0;
; 1901 :          if (z > 255) z = 255;
; 1902 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1903 :       }
; 1904 :    }
; 1905 :    STBI_FREE(data);
; 1906 :    return output;
; 1907 : }
; 1908 : #endif
; 1909 : 
; 1910 : //////////////////////////////////////////////////////////////////////////////
; 1911 : //
; 1912 : //  "baseline" JPEG/JFIF decoder
; 1913 : //
; 1914 : //    simple implementation
; 1915 : //      - doesn't support delayed output of y-dimension
; 1916 : //      - simple interface (only one output format: 8-bit interleaved RGB)
; 1917 : //      - doesn't try to recover corrupt jpegs
; 1918 : //      - doesn't allow partial loading, loading multiple at once
; 1919 : //      - still fast on x86 (copying globals into locals doesn't help x86)
; 1920 : //      - allocates lots of intermediate memory (full size of all components)
; 1921 : //        - non-interleaved case requires this anyway
; 1922 : //        - allows good upsampling (see next)
; 1923 : //    high-quality
; 1924 : //      - upsampled channels are bilinearly interpolated, even across blocks
; 1925 : //      - quality integer IDCT derived from IJG's 'slow'
; 1926 : //    performance
; 1927 : //      - fast huffman; reasonable integer IDCT
; 1928 : //      - some SIMD kernels for common paths on targets with SSE2/NEON
; 1929 : //      - uses a lot of intermediate memory, could cache poorly
; 1930 : 
; 1931 : #ifndef STBI_NO_JPEG
; 1932 : 
; 1933 : // huffman decoding acceleration
; 1934 : #define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
; 1935 : 
; 1936 : typedef struct
; 1937 : {
; 1938 :    stbi_uc  fast[1 << FAST_BITS];
; 1939 :    // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
; 1940 :    stbi__uint16 code[256];
; 1941 :    stbi_uc  values[256];
; 1942 :    stbi_uc  size[257];
; 1943 :    unsigned int maxcode[18];
; 1944 :    int    delta[17];   // old 'firstsymbol' - old 'firstcode'
; 1945 : } stbi__huffman;
; 1946 : 
; 1947 : typedef struct
; 1948 : {
; 1949 :    stbi__context *s;
; 1950 :    stbi__huffman huff_dc[4];
; 1951 :    stbi__huffman huff_ac[4];
; 1952 :    stbi__uint16 dequant[4][64];
; 1953 :    stbi__int16 fast_ac[4][1 << FAST_BITS];
; 1954 : 
; 1955 : // sizes for components, interleaved MCUs
; 1956 :    int img_h_max, img_v_max;
; 1957 :    int img_mcu_x, img_mcu_y;
; 1958 :    int img_mcu_w, img_mcu_h;
; 1959 : 
; 1960 : // definition of jpeg image component
; 1961 :    struct
; 1962 :    {
; 1963 :       int id;
; 1964 :       int h,v;
; 1965 :       int tq;
; 1966 :       int hd,ha;
; 1967 :       int dc_pred;
; 1968 : 
; 1969 :       int x,y,w2,h2;
; 1970 :       stbi_uc *data;
; 1971 :       void *raw_data, *raw_coeff;
; 1972 :       stbi_uc *linebuf;
; 1973 :       short   *coeff;   // progressive only
; 1974 :       int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
; 1975 :    } img_comp[4];
; 1976 : 
; 1977 :    stbi__uint32   code_buffer; // jpeg entropy-coded buffer
; 1978 :    int            code_bits;   // number of valid bits
; 1979 :    unsigned char  marker;      // marker seen while filling entropy buffer
; 1980 :    int            nomore;      // flag if we saw a marker so must stop
; 1981 : 
; 1982 :    int            progressive;
; 1983 :    int            spec_start;
; 1984 :    int            spec_end;
; 1985 :    int            succ_high;
; 1986 :    int            succ_low;
; 1987 :    int            eob_run;
; 1988 :    int            jfif;
; 1989 :    int            app14_color_transform; // Adobe APP14 tag
; 1990 :    int            rgb;
; 1991 : 
; 1992 :    int scan_n, order[4];
; 1993 :    int restart_interval, todo;
; 1994 : 
; 1995 : // kernels
; 1996 :    void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
; 1997 :    void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
; 1998 :    stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
; 1999 : } stbi__jpeg;
; 2000 : 
; 2001 : static int stbi__build_huffman(stbi__huffman *h, int *count)
; 2002 : {
; 2003 :    int i,j,k=0;
; 2004 :    unsigned int code;
; 2005 :    // build size list for each symbol (from JPEG spec)
; 2006 :    for (i=0; i < 16; ++i) {
; 2007 :       for (j=0; j < count[i]; ++j) {
; 2008 :          h->size[k++] = (stbi_uc) (i+1);
; 2009 :          if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");
; 2010 :       }
; 2011 :    }
; 2012 :    h->size[k] = 0;
; 2013 : 
; 2014 :    // compute actual symbols (from jpeg spec)
; 2015 :    code = 0;
; 2016 :    k = 0;
; 2017 :    for(j=1; j <= 16; ++j) {
; 2018 :       // compute delta to add to code to compute symbol id
; 2019 :       h->delta[j] = k - code;
; 2020 :       if (h->size[k] == j) {
; 2021 :          while (h->size[k] == j)
; 2022 :             h->code[k++] = (stbi__uint16) (code++);
; 2023 :          if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
; 2024 :       }
; 2025 :       // compute largest code + 1 for this size, preshifted as needed later
; 2026 :       h->maxcode[j] = code << (16-j);
; 2027 :       code <<= 1;
; 2028 :    }
; 2029 :    h->maxcode[j] = 0xffffffff;
; 2030 : 
; 2031 :    // build non-spec acceleration table; 255 is flag for not-accelerated
; 2032 :    memset(h->fast, 255, 1 << FAST_BITS);
; 2033 :    for (i=0; i < k; ++i) {
; 2034 :       int s = h->size[i];
; 2035 :       if (s <= FAST_BITS) {
; 2036 :          int c = h->code[i] << (FAST_BITS-s);
; 2037 :          int m = 1 << (FAST_BITS-s);
; 2038 :          for (j=0; j < m; ++j) {
; 2039 :             h->fast[c+j] = (stbi_uc) i;
; 2040 :          }
; 2041 :       }
; 2042 :    }
; 2043 :    return 1;
; 2044 : }
; 2045 : 
; 2046 : // build a table that decodes both magnitude and value of small ACs in
; 2047 : // one go.
; 2048 : static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
; 2049 : {
; 2050 :    int i;
; 2051 :    for (i=0; i < (1 << FAST_BITS); ++i) {
; 2052 :       stbi_uc fast = h->fast[i];
; 2053 :       fast_ac[i] = 0;
; 2054 :       if (fast < 255) {
; 2055 :          int rs = h->values[fast];
; 2056 :          int run = (rs >> 4) & 15;
; 2057 :          int magbits = rs & 15;
; 2058 :          int len = h->size[fast];
; 2059 : 
; 2060 :          if (magbits && len + magbits <= FAST_BITS) {
; 2061 :             // magnitude code followed by receive_extend code
; 2062 :             int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
; 2063 :             int m = 1 << (magbits - 1);
; 2064 :             if (k < m) k += (~0U << magbits) + 1;
; 2065 :             // if the result is small enough, we can fit it in fast_ac table
; 2066 :             if (k >= -128 && k <= 127)
; 2067 :                fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
; 2068 :          }
; 2069 :       }
; 2070 :    }
; 2071 : }
; 2072 : 
; 2073 : static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
; 2074 : {
; 2075 :    do {
; 2076 :       unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
; 2077 :       if (b == 0xff) {
; 2078 :          int c = stbi__get8(j->s);
; 2079 :          while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
; 2080 :          if (c != 0) {
; 2081 :             j->marker = (unsigned char) c;
; 2082 :             j->nomore = 1;
; 2083 :             return;
; 2084 :          }
; 2085 :       }
; 2086 :       j->code_buffer |= b << (24 - j->code_bits);
; 2087 :       j->code_bits += 8;
; 2088 :    } while (j->code_bits <= 24);
; 2089 : }
; 2090 : 
; 2091 : // (1 << n) - 1
; 2092 : static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
; 2093 : 
; 2094 : // decode a jpeg huffman value from the bitstream
; 2095 : stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
; 2096 : {
; 2097 :    unsigned int temp;
; 2098 :    int c,k;
; 2099 : 
; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2105 :    k = h->fast[c];
; 2106 :    if (k < 255) {
; 2107 :       int s = h->size[k];
; 2108 :       if (s > j->code_bits)
; 2109 :          return -1;
; 2110 :       j->code_buffer <<= s;
; 2111 :       j->code_bits -= s;
; 2112 :       return h->values[k];
; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;
; 2122 :    for (k=FAST_BITS+1 ; ; ++k)
; 2123 :       if (temp < h->maxcode[k])
; 2124 :          break;
; 2125 :    if (k == 17) {
; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;
; 2128 :       return -1;
; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)
; 2132 :       return -1;
; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!
; 2137 :        return -1;
; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;
; 2142 :    j->code_buffer <<= k;
; 2143 :    return h->values[c];
; 2144 : }
; 2145 : 
; 2146 : // bias[n] = (-1<<n) + 1
; 2147 : static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};
; 2148 : 
; 2149 : // combined JPEG 'receive' and JPEG 'extend', since baseline
; 2150 : // always extends everything it receives.
; 2151 : stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
; 2152 : {
; 2153 :    unsigned int k;
; 2154 :    int sgn;
; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
; 2159 :    k = stbi_lrot(j->code_buffer, n);
; 2160 :    j->code_buffer = k & ~stbi__bmask[n];
; 2161 :    k &= stbi__bmask[n];
; 2162 :    j->code_bits -= n;
; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));
; 2164 : }
; 2165 : 
; 2166 : // get some unsigned bits
; 2167 : stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
; 2168 : {
; 2169 :    unsigned int k;
; 2170 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2171 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2172 :    k = stbi_lrot(j->code_buffer, n);
; 2173 :    j->code_buffer = k & ~stbi__bmask[n];
; 2174 :    k &= stbi__bmask[n];
; 2175 :    j->code_bits -= n;
; 2176 :    return k;
; 2177 : }
; 2178 : 
; 2179 : stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
; 2180 : {
; 2181 :    unsigned int k;
; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2184 :    k = j->code_buffer;
; 2185 :    j->code_buffer <<= 1;
; 2186 :    --j->code_bits;
; 2187 :    return k & 0x80000000;
; 2188 : }
; 2189 : 
; 2190 : // given a value that's at position X in the zigzag stream,
; 2191 : // where does it appear in the 8x8 matrix coded as row-major?
; 2192 : static const stbi_uc stbi__jpeg_dezigzag[64+15] =
; 2193 : {
; 2194 :     0,  1,  8, 16,  9,  2,  3, 10,
; 2195 :    17, 24, 32, 25, 18, 11,  4,  5,
; 2196 :    12, 19, 26, 33, 40, 48, 41, 34,
; 2197 :    27, 20, 13,  6,  7, 14, 21, 28,
; 2198 :    35, 42, 49, 56, 57, 50, 43, 36,
; 2199 :    29, 22, 15, 23, 30, 37, 44, 51,
; 2200 :    58, 59, 52, 45, 38, 31, 39, 46,
; 2201 :    53, 60, 61, 54, 47, 55, 62, 63,
; 2202 :    // let corrupt input sample past end
; 2203 :    63, 63, 63, 63, 63, 63, 63, 63,
; 2204 :    63, 63, 63, 63, 63, 63, 63
; 2205 : };
; 2206 : 
; 2207 : // decode one 64-entry block--
; 2208 : static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
; 2209 : {
; 2210 :    int diff,dc,k;
; 2211 :    int t;
; 2212 : 
; 2213 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2214 :    t = stbi__jpeg_huff_decode(j, hdc);
; 2215 :    if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");
; 2216 : 
; 2217 :    // 0 all the ac values now so we can do it 32-bits at a time
; 2218 :    memset(data,0,64*sizeof(data[0]));
; 2219 : 
; 2220 :    diff = t ? stbi__extend_receive(j, t) : 0;
; 2221 :    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");
; 2222 :    dc = j->img_comp[b].dc_pred + diff;
; 2223 :    j->img_comp[b].dc_pred = dc;
; 2224 :    if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2225 :    data[0] = (short) (dc * dequant[0]);
; 2226 : 
; 2227 :    // decode AC components, see JPEG spec
; 2228 :    k = 1;
; 2229 :    do {
; 2230 :       unsigned int zig;
; 2231 :       int c,r,s;
; 2232 :       if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2233 :       c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2234 :       r = fac[c];
; 2235 :       if (r) { // fast-AC path
; 2236 :          k += (r >> 4) & 15; // run
; 2237 :          s = r & 15; // combined length
; 2238 :          if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2239 :          j->code_buffer <<= s;
; 2240 :          j->code_bits -= s;
; 2241 :          // decode into unzigzag'd location
; 2242 :          zig = stbi__jpeg_dezigzag[k++];
; 2243 :          data[zig] = (short) ((r >> 8) * dequant[zig]);
; 2244 :       } else {
; 2245 :          int rs = stbi__jpeg_huff_decode(j, hac);
; 2246 :          if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2247 :          s = rs & 15;
; 2248 :          r = rs >> 4;
; 2249 :          if (s == 0) {
; 2250 :             if (rs != 0xf0) break; // end block
; 2251 :             k += 16;
; 2252 :          } else {
; 2253 :             k += r;
; 2254 :             // decode into unzigzag'd location
; 2255 :             zig = stbi__jpeg_dezigzag[k++];
; 2256 :             data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
; 2257 :          }
; 2258 :       }
; 2259 :    } while (k < 64);
; 2260 :    return 1;
; 2261 : }
; 2262 : 
; 2263 : static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
; 2264 : {
; 2265 :    int diff,dc;
; 2266 :    int t;
; 2267 :    if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2268 : 
; 2269 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2270 : 
; 2271 :    if (j->succ_high == 0) {
; 2272 :       // first scan for DC coefficient, must be first
; 2273 :       memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
; 2274 :       t = stbi__jpeg_huff_decode(j, hdc);
; 2275 :       if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2276 :       diff = t ? stbi__extend_receive(j, t) : 0;
; 2277 : 
; 2278 :       if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");
; 2279 :       dc = j->img_comp[b].dc_pred + diff;
; 2280 :       j->img_comp[b].dc_pred = dc;
; 2281 :       if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2282 :       data[0] = (short) (dc * (1 << j->succ_low));
; 2283 :    } else {
; 2284 :       // refinement scan for DC coefficient
; 2285 :       if (stbi__jpeg_get_bit(j))
; 2286 :          data[0] += (short) (1 << j->succ_low);
; 2287 :    }
; 2288 :    return 1;
; 2289 : }
; 2290 : 
; 2291 : // @OPTIMIZE: store non-zigzagged during the decode passes,
; 2292 : // and only de-zigzag when dequantizing
; 2293 : static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
; 2294 : {
; 2295 :    int k;
; 2296 :    if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2297 : 
; 2298 :    if (j->succ_high == 0) {
; 2299 :       int shift = j->succ_low;
; 2300 : 
; 2301 :       if (j->eob_run) {
; 2302 :          --j->eob_run;
; 2303 :          return 1;
; 2304 :       }
; 2305 : 
; 2306 :       k = j->spec_start;
; 2307 :       do {
; 2308 :          unsigned int zig;
; 2309 :          int c,r,s;
; 2310 :          if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2311 :          c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2312 :          r = fac[c];
; 2313 :          if (r) { // fast-AC path
; 2314 :             k += (r >> 4) & 15; // run
; 2315 :             s = r & 15; // combined length
; 2316 :             if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2317 :             j->code_buffer <<= s;
; 2318 :             j->code_bits -= s;
; 2319 :             zig = stbi__jpeg_dezigzag[k++];
; 2320 :             data[zig] = (short) ((r >> 8) * (1 << shift));
; 2321 :          } else {
; 2322 :             int rs = stbi__jpeg_huff_decode(j, hac);
; 2323 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2324 :             s = rs & 15;
; 2325 :             r = rs >> 4;
; 2326 :             if (s == 0) {
; 2327 :                if (r < 15) {
; 2328 :                   j->eob_run = (1 << r);
; 2329 :                   if (r)
; 2330 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2331 :                   --j->eob_run;
; 2332 :                   break;
; 2333 :                }
; 2334 :                k += 16;
; 2335 :             } else {
; 2336 :                k += r;
; 2337 :                zig = stbi__jpeg_dezigzag[k++];
; 2338 :                data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
; 2339 :             }
; 2340 :          }
; 2341 :       } while (k <= j->spec_end);
; 2342 :    } else {
; 2343 :       // refinement scan for these AC coefficients
; 2344 : 
; 2345 :       short bit = (short) (1 << j->succ_low);
; 2346 : 
; 2347 :       if (j->eob_run) {
; 2348 :          --j->eob_run;
; 2349 :          for (k = j->spec_start; k <= j->spec_end; ++k) {
; 2350 :             short *p = &data[stbi__jpeg_dezigzag[k]];
; 2351 :             if (*p != 0)
; 2352 :                if (stbi__jpeg_get_bit(j))
; 2353 :                   if ((*p & bit)==0) {
; 2354 :                      if (*p > 0)
; 2355 :                         *p += bit;
; 2356 :                      else
; 2357 :                         *p -= bit;
; 2358 :                   }
; 2359 :          }
; 2360 :       } else {
; 2361 :          k = j->spec_start;
; 2362 :          do {
; 2363 :             int r,s;
; 2364 :             int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
; 2365 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2366 :             s = rs & 15;
; 2367 :             r = rs >> 4;
; 2368 :             if (s == 0) {
; 2369 :                if (r < 15) {
; 2370 :                   j->eob_run = (1 << r) - 1;
; 2371 :                   if (r)
; 2372 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2373 :                   r = 64; // force end of block
; 2374 :                } else {
; 2375 :                   // r=15 s=0 should write 16 0s, so we just do
; 2376 :                   // a run of 15 0s and then write s (which is 0),
; 2377 :                   // so we don't have to do anything special here
; 2378 :                }
; 2379 :             } else {
; 2380 :                if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
; 2381 :                // sign bit
; 2382 :                if (stbi__jpeg_get_bit(j))
; 2383 :                   s = bit;
; 2384 :                else
; 2385 :                   s = -bit;
; 2386 :             }
; 2387 : 
; 2388 :             // advance by r
; 2389 :             while (k <= j->spec_end) {
; 2390 :                short *p = &data[stbi__jpeg_dezigzag[k++]];
; 2391 :                if (*p != 0) {
; 2392 :                   if (stbi__jpeg_get_bit(j))
; 2393 :                      if ((*p & bit)==0) {
; 2394 :                         if (*p > 0)
; 2395 :                            *p += bit;
; 2396 :                         else
; 2397 :                            *p -= bit;
; 2398 :                      }
; 2399 :                } else {
; 2400 :                   if (r == 0) {
; 2401 :                      *p = (short) s;
; 2402 :                      break;
; 2403 :                   }
; 2404 :                   --r;
; 2405 :                }
; 2406 :             }
; 2407 :          } while (k <= j->spec_end);
; 2408 :       }
; 2409 :    }
; 2410 :    return 1;
; 2411 : }
; 2412 : 
; 2413 : // take a -128..127 value and stbi__clamp it and convert to 0..255
; 2414 : stbi_inline static stbi_uc stbi__clamp(int x)
; 2415 : {
; 2416 :    // trick to use a single test to catch both cases
; 2417 :    if ((unsigned int) x > 255) {
; 2418 :       if (x < 0) return 0;
; 2419 :       if (x > 255) return 255;
; 2420 :    }
; 2421 :    return (stbi_uc) x;
; 2422 : }
; 2423 : 
; 2424 : #define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
; 2425 : #define stbi__fsh(x)  ((x) * 4096)
; 2426 : 
; 2427 : // derived from jidctint -- DCT_ISLOW
; 2428 : #define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
; 2429 :    int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
; 2430 :    p2 = s2;                                    \
; 2431 :    p3 = s6;                                    \
; 2432 :    p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
; 2433 :    t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
; 2434 :    t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
; 2435 :    p2 = s0;                                    \
; 2436 :    p3 = s4;                                    \
; 2437 :    t0 = stbi__fsh(p2+p3);                      \
; 2438 :    t1 = stbi__fsh(p2-p3);                      \
; 2439 :    x0 = t0+t3;                                 \
; 2440 :    x3 = t0-t3;                                 \
; 2441 :    x1 = t1+t2;                                 \
; 2442 :    x2 = t1-t2;                                 \
; 2443 :    t0 = s7;                                    \
; 2444 :    t1 = s5;                                    \
; 2445 :    t2 = s3;                                    \
; 2446 :    t3 = s1;                                    \
; 2447 :    p3 = t0+t2;                                 \
; 2448 :    p4 = t1+t3;                                 \
; 2449 :    p1 = t0+t3;                                 \
; 2450 :    p2 = t1+t2;                                 \
; 2451 :    p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
; 2452 :    t0 = t0*stbi__f2f( 0.298631336f);           \
; 2453 :    t1 = t1*stbi__f2f( 2.053119869f);           \
; 2454 :    t2 = t2*stbi__f2f( 3.072711026f);           \
; 2455 :    t3 = t3*stbi__f2f( 1.501321110f);           \
; 2456 :    p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
; 2457 :    p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
; 2458 :    p3 = p3*stbi__f2f(-1.961570560f);           \
; 2459 :    p4 = p4*stbi__f2f(-0.390180644f);           \
; 2460 :    t3 += p1+p4;                                \
; 2461 :    t2 += p2+p3;                                \
; 2462 :    t1 += p2+p4;                                \
; 2463 :    t0 += p1+p3;
; 2464 : 
; 2465 : static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
; 2466 : {
; 2467 :    int i,val[64],*v=val;
; 2468 :    stbi_uc *o;
; 2469 :    short *d = data;
; 2470 : 
; 2471 :    // columns
; 2472 :    for (i=0; i < 8; ++i,++d, ++v) {
; 2473 :       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2474 :       if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2475 :            && d[40]==0 && d[48]==0 && d[56]==0) {
; 2476 :          //    no shortcut                 0     seconds
; 2477 :          //    (1|2|3|4|5|6|7)==0          0     seconds
; 2478 :          //    all separate               -0.047 seconds
; 2479 :          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2480 :          int dcterm = d[0]*4;
; 2481 :          v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
; 2482 :       } else {
; 2483 :          STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
; 2484 :          // constants scaled things up by 1<<12; let's bring them back
; 2485 :          // down, but keep 2 extra bits of precision
; 2486 :          x0 += 512; x1 += 512; x2 += 512; x3 += 512;
; 2487 :          v[ 0] = (x0+t3) >> 10;
; 2488 :          v[56] = (x0-t3) >> 10;
; 2489 :          v[ 8] = (x1+t2) >> 10;
; 2490 :          v[48] = (x1-t2) >> 10;
; 2491 :          v[16] = (x2+t1) >> 10;
; 2492 :          v[40] = (x2-t1) >> 10;
; 2493 :          v[24] = (x3+t0) >> 10;
; 2494 :          v[32] = (x3-t0) >> 10;
; 2495 :       }
; 2496 :    }
; 2497 : 
; 2498 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
; 2499 :       // no fast case since the first 1D IDCT spread components out
; 2500 :       STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
; 2501 :       // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2502 :       // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2503 :       // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2504 :       // so we want to round that, which means adding 0.5 * 1<<17,
; 2505 :       // aka 65536. Also, we'll end up with -128 to 127 that we want
; 2506 :       // to encode as 0..255 by adding 128, so we'll add that before the shift
; 2507 :       x0 += 65536 + (128<<17);
; 2508 :       x1 += 65536 + (128<<17);
; 2509 :       x2 += 65536 + (128<<17);
; 2510 :       x3 += 65536 + (128<<17);
; 2511 :       // tried computing the shifts into temps, or'ing the temps to see
; 2512 :       // if any were out of range, but that was slower
; 2513 :       o[0] = stbi__clamp((x0+t3) >> 17);
; 2514 :       o[7] = stbi__clamp((x0-t3) >> 17);
; 2515 :       o[1] = stbi__clamp((x1+t2) >> 17);
; 2516 :       o[6] = stbi__clamp((x1-t2) >> 17);
; 2517 :       o[2] = stbi__clamp((x2+t1) >> 17);
; 2518 :       o[5] = stbi__clamp((x2-t1) >> 17);
; 2519 :       o[3] = stbi__clamp((x3+t0) >> 17);
; 2520 :       o[4] = stbi__clamp((x3-t0) >> 17);
; 2521 :    }
; 2522 : }
; 2523 : 
; 2524 : #ifdef STBI_SSE2
; 2525 : // sse2 integer IDCT. not the fastest possible implementation but it
; 2526 : // produces bit-identical results to the generic C version so it's
; 2527 : // fully "transparent".
; 2528 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2529 : {
; 2530 :    // This is constructed to match our regular (generic) integer IDCT exactly.
; 2531 :    __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2532 :    __m128i tmp;
; 2533 : 
; 2534 :    // dot product constant: even elems=x, odd elems=y
; 2535 :    #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2536 : 
; 2537 :    // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2538 :    // out(1) = c1[even]*x + c1[odd]*y
; 2539 :    #define dct_rot(out0,out1, x,y,c0,c1) \
; 2540 :       __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2541 :       __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2542 :       __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2543 :       __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2544 :       __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2545 :       __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2546 : 
; 2547 :    // out = in << 12  (in 16-bit, out 32-bit)
; 2548 :    #define dct_widen(out, in) \
; 2549 :       __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2550 :       __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2551 : 
; 2552 :    // wide add
; 2553 :    #define dct_wadd(out, a, b) \
; 2554 :       __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2555 :       __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2556 : 
; 2557 :    // wide sub
; 2558 :    #define dct_wsub(out, a, b) \
; 2559 :       __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2560 :       __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2561 : 
; 2562 :    // butterfly a/b, add bias, then shift by "s" and pack
; 2563 :    #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2564 :       { \
; 2565 :          __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2566 :          __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2567 :          dct_wadd(sum, abiased, b); \
; 2568 :          dct_wsub(dif, abiased, b); \
; 2569 :          out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2570 :          out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2571 :       }
; 2572 : 
; 2573 :    // 8-bit interleave step (for transposes)
; 2574 :    #define dct_interleave8(a, b) \
; 2575 :       tmp = a; \
; 2576 :       a = _mm_unpacklo_epi8(a, b); \
; 2577 :       b = _mm_unpackhi_epi8(tmp, b)
; 2578 : 
; 2579 :    // 16-bit interleave step (for transposes)
; 2580 :    #define dct_interleave16(a, b) \
; 2581 :       tmp = a; \
; 2582 :       a = _mm_unpacklo_epi16(a, b); \
; 2583 :       b = _mm_unpackhi_epi16(tmp, b)
; 2584 : 
; 2585 :    #define dct_pass(bias,shift) \
; 2586 :       { \
; 2587 :          /* even part */ \
; 2588 :          dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2589 :          __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2590 :          __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2591 :          dct_widen(t0e, sum04); \
; 2592 :          dct_widen(t1e, dif04); \
; 2593 :          dct_wadd(x0, t0e, t3e); \
; 2594 :          dct_wsub(x3, t0e, t3e); \
; 2595 :          dct_wadd(x1, t1e, t2e); \
; 2596 :          dct_wsub(x2, t1e, t2e); \
; 2597 :          /* odd part */ \
; 2598 :          dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2599 :          dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2600 :          __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2601 :          __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2602 :          dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2603 :          dct_wadd(x4, y0o, y4o); \
; 2604 :          dct_wadd(x5, y1o, y5o); \
; 2605 :          dct_wadd(x6, y2o, y5o); \
; 2606 :          dct_wadd(x7, y3o, y4o); \
; 2607 :          dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2608 :          dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2609 :          dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2610 :          dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2611 :       }
; 2612 : 
; 2613 :    __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
; 2614 :    __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
; 2615 :    __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
; 2616 :    __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
; 2617 :    __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
; 2618 :    __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
; 2619 :    __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
; 2620 :    __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
; 2621 : 
; 2622 :    // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2623 :    __m128i bias_0 = _mm_set1_epi32(512);
; 2624 :    __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
; 2625 : 
; 2626 :    // load
; 2627 :    row0 = _mm_load_si128((const __m128i *) (data + 0*8));
; 2628 :    row1 = _mm_load_si128((const __m128i *) (data + 1*8));
; 2629 :    row2 = _mm_load_si128((const __m128i *) (data + 2*8));
; 2630 :    row3 = _mm_load_si128((const __m128i *) (data + 3*8));
; 2631 :    row4 = _mm_load_si128((const __m128i *) (data + 4*8));
; 2632 :    row5 = _mm_load_si128((const __m128i *) (data + 5*8));
; 2633 :    row6 = _mm_load_si128((const __m128i *) (data + 6*8));
; 2634 :    row7 = _mm_load_si128((const __m128i *) (data + 7*8));
; 2635 : 
; 2636 :    // column pass
; 2637 :    dct_pass(bias_0, 10);
; 2638 : 
; 2639 :    {
; 2640 :       // 16bit 8x8 transpose pass 1
; 2641 :       dct_interleave16(row0, row4);
; 2642 :       dct_interleave16(row1, row5);
; 2643 :       dct_interleave16(row2, row6);
; 2644 :       dct_interleave16(row3, row7);
; 2645 : 
; 2646 :       // transpose pass 2
; 2647 :       dct_interleave16(row0, row2);
; 2648 :       dct_interleave16(row1, row3);
; 2649 :       dct_interleave16(row4, row6);
; 2650 :       dct_interleave16(row5, row7);
; 2651 : 
; 2652 :       // transpose pass 3
; 2653 :       dct_interleave16(row0, row1);
; 2654 :       dct_interleave16(row2, row3);
; 2655 :       dct_interleave16(row4, row5);
; 2656 :       dct_interleave16(row6, row7);
; 2657 :    }
; 2658 : 
; 2659 :    // row pass
; 2660 :    dct_pass(bias_1, 17);
; 2661 : 
; 2662 :    {
; 2663 :       // pack
; 2664 :       __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
; 2665 :       __m128i p1 = _mm_packus_epi16(row2, row3);
; 2666 :       __m128i p2 = _mm_packus_epi16(row4, row5);
; 2667 :       __m128i p3 = _mm_packus_epi16(row6, row7);
; 2668 : 
; 2669 :       // 8bit 8x8 transpose pass 1
; 2670 :       dct_interleave8(p0, p2); // a0e0a1e1...
; 2671 :       dct_interleave8(p1, p3); // c0g0c1g1...
; 2672 : 
; 2673 :       // transpose pass 2
; 2674 :       dct_interleave8(p0, p1); // a0c0e0g0...
; 2675 :       dct_interleave8(p2, p3); // b0d0f0h0...
; 2676 : 
; 2677 :       // transpose pass 3
; 2678 :       dct_interleave8(p0, p2); // a0b0c0d0...
; 2679 :       dct_interleave8(p1, p3); // a4b4c4d4...
; 2680 : 
; 2681 :       // store
; 2682 :       _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
; 2683 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
; 2684 :       _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
; 2685 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
; 2686 :       _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
; 2687 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
; 2688 :       _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
; 2689 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
; 2690 :    }
; 2691 : 
; 2692 : #undef dct_const
; 2693 : #undef dct_rot
; 2694 : #undef dct_widen
; 2695 : #undef dct_wadd
; 2696 : #undef dct_wsub
; 2697 : #undef dct_bfly32o
; 2698 : #undef dct_interleave8
; 2699 : #undef dct_interleave16
; 2700 : #undef dct_pass
; 2701 : }
; 2702 : 
; 2703 : #endif // STBI_SSE2
; 2704 : 
; 2705 : #ifdef STBI_NEON
; 2706 : 
; 2707 : // NEON integer IDCT. should produce bit-identical
; 2708 : // results to the generic C version.
; 2709 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2710 : {
; 2711 :    int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;
; 2712 : 
; 2713 :    int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
; 2714 :    int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
; 2715 :    int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
; 2716 :    int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
; 2717 :    int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
; 2718 :    int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
; 2719 :    int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
; 2720 :    int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
; 2721 :    int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
; 2722 :    int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
; 2723 :    int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
; 2724 :    int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));
; 2725 : 
; 2726 : #define dct_long_mul(out, inq, coeff) \
; 2727 :    int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
; 2728 :    int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)
; 2729 : 
; 2730 : #define dct_long_mac(out, acc, inq, coeff) \
; 2731 :    int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
; 2732 :    int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)
; 2733 : 
; 2734 : #define dct_widen(out, inq) \
; 2735 :    int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
; 2736 :    int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)
; 2737 : 
; 2738 : // wide add
; 2739 : #define dct_wadd(out, a, b) \
; 2740 :    int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
; 2741 :    int32x4_t out##_h = vaddq_s32(a##_h, b##_h)
; 2742 : 
; 2743 : // wide sub
; 2744 : #define dct_wsub(out, a, b) \
; 2745 :    int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
; 2746 :    int32x4_t out##_h = vsubq_s32(a##_h, b##_h)
; 2747 : 
; 2748 : // butterfly a/b, then shift using "shiftop" by "s" and pack
; 2749 : #define dct_bfly32o(out0,out1, a,b,shiftop,s) \
; 2750 :    { \
; 2751 :       dct_wadd(sum, a, b); \
; 2752 :       dct_wsub(dif, a, b); \
; 2753 :       out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
; 2754 :       out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
; 2755 :    }
; 2756 : 
; 2757 : #define dct_pass(shiftop, shift) \
; 2758 :    { \
; 2759 :       /* even part */ \
; 2760 :       int16x8_t sum26 = vaddq_s16(row2, row6); \
; 2761 :       dct_long_mul(p1e, sum26, rot0_0); \
; 2762 :       dct_long_mac(t2e, p1e, row6, rot0_1); \
; 2763 :       dct_long_mac(t3e, p1e, row2, rot0_2); \
; 2764 :       int16x8_t sum04 = vaddq_s16(row0, row4); \
; 2765 :       int16x8_t dif04 = vsubq_s16(row0, row4); \
; 2766 :       dct_widen(t0e, sum04); \
; 2767 :       dct_widen(t1e, dif04); \
; 2768 :       dct_wadd(x0, t0e, t3e); \
; 2769 :       dct_wsub(x3, t0e, t3e); \
; 2770 :       dct_wadd(x1, t1e, t2e); \
; 2771 :       dct_wsub(x2, t1e, t2e); \
; 2772 :       /* odd part */ \
; 2773 :       int16x8_t sum15 = vaddq_s16(row1, row5); \
; 2774 :       int16x8_t sum17 = vaddq_s16(row1, row7); \
; 2775 :       int16x8_t sum35 = vaddq_s16(row3, row5); \
; 2776 :       int16x8_t sum37 = vaddq_s16(row3, row7); \
; 2777 :       int16x8_t sumodd = vaddq_s16(sum17, sum35); \
; 2778 :       dct_long_mul(p5o, sumodd, rot1_0); \
; 2779 :       dct_long_mac(p1o, p5o, sum17, rot1_1); \
; 2780 :       dct_long_mac(p2o, p5o, sum35, rot1_2); \
; 2781 :       dct_long_mul(p3o, sum37, rot2_0); \
; 2782 :       dct_long_mul(p4o, sum15, rot2_1); \
; 2783 :       dct_wadd(sump13o, p1o, p3o); \
; 2784 :       dct_wadd(sump24o, p2o, p4o); \
; 2785 :       dct_wadd(sump23o, p2o, p3o); \
; 2786 :       dct_wadd(sump14o, p1o, p4o); \
; 2787 :       dct_long_mac(x4, sump13o, row7, rot3_0); \
; 2788 :       dct_long_mac(x5, sump24o, row5, rot3_1); \
; 2789 :       dct_long_mac(x6, sump23o, row3, rot3_2); \
; 2790 :       dct_long_mac(x7, sump14o, row1, rot3_3); \
; 2791 :       dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
; 2792 :       dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
; 2793 :       dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
; 2794 :       dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
; 2795 :    }
; 2796 : 
; 2797 :    // load
; 2798 :    row0 = vld1q_s16(data + 0*8);
; 2799 :    row1 = vld1q_s16(data + 1*8);
; 2800 :    row2 = vld1q_s16(data + 2*8);
; 2801 :    row3 = vld1q_s16(data + 3*8);
; 2802 :    row4 = vld1q_s16(data + 4*8);
; 2803 :    row5 = vld1q_s16(data + 5*8);
; 2804 :    row6 = vld1q_s16(data + 6*8);
; 2805 :    row7 = vld1q_s16(data + 7*8);
; 2806 : 
; 2807 :    // add DC bias
; 2808 :    row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));
; 2809 : 
; 2810 :    // column pass
; 2811 :    dct_pass(vrshrn_n_s32, 10);
; 2812 : 
; 2813 :    // 16bit 8x8 transpose
; 2814 :    {
; 2815 : // these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
; 2816 : // whether compilers actually get this is another story, sadly.
; 2817 : #define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
; 2818 : #define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
; 2819 : #define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }
; 2820 : 
; 2821 :       // pass 1
; 2822 :       dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
; 2823 :       dct_trn16(row2, row3);
; 2824 :       dct_trn16(row4, row5);
; 2825 :       dct_trn16(row6, row7);
; 2826 : 
; 2827 :       // pass 2
; 2828 :       dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
; 2829 :       dct_trn32(row1, row3);
; 2830 :       dct_trn32(row4, row6);
; 2831 :       dct_trn32(row5, row7);
; 2832 : 
; 2833 :       // pass 3
; 2834 :       dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
; 2835 :       dct_trn64(row1, row5);
; 2836 :       dct_trn64(row2, row6);
; 2837 :       dct_trn64(row3, row7);
; 2838 : 
; 2839 : #undef dct_trn16
; 2840 : #undef dct_trn32
; 2841 : #undef dct_trn64
; 2842 :    }
; 2843 : 
; 2844 :    // row pass
; 2845 :    // vrshrn_n_s32 only supports shifts up to 16, we need
; 2846 :    // 17. so do a non-rounding shift of 16 first then follow
; 2847 :    // up with a rounding shift by 1.
; 2848 :    dct_pass(vshrn_n_s32, 16);
; 2849 : 
; 2850 :    {
; 2851 :       // pack and round
; 2852 :       uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
; 2853 :       uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
; 2854 :       uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
; 2855 :       uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
; 2856 :       uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
; 2857 :       uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
; 2858 :       uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
; 2859 :       uint8x8_t p7 = vqrshrun_n_s16(row7, 1);
; 2860 : 
; 2861 :       // again, these can translate into one instruction, but often don't.
; 2862 : #define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
; 2863 : #define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
; 2864 : #define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }
; 2865 : 
; 2866 :       // sadly can't use interleaved stores here since we only write
; 2867 :       // 8 bytes to each scan line!
; 2868 : 
; 2869 :       // 8x8 8-bit transpose pass 1
; 2870 :       dct_trn8_8(p0, p1);
; 2871 :       dct_trn8_8(p2, p3);
; 2872 :       dct_trn8_8(p4, p5);
; 2873 :       dct_trn8_8(p6, p7);
; 2874 : 
; 2875 :       // pass 2
; 2876 :       dct_trn8_16(p0, p2);
; 2877 :       dct_trn8_16(p1, p3);
; 2878 :       dct_trn8_16(p4, p6);
; 2879 :       dct_trn8_16(p5, p7);
; 2880 : 
; 2881 :       // pass 3
; 2882 :       dct_trn8_32(p0, p4);
; 2883 :       dct_trn8_32(p1, p5);
; 2884 :       dct_trn8_32(p2, p6);
; 2885 :       dct_trn8_32(p3, p7);
; 2886 : 
; 2887 :       // store
; 2888 :       vst1_u8(out, p0); out += out_stride;
; 2889 :       vst1_u8(out, p1); out += out_stride;
; 2890 :       vst1_u8(out, p2); out += out_stride;
; 2891 :       vst1_u8(out, p3); out += out_stride;
; 2892 :       vst1_u8(out, p4); out += out_stride;
; 2893 :       vst1_u8(out, p5); out += out_stride;
; 2894 :       vst1_u8(out, p6); out += out_stride;
; 2895 :       vst1_u8(out, p7);
; 2896 : 
; 2897 : #undef dct_trn8_8
; 2898 : #undef dct_trn8_16
; 2899 : #undef dct_trn8_32
; 2900 :    }
; 2901 : 
; 2902 : #undef dct_long_mul
; 2903 : #undef dct_long_mac
; 2904 : #undef dct_widen
; 2905 : #undef dct_wadd
; 2906 : #undef dct_wsub
; 2907 : #undef dct_bfly32o
; 2908 : #undef dct_pass
; 2909 : }
; 2910 : 
; 2911 : #endif // STBI_NEON
; 2912 : 
; 2913 : #define STBI__MARKER_none  0xff
; 2914 : // if there's a pending marker from the entropy stream, return that
; 2915 : // otherwise, fetch from the stream and get a marker. if there's no
; 2916 : // marker, return 0xff, which is never a valid marker value
; 2917 : static stbi_uc stbi__get_marker(stbi__jpeg *j)
; 2918 : {
; 2919 :    stbi_uc x;
; 2920 :    if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
; 2921 :    x = stbi__get8(j->s);
; 2922 :    if (x != 0xff) return STBI__MARKER_none;
; 2923 :    while (x == 0xff)
; 2924 :       x = stbi__get8(j->s); // consume repeated 0xff fill bytes
; 2925 :    return x;
; 2926 : }
; 2927 : 
; 2928 : // in each scan, we'll have scan_n components, and the order
; 2929 : // of the components is specified by order[]
; 2930 : #define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
; 2931 : 
; 2932 : // after a restart interval, stbi__jpeg_reset the entropy decoder and
; 2933 : // the dc prediction
; 2934 : static void stbi__jpeg_reset(stbi__jpeg *j)
; 2935 : {
; 2936 :    j->code_bits = 0;
; 2937 :    j->code_buffer = 0;
; 2938 :    j->nomore = 0;
; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
; 2940 :    j->marker = STBI__MARKER_none;
; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
; 2942 :    j->eob_run = 0;
; 2943 :    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2944 :    // since we don't even allow 1<<30 pixels
; 2945 : }
; 2946 : 
; 2947 : static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
; 2948 : {
; 2949 :    stbi__jpeg_reset(z);
; 2950 :    if (!z->progressive) {
; 2951 :       if (z->scan_n == 1) {
; 2952 :          int i,j;
; 2953 :          STBI_SIMD_ALIGN(short, data[64]);
; 2954 :          int n = z->order[0];
; 2955 :          // non-interleaved data, we just need to process one block at a time,
; 2956 :          // in trivial scanline order
; 2957 :          // number of blocks to do just depends on how many actual "pixels" this
; 2958 :          // component has, independent of interleaved MCU blocking and such
; 2959 :          int w = (z->img_comp[n].x+7) >> 3;
; 2960 :          int h = (z->img_comp[n].y+7) >> 3;
; 2961 :          for (j=0; j < h; ++j) {
; 2962 :             for (i=0; i < w; ++i) {
; 2963 :                int ha = z->img_comp[n].ha;
; 2964 :                if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2965 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 2966 :                // every data block is an MCU, so countdown the restart interval
; 2967 :                if (--z->todo <= 0) {
; 2968 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 2969 :                   // if it's NOT a restart, then just bail, so we get corrupt data
; 2970 :                   // rather than no data
; 2971 :                   if (!STBI__RESTART(z->marker)) return 1;
; 2972 :                   stbi__jpeg_reset(z);
; 2973 :                }
; 2974 :             }
; 2975 :          }
; 2976 :          return 1;
; 2977 :       } else { // interleaved
; 2978 :          int i,j,k,x,y;
; 2979 :          STBI_SIMD_ALIGN(short, data[64]);
; 2980 :          for (j=0; j < z->img_mcu_y; ++j) {
; 2981 :             for (i=0; i < z->img_mcu_x; ++i) {
; 2982 :                // scan an interleaved mcu... process scan_n components in order
; 2983 :                for (k=0; k < z->scan_n; ++k) {
; 2984 :                   int n = z->order[k];
; 2985 :                   // scan out an mcu's worth of this component; that's just determined
; 2986 :                   // by the basic H and V specified for the component
; 2987 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 2988 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 2989 :                         int x2 = (i*z->img_comp[n].h + x)*8;
; 2990 :                         int y2 = (j*z->img_comp[n].v + y)*8;
; 2991 :                         int ha = z->img_comp[n].ha;
; 2992 :                         if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2993 :                         z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
; 2994 :                      }
; 2995 :                   }
; 2996 :                }
; 2997 :                // after all interleaved components, that's an interleaved MCU,
; 2998 :                // so now count down the restart interval
; 2999 :                if (--z->todo <= 0) {
; 3000 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3001 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3002 :                   stbi__jpeg_reset(z);
; 3003 :                }
; 3004 :             }
; 3005 :          }
; 3006 :          return 1;
; 3007 :       }
; 3008 :    } else {
; 3009 :       if (z->scan_n == 1) {
; 3010 :          int i,j;
; 3011 :          int n = z->order[0];
; 3012 :          // non-interleaved data, we just need to process one block at a time,
; 3013 :          // in trivial scanline order
; 3014 :          // number of blocks to do just depends on how many actual "pixels" this
; 3015 :          // component has, independent of interleaved MCU blocking and such
; 3016 :          int w = (z->img_comp[n].x+7) >> 3;
; 3017 :          int h = (z->img_comp[n].y+7) >> 3;
; 3018 :          for (j=0; j < h; ++j) {
; 3019 :             for (i=0; i < w; ++i) {
; 3020 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3021 :                if (z->spec_start == 0) {
; 3022 :                   if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3023 :                      return 0;
; 3024 :                } else {
; 3025 :                   int ha = z->img_comp[n].ha;
; 3026 :                   if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
; 3027 :                      return 0;
; 3028 :                }
; 3029 :                // every data block is an MCU, so countdown the restart interval
; 3030 :                if (--z->todo <= 0) {
; 3031 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3032 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3033 :                   stbi__jpeg_reset(z);
; 3034 :                }
; 3035 :             }
; 3036 :          }
; 3037 :          return 1;
; 3038 :       } else { // interleaved
; 3039 :          int i,j,k,x,y;
; 3040 :          for (j=0; j < z->img_mcu_y; ++j) {
; 3041 :             for (i=0; i < z->img_mcu_x; ++i) {
; 3042 :                // scan an interleaved mcu... process scan_n components in order
; 3043 :                for (k=0; k < z->scan_n; ++k) {
; 3044 :                   int n = z->order[k];
; 3045 :                   // scan out an mcu's worth of this component; that's just determined
; 3046 :                   // by the basic H and V specified for the component
; 3047 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 3048 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 3049 :                         int x2 = (i*z->img_comp[n].h + x);
; 3050 :                         int y2 = (j*z->img_comp[n].v + y);
; 3051 :                         short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
; 3052 :                         if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3053 :                            return 0;
; 3054 :                      }
; 3055 :                   }
; 3056 :                }
; 3057 :                // after all interleaved components, that's an interleaved MCU,
; 3058 :                // so now count down the restart interval
; 3059 :                if (--z->todo <= 0) {
; 3060 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3061 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3062 :                   stbi__jpeg_reset(z);
; 3063 :                }
; 3064 :             }
; 3065 :          }
; 3066 :          return 1;
; 3067 :       }
; 3068 :    }
; 3069 : }
; 3070 : 
; 3071 : static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
; 3072 : {
; 3073 :    int i;
; 3074 :    for (i=0; i < 64; ++i)
; 3075 :       data[i] *= dequant[i];
; 3076 : }
; 3077 : 
; 3078 : static void stbi__jpeg_finish(stbi__jpeg *z)
; 3079 : {
; 3080 :    if (z->progressive) {
; 3081 :       // dequantize and idct the data
; 3082 :       int i,j,n;
; 3083 :       for (n=0; n < z->s->img_n; ++n) {
; 3084 :          int w = (z->img_comp[n].x+7) >> 3;
; 3085 :          int h = (z->img_comp[n].y+7) >> 3;
; 3086 :          for (j=0; j < h; ++j) {
; 3087 :             for (i=0; i < w; ++i) {
; 3088 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3089 :                stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
; 3090 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 3091 :             }
; 3092 :          }
; 3093 :       }
; 3094 :    }
; 3095 : }
; 3096 : 
; 3097 : static int stbi__process_marker(stbi__jpeg *z, int m)
; 3098 : {
; 3099 :    int L;
; 3100 :    switch (m) {
; 3101 :       case STBI__MARKER_none: // no marker found
; 3102 :          return stbi__err("expected marker","Corrupt JPEG");
; 3103 : 
; 3104 :       case 0xDD: // DRI - specify restart interval
; 3105 :          if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
; 3106 :          z->restart_interval = stbi__get16be(z->s);
; 3107 :          return 1;
; 3108 : 
; 3109 :       case 0xDB: // DQT - define quantization table
; 3110 :          L = stbi__get16be(z->s)-2;
; 3111 :          while (L > 0) {
; 3112 :             int q = stbi__get8(z->s);
; 3113 :             int p = q >> 4, sixteen = (p != 0);
; 3114 :             int t = q & 15,i;
; 3115 :             if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
; 3116 :             if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");
; 3117 : 
; 3118 :             for (i=0; i < 64; ++i)
; 3119 :                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
; 3120 :             L -= (sixteen ? 129 : 65);
; 3121 :          }
; 3122 :          return L==0;
; 3123 : 
; 3124 :       case 0xC4: // DHT - define huffman table
; 3125 :          L = stbi__get16be(z->s)-2;
; 3126 :          while (L > 0) {
; 3127 :             stbi_uc *v;
; 3128 :             int sizes[16],i,n=0;
; 3129 :             int q = stbi__get8(z->s);
; 3130 :             int tc = q >> 4;
; 3131 :             int th = q & 15;
; 3132 :             if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
; 3133 :             for (i=0; i < 16; ++i) {
; 3134 :                sizes[i] = stbi__get8(z->s);
; 3135 :                n += sizes[i];
; 3136 :             }
; 3137 :             if(n > 256) return stbi__err("bad DHT header","Corrupt JPEG"); // Loop over i < n would write past end of values!
; 3138 :             L -= 17;
; 3139 :             if (tc == 0) {
; 3140 :                if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
; 3141 :                v = z->huff_dc[th].values;
; 3142 :             } else {
; 3143 :                if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
; 3144 :                v = z->huff_ac[th].values;
; 3145 :             }
; 3146 :             for (i=0; i < n; ++i)
; 3147 :                v[i] = stbi__get8(z->s);
; 3148 :             if (tc != 0)
; 3149 :                stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
; 3150 :             L -= n;
; 3151 :          }
; 3152 :          return L==0;
; 3153 :    }
; 3154 : 
; 3155 :    // check for comment block or APP blocks
; 3156 :    if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
; 3157 :       L = stbi__get16be(z->s);
; 3158 :       if (L < 2) {
; 3159 :          if (m == 0xFE)
; 3160 :             return stbi__err("bad COM len","Corrupt JPEG");
; 3161 :          else
; 3162 :             return stbi__err("bad APP len","Corrupt JPEG");
; 3163 :       }
; 3164 :       L -= 2;
; 3165 : 
; 3166 :       if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
; 3167 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3168 :          int ok = 1;
; 3169 :          int i;
; 3170 :          for (i=0; i < 5; ++i)
; 3171 :             if (stbi__get8(z->s) != tag[i])
; 3172 :                ok = 0;
; 3173 :          L -= 5;
; 3174 :          if (ok)
; 3175 :             z->jfif = 1;
; 3176 :       } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;
; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)
; 3181 :             if (stbi__get8(z->s) != tag[i])
; 3182 :                ok = 0;
; 3183 :          L -= 6;
; 3184 :          if (ok) {
; 3185 :             stbi__get8(z->s); // version
; 3186 :             stbi__get16be(z->s); // flags0
; 3187 :             stbi__get16be(z->s); // flags1
; 3188 :             z->app14_color_transform = stbi__get8(z->s); // color transform
; 3189 :             L -= 6;
; 3190 :          }
; 3191 :       }
; 3192 : 
; 3193 :       stbi__skip(z->s, L);
; 3194 :       return 1;
; 3195 :    }
; 3196 : 
; 3197 :    return stbi__err("unknown marker","Corrupt JPEG");
; 3198 : }
; 3199 : 
; 3200 : // after we see SOS
; 3201 : static int stbi__process_scan_header(stbi__jpeg *z)
; 3202 : {
; 3203 :    int i;
; 3204 :    int Ls = stbi__get16be(z->s);
; 3205 :    z->scan_n = stbi__get8(z->s);
; 3206 :    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
; 3207 :    if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
; 3208 :    for (i=0; i < z->scan_n; ++i) {
; 3209 :       int id = stbi__get8(z->s), which;
; 3210 :       int q = stbi__get8(z->s);
; 3211 :       for (which = 0; which < z->s->img_n; ++which)
; 3212 :          if (z->img_comp[which].id == id)
; 3213 :             break;
; 3214 :       if (which == z->s->img_n) return 0; // no match
; 3215 :       z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
; 3216 :       z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
; 3217 :       z->order[i] = which;
; 3218 :    }
; 3219 : 
; 3220 :    {
; 3221 :       int aa;
; 3222 :       z->spec_start = stbi__get8(z->s);
; 3223 :       z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
; 3224 :       aa = stbi__get8(z->s);
; 3225 :       z->succ_high = (aa >> 4);
; 3226 :       z->succ_low  = (aa & 15);
; 3227 :       if (z->progressive) {
; 3228 :          if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
; 3229 :             return stbi__err("bad SOS", "Corrupt JPEG");
; 3230 :       } else {
; 3231 :          if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3232 :          if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3233 :          z->spec_end = 63;
; 3234 :       }
; 3235 :    }
; 3236 : 
; 3237 :    return 1;
; 3238 : }
; 3239 : 
; 3240 : static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
; 3241 : {
; 3242 :    int i;
; 3243 :    for (i=0; i < ncomp; ++i) {

	add	rdi, 96					; 00000060H
	sub	r12, r14
	jne	SHORT $LL194@load_jpeg_
$LN193@load_jpeg_:

; 3883 : 
; 3884 :    // nothing to do if no components requested; check this now to avoid
; 3885 :    // accessing uninitialized coutput[0] later
; 3886 :    if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }

	xor	eax, eax
	jmp	$LN1@load_jpeg_
$LN277@load_jpeg_:

; 3913 :          else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;

	cmp	r8d, 2
	jne	SHORT $LN280@load_jpeg_
	lea	rax, OFFSET FLAT:?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z ; stbi__resample_row_v_2
	jmp	SHORT $LN2@load_jpeg_
$LN278@load_jpeg_:

; 3914 :          else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;

	cmp	r9d, 2
	jne	SHORT $LN280@load_jpeg_
	cmp	r8d, r14d
	jne	SHORT $LN279@load_jpeg_
	lea	rax, OFFSET FLAT:?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z ; stbi__resample_row_h_2
	jmp	SHORT $LN2@load_jpeg_
$LN279@load_jpeg_:

; 3915 :          else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;

	cmp	r8d, 2
	jne	SHORT $LN280@load_jpeg_
	mov	rax, QWORD PTR [rdi+18560]
	jmp	SHORT $LN2@load_jpeg_
$LN280@load_jpeg_:

; 3916 :          else                               r->resample = stbi__resample_row_generic;

	lea	rax, OFFSET FLAT:?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z ; stbi__resample_row_generic
$LN2@load_jpeg_:

; 3894 : 
; 3895 :       stbi__resample res_comp[4];
; 3896 : 
; 3897 :       for (k=0; k < decode_n; ++k) {

	mov	QWORD PTR [rbx-24], rax
	inc	rbp
	add	rbx, 48					; 00000030H
	add	rsi, 96					; 00000060H
	cmp	rbp, r12
	jl	$LL4@load_jpeg_

; 3903 :          if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

	xor	ebp, ebp
$LN3@load_jpeg_:

; 3917 :       }
; 3918 : 
; 3919 :       // can't error after this so, this is safe
; 3920 :       output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);

	mov	rax, QWORD PTR [rdi]
	mov	ecx, DWORD PTR [rax]
	mov	r8d, DWORD PTR [rax+4]

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	$LN306@load_jpeg_

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	jne	SHORT $LN143@load_jpeg_
	lea	r9d, DWORD PTR [rcx*4]
	jmp	$LN309@load_jpeg_
$LN217@load_jpeg_:

; 3243 :    for (i=0; i < ncomp; ++i) {

	mov	rax, QWORD PTR [rdi]
	movsxd	rbx, DWORD PTR [rax+8]
	test	rbx, rbx
	jle	$LN171@load_jpeg_
	add	rdi, 18136				; 000046d8H
	npad	4
$LL160@load_jpeg_:

; 3244 :       if (z->img_comp[i].raw_data) {

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN161@load_jpeg_

; 3245 :          STBI_FREE(z->img_comp[i].raw_data);

	call	QWORD PTR __imp_free

; 3246 :          z->img_comp[i].raw_data = NULL;

	mov	QWORD PTR [rdi], r13

; 3247 :          z->img_comp[i].data = NULL;

	mov	QWORD PTR [rdi-8], r13
$LN161@load_jpeg_:

; 3248 :       }
; 3249 :       if (z->img_comp[i].raw_coeff) {

	mov	rcx, QWORD PTR [rdi+8]
	test	rcx, rcx
	je	SHORT $LN162@load_jpeg_

; 3250 :          STBI_FREE(z->img_comp[i].raw_coeff);

	call	QWORD PTR __imp_free

; 3251 :          z->img_comp[i].raw_coeff = 0;

	mov	QWORD PTR [rdi+8], r13

; 3252 :          z->img_comp[i].coeff = 0;

	mov	QWORD PTR [rdi+24], r13
$LN162@load_jpeg_:

; 3253 :       }
; 3254 :       if (z->img_comp[i].linebuf) {

	mov	rcx, QWORD PTR [rdi+16]
	test	rcx, rcx
	je	SHORT $LN158@load_jpeg_

; 3255 :          STBI_FREE(z->img_comp[i].linebuf);

	call	QWORD PTR __imp_free

; 3256 :          z->img_comp[i].linebuf = NULL;

	mov	QWORD PTR [rdi+16], r13
$LN158@load_jpeg_:

; 1057 : }
; 1058 : 
; 1059 : #if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
; 1060 : static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
; 1061 : {
; 1062 :    if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
; 1063 :    return stbi__malloc(a*b*c*d + add);
; 1064 : }
; 1065 : #endif
; 1066 : 
; 1067 : // returns 1 if the sum of two signed ints is valid (between -2^31 and 2^31-1 inclusive), 0 on overflow.
; 1068 : static int stbi__addints_valid(int a, int b)
; 1069 : {
; 1070 :    if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow
; 1071 :    if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.
; 1072 :    return a <= INT_MAX - b;
; 1073 : }
; 1074 : 
; 1075 : // returns 1 if the product of two signed shorts is valid, 0 on overflow.
; 1076 : static int stbi__mul2shorts_valid(short a, short b)
; 1077 : {
; 1078 :    if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow
; 1079 :    if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX/b; // product is positive, so similar to mul2sizes_valid
; 1080 :    if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN
; 1081 :    return a >= SHRT_MIN / b;
; 1082 : }
; 1083 : 
; 1084 : // stbi__err - error
; 1085 : // stbi__errpf - error returning pointer to float
; 1086 : // stbi__errpuc - error returning pointer to unsigned char
; 1087 : 
; 1088 : #ifdef STBI_NO_FAILURE_STRINGS
; 1089 :    #define stbi__err(x,y)  0
; 1090 : #elif defined(STBI_FAILURE_USERMSG)
; 1091 :    #define stbi__err(x,y)  stbi__err(y)
; 1092 : #else
; 1093 :    #define stbi__err(x,y)  stbi__err(x)
; 1094 : #endif
; 1095 : 
; 1096 : #define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
; 1097 : #define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))
; 1098 : 
; 1099 : STBIDEF void stbi_image_free(void *retval_from_stbi_load)
; 1100 : {
; 1101 :    STBI_FREE(retval_from_stbi_load);
; 1102 : }
; 1103 : 
; 1104 : #ifndef STBI_NO_LINEAR
; 1105 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
; 1106 : #endif
; 1107 : 
; 1108 : #ifndef STBI_NO_HDR
; 1109 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
; 1110 : #endif
; 1111 : 
; 1112 : static int stbi__vertically_flip_on_load_global = 0;
; 1113 : 
; 1114 : STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
; 1115 : {
; 1116 :    stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
; 1117 : }
; 1118 : 
; 1119 : #ifndef STBI_THREAD_LOCAL
; 1120 : #define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global
; 1121 : #else
; 1122 : static STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;
; 1123 : 
; 1124 : STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
; 1125 : {
; 1126 :    stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
; 1127 :    stbi__vertically_flip_on_load_set = 1;
; 1128 : }
; 1129 : 
; 1130 : #define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \
; 1131 :                                          ? stbi__vertically_flip_on_load_local  \
; 1132 :                                          : stbi__vertically_flip_on_load_global)
; 1133 : #endif // STBI_THREAD_LOCAL
; 1134 : 
; 1135 : static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
; 1136 : {
; 1137 :    memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
; 1138 :    ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
; 1139 :    ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
; 1140 :    ri->num_channels = 0;
; 1141 : 
; 1142 :    // test the formats with a very explicit header first (at least a FOURCC
; 1143 :    // or distinctive magic number first)
; 1144 :    #ifndef STBI_NO_PNG
; 1145 :    if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
; 1146 :    #endif
; 1147 :    #ifndef STBI_NO_BMP
; 1148 :    if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
; 1149 :    #endif
; 1150 :    #ifndef STBI_NO_GIF
; 1151 :    if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
; 1152 :    #endif
; 1153 :    #ifndef STBI_NO_PSD
; 1154 :    if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
; 1155 :    #else
; 1156 :    STBI_NOTUSED(bpc);
; 1157 :    #endif
; 1158 :    #ifndef STBI_NO_PIC
; 1159 :    if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
; 1160 :    #endif
; 1161 : 
; 1162 :    // then the formats that can end up attempting to load with just 1 or 2
; 1163 :    // bytes matching expectations; these are prone to false positives, so
; 1164 :    // try them later
; 1165 :    #ifndef STBI_NO_JPEG
; 1166 :    if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
; 1167 :    #endif
; 1168 :    #ifndef STBI_NO_PNM
; 1169 :    if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
; 1170 :    #endif
; 1171 : 
; 1172 :    #ifndef STBI_NO_HDR
; 1173 :    if (stbi__hdr_test(s)) {
; 1174 :       float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
; 1175 :       return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
; 1176 :    }
; 1177 :    #endif
; 1178 : 
; 1179 :    #ifndef STBI_NO_TGA
; 1180 :    // test tga last because it's a crappy test!
; 1181 :    if (stbi__tga_test(s))
; 1182 :       return stbi__tga_load(s,x,y,comp,req_comp, ri);
; 1183 :    #endif
; 1184 : 
; 1185 :    return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
; 1186 : }
; 1187 : 
; 1188 : static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
; 1189 : {
; 1190 :    int i;
; 1191 :    int img_len = w * h * channels;
; 1192 :    stbi_uc *reduced;
; 1193 : 
; 1194 :    reduced = (stbi_uc *) stbi__malloc(img_len);
; 1195 :    if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");
; 1196 : 
; 1197 :    for (i = 0; i < img_len; ++i)
; 1198 :       reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling
; 1199 : 
; 1200 :    STBI_FREE(orig);
; 1201 :    return reduced;
; 1202 : }
; 1203 : 
; 1204 : static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
; 1205 : {
; 1206 :    int i;
; 1207 :    int img_len = w * h * channels;
; 1208 :    stbi__uint16 *enlarged;
; 1209 : 
; 1210 :    enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
; 1211 :    if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1212 : 
; 1213 :    for (i = 0; i < img_len; ++i)
; 1214 :       enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff
; 1215 : 
; 1216 :    STBI_FREE(orig);
; 1217 :    return enlarged;
; 1218 : }
; 1219 : 
; 1220 : static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
; 1221 : {
; 1222 :    int row;
; 1223 :    size_t bytes_per_row = (size_t)w * bytes_per_pixel;
; 1224 :    stbi_uc temp[2048];
; 1225 :    stbi_uc *bytes = (stbi_uc *)image;
; 1226 : 
; 1227 :    for (row = 0; row < (h>>1); row++) {
; 1228 :       stbi_uc *row0 = bytes + row*bytes_per_row;
; 1229 :       stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
; 1230 :       // swap row0 with row1
; 1231 :       size_t bytes_left = bytes_per_row;
; 1232 :       while (bytes_left) {
; 1233 :          size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
; 1234 :          memcpy(temp, row0, bytes_copy);
; 1235 :          memcpy(row0, row1, bytes_copy);
; 1236 :          memcpy(row1, temp, bytes_copy);
; 1237 :          row0 += bytes_copy;
; 1238 :          row1 += bytes_copy;
; 1239 :          bytes_left -= bytes_copy;
; 1240 :       }
; 1241 :    }
; 1242 : }
; 1243 : 
; 1244 : #ifndef STBI_NO_GIF
; 1245 : static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
; 1246 : {
; 1247 :    int slice;
; 1248 :    int slice_size = w * h * bytes_per_pixel;
; 1249 : 
; 1250 :    stbi_uc *bytes = (stbi_uc *)image;
; 1251 :    for (slice = 0; slice < z; ++slice) {
; 1252 :       stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
; 1253 :       bytes += slice_size;
; 1254 :    }
; 1255 : }
; 1256 : #endif
; 1257 : 
; 1258 : static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
; 1259 : {
; 1260 :    stbi__result_info ri;
; 1261 :    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);
; 1262 : 
; 1263 :    if (result == NULL)
; 1264 :       return NULL;
; 1265 : 
; 1266 :    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1267 :    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
; 1268 : 
; 1269 :    if (ri.bits_per_channel != 8) {
; 1270 :       result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
; 1271 :       ri.bits_per_channel = 8;
; 1272 :    }
; 1273 : 
; 1274 :    // @TODO: move stbi__convert_format to here
; 1275 : 
; 1276 :    if (stbi__vertically_flip_on_load) {
; 1277 :       int channels = req_comp ? req_comp : *comp;
; 1278 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
; 1279 :    }
; 1280 : 
; 1281 :    return (unsigned char *) result;
; 1282 : }
; 1283 : 
; 1284 : static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
; 1285 : {
; 1286 :    stbi__result_info ri;
; 1287 :    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);
; 1288 : 
; 1289 :    if (result == NULL)
; 1290 :       return NULL;
; 1291 : 
; 1292 :    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1293 :    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
; 1294 : 
; 1295 :    if (ri.bits_per_channel != 16) {
; 1296 :       result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
; 1297 :       ri.bits_per_channel = 16;
; 1298 :    }
; 1299 : 
; 1300 :    // @TODO: move stbi__convert_format16 to here
; 1301 :    // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision
; 1302 : 
; 1303 :    if (stbi__vertically_flip_on_load) {
; 1304 :       int channels = req_comp ? req_comp : *comp;
; 1305 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
; 1306 :    }
; 1307 : 
; 1308 :    return (stbi__uint16 *) result;
; 1309 : }
; 1310 : 
; 1311 : #if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)
; 1312 : static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
; 1313 : {
; 1314 :    if (stbi__vertically_flip_on_load && result != NULL) {
; 1315 :       int channels = req_comp ? req_comp : *comp;
; 1316 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
; 1317 :    }
; 1318 : }
; 1319 : #endif
; 1320 : 
; 1321 : #ifndef STBI_NO_STDIO
; 1322 : 
; 1323 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1324 : STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
; 1325 : STBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);
; 1326 : #endif
; 1327 : 
; 1328 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1329 : STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
; 1330 : {
; 1331 : 	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
; 1332 : }
; 1333 : #endif
; 1334 : 
; 1335 : static FILE *stbi__fopen(char const *filename, char const *mode)
; 1336 : {
; 1337 :    FILE *f;
; 1338 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1339 :    wchar_t wMode[64];
; 1340 :    wchar_t wFilename[1024];
; 1341 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
; 1342 :       return 0;
; 1343 : 
; 1344 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
; 1345 :       return 0;
; 1346 : 
; 1347 : #if defined(_MSC_VER) && _MSC_VER >= 1400
; 1348 : 	if (0 != _wfopen_s(&f, wFilename, wMode))
; 1349 : 		f = 0;
; 1350 : #else
; 1351 :    f = _wfopen(wFilename, wMode);
; 1352 : #endif
; 1353 : 
; 1354 : #elif defined(_MSC_VER) && _MSC_VER >= 1400
; 1355 :    if (0 != fopen_s(&f, filename, mode))
; 1356 :       f=0;
; 1357 : #else
; 1358 :    f = fopen(filename, mode);
; 1359 : #endif
; 1360 :    return f;
; 1361 : }
; 1362 : 
; 1363 : 
; 1364 : STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
; 1365 : {
; 1366 :    FILE *f = stbi__fopen(filename, "rb");
; 1367 :    unsigned char *result;
; 1368 :    if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
; 1369 :    result = stbi_load_from_file(f,x,y,comp,req_comp);
; 1370 :    fclose(f);
; 1371 :    return result;
; 1372 : }
; 1373 : 
; 1374 : STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
; 1375 : {
; 1376 :    unsigned char *result;
; 1377 :    stbi__context s;
; 1378 :    stbi__start_file(&s,f);
; 1379 :    result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
; 1380 :    if (result) {
; 1381 :       // need to 'unget' all the characters in the IO buffer
; 1382 :       fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
; 1383 :    }
; 1384 :    return result;
; 1385 : }
; 1386 : 
; 1387 : STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
; 1388 : {
; 1389 :    stbi__uint16 *result;
; 1390 :    stbi__context s;
; 1391 :    stbi__start_file(&s,f);
; 1392 :    result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
; 1393 :    if (result) {
; 1394 :       // need to 'unget' all the characters in the IO buffer
; 1395 :       fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
; 1396 :    }
; 1397 :    return result;
; 1398 : }
; 1399 : 
; 1400 : STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
; 1401 : {
; 1402 :    FILE *f = stbi__fopen(filename, "rb");
; 1403 :    stbi__uint16 *result;
; 1404 :    if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");
; 1405 :    result = stbi_load_from_file_16(f,x,y,comp,req_comp);
; 1406 :    fclose(f);
; 1407 :    return result;
; 1408 : }
; 1409 : 
; 1410 : 
; 1411 : #endif //!STBI_NO_STDIO
; 1412 : 
; 1413 : STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
; 1414 : {
; 1415 :    stbi__context s;
; 1416 :    stbi__start_mem(&s,buffer,len);
; 1417 :    return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
; 1418 : }
; 1419 : 
; 1420 : STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
; 1421 : {
; 1422 :    stbi__context s;
; 1423 :    stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
; 1424 :    return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
; 1425 : }
; 1426 : 
; 1427 : STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
; 1428 : {
; 1429 :    stbi__context s;
; 1430 :    stbi__start_mem(&s,buffer,len);
; 1431 :    return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
; 1432 : }
; 1433 : 
; 1434 : STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
; 1435 : {
; 1436 :    stbi__context s;
; 1437 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
; 1438 :    return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
; 1439 : }
; 1440 : 
; 1441 : #ifndef STBI_NO_GIF
; 1442 : STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
; 1443 : {
; 1444 :    unsigned char *result;
; 1445 :    stbi__context s;
; 1446 :    stbi__start_mem(&s,buffer,len);
; 1447 : 
; 1448 :    result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
; 1449 :    if (stbi__vertically_flip_on_load) {
; 1450 :       stbi__vertical_flip_slices( result, *x, *y, *z, *comp );
; 1451 :    }
; 1452 : 
; 1453 :    return result;
; 1454 : }
; 1455 : #endif
; 1456 : 
; 1457 : #ifndef STBI_NO_LINEAR
; 1458 : static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
; 1459 : {
; 1460 :    unsigned char *data;
; 1461 :    #ifndef STBI_NO_HDR
; 1462 :    if (stbi__hdr_test(s)) {
; 1463 :       stbi__result_info ri;
; 1464 :       float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
; 1465 :       if (hdr_data)
; 1466 :          stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
; 1467 :       return hdr_data;
; 1468 :    }
; 1469 :    #endif
; 1470 :    data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
; 1471 :    if (data)
; 1472 :       return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
; 1473 :    return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
; 1474 : }
; 1475 : 
; 1476 : STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
; 1477 : {
; 1478 :    stbi__context s;
; 1479 :    stbi__start_mem(&s,buffer,len);
; 1480 :    return stbi__loadf_main(&s,x,y,comp,req_comp);
; 1481 : }
; 1482 : 
; 1483 : STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
; 1484 : {
; 1485 :    stbi__context s;
; 1486 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
; 1487 :    return stbi__loadf_main(&s,x,y,comp,req_comp);
; 1488 : }
; 1489 : 
; 1490 : #ifndef STBI_NO_STDIO
; 1491 : STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
; 1492 : {
; 1493 :    float *result;
; 1494 :    FILE *f = stbi__fopen(filename, "rb");
; 1495 :    if (!f) return stbi__errpf("can't fopen", "Unable to open file");
; 1496 :    result = stbi_loadf_from_file(f,x,y,comp,req_comp);
; 1497 :    fclose(f);
; 1498 :    return result;
; 1499 : }
; 1500 : 
; 1501 : STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
; 1502 : {
; 1503 :    stbi__context s;
; 1504 :    stbi__start_file(&s,f);
; 1505 :    return stbi__loadf_main(&s,x,y,comp,req_comp);
; 1506 : }
; 1507 : #endif // !STBI_NO_STDIO
; 1508 : 
; 1509 : #endif // !STBI_NO_LINEAR
; 1510 : 
; 1511 : // these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
; 1512 : // defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
; 1513 : // reports false!
; 1514 : 
; 1515 : STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
; 1516 : {
; 1517 :    #ifndef STBI_NO_HDR
; 1518 :    stbi__context s;
; 1519 :    stbi__start_mem(&s,buffer,len);
; 1520 :    return stbi__hdr_test(&s);
; 1521 :    #else
; 1522 :    STBI_NOTUSED(buffer);
; 1523 :    STBI_NOTUSED(len);
; 1524 :    return 0;
; 1525 :    #endif
; 1526 : }
; 1527 : 
; 1528 : #ifndef STBI_NO_STDIO
; 1529 : STBIDEF int      stbi_is_hdr          (char const *filename)
; 1530 : {
; 1531 :    FILE *f = stbi__fopen(filename, "rb");
; 1532 :    int result=0;
; 1533 :    if (f) {
; 1534 :       result = stbi_is_hdr_from_file(f);
; 1535 :       fclose(f);
; 1536 :    }
; 1537 :    return result;
; 1538 : }
; 1539 : 
; 1540 : STBIDEF int stbi_is_hdr_from_file(FILE *f)
; 1541 : {
; 1542 :    #ifndef STBI_NO_HDR
; 1543 :    long pos = ftell(f);
; 1544 :    int res;
; 1545 :    stbi__context s;
; 1546 :    stbi__start_file(&s,f);
; 1547 :    res = stbi__hdr_test(&s);
; 1548 :    fseek(f, pos, SEEK_SET);
; 1549 :    return res;
; 1550 :    #else
; 1551 :    STBI_NOTUSED(f);
; 1552 :    return 0;
; 1553 :    #endif
; 1554 : }
; 1555 : #endif // !STBI_NO_STDIO
; 1556 : 
; 1557 : STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
; 1558 : {
; 1559 :    #ifndef STBI_NO_HDR
; 1560 :    stbi__context s;
; 1561 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
; 1562 :    return stbi__hdr_test(&s);
; 1563 :    #else
; 1564 :    STBI_NOTUSED(clbk);
; 1565 :    STBI_NOTUSED(user);
; 1566 :    return 0;
; 1567 :    #endif
; 1568 : }
; 1569 : 
; 1570 : #ifndef STBI_NO_LINEAR
; 1571 : static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;
; 1572 : 
; 1573 : STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
; 1574 : STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
; 1575 : #endif
; 1576 : 
; 1577 : static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;
; 1578 : 
; 1579 : STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
; 1580 : STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }
; 1581 : 
; 1582 : 
; 1583 : //////////////////////////////////////////////////////////////////////////////
; 1584 : //
; 1585 : // Common code used by all image loaders
; 1586 : //
; 1587 : 
; 1588 : enum
; 1589 : {
; 1590 :    STBI__SCAN_load=0,
; 1591 :    STBI__SCAN_type,
; 1592 :    STBI__SCAN_header
; 1593 : };
; 1594 : 
; 1595 : static void stbi__refill_buffer(stbi__context *s)
; 1596 : {
; 1597 :    int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
; 1598 :    s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);
; 1599 :    if (n == 0) {
; 1600 :       // at end of file, treat same as if from memory, but need to handle case
; 1601 :       // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
; 1602 :       s->read_from_callbacks = 0;
; 1603 :       s->img_buffer = s->buffer_start;
; 1604 :       s->img_buffer_end = s->buffer_start+1;
; 1605 :       *s->img_buffer = 0;
; 1606 :    } else {
; 1607 :       s->img_buffer = s->buffer_start;
; 1608 :       s->img_buffer_end = s->buffer_start + n;
; 1609 :    }
; 1610 : }
; 1611 : 
; 1612 : stbi_inline static stbi_uc stbi__get8(stbi__context *s)
; 1613 : {
; 1614 :    if (s->img_buffer < s->img_buffer_end)
; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {
; 1617 :       stbi__refill_buffer(s);
; 1618 :       return *s->img_buffer++;
; 1619 :    }
; 1620 :    return 0;
; 1621 : }
; 1622 : 
; 1623 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1624 : // nothing
; 1625 : #else
; 1626 : stbi_inline static int stbi__at_eof(stbi__context *s)
; 1627 : {
; 1628 :    if (s->io.read) {
; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;
; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;
; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;
; 1636 : }
; 1637 : #endif
; 1638 : 
; 1639 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
; 1640 : // nothing
; 1641 : #else
; 1642 : static void stbi__skip(stbi__context *s, int n)
; 1643 : {
; 1644 :    if (n == 0) return;  // already there!
; 1645 :    if (n < 0) {
; 1646 :       s->img_buffer = s->img_buffer_end;
; 1647 :       return;
; 1648 :    }
; 1649 :    if (s->io.read) {
; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1651 :       if (blen < n) {
; 1652 :          s->img_buffer = s->img_buffer_end;
; 1653 :          (s->io.skip)(s->io_user_data, n - blen);
; 1654 :          return;
; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;
; 1658 : }
; 1659 : #endif
; 1660 : 
; 1661 : #if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
; 1662 : // nothing
; 1663 : #else
; 1664 : static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
; 1665 : {
; 1666 :    if (s->io.read) {
; 1667 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1668 :       if (blen < n) {
; 1669 :          int res, count;
; 1670 : 
; 1671 :          memcpy(buffer, s->img_buffer, blen);
; 1672 : 
; 1673 :          count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
; 1674 :          res = (count == (n-blen));
; 1675 :          s->img_buffer = s->img_buffer_end;
; 1676 :          return res;
; 1677 :       }
; 1678 :    }
; 1679 : 
; 1680 :    if (s->img_buffer+n <= s->img_buffer_end) {
; 1681 :       memcpy(buffer, s->img_buffer, n);
; 1682 :       s->img_buffer += n;
; 1683 :       return 1;
; 1684 :    } else
; 1685 :       return 0;
; 1686 : }
; 1687 : #endif
; 1688 : 
; 1689 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1690 : // nothing
; 1691 : #else
; 1692 : static int stbi__get16be(stbi__context *s)
; 1693 : {
; 1694 :    int z = stbi__get8(s);
; 1695 :    return (z << 8) + stbi__get8(s);
; 1696 : }
; 1697 : #endif
; 1698 : 
; 1699 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1700 : // nothing
; 1701 : #else
; 1702 : static stbi__uint32 stbi__get32be(stbi__context *s)
; 1703 : {
; 1704 :    stbi__uint32 z = stbi__get16be(s);
; 1705 :    return (z << 16) + stbi__get16be(s);
; 1706 : }
; 1707 : #endif
; 1708 : 
; 1709 : #if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
; 1710 : // nothing
; 1711 : #else
; 1712 : static int stbi__get16le(stbi__context *s)
; 1713 : {
; 1714 :    int z = stbi__get8(s);
; 1715 :    return z + (stbi__get8(s) << 8);
; 1716 : }
; 1717 : #endif
; 1718 : 
; 1719 : #ifndef STBI_NO_BMP
; 1720 : static stbi__uint32 stbi__get32le(stbi__context *s)
; 1721 : {
; 1722 :    stbi__uint32 z = stbi__get16le(s);
; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;
; 1724 :    return z;
; 1725 : }
; 1726 : #endif
; 1727 : 
; 1728 : #define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
; 1729 : 
; 1730 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1731 : // nothing
; 1732 : #else
; 1733 : //////////////////////////////////////////////////////////////////////////////
; 1734 : //
; 1735 : //  generic converter from built-in img_n to req_comp
; 1736 : //    individual types do this automatically as much as possible (e.g. jpeg
; 1737 : //    does all cases internally since it needs to colorspace convert anyway,
; 1738 : //    and it never has alpha, so very few cases ). png can automatically
; 1739 : //    interleave an alpha=255 channel, but falls back to this for other cases
; 1740 : //
; 1741 : //  assume data buffer is malloced, so malloc a new one and free that one
; 1742 : //  only failure mode is malloc failing
; 1743 : 
; 1744 : static stbi_uc stbi__compute_y(int r, int g, int b)
; 1745 : {
; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1747 : }
; 1748 : #endif
; 1749 : 
; 1750 : #if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1751 : // nothing
; 1752 : #else
; 1753 : static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1754 : {
; 1755 :    int i,j;
; 1756 :    unsigned char *good;
; 1757 : 
; 1758 :    if (req_comp == img_n) return data;
; 1759 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1760 : 
; 1761 :    good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
; 1762 :    if (good == NULL) {
; 1763 :       STBI_FREE(data);
; 1764 :       return stbi__errpuc("outofmem", "Out of memory");
; 1765 :    }
; 1766 : 
; 1767 :    for (j=0; j < (int) y; ++j) {
; 1768 :       unsigned char *src  = data + j * x * img_n   ;
; 1769 :       unsigned char *dest = good + j * x * req_comp;
; 1770 : 
; 1771 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1772 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1773 :       // convert source image with img_n components to one with req_comp components;
; 1774 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1775 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1776 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
; 1777 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1778 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
; 1779 :          STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
; 1780 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1781 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
; 1782 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
; 1783 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1784 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
; 1785 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1786 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1787 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
; 1788 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
; 1789 :       }
; 1790 :       #undef STBI__CASE
; 1791 :    }
; 1792 : 
; 1793 :    STBI_FREE(data);
; 1794 :    return good;
; 1795 : }
; 1796 : #endif
; 1797 : 
; 1798 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1799 : // nothing
; 1800 : #else
; 1801 : static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
; 1802 : {
; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1804 : }
; 1805 : #endif
; 1806 : 
; 1807 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1808 : // nothing
; 1809 : #else
; 1810 : static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1811 : {
; 1812 :    int i,j;
; 1813 :    stbi__uint16 *good;
; 1814 : 
; 1815 :    if (req_comp == img_n) return data;
; 1816 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1817 : 
; 1818 :    good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
; 1819 :    if (good == NULL) {
; 1820 :       STBI_FREE(data);
; 1821 :       return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1822 :    }
; 1823 : 
; 1824 :    for (j=0; j < (int) y; ++j) {
; 1825 :       stbi__uint16 *src  = data + j * x * img_n   ;
; 1826 :       stbi__uint16 *dest = good + j * x * req_comp;
; 1827 : 
; 1828 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1829 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1830 :       // convert source image with img_n components to one with req_comp components;
; 1831 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1832 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1833 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
; 1834 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1835 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
; 1836 :          STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
; 1837 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1838 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
; 1839 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
; 1840 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1841 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
; 1842 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1843 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1844 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
; 1845 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
; 1846 :       }
; 1847 :       #undef STBI__CASE
; 1848 :    }
; 1849 : 
; 1850 :    STBI_FREE(data);
; 1851 :    return good;
; 1852 : }
; 1853 : #endif
; 1854 : 
; 1855 : #ifndef STBI_NO_LINEAR
; 1856 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
; 1857 : {
; 1858 :    int i,k,n;
; 1859 :    float *output;
; 1860 :    if (!data) return NULL;
; 1861 :    output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
; 1862 :    if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
; 1863 :    // compute number of non-alpha components
; 1864 :    if (comp & 1) n = comp; else n = comp-1;
; 1865 :    for (i=0; i < x*y; ++i) {
; 1866 :       for (k=0; k < n; ++k) {
; 1867 :          output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
; 1868 :       }
; 1869 :    }
; 1870 :    if (n < comp) {
; 1871 :       for (i=0; i < x*y; ++i) {
; 1872 :          output[i*comp + n] = data[i*comp + n]/255.0f;
; 1873 :       }
; 1874 :    }
; 1875 :    STBI_FREE(data);
; 1876 :    return output;
; 1877 : }
; 1878 : #endif
; 1879 : 
; 1880 : #ifndef STBI_NO_HDR
; 1881 : #define stbi__float2int(x)   ((int) (x))
; 1882 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
; 1883 : {
; 1884 :    int i,k,n;
; 1885 :    stbi_uc *output;
; 1886 :    if (!data) return NULL;
; 1887 :    output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
; 1888 :    if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
; 1889 :    // compute number of non-alpha components
; 1890 :    if (comp & 1) n = comp; else n = comp-1;
; 1891 :    for (i=0; i < x*y; ++i) {
; 1892 :       for (k=0; k < n; ++k) {
; 1893 :          float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
; 1894 :          if (z < 0) z = 0;
; 1895 :          if (z > 255) z = 255;
; 1896 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1897 :       }
; 1898 :       if (k < comp) {
; 1899 :          float z = data[i*comp+k] * 255 + 0.5f;
; 1900 :          if (z < 0) z = 0;
; 1901 :          if (z > 255) z = 255;
; 1902 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1903 :       }
; 1904 :    }
; 1905 :    STBI_FREE(data);
; 1906 :    return output;
; 1907 : }
; 1908 : #endif
; 1909 : 
; 1910 : //////////////////////////////////////////////////////////////////////////////
; 1911 : //
; 1912 : //  "baseline" JPEG/JFIF decoder
; 1913 : //
; 1914 : //    simple implementation
; 1915 : //      - doesn't support delayed output of y-dimension
; 1916 : //      - simple interface (only one output format: 8-bit interleaved RGB)
; 1917 : //      - doesn't try to recover corrupt jpegs
; 1918 : //      - doesn't allow partial loading, loading multiple at once
; 1919 : //      - still fast on x86 (copying globals into locals doesn't help x86)
; 1920 : //      - allocates lots of intermediate memory (full size of all components)
; 1921 : //        - non-interleaved case requires this anyway
; 1922 : //        - allows good upsampling (see next)
; 1923 : //    high-quality
; 1924 : //      - upsampled channels are bilinearly interpolated, even across blocks
; 1925 : //      - quality integer IDCT derived from IJG's 'slow'
; 1926 : //    performance
; 1927 : //      - fast huffman; reasonable integer IDCT
; 1928 : //      - some SIMD kernels for common paths on targets with SSE2/NEON
; 1929 : //      - uses a lot of intermediate memory, could cache poorly
; 1930 : 
; 1931 : #ifndef STBI_NO_JPEG
; 1932 : 
; 1933 : // huffman decoding acceleration
; 1934 : #define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
; 1935 : 
; 1936 : typedef struct
; 1937 : {
; 1938 :    stbi_uc  fast[1 << FAST_BITS];
; 1939 :    // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
; 1940 :    stbi__uint16 code[256];
; 1941 :    stbi_uc  values[256];
; 1942 :    stbi_uc  size[257];
; 1943 :    unsigned int maxcode[18];
; 1944 :    int    delta[17];   // old 'firstsymbol' - old 'firstcode'
; 1945 : } stbi__huffman;
; 1946 : 
; 1947 : typedef struct
; 1948 : {
; 1949 :    stbi__context *s;
; 1950 :    stbi__huffman huff_dc[4];
; 1951 :    stbi__huffman huff_ac[4];
; 1952 :    stbi__uint16 dequant[4][64];
; 1953 :    stbi__int16 fast_ac[4][1 << FAST_BITS];
; 1954 : 
; 1955 : // sizes for components, interleaved MCUs
; 1956 :    int img_h_max, img_v_max;
; 1957 :    int img_mcu_x, img_mcu_y;
; 1958 :    int img_mcu_w, img_mcu_h;
; 1959 : 
; 1960 : // definition of jpeg image component
; 1961 :    struct
; 1962 :    {
; 1963 :       int id;
; 1964 :       int h,v;
; 1965 :       int tq;
; 1966 :       int hd,ha;
; 1967 :       int dc_pred;
; 1968 : 
; 1969 :       int x,y,w2,h2;
; 1970 :       stbi_uc *data;
; 1971 :       void *raw_data, *raw_coeff;
; 1972 :       stbi_uc *linebuf;
; 1973 :       short   *coeff;   // progressive only
; 1974 :       int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
; 1975 :    } img_comp[4];
; 1976 : 
; 1977 :    stbi__uint32   code_buffer; // jpeg entropy-coded buffer
; 1978 :    int            code_bits;   // number of valid bits
; 1979 :    unsigned char  marker;      // marker seen while filling entropy buffer
; 1980 :    int            nomore;      // flag if we saw a marker so must stop
; 1981 : 
; 1982 :    int            progressive;
; 1983 :    int            spec_start;
; 1984 :    int            spec_end;
; 1985 :    int            succ_high;
; 1986 :    int            succ_low;
; 1987 :    int            eob_run;
; 1988 :    int            jfif;
; 1989 :    int            app14_color_transform; // Adobe APP14 tag
; 1990 :    int            rgb;
; 1991 : 
; 1992 :    int scan_n, order[4];
; 1993 :    int restart_interval, todo;
; 1994 : 
; 1995 : // kernels
; 1996 :    void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
; 1997 :    void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
; 1998 :    stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
; 1999 : } stbi__jpeg;
; 2000 : 
; 2001 : static int stbi__build_huffman(stbi__huffman *h, int *count)
; 2002 : {
; 2003 :    int i,j,k=0;
; 2004 :    unsigned int code;
; 2005 :    // build size list for each symbol (from JPEG spec)
; 2006 :    for (i=0; i < 16; ++i) {
; 2007 :       for (j=0; j < count[i]; ++j) {
; 2008 :          h->size[k++] = (stbi_uc) (i+1);
; 2009 :          if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");
; 2010 :       }
; 2011 :    }
; 2012 :    h->size[k] = 0;
; 2013 : 
; 2014 :    // compute actual symbols (from jpeg spec)
; 2015 :    code = 0;
; 2016 :    k = 0;
; 2017 :    for(j=1; j <= 16; ++j) {
; 2018 :       // compute delta to add to code to compute symbol id
; 2019 :       h->delta[j] = k - code;
; 2020 :       if (h->size[k] == j) {
; 2021 :          while (h->size[k] == j)
; 2022 :             h->code[k++] = (stbi__uint16) (code++);
; 2023 :          if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
; 2024 :       }
; 2025 :       // compute largest code + 1 for this size, preshifted as needed later
; 2026 :       h->maxcode[j] = code << (16-j);
; 2027 :       code <<= 1;
; 2028 :    }
; 2029 :    h->maxcode[j] = 0xffffffff;
; 2030 : 
; 2031 :    // build non-spec acceleration table; 255 is flag for not-accelerated
; 2032 :    memset(h->fast, 255, 1 << FAST_BITS);
; 2033 :    for (i=0; i < k; ++i) {
; 2034 :       int s = h->size[i];
; 2035 :       if (s <= FAST_BITS) {
; 2036 :          int c = h->code[i] << (FAST_BITS-s);
; 2037 :          int m = 1 << (FAST_BITS-s);
; 2038 :          for (j=0; j < m; ++j) {
; 2039 :             h->fast[c+j] = (stbi_uc) i;
; 2040 :          }
; 2041 :       }
; 2042 :    }
; 2043 :    return 1;
; 2044 : }
; 2045 : 
; 2046 : // build a table that decodes both magnitude and value of small ACs in
; 2047 : // one go.
; 2048 : static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
; 2049 : {
; 2050 :    int i;
; 2051 :    for (i=0; i < (1 << FAST_BITS); ++i) {
; 2052 :       stbi_uc fast = h->fast[i];
; 2053 :       fast_ac[i] = 0;
; 2054 :       if (fast < 255) {
; 2055 :          int rs = h->values[fast];
; 2056 :          int run = (rs >> 4) & 15;
; 2057 :          int magbits = rs & 15;
; 2058 :          int len = h->size[fast];
; 2059 : 
; 2060 :          if (magbits && len + magbits <= FAST_BITS) {
; 2061 :             // magnitude code followed by receive_extend code
; 2062 :             int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
; 2063 :             int m = 1 << (magbits - 1);
; 2064 :             if (k < m) k += (~0U << magbits) + 1;
; 2065 :             // if the result is small enough, we can fit it in fast_ac table
; 2066 :             if (k >= -128 && k <= 127)
; 2067 :                fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
; 2068 :          }
; 2069 :       }
; 2070 :    }
; 2071 : }
; 2072 : 
; 2073 : static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
; 2074 : {
; 2075 :    do {
; 2076 :       unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
; 2077 :       if (b == 0xff) {
; 2078 :          int c = stbi__get8(j->s);
; 2079 :          while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
; 2080 :          if (c != 0) {
; 2081 :             j->marker = (unsigned char) c;
; 2082 :             j->nomore = 1;
; 2083 :             return;
; 2084 :          }
; 2085 :       }
; 2086 :       j->code_buffer |= b << (24 - j->code_bits);
; 2087 :       j->code_bits += 8;
; 2088 :    } while (j->code_bits <= 24);
; 2089 : }
; 2090 : 
; 2091 : // (1 << n) - 1
; 2092 : static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
; 2093 : 
; 2094 : // decode a jpeg huffman value from the bitstream
; 2095 : stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
; 2096 : {
; 2097 :    unsigned int temp;
; 2098 :    int c,k;
; 2099 : 
; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2105 :    k = h->fast[c];
; 2106 :    if (k < 255) {
; 2107 :       int s = h->size[k];
; 2108 :       if (s > j->code_bits)
; 2109 :          return -1;
; 2110 :       j->code_buffer <<= s;
; 2111 :       j->code_bits -= s;
; 2112 :       return h->values[k];
; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;
; 2122 :    for (k=FAST_BITS+1 ; ; ++k)
; 2123 :       if (temp < h->maxcode[k])
; 2124 :          break;
; 2125 :    if (k == 17) {
; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;
; 2128 :       return -1;
; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)
; 2132 :       return -1;
; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!
; 2137 :        return -1;
; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;
; 2142 :    j->code_buffer <<= k;
; 2143 :    return h->values[c];
; 2144 : }
; 2145 : 
; 2146 : // bias[n] = (-1<<n) + 1
; 2147 : static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};
; 2148 : 
; 2149 : // combined JPEG 'receive' and JPEG 'extend', since baseline
; 2150 : // always extends everything it receives.
; 2151 : stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
; 2152 : {
; 2153 :    unsigned int k;
; 2154 :    int sgn;
; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
; 2159 :    k = stbi_lrot(j->code_buffer, n);
; 2160 :    j->code_buffer = k & ~stbi__bmask[n];
; 2161 :    k &= stbi__bmask[n];
; 2162 :    j->code_bits -= n;
; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));
; 2164 : }
; 2165 : 
; 2166 : // get some unsigned bits
; 2167 : stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
; 2168 : {
; 2169 :    unsigned int k;
; 2170 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2171 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2172 :    k = stbi_lrot(j->code_buffer, n);
; 2173 :    j->code_buffer = k & ~stbi__bmask[n];
; 2174 :    k &= stbi__bmask[n];
; 2175 :    j->code_bits -= n;
; 2176 :    return k;
; 2177 : }
; 2178 : 
; 2179 : stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
; 2180 : {
; 2181 :    unsigned int k;
; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2184 :    k = j->code_buffer;
; 2185 :    j->code_buffer <<= 1;
; 2186 :    --j->code_bits;
; 2187 :    return k & 0x80000000;
; 2188 : }
; 2189 : 
; 2190 : // given a value that's at position X in the zigzag stream,
; 2191 : // where does it appear in the 8x8 matrix coded as row-major?
; 2192 : static const stbi_uc stbi__jpeg_dezigzag[64+15] =
; 2193 : {
; 2194 :     0,  1,  8, 16,  9,  2,  3, 10,
; 2195 :    17, 24, 32, 25, 18, 11,  4,  5,
; 2196 :    12, 19, 26, 33, 40, 48, 41, 34,
; 2197 :    27, 20, 13,  6,  7, 14, 21, 28,
; 2198 :    35, 42, 49, 56, 57, 50, 43, 36,
; 2199 :    29, 22, 15, 23, 30, 37, 44, 51,
; 2200 :    58, 59, 52, 45, 38, 31, 39, 46,
; 2201 :    53, 60, 61, 54, 47, 55, 62, 63,
; 2202 :    // let corrupt input sample past end
; 2203 :    63, 63, 63, 63, 63, 63, 63, 63,
; 2204 :    63, 63, 63, 63, 63, 63, 63
; 2205 : };
; 2206 : 
; 2207 : // decode one 64-entry block--
; 2208 : static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
; 2209 : {
; 2210 :    int diff,dc,k;
; 2211 :    int t;
; 2212 : 
; 2213 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2214 :    t = stbi__jpeg_huff_decode(j, hdc);
; 2215 :    if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");
; 2216 : 
; 2217 :    // 0 all the ac values now so we can do it 32-bits at a time
; 2218 :    memset(data,0,64*sizeof(data[0]));
; 2219 : 
; 2220 :    diff = t ? stbi__extend_receive(j, t) : 0;
; 2221 :    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");
; 2222 :    dc = j->img_comp[b].dc_pred + diff;
; 2223 :    j->img_comp[b].dc_pred = dc;
; 2224 :    if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2225 :    data[0] = (short) (dc * dequant[0]);
; 2226 : 
; 2227 :    // decode AC components, see JPEG spec
; 2228 :    k = 1;
; 2229 :    do {
; 2230 :       unsigned int zig;
; 2231 :       int c,r,s;
; 2232 :       if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2233 :       c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2234 :       r = fac[c];
; 2235 :       if (r) { // fast-AC path
; 2236 :          k += (r >> 4) & 15; // run
; 2237 :          s = r & 15; // combined length
; 2238 :          if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2239 :          j->code_buffer <<= s;
; 2240 :          j->code_bits -= s;
; 2241 :          // decode into unzigzag'd location
; 2242 :          zig = stbi__jpeg_dezigzag[k++];
; 2243 :          data[zig] = (short) ((r >> 8) * dequant[zig]);
; 2244 :       } else {
; 2245 :          int rs = stbi__jpeg_huff_decode(j, hac);
; 2246 :          if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2247 :          s = rs & 15;
; 2248 :          r = rs >> 4;
; 2249 :          if (s == 0) {
; 2250 :             if (rs != 0xf0) break; // end block
; 2251 :             k += 16;
; 2252 :          } else {
; 2253 :             k += r;
; 2254 :             // decode into unzigzag'd location
; 2255 :             zig = stbi__jpeg_dezigzag[k++];
; 2256 :             data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
; 2257 :          }
; 2258 :       }
; 2259 :    } while (k < 64);
; 2260 :    return 1;
; 2261 : }
; 2262 : 
; 2263 : static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
; 2264 : {
; 2265 :    int diff,dc;
; 2266 :    int t;
; 2267 :    if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2268 : 
; 2269 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2270 : 
; 2271 :    if (j->succ_high == 0) {
; 2272 :       // first scan for DC coefficient, must be first
; 2273 :       memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
; 2274 :       t = stbi__jpeg_huff_decode(j, hdc);
; 2275 :       if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2276 :       diff = t ? stbi__extend_receive(j, t) : 0;
; 2277 : 
; 2278 :       if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");
; 2279 :       dc = j->img_comp[b].dc_pred + diff;
; 2280 :       j->img_comp[b].dc_pred = dc;
; 2281 :       if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2282 :       data[0] = (short) (dc * (1 << j->succ_low));
; 2283 :    } else {
; 2284 :       // refinement scan for DC coefficient
; 2285 :       if (stbi__jpeg_get_bit(j))
; 2286 :          data[0] += (short) (1 << j->succ_low);
; 2287 :    }
; 2288 :    return 1;
; 2289 : }
; 2290 : 
; 2291 : // @OPTIMIZE: store non-zigzagged during the decode passes,
; 2292 : // and only de-zigzag when dequantizing
; 2293 : static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
; 2294 : {
; 2295 :    int k;
; 2296 :    if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2297 : 
; 2298 :    if (j->succ_high == 0) {
; 2299 :       int shift = j->succ_low;
; 2300 : 
; 2301 :       if (j->eob_run) {
; 2302 :          --j->eob_run;
; 2303 :          return 1;
; 2304 :       }
; 2305 : 
; 2306 :       k = j->spec_start;
; 2307 :       do {
; 2308 :          unsigned int zig;
; 2309 :          int c,r,s;
; 2310 :          if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2311 :          c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2312 :          r = fac[c];
; 2313 :          if (r) { // fast-AC path
; 2314 :             k += (r >> 4) & 15; // run
; 2315 :             s = r & 15; // combined length
; 2316 :             if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2317 :             j->code_buffer <<= s;
; 2318 :             j->code_bits -= s;
; 2319 :             zig = stbi__jpeg_dezigzag[k++];
; 2320 :             data[zig] = (short) ((r >> 8) * (1 << shift));
; 2321 :          } else {
; 2322 :             int rs = stbi__jpeg_huff_decode(j, hac);
; 2323 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2324 :             s = rs & 15;
; 2325 :             r = rs >> 4;
; 2326 :             if (s == 0) {
; 2327 :                if (r < 15) {
; 2328 :                   j->eob_run = (1 << r);
; 2329 :                   if (r)
; 2330 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2331 :                   --j->eob_run;
; 2332 :                   break;
; 2333 :                }
; 2334 :                k += 16;
; 2335 :             } else {
; 2336 :                k += r;
; 2337 :                zig = stbi__jpeg_dezigzag[k++];
; 2338 :                data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
; 2339 :             }
; 2340 :          }
; 2341 :       } while (k <= j->spec_end);
; 2342 :    } else {
; 2343 :       // refinement scan for these AC coefficients
; 2344 : 
; 2345 :       short bit = (short) (1 << j->succ_low);
; 2346 : 
; 2347 :       if (j->eob_run) {
; 2348 :          --j->eob_run;
; 2349 :          for (k = j->spec_start; k <= j->spec_end; ++k) {
; 2350 :             short *p = &data[stbi__jpeg_dezigzag[k]];
; 2351 :             if (*p != 0)
; 2352 :                if (stbi__jpeg_get_bit(j))
; 2353 :                   if ((*p & bit)==0) {
; 2354 :                      if (*p > 0)
; 2355 :                         *p += bit;
; 2356 :                      else
; 2357 :                         *p -= bit;
; 2358 :                   }
; 2359 :          }
; 2360 :       } else {
; 2361 :          k = j->spec_start;
; 2362 :          do {
; 2363 :             int r,s;
; 2364 :             int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
; 2365 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2366 :             s = rs & 15;
; 2367 :             r = rs >> 4;
; 2368 :             if (s == 0) {
; 2369 :                if (r < 15) {
; 2370 :                   j->eob_run = (1 << r) - 1;
; 2371 :                   if (r)
; 2372 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2373 :                   r = 64; // force end of block
; 2374 :                } else {
; 2375 :                   // r=15 s=0 should write 16 0s, so we just do
; 2376 :                   // a run of 15 0s and then write s (which is 0),
; 2377 :                   // so we don't have to do anything special here
; 2378 :                }
; 2379 :             } else {
; 2380 :                if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
; 2381 :                // sign bit
; 2382 :                if (stbi__jpeg_get_bit(j))
; 2383 :                   s = bit;
; 2384 :                else
; 2385 :                   s = -bit;
; 2386 :             }
; 2387 : 
; 2388 :             // advance by r
; 2389 :             while (k <= j->spec_end) {
; 2390 :                short *p = &data[stbi__jpeg_dezigzag[k++]];
; 2391 :                if (*p != 0) {
; 2392 :                   if (stbi__jpeg_get_bit(j))
; 2393 :                      if ((*p & bit)==0) {
; 2394 :                         if (*p > 0)
; 2395 :                            *p += bit;
; 2396 :                         else
; 2397 :                            *p -= bit;
; 2398 :                      }
; 2399 :                } else {
; 2400 :                   if (r == 0) {
; 2401 :                      *p = (short) s;
; 2402 :                      break;
; 2403 :                   }
; 2404 :                   --r;
; 2405 :                }
; 2406 :             }
; 2407 :          } while (k <= j->spec_end);
; 2408 :       }
; 2409 :    }
; 2410 :    return 1;
; 2411 : }
; 2412 : 
; 2413 : // take a -128..127 value and stbi__clamp it and convert to 0..255
; 2414 : stbi_inline static stbi_uc stbi__clamp(int x)
; 2415 : {
; 2416 :    // trick to use a single test to catch both cases
; 2417 :    if ((unsigned int) x > 255) {
; 2418 :       if (x < 0) return 0;
; 2419 :       if (x > 255) return 255;
; 2420 :    }
; 2421 :    return (stbi_uc) x;
; 2422 : }
; 2423 : 
; 2424 : #define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
; 2425 : #define stbi__fsh(x)  ((x) * 4096)
; 2426 : 
; 2427 : // derived from jidctint -- DCT_ISLOW
; 2428 : #define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
; 2429 :    int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
; 2430 :    p2 = s2;                                    \
; 2431 :    p3 = s6;                                    \
; 2432 :    p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
; 2433 :    t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
; 2434 :    t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
; 2435 :    p2 = s0;                                    \
; 2436 :    p3 = s4;                                    \
; 2437 :    t0 = stbi__fsh(p2+p3);                      \
; 2438 :    t1 = stbi__fsh(p2-p3);                      \
; 2439 :    x0 = t0+t3;                                 \
; 2440 :    x3 = t0-t3;                                 \
; 2441 :    x1 = t1+t2;                                 \
; 2442 :    x2 = t1-t2;                                 \
; 2443 :    t0 = s7;                                    \
; 2444 :    t1 = s5;                                    \
; 2445 :    t2 = s3;                                    \
; 2446 :    t3 = s1;                                    \
; 2447 :    p3 = t0+t2;                                 \
; 2448 :    p4 = t1+t3;                                 \
; 2449 :    p1 = t0+t3;                                 \
; 2450 :    p2 = t1+t2;                                 \
; 2451 :    p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
; 2452 :    t0 = t0*stbi__f2f( 0.298631336f);           \
; 2453 :    t1 = t1*stbi__f2f( 2.053119869f);           \
; 2454 :    t2 = t2*stbi__f2f( 3.072711026f);           \
; 2455 :    t3 = t3*stbi__f2f( 1.501321110f);           \
; 2456 :    p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
; 2457 :    p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
; 2458 :    p3 = p3*stbi__f2f(-1.961570560f);           \
; 2459 :    p4 = p4*stbi__f2f(-0.390180644f);           \
; 2460 :    t3 += p1+p4;                                \
; 2461 :    t2 += p2+p3;                                \
; 2462 :    t1 += p2+p4;                                \
; 2463 :    t0 += p1+p3;
; 2464 : 
; 2465 : static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
; 2466 : {
; 2467 :    int i,val[64],*v=val;
; 2468 :    stbi_uc *o;
; 2469 :    short *d = data;
; 2470 : 
; 2471 :    // columns
; 2472 :    for (i=0; i < 8; ++i,++d, ++v) {
; 2473 :       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2474 :       if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2475 :            && d[40]==0 && d[48]==0 && d[56]==0) {
; 2476 :          //    no shortcut                 0     seconds
; 2477 :          //    (1|2|3|4|5|6|7)==0          0     seconds
; 2478 :          //    all separate               -0.047 seconds
; 2479 :          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2480 :          int dcterm = d[0]*4;
; 2481 :          v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
; 2482 :       } else {
; 2483 :          STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
; 2484 :          // constants scaled things up by 1<<12; let's bring them back
; 2485 :          // down, but keep 2 extra bits of precision
; 2486 :          x0 += 512; x1 += 512; x2 += 512; x3 += 512;
; 2487 :          v[ 0] = (x0+t3) >> 10;
; 2488 :          v[56] = (x0-t3) >> 10;
; 2489 :          v[ 8] = (x1+t2) >> 10;
; 2490 :          v[48] = (x1-t2) >> 10;
; 2491 :          v[16] = (x2+t1) >> 10;
; 2492 :          v[40] = (x2-t1) >> 10;
; 2493 :          v[24] = (x3+t0) >> 10;
; 2494 :          v[32] = (x3-t0) >> 10;
; 2495 :       }
; 2496 :    }
; 2497 : 
; 2498 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
; 2499 :       // no fast case since the first 1D IDCT spread components out
; 2500 :       STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
; 2501 :       // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2502 :       // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2503 :       // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2504 :       // so we want to round that, which means adding 0.5 * 1<<17,
; 2505 :       // aka 65536. Also, we'll end up with -128 to 127 that we want
; 2506 :       // to encode as 0..255 by adding 128, so we'll add that before the shift
; 2507 :       x0 += 65536 + (128<<17);
; 2508 :       x1 += 65536 + (128<<17);
; 2509 :       x2 += 65536 + (128<<17);
; 2510 :       x3 += 65536 + (128<<17);
; 2511 :       // tried computing the shifts into temps, or'ing the temps to see
; 2512 :       // if any were out of range, but that was slower
; 2513 :       o[0] = stbi__clamp((x0+t3) >> 17);
; 2514 :       o[7] = stbi__clamp((x0-t3) >> 17);
; 2515 :       o[1] = stbi__clamp((x1+t2) >> 17);
; 2516 :       o[6] = stbi__clamp((x1-t2) >> 17);
; 2517 :       o[2] = stbi__clamp((x2+t1) >> 17);
; 2518 :       o[5] = stbi__clamp((x2-t1) >> 17);
; 2519 :       o[3] = stbi__clamp((x3+t0) >> 17);
; 2520 :       o[4] = stbi__clamp((x3-t0) >> 17);
; 2521 :    }
; 2522 : }
; 2523 : 
; 2524 : #ifdef STBI_SSE2
; 2525 : // sse2 integer IDCT. not the fastest possible implementation but it
; 2526 : // produces bit-identical results to the generic C version so it's
; 2527 : // fully "transparent".
; 2528 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2529 : {
; 2530 :    // This is constructed to match our regular (generic) integer IDCT exactly.
; 2531 :    __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2532 :    __m128i tmp;
; 2533 : 
; 2534 :    // dot product constant: even elems=x, odd elems=y
; 2535 :    #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2536 : 
; 2537 :    // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2538 :    // out(1) = c1[even]*x + c1[odd]*y
; 2539 :    #define dct_rot(out0,out1, x,y,c0,c1) \
; 2540 :       __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2541 :       __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2542 :       __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2543 :       __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2544 :       __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2545 :       __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2546 : 
; 2547 :    // out = in << 12  (in 16-bit, out 32-bit)
; 2548 :    #define dct_widen(out, in) \
; 2549 :       __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2550 :       __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2551 : 
; 2552 :    // wide add
; 2553 :    #define dct_wadd(out, a, b) \
; 2554 :       __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2555 :       __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2556 : 
; 2557 :    // wide sub
; 2558 :    #define dct_wsub(out, a, b) \
; 2559 :       __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2560 :       __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2561 : 
; 2562 :    // butterfly a/b, add bias, then shift by "s" and pack
; 2563 :    #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2564 :       { \
; 2565 :          __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2566 :          __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2567 :          dct_wadd(sum, abiased, b); \
; 2568 :          dct_wsub(dif, abiased, b); \
; 2569 :          out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2570 :          out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2571 :       }
; 2572 : 
; 2573 :    // 8-bit interleave step (for transposes)
; 2574 :    #define dct_interleave8(a, b) \
; 2575 :       tmp = a; \
; 2576 :       a = _mm_unpacklo_epi8(a, b); \
; 2577 :       b = _mm_unpackhi_epi8(tmp, b)
; 2578 : 
; 2579 :    // 16-bit interleave step (for transposes)
; 2580 :    #define dct_interleave16(a, b) \
; 2581 :       tmp = a; \
; 2582 :       a = _mm_unpacklo_epi16(a, b); \
; 2583 :       b = _mm_unpackhi_epi16(tmp, b)
; 2584 : 
; 2585 :    #define dct_pass(bias,shift) \
; 2586 :       { \
; 2587 :          /* even part */ \
; 2588 :          dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2589 :          __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2590 :          __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2591 :          dct_widen(t0e, sum04); \
; 2592 :          dct_widen(t1e, dif04); \
; 2593 :          dct_wadd(x0, t0e, t3e); \
; 2594 :          dct_wsub(x3, t0e, t3e); \
; 2595 :          dct_wadd(x1, t1e, t2e); \
; 2596 :          dct_wsub(x2, t1e, t2e); \
; 2597 :          /* odd part */ \
; 2598 :          dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2599 :          dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2600 :          __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2601 :          __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2602 :          dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2603 :          dct_wadd(x4, y0o, y4o); \
; 2604 :          dct_wadd(x5, y1o, y5o); \
; 2605 :          dct_wadd(x6, y2o, y5o); \
; 2606 :          dct_wadd(x7, y3o, y4o); \
; 2607 :          dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2608 :          dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2609 :          dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2610 :          dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2611 :       }
; 2612 : 
; 2613 :    __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
; 2614 :    __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
; 2615 :    __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
; 2616 :    __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
; 2617 :    __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
; 2618 :    __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
; 2619 :    __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
; 2620 :    __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
; 2621 : 
; 2622 :    // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2623 :    __m128i bias_0 = _mm_set1_epi32(512);
; 2624 :    __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
; 2625 : 
; 2626 :    // load
; 2627 :    row0 = _mm_load_si128((const __m128i *) (data + 0*8));
; 2628 :    row1 = _mm_load_si128((const __m128i *) (data + 1*8));
; 2629 :    row2 = _mm_load_si128((const __m128i *) (data + 2*8));
; 2630 :    row3 = _mm_load_si128((const __m128i *) (data + 3*8));
; 2631 :    row4 = _mm_load_si128((const __m128i *) (data + 4*8));
; 2632 :    row5 = _mm_load_si128((const __m128i *) (data + 5*8));
; 2633 :    row6 = _mm_load_si128((const __m128i *) (data + 6*8));
; 2634 :    row7 = _mm_load_si128((const __m128i *) (data + 7*8));
; 2635 : 
; 2636 :    // column pass
; 2637 :    dct_pass(bias_0, 10);
; 2638 : 
; 2639 :    {
; 2640 :       // 16bit 8x8 transpose pass 1
; 2641 :       dct_interleave16(row0, row4);
; 2642 :       dct_interleave16(row1, row5);
; 2643 :       dct_interleave16(row2, row6);
; 2644 :       dct_interleave16(row3, row7);
; 2645 : 
; 2646 :       // transpose pass 2
; 2647 :       dct_interleave16(row0, row2);
; 2648 :       dct_interleave16(row1, row3);
; 2649 :       dct_interleave16(row4, row6);
; 2650 :       dct_interleave16(row5, row7);
; 2651 : 
; 2652 :       // transpose pass 3
; 2653 :       dct_interleave16(row0, row1);
; 2654 :       dct_interleave16(row2, row3);
; 2655 :       dct_interleave16(row4, row5);
; 2656 :       dct_interleave16(row6, row7);
; 2657 :    }
; 2658 : 
; 2659 :    // row pass
; 2660 :    dct_pass(bias_1, 17);
; 2661 : 
; 2662 :    {
; 2663 :       // pack
; 2664 :       __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
; 2665 :       __m128i p1 = _mm_packus_epi16(row2, row3);
; 2666 :       __m128i p2 = _mm_packus_epi16(row4, row5);
; 2667 :       __m128i p3 = _mm_packus_epi16(row6, row7);
; 2668 : 
; 2669 :       // 8bit 8x8 transpose pass 1
; 2670 :       dct_interleave8(p0, p2); // a0e0a1e1...
; 2671 :       dct_interleave8(p1, p3); // c0g0c1g1...
; 2672 : 
; 2673 :       // transpose pass 2
; 2674 :       dct_interleave8(p0, p1); // a0c0e0g0...
; 2675 :       dct_interleave8(p2, p3); // b0d0f0h0...
; 2676 : 
; 2677 :       // transpose pass 3
; 2678 :       dct_interleave8(p0, p2); // a0b0c0d0...
; 2679 :       dct_interleave8(p1, p3); // a4b4c4d4...
; 2680 : 
; 2681 :       // store
; 2682 :       _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
; 2683 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
; 2684 :       _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
; 2685 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
; 2686 :       _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
; 2687 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
; 2688 :       _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
; 2689 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
; 2690 :    }
; 2691 : 
; 2692 : #undef dct_const
; 2693 : #undef dct_rot
; 2694 : #undef dct_widen
; 2695 : #undef dct_wadd
; 2696 : #undef dct_wsub
; 2697 : #undef dct_bfly32o
; 2698 : #undef dct_interleave8
; 2699 : #undef dct_interleave16
; 2700 : #undef dct_pass
; 2701 : }
; 2702 : 
; 2703 : #endif // STBI_SSE2
; 2704 : 
; 2705 : #ifdef STBI_NEON
; 2706 : 
; 2707 : // NEON integer IDCT. should produce bit-identical
; 2708 : // results to the generic C version.
; 2709 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2710 : {
; 2711 :    int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;
; 2712 : 
; 2713 :    int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
; 2714 :    int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
; 2715 :    int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
; 2716 :    int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
; 2717 :    int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
; 2718 :    int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
; 2719 :    int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
; 2720 :    int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
; 2721 :    int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
; 2722 :    int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
; 2723 :    int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
; 2724 :    int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));
; 2725 : 
; 2726 : #define dct_long_mul(out, inq, coeff) \
; 2727 :    int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
; 2728 :    int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)
; 2729 : 
; 2730 : #define dct_long_mac(out, acc, inq, coeff) \
; 2731 :    int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
; 2732 :    int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)
; 2733 : 
; 2734 : #define dct_widen(out, inq) \
; 2735 :    int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
; 2736 :    int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)
; 2737 : 
; 2738 : // wide add
; 2739 : #define dct_wadd(out, a, b) \
; 2740 :    int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
; 2741 :    int32x4_t out##_h = vaddq_s32(a##_h, b##_h)
; 2742 : 
; 2743 : // wide sub
; 2744 : #define dct_wsub(out, a, b) \
; 2745 :    int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
; 2746 :    int32x4_t out##_h = vsubq_s32(a##_h, b##_h)
; 2747 : 
; 2748 : // butterfly a/b, then shift using "shiftop" by "s" and pack
; 2749 : #define dct_bfly32o(out0,out1, a,b,shiftop,s) \
; 2750 :    { \
; 2751 :       dct_wadd(sum, a, b); \
; 2752 :       dct_wsub(dif, a, b); \
; 2753 :       out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
; 2754 :       out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
; 2755 :    }
; 2756 : 
; 2757 : #define dct_pass(shiftop, shift) \
; 2758 :    { \
; 2759 :       /* even part */ \
; 2760 :       int16x8_t sum26 = vaddq_s16(row2, row6); \
; 2761 :       dct_long_mul(p1e, sum26, rot0_0); \
; 2762 :       dct_long_mac(t2e, p1e, row6, rot0_1); \
; 2763 :       dct_long_mac(t3e, p1e, row2, rot0_2); \
; 2764 :       int16x8_t sum04 = vaddq_s16(row0, row4); \
; 2765 :       int16x8_t dif04 = vsubq_s16(row0, row4); \
; 2766 :       dct_widen(t0e, sum04); \
; 2767 :       dct_widen(t1e, dif04); \
; 2768 :       dct_wadd(x0, t0e, t3e); \
; 2769 :       dct_wsub(x3, t0e, t3e); \
; 2770 :       dct_wadd(x1, t1e, t2e); \
; 2771 :       dct_wsub(x2, t1e, t2e); \
; 2772 :       /* odd part */ \
; 2773 :       int16x8_t sum15 = vaddq_s16(row1, row5); \
; 2774 :       int16x8_t sum17 = vaddq_s16(row1, row7); \
; 2775 :       int16x8_t sum35 = vaddq_s16(row3, row5); \
; 2776 :       int16x8_t sum37 = vaddq_s16(row3, row7); \
; 2777 :       int16x8_t sumodd = vaddq_s16(sum17, sum35); \
; 2778 :       dct_long_mul(p5o, sumodd, rot1_0); \
; 2779 :       dct_long_mac(p1o, p5o, sum17, rot1_1); \
; 2780 :       dct_long_mac(p2o, p5o, sum35, rot1_2); \
; 2781 :       dct_long_mul(p3o, sum37, rot2_0); \
; 2782 :       dct_long_mul(p4o, sum15, rot2_1); \
; 2783 :       dct_wadd(sump13o, p1o, p3o); \
; 2784 :       dct_wadd(sump24o, p2o, p4o); \
; 2785 :       dct_wadd(sump23o, p2o, p3o); \
; 2786 :       dct_wadd(sump14o, p1o, p4o); \
; 2787 :       dct_long_mac(x4, sump13o, row7, rot3_0); \
; 2788 :       dct_long_mac(x5, sump24o, row5, rot3_1); \
; 2789 :       dct_long_mac(x6, sump23o, row3, rot3_2); \
; 2790 :       dct_long_mac(x7, sump14o, row1, rot3_3); \
; 2791 :       dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
; 2792 :       dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
; 2793 :       dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
; 2794 :       dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
; 2795 :    }
; 2796 : 
; 2797 :    // load
; 2798 :    row0 = vld1q_s16(data + 0*8);
; 2799 :    row1 = vld1q_s16(data + 1*8);
; 2800 :    row2 = vld1q_s16(data + 2*8);
; 2801 :    row3 = vld1q_s16(data + 3*8);
; 2802 :    row4 = vld1q_s16(data + 4*8);
; 2803 :    row5 = vld1q_s16(data + 5*8);
; 2804 :    row6 = vld1q_s16(data + 6*8);
; 2805 :    row7 = vld1q_s16(data + 7*8);
; 2806 : 
; 2807 :    // add DC bias
; 2808 :    row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));
; 2809 : 
; 2810 :    // column pass
; 2811 :    dct_pass(vrshrn_n_s32, 10);
; 2812 : 
; 2813 :    // 16bit 8x8 transpose
; 2814 :    {
; 2815 : // these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
; 2816 : // whether compilers actually get this is another story, sadly.
; 2817 : #define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
; 2818 : #define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
; 2819 : #define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }
; 2820 : 
; 2821 :       // pass 1
; 2822 :       dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
; 2823 :       dct_trn16(row2, row3);
; 2824 :       dct_trn16(row4, row5);
; 2825 :       dct_trn16(row6, row7);
; 2826 : 
; 2827 :       // pass 2
; 2828 :       dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
; 2829 :       dct_trn32(row1, row3);
; 2830 :       dct_trn32(row4, row6);
; 2831 :       dct_trn32(row5, row7);
; 2832 : 
; 2833 :       // pass 3
; 2834 :       dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
; 2835 :       dct_trn64(row1, row5);
; 2836 :       dct_trn64(row2, row6);
; 2837 :       dct_trn64(row3, row7);
; 2838 : 
; 2839 : #undef dct_trn16
; 2840 : #undef dct_trn32
; 2841 : #undef dct_trn64
; 2842 :    }
; 2843 : 
; 2844 :    // row pass
; 2845 :    // vrshrn_n_s32 only supports shifts up to 16, we need
; 2846 :    // 17. so do a non-rounding shift of 16 first then follow
; 2847 :    // up with a rounding shift by 1.
; 2848 :    dct_pass(vshrn_n_s32, 16);
; 2849 : 
; 2850 :    {
; 2851 :       // pack and round
; 2852 :       uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
; 2853 :       uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
; 2854 :       uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
; 2855 :       uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
; 2856 :       uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
; 2857 :       uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
; 2858 :       uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
; 2859 :       uint8x8_t p7 = vqrshrun_n_s16(row7, 1);
; 2860 : 
; 2861 :       // again, these can translate into one instruction, but often don't.
; 2862 : #define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
; 2863 : #define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
; 2864 : #define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }
; 2865 : 
; 2866 :       // sadly can't use interleaved stores here since we only write
; 2867 :       // 8 bytes to each scan line!
; 2868 : 
; 2869 :       // 8x8 8-bit transpose pass 1
; 2870 :       dct_trn8_8(p0, p1);
; 2871 :       dct_trn8_8(p2, p3);
; 2872 :       dct_trn8_8(p4, p5);
; 2873 :       dct_trn8_8(p6, p7);
; 2874 : 
; 2875 :       // pass 2
; 2876 :       dct_trn8_16(p0, p2);
; 2877 :       dct_trn8_16(p1, p3);
; 2878 :       dct_trn8_16(p4, p6);
; 2879 :       dct_trn8_16(p5, p7);
; 2880 : 
; 2881 :       // pass 3
; 2882 :       dct_trn8_32(p0, p4);
; 2883 :       dct_trn8_32(p1, p5);
; 2884 :       dct_trn8_32(p2, p6);
; 2885 :       dct_trn8_32(p3, p7);
; 2886 : 
; 2887 :       // store
; 2888 :       vst1_u8(out, p0); out += out_stride;
; 2889 :       vst1_u8(out, p1); out += out_stride;
; 2890 :       vst1_u8(out, p2); out += out_stride;
; 2891 :       vst1_u8(out, p3); out += out_stride;
; 2892 :       vst1_u8(out, p4); out += out_stride;
; 2893 :       vst1_u8(out, p5); out += out_stride;
; 2894 :       vst1_u8(out, p6); out += out_stride;
; 2895 :       vst1_u8(out, p7);
; 2896 : 
; 2897 : #undef dct_trn8_8
; 2898 : #undef dct_trn8_16
; 2899 : #undef dct_trn8_32
; 2900 :    }
; 2901 : 
; 2902 : #undef dct_long_mul
; 2903 : #undef dct_long_mac
; 2904 : #undef dct_widen
; 2905 : #undef dct_wadd
; 2906 : #undef dct_wsub
; 2907 : #undef dct_bfly32o
; 2908 : #undef dct_pass
; 2909 : }
; 2910 : 
; 2911 : #endif // STBI_NEON
; 2912 : 
; 2913 : #define STBI__MARKER_none  0xff
; 2914 : // if there's a pending marker from the entropy stream, return that
; 2915 : // otherwise, fetch from the stream and get a marker. if there's no
; 2916 : // marker, return 0xff, which is never a valid marker value
; 2917 : static stbi_uc stbi__get_marker(stbi__jpeg *j)
; 2918 : {
; 2919 :    stbi_uc x;
; 2920 :    if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
; 2921 :    x = stbi__get8(j->s);
; 2922 :    if (x != 0xff) return STBI__MARKER_none;
; 2923 :    while (x == 0xff)
; 2924 :       x = stbi__get8(j->s); // consume repeated 0xff fill bytes
; 2925 :    return x;
; 2926 : }
; 2927 : 
; 2928 : // in each scan, we'll have scan_n components, and the order
; 2929 : // of the components is specified by order[]
; 2930 : #define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
; 2931 : 
; 2932 : // after a restart interval, stbi__jpeg_reset the entropy decoder and
; 2933 : // the dc prediction
; 2934 : static void stbi__jpeg_reset(stbi__jpeg *j)
; 2935 : {
; 2936 :    j->code_bits = 0;
; 2937 :    j->code_buffer = 0;
; 2938 :    j->nomore = 0;
; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
; 2940 :    j->marker = STBI__MARKER_none;
; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
; 2942 :    j->eob_run = 0;
; 2943 :    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2944 :    // since we don't even allow 1<<30 pixels
; 2945 : }
; 2946 : 
; 2947 : static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
; 2948 : {
; 2949 :    stbi__jpeg_reset(z);
; 2950 :    if (!z->progressive) {
; 2951 :       if (z->scan_n == 1) {
; 2952 :          int i,j;
; 2953 :          STBI_SIMD_ALIGN(short, data[64]);
; 2954 :          int n = z->order[0];
; 2955 :          // non-interleaved data, we just need to process one block at a time,
; 2956 :          // in trivial scanline order
; 2957 :          // number of blocks to do just depends on how many actual "pixels" this
; 2958 :          // component has, independent of interleaved MCU blocking and such
; 2959 :          int w = (z->img_comp[n].x+7) >> 3;
; 2960 :          int h = (z->img_comp[n].y+7) >> 3;
; 2961 :          for (j=0; j < h; ++j) {
; 2962 :             for (i=0; i < w; ++i) {
; 2963 :                int ha = z->img_comp[n].ha;
; 2964 :                if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2965 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 2966 :                // every data block is an MCU, so countdown the restart interval
; 2967 :                if (--z->todo <= 0) {
; 2968 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 2969 :                   // if it's NOT a restart, then just bail, so we get corrupt data
; 2970 :                   // rather than no data
; 2971 :                   if (!STBI__RESTART(z->marker)) return 1;
; 2972 :                   stbi__jpeg_reset(z);
; 2973 :                }
; 2974 :             }
; 2975 :          }
; 2976 :          return 1;
; 2977 :       } else { // interleaved
; 2978 :          int i,j,k,x,y;
; 2979 :          STBI_SIMD_ALIGN(short, data[64]);
; 2980 :          for (j=0; j < z->img_mcu_y; ++j) {
; 2981 :             for (i=0; i < z->img_mcu_x; ++i) {
; 2982 :                // scan an interleaved mcu... process scan_n components in order
; 2983 :                for (k=0; k < z->scan_n; ++k) {
; 2984 :                   int n = z->order[k];
; 2985 :                   // scan out an mcu's worth of this component; that's just determined
; 2986 :                   // by the basic H and V specified for the component
; 2987 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 2988 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 2989 :                         int x2 = (i*z->img_comp[n].h + x)*8;
; 2990 :                         int y2 = (j*z->img_comp[n].v + y)*8;
; 2991 :                         int ha = z->img_comp[n].ha;
; 2992 :                         if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2993 :                         z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
; 2994 :                      }
; 2995 :                   }
; 2996 :                }
; 2997 :                // after all interleaved components, that's an interleaved MCU,
; 2998 :                // so now count down the restart interval
; 2999 :                if (--z->todo <= 0) {
; 3000 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3001 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3002 :                   stbi__jpeg_reset(z);
; 3003 :                }
; 3004 :             }
; 3005 :          }
; 3006 :          return 1;
; 3007 :       }
; 3008 :    } else {
; 3009 :       if (z->scan_n == 1) {
; 3010 :          int i,j;
; 3011 :          int n = z->order[0];
; 3012 :          // non-interleaved data, we just need to process one block at a time,
; 3013 :          // in trivial scanline order
; 3014 :          // number of blocks to do just depends on how many actual "pixels" this
; 3015 :          // component has, independent of interleaved MCU blocking and such
; 3016 :          int w = (z->img_comp[n].x+7) >> 3;
; 3017 :          int h = (z->img_comp[n].y+7) >> 3;
; 3018 :          for (j=0; j < h; ++j) {
; 3019 :             for (i=0; i < w; ++i) {
; 3020 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3021 :                if (z->spec_start == 0) {
; 3022 :                   if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3023 :                      return 0;
; 3024 :                } else {
; 3025 :                   int ha = z->img_comp[n].ha;
; 3026 :                   if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
; 3027 :                      return 0;
; 3028 :                }
; 3029 :                // every data block is an MCU, so countdown the restart interval
; 3030 :                if (--z->todo <= 0) {
; 3031 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3032 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3033 :                   stbi__jpeg_reset(z);
; 3034 :                }
; 3035 :             }
; 3036 :          }
; 3037 :          return 1;
; 3038 :       } else { // interleaved
; 3039 :          int i,j,k,x,y;
; 3040 :          for (j=0; j < z->img_mcu_y; ++j) {
; 3041 :             for (i=0; i < z->img_mcu_x; ++i) {
; 3042 :                // scan an interleaved mcu... process scan_n components in order
; 3043 :                for (k=0; k < z->scan_n; ++k) {
; 3044 :                   int n = z->order[k];
; 3045 :                   // scan out an mcu's worth of this component; that's just determined
; 3046 :                   // by the basic H and V specified for the component
; 3047 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 3048 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 3049 :                         int x2 = (i*z->img_comp[n].h + x);
; 3050 :                         int y2 = (j*z->img_comp[n].v + y);
; 3051 :                         short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
; 3052 :                         if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3053 :                            return 0;
; 3054 :                      }
; 3055 :                   }
; 3056 :                }
; 3057 :                // after all interleaved components, that's an interleaved MCU,
; 3058 :                // so now count down the restart interval
; 3059 :                if (--z->todo <= 0) {
; 3060 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3061 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3062 :                   stbi__jpeg_reset(z);
; 3063 :                }
; 3064 :             }
; 3065 :          }
; 3066 :          return 1;
; 3067 :       }
; 3068 :    }
; 3069 : }
; 3070 : 
; 3071 : static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
; 3072 : {
; 3073 :    int i;
; 3074 :    for (i=0; i < 64; ++i)
; 3075 :       data[i] *= dequant[i];
; 3076 : }
; 3077 : 
; 3078 : static void stbi__jpeg_finish(stbi__jpeg *z)
; 3079 : {
; 3080 :    if (z->progressive) {
; 3081 :       // dequantize and idct the data
; 3082 :       int i,j,n;
; 3083 :       for (n=0; n < z->s->img_n; ++n) {
; 3084 :          int w = (z->img_comp[n].x+7) >> 3;
; 3085 :          int h = (z->img_comp[n].y+7) >> 3;
; 3086 :          for (j=0; j < h; ++j) {
; 3087 :             for (i=0; i < w; ++i) {
; 3088 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3089 :                stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
; 3090 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 3091 :             }
; 3092 :          }
; 3093 :       }
; 3094 :    }
; 3095 : }
; 3096 : 
; 3097 : static int stbi__process_marker(stbi__jpeg *z, int m)
; 3098 : {
; 3099 :    int L;
; 3100 :    switch (m) {
; 3101 :       case STBI__MARKER_none: // no marker found
; 3102 :          return stbi__err("expected marker","Corrupt JPEG");
; 3103 : 
; 3104 :       case 0xDD: // DRI - specify restart interval
; 3105 :          if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
; 3106 :          z->restart_interval = stbi__get16be(z->s);
; 3107 :          return 1;
; 3108 : 
; 3109 :       case 0xDB: // DQT - define quantization table
; 3110 :          L = stbi__get16be(z->s)-2;
; 3111 :          while (L > 0) {
; 3112 :             int q = stbi__get8(z->s);
; 3113 :             int p = q >> 4, sixteen = (p != 0);
; 3114 :             int t = q & 15,i;
; 3115 :             if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
; 3116 :             if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");
; 3117 : 
; 3118 :             for (i=0; i < 64; ++i)
; 3119 :                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
; 3120 :             L -= (sixteen ? 129 : 65);
; 3121 :          }
; 3122 :          return L==0;
; 3123 : 
; 3124 :       case 0xC4: // DHT - define huffman table
; 3125 :          L = stbi__get16be(z->s)-2;
; 3126 :          while (L > 0) {
; 3127 :             stbi_uc *v;
; 3128 :             int sizes[16],i,n=0;
; 3129 :             int q = stbi__get8(z->s);
; 3130 :             int tc = q >> 4;
; 3131 :             int th = q & 15;
; 3132 :             if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
; 3133 :             for (i=0; i < 16; ++i) {
; 3134 :                sizes[i] = stbi__get8(z->s);
; 3135 :                n += sizes[i];
; 3136 :             }
; 3137 :             if(n > 256) return stbi__err("bad DHT header","Corrupt JPEG"); // Loop over i < n would write past end of values!
; 3138 :             L -= 17;
; 3139 :             if (tc == 0) {
; 3140 :                if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
; 3141 :                v = z->huff_dc[th].values;
; 3142 :             } else {
; 3143 :                if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
; 3144 :                v = z->huff_ac[th].values;
; 3145 :             }
; 3146 :             for (i=0; i < n; ++i)
; 3147 :                v[i] = stbi__get8(z->s);
; 3148 :             if (tc != 0)
; 3149 :                stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
; 3150 :             L -= n;
; 3151 :          }
; 3152 :          return L==0;
; 3153 :    }
; 3154 : 
; 3155 :    // check for comment block or APP blocks
; 3156 :    if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
; 3157 :       L = stbi__get16be(z->s);
; 3158 :       if (L < 2) {
; 3159 :          if (m == 0xFE)
; 3160 :             return stbi__err("bad COM len","Corrupt JPEG");
; 3161 :          else
; 3162 :             return stbi__err("bad APP len","Corrupt JPEG");
; 3163 :       }
; 3164 :       L -= 2;
; 3165 : 
; 3166 :       if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
; 3167 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3168 :          int ok = 1;
; 3169 :          int i;
; 3170 :          for (i=0; i < 5; ++i)
; 3171 :             if (stbi__get8(z->s) != tag[i])
; 3172 :                ok = 0;
; 3173 :          L -= 5;
; 3174 :          if (ok)
; 3175 :             z->jfif = 1;
; 3176 :       } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;
; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)
; 3181 :             if (stbi__get8(z->s) != tag[i])
; 3182 :                ok = 0;
; 3183 :          L -= 6;
; 3184 :          if (ok) {
; 3185 :             stbi__get8(z->s); // version
; 3186 :             stbi__get16be(z->s); // flags0
; 3187 :             stbi__get16be(z->s); // flags1
; 3188 :             z->app14_color_transform = stbi__get8(z->s); // color transform
; 3189 :             L -= 6;
; 3190 :          }
; 3191 :       }
; 3192 : 
; 3193 :       stbi__skip(z->s, L);
; 3194 :       return 1;
; 3195 :    }
; 3196 : 
; 3197 :    return stbi__err("unknown marker","Corrupt JPEG");
; 3198 : }
; 3199 : 
; 3200 : // after we see SOS
; 3201 : static int stbi__process_scan_header(stbi__jpeg *z)
; 3202 : {
; 3203 :    int i;
; 3204 :    int Ls = stbi__get16be(z->s);
; 3205 :    z->scan_n = stbi__get8(z->s);
; 3206 :    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
; 3207 :    if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
; 3208 :    for (i=0; i < z->scan_n; ++i) {
; 3209 :       int id = stbi__get8(z->s), which;
; 3210 :       int q = stbi__get8(z->s);
; 3211 :       for (which = 0; which < z->s->img_n; ++which)
; 3212 :          if (z->img_comp[which].id == id)
; 3213 :             break;
; 3214 :       if (which == z->s->img_n) return 0; // no match
; 3215 :       z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
; 3216 :       z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
; 3217 :       z->order[i] = which;
; 3218 :    }
; 3219 : 
; 3220 :    {
; 3221 :       int aa;
; 3222 :       z->spec_start = stbi__get8(z->s);
; 3223 :       z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
; 3224 :       aa = stbi__get8(z->s);
; 3225 :       z->succ_high = (aa >> 4);
; 3226 :       z->succ_low  = (aa & 15);
; 3227 :       if (z->progressive) {
; 3228 :          if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
; 3229 :             return stbi__err("bad SOS", "Corrupt JPEG");
; 3230 :       } else {
; 3231 :          if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3232 :          if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3233 :          z->spec_end = 63;
; 3234 :       }
; 3235 :    }
; 3236 : 
; 3237 :    return 1;
; 3238 : }
; 3239 : 
; 3240 : static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
; 3241 : {
; 3242 :    int i;
; 3243 :    for (i=0; i < ncomp; ++i) {

	add	rdi, 96					; 00000060H
	sub	rbx, r14
	jne	SHORT $LL160@load_jpeg_

; 3903 :          if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

	jmp	$LN171@load_jpeg_
$LN143@load_jpeg_:

; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	ecx

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	eax, 4
	jl	$LN306@load_jpeg_
	lea	r9d, DWORD PTR [rcx*4]

; 1014 :    if (a < 0 || b < 0) return 0;

	test	r9d, r9d
	js	$LN306@load_jpeg_
$LN309@load_jpeg_:
	test	r8d, r8d
	js	$LN306@load_jpeg_

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN373@load_jpeg_

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	r8d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	r9d, eax
	jg	$LN306@load_jpeg_
$LN373@load_jpeg_:

; 1056 :    return stbi__malloc(a*b*c + add);

	imul	r8d, ecx
	lea	eax, DWORD PTR [r8*4+1]
	movsxd	rcx, eax

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc

; 3921 :       if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

	mov	rcx, QWORD PTR [rdi]

; 985  :     return STBI_MALLOC(size);

	mov	r13, rax

; 3921 :       if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

	test	rax, rax
	je	$LN305@load_jpeg_

; 3922 : 
; 3923 :       // now go ahead and resample
; 3924 :       for (j=0; j < z->s->img_y; ++j) {

	cmp	DWORD PTR [rcx+4], 0
	mov	eax, ebp
	mov	DWORD PTR j$1$[rsp], eax
	jbe	$LN6@load_jpeg_

; 3943 :                if (is_rgb) {

	mov	r14, QWORD PTR coutput$1[rsp+16]
	mov	rdx, rcx
	mov	r15, QWORD PTR coutput$1[rsp+8]
	mov	rbx, QWORD PTR coutput$1[rsp]
	mov	QWORD PTR output$2$[rsp], r13
	npad	9
$LL7@load_jpeg_:

; 3925 :          stbi_uc *out = output + n * z->s->img_x * j;

	imul	eax, DWORD PTR [rdx]
	shl	eax, 2
	mov	esi, eax
	add	rsi, r13
	mov	QWORD PTR out$1$[rsp], rsi

; 3926 :          for (k=0; k < decode_n; ++k) {

	test	r12, r12
	jle	$LN303@load_jpeg_

; 3925 :          stbi_uc *out = output + n * z->s->img_x * j;

	lea	rsi, QWORD PTR [rdi+18112]
	mov	rdi, QWORD PTR output$2$[rsp]
	lea	rbx, QWORD PTR res_comp$2[rsp+36]
	npad	3
$LL10@load_jpeg_:

; 3927 :             stbi__resample *r = &res_comp[k];
; 3928 :             int y_bot = r->ystep >= (r->vs >> 1);

	mov	rax, QWORD PTR tv5439[rsp]

; 3929 :             coutput[k] = r->resample(z->img_comp[k].linebuf,

	lea	r14, QWORD PTR [rbx-20]
	mov	r11d, DWORD PTR [rbx-12]
	lea	r15, QWORD PTR [rbx-28]
	mov	r9, rax
	mov	QWORD PTR tv5439[rsp], rax
	mov	eax, DWORD PTR [rbx-8]
	mov	r13, r14
	sar	eax, 1
	cmp	DWORD PTR [rbx], eax
	jl	SHORT $LN89@load_jpeg_
	mov	r8, QWORD PTR [r15]
	mov	rdx, r14
	mov	QWORD PTR tv5439[rsp], r9
	jmp	SHORT $LN92@load_jpeg_
$LN89@load_jpeg_:
	mov	r8, QWORD PTR [r14]
	mov	rdx, r15
$LN92@load_jpeg_:
	mov	r9d, DWORD PTR [rbx-4]
	mov	rdx, QWORD PTR [rdx]
	mov	rcx, QWORD PTR [rsi+40]
	mov	DWORD PTR [rsp+32], r11d
	call	QWORD PTR [rbx-36]
	mov	QWORD PTR coutput$1[rsp+rbp*8], rax

; 3930 :                                      y_bot ? r->line1 : r->line0,
; 3931 :                                      y_bot ? r->line0 : r->line1,
; 3932 :                                      r->w_lores, r->hs);
; 3933 :             if (++r->ystep >= r->vs) {

	mov	eax, DWORD PTR [rbx]
	inc	eax
	mov	DWORD PTR [rbx], eax
	cmp	eax, DWORD PTR [rbx-8]
	jl	SHORT $LN8@load_jpeg_

; 3934 :                r->ystep = 0;
; 3935 :                r->line0 = r->line1;
; 3936 :                if (++r->ypos < z->img_comp[k].y)

	inc	DWORD PTR [rbx+4]
	mov	eax, DWORD PTR [rbx+4]
	mov	rcx, QWORD PTR [r13]
	mov	DWORD PTR [rbx], 0
	mov	QWORD PTR [r15], rcx
	cmp	eax, DWORD PTR [rsi]
	jge	SHORT $LN8@load_jpeg_

; 3937 :                   r->line1 += z->img_comp[k].w2;

	movsxd	rax, DWORD PTR [rsi+4]
	add	rax, rcx
	mov	QWORD PTR [r14], rax
$LN8@load_jpeg_:

; 3926 :          for (k=0; k < decode_n; ++k) {

	inc	rbp
	add	rbx, 48					; 00000030H
	add	rsi, 96					; 00000060H
	cmp	rbp, r12
	jl	$LL10@load_jpeg_
	mov	r14, QWORD PTR coutput$1[rsp+16]
	mov	r15, QWORD PTR coutput$1[rsp+8]
	mov	rbx, QWORD PTR coutput$1[rsp]
	mov	rsi, QWORD PTR out$1$[rsp]
	mov	QWORD PTR output$2$[rsp], rdi
	mov	rdi, QWORD PTR z$GSCopy$1$[rsp]
	mov	r13, QWORD PTR output$2$[rsp]
	mov	rcx, QWORD PTR [rdi]
	mov	rdx, rcx
$LN303@load_jpeg_:

; 3938 :             }
; 3939 :          }
; 3940 :          if (n >= 3) {
; 3941 :             stbi_uc *y = coutput[0];
; 3942 :             if (z->s->img_n == 3) {

	mov	eax, DWORD PTR [rdx+8]
	cmp	eax, 3
	jne	SHORT $LN61@load_jpeg_

; 3943 :                if (is_rgb) {

	cmp	QWORD PTR tv5439[rsp], 0
	je	SHORT $LN63@load_jpeg_

; 3944 :                   for (i=0; i < z->s->img_x; ++i) {

	xor	ebp, ebp
	mov	r8d, ebp
	cmp	DWORD PTR [rdx], ebp
	jbe	$LN21@load_jpeg_
	lea	rdx, QWORD PTR [rsi+2]
	npad	6
$LL13@load_jpeg_:

; 3945 :                      out[0] = y[i];

	mov	ecx, r8d

; 3946 :                      out[1] = coutput[1][i];
; 3947 :                      out[2] = coutput[2][i];
; 3948 :                      out[3] = 255;
; 3949 :                      out += n;

	lea	rdx, QWORD PTR [rdx+4]
	inc	r8d
	movzx	eax, BYTE PTR [rcx+rbx]
	mov	BYTE PTR [rdx-6], al
	movzx	eax, BYTE PTR [rcx+r15]
	mov	BYTE PTR [rdx-5], al
	movzx	eax, BYTE PTR [rcx+r14]
	mov	BYTE PTR [rdx-4], al
	mov	BYTE PTR [rdx-3], 255			; 000000ffH
	mov	rcx, QWORD PTR [rdi]
	cmp	r8d, DWORD PTR [rcx]
	jb	SHORT $LL13@load_jpeg_

; 3950 :                   }
; 3951 :                } else {

	jmp	$LN21@load_jpeg_
$LN63@load_jpeg_:

; 3952 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

	mov	eax, DWORD PTR [rdx]
	mov	r9, r14
	mov	rdx, rbx
	mov	DWORD PTR [rsp+40], 4
	mov	r8, r15
	mov	DWORD PTR [rsp+32], eax
	mov	rcx, rsi
	call	QWORD PTR [rdi+18552]
	mov	rcx, QWORD PTR [rdi]
	xor	ebp, ebp

; 3953 :                }

	jmp	$LN21@load_jpeg_
$LN61@load_jpeg_:

; 3954 :             } else if (z->s->img_n == 4) {

	cmp	eax, 4
	jne	$LN65@load_jpeg_

; 3955 :                if (z->app14_color_transform == 0) { // CMYK

	mov	eax, DWORD PTR [rdi+18508]
	test	eax, eax
	jne	$LN67@load_jpeg_

; 3956 :                   for (i=0; i < z->s->img_x; ++i) {

	xor	ebp, ebp
	mov	r10d, ebp
	cmp	DWORD PTR [rdx], ebp
	jbe	$LN21@load_jpeg_
	mov	r13, QWORD PTR coutput$1[rsp+24]
	lea	r9, QWORD PTR [rsi+2]
	npad	7
$LL16@load_jpeg_:

; 3957 :                      stbi_uc m = coutput[3][i];

	mov	edx, r10d

; 3962 :                      out += n;

	lea	r9, QWORD PTR [r9+4]
	inc	r10d

; 3859 :    unsigned int t = x*y + 128;

	movzx	r8d, BYTE PTR [rdx+r13]
	movzx	ecx, BYTE PTR [rdx+rbx]
	imul	ecx, r8d
	sub	ecx, -128				; ffffffffffffff80H

; 3860 :    return (stbi_uc) ((t + (t >>8)) >> 8);

	mov	eax, ecx
	shr	eax, 8
	add	eax, ecx
	shr	eax, 8

; 3958 :                      out[0] = stbi__blinn_8x8(coutput[0][i], m);

	mov	BYTE PTR [r9-6], al

; 3859 :    unsigned int t = x*y + 128;

	movzx	ecx, BYTE PTR [rdx+r15]
	imul	ecx, r8d
	sub	ecx, -128				; ffffffffffffff80H

; 3860 :    return (stbi_uc) ((t + (t >>8)) >> 8);

	mov	eax, ecx
	shr	eax, 8
	add	eax, ecx
	shr	eax, 8

; 3959 :                      out[1] = stbi__blinn_8x8(coutput[1][i], m);

	mov	BYTE PTR [r9-5], al

; 3859 :    unsigned int t = x*y + 128;

	movzx	ecx, BYTE PTR [rdx+r14]
	imul	ecx, r8d

; 3961 :                      out[3] = 255;

	mov	BYTE PTR [r9-3], 255			; 000000ffH

; 3859 :    unsigned int t = x*y + 128;

	sub	ecx, -128				; ffffffffffffff80H

; 3860 :    return (stbi_uc) ((t + (t >>8)) >> 8);

	mov	eax, ecx
	shr	eax, 8
	add	eax, ecx
	shr	eax, 8

; 3960 :                      out[2] = stbi__blinn_8x8(coutput[2][i], m);

	mov	BYTE PTR [r9-4], al
	mov	rcx, QWORD PTR [rdi]
	cmp	r10d, DWORD PTR [rcx]
	jb	SHORT $LL16@load_jpeg_

; 3963 :                   }
; 3964 :                } else if (z->app14_color_transform == 2) { // YCCK

	mov	r13, QWORD PTR output$2$[rsp]
	jmp	$LN21@load_jpeg_
$LN67@load_jpeg_:
	mov	ecx, DWORD PTR [rdx]
	mov	r9, r14
	mov	r10, QWORD PTR [rdi+18552]
	mov	r8, r15
	mov	DWORD PTR [rsp+40], 4
	mov	rdx, rbx
	mov	DWORD PTR [rsp+32], ecx
	mov	rcx, rsi
	cmp	eax, 2
	jne	$LN69@load_jpeg_

; 3965 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

	call	r10

; 3966 :                   for (i=0; i < z->s->img_x; ++i) {

	mov	rcx, QWORD PTR [rdi]
	xor	ebp, ebp
	mov	r9d, ebp
	cmp	DWORD PTR [rcx], ebp
	jbe	$LN21@load_jpeg_
	mov	r14, QWORD PTR coutput$1[rsp+24]
	lea	r8, QWORD PTR [rsi+2]
	npad	7
$LL19@load_jpeg_:

; 3967 :                      stbi_uc m = coutput[3][i];

	mov	eax, r9d

; 3971 :                      out += n;

	lea	r8, QWORD PTR [r8+4]
	inc	r9d

; 3859 :    unsigned int t = x*y + 128;

	movzx	edx, BYTE PTR [rax+r14]

; 3968 :                      out[0] = stbi__blinn_8x8(255 - out[0], m);

	movzx	eax, BYTE PTR [r8-6]
	not	al

; 3859 :    unsigned int t = x*y + 128;

	movzx	ecx, al
	imul	ecx, edx
	sub	ecx, -128				; ffffffffffffff80H

; 3860 :    return (stbi_uc) ((t + (t >>8)) >> 8);

	mov	eax, ecx
	shr	eax, 8
	add	eax, ecx
	shr	eax, 8

; 3968 :                      out[0] = stbi__blinn_8x8(255 - out[0], m);

	mov	BYTE PTR [r8-6], al

; 3969 :                      out[1] = stbi__blinn_8x8(255 - out[1], m);

	movzx	eax, BYTE PTR [r8-5]
	not	al

; 3859 :    unsigned int t = x*y + 128;

	movzx	ecx, al
	imul	ecx, edx
	sub	ecx, -128				; ffffffffffffff80H

; 3860 :    return (stbi_uc) ((t + (t >>8)) >> 8);

	mov	eax, ecx
	shr	eax, 8
	add	eax, ecx
	shr	eax, 8

; 3969 :                      out[1] = stbi__blinn_8x8(255 - out[1], m);

	mov	BYTE PTR [r8-5], al

; 3970 :                      out[2] = stbi__blinn_8x8(255 - out[2], m);

	movzx	eax, BYTE PTR [r8-4]
	not	al

; 3859 :    unsigned int t = x*y + 128;

	movzx	ecx, al
	imul	ecx, edx
	sub	ecx, -128				; ffffffffffffff80H

; 3860 :    return (stbi_uc) ((t + (t >>8)) >> 8);

	mov	eax, ecx
	shr	eax, 8
	add	eax, ecx
	shr	eax, 8

; 3970 :                      out[2] = stbi__blinn_8x8(255 - out[2], m);

	mov	BYTE PTR [r8-4], al
	mov	rcx, QWORD PTR [rdi]
	cmp	r9d, DWORD PTR [rcx]
	jb	SHORT $LL19@load_jpeg_

; 3972 :                   }
; 3973 :                } else { // YCbCr + alpha?  Ignore the fourth channel for now

	mov	r14, QWORD PTR coutput$1[rsp+16]
	jmp	SHORT $LN21@load_jpeg_
$LN69@load_jpeg_:

; 3974 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

	call	r10
	mov	rcx, QWORD PTR [rdi]
	xor	ebp, ebp

; 3975 :                }
; 3976 :             } else

	jmp	SHORT $LN21@load_jpeg_
$LN65@load_jpeg_:

; 3977 :                for (i=0; i < z->s->img_x; ++i) {

	xor	ebp, ebp
	mov	r8d, ebp
	cmp	DWORD PTR [rdx], ebp
	jbe	SHORT $LN21@load_jpeg_
	lea	rdx, QWORD PTR [rsi+1]
	npad	1
$LL22@load_jpeg_:

; 3978 :                   out[0] = out[1] = out[2] = y[i];

	mov	eax, r8d

; 3979 :                   out[3] = 255; // not used if n==3
; 3980 :                   out += n;

	lea	rdx, QWORD PTR [rdx+4]
	inc	r8d
	movzx	ecx, BYTE PTR [rax+rbx]
	mov	BYTE PTR [rdx-3], cl
	mov	BYTE PTR [rdx-4], cl
	mov	BYTE PTR [rdx-5], cl
	mov	BYTE PTR [rdx-2], 255			; 000000ffH
	mov	rcx, QWORD PTR [rdi]
	cmp	r8d, DWORD PTR [rcx]
	jb	SHORT $LL22@load_jpeg_
$LN21@load_jpeg_:

; 3922 : 
; 3923 :       // now go ahead and resample
; 3924 :       for (j=0; j < z->s->img_y; ++j) {

	mov	eax, DWORD PTR j$1$[rsp]
	mov	rdx, rcx
	inc	eax
	mov	DWORD PTR j$1$[rsp], eax
	cmp	eax, DWORD PTR [rcx+4]
	jb	$LL7@load_jpeg_
	mov	r15, QWORD PTR comp$GSCopy$1$[rsp]
	mov	r14d, 1
$LN6@load_jpeg_:

; 3243 :    for (i=0; i < ncomp; ++i) {

	movsxd	rsi, DWORD PTR [rcx+8]
	test	rsi, rsi
	jle	SHORT $LN117@load_jpeg_
	lea	rbx, QWORD PTR [rdi+18136]
$LL118@load_jpeg_:

; 3244 :       if (z->img_comp[i].raw_data) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN119@load_jpeg_

; 3245 :          STBI_FREE(z->img_comp[i].raw_data);

	call	QWORD PTR __imp_free

; 3246 :          z->img_comp[i].raw_data = NULL;

	mov	QWORD PTR [rbx], rbp

; 3247 :          z->img_comp[i].data = NULL;

	mov	QWORD PTR [rbx-8], rbp
$LN119@load_jpeg_:

; 3248 :       }
; 3249 :       if (z->img_comp[i].raw_coeff) {

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN120@load_jpeg_

; 3250 :          STBI_FREE(z->img_comp[i].raw_coeff);

	call	QWORD PTR __imp_free

; 3251 :          z->img_comp[i].raw_coeff = 0;

	mov	QWORD PTR [rbx+8], rbp

; 3252 :          z->img_comp[i].coeff = 0;

	mov	QWORD PTR [rbx+24], rbp
$LN120@load_jpeg_:

; 3253 :       }
; 3254 :       if (z->img_comp[i].linebuf) {

	mov	rcx, QWORD PTR [rbx+16]
	test	rcx, rcx
	je	SHORT $LN116@load_jpeg_

; 3255 :          STBI_FREE(z->img_comp[i].linebuf);

	call	QWORD PTR __imp_free

; 3256 :          z->img_comp[i].linebuf = NULL;

	mov	QWORD PTR [rbx+16], rbp
$LN116@load_jpeg_:

; 1057 : }
; 1058 : 
; 1059 : #if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
; 1060 : static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
; 1061 : {
; 1062 :    if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
; 1063 :    return stbi__malloc(a*b*c*d + add);
; 1064 : }
; 1065 : #endif
; 1066 : 
; 1067 : // returns 1 if the sum of two signed ints is valid (between -2^31 and 2^31-1 inclusive), 0 on overflow.
; 1068 : static int stbi__addints_valid(int a, int b)
; 1069 : {
; 1070 :    if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow
; 1071 :    if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.
; 1072 :    return a <= INT_MAX - b;
; 1073 : }
; 1074 : 
; 1075 : // returns 1 if the product of two signed shorts is valid, 0 on overflow.
; 1076 : static int stbi__mul2shorts_valid(short a, short b)
; 1077 : {
; 1078 :    if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow
; 1079 :    if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX/b; // product is positive, so similar to mul2sizes_valid
; 1080 :    if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN
; 1081 :    return a >= SHRT_MIN / b;
; 1082 : }
; 1083 : 
; 1084 : // stbi__err - error
; 1085 : // stbi__errpf - error returning pointer to float
; 1086 : // stbi__errpuc - error returning pointer to unsigned char
; 1087 : 
; 1088 : #ifdef STBI_NO_FAILURE_STRINGS
; 1089 :    #define stbi__err(x,y)  0
; 1090 : #elif defined(STBI_FAILURE_USERMSG)
; 1091 :    #define stbi__err(x,y)  stbi__err(y)
; 1092 : #else
; 1093 :    #define stbi__err(x,y)  stbi__err(x)
; 1094 : #endif
; 1095 : 
; 1096 : #define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
; 1097 : #define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))
; 1098 : 
; 1099 : STBIDEF void stbi_image_free(void *retval_from_stbi_load)
; 1100 : {
; 1101 :    STBI_FREE(retval_from_stbi_load);
; 1102 : }
; 1103 : 
; 1104 : #ifndef STBI_NO_LINEAR
; 1105 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
; 1106 : #endif
; 1107 : 
; 1108 : #ifndef STBI_NO_HDR
; 1109 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
; 1110 : #endif
; 1111 : 
; 1112 : static int stbi__vertically_flip_on_load_global = 0;
; 1113 : 
; 1114 : STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
; 1115 : {
; 1116 :    stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
; 1117 : }
; 1118 : 
; 1119 : #ifndef STBI_THREAD_LOCAL
; 1120 : #define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global
; 1121 : #else
; 1122 : static STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;
; 1123 : 
; 1124 : STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
; 1125 : {
; 1126 :    stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
; 1127 :    stbi__vertically_flip_on_load_set = 1;
; 1128 : }
; 1129 : 
; 1130 : #define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \
; 1131 :                                          ? stbi__vertically_flip_on_load_local  \
; 1132 :                                          : stbi__vertically_flip_on_load_global)
; 1133 : #endif // STBI_THREAD_LOCAL
; 1134 : 
; 1135 : static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
; 1136 : {
; 1137 :    memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
; 1138 :    ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
; 1139 :    ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
; 1140 :    ri->num_channels = 0;
; 1141 : 
; 1142 :    // test the formats with a very explicit header first (at least a FOURCC
; 1143 :    // or distinctive magic number first)
; 1144 :    #ifndef STBI_NO_PNG
; 1145 :    if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
; 1146 :    #endif
; 1147 :    #ifndef STBI_NO_BMP
; 1148 :    if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
; 1149 :    #endif
; 1150 :    #ifndef STBI_NO_GIF
; 1151 :    if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
; 1152 :    #endif
; 1153 :    #ifndef STBI_NO_PSD
; 1154 :    if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
; 1155 :    #else
; 1156 :    STBI_NOTUSED(bpc);
; 1157 :    #endif
; 1158 :    #ifndef STBI_NO_PIC
; 1159 :    if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
; 1160 :    #endif
; 1161 : 
; 1162 :    // then the formats that can end up attempting to load with just 1 or 2
; 1163 :    // bytes matching expectations; these are prone to false positives, so
; 1164 :    // try them later
; 1165 :    #ifndef STBI_NO_JPEG
; 1166 :    if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
; 1167 :    #endif
; 1168 :    #ifndef STBI_NO_PNM
; 1169 :    if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
; 1170 :    #endif
; 1171 : 
; 1172 :    #ifndef STBI_NO_HDR
; 1173 :    if (stbi__hdr_test(s)) {
; 1174 :       float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
; 1175 :       return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
; 1176 :    }
; 1177 :    #endif
; 1178 : 
; 1179 :    #ifndef STBI_NO_TGA
; 1180 :    // test tga last because it's a crappy test!
; 1181 :    if (stbi__tga_test(s))
; 1182 :       return stbi__tga_load(s,x,y,comp,req_comp, ri);
; 1183 :    #endif
; 1184 : 
; 1185 :    return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
; 1186 : }
; 1187 : 
; 1188 : static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
; 1189 : {
; 1190 :    int i;
; 1191 :    int img_len = w * h * channels;
; 1192 :    stbi_uc *reduced;
; 1193 : 
; 1194 :    reduced = (stbi_uc *) stbi__malloc(img_len);
; 1195 :    if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");
; 1196 : 
; 1197 :    for (i = 0; i < img_len; ++i)
; 1198 :       reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling
; 1199 : 
; 1200 :    STBI_FREE(orig);
; 1201 :    return reduced;
; 1202 : }
; 1203 : 
; 1204 : static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
; 1205 : {
; 1206 :    int i;
; 1207 :    int img_len = w * h * channels;
; 1208 :    stbi__uint16 *enlarged;
; 1209 : 
; 1210 :    enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
; 1211 :    if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1212 : 
; 1213 :    for (i = 0; i < img_len; ++i)
; 1214 :       enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff
; 1215 : 
; 1216 :    STBI_FREE(orig);
; 1217 :    return enlarged;
; 1218 : }
; 1219 : 
; 1220 : static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
; 1221 : {
; 1222 :    int row;
; 1223 :    size_t bytes_per_row = (size_t)w * bytes_per_pixel;
; 1224 :    stbi_uc temp[2048];
; 1225 :    stbi_uc *bytes = (stbi_uc *)image;
; 1226 : 
; 1227 :    for (row = 0; row < (h>>1); row++) {
; 1228 :       stbi_uc *row0 = bytes + row*bytes_per_row;
; 1229 :       stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
; 1230 :       // swap row0 with row1
; 1231 :       size_t bytes_left = bytes_per_row;
; 1232 :       while (bytes_left) {
; 1233 :          size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
; 1234 :          memcpy(temp, row0, bytes_copy);
; 1235 :          memcpy(row0, row1, bytes_copy);
; 1236 :          memcpy(row1, temp, bytes_copy);
; 1237 :          row0 += bytes_copy;
; 1238 :          row1 += bytes_copy;
; 1239 :          bytes_left -= bytes_copy;
; 1240 :       }
; 1241 :    }
; 1242 : }
; 1243 : 
; 1244 : #ifndef STBI_NO_GIF
; 1245 : static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
; 1246 : {
; 1247 :    int slice;
; 1248 :    int slice_size = w * h * bytes_per_pixel;
; 1249 : 
; 1250 :    stbi_uc *bytes = (stbi_uc *)image;
; 1251 :    for (slice = 0; slice < z; ++slice) {
; 1252 :       stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
; 1253 :       bytes += slice_size;
; 1254 :    }
; 1255 : }
; 1256 : #endif
; 1257 : 
; 1258 : static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
; 1259 : {
; 1260 :    stbi__result_info ri;
; 1261 :    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);
; 1262 : 
; 1263 :    if (result == NULL)
; 1264 :       return NULL;
; 1265 : 
; 1266 :    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1267 :    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
; 1268 : 
; 1269 :    if (ri.bits_per_channel != 8) {
; 1270 :       result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
; 1271 :       ri.bits_per_channel = 8;
; 1272 :    }
; 1273 : 
; 1274 :    // @TODO: move stbi__convert_format to here
; 1275 : 
; 1276 :    if (stbi__vertically_flip_on_load) {
; 1277 :       int channels = req_comp ? req_comp : *comp;
; 1278 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
; 1279 :    }
; 1280 : 
; 1281 :    return (unsigned char *) result;
; 1282 : }
; 1283 : 
; 1284 : static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
; 1285 : {
; 1286 :    stbi__result_info ri;
; 1287 :    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);
; 1288 : 
; 1289 :    if (result == NULL)
; 1290 :       return NULL;
; 1291 : 
; 1292 :    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1293 :    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
; 1294 : 
; 1295 :    if (ri.bits_per_channel != 16) {
; 1296 :       result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
; 1297 :       ri.bits_per_channel = 16;
; 1298 :    }
; 1299 : 
; 1300 :    // @TODO: move stbi__convert_format16 to here
; 1301 :    // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision
; 1302 : 
; 1303 :    if (stbi__vertically_flip_on_load) {
; 1304 :       int channels = req_comp ? req_comp : *comp;
; 1305 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
; 1306 :    }
; 1307 : 
; 1308 :    return (stbi__uint16 *) result;
; 1309 : }
; 1310 : 
; 1311 : #if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)
; 1312 : static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
; 1313 : {
; 1314 :    if (stbi__vertically_flip_on_load && result != NULL) {
; 1315 :       int channels = req_comp ? req_comp : *comp;
; 1316 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
; 1317 :    }
; 1318 : }
; 1319 : #endif
; 1320 : 
; 1321 : #ifndef STBI_NO_STDIO
; 1322 : 
; 1323 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1324 : STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
; 1325 : STBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);
; 1326 : #endif
; 1327 : 
; 1328 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1329 : STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
; 1330 : {
; 1331 : 	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
; 1332 : }
; 1333 : #endif
; 1334 : 
; 1335 : static FILE *stbi__fopen(char const *filename, char const *mode)
; 1336 : {
; 1337 :    FILE *f;
; 1338 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1339 :    wchar_t wMode[64];
; 1340 :    wchar_t wFilename[1024];
; 1341 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
; 1342 :       return 0;
; 1343 : 
; 1344 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
; 1345 :       return 0;
; 1346 : 
; 1347 : #if defined(_MSC_VER) && _MSC_VER >= 1400
; 1348 : 	if (0 != _wfopen_s(&f, wFilename, wMode))
; 1349 : 		f = 0;
; 1350 : #else
; 1351 :    f = _wfopen(wFilename, wMode);
; 1352 : #endif
; 1353 : 
; 1354 : #elif defined(_MSC_VER) && _MSC_VER >= 1400
; 1355 :    if (0 != fopen_s(&f, filename, mode))
; 1356 :       f=0;
; 1357 : #else
; 1358 :    f = fopen(filename, mode);
; 1359 : #endif
; 1360 :    return f;
; 1361 : }
; 1362 : 
; 1363 : 
; 1364 : STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
; 1365 : {
; 1366 :    FILE *f = stbi__fopen(filename, "rb");
; 1367 :    unsigned char *result;
; 1368 :    if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
; 1369 :    result = stbi_load_from_file(f,x,y,comp,req_comp);
; 1370 :    fclose(f);
; 1371 :    return result;
; 1372 : }
; 1373 : 
; 1374 : STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
; 1375 : {
; 1376 :    unsigned char *result;
; 1377 :    stbi__context s;
; 1378 :    stbi__start_file(&s,f);
; 1379 :    result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
; 1380 :    if (result) {
; 1381 :       // need to 'unget' all the characters in the IO buffer
; 1382 :       fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
; 1383 :    }
; 1384 :    return result;
; 1385 : }
; 1386 : 
; 1387 : STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
; 1388 : {
; 1389 :    stbi__uint16 *result;
; 1390 :    stbi__context s;
; 1391 :    stbi__start_file(&s,f);
; 1392 :    result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
; 1393 :    if (result) {
; 1394 :       // need to 'unget' all the characters in the IO buffer
; 1395 :       fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
; 1396 :    }
; 1397 :    return result;
; 1398 : }
; 1399 : 
; 1400 : STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
; 1401 : {
; 1402 :    FILE *f = stbi__fopen(filename, "rb");
; 1403 :    stbi__uint16 *result;
; 1404 :    if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");
; 1405 :    result = stbi_load_from_file_16(f,x,y,comp,req_comp);
; 1406 :    fclose(f);
; 1407 :    return result;
; 1408 : }
; 1409 : 
; 1410 : 
; 1411 : #endif //!STBI_NO_STDIO
; 1412 : 
; 1413 : STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
; 1414 : {
; 1415 :    stbi__context s;
; 1416 :    stbi__start_mem(&s,buffer,len);
; 1417 :    return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
; 1418 : }
; 1419 : 
; 1420 : STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
; 1421 : {
; 1422 :    stbi__context s;
; 1423 :    stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
; 1424 :    return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
; 1425 : }
; 1426 : 
; 1427 : STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
; 1428 : {
; 1429 :    stbi__context s;
; 1430 :    stbi__start_mem(&s,buffer,len);
; 1431 :    return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
; 1432 : }
; 1433 : 
; 1434 : STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
; 1435 : {
; 1436 :    stbi__context s;
; 1437 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
; 1438 :    return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
; 1439 : }
; 1440 : 
; 1441 : #ifndef STBI_NO_GIF
; 1442 : STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
; 1443 : {
; 1444 :    unsigned char *result;
; 1445 :    stbi__context s;
; 1446 :    stbi__start_mem(&s,buffer,len);
; 1447 : 
; 1448 :    result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
; 1449 :    if (stbi__vertically_flip_on_load) {
; 1450 :       stbi__vertical_flip_slices( result, *x, *y, *z, *comp );
; 1451 :    }
; 1452 : 
; 1453 :    return result;
; 1454 : }
; 1455 : #endif
; 1456 : 
; 1457 : #ifndef STBI_NO_LINEAR
; 1458 : static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
; 1459 : {
; 1460 :    unsigned char *data;
; 1461 :    #ifndef STBI_NO_HDR
; 1462 :    if (stbi__hdr_test(s)) {
; 1463 :       stbi__result_info ri;
; 1464 :       float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
; 1465 :       if (hdr_data)
; 1466 :          stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
; 1467 :       return hdr_data;
; 1468 :    }
; 1469 :    #endif
; 1470 :    data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
; 1471 :    if (data)
; 1472 :       return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
; 1473 :    return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
; 1474 : }
; 1475 : 
; 1476 : STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
; 1477 : {
; 1478 :    stbi__context s;
; 1479 :    stbi__start_mem(&s,buffer,len);
; 1480 :    return stbi__loadf_main(&s,x,y,comp,req_comp);
; 1481 : }
; 1482 : 
; 1483 : STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
; 1484 : {
; 1485 :    stbi__context s;
; 1486 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
; 1487 :    return stbi__loadf_main(&s,x,y,comp,req_comp);
; 1488 : }
; 1489 : 
; 1490 : #ifndef STBI_NO_STDIO
; 1491 : STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
; 1492 : {
; 1493 :    float *result;
; 1494 :    FILE *f = stbi__fopen(filename, "rb");
; 1495 :    if (!f) return stbi__errpf("can't fopen", "Unable to open file");
; 1496 :    result = stbi_loadf_from_file(f,x,y,comp,req_comp);
; 1497 :    fclose(f);
; 1498 :    return result;
; 1499 : }
; 1500 : 
; 1501 : STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
; 1502 : {
; 1503 :    stbi__context s;
; 1504 :    stbi__start_file(&s,f);
; 1505 :    return stbi__loadf_main(&s,x,y,comp,req_comp);
; 1506 : }
; 1507 : #endif // !STBI_NO_STDIO
; 1508 : 
; 1509 : #endif // !STBI_NO_LINEAR
; 1510 : 
; 1511 : // these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
; 1512 : // defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
; 1513 : // reports false!
; 1514 : 
; 1515 : STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
; 1516 : {
; 1517 :    #ifndef STBI_NO_HDR
; 1518 :    stbi__context s;
; 1519 :    stbi__start_mem(&s,buffer,len);
; 1520 :    return stbi__hdr_test(&s);
; 1521 :    #else
; 1522 :    STBI_NOTUSED(buffer);
; 1523 :    STBI_NOTUSED(len);
; 1524 :    return 0;
; 1525 :    #endif
; 1526 : }
; 1527 : 
; 1528 : #ifndef STBI_NO_STDIO
; 1529 : STBIDEF int      stbi_is_hdr          (char const *filename)
; 1530 : {
; 1531 :    FILE *f = stbi__fopen(filename, "rb");
; 1532 :    int result=0;
; 1533 :    if (f) {
; 1534 :       result = stbi_is_hdr_from_file(f);
; 1535 :       fclose(f);
; 1536 :    }
; 1537 :    return result;
; 1538 : }
; 1539 : 
; 1540 : STBIDEF int stbi_is_hdr_from_file(FILE *f)
; 1541 : {
; 1542 :    #ifndef STBI_NO_HDR
; 1543 :    long pos = ftell(f);
; 1544 :    int res;
; 1545 :    stbi__context s;
; 1546 :    stbi__start_file(&s,f);
; 1547 :    res = stbi__hdr_test(&s);
; 1548 :    fseek(f, pos, SEEK_SET);
; 1549 :    return res;
; 1550 :    #else
; 1551 :    STBI_NOTUSED(f);
; 1552 :    return 0;
; 1553 :    #endif
; 1554 : }
; 1555 : #endif // !STBI_NO_STDIO
; 1556 : 
; 1557 : STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
; 1558 : {
; 1559 :    #ifndef STBI_NO_HDR
; 1560 :    stbi__context s;
; 1561 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
; 1562 :    return stbi__hdr_test(&s);
; 1563 :    #else
; 1564 :    STBI_NOTUSED(clbk);
; 1565 :    STBI_NOTUSED(user);
; 1566 :    return 0;
; 1567 :    #endif
; 1568 : }
; 1569 : 
; 1570 : #ifndef STBI_NO_LINEAR
; 1571 : static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;
; 1572 : 
; 1573 : STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
; 1574 : STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
; 1575 : #endif
; 1576 : 
; 1577 : static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;
; 1578 : 
; 1579 : STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
; 1580 : STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }
; 1581 : 
; 1582 : 
; 1583 : //////////////////////////////////////////////////////////////////////////////
; 1584 : //
; 1585 : // Common code used by all image loaders
; 1586 : //
; 1587 : 
; 1588 : enum
; 1589 : {
; 1590 :    STBI__SCAN_load=0,
; 1591 :    STBI__SCAN_type,
; 1592 :    STBI__SCAN_header
; 1593 : };
; 1594 : 
; 1595 : static void stbi__refill_buffer(stbi__context *s)
; 1596 : {
; 1597 :    int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
; 1598 :    s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);
; 1599 :    if (n == 0) {
; 1600 :       // at end of file, treat same as if from memory, but need to handle case
; 1601 :       // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
; 1602 :       s->read_from_callbacks = 0;
; 1603 :       s->img_buffer = s->buffer_start;
; 1604 :       s->img_buffer_end = s->buffer_start+1;
; 1605 :       *s->img_buffer = 0;
; 1606 :    } else {
; 1607 :       s->img_buffer = s->buffer_start;
; 1608 :       s->img_buffer_end = s->buffer_start + n;
; 1609 :    }
; 1610 : }
; 1611 : 
; 1612 : stbi_inline static stbi_uc stbi__get8(stbi__context *s)
; 1613 : {
; 1614 :    if (s->img_buffer < s->img_buffer_end)
; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {
; 1617 :       stbi__refill_buffer(s);
; 1618 :       return *s->img_buffer++;
; 1619 :    }
; 1620 :    return 0;
; 1621 : }
; 1622 : 
; 1623 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1624 : // nothing
; 1625 : #else
; 1626 : stbi_inline static int stbi__at_eof(stbi__context *s)
; 1627 : {
; 1628 :    if (s->io.read) {
; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;
; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;
; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;
; 1636 : }
; 1637 : #endif
; 1638 : 
; 1639 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
; 1640 : // nothing
; 1641 : #else
; 1642 : static void stbi__skip(stbi__context *s, int n)
; 1643 : {
; 1644 :    if (n == 0) return;  // already there!
; 1645 :    if (n < 0) {
; 1646 :       s->img_buffer = s->img_buffer_end;
; 1647 :       return;
; 1648 :    }
; 1649 :    if (s->io.read) {
; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1651 :       if (blen < n) {
; 1652 :          s->img_buffer = s->img_buffer_end;
; 1653 :          (s->io.skip)(s->io_user_data, n - blen);
; 1654 :          return;
; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;
; 1658 : }
; 1659 : #endif
; 1660 : 
; 1661 : #if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
; 1662 : // nothing
; 1663 : #else
; 1664 : static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
; 1665 : {
; 1666 :    if (s->io.read) {
; 1667 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1668 :       if (blen < n) {
; 1669 :          int res, count;
; 1670 : 
; 1671 :          memcpy(buffer, s->img_buffer, blen);
; 1672 : 
; 1673 :          count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
; 1674 :          res = (count == (n-blen));
; 1675 :          s->img_buffer = s->img_buffer_end;
; 1676 :          return res;
; 1677 :       }
; 1678 :    }
; 1679 : 
; 1680 :    if (s->img_buffer+n <= s->img_buffer_end) {
; 1681 :       memcpy(buffer, s->img_buffer, n);
; 1682 :       s->img_buffer += n;
; 1683 :       return 1;
; 1684 :    } else
; 1685 :       return 0;
; 1686 : }
; 1687 : #endif
; 1688 : 
; 1689 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1690 : // nothing
; 1691 : #else
; 1692 : static int stbi__get16be(stbi__context *s)
; 1693 : {
; 1694 :    int z = stbi__get8(s);
; 1695 :    return (z << 8) + stbi__get8(s);
; 1696 : }
; 1697 : #endif
; 1698 : 
; 1699 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1700 : // nothing
; 1701 : #else
; 1702 : static stbi__uint32 stbi__get32be(stbi__context *s)
; 1703 : {
; 1704 :    stbi__uint32 z = stbi__get16be(s);
; 1705 :    return (z << 16) + stbi__get16be(s);
; 1706 : }
; 1707 : #endif
; 1708 : 
; 1709 : #if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
; 1710 : // nothing
; 1711 : #else
; 1712 : static int stbi__get16le(stbi__context *s)
; 1713 : {
; 1714 :    int z = stbi__get8(s);
; 1715 :    return z + (stbi__get8(s) << 8);
; 1716 : }
; 1717 : #endif
; 1718 : 
; 1719 : #ifndef STBI_NO_BMP
; 1720 : static stbi__uint32 stbi__get32le(stbi__context *s)
; 1721 : {
; 1722 :    stbi__uint32 z = stbi__get16le(s);
; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;
; 1724 :    return z;
; 1725 : }
; 1726 : #endif
; 1727 : 
; 1728 : #define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
; 1729 : 
; 1730 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1731 : // nothing
; 1732 : #else
; 1733 : //////////////////////////////////////////////////////////////////////////////
; 1734 : //
; 1735 : //  generic converter from built-in img_n to req_comp
; 1736 : //    individual types do this automatically as much as possible (e.g. jpeg
; 1737 : //    does all cases internally since it needs to colorspace convert anyway,
; 1738 : //    and it never has alpha, so very few cases ). png can automatically
; 1739 : //    interleave an alpha=255 channel, but falls back to this for other cases
; 1740 : //
; 1741 : //  assume data buffer is malloced, so malloc a new one and free that one
; 1742 : //  only failure mode is malloc failing
; 1743 : 
; 1744 : static stbi_uc stbi__compute_y(int r, int g, int b)
; 1745 : {
; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1747 : }
; 1748 : #endif
; 1749 : 
; 1750 : #if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1751 : // nothing
; 1752 : #else
; 1753 : static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1754 : {
; 1755 :    int i,j;
; 1756 :    unsigned char *good;
; 1757 : 
; 1758 :    if (req_comp == img_n) return data;
; 1759 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1760 : 
; 1761 :    good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
; 1762 :    if (good == NULL) {
; 1763 :       STBI_FREE(data);
; 1764 :       return stbi__errpuc("outofmem", "Out of memory");
; 1765 :    }
; 1766 : 
; 1767 :    for (j=0; j < (int) y; ++j) {
; 1768 :       unsigned char *src  = data + j * x * img_n   ;
; 1769 :       unsigned char *dest = good + j * x * req_comp;
; 1770 : 
; 1771 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1772 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1773 :       // convert source image with img_n components to one with req_comp components;
; 1774 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1775 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1776 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
; 1777 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1778 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
; 1779 :          STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
; 1780 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1781 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
; 1782 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
; 1783 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1784 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
; 1785 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1786 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1787 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
; 1788 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
; 1789 :       }
; 1790 :       #undef STBI__CASE
; 1791 :    }
; 1792 : 
; 1793 :    STBI_FREE(data);
; 1794 :    return good;
; 1795 : }
; 1796 : #endif
; 1797 : 
; 1798 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1799 : // nothing
; 1800 : #else
; 1801 : static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
; 1802 : {
; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1804 : }
; 1805 : #endif
; 1806 : 
; 1807 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1808 : // nothing
; 1809 : #else
; 1810 : static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1811 : {
; 1812 :    int i,j;
; 1813 :    stbi__uint16 *good;
; 1814 : 
; 1815 :    if (req_comp == img_n) return data;
; 1816 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1817 : 
; 1818 :    good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
; 1819 :    if (good == NULL) {
; 1820 :       STBI_FREE(data);
; 1821 :       return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1822 :    }
; 1823 : 
; 1824 :    for (j=0; j < (int) y; ++j) {
; 1825 :       stbi__uint16 *src  = data + j * x * img_n   ;
; 1826 :       stbi__uint16 *dest = good + j * x * req_comp;
; 1827 : 
; 1828 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1829 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1830 :       // convert source image with img_n components to one with req_comp components;
; 1831 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1832 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1833 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
; 1834 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1835 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
; 1836 :          STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
; 1837 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1838 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
; 1839 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
; 1840 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1841 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
; 1842 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1843 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1844 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
; 1845 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
; 1846 :       }
; 1847 :       #undef STBI__CASE
; 1848 :    }
; 1849 : 
; 1850 :    STBI_FREE(data);
; 1851 :    return good;
; 1852 : }
; 1853 : #endif
; 1854 : 
; 1855 : #ifndef STBI_NO_LINEAR
; 1856 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
; 1857 : {
; 1858 :    int i,k,n;
; 1859 :    float *output;
; 1860 :    if (!data) return NULL;
; 1861 :    output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
; 1862 :    if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
; 1863 :    // compute number of non-alpha components
; 1864 :    if (comp & 1) n = comp; else n = comp-1;
; 1865 :    for (i=0; i < x*y; ++i) {
; 1866 :       for (k=0; k < n; ++k) {
; 1867 :          output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
; 1868 :       }
; 1869 :    }
; 1870 :    if (n < comp) {
; 1871 :       for (i=0; i < x*y; ++i) {
; 1872 :          output[i*comp + n] = data[i*comp + n]/255.0f;
; 1873 :       }
; 1874 :    }
; 1875 :    STBI_FREE(data);
; 1876 :    return output;
; 1877 : }
; 1878 : #endif
; 1879 : 
; 1880 : #ifndef STBI_NO_HDR
; 1881 : #define stbi__float2int(x)   ((int) (x))
; 1882 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
; 1883 : {
; 1884 :    int i,k,n;
; 1885 :    stbi_uc *output;
; 1886 :    if (!data) return NULL;
; 1887 :    output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
; 1888 :    if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
; 1889 :    // compute number of non-alpha components
; 1890 :    if (comp & 1) n = comp; else n = comp-1;
; 1891 :    for (i=0; i < x*y; ++i) {
; 1892 :       for (k=0; k < n; ++k) {
; 1893 :          float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
; 1894 :          if (z < 0) z = 0;
; 1895 :          if (z > 255) z = 255;
; 1896 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1897 :       }
; 1898 :       if (k < comp) {
; 1899 :          float z = data[i*comp+k] * 255 + 0.5f;
; 1900 :          if (z < 0) z = 0;
; 1901 :          if (z > 255) z = 255;
; 1902 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1903 :       }
; 1904 :    }
; 1905 :    STBI_FREE(data);
; 1906 :    return output;
; 1907 : }
; 1908 : #endif
; 1909 : 
; 1910 : //////////////////////////////////////////////////////////////////////////////
; 1911 : //
; 1912 : //  "baseline" JPEG/JFIF decoder
; 1913 : //
; 1914 : //    simple implementation
; 1915 : //      - doesn't support delayed output of y-dimension
; 1916 : //      - simple interface (only one output format: 8-bit interleaved RGB)
; 1917 : //      - doesn't try to recover corrupt jpegs
; 1918 : //      - doesn't allow partial loading, loading multiple at once
; 1919 : //      - still fast on x86 (copying globals into locals doesn't help x86)
; 1920 : //      - allocates lots of intermediate memory (full size of all components)
; 1921 : //        - non-interleaved case requires this anyway
; 1922 : //        - allows good upsampling (see next)
; 1923 : //    high-quality
; 1924 : //      - upsampled channels are bilinearly interpolated, even across blocks
; 1925 : //      - quality integer IDCT derived from IJG's 'slow'
; 1926 : //    performance
; 1927 : //      - fast huffman; reasonable integer IDCT
; 1928 : //      - some SIMD kernels for common paths on targets with SSE2/NEON
; 1929 : //      - uses a lot of intermediate memory, could cache poorly
; 1930 : 
; 1931 : #ifndef STBI_NO_JPEG
; 1932 : 
; 1933 : // huffman decoding acceleration
; 1934 : #define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
; 1935 : 
; 1936 : typedef struct
; 1937 : {
; 1938 :    stbi_uc  fast[1 << FAST_BITS];
; 1939 :    // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
; 1940 :    stbi__uint16 code[256];
; 1941 :    stbi_uc  values[256];
; 1942 :    stbi_uc  size[257];
; 1943 :    unsigned int maxcode[18];
; 1944 :    int    delta[17];   // old 'firstsymbol' - old 'firstcode'
; 1945 : } stbi__huffman;
; 1946 : 
; 1947 : typedef struct
; 1948 : {
; 1949 :    stbi__context *s;
; 1950 :    stbi__huffman huff_dc[4];
; 1951 :    stbi__huffman huff_ac[4];
; 1952 :    stbi__uint16 dequant[4][64];
; 1953 :    stbi__int16 fast_ac[4][1 << FAST_BITS];
; 1954 : 
; 1955 : // sizes for components, interleaved MCUs
; 1956 :    int img_h_max, img_v_max;
; 1957 :    int img_mcu_x, img_mcu_y;
; 1958 :    int img_mcu_w, img_mcu_h;
; 1959 : 
; 1960 : // definition of jpeg image component
; 1961 :    struct
; 1962 :    {
; 1963 :       int id;
; 1964 :       int h,v;
; 1965 :       int tq;
; 1966 :       int hd,ha;
; 1967 :       int dc_pred;
; 1968 : 
; 1969 :       int x,y,w2,h2;
; 1970 :       stbi_uc *data;
; 1971 :       void *raw_data, *raw_coeff;
; 1972 :       stbi_uc *linebuf;
; 1973 :       short   *coeff;   // progressive only
; 1974 :       int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
; 1975 :    } img_comp[4];
; 1976 : 
; 1977 :    stbi__uint32   code_buffer; // jpeg entropy-coded buffer
; 1978 :    int            code_bits;   // number of valid bits
; 1979 :    unsigned char  marker;      // marker seen while filling entropy buffer
; 1980 :    int            nomore;      // flag if we saw a marker so must stop
; 1981 : 
; 1982 :    int            progressive;
; 1983 :    int            spec_start;
; 1984 :    int            spec_end;
; 1985 :    int            succ_high;
; 1986 :    int            succ_low;
; 1987 :    int            eob_run;
; 1988 :    int            jfif;
; 1989 :    int            app14_color_transform; // Adobe APP14 tag
; 1990 :    int            rgb;
; 1991 : 
; 1992 :    int scan_n, order[4];
; 1993 :    int restart_interval, todo;
; 1994 : 
; 1995 : // kernels
; 1996 :    void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
; 1997 :    void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
; 1998 :    stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
; 1999 : } stbi__jpeg;
; 2000 : 
; 2001 : static int stbi__build_huffman(stbi__huffman *h, int *count)
; 2002 : {
; 2003 :    int i,j,k=0;
; 2004 :    unsigned int code;
; 2005 :    // build size list for each symbol (from JPEG spec)
; 2006 :    for (i=0; i < 16; ++i) {
; 2007 :       for (j=0; j < count[i]; ++j) {
; 2008 :          h->size[k++] = (stbi_uc) (i+1);
; 2009 :          if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");
; 2010 :       }
; 2011 :    }
; 2012 :    h->size[k] = 0;
; 2013 : 
; 2014 :    // compute actual symbols (from jpeg spec)
; 2015 :    code = 0;
; 2016 :    k = 0;
; 2017 :    for(j=1; j <= 16; ++j) {
; 2018 :       // compute delta to add to code to compute symbol id
; 2019 :       h->delta[j] = k - code;
; 2020 :       if (h->size[k] == j) {
; 2021 :          while (h->size[k] == j)
; 2022 :             h->code[k++] = (stbi__uint16) (code++);
; 2023 :          if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
; 2024 :       }
; 2025 :       // compute largest code + 1 for this size, preshifted as needed later
; 2026 :       h->maxcode[j] = code << (16-j);
; 2027 :       code <<= 1;
; 2028 :    }
; 2029 :    h->maxcode[j] = 0xffffffff;
; 2030 : 
; 2031 :    // build non-spec acceleration table; 255 is flag for not-accelerated
; 2032 :    memset(h->fast, 255, 1 << FAST_BITS);
; 2033 :    for (i=0; i < k; ++i) {
; 2034 :       int s = h->size[i];
; 2035 :       if (s <= FAST_BITS) {
; 2036 :          int c = h->code[i] << (FAST_BITS-s);
; 2037 :          int m = 1 << (FAST_BITS-s);
; 2038 :          for (j=0; j < m; ++j) {
; 2039 :             h->fast[c+j] = (stbi_uc) i;
; 2040 :          }
; 2041 :       }
; 2042 :    }
; 2043 :    return 1;
; 2044 : }
; 2045 : 
; 2046 : // build a table that decodes both magnitude and value of small ACs in
; 2047 : // one go.
; 2048 : static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
; 2049 : {
; 2050 :    int i;
; 2051 :    for (i=0; i < (1 << FAST_BITS); ++i) {
; 2052 :       stbi_uc fast = h->fast[i];
; 2053 :       fast_ac[i] = 0;
; 2054 :       if (fast < 255) {
; 2055 :          int rs = h->values[fast];
; 2056 :          int run = (rs >> 4) & 15;
; 2057 :          int magbits = rs & 15;
; 2058 :          int len = h->size[fast];
; 2059 : 
; 2060 :          if (magbits && len + magbits <= FAST_BITS) {
; 2061 :             // magnitude code followed by receive_extend code
; 2062 :             int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
; 2063 :             int m = 1 << (magbits - 1);
; 2064 :             if (k < m) k += (~0U << magbits) + 1;
; 2065 :             // if the result is small enough, we can fit it in fast_ac table
; 2066 :             if (k >= -128 && k <= 127)
; 2067 :                fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
; 2068 :          }
; 2069 :       }
; 2070 :    }
; 2071 : }
; 2072 : 
; 2073 : static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
; 2074 : {
; 2075 :    do {
; 2076 :       unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
; 2077 :       if (b == 0xff) {
; 2078 :          int c = stbi__get8(j->s);
; 2079 :          while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
; 2080 :          if (c != 0) {
; 2081 :             j->marker = (unsigned char) c;
; 2082 :             j->nomore = 1;
; 2083 :             return;
; 2084 :          }
; 2085 :       }
; 2086 :       j->code_buffer |= b << (24 - j->code_bits);
; 2087 :       j->code_bits += 8;
; 2088 :    } while (j->code_bits <= 24);
; 2089 : }
; 2090 : 
; 2091 : // (1 << n) - 1
; 2092 : static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
; 2093 : 
; 2094 : // decode a jpeg huffman value from the bitstream
; 2095 : stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
; 2096 : {
; 2097 :    unsigned int temp;
; 2098 :    int c,k;
; 2099 : 
; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2105 :    k = h->fast[c];
; 2106 :    if (k < 255) {
; 2107 :       int s = h->size[k];
; 2108 :       if (s > j->code_bits)
; 2109 :          return -1;
; 2110 :       j->code_buffer <<= s;
; 2111 :       j->code_bits -= s;
; 2112 :       return h->values[k];
; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;
; 2122 :    for (k=FAST_BITS+1 ; ; ++k)
; 2123 :       if (temp < h->maxcode[k])
; 2124 :          break;
; 2125 :    if (k == 17) {
; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;
; 2128 :       return -1;
; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)
; 2132 :       return -1;
; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!
; 2137 :        return -1;
; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;
; 2142 :    j->code_buffer <<= k;
; 2143 :    return h->values[c];
; 2144 : }
; 2145 : 
; 2146 : // bias[n] = (-1<<n) + 1
; 2147 : static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};
; 2148 : 
; 2149 : // combined JPEG 'receive' and JPEG 'extend', since baseline
; 2150 : // always extends everything it receives.
; 2151 : stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
; 2152 : {
; 2153 :    unsigned int k;
; 2154 :    int sgn;
; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
; 2159 :    k = stbi_lrot(j->code_buffer, n);
; 2160 :    j->code_buffer = k & ~stbi__bmask[n];
; 2161 :    k &= stbi__bmask[n];
; 2162 :    j->code_bits -= n;
; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));
; 2164 : }
; 2165 : 
; 2166 : // get some unsigned bits
; 2167 : stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
; 2168 : {
; 2169 :    unsigned int k;
; 2170 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2171 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2172 :    k = stbi_lrot(j->code_buffer, n);
; 2173 :    j->code_buffer = k & ~stbi__bmask[n];
; 2174 :    k &= stbi__bmask[n];
; 2175 :    j->code_bits -= n;
; 2176 :    return k;
; 2177 : }
; 2178 : 
; 2179 : stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
; 2180 : {
; 2181 :    unsigned int k;
; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2184 :    k = j->code_buffer;
; 2185 :    j->code_buffer <<= 1;
; 2186 :    --j->code_bits;
; 2187 :    return k & 0x80000000;
; 2188 : }
; 2189 : 
; 2190 : // given a value that's at position X in the zigzag stream,
; 2191 : // where does it appear in the 8x8 matrix coded as row-major?
; 2192 : static const stbi_uc stbi__jpeg_dezigzag[64+15] =
; 2193 : {
; 2194 :     0,  1,  8, 16,  9,  2,  3, 10,
; 2195 :    17, 24, 32, 25, 18, 11,  4,  5,
; 2196 :    12, 19, 26, 33, 40, 48, 41, 34,
; 2197 :    27, 20, 13,  6,  7, 14, 21, 28,
; 2198 :    35, 42, 49, 56, 57, 50, 43, 36,
; 2199 :    29, 22, 15, 23, 30, 37, 44, 51,
; 2200 :    58, 59, 52, 45, 38, 31, 39, 46,
; 2201 :    53, 60, 61, 54, 47, 55, 62, 63,
; 2202 :    // let corrupt input sample past end
; 2203 :    63, 63, 63, 63, 63, 63, 63, 63,
; 2204 :    63, 63, 63, 63, 63, 63, 63
; 2205 : };
; 2206 : 
; 2207 : // decode one 64-entry block--
; 2208 : static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
; 2209 : {
; 2210 :    int diff,dc,k;
; 2211 :    int t;
; 2212 : 
; 2213 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2214 :    t = stbi__jpeg_huff_decode(j, hdc);
; 2215 :    if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");
; 2216 : 
; 2217 :    // 0 all the ac values now so we can do it 32-bits at a time
; 2218 :    memset(data,0,64*sizeof(data[0]));
; 2219 : 
; 2220 :    diff = t ? stbi__extend_receive(j, t) : 0;
; 2221 :    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");
; 2222 :    dc = j->img_comp[b].dc_pred + diff;
; 2223 :    j->img_comp[b].dc_pred = dc;
; 2224 :    if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2225 :    data[0] = (short) (dc * dequant[0]);
; 2226 : 
; 2227 :    // decode AC components, see JPEG spec
; 2228 :    k = 1;
; 2229 :    do {
; 2230 :       unsigned int zig;
; 2231 :       int c,r,s;
; 2232 :       if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2233 :       c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2234 :       r = fac[c];
; 2235 :       if (r) { // fast-AC path
; 2236 :          k += (r >> 4) & 15; // run
; 2237 :          s = r & 15; // combined length
; 2238 :          if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2239 :          j->code_buffer <<= s;
; 2240 :          j->code_bits -= s;
; 2241 :          // decode into unzigzag'd location
; 2242 :          zig = stbi__jpeg_dezigzag[k++];
; 2243 :          data[zig] = (short) ((r >> 8) * dequant[zig]);
; 2244 :       } else {
; 2245 :          int rs = stbi__jpeg_huff_decode(j, hac);
; 2246 :          if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2247 :          s = rs & 15;
; 2248 :          r = rs >> 4;
; 2249 :          if (s == 0) {
; 2250 :             if (rs != 0xf0) break; // end block
; 2251 :             k += 16;
; 2252 :          } else {
; 2253 :             k += r;
; 2254 :             // decode into unzigzag'd location
; 2255 :             zig = stbi__jpeg_dezigzag[k++];
; 2256 :             data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
; 2257 :          }
; 2258 :       }
; 2259 :    } while (k < 64);
; 2260 :    return 1;
; 2261 : }
; 2262 : 
; 2263 : static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
; 2264 : {
; 2265 :    int diff,dc;
; 2266 :    int t;
; 2267 :    if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2268 : 
; 2269 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2270 : 
; 2271 :    if (j->succ_high == 0) {
; 2272 :       // first scan for DC coefficient, must be first
; 2273 :       memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
; 2274 :       t = stbi__jpeg_huff_decode(j, hdc);
; 2275 :       if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2276 :       diff = t ? stbi__extend_receive(j, t) : 0;
; 2277 : 
; 2278 :       if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");
; 2279 :       dc = j->img_comp[b].dc_pred + diff;
; 2280 :       j->img_comp[b].dc_pred = dc;
; 2281 :       if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2282 :       data[0] = (short) (dc * (1 << j->succ_low));
; 2283 :    } else {
; 2284 :       // refinement scan for DC coefficient
; 2285 :       if (stbi__jpeg_get_bit(j))
; 2286 :          data[0] += (short) (1 << j->succ_low);
; 2287 :    }
; 2288 :    return 1;
; 2289 : }
; 2290 : 
; 2291 : // @OPTIMIZE: store non-zigzagged during the decode passes,
; 2292 : // and only de-zigzag when dequantizing
; 2293 : static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
; 2294 : {
; 2295 :    int k;
; 2296 :    if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2297 : 
; 2298 :    if (j->succ_high == 0) {
; 2299 :       int shift = j->succ_low;
; 2300 : 
; 2301 :       if (j->eob_run) {
; 2302 :          --j->eob_run;
; 2303 :          return 1;
; 2304 :       }
; 2305 : 
; 2306 :       k = j->spec_start;
; 2307 :       do {
; 2308 :          unsigned int zig;
; 2309 :          int c,r,s;
; 2310 :          if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2311 :          c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2312 :          r = fac[c];
; 2313 :          if (r) { // fast-AC path
; 2314 :             k += (r >> 4) & 15; // run
; 2315 :             s = r & 15; // combined length
; 2316 :             if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2317 :             j->code_buffer <<= s;
; 2318 :             j->code_bits -= s;
; 2319 :             zig = stbi__jpeg_dezigzag[k++];
; 2320 :             data[zig] = (short) ((r >> 8) * (1 << shift));
; 2321 :          } else {
; 2322 :             int rs = stbi__jpeg_huff_decode(j, hac);
; 2323 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2324 :             s = rs & 15;
; 2325 :             r = rs >> 4;
; 2326 :             if (s == 0) {
; 2327 :                if (r < 15) {
; 2328 :                   j->eob_run = (1 << r);
; 2329 :                   if (r)
; 2330 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2331 :                   --j->eob_run;
; 2332 :                   break;
; 2333 :                }
; 2334 :                k += 16;
; 2335 :             } else {
; 2336 :                k += r;
; 2337 :                zig = stbi__jpeg_dezigzag[k++];
; 2338 :                data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
; 2339 :             }
; 2340 :          }
; 2341 :       } while (k <= j->spec_end);
; 2342 :    } else {
; 2343 :       // refinement scan for these AC coefficients
; 2344 : 
; 2345 :       short bit = (short) (1 << j->succ_low);
; 2346 : 
; 2347 :       if (j->eob_run) {
; 2348 :          --j->eob_run;
; 2349 :          for (k = j->spec_start; k <= j->spec_end; ++k) {
; 2350 :             short *p = &data[stbi__jpeg_dezigzag[k]];
; 2351 :             if (*p != 0)
; 2352 :                if (stbi__jpeg_get_bit(j))
; 2353 :                   if ((*p & bit)==0) {
; 2354 :                      if (*p > 0)
; 2355 :                         *p += bit;
; 2356 :                      else
; 2357 :                         *p -= bit;
; 2358 :                   }
; 2359 :          }
; 2360 :       } else {
; 2361 :          k = j->spec_start;
; 2362 :          do {
; 2363 :             int r,s;
; 2364 :             int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
; 2365 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2366 :             s = rs & 15;
; 2367 :             r = rs >> 4;
; 2368 :             if (s == 0) {
; 2369 :                if (r < 15) {
; 2370 :                   j->eob_run = (1 << r) - 1;
; 2371 :                   if (r)
; 2372 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2373 :                   r = 64; // force end of block
; 2374 :                } else {
; 2375 :                   // r=15 s=0 should write 16 0s, so we just do
; 2376 :                   // a run of 15 0s and then write s (which is 0),
; 2377 :                   // so we don't have to do anything special here
; 2378 :                }
; 2379 :             } else {
; 2380 :                if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
; 2381 :                // sign bit
; 2382 :                if (stbi__jpeg_get_bit(j))
; 2383 :                   s = bit;
; 2384 :                else
; 2385 :                   s = -bit;
; 2386 :             }
; 2387 : 
; 2388 :             // advance by r
; 2389 :             while (k <= j->spec_end) {
; 2390 :                short *p = &data[stbi__jpeg_dezigzag[k++]];
; 2391 :                if (*p != 0) {
; 2392 :                   if (stbi__jpeg_get_bit(j))
; 2393 :                      if ((*p & bit)==0) {
; 2394 :                         if (*p > 0)
; 2395 :                            *p += bit;
; 2396 :                         else
; 2397 :                            *p -= bit;
; 2398 :                      }
; 2399 :                } else {
; 2400 :                   if (r == 0) {
; 2401 :                      *p = (short) s;
; 2402 :                      break;
; 2403 :                   }
; 2404 :                   --r;
; 2405 :                }
; 2406 :             }
; 2407 :          } while (k <= j->spec_end);
; 2408 :       }
; 2409 :    }
; 2410 :    return 1;
; 2411 : }
; 2412 : 
; 2413 : // take a -128..127 value and stbi__clamp it and convert to 0..255
; 2414 : stbi_inline static stbi_uc stbi__clamp(int x)
; 2415 : {
; 2416 :    // trick to use a single test to catch both cases
; 2417 :    if ((unsigned int) x > 255) {
; 2418 :       if (x < 0) return 0;
; 2419 :       if (x > 255) return 255;
; 2420 :    }
; 2421 :    return (stbi_uc) x;
; 2422 : }
; 2423 : 
; 2424 : #define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
; 2425 : #define stbi__fsh(x)  ((x) * 4096)
; 2426 : 
; 2427 : // derived from jidctint -- DCT_ISLOW
; 2428 : #define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
; 2429 :    int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
; 2430 :    p2 = s2;                                    \
; 2431 :    p3 = s6;                                    \
; 2432 :    p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
; 2433 :    t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
; 2434 :    t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
; 2435 :    p2 = s0;                                    \
; 2436 :    p3 = s4;                                    \
; 2437 :    t0 = stbi__fsh(p2+p3);                      \
; 2438 :    t1 = stbi__fsh(p2-p3);                      \
; 2439 :    x0 = t0+t3;                                 \
; 2440 :    x3 = t0-t3;                                 \
; 2441 :    x1 = t1+t2;                                 \
; 2442 :    x2 = t1-t2;                                 \
; 2443 :    t0 = s7;                                    \
; 2444 :    t1 = s5;                                    \
; 2445 :    t2 = s3;                                    \
; 2446 :    t3 = s1;                                    \
; 2447 :    p3 = t0+t2;                                 \
; 2448 :    p4 = t1+t3;                                 \
; 2449 :    p1 = t0+t3;                                 \
; 2450 :    p2 = t1+t2;                                 \
; 2451 :    p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
; 2452 :    t0 = t0*stbi__f2f( 0.298631336f);           \
; 2453 :    t1 = t1*stbi__f2f( 2.053119869f);           \
; 2454 :    t2 = t2*stbi__f2f( 3.072711026f);           \
; 2455 :    t3 = t3*stbi__f2f( 1.501321110f);           \
; 2456 :    p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
; 2457 :    p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
; 2458 :    p3 = p3*stbi__f2f(-1.961570560f);           \
; 2459 :    p4 = p4*stbi__f2f(-0.390180644f);           \
; 2460 :    t3 += p1+p4;                                \
; 2461 :    t2 += p2+p3;                                \
; 2462 :    t1 += p2+p4;                                \
; 2463 :    t0 += p1+p3;
; 2464 : 
; 2465 : static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
; 2466 : {
; 2467 :    int i,val[64],*v=val;
; 2468 :    stbi_uc *o;
; 2469 :    short *d = data;
; 2470 : 
; 2471 :    // columns
; 2472 :    for (i=0; i < 8; ++i,++d, ++v) {
; 2473 :       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2474 :       if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2475 :            && d[40]==0 && d[48]==0 && d[56]==0) {
; 2476 :          //    no shortcut                 0     seconds
; 2477 :          //    (1|2|3|4|5|6|7)==0          0     seconds
; 2478 :          //    all separate               -0.047 seconds
; 2479 :          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2480 :          int dcterm = d[0]*4;
; 2481 :          v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
; 2482 :       } else {
; 2483 :          STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
; 2484 :          // constants scaled things up by 1<<12; let's bring them back
; 2485 :          // down, but keep 2 extra bits of precision
; 2486 :          x0 += 512; x1 += 512; x2 += 512; x3 += 512;
; 2487 :          v[ 0] = (x0+t3) >> 10;
; 2488 :          v[56] = (x0-t3) >> 10;
; 2489 :          v[ 8] = (x1+t2) >> 10;
; 2490 :          v[48] = (x1-t2) >> 10;
; 2491 :          v[16] = (x2+t1) >> 10;
; 2492 :          v[40] = (x2-t1) >> 10;
; 2493 :          v[24] = (x3+t0) >> 10;
; 2494 :          v[32] = (x3-t0) >> 10;
; 2495 :       }
; 2496 :    }
; 2497 : 
; 2498 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
; 2499 :       // no fast case since the first 1D IDCT spread components out
; 2500 :       STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
; 2501 :       // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2502 :       // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2503 :       // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2504 :       // so we want to round that, which means adding 0.5 * 1<<17,
; 2505 :       // aka 65536. Also, we'll end up with -128 to 127 that we want
; 2506 :       // to encode as 0..255 by adding 128, so we'll add that before the shift
; 2507 :       x0 += 65536 + (128<<17);
; 2508 :       x1 += 65536 + (128<<17);
; 2509 :       x2 += 65536 + (128<<17);
; 2510 :       x3 += 65536 + (128<<17);
; 2511 :       // tried computing the shifts into temps, or'ing the temps to see
; 2512 :       // if any were out of range, but that was slower
; 2513 :       o[0] = stbi__clamp((x0+t3) >> 17);
; 2514 :       o[7] = stbi__clamp((x0-t3) >> 17);
; 2515 :       o[1] = stbi__clamp((x1+t2) >> 17);
; 2516 :       o[6] = stbi__clamp((x1-t2) >> 17);
; 2517 :       o[2] = stbi__clamp((x2+t1) >> 17);
; 2518 :       o[5] = stbi__clamp((x2-t1) >> 17);
; 2519 :       o[3] = stbi__clamp((x3+t0) >> 17);
; 2520 :       o[4] = stbi__clamp((x3-t0) >> 17);
; 2521 :    }
; 2522 : }
; 2523 : 
; 2524 : #ifdef STBI_SSE2
; 2525 : // sse2 integer IDCT. not the fastest possible implementation but it
; 2526 : // produces bit-identical results to the generic C version so it's
; 2527 : // fully "transparent".
; 2528 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2529 : {
; 2530 :    // This is constructed to match our regular (generic) integer IDCT exactly.
; 2531 :    __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2532 :    __m128i tmp;
; 2533 : 
; 2534 :    // dot product constant: even elems=x, odd elems=y
; 2535 :    #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2536 : 
; 2537 :    // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2538 :    // out(1) = c1[even]*x + c1[odd]*y
; 2539 :    #define dct_rot(out0,out1, x,y,c0,c1) \
; 2540 :       __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2541 :       __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2542 :       __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2543 :       __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2544 :       __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2545 :       __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2546 : 
; 2547 :    // out = in << 12  (in 16-bit, out 32-bit)
; 2548 :    #define dct_widen(out, in) \
; 2549 :       __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2550 :       __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2551 : 
; 2552 :    // wide add
; 2553 :    #define dct_wadd(out, a, b) \
; 2554 :       __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2555 :       __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2556 : 
; 2557 :    // wide sub
; 2558 :    #define dct_wsub(out, a, b) \
; 2559 :       __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2560 :       __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2561 : 
; 2562 :    // butterfly a/b, add bias, then shift by "s" and pack
; 2563 :    #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2564 :       { \
; 2565 :          __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2566 :          __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2567 :          dct_wadd(sum, abiased, b); \
; 2568 :          dct_wsub(dif, abiased, b); \
; 2569 :          out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2570 :          out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2571 :       }
; 2572 : 
; 2573 :    // 8-bit interleave step (for transposes)
; 2574 :    #define dct_interleave8(a, b) \
; 2575 :       tmp = a; \
; 2576 :       a = _mm_unpacklo_epi8(a, b); \
; 2577 :       b = _mm_unpackhi_epi8(tmp, b)
; 2578 : 
; 2579 :    // 16-bit interleave step (for transposes)
; 2580 :    #define dct_interleave16(a, b) \
; 2581 :       tmp = a; \
; 2582 :       a = _mm_unpacklo_epi16(a, b); \
; 2583 :       b = _mm_unpackhi_epi16(tmp, b)
; 2584 : 
; 2585 :    #define dct_pass(bias,shift) \
; 2586 :       { \
; 2587 :          /* even part */ \
; 2588 :          dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2589 :          __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2590 :          __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2591 :          dct_widen(t0e, sum04); \
; 2592 :          dct_widen(t1e, dif04); \
; 2593 :          dct_wadd(x0, t0e, t3e); \
; 2594 :          dct_wsub(x3, t0e, t3e); \
; 2595 :          dct_wadd(x1, t1e, t2e); \
; 2596 :          dct_wsub(x2, t1e, t2e); \
; 2597 :          /* odd part */ \
; 2598 :          dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2599 :          dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2600 :          __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2601 :          __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2602 :          dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2603 :          dct_wadd(x4, y0o, y4o); \
; 2604 :          dct_wadd(x5, y1o, y5o); \
; 2605 :          dct_wadd(x6, y2o, y5o); \
; 2606 :          dct_wadd(x7, y3o, y4o); \
; 2607 :          dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2608 :          dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2609 :          dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2610 :          dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2611 :       }
; 2612 : 
; 2613 :    __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
; 2614 :    __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
; 2615 :    __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
; 2616 :    __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
; 2617 :    __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
; 2618 :    __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
; 2619 :    __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
; 2620 :    __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
; 2621 : 
; 2622 :    // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2623 :    __m128i bias_0 = _mm_set1_epi32(512);
; 2624 :    __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
; 2625 : 
; 2626 :    // load
; 2627 :    row0 = _mm_load_si128((const __m128i *) (data + 0*8));
; 2628 :    row1 = _mm_load_si128((const __m128i *) (data + 1*8));
; 2629 :    row2 = _mm_load_si128((const __m128i *) (data + 2*8));
; 2630 :    row3 = _mm_load_si128((const __m128i *) (data + 3*8));
; 2631 :    row4 = _mm_load_si128((const __m128i *) (data + 4*8));
; 2632 :    row5 = _mm_load_si128((const __m128i *) (data + 5*8));
; 2633 :    row6 = _mm_load_si128((const __m128i *) (data + 6*8));
; 2634 :    row7 = _mm_load_si128((const __m128i *) (data + 7*8));
; 2635 : 
; 2636 :    // column pass
; 2637 :    dct_pass(bias_0, 10);
; 2638 : 
; 2639 :    {
; 2640 :       // 16bit 8x8 transpose pass 1
; 2641 :       dct_interleave16(row0, row4);
; 2642 :       dct_interleave16(row1, row5);
; 2643 :       dct_interleave16(row2, row6);
; 2644 :       dct_interleave16(row3, row7);
; 2645 : 
; 2646 :       // transpose pass 2
; 2647 :       dct_interleave16(row0, row2);
; 2648 :       dct_interleave16(row1, row3);
; 2649 :       dct_interleave16(row4, row6);
; 2650 :       dct_interleave16(row5, row7);
; 2651 : 
; 2652 :       // transpose pass 3
; 2653 :       dct_interleave16(row0, row1);
; 2654 :       dct_interleave16(row2, row3);
; 2655 :       dct_interleave16(row4, row5);
; 2656 :       dct_interleave16(row6, row7);
; 2657 :    }
; 2658 : 
; 2659 :    // row pass
; 2660 :    dct_pass(bias_1, 17);
; 2661 : 
; 2662 :    {
; 2663 :       // pack
; 2664 :       __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
; 2665 :       __m128i p1 = _mm_packus_epi16(row2, row3);
; 2666 :       __m128i p2 = _mm_packus_epi16(row4, row5);
; 2667 :       __m128i p3 = _mm_packus_epi16(row6, row7);
; 2668 : 
; 2669 :       // 8bit 8x8 transpose pass 1
; 2670 :       dct_interleave8(p0, p2); // a0e0a1e1...
; 2671 :       dct_interleave8(p1, p3); // c0g0c1g1...
; 2672 : 
; 2673 :       // transpose pass 2
; 2674 :       dct_interleave8(p0, p1); // a0c0e0g0...
; 2675 :       dct_interleave8(p2, p3); // b0d0f0h0...
; 2676 : 
; 2677 :       // transpose pass 3
; 2678 :       dct_interleave8(p0, p2); // a0b0c0d0...
; 2679 :       dct_interleave8(p1, p3); // a4b4c4d4...
; 2680 : 
; 2681 :       // store
; 2682 :       _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
; 2683 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
; 2684 :       _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
; 2685 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
; 2686 :       _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
; 2687 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
; 2688 :       _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
; 2689 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
; 2690 :    }
; 2691 : 
; 2692 : #undef dct_const
; 2693 : #undef dct_rot
; 2694 : #undef dct_widen
; 2695 : #undef dct_wadd
; 2696 : #undef dct_wsub
; 2697 : #undef dct_bfly32o
; 2698 : #undef dct_interleave8
; 2699 : #undef dct_interleave16
; 2700 : #undef dct_pass
; 2701 : }
; 2702 : 
; 2703 : #endif // STBI_SSE2
; 2704 : 
; 2705 : #ifdef STBI_NEON
; 2706 : 
; 2707 : // NEON integer IDCT. should produce bit-identical
; 2708 : // results to the generic C version.
; 2709 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2710 : {
; 2711 :    int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;
; 2712 : 
; 2713 :    int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
; 2714 :    int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
; 2715 :    int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
; 2716 :    int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
; 2717 :    int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
; 2718 :    int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
; 2719 :    int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
; 2720 :    int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
; 2721 :    int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
; 2722 :    int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
; 2723 :    int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
; 2724 :    int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));
; 2725 : 
; 2726 : #define dct_long_mul(out, inq, coeff) \
; 2727 :    int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
; 2728 :    int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)
; 2729 : 
; 2730 : #define dct_long_mac(out, acc, inq, coeff) \
; 2731 :    int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
; 2732 :    int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)
; 2733 : 
; 2734 : #define dct_widen(out, inq) \
; 2735 :    int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
; 2736 :    int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)
; 2737 : 
; 2738 : // wide add
; 2739 : #define dct_wadd(out, a, b) \
; 2740 :    int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
; 2741 :    int32x4_t out##_h = vaddq_s32(a##_h, b##_h)
; 2742 : 
; 2743 : // wide sub
; 2744 : #define dct_wsub(out, a, b) \
; 2745 :    int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
; 2746 :    int32x4_t out##_h = vsubq_s32(a##_h, b##_h)
; 2747 : 
; 2748 : // butterfly a/b, then shift using "shiftop" by "s" and pack
; 2749 : #define dct_bfly32o(out0,out1, a,b,shiftop,s) \
; 2750 :    { \
; 2751 :       dct_wadd(sum, a, b); \
; 2752 :       dct_wsub(dif, a, b); \
; 2753 :       out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
; 2754 :       out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
; 2755 :    }
; 2756 : 
; 2757 : #define dct_pass(shiftop, shift) \
; 2758 :    { \
; 2759 :       /* even part */ \
; 2760 :       int16x8_t sum26 = vaddq_s16(row2, row6); \
; 2761 :       dct_long_mul(p1e, sum26, rot0_0); \
; 2762 :       dct_long_mac(t2e, p1e, row6, rot0_1); \
; 2763 :       dct_long_mac(t3e, p1e, row2, rot0_2); \
; 2764 :       int16x8_t sum04 = vaddq_s16(row0, row4); \
; 2765 :       int16x8_t dif04 = vsubq_s16(row0, row4); \
; 2766 :       dct_widen(t0e, sum04); \
; 2767 :       dct_widen(t1e, dif04); \
; 2768 :       dct_wadd(x0, t0e, t3e); \
; 2769 :       dct_wsub(x3, t0e, t3e); \
; 2770 :       dct_wadd(x1, t1e, t2e); \
; 2771 :       dct_wsub(x2, t1e, t2e); \
; 2772 :       /* odd part */ \
; 2773 :       int16x8_t sum15 = vaddq_s16(row1, row5); \
; 2774 :       int16x8_t sum17 = vaddq_s16(row1, row7); \
; 2775 :       int16x8_t sum35 = vaddq_s16(row3, row5); \
; 2776 :       int16x8_t sum37 = vaddq_s16(row3, row7); \
; 2777 :       int16x8_t sumodd = vaddq_s16(sum17, sum35); \
; 2778 :       dct_long_mul(p5o, sumodd, rot1_0); \
; 2779 :       dct_long_mac(p1o, p5o, sum17, rot1_1); \
; 2780 :       dct_long_mac(p2o, p5o, sum35, rot1_2); \
; 2781 :       dct_long_mul(p3o, sum37, rot2_0); \
; 2782 :       dct_long_mul(p4o, sum15, rot2_1); \
; 2783 :       dct_wadd(sump13o, p1o, p3o); \
; 2784 :       dct_wadd(sump24o, p2o, p4o); \
; 2785 :       dct_wadd(sump23o, p2o, p3o); \
; 2786 :       dct_wadd(sump14o, p1o, p4o); \
; 2787 :       dct_long_mac(x4, sump13o, row7, rot3_0); \
; 2788 :       dct_long_mac(x5, sump24o, row5, rot3_1); \
; 2789 :       dct_long_mac(x6, sump23o, row3, rot3_2); \
; 2790 :       dct_long_mac(x7, sump14o, row1, rot3_3); \
; 2791 :       dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
; 2792 :       dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
; 2793 :       dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
; 2794 :       dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
; 2795 :    }
; 2796 : 
; 2797 :    // load
; 2798 :    row0 = vld1q_s16(data + 0*8);
; 2799 :    row1 = vld1q_s16(data + 1*8);
; 2800 :    row2 = vld1q_s16(data + 2*8);
; 2801 :    row3 = vld1q_s16(data + 3*8);
; 2802 :    row4 = vld1q_s16(data + 4*8);
; 2803 :    row5 = vld1q_s16(data + 5*8);
; 2804 :    row6 = vld1q_s16(data + 6*8);
; 2805 :    row7 = vld1q_s16(data + 7*8);
; 2806 : 
; 2807 :    // add DC bias
; 2808 :    row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));
; 2809 : 
; 2810 :    // column pass
; 2811 :    dct_pass(vrshrn_n_s32, 10);
; 2812 : 
; 2813 :    // 16bit 8x8 transpose
; 2814 :    {
; 2815 : // these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
; 2816 : // whether compilers actually get this is another story, sadly.
; 2817 : #define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
; 2818 : #define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
; 2819 : #define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }
; 2820 : 
; 2821 :       // pass 1
; 2822 :       dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
; 2823 :       dct_trn16(row2, row3);
; 2824 :       dct_trn16(row4, row5);
; 2825 :       dct_trn16(row6, row7);
; 2826 : 
; 2827 :       // pass 2
; 2828 :       dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
; 2829 :       dct_trn32(row1, row3);
; 2830 :       dct_trn32(row4, row6);
; 2831 :       dct_trn32(row5, row7);
; 2832 : 
; 2833 :       // pass 3
; 2834 :       dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
; 2835 :       dct_trn64(row1, row5);
; 2836 :       dct_trn64(row2, row6);
; 2837 :       dct_trn64(row3, row7);
; 2838 : 
; 2839 : #undef dct_trn16
; 2840 : #undef dct_trn32
; 2841 : #undef dct_trn64
; 2842 :    }
; 2843 : 
; 2844 :    // row pass
; 2845 :    // vrshrn_n_s32 only supports shifts up to 16, we need
; 2846 :    // 17. so do a non-rounding shift of 16 first then follow
; 2847 :    // up with a rounding shift by 1.
; 2848 :    dct_pass(vshrn_n_s32, 16);
; 2849 : 
; 2850 :    {
; 2851 :       // pack and round
; 2852 :       uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
; 2853 :       uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
; 2854 :       uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
; 2855 :       uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
; 2856 :       uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
; 2857 :       uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
; 2858 :       uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
; 2859 :       uint8x8_t p7 = vqrshrun_n_s16(row7, 1);
; 2860 : 
; 2861 :       // again, these can translate into one instruction, but often don't.
; 2862 : #define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
; 2863 : #define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
; 2864 : #define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }
; 2865 : 
; 2866 :       // sadly can't use interleaved stores here since we only write
; 2867 :       // 8 bytes to each scan line!
; 2868 : 
; 2869 :       // 8x8 8-bit transpose pass 1
; 2870 :       dct_trn8_8(p0, p1);
; 2871 :       dct_trn8_8(p2, p3);
; 2872 :       dct_trn8_8(p4, p5);
; 2873 :       dct_trn8_8(p6, p7);
; 2874 : 
; 2875 :       // pass 2
; 2876 :       dct_trn8_16(p0, p2);
; 2877 :       dct_trn8_16(p1, p3);
; 2878 :       dct_trn8_16(p4, p6);
; 2879 :       dct_trn8_16(p5, p7);
; 2880 : 
; 2881 :       // pass 3
; 2882 :       dct_trn8_32(p0, p4);
; 2883 :       dct_trn8_32(p1, p5);
; 2884 :       dct_trn8_32(p2, p6);
; 2885 :       dct_trn8_32(p3, p7);
; 2886 : 
; 2887 :       // store
; 2888 :       vst1_u8(out, p0); out += out_stride;
; 2889 :       vst1_u8(out, p1); out += out_stride;
; 2890 :       vst1_u8(out, p2); out += out_stride;
; 2891 :       vst1_u8(out, p3); out += out_stride;
; 2892 :       vst1_u8(out, p4); out += out_stride;
; 2893 :       vst1_u8(out, p5); out += out_stride;
; 2894 :       vst1_u8(out, p6); out += out_stride;
; 2895 :       vst1_u8(out, p7);
; 2896 : 
; 2897 : #undef dct_trn8_8
; 2898 : #undef dct_trn8_16
; 2899 : #undef dct_trn8_32
; 2900 :    }
; 2901 : 
; 2902 : #undef dct_long_mul
; 2903 : #undef dct_long_mac
; 2904 : #undef dct_widen
; 2905 : #undef dct_wadd
; 2906 : #undef dct_wsub
; 2907 : #undef dct_bfly32o
; 2908 : #undef dct_pass
; 2909 : }
; 2910 : 
; 2911 : #endif // STBI_NEON
; 2912 : 
; 2913 : #define STBI__MARKER_none  0xff
; 2914 : // if there's a pending marker from the entropy stream, return that
; 2915 : // otherwise, fetch from the stream and get a marker. if there's no
; 2916 : // marker, return 0xff, which is never a valid marker value
; 2917 : static stbi_uc stbi__get_marker(stbi__jpeg *j)
; 2918 : {
; 2919 :    stbi_uc x;
; 2920 :    if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
; 2921 :    x = stbi__get8(j->s);
; 2922 :    if (x != 0xff) return STBI__MARKER_none;
; 2923 :    while (x == 0xff)
; 2924 :       x = stbi__get8(j->s); // consume repeated 0xff fill bytes
; 2925 :    return x;
; 2926 : }
; 2927 : 
; 2928 : // in each scan, we'll have scan_n components, and the order
; 2929 : // of the components is specified by order[]
; 2930 : #define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
; 2931 : 
; 2932 : // after a restart interval, stbi__jpeg_reset the entropy decoder and
; 2933 : // the dc prediction
; 2934 : static void stbi__jpeg_reset(stbi__jpeg *j)
; 2935 : {
; 2936 :    j->code_bits = 0;
; 2937 :    j->code_buffer = 0;
; 2938 :    j->nomore = 0;
; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
; 2940 :    j->marker = STBI__MARKER_none;
; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
; 2942 :    j->eob_run = 0;
; 2943 :    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2944 :    // since we don't even allow 1<<30 pixels
; 2945 : }
; 2946 : 
; 2947 : static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
; 2948 : {
; 2949 :    stbi__jpeg_reset(z);
; 2950 :    if (!z->progressive) {
; 2951 :       if (z->scan_n == 1) {
; 2952 :          int i,j;
; 2953 :          STBI_SIMD_ALIGN(short, data[64]);
; 2954 :          int n = z->order[0];
; 2955 :          // non-interleaved data, we just need to process one block at a time,
; 2956 :          // in trivial scanline order
; 2957 :          // number of blocks to do just depends on how many actual "pixels" this
; 2958 :          // component has, independent of interleaved MCU blocking and such
; 2959 :          int w = (z->img_comp[n].x+7) >> 3;
; 2960 :          int h = (z->img_comp[n].y+7) >> 3;
; 2961 :          for (j=0; j < h; ++j) {
; 2962 :             for (i=0; i < w; ++i) {
; 2963 :                int ha = z->img_comp[n].ha;
; 2964 :                if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2965 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 2966 :                // every data block is an MCU, so countdown the restart interval
; 2967 :                if (--z->todo <= 0) {
; 2968 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 2969 :                   // if it's NOT a restart, then just bail, so we get corrupt data
; 2970 :                   // rather than no data
; 2971 :                   if (!STBI__RESTART(z->marker)) return 1;
; 2972 :                   stbi__jpeg_reset(z);
; 2973 :                }
; 2974 :             }
; 2975 :          }
; 2976 :          return 1;
; 2977 :       } else { // interleaved
; 2978 :          int i,j,k,x,y;
; 2979 :          STBI_SIMD_ALIGN(short, data[64]);
; 2980 :          for (j=0; j < z->img_mcu_y; ++j) {
; 2981 :             for (i=0; i < z->img_mcu_x; ++i) {
; 2982 :                // scan an interleaved mcu... process scan_n components in order
; 2983 :                for (k=0; k < z->scan_n; ++k) {
; 2984 :                   int n = z->order[k];
; 2985 :                   // scan out an mcu's worth of this component; that's just determined
; 2986 :                   // by the basic H and V specified for the component
; 2987 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 2988 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 2989 :                         int x2 = (i*z->img_comp[n].h + x)*8;
; 2990 :                         int y2 = (j*z->img_comp[n].v + y)*8;
; 2991 :                         int ha = z->img_comp[n].ha;
; 2992 :                         if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2993 :                         z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
; 2994 :                      }
; 2995 :                   }
; 2996 :                }
; 2997 :                // after all interleaved components, that's an interleaved MCU,
; 2998 :                // so now count down the restart interval
; 2999 :                if (--z->todo <= 0) {
; 3000 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3001 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3002 :                   stbi__jpeg_reset(z);
; 3003 :                }
; 3004 :             }
; 3005 :          }
; 3006 :          return 1;
; 3007 :       }
; 3008 :    } else {
; 3009 :       if (z->scan_n == 1) {
; 3010 :          int i,j;
; 3011 :          int n = z->order[0];
; 3012 :          // non-interleaved data, we just need to process one block at a time,
; 3013 :          // in trivial scanline order
; 3014 :          // number of blocks to do just depends on how many actual "pixels" this
; 3015 :          // component has, independent of interleaved MCU blocking and such
; 3016 :          int w = (z->img_comp[n].x+7) >> 3;
; 3017 :          int h = (z->img_comp[n].y+7) >> 3;
; 3018 :          for (j=0; j < h; ++j) {
; 3019 :             for (i=0; i < w; ++i) {
; 3020 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3021 :                if (z->spec_start == 0) {
; 3022 :                   if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3023 :                      return 0;
; 3024 :                } else {
; 3025 :                   int ha = z->img_comp[n].ha;
; 3026 :                   if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
; 3027 :                      return 0;
; 3028 :                }
; 3029 :                // every data block is an MCU, so countdown the restart interval
; 3030 :                if (--z->todo <= 0) {
; 3031 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3032 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3033 :                   stbi__jpeg_reset(z);
; 3034 :                }
; 3035 :             }
; 3036 :          }
; 3037 :          return 1;
; 3038 :       } else { // interleaved
; 3039 :          int i,j,k,x,y;
; 3040 :          for (j=0; j < z->img_mcu_y; ++j) {
; 3041 :             for (i=0; i < z->img_mcu_x; ++i) {
; 3042 :                // scan an interleaved mcu... process scan_n components in order
; 3043 :                for (k=0; k < z->scan_n; ++k) {
; 3044 :                   int n = z->order[k];
; 3045 :                   // scan out an mcu's worth of this component; that's just determined
; 3046 :                   // by the basic H and V specified for the component
; 3047 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 3048 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 3049 :                         int x2 = (i*z->img_comp[n].h + x);
; 3050 :                         int y2 = (j*z->img_comp[n].v + y);
; 3051 :                         short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
; 3052 :                         if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3053 :                            return 0;
; 3054 :                      }
; 3055 :                   }
; 3056 :                }
; 3057 :                // after all interleaved components, that's an interleaved MCU,
; 3058 :                // so now count down the restart interval
; 3059 :                if (--z->todo <= 0) {
; 3060 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3061 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3062 :                   stbi__jpeg_reset(z);
; 3063 :                }
; 3064 :             }
; 3065 :          }
; 3066 :          return 1;
; 3067 :       }
; 3068 :    }
; 3069 : }
; 3070 : 
; 3071 : static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
; 3072 : {
; 3073 :    int i;
; 3074 :    for (i=0; i < 64; ++i)
; 3075 :       data[i] *= dequant[i];
; 3076 : }
; 3077 : 
; 3078 : static void stbi__jpeg_finish(stbi__jpeg *z)
; 3079 : {
; 3080 :    if (z->progressive) {
; 3081 :       // dequantize and idct the data
; 3082 :       int i,j,n;
; 3083 :       for (n=0; n < z->s->img_n; ++n) {
; 3084 :          int w = (z->img_comp[n].x+7) >> 3;
; 3085 :          int h = (z->img_comp[n].y+7) >> 3;
; 3086 :          for (j=0; j < h; ++j) {
; 3087 :             for (i=0; i < w; ++i) {
; 3088 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3089 :                stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
; 3090 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 3091 :             }
; 3092 :          }
; 3093 :       }
; 3094 :    }
; 3095 : }
; 3096 : 
; 3097 : static int stbi__process_marker(stbi__jpeg *z, int m)
; 3098 : {
; 3099 :    int L;
; 3100 :    switch (m) {
; 3101 :       case STBI__MARKER_none: // no marker found
; 3102 :          return stbi__err("expected marker","Corrupt JPEG");
; 3103 : 
; 3104 :       case 0xDD: // DRI - specify restart interval
; 3105 :          if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
; 3106 :          z->restart_interval = stbi__get16be(z->s);
; 3107 :          return 1;
; 3108 : 
; 3109 :       case 0xDB: // DQT - define quantization table
; 3110 :          L = stbi__get16be(z->s)-2;
; 3111 :          while (L > 0) {
; 3112 :             int q = stbi__get8(z->s);
; 3113 :             int p = q >> 4, sixteen = (p != 0);
; 3114 :             int t = q & 15,i;
; 3115 :             if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
; 3116 :             if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");
; 3117 : 
; 3118 :             for (i=0; i < 64; ++i)
; 3119 :                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
; 3120 :             L -= (sixteen ? 129 : 65);
; 3121 :          }
; 3122 :          return L==0;
; 3123 : 
; 3124 :       case 0xC4: // DHT - define huffman table
; 3125 :          L = stbi__get16be(z->s)-2;
; 3126 :          while (L > 0) {
; 3127 :             stbi_uc *v;
; 3128 :             int sizes[16],i,n=0;
; 3129 :             int q = stbi__get8(z->s);
; 3130 :             int tc = q >> 4;
; 3131 :             int th = q & 15;
; 3132 :             if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
; 3133 :             for (i=0; i < 16; ++i) {
; 3134 :                sizes[i] = stbi__get8(z->s);
; 3135 :                n += sizes[i];
; 3136 :             }
; 3137 :             if(n > 256) return stbi__err("bad DHT header","Corrupt JPEG"); // Loop over i < n would write past end of values!
; 3138 :             L -= 17;
; 3139 :             if (tc == 0) {
; 3140 :                if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
; 3141 :                v = z->huff_dc[th].values;
; 3142 :             } else {
; 3143 :                if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
; 3144 :                v = z->huff_ac[th].values;
; 3145 :             }
; 3146 :             for (i=0; i < n; ++i)
; 3147 :                v[i] = stbi__get8(z->s);
; 3148 :             if (tc != 0)
; 3149 :                stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
; 3150 :             L -= n;
; 3151 :          }
; 3152 :          return L==0;
; 3153 :    }
; 3154 : 
; 3155 :    // check for comment block or APP blocks
; 3156 :    if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
; 3157 :       L = stbi__get16be(z->s);
; 3158 :       if (L < 2) {
; 3159 :          if (m == 0xFE)
; 3160 :             return stbi__err("bad COM len","Corrupt JPEG");
; 3161 :          else
; 3162 :             return stbi__err("bad APP len","Corrupt JPEG");
; 3163 :       }
; 3164 :       L -= 2;
; 3165 : 
; 3166 :       if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
; 3167 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3168 :          int ok = 1;
; 3169 :          int i;
; 3170 :          for (i=0; i < 5; ++i)
; 3171 :             if (stbi__get8(z->s) != tag[i])
; 3172 :                ok = 0;
; 3173 :          L -= 5;
; 3174 :          if (ok)
; 3175 :             z->jfif = 1;
; 3176 :       } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;
; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)
; 3181 :             if (stbi__get8(z->s) != tag[i])
; 3182 :                ok = 0;
; 3183 :          L -= 6;
; 3184 :          if (ok) {
; 3185 :             stbi__get8(z->s); // version
; 3186 :             stbi__get16be(z->s); // flags0
; 3187 :             stbi__get16be(z->s); // flags1
; 3188 :             z->app14_color_transform = stbi__get8(z->s); // color transform
; 3189 :             L -= 6;
; 3190 :          }
; 3191 :       }
; 3192 : 
; 3193 :       stbi__skip(z->s, L);
; 3194 :       return 1;
; 3195 :    }
; 3196 : 
; 3197 :    return stbi__err("unknown marker","Corrupt JPEG");
; 3198 : }
; 3199 : 
; 3200 : // after we see SOS
; 3201 : static int stbi__process_scan_header(stbi__jpeg *z)
; 3202 : {
; 3203 :    int i;
; 3204 :    int Ls = stbi__get16be(z->s);
; 3205 :    z->scan_n = stbi__get8(z->s);
; 3206 :    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
; 3207 :    if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
; 3208 :    for (i=0; i < z->scan_n; ++i) {
; 3209 :       int id = stbi__get8(z->s), which;
; 3210 :       int q = stbi__get8(z->s);
; 3211 :       for (which = 0; which < z->s->img_n; ++which)
; 3212 :          if (z->img_comp[which].id == id)
; 3213 :             break;
; 3214 :       if (which == z->s->img_n) return 0; // no match
; 3215 :       z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
; 3216 :       z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
; 3217 :       z->order[i] = which;
; 3218 :    }
; 3219 : 
; 3220 :    {
; 3221 :       int aa;
; 3222 :       z->spec_start = stbi__get8(z->s);
; 3223 :       z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
; 3224 :       aa = stbi__get8(z->s);
; 3225 :       z->succ_high = (aa >> 4);
; 3226 :       z->succ_low  = (aa & 15);
; 3227 :       if (z->progressive) {
; 3228 :          if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
; 3229 :             return stbi__err("bad SOS", "Corrupt JPEG");
; 3230 :       } else {
; 3231 :          if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3232 :          if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3233 :          z->spec_end = 63;
; 3234 :       }
; 3235 :    }
; 3236 : 
; 3237 :    return 1;
; 3238 : }
; 3239 : 
; 3240 : static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
; 3241 : {
; 3242 :    int i;
; 3243 :    for (i=0; i < ncomp; ++i) {

	add	rbx, 96					; 00000060H
	sub	rsi, 1
	jne	SHORT $LL118@load_jpeg_
$LN117@load_jpeg_:

; 3981 :                }
; 3982 :          } else {
; 3983 :             if (is_rgb) {
; 3984 :                if (n == 1)
; 3985 :                   for (i=0; i < z->s->img_x; ++i)
; 3986 :                      *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
; 3987 :                else {
; 3988 :                   for (i=0; i < z->s->img_x; ++i, out += 2) {
; 3989 :                      out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
; 3990 :                      out[1] = 255;
; 3991 :                   }
; 3992 :                }
; 3993 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
; 3994 :                for (i=0; i < z->s->img_x; ++i) {
; 3995 :                   stbi_uc m = coutput[3][i];
; 3996 :                   stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
; 3997 :                   stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
; 3998 :                   stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
; 3999 :                   out[0] = stbi__compute_y(r, g, b);
; 4000 :                   out[1] = 255;
; 4001 :                   out += n;
; 4002 :                }
; 4003 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
; 4004 :                for (i=0; i < z->s->img_x; ++i) {
; 4005 :                   out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
; 4006 :                   out[1] = 255;
; 4007 :                   out += n;
; 4008 :                }
; 4009 :             } else {
; 4010 :                stbi_uc *y = coutput[0];
; 4011 :                if (n == 1)
; 4012 :                   for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
; 4013 :                else
; 4014 :                   for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
; 4015 :             }
; 4016 :          }
; 4017 :       }
; 4018 :       stbi__cleanup_jpeg(z);
; 4019 :       *out_x = z->s->img_x;

	mov	rax, QWORD PTR [rdi]
	mov	ecx, DWORD PTR [rax]
	mov	rax, QWORD PTR out_x$GSCopy$1$[rsp]
	mov	DWORD PTR [rax], ecx

; 4020 :       *out_y = z->s->img_y;

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR out_y$GSCopy$1$[rsp]
	mov	edx, DWORD PTR [rcx+4]
	mov	DWORD PTR [rax], edx

; 4021 :       if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output

	test	r15, r15
	je	SHORT $LN81@load_jpeg_
	mov	rcx, QWORD PTR [rdi]
	mov	eax, 3
	cmp	DWORD PTR [rcx+8], eax
	cmovge	r14d, eax
	mov	DWORD PTR [r15], r14d
$LN81@load_jpeg_:

; 4022 :       return output;

	mov	rax, r13
	jmp	SHORT $LN372@load_jpeg_
$LN306@load_jpeg_:

; 1055 :    if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;

	mov	rcx, QWORD PTR [rdi]
$LN305@load_jpeg_:

; 3243 :    for (i=0; i < ncomp; ++i) {

	movsxd	rbx, DWORD PTR [rcx+8]
	test	rbx, rbx
	jle	SHORT $LN171@load_jpeg_
	add	rdi, 18136				; 000046d8H
	npad	5
$LL172@load_jpeg_:

; 3244 :       if (z->img_comp[i].raw_data) {

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN173@load_jpeg_

; 3245 :          STBI_FREE(z->img_comp[i].raw_data);

	call	QWORD PTR __imp_free

; 3246 :          z->img_comp[i].raw_data = NULL;

	mov	QWORD PTR [rdi], rbp

; 3247 :          z->img_comp[i].data = NULL;

	mov	QWORD PTR [rdi-8], rbp
$LN173@load_jpeg_:

; 3248 :       }
; 3249 :       if (z->img_comp[i].raw_coeff) {

	mov	rcx, QWORD PTR [rdi+8]
	test	rcx, rcx
	je	SHORT $LN174@load_jpeg_

; 3250 :          STBI_FREE(z->img_comp[i].raw_coeff);

	call	QWORD PTR __imp_free

; 3251 :          z->img_comp[i].raw_coeff = 0;

	mov	QWORD PTR [rdi+8], rbp

; 3252 :          z->img_comp[i].coeff = 0;

	mov	QWORD PTR [rdi+24], rbp
$LN174@load_jpeg_:

; 3253 :       }
; 3254 :       if (z->img_comp[i].linebuf) {

	mov	rcx, QWORD PTR [rdi+16]
	test	rcx, rcx
	je	SHORT $LN170@load_jpeg_

; 3255 :          STBI_FREE(z->img_comp[i].linebuf);

	call	QWORD PTR __imp_free

; 3256 :          z->img_comp[i].linebuf = NULL;

	mov	QWORD PTR [rdi+16], rbp
$LN170@load_jpeg_:

; 1057 : }
; 1058 : 
; 1059 : #if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
; 1060 : static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
; 1061 : {
; 1062 :    if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
; 1063 :    return stbi__malloc(a*b*c*d + add);
; 1064 : }
; 1065 : #endif
; 1066 : 
; 1067 : // returns 1 if the sum of two signed ints is valid (between -2^31 and 2^31-1 inclusive), 0 on overflow.
; 1068 : static int stbi__addints_valid(int a, int b)
; 1069 : {
; 1070 :    if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow
; 1071 :    if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.
; 1072 :    return a <= INT_MAX - b;
; 1073 : }
; 1074 : 
; 1075 : // returns 1 if the product of two signed shorts is valid, 0 on overflow.
; 1076 : static int stbi__mul2shorts_valid(short a, short b)
; 1077 : {
; 1078 :    if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow
; 1079 :    if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX/b; // product is positive, so similar to mul2sizes_valid
; 1080 :    if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN
; 1081 :    return a >= SHRT_MIN / b;
; 1082 : }
; 1083 : 
; 1084 : // stbi__err - error
; 1085 : // stbi__errpf - error returning pointer to float
; 1086 : // stbi__errpuc - error returning pointer to unsigned char
; 1087 : 
; 1088 : #ifdef STBI_NO_FAILURE_STRINGS
; 1089 :    #define stbi__err(x,y)  0
; 1090 : #elif defined(STBI_FAILURE_USERMSG)
; 1091 :    #define stbi__err(x,y)  stbi__err(y)
; 1092 : #else
; 1093 :    #define stbi__err(x,y)  stbi__err(x)
; 1094 : #endif
; 1095 : 
; 1096 : #define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
; 1097 : #define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))
; 1098 : 
; 1099 : STBIDEF void stbi_image_free(void *retval_from_stbi_load)
; 1100 : {
; 1101 :    STBI_FREE(retval_from_stbi_load);
; 1102 : }
; 1103 : 
; 1104 : #ifndef STBI_NO_LINEAR
; 1105 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
; 1106 : #endif
; 1107 : 
; 1108 : #ifndef STBI_NO_HDR
; 1109 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
; 1110 : #endif
; 1111 : 
; 1112 : static int stbi__vertically_flip_on_load_global = 0;
; 1113 : 
; 1114 : STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
; 1115 : {
; 1116 :    stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
; 1117 : }
; 1118 : 
; 1119 : #ifndef STBI_THREAD_LOCAL
; 1120 : #define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global
; 1121 : #else
; 1122 : static STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;
; 1123 : 
; 1124 : STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
; 1125 : {
; 1126 :    stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
; 1127 :    stbi__vertically_flip_on_load_set = 1;
; 1128 : }
; 1129 : 
; 1130 : #define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \
; 1131 :                                          ? stbi__vertically_flip_on_load_local  \
; 1132 :                                          : stbi__vertically_flip_on_load_global)
; 1133 : #endif // STBI_THREAD_LOCAL
; 1134 : 
; 1135 : static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
; 1136 : {
; 1137 :    memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
; 1138 :    ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
; 1139 :    ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
; 1140 :    ri->num_channels = 0;
; 1141 : 
; 1142 :    // test the formats with a very explicit header first (at least a FOURCC
; 1143 :    // or distinctive magic number first)
; 1144 :    #ifndef STBI_NO_PNG
; 1145 :    if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
; 1146 :    #endif
; 1147 :    #ifndef STBI_NO_BMP
; 1148 :    if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
; 1149 :    #endif
; 1150 :    #ifndef STBI_NO_GIF
; 1151 :    if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
; 1152 :    #endif
; 1153 :    #ifndef STBI_NO_PSD
; 1154 :    if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
; 1155 :    #else
; 1156 :    STBI_NOTUSED(bpc);
; 1157 :    #endif
; 1158 :    #ifndef STBI_NO_PIC
; 1159 :    if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
; 1160 :    #endif
; 1161 : 
; 1162 :    // then the formats that can end up attempting to load with just 1 or 2
; 1163 :    // bytes matching expectations; these are prone to false positives, so
; 1164 :    // try them later
; 1165 :    #ifndef STBI_NO_JPEG
; 1166 :    if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
; 1167 :    #endif
; 1168 :    #ifndef STBI_NO_PNM
; 1169 :    if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
; 1170 :    #endif
; 1171 : 
; 1172 :    #ifndef STBI_NO_HDR
; 1173 :    if (stbi__hdr_test(s)) {
; 1174 :       float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
; 1175 :       return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
; 1176 :    }
; 1177 :    #endif
; 1178 : 
; 1179 :    #ifndef STBI_NO_TGA
; 1180 :    // test tga last because it's a crappy test!
; 1181 :    if (stbi__tga_test(s))
; 1182 :       return stbi__tga_load(s,x,y,comp,req_comp, ri);
; 1183 :    #endif
; 1184 : 
; 1185 :    return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
; 1186 : }
; 1187 : 
; 1188 : static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
; 1189 : {
; 1190 :    int i;
; 1191 :    int img_len = w * h * channels;
; 1192 :    stbi_uc *reduced;
; 1193 : 
; 1194 :    reduced = (stbi_uc *) stbi__malloc(img_len);
; 1195 :    if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");
; 1196 : 
; 1197 :    for (i = 0; i < img_len; ++i)
; 1198 :       reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling
; 1199 : 
; 1200 :    STBI_FREE(orig);
; 1201 :    return reduced;
; 1202 : }
; 1203 : 
; 1204 : static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
; 1205 : {
; 1206 :    int i;
; 1207 :    int img_len = w * h * channels;
; 1208 :    stbi__uint16 *enlarged;
; 1209 : 
; 1210 :    enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
; 1211 :    if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1212 : 
; 1213 :    for (i = 0; i < img_len; ++i)
; 1214 :       enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff
; 1215 : 
; 1216 :    STBI_FREE(orig);
; 1217 :    return enlarged;
; 1218 : }
; 1219 : 
; 1220 : static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
; 1221 : {
; 1222 :    int row;
; 1223 :    size_t bytes_per_row = (size_t)w * bytes_per_pixel;
; 1224 :    stbi_uc temp[2048];
; 1225 :    stbi_uc *bytes = (stbi_uc *)image;
; 1226 : 
; 1227 :    for (row = 0; row < (h>>1); row++) {
; 1228 :       stbi_uc *row0 = bytes + row*bytes_per_row;
; 1229 :       stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
; 1230 :       // swap row0 with row1
; 1231 :       size_t bytes_left = bytes_per_row;
; 1232 :       while (bytes_left) {
; 1233 :          size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
; 1234 :          memcpy(temp, row0, bytes_copy);
; 1235 :          memcpy(row0, row1, bytes_copy);
; 1236 :          memcpy(row1, temp, bytes_copy);
; 1237 :          row0 += bytes_copy;
; 1238 :          row1 += bytes_copy;
; 1239 :          bytes_left -= bytes_copy;
; 1240 :       }
; 1241 :    }
; 1242 : }
; 1243 : 
; 1244 : #ifndef STBI_NO_GIF
; 1245 : static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
; 1246 : {
; 1247 :    int slice;
; 1248 :    int slice_size = w * h * bytes_per_pixel;
; 1249 : 
; 1250 :    stbi_uc *bytes = (stbi_uc *)image;
; 1251 :    for (slice = 0; slice < z; ++slice) {
; 1252 :       stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
; 1253 :       bytes += slice_size;
; 1254 :    }
; 1255 : }
; 1256 : #endif
; 1257 : 
; 1258 : static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
; 1259 : {
; 1260 :    stbi__result_info ri;
; 1261 :    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);
; 1262 : 
; 1263 :    if (result == NULL)
; 1264 :       return NULL;
; 1265 : 
; 1266 :    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1267 :    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
; 1268 : 
; 1269 :    if (ri.bits_per_channel != 8) {
; 1270 :       result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
; 1271 :       ri.bits_per_channel = 8;
; 1272 :    }
; 1273 : 
; 1274 :    // @TODO: move stbi__convert_format to here
; 1275 : 
; 1276 :    if (stbi__vertically_flip_on_load) {
; 1277 :       int channels = req_comp ? req_comp : *comp;
; 1278 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
; 1279 :    }
; 1280 : 
; 1281 :    return (unsigned char *) result;
; 1282 : }
; 1283 : 
; 1284 : static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
; 1285 : {
; 1286 :    stbi__result_info ri;
; 1287 :    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);
; 1288 : 
; 1289 :    if (result == NULL)
; 1290 :       return NULL;
; 1291 : 
; 1292 :    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1293 :    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
; 1294 : 
; 1295 :    if (ri.bits_per_channel != 16) {
; 1296 :       result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
; 1297 :       ri.bits_per_channel = 16;
; 1298 :    }
; 1299 : 
; 1300 :    // @TODO: move stbi__convert_format16 to here
; 1301 :    // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision
; 1302 : 
; 1303 :    if (stbi__vertically_flip_on_load) {
; 1304 :       int channels = req_comp ? req_comp : *comp;
; 1305 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
; 1306 :    }
; 1307 : 
; 1308 :    return (stbi__uint16 *) result;
; 1309 : }
; 1310 : 
; 1311 : #if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)
; 1312 : static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
; 1313 : {
; 1314 :    if (stbi__vertically_flip_on_load && result != NULL) {
; 1315 :       int channels = req_comp ? req_comp : *comp;
; 1316 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
; 1317 :    }
; 1318 : }
; 1319 : #endif
; 1320 : 
; 1321 : #ifndef STBI_NO_STDIO
; 1322 : 
; 1323 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1324 : STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
; 1325 : STBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);
; 1326 : #endif
; 1327 : 
; 1328 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1329 : STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
; 1330 : {
; 1331 : 	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
; 1332 : }
; 1333 : #endif
; 1334 : 
; 1335 : static FILE *stbi__fopen(char const *filename, char const *mode)
; 1336 : {
; 1337 :    FILE *f;
; 1338 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1339 :    wchar_t wMode[64];
; 1340 :    wchar_t wFilename[1024];
; 1341 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
; 1342 :       return 0;
; 1343 : 
; 1344 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
; 1345 :       return 0;
; 1346 : 
; 1347 : #if defined(_MSC_VER) && _MSC_VER >= 1400
; 1348 : 	if (0 != _wfopen_s(&f, wFilename, wMode))
; 1349 : 		f = 0;
; 1350 : #else
; 1351 :    f = _wfopen(wFilename, wMode);
; 1352 : #endif
; 1353 : 
; 1354 : #elif defined(_MSC_VER) && _MSC_VER >= 1400
; 1355 :    if (0 != fopen_s(&f, filename, mode))
; 1356 :       f=0;
; 1357 : #else
; 1358 :    f = fopen(filename, mode);
; 1359 : #endif
; 1360 :    return f;
; 1361 : }
; 1362 : 
; 1363 : 
; 1364 : STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
; 1365 : {
; 1366 :    FILE *f = stbi__fopen(filename, "rb");
; 1367 :    unsigned char *result;
; 1368 :    if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
; 1369 :    result = stbi_load_from_file(f,x,y,comp,req_comp);
; 1370 :    fclose(f);
; 1371 :    return result;
; 1372 : }
; 1373 : 
; 1374 : STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
; 1375 : {
; 1376 :    unsigned char *result;
; 1377 :    stbi__context s;
; 1378 :    stbi__start_file(&s,f);
; 1379 :    result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
; 1380 :    if (result) {
; 1381 :       // need to 'unget' all the characters in the IO buffer
; 1382 :       fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
; 1383 :    }
; 1384 :    return result;
; 1385 : }
; 1386 : 
; 1387 : STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
; 1388 : {
; 1389 :    stbi__uint16 *result;
; 1390 :    stbi__context s;
; 1391 :    stbi__start_file(&s,f);
; 1392 :    result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
; 1393 :    if (result) {
; 1394 :       // need to 'unget' all the characters in the IO buffer
; 1395 :       fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
; 1396 :    }
; 1397 :    return result;
; 1398 : }
; 1399 : 
; 1400 : STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
; 1401 : {
; 1402 :    FILE *f = stbi__fopen(filename, "rb");
; 1403 :    stbi__uint16 *result;
; 1404 :    if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");
; 1405 :    result = stbi_load_from_file_16(f,x,y,comp,req_comp);
; 1406 :    fclose(f);
; 1407 :    return result;
; 1408 : }
; 1409 : 
; 1410 : 
; 1411 : #endif //!STBI_NO_STDIO
; 1412 : 
; 1413 : STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
; 1414 : {
; 1415 :    stbi__context s;
; 1416 :    stbi__start_mem(&s,buffer,len);
; 1417 :    return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
; 1418 : }
; 1419 : 
; 1420 : STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
; 1421 : {
; 1422 :    stbi__context s;
; 1423 :    stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
; 1424 :    return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
; 1425 : }
; 1426 : 
; 1427 : STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
; 1428 : {
; 1429 :    stbi__context s;
; 1430 :    stbi__start_mem(&s,buffer,len);
; 1431 :    return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
; 1432 : }
; 1433 : 
; 1434 : STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
; 1435 : {
; 1436 :    stbi__context s;
; 1437 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
; 1438 :    return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
; 1439 : }
; 1440 : 
; 1441 : #ifndef STBI_NO_GIF
; 1442 : STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
; 1443 : {
; 1444 :    unsigned char *result;
; 1445 :    stbi__context s;
; 1446 :    stbi__start_mem(&s,buffer,len);
; 1447 : 
; 1448 :    result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
; 1449 :    if (stbi__vertically_flip_on_load) {
; 1450 :       stbi__vertical_flip_slices( result, *x, *y, *z, *comp );
; 1451 :    }
; 1452 : 
; 1453 :    return result;
; 1454 : }
; 1455 : #endif
; 1456 : 
; 1457 : #ifndef STBI_NO_LINEAR
; 1458 : static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
; 1459 : {
; 1460 :    unsigned char *data;
; 1461 :    #ifndef STBI_NO_HDR
; 1462 :    if (stbi__hdr_test(s)) {
; 1463 :       stbi__result_info ri;
; 1464 :       float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
; 1465 :       if (hdr_data)
; 1466 :          stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
; 1467 :       return hdr_data;
; 1468 :    }
; 1469 :    #endif
; 1470 :    data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
; 1471 :    if (data)
; 1472 :       return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
; 1473 :    return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
; 1474 : }
; 1475 : 
; 1476 : STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
; 1477 : {
; 1478 :    stbi__context s;
; 1479 :    stbi__start_mem(&s,buffer,len);
; 1480 :    return stbi__loadf_main(&s,x,y,comp,req_comp);
; 1481 : }
; 1482 : 
; 1483 : STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
; 1484 : {
; 1485 :    stbi__context s;
; 1486 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
; 1487 :    return stbi__loadf_main(&s,x,y,comp,req_comp);
; 1488 : }
; 1489 : 
; 1490 : #ifndef STBI_NO_STDIO
; 1491 : STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
; 1492 : {
; 1493 :    float *result;
; 1494 :    FILE *f = stbi__fopen(filename, "rb");
; 1495 :    if (!f) return stbi__errpf("can't fopen", "Unable to open file");
; 1496 :    result = stbi_loadf_from_file(f,x,y,comp,req_comp);
; 1497 :    fclose(f);
; 1498 :    return result;
; 1499 : }
; 1500 : 
; 1501 : STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
; 1502 : {
; 1503 :    stbi__context s;
; 1504 :    stbi__start_file(&s,f);
; 1505 :    return stbi__loadf_main(&s,x,y,comp,req_comp);
; 1506 : }
; 1507 : #endif // !STBI_NO_STDIO
; 1508 : 
; 1509 : #endif // !STBI_NO_LINEAR
; 1510 : 
; 1511 : // these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
; 1512 : // defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
; 1513 : // reports false!
; 1514 : 
; 1515 : STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
; 1516 : {
; 1517 :    #ifndef STBI_NO_HDR
; 1518 :    stbi__context s;
; 1519 :    stbi__start_mem(&s,buffer,len);
; 1520 :    return stbi__hdr_test(&s);
; 1521 :    #else
; 1522 :    STBI_NOTUSED(buffer);
; 1523 :    STBI_NOTUSED(len);
; 1524 :    return 0;
; 1525 :    #endif
; 1526 : }
; 1527 : 
; 1528 : #ifndef STBI_NO_STDIO
; 1529 : STBIDEF int      stbi_is_hdr          (char const *filename)
; 1530 : {
; 1531 :    FILE *f = stbi__fopen(filename, "rb");
; 1532 :    int result=0;
; 1533 :    if (f) {
; 1534 :       result = stbi_is_hdr_from_file(f);
; 1535 :       fclose(f);
; 1536 :    }
; 1537 :    return result;
; 1538 : }
; 1539 : 
; 1540 : STBIDEF int stbi_is_hdr_from_file(FILE *f)
; 1541 : {
; 1542 :    #ifndef STBI_NO_HDR
; 1543 :    long pos = ftell(f);
; 1544 :    int res;
; 1545 :    stbi__context s;
; 1546 :    stbi__start_file(&s,f);
; 1547 :    res = stbi__hdr_test(&s);
; 1548 :    fseek(f, pos, SEEK_SET);
; 1549 :    return res;
; 1550 :    #else
; 1551 :    STBI_NOTUSED(f);
; 1552 :    return 0;
; 1553 :    #endif
; 1554 : }
; 1555 : #endif // !STBI_NO_STDIO
; 1556 : 
; 1557 : STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
; 1558 : {
; 1559 :    #ifndef STBI_NO_HDR
; 1560 :    stbi__context s;
; 1561 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
; 1562 :    return stbi__hdr_test(&s);
; 1563 :    #else
; 1564 :    STBI_NOTUSED(clbk);
; 1565 :    STBI_NOTUSED(user);
; 1566 :    return 0;
; 1567 :    #endif
; 1568 : }
; 1569 : 
; 1570 : #ifndef STBI_NO_LINEAR
; 1571 : static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;
; 1572 : 
; 1573 : STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
; 1574 : STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
; 1575 : #endif
; 1576 : 
; 1577 : static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;
; 1578 : 
; 1579 : STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
; 1580 : STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }
; 1581 : 
; 1582 : 
; 1583 : //////////////////////////////////////////////////////////////////////////////
; 1584 : //
; 1585 : // Common code used by all image loaders
; 1586 : //
; 1587 : 
; 1588 : enum
; 1589 : {
; 1590 :    STBI__SCAN_load=0,
; 1591 :    STBI__SCAN_type,
; 1592 :    STBI__SCAN_header
; 1593 : };
; 1594 : 
; 1595 : static void stbi__refill_buffer(stbi__context *s)
; 1596 : {
; 1597 :    int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
; 1598 :    s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);
; 1599 :    if (n == 0) {
; 1600 :       // at end of file, treat same as if from memory, but need to handle case
; 1601 :       // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
; 1602 :       s->read_from_callbacks = 0;
; 1603 :       s->img_buffer = s->buffer_start;
; 1604 :       s->img_buffer_end = s->buffer_start+1;
; 1605 :       *s->img_buffer = 0;
; 1606 :    } else {
; 1607 :       s->img_buffer = s->buffer_start;
; 1608 :       s->img_buffer_end = s->buffer_start + n;
; 1609 :    }
; 1610 : }
; 1611 : 
; 1612 : stbi_inline static stbi_uc stbi__get8(stbi__context *s)
; 1613 : {
; 1614 :    if (s->img_buffer < s->img_buffer_end)
; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {
; 1617 :       stbi__refill_buffer(s);
; 1618 :       return *s->img_buffer++;
; 1619 :    }
; 1620 :    return 0;
; 1621 : }
; 1622 : 
; 1623 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1624 : // nothing
; 1625 : #else
; 1626 : stbi_inline static int stbi__at_eof(stbi__context *s)
; 1627 : {
; 1628 :    if (s->io.read) {
; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;
; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;
; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;
; 1636 : }
; 1637 : #endif
; 1638 : 
; 1639 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
; 1640 : // nothing
; 1641 : #else
; 1642 : static void stbi__skip(stbi__context *s, int n)
; 1643 : {
; 1644 :    if (n == 0) return;  // already there!
; 1645 :    if (n < 0) {
; 1646 :       s->img_buffer = s->img_buffer_end;
; 1647 :       return;
; 1648 :    }
; 1649 :    if (s->io.read) {
; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1651 :       if (blen < n) {
; 1652 :          s->img_buffer = s->img_buffer_end;
; 1653 :          (s->io.skip)(s->io_user_data, n - blen);
; 1654 :          return;
; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;
; 1658 : }
; 1659 : #endif
; 1660 : 
; 1661 : #if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
; 1662 : // nothing
; 1663 : #else
; 1664 : static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
; 1665 : {
; 1666 :    if (s->io.read) {
; 1667 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1668 :       if (blen < n) {
; 1669 :          int res, count;
; 1670 : 
; 1671 :          memcpy(buffer, s->img_buffer, blen);
; 1672 : 
; 1673 :          count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
; 1674 :          res = (count == (n-blen));
; 1675 :          s->img_buffer = s->img_buffer_end;
; 1676 :          return res;
; 1677 :       }
; 1678 :    }
; 1679 : 
; 1680 :    if (s->img_buffer+n <= s->img_buffer_end) {
; 1681 :       memcpy(buffer, s->img_buffer, n);
; 1682 :       s->img_buffer += n;
; 1683 :       return 1;
; 1684 :    } else
; 1685 :       return 0;
; 1686 : }
; 1687 : #endif
; 1688 : 
; 1689 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1690 : // nothing
; 1691 : #else
; 1692 : static int stbi__get16be(stbi__context *s)
; 1693 : {
; 1694 :    int z = stbi__get8(s);
; 1695 :    return (z << 8) + stbi__get8(s);
; 1696 : }
; 1697 : #endif
; 1698 : 
; 1699 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1700 : // nothing
; 1701 : #else
; 1702 : static stbi__uint32 stbi__get32be(stbi__context *s)
; 1703 : {
; 1704 :    stbi__uint32 z = stbi__get16be(s);
; 1705 :    return (z << 16) + stbi__get16be(s);
; 1706 : }
; 1707 : #endif
; 1708 : 
; 1709 : #if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
; 1710 : // nothing
; 1711 : #else
; 1712 : static int stbi__get16le(stbi__context *s)
; 1713 : {
; 1714 :    int z = stbi__get8(s);
; 1715 :    return z + (stbi__get8(s) << 8);
; 1716 : }
; 1717 : #endif
; 1718 : 
; 1719 : #ifndef STBI_NO_BMP
; 1720 : static stbi__uint32 stbi__get32le(stbi__context *s)
; 1721 : {
; 1722 :    stbi__uint32 z = stbi__get16le(s);
; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;
; 1724 :    return z;
; 1725 : }
; 1726 : #endif
; 1727 : 
; 1728 : #define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
; 1729 : 
; 1730 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1731 : // nothing
; 1732 : #else
; 1733 : //////////////////////////////////////////////////////////////////////////////
; 1734 : //
; 1735 : //  generic converter from built-in img_n to req_comp
; 1736 : //    individual types do this automatically as much as possible (e.g. jpeg
; 1737 : //    does all cases internally since it needs to colorspace convert anyway,
; 1738 : //    and it never has alpha, so very few cases ). png can automatically
; 1739 : //    interleave an alpha=255 channel, but falls back to this for other cases
; 1740 : //
; 1741 : //  assume data buffer is malloced, so malloc a new one and free that one
; 1742 : //  only failure mode is malloc failing
; 1743 : 
; 1744 : static stbi_uc stbi__compute_y(int r, int g, int b)
; 1745 : {
; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1747 : }
; 1748 : #endif
; 1749 : 
; 1750 : #if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1751 : // nothing
; 1752 : #else
; 1753 : static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1754 : {
; 1755 :    int i,j;
; 1756 :    unsigned char *good;
; 1757 : 
; 1758 :    if (req_comp == img_n) return data;
; 1759 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1760 : 
; 1761 :    good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
; 1762 :    if (good == NULL) {
; 1763 :       STBI_FREE(data);
; 1764 :       return stbi__errpuc("outofmem", "Out of memory");
; 1765 :    }
; 1766 : 
; 1767 :    for (j=0; j < (int) y; ++j) {
; 1768 :       unsigned char *src  = data + j * x * img_n   ;
; 1769 :       unsigned char *dest = good + j * x * req_comp;
; 1770 : 
; 1771 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1772 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1773 :       // convert source image with img_n components to one with req_comp components;
; 1774 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1775 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1776 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
; 1777 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1778 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
; 1779 :          STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
; 1780 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1781 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
; 1782 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
; 1783 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1784 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
; 1785 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1786 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1787 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
; 1788 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
; 1789 :       }
; 1790 :       #undef STBI__CASE
; 1791 :    }
; 1792 : 
; 1793 :    STBI_FREE(data);
; 1794 :    return good;
; 1795 : }
; 1796 : #endif
; 1797 : 
; 1798 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1799 : // nothing
; 1800 : #else
; 1801 : static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
; 1802 : {
; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1804 : }
; 1805 : #endif
; 1806 : 
; 1807 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1808 : // nothing
; 1809 : #else
; 1810 : static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1811 : {
; 1812 :    int i,j;
; 1813 :    stbi__uint16 *good;
; 1814 : 
; 1815 :    if (req_comp == img_n) return data;
; 1816 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1817 : 
; 1818 :    good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
; 1819 :    if (good == NULL) {
; 1820 :       STBI_FREE(data);
; 1821 :       return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1822 :    }
; 1823 : 
; 1824 :    for (j=0; j < (int) y; ++j) {
; 1825 :       stbi__uint16 *src  = data + j * x * img_n   ;
; 1826 :       stbi__uint16 *dest = good + j * x * req_comp;
; 1827 : 
; 1828 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1829 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1830 :       // convert source image with img_n components to one with req_comp components;
; 1831 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1832 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1833 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
; 1834 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1835 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
; 1836 :          STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
; 1837 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1838 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
; 1839 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
; 1840 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1841 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
; 1842 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1843 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1844 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
; 1845 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
; 1846 :       }
; 1847 :       #undef STBI__CASE
; 1848 :    }
; 1849 : 
; 1850 :    STBI_FREE(data);
; 1851 :    return good;
; 1852 : }
; 1853 : #endif
; 1854 : 
; 1855 : #ifndef STBI_NO_LINEAR
; 1856 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
; 1857 : {
; 1858 :    int i,k,n;
; 1859 :    float *output;
; 1860 :    if (!data) return NULL;
; 1861 :    output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
; 1862 :    if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
; 1863 :    // compute number of non-alpha components
; 1864 :    if (comp & 1) n = comp; else n = comp-1;
; 1865 :    for (i=0; i < x*y; ++i) {
; 1866 :       for (k=0; k < n; ++k) {
; 1867 :          output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
; 1868 :       }
; 1869 :    }
; 1870 :    if (n < comp) {
; 1871 :       for (i=0; i < x*y; ++i) {
; 1872 :          output[i*comp + n] = data[i*comp + n]/255.0f;
; 1873 :       }
; 1874 :    }
; 1875 :    STBI_FREE(data);
; 1876 :    return output;
; 1877 : }
; 1878 : #endif
; 1879 : 
; 1880 : #ifndef STBI_NO_HDR
; 1881 : #define stbi__float2int(x)   ((int) (x))
; 1882 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
; 1883 : {
; 1884 :    int i,k,n;
; 1885 :    stbi_uc *output;
; 1886 :    if (!data) return NULL;
; 1887 :    output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
; 1888 :    if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
; 1889 :    // compute number of non-alpha components
; 1890 :    if (comp & 1) n = comp; else n = comp-1;
; 1891 :    for (i=0; i < x*y; ++i) {
; 1892 :       for (k=0; k < n; ++k) {
; 1893 :          float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
; 1894 :          if (z < 0) z = 0;
; 1895 :          if (z > 255) z = 255;
; 1896 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1897 :       }
; 1898 :       if (k < comp) {
; 1899 :          float z = data[i*comp+k] * 255 + 0.5f;
; 1900 :          if (z < 0) z = 0;
; 1901 :          if (z > 255) z = 255;
; 1902 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1903 :       }
; 1904 :    }
; 1905 :    STBI_FREE(data);
; 1906 :    return output;
; 1907 : }
; 1908 : #endif
; 1909 : 
; 1910 : //////////////////////////////////////////////////////////////////////////////
; 1911 : //
; 1912 : //  "baseline" JPEG/JFIF decoder
; 1913 : //
; 1914 : //    simple implementation
; 1915 : //      - doesn't support delayed output of y-dimension
; 1916 : //      - simple interface (only one output format: 8-bit interleaved RGB)
; 1917 : //      - doesn't try to recover corrupt jpegs
; 1918 : //      - doesn't allow partial loading, loading multiple at once
; 1919 : //      - still fast on x86 (copying globals into locals doesn't help x86)
; 1920 : //      - allocates lots of intermediate memory (full size of all components)
; 1921 : //        - non-interleaved case requires this anyway
; 1922 : //        - allows good upsampling (see next)
; 1923 : //    high-quality
; 1924 : //      - upsampled channels are bilinearly interpolated, even across blocks
; 1925 : //      - quality integer IDCT derived from IJG's 'slow'
; 1926 : //    performance
; 1927 : //      - fast huffman; reasonable integer IDCT
; 1928 : //      - some SIMD kernels for common paths on targets with SSE2/NEON
; 1929 : //      - uses a lot of intermediate memory, could cache poorly
; 1930 : 
; 1931 : #ifndef STBI_NO_JPEG
; 1932 : 
; 1933 : // huffman decoding acceleration
; 1934 : #define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
; 1935 : 
; 1936 : typedef struct
; 1937 : {
; 1938 :    stbi_uc  fast[1 << FAST_BITS];
; 1939 :    // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
; 1940 :    stbi__uint16 code[256];
; 1941 :    stbi_uc  values[256];
; 1942 :    stbi_uc  size[257];
; 1943 :    unsigned int maxcode[18];
; 1944 :    int    delta[17];   // old 'firstsymbol' - old 'firstcode'
; 1945 : } stbi__huffman;
; 1946 : 
; 1947 : typedef struct
; 1948 : {
; 1949 :    stbi__context *s;
; 1950 :    stbi__huffman huff_dc[4];
; 1951 :    stbi__huffman huff_ac[4];
; 1952 :    stbi__uint16 dequant[4][64];
; 1953 :    stbi__int16 fast_ac[4][1 << FAST_BITS];
; 1954 : 
; 1955 : // sizes for components, interleaved MCUs
; 1956 :    int img_h_max, img_v_max;
; 1957 :    int img_mcu_x, img_mcu_y;
; 1958 :    int img_mcu_w, img_mcu_h;
; 1959 : 
; 1960 : // definition of jpeg image component
; 1961 :    struct
; 1962 :    {
; 1963 :       int id;
; 1964 :       int h,v;
; 1965 :       int tq;
; 1966 :       int hd,ha;
; 1967 :       int dc_pred;
; 1968 : 
; 1969 :       int x,y,w2,h2;
; 1970 :       stbi_uc *data;
; 1971 :       void *raw_data, *raw_coeff;
; 1972 :       stbi_uc *linebuf;
; 1973 :       short   *coeff;   // progressive only
; 1974 :       int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
; 1975 :    } img_comp[4];
; 1976 : 
; 1977 :    stbi__uint32   code_buffer; // jpeg entropy-coded buffer
; 1978 :    int            code_bits;   // number of valid bits
; 1979 :    unsigned char  marker;      // marker seen while filling entropy buffer
; 1980 :    int            nomore;      // flag if we saw a marker so must stop
; 1981 : 
; 1982 :    int            progressive;
; 1983 :    int            spec_start;
; 1984 :    int            spec_end;
; 1985 :    int            succ_high;
; 1986 :    int            succ_low;
; 1987 :    int            eob_run;
; 1988 :    int            jfif;
; 1989 :    int            app14_color_transform; // Adobe APP14 tag
; 1990 :    int            rgb;
; 1991 : 
; 1992 :    int scan_n, order[4];
; 1993 :    int restart_interval, todo;
; 1994 : 
; 1995 : // kernels
; 1996 :    void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
; 1997 :    void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
; 1998 :    stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
; 1999 : } stbi__jpeg;
; 2000 : 
; 2001 : static int stbi__build_huffman(stbi__huffman *h, int *count)
; 2002 : {
; 2003 :    int i,j,k=0;
; 2004 :    unsigned int code;
; 2005 :    // build size list for each symbol (from JPEG spec)
; 2006 :    for (i=0; i < 16; ++i) {
; 2007 :       for (j=0; j < count[i]; ++j) {
; 2008 :          h->size[k++] = (stbi_uc) (i+1);
; 2009 :          if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");
; 2010 :       }
; 2011 :    }
; 2012 :    h->size[k] = 0;
; 2013 : 
; 2014 :    // compute actual symbols (from jpeg spec)
; 2015 :    code = 0;
; 2016 :    k = 0;
; 2017 :    for(j=1; j <= 16; ++j) {
; 2018 :       // compute delta to add to code to compute symbol id
; 2019 :       h->delta[j] = k - code;
; 2020 :       if (h->size[k] == j) {
; 2021 :          while (h->size[k] == j)
; 2022 :             h->code[k++] = (stbi__uint16) (code++);
; 2023 :          if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
; 2024 :       }
; 2025 :       // compute largest code + 1 for this size, preshifted as needed later
; 2026 :       h->maxcode[j] = code << (16-j);
; 2027 :       code <<= 1;
; 2028 :    }
; 2029 :    h->maxcode[j] = 0xffffffff;
; 2030 : 
; 2031 :    // build non-spec acceleration table; 255 is flag for not-accelerated
; 2032 :    memset(h->fast, 255, 1 << FAST_BITS);
; 2033 :    for (i=0; i < k; ++i) {
; 2034 :       int s = h->size[i];
; 2035 :       if (s <= FAST_BITS) {
; 2036 :          int c = h->code[i] << (FAST_BITS-s);
; 2037 :          int m = 1 << (FAST_BITS-s);
; 2038 :          for (j=0; j < m; ++j) {
; 2039 :             h->fast[c+j] = (stbi_uc) i;
; 2040 :          }
; 2041 :       }
; 2042 :    }
; 2043 :    return 1;
; 2044 : }
; 2045 : 
; 2046 : // build a table that decodes both magnitude and value of small ACs in
; 2047 : // one go.
; 2048 : static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
; 2049 : {
; 2050 :    int i;
; 2051 :    for (i=0; i < (1 << FAST_BITS); ++i) {
; 2052 :       stbi_uc fast = h->fast[i];
; 2053 :       fast_ac[i] = 0;
; 2054 :       if (fast < 255) {
; 2055 :          int rs = h->values[fast];
; 2056 :          int run = (rs >> 4) & 15;
; 2057 :          int magbits = rs & 15;
; 2058 :          int len = h->size[fast];
; 2059 : 
; 2060 :          if (magbits && len + magbits <= FAST_BITS) {
; 2061 :             // magnitude code followed by receive_extend code
; 2062 :             int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
; 2063 :             int m = 1 << (magbits - 1);
; 2064 :             if (k < m) k += (~0U << magbits) + 1;
; 2065 :             // if the result is small enough, we can fit it in fast_ac table
; 2066 :             if (k >= -128 && k <= 127)
; 2067 :                fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
; 2068 :          }
; 2069 :       }
; 2070 :    }
; 2071 : }
; 2072 : 
; 2073 : static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
; 2074 : {
; 2075 :    do {
; 2076 :       unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
; 2077 :       if (b == 0xff) {
; 2078 :          int c = stbi__get8(j->s);
; 2079 :          while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
; 2080 :          if (c != 0) {
; 2081 :             j->marker = (unsigned char) c;
; 2082 :             j->nomore = 1;
; 2083 :             return;
; 2084 :          }
; 2085 :       }
; 2086 :       j->code_buffer |= b << (24 - j->code_bits);
; 2087 :       j->code_bits += 8;
; 2088 :    } while (j->code_bits <= 24);
; 2089 : }
; 2090 : 
; 2091 : // (1 << n) - 1
; 2092 : static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
; 2093 : 
; 2094 : // decode a jpeg huffman value from the bitstream
; 2095 : stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
; 2096 : {
; 2097 :    unsigned int temp;
; 2098 :    int c,k;
; 2099 : 
; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2105 :    k = h->fast[c];
; 2106 :    if (k < 255) {
; 2107 :       int s = h->size[k];
; 2108 :       if (s > j->code_bits)
; 2109 :          return -1;
; 2110 :       j->code_buffer <<= s;
; 2111 :       j->code_bits -= s;
; 2112 :       return h->values[k];
; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;
; 2122 :    for (k=FAST_BITS+1 ; ; ++k)
; 2123 :       if (temp < h->maxcode[k])
; 2124 :          break;
; 2125 :    if (k == 17) {
; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;
; 2128 :       return -1;
; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)
; 2132 :       return -1;
; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!
; 2137 :        return -1;
; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;
; 2142 :    j->code_buffer <<= k;
; 2143 :    return h->values[c];
; 2144 : }
; 2145 : 
; 2146 : // bias[n] = (-1<<n) + 1
; 2147 : static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};
; 2148 : 
; 2149 : // combined JPEG 'receive' and JPEG 'extend', since baseline
; 2150 : // always extends everything it receives.
; 2151 : stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
; 2152 : {
; 2153 :    unsigned int k;
; 2154 :    int sgn;
; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
; 2159 :    k = stbi_lrot(j->code_buffer, n);
; 2160 :    j->code_buffer = k & ~stbi__bmask[n];
; 2161 :    k &= stbi__bmask[n];
; 2162 :    j->code_bits -= n;
; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));
; 2164 : }
; 2165 : 
; 2166 : // get some unsigned bits
; 2167 : stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
; 2168 : {
; 2169 :    unsigned int k;
; 2170 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2171 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2172 :    k = stbi_lrot(j->code_buffer, n);
; 2173 :    j->code_buffer = k & ~stbi__bmask[n];
; 2174 :    k &= stbi__bmask[n];
; 2175 :    j->code_bits -= n;
; 2176 :    return k;
; 2177 : }
; 2178 : 
; 2179 : stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
; 2180 : {
; 2181 :    unsigned int k;
; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2184 :    k = j->code_buffer;
; 2185 :    j->code_buffer <<= 1;
; 2186 :    --j->code_bits;
; 2187 :    return k & 0x80000000;
; 2188 : }
; 2189 : 
; 2190 : // given a value that's at position X in the zigzag stream,
; 2191 : // where does it appear in the 8x8 matrix coded as row-major?
; 2192 : static const stbi_uc stbi__jpeg_dezigzag[64+15] =
; 2193 : {
; 2194 :     0,  1,  8, 16,  9,  2,  3, 10,
; 2195 :    17, 24, 32, 25, 18, 11,  4,  5,
; 2196 :    12, 19, 26, 33, 40, 48, 41, 34,
; 2197 :    27, 20, 13,  6,  7, 14, 21, 28,
; 2198 :    35, 42, 49, 56, 57, 50, 43, 36,
; 2199 :    29, 22, 15, 23, 30, 37, 44, 51,
; 2200 :    58, 59, 52, 45, 38, 31, 39, 46,
; 2201 :    53, 60, 61, 54, 47, 55, 62, 63,
; 2202 :    // let corrupt input sample past end
; 2203 :    63, 63, 63, 63, 63, 63, 63, 63,
; 2204 :    63, 63, 63, 63, 63, 63, 63
; 2205 : };
; 2206 : 
; 2207 : // decode one 64-entry block--
; 2208 : static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
; 2209 : {
; 2210 :    int diff,dc,k;
; 2211 :    int t;
; 2212 : 
; 2213 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2214 :    t = stbi__jpeg_huff_decode(j, hdc);
; 2215 :    if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");
; 2216 : 
; 2217 :    // 0 all the ac values now so we can do it 32-bits at a time
; 2218 :    memset(data,0,64*sizeof(data[0]));
; 2219 : 
; 2220 :    diff = t ? stbi__extend_receive(j, t) : 0;
; 2221 :    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");
; 2222 :    dc = j->img_comp[b].dc_pred + diff;
; 2223 :    j->img_comp[b].dc_pred = dc;
; 2224 :    if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2225 :    data[0] = (short) (dc * dequant[0]);
; 2226 : 
; 2227 :    // decode AC components, see JPEG spec
; 2228 :    k = 1;
; 2229 :    do {
; 2230 :       unsigned int zig;
; 2231 :       int c,r,s;
; 2232 :       if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2233 :       c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2234 :       r = fac[c];
; 2235 :       if (r) { // fast-AC path
; 2236 :          k += (r >> 4) & 15; // run
; 2237 :          s = r & 15; // combined length
; 2238 :          if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2239 :          j->code_buffer <<= s;
; 2240 :          j->code_bits -= s;
; 2241 :          // decode into unzigzag'd location
; 2242 :          zig = stbi__jpeg_dezigzag[k++];
; 2243 :          data[zig] = (short) ((r >> 8) * dequant[zig]);
; 2244 :       } else {
; 2245 :          int rs = stbi__jpeg_huff_decode(j, hac);
; 2246 :          if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2247 :          s = rs & 15;
; 2248 :          r = rs >> 4;
; 2249 :          if (s == 0) {
; 2250 :             if (rs != 0xf0) break; // end block
; 2251 :             k += 16;
; 2252 :          } else {
; 2253 :             k += r;
; 2254 :             // decode into unzigzag'd location
; 2255 :             zig = stbi__jpeg_dezigzag[k++];
; 2256 :             data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
; 2257 :          }
; 2258 :       }
; 2259 :    } while (k < 64);
; 2260 :    return 1;
; 2261 : }
; 2262 : 
; 2263 : static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
; 2264 : {
; 2265 :    int diff,dc;
; 2266 :    int t;
; 2267 :    if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2268 : 
; 2269 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2270 : 
; 2271 :    if (j->succ_high == 0) {
; 2272 :       // first scan for DC coefficient, must be first
; 2273 :       memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
; 2274 :       t = stbi__jpeg_huff_decode(j, hdc);
; 2275 :       if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2276 :       diff = t ? stbi__extend_receive(j, t) : 0;
; 2277 : 
; 2278 :       if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");
; 2279 :       dc = j->img_comp[b].dc_pred + diff;
; 2280 :       j->img_comp[b].dc_pred = dc;
; 2281 :       if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2282 :       data[0] = (short) (dc * (1 << j->succ_low));
; 2283 :    } else {
; 2284 :       // refinement scan for DC coefficient
; 2285 :       if (stbi__jpeg_get_bit(j))
; 2286 :          data[0] += (short) (1 << j->succ_low);
; 2287 :    }
; 2288 :    return 1;
; 2289 : }
; 2290 : 
; 2291 : // @OPTIMIZE: store non-zigzagged during the decode passes,
; 2292 : // and only de-zigzag when dequantizing
; 2293 : static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
; 2294 : {
; 2295 :    int k;
; 2296 :    if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2297 : 
; 2298 :    if (j->succ_high == 0) {
; 2299 :       int shift = j->succ_low;
; 2300 : 
; 2301 :       if (j->eob_run) {
; 2302 :          --j->eob_run;
; 2303 :          return 1;
; 2304 :       }
; 2305 : 
; 2306 :       k = j->spec_start;
; 2307 :       do {
; 2308 :          unsigned int zig;
; 2309 :          int c,r,s;
; 2310 :          if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2311 :          c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2312 :          r = fac[c];
; 2313 :          if (r) { // fast-AC path
; 2314 :             k += (r >> 4) & 15; // run
; 2315 :             s = r & 15; // combined length
; 2316 :             if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2317 :             j->code_buffer <<= s;
; 2318 :             j->code_bits -= s;
; 2319 :             zig = stbi__jpeg_dezigzag[k++];
; 2320 :             data[zig] = (short) ((r >> 8) * (1 << shift));
; 2321 :          } else {
; 2322 :             int rs = stbi__jpeg_huff_decode(j, hac);
; 2323 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2324 :             s = rs & 15;
; 2325 :             r = rs >> 4;
; 2326 :             if (s == 0) {
; 2327 :                if (r < 15) {
; 2328 :                   j->eob_run = (1 << r);
; 2329 :                   if (r)
; 2330 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2331 :                   --j->eob_run;
; 2332 :                   break;
; 2333 :                }
; 2334 :                k += 16;
; 2335 :             } else {
; 2336 :                k += r;
; 2337 :                zig = stbi__jpeg_dezigzag[k++];
; 2338 :                data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
; 2339 :             }
; 2340 :          }
; 2341 :       } while (k <= j->spec_end);
; 2342 :    } else {
; 2343 :       // refinement scan for these AC coefficients
; 2344 : 
; 2345 :       short bit = (short) (1 << j->succ_low);
; 2346 : 
; 2347 :       if (j->eob_run) {
; 2348 :          --j->eob_run;
; 2349 :          for (k = j->spec_start; k <= j->spec_end; ++k) {
; 2350 :             short *p = &data[stbi__jpeg_dezigzag[k]];
; 2351 :             if (*p != 0)
; 2352 :                if (stbi__jpeg_get_bit(j))
; 2353 :                   if ((*p & bit)==0) {
; 2354 :                      if (*p > 0)
; 2355 :                         *p += bit;
; 2356 :                      else
; 2357 :                         *p -= bit;
; 2358 :                   }
; 2359 :          }
; 2360 :       } else {
; 2361 :          k = j->spec_start;
; 2362 :          do {
; 2363 :             int r,s;
; 2364 :             int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
; 2365 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2366 :             s = rs & 15;
; 2367 :             r = rs >> 4;
; 2368 :             if (s == 0) {
; 2369 :                if (r < 15) {
; 2370 :                   j->eob_run = (1 << r) - 1;
; 2371 :                   if (r)
; 2372 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2373 :                   r = 64; // force end of block
; 2374 :                } else {
; 2375 :                   // r=15 s=0 should write 16 0s, so we just do
; 2376 :                   // a run of 15 0s and then write s (which is 0),
; 2377 :                   // so we don't have to do anything special here
; 2378 :                }
; 2379 :             } else {
; 2380 :                if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
; 2381 :                // sign bit
; 2382 :                if (stbi__jpeg_get_bit(j))
; 2383 :                   s = bit;
; 2384 :                else
; 2385 :                   s = -bit;
; 2386 :             }
; 2387 : 
; 2388 :             // advance by r
; 2389 :             while (k <= j->spec_end) {
; 2390 :                short *p = &data[stbi__jpeg_dezigzag[k++]];
; 2391 :                if (*p != 0) {
; 2392 :                   if (stbi__jpeg_get_bit(j))
; 2393 :                      if ((*p & bit)==0) {
; 2394 :                         if (*p > 0)
; 2395 :                            *p += bit;
; 2396 :                         else
; 2397 :                            *p -= bit;
; 2398 :                      }
; 2399 :                } else {
; 2400 :                   if (r == 0) {
; 2401 :                      *p = (short) s;
; 2402 :                      break;
; 2403 :                   }
; 2404 :                   --r;
; 2405 :                }
; 2406 :             }
; 2407 :          } while (k <= j->spec_end);
; 2408 :       }
; 2409 :    }
; 2410 :    return 1;
; 2411 : }
; 2412 : 
; 2413 : // take a -128..127 value and stbi__clamp it and convert to 0..255
; 2414 : stbi_inline static stbi_uc stbi__clamp(int x)
; 2415 : {
; 2416 :    // trick to use a single test to catch both cases
; 2417 :    if ((unsigned int) x > 255) {
; 2418 :       if (x < 0) return 0;
; 2419 :       if (x > 255) return 255;
; 2420 :    }
; 2421 :    return (stbi_uc) x;
; 2422 : }
; 2423 : 
; 2424 : #define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
; 2425 : #define stbi__fsh(x)  ((x) * 4096)
; 2426 : 
; 2427 : // derived from jidctint -- DCT_ISLOW
; 2428 : #define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
; 2429 :    int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
; 2430 :    p2 = s2;                                    \
; 2431 :    p3 = s6;                                    \
; 2432 :    p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
; 2433 :    t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
; 2434 :    t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
; 2435 :    p2 = s0;                                    \
; 2436 :    p3 = s4;                                    \
; 2437 :    t0 = stbi__fsh(p2+p3);                      \
; 2438 :    t1 = stbi__fsh(p2-p3);                      \
; 2439 :    x0 = t0+t3;                                 \
; 2440 :    x3 = t0-t3;                                 \
; 2441 :    x1 = t1+t2;                                 \
; 2442 :    x2 = t1-t2;                                 \
; 2443 :    t0 = s7;                                    \
; 2444 :    t1 = s5;                                    \
; 2445 :    t2 = s3;                                    \
; 2446 :    t3 = s1;                                    \
; 2447 :    p3 = t0+t2;                                 \
; 2448 :    p4 = t1+t3;                                 \
; 2449 :    p1 = t0+t3;                                 \
; 2450 :    p2 = t1+t2;                                 \
; 2451 :    p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
; 2452 :    t0 = t0*stbi__f2f( 0.298631336f);           \
; 2453 :    t1 = t1*stbi__f2f( 2.053119869f);           \
; 2454 :    t2 = t2*stbi__f2f( 3.072711026f);           \
; 2455 :    t3 = t3*stbi__f2f( 1.501321110f);           \
; 2456 :    p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
; 2457 :    p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
; 2458 :    p3 = p3*stbi__f2f(-1.961570560f);           \
; 2459 :    p4 = p4*stbi__f2f(-0.390180644f);           \
; 2460 :    t3 += p1+p4;                                \
; 2461 :    t2 += p2+p3;                                \
; 2462 :    t1 += p2+p4;                                \
; 2463 :    t0 += p1+p3;
; 2464 : 
; 2465 : static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
; 2466 : {
; 2467 :    int i,val[64],*v=val;
; 2468 :    stbi_uc *o;
; 2469 :    short *d = data;
; 2470 : 
; 2471 :    // columns
; 2472 :    for (i=0; i < 8; ++i,++d, ++v) {
; 2473 :       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2474 :       if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2475 :            && d[40]==0 && d[48]==0 && d[56]==0) {
; 2476 :          //    no shortcut                 0     seconds
; 2477 :          //    (1|2|3|4|5|6|7)==0          0     seconds
; 2478 :          //    all separate               -0.047 seconds
; 2479 :          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2480 :          int dcterm = d[0]*4;
; 2481 :          v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
; 2482 :       } else {
; 2483 :          STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
; 2484 :          // constants scaled things up by 1<<12; let's bring them back
; 2485 :          // down, but keep 2 extra bits of precision
; 2486 :          x0 += 512; x1 += 512; x2 += 512; x3 += 512;
; 2487 :          v[ 0] = (x0+t3) >> 10;
; 2488 :          v[56] = (x0-t3) >> 10;
; 2489 :          v[ 8] = (x1+t2) >> 10;
; 2490 :          v[48] = (x1-t2) >> 10;
; 2491 :          v[16] = (x2+t1) >> 10;
; 2492 :          v[40] = (x2-t1) >> 10;
; 2493 :          v[24] = (x3+t0) >> 10;
; 2494 :          v[32] = (x3-t0) >> 10;
; 2495 :       }
; 2496 :    }
; 2497 : 
; 2498 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
; 2499 :       // no fast case since the first 1D IDCT spread components out
; 2500 :       STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
; 2501 :       // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2502 :       // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2503 :       // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2504 :       // so we want to round that, which means adding 0.5 * 1<<17,
; 2505 :       // aka 65536. Also, we'll end up with -128 to 127 that we want
; 2506 :       // to encode as 0..255 by adding 128, so we'll add that before the shift
; 2507 :       x0 += 65536 + (128<<17);
; 2508 :       x1 += 65536 + (128<<17);
; 2509 :       x2 += 65536 + (128<<17);
; 2510 :       x3 += 65536 + (128<<17);
; 2511 :       // tried computing the shifts into temps, or'ing the temps to see
; 2512 :       // if any were out of range, but that was slower
; 2513 :       o[0] = stbi__clamp((x0+t3) >> 17);
; 2514 :       o[7] = stbi__clamp((x0-t3) >> 17);
; 2515 :       o[1] = stbi__clamp((x1+t2) >> 17);
; 2516 :       o[6] = stbi__clamp((x1-t2) >> 17);
; 2517 :       o[2] = stbi__clamp((x2+t1) >> 17);
; 2518 :       o[5] = stbi__clamp((x2-t1) >> 17);
; 2519 :       o[3] = stbi__clamp((x3+t0) >> 17);
; 2520 :       o[4] = stbi__clamp((x3-t0) >> 17);
; 2521 :    }
; 2522 : }
; 2523 : 
; 2524 : #ifdef STBI_SSE2
; 2525 : // sse2 integer IDCT. not the fastest possible implementation but it
; 2526 : // produces bit-identical results to the generic C version so it's
; 2527 : // fully "transparent".
; 2528 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2529 : {
; 2530 :    // This is constructed to match our regular (generic) integer IDCT exactly.
; 2531 :    __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2532 :    __m128i tmp;
; 2533 : 
; 2534 :    // dot product constant: even elems=x, odd elems=y
; 2535 :    #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2536 : 
; 2537 :    // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2538 :    // out(1) = c1[even]*x + c1[odd]*y
; 2539 :    #define dct_rot(out0,out1, x,y,c0,c1) \
; 2540 :       __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2541 :       __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2542 :       __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2543 :       __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2544 :       __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2545 :       __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2546 : 
; 2547 :    // out = in << 12  (in 16-bit, out 32-bit)
; 2548 :    #define dct_widen(out, in) \
; 2549 :       __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2550 :       __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2551 : 
; 2552 :    // wide add
; 2553 :    #define dct_wadd(out, a, b) \
; 2554 :       __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2555 :       __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2556 : 
; 2557 :    // wide sub
; 2558 :    #define dct_wsub(out, a, b) \
; 2559 :       __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2560 :       __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2561 : 
; 2562 :    // butterfly a/b, add bias, then shift by "s" and pack
; 2563 :    #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2564 :       { \
; 2565 :          __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2566 :          __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2567 :          dct_wadd(sum, abiased, b); \
; 2568 :          dct_wsub(dif, abiased, b); \
; 2569 :          out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2570 :          out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2571 :       }
; 2572 : 
; 2573 :    // 8-bit interleave step (for transposes)
; 2574 :    #define dct_interleave8(a, b) \
; 2575 :       tmp = a; \
; 2576 :       a = _mm_unpacklo_epi8(a, b); \
; 2577 :       b = _mm_unpackhi_epi8(tmp, b)
; 2578 : 
; 2579 :    // 16-bit interleave step (for transposes)
; 2580 :    #define dct_interleave16(a, b) \
; 2581 :       tmp = a; \
; 2582 :       a = _mm_unpacklo_epi16(a, b); \
; 2583 :       b = _mm_unpackhi_epi16(tmp, b)
; 2584 : 
; 2585 :    #define dct_pass(bias,shift) \
; 2586 :       { \
; 2587 :          /* even part */ \
; 2588 :          dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2589 :          __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2590 :          __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2591 :          dct_widen(t0e, sum04); \
; 2592 :          dct_widen(t1e, dif04); \
; 2593 :          dct_wadd(x0, t0e, t3e); \
; 2594 :          dct_wsub(x3, t0e, t3e); \
; 2595 :          dct_wadd(x1, t1e, t2e); \
; 2596 :          dct_wsub(x2, t1e, t2e); \
; 2597 :          /* odd part */ \
; 2598 :          dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2599 :          dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2600 :          __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2601 :          __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2602 :          dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2603 :          dct_wadd(x4, y0o, y4o); \
; 2604 :          dct_wadd(x5, y1o, y5o); \
; 2605 :          dct_wadd(x6, y2o, y5o); \
; 2606 :          dct_wadd(x7, y3o, y4o); \
; 2607 :          dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2608 :          dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2609 :          dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2610 :          dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2611 :       }
; 2612 : 
; 2613 :    __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
; 2614 :    __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
; 2615 :    __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
; 2616 :    __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
; 2617 :    __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
; 2618 :    __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
; 2619 :    __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
; 2620 :    __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
; 2621 : 
; 2622 :    // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2623 :    __m128i bias_0 = _mm_set1_epi32(512);
; 2624 :    __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
; 2625 : 
; 2626 :    // load
; 2627 :    row0 = _mm_load_si128((const __m128i *) (data + 0*8));
; 2628 :    row1 = _mm_load_si128((const __m128i *) (data + 1*8));
; 2629 :    row2 = _mm_load_si128((const __m128i *) (data + 2*8));
; 2630 :    row3 = _mm_load_si128((const __m128i *) (data + 3*8));
; 2631 :    row4 = _mm_load_si128((const __m128i *) (data + 4*8));
; 2632 :    row5 = _mm_load_si128((const __m128i *) (data + 5*8));
; 2633 :    row6 = _mm_load_si128((const __m128i *) (data + 6*8));
; 2634 :    row7 = _mm_load_si128((const __m128i *) (data + 7*8));
; 2635 : 
; 2636 :    // column pass
; 2637 :    dct_pass(bias_0, 10);
; 2638 : 
; 2639 :    {
; 2640 :       // 16bit 8x8 transpose pass 1
; 2641 :       dct_interleave16(row0, row4);
; 2642 :       dct_interleave16(row1, row5);
; 2643 :       dct_interleave16(row2, row6);
; 2644 :       dct_interleave16(row3, row7);
; 2645 : 
; 2646 :       // transpose pass 2
; 2647 :       dct_interleave16(row0, row2);
; 2648 :       dct_interleave16(row1, row3);
; 2649 :       dct_interleave16(row4, row6);
; 2650 :       dct_interleave16(row5, row7);
; 2651 : 
; 2652 :       // transpose pass 3
; 2653 :       dct_interleave16(row0, row1);
; 2654 :       dct_interleave16(row2, row3);
; 2655 :       dct_interleave16(row4, row5);
; 2656 :       dct_interleave16(row6, row7);
; 2657 :    }
; 2658 : 
; 2659 :    // row pass
; 2660 :    dct_pass(bias_1, 17);
; 2661 : 
; 2662 :    {
; 2663 :       // pack
; 2664 :       __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
; 2665 :       __m128i p1 = _mm_packus_epi16(row2, row3);
; 2666 :       __m128i p2 = _mm_packus_epi16(row4, row5);
; 2667 :       __m128i p3 = _mm_packus_epi16(row6, row7);
; 2668 : 
; 2669 :       // 8bit 8x8 transpose pass 1
; 2670 :       dct_interleave8(p0, p2); // a0e0a1e1...
; 2671 :       dct_interleave8(p1, p3); // c0g0c1g1...
; 2672 : 
; 2673 :       // transpose pass 2
; 2674 :       dct_interleave8(p0, p1); // a0c0e0g0...
; 2675 :       dct_interleave8(p2, p3); // b0d0f0h0...
; 2676 : 
; 2677 :       // transpose pass 3
; 2678 :       dct_interleave8(p0, p2); // a0b0c0d0...
; 2679 :       dct_interleave8(p1, p3); // a4b4c4d4...
; 2680 : 
; 2681 :       // store
; 2682 :       _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
; 2683 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
; 2684 :       _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
; 2685 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
; 2686 :       _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
; 2687 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
; 2688 :       _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
; 2689 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
; 2690 :    }
; 2691 : 
; 2692 : #undef dct_const
; 2693 : #undef dct_rot
; 2694 : #undef dct_widen
; 2695 : #undef dct_wadd
; 2696 : #undef dct_wsub
; 2697 : #undef dct_bfly32o
; 2698 : #undef dct_interleave8
; 2699 : #undef dct_interleave16
; 2700 : #undef dct_pass
; 2701 : }
; 2702 : 
; 2703 : #endif // STBI_SSE2
; 2704 : 
; 2705 : #ifdef STBI_NEON
; 2706 : 
; 2707 : // NEON integer IDCT. should produce bit-identical
; 2708 : // results to the generic C version.
; 2709 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2710 : {
; 2711 :    int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;
; 2712 : 
; 2713 :    int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
; 2714 :    int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
; 2715 :    int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
; 2716 :    int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
; 2717 :    int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
; 2718 :    int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
; 2719 :    int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
; 2720 :    int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
; 2721 :    int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
; 2722 :    int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
; 2723 :    int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
; 2724 :    int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));
; 2725 : 
; 2726 : #define dct_long_mul(out, inq, coeff) \
; 2727 :    int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
; 2728 :    int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)
; 2729 : 
; 2730 : #define dct_long_mac(out, acc, inq, coeff) \
; 2731 :    int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
; 2732 :    int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)
; 2733 : 
; 2734 : #define dct_widen(out, inq) \
; 2735 :    int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
; 2736 :    int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)
; 2737 : 
; 2738 : // wide add
; 2739 : #define dct_wadd(out, a, b) \
; 2740 :    int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
; 2741 :    int32x4_t out##_h = vaddq_s32(a##_h, b##_h)
; 2742 : 
; 2743 : // wide sub
; 2744 : #define dct_wsub(out, a, b) \
; 2745 :    int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
; 2746 :    int32x4_t out##_h = vsubq_s32(a##_h, b##_h)
; 2747 : 
; 2748 : // butterfly a/b, then shift using "shiftop" by "s" and pack
; 2749 : #define dct_bfly32o(out0,out1, a,b,shiftop,s) \
; 2750 :    { \
; 2751 :       dct_wadd(sum, a, b); \
; 2752 :       dct_wsub(dif, a, b); \
; 2753 :       out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
; 2754 :       out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
; 2755 :    }
; 2756 : 
; 2757 : #define dct_pass(shiftop, shift) \
; 2758 :    { \
; 2759 :       /* even part */ \
; 2760 :       int16x8_t sum26 = vaddq_s16(row2, row6); \
; 2761 :       dct_long_mul(p1e, sum26, rot0_0); \
; 2762 :       dct_long_mac(t2e, p1e, row6, rot0_1); \
; 2763 :       dct_long_mac(t3e, p1e, row2, rot0_2); \
; 2764 :       int16x8_t sum04 = vaddq_s16(row0, row4); \
; 2765 :       int16x8_t dif04 = vsubq_s16(row0, row4); \
; 2766 :       dct_widen(t0e, sum04); \
; 2767 :       dct_widen(t1e, dif04); \
; 2768 :       dct_wadd(x0, t0e, t3e); \
; 2769 :       dct_wsub(x3, t0e, t3e); \
; 2770 :       dct_wadd(x1, t1e, t2e); \
; 2771 :       dct_wsub(x2, t1e, t2e); \
; 2772 :       /* odd part */ \
; 2773 :       int16x8_t sum15 = vaddq_s16(row1, row5); \
; 2774 :       int16x8_t sum17 = vaddq_s16(row1, row7); \
; 2775 :       int16x8_t sum35 = vaddq_s16(row3, row5); \
; 2776 :       int16x8_t sum37 = vaddq_s16(row3, row7); \
; 2777 :       int16x8_t sumodd = vaddq_s16(sum17, sum35); \
; 2778 :       dct_long_mul(p5o, sumodd, rot1_0); \
; 2779 :       dct_long_mac(p1o, p5o, sum17, rot1_1); \
; 2780 :       dct_long_mac(p2o, p5o, sum35, rot1_2); \
; 2781 :       dct_long_mul(p3o, sum37, rot2_0); \
; 2782 :       dct_long_mul(p4o, sum15, rot2_1); \
; 2783 :       dct_wadd(sump13o, p1o, p3o); \
; 2784 :       dct_wadd(sump24o, p2o, p4o); \
; 2785 :       dct_wadd(sump23o, p2o, p3o); \
; 2786 :       dct_wadd(sump14o, p1o, p4o); \
; 2787 :       dct_long_mac(x4, sump13o, row7, rot3_0); \
; 2788 :       dct_long_mac(x5, sump24o, row5, rot3_1); \
; 2789 :       dct_long_mac(x6, sump23o, row3, rot3_2); \
; 2790 :       dct_long_mac(x7, sump14o, row1, rot3_3); \
; 2791 :       dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
; 2792 :       dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
; 2793 :       dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
; 2794 :       dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
; 2795 :    }
; 2796 : 
; 2797 :    // load
; 2798 :    row0 = vld1q_s16(data + 0*8);
; 2799 :    row1 = vld1q_s16(data + 1*8);
; 2800 :    row2 = vld1q_s16(data + 2*8);
; 2801 :    row3 = vld1q_s16(data + 3*8);
; 2802 :    row4 = vld1q_s16(data + 4*8);
; 2803 :    row5 = vld1q_s16(data + 5*8);
; 2804 :    row6 = vld1q_s16(data + 6*8);
; 2805 :    row7 = vld1q_s16(data + 7*8);
; 2806 : 
; 2807 :    // add DC bias
; 2808 :    row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));
; 2809 : 
; 2810 :    // column pass
; 2811 :    dct_pass(vrshrn_n_s32, 10);
; 2812 : 
; 2813 :    // 16bit 8x8 transpose
; 2814 :    {
; 2815 : // these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
; 2816 : // whether compilers actually get this is another story, sadly.
; 2817 : #define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
; 2818 : #define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
; 2819 : #define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }
; 2820 : 
; 2821 :       // pass 1
; 2822 :       dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
; 2823 :       dct_trn16(row2, row3);
; 2824 :       dct_trn16(row4, row5);
; 2825 :       dct_trn16(row6, row7);
; 2826 : 
; 2827 :       // pass 2
; 2828 :       dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
; 2829 :       dct_trn32(row1, row3);
; 2830 :       dct_trn32(row4, row6);
; 2831 :       dct_trn32(row5, row7);
; 2832 : 
; 2833 :       // pass 3
; 2834 :       dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
; 2835 :       dct_trn64(row1, row5);
; 2836 :       dct_trn64(row2, row6);
; 2837 :       dct_trn64(row3, row7);
; 2838 : 
; 2839 : #undef dct_trn16
; 2840 : #undef dct_trn32
; 2841 : #undef dct_trn64
; 2842 :    }
; 2843 : 
; 2844 :    // row pass
; 2845 :    // vrshrn_n_s32 only supports shifts up to 16, we need
; 2846 :    // 17. so do a non-rounding shift of 16 first then follow
; 2847 :    // up with a rounding shift by 1.
; 2848 :    dct_pass(vshrn_n_s32, 16);
; 2849 : 
; 2850 :    {
; 2851 :       // pack and round
; 2852 :       uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
; 2853 :       uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
; 2854 :       uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
; 2855 :       uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
; 2856 :       uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
; 2857 :       uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
; 2858 :       uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
; 2859 :       uint8x8_t p7 = vqrshrun_n_s16(row7, 1);
; 2860 : 
; 2861 :       // again, these can translate into one instruction, but often don't.
; 2862 : #define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
; 2863 : #define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
; 2864 : #define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }
; 2865 : 
; 2866 :       // sadly can't use interleaved stores here since we only write
; 2867 :       // 8 bytes to each scan line!
; 2868 : 
; 2869 :       // 8x8 8-bit transpose pass 1
; 2870 :       dct_trn8_8(p0, p1);
; 2871 :       dct_trn8_8(p2, p3);
; 2872 :       dct_trn8_8(p4, p5);
; 2873 :       dct_trn8_8(p6, p7);
; 2874 : 
; 2875 :       // pass 2
; 2876 :       dct_trn8_16(p0, p2);
; 2877 :       dct_trn8_16(p1, p3);
; 2878 :       dct_trn8_16(p4, p6);
; 2879 :       dct_trn8_16(p5, p7);
; 2880 : 
; 2881 :       // pass 3
; 2882 :       dct_trn8_32(p0, p4);
; 2883 :       dct_trn8_32(p1, p5);
; 2884 :       dct_trn8_32(p2, p6);
; 2885 :       dct_trn8_32(p3, p7);
; 2886 : 
; 2887 :       // store
; 2888 :       vst1_u8(out, p0); out += out_stride;
; 2889 :       vst1_u8(out, p1); out += out_stride;
; 2890 :       vst1_u8(out, p2); out += out_stride;
; 2891 :       vst1_u8(out, p3); out += out_stride;
; 2892 :       vst1_u8(out, p4); out += out_stride;
; 2893 :       vst1_u8(out, p5); out += out_stride;
; 2894 :       vst1_u8(out, p6); out += out_stride;
; 2895 :       vst1_u8(out, p7);
; 2896 : 
; 2897 : #undef dct_trn8_8
; 2898 : #undef dct_trn8_16
; 2899 : #undef dct_trn8_32
; 2900 :    }
; 2901 : 
; 2902 : #undef dct_long_mul
; 2903 : #undef dct_long_mac
; 2904 : #undef dct_widen
; 2905 : #undef dct_wadd
; 2906 : #undef dct_wsub
; 2907 : #undef dct_bfly32o
; 2908 : #undef dct_pass
; 2909 : }
; 2910 : 
; 2911 : #endif // STBI_NEON
; 2912 : 
; 2913 : #define STBI__MARKER_none  0xff
; 2914 : // if there's a pending marker from the entropy stream, return that
; 2915 : // otherwise, fetch from the stream and get a marker. if there's no
; 2916 : // marker, return 0xff, which is never a valid marker value
; 2917 : static stbi_uc stbi__get_marker(stbi__jpeg *j)
; 2918 : {
; 2919 :    stbi_uc x;
; 2920 :    if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
; 2921 :    x = stbi__get8(j->s);
; 2922 :    if (x != 0xff) return STBI__MARKER_none;
; 2923 :    while (x == 0xff)
; 2924 :       x = stbi__get8(j->s); // consume repeated 0xff fill bytes
; 2925 :    return x;
; 2926 : }
; 2927 : 
; 2928 : // in each scan, we'll have scan_n components, and the order
; 2929 : // of the components is specified by order[]
; 2930 : #define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
; 2931 : 
; 2932 : // after a restart interval, stbi__jpeg_reset the entropy decoder and
; 2933 : // the dc prediction
; 2934 : static void stbi__jpeg_reset(stbi__jpeg *j)
; 2935 : {
; 2936 :    j->code_bits = 0;
; 2937 :    j->code_buffer = 0;
; 2938 :    j->nomore = 0;
; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
; 2940 :    j->marker = STBI__MARKER_none;
; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
; 2942 :    j->eob_run = 0;
; 2943 :    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2944 :    // since we don't even allow 1<<30 pixels
; 2945 : }
; 2946 : 
; 2947 : static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
; 2948 : {
; 2949 :    stbi__jpeg_reset(z);
; 2950 :    if (!z->progressive) {
; 2951 :       if (z->scan_n == 1) {
; 2952 :          int i,j;
; 2953 :          STBI_SIMD_ALIGN(short, data[64]);
; 2954 :          int n = z->order[0];
; 2955 :          // non-interleaved data, we just need to process one block at a time,
; 2956 :          // in trivial scanline order
; 2957 :          // number of blocks to do just depends on how many actual "pixels" this
; 2958 :          // component has, independent of interleaved MCU blocking and such
; 2959 :          int w = (z->img_comp[n].x+7) >> 3;
; 2960 :          int h = (z->img_comp[n].y+7) >> 3;
; 2961 :          for (j=0; j < h; ++j) {
; 2962 :             for (i=0; i < w; ++i) {
; 2963 :                int ha = z->img_comp[n].ha;
; 2964 :                if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2965 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 2966 :                // every data block is an MCU, so countdown the restart interval
; 2967 :                if (--z->todo <= 0) {
; 2968 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 2969 :                   // if it's NOT a restart, then just bail, so we get corrupt data
; 2970 :                   // rather than no data
; 2971 :                   if (!STBI__RESTART(z->marker)) return 1;
; 2972 :                   stbi__jpeg_reset(z);
; 2973 :                }
; 2974 :             }
; 2975 :          }
; 2976 :          return 1;
; 2977 :       } else { // interleaved
; 2978 :          int i,j,k,x,y;
; 2979 :          STBI_SIMD_ALIGN(short, data[64]);
; 2980 :          for (j=0; j < z->img_mcu_y; ++j) {
; 2981 :             for (i=0; i < z->img_mcu_x; ++i) {
; 2982 :                // scan an interleaved mcu... process scan_n components in order
; 2983 :                for (k=0; k < z->scan_n; ++k) {
; 2984 :                   int n = z->order[k];
; 2985 :                   // scan out an mcu's worth of this component; that's just determined
; 2986 :                   // by the basic H and V specified for the component
; 2987 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 2988 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 2989 :                         int x2 = (i*z->img_comp[n].h + x)*8;
; 2990 :                         int y2 = (j*z->img_comp[n].v + y)*8;
; 2991 :                         int ha = z->img_comp[n].ha;
; 2992 :                         if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2993 :                         z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
; 2994 :                      }
; 2995 :                   }
; 2996 :                }
; 2997 :                // after all interleaved components, that's an interleaved MCU,
; 2998 :                // so now count down the restart interval
; 2999 :                if (--z->todo <= 0) {
; 3000 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3001 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3002 :                   stbi__jpeg_reset(z);
; 3003 :                }
; 3004 :             }
; 3005 :          }
; 3006 :          return 1;
; 3007 :       }
; 3008 :    } else {
; 3009 :       if (z->scan_n == 1) {
; 3010 :          int i,j;
; 3011 :          int n = z->order[0];
; 3012 :          // non-interleaved data, we just need to process one block at a time,
; 3013 :          // in trivial scanline order
; 3014 :          // number of blocks to do just depends on how many actual "pixels" this
; 3015 :          // component has, independent of interleaved MCU blocking and such
; 3016 :          int w = (z->img_comp[n].x+7) >> 3;
; 3017 :          int h = (z->img_comp[n].y+7) >> 3;
; 3018 :          for (j=0; j < h; ++j) {
; 3019 :             for (i=0; i < w; ++i) {
; 3020 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3021 :                if (z->spec_start == 0) {
; 3022 :                   if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3023 :                      return 0;
; 3024 :                } else {
; 3025 :                   int ha = z->img_comp[n].ha;
; 3026 :                   if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
; 3027 :                      return 0;
; 3028 :                }
; 3029 :                // every data block is an MCU, so countdown the restart interval
; 3030 :                if (--z->todo <= 0) {
; 3031 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3032 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3033 :                   stbi__jpeg_reset(z);
; 3034 :                }
; 3035 :             }
; 3036 :          }
; 3037 :          return 1;
; 3038 :       } else { // interleaved
; 3039 :          int i,j,k,x,y;
; 3040 :          for (j=0; j < z->img_mcu_y; ++j) {
; 3041 :             for (i=0; i < z->img_mcu_x; ++i) {
; 3042 :                // scan an interleaved mcu... process scan_n components in order
; 3043 :                for (k=0; k < z->scan_n; ++k) {
; 3044 :                   int n = z->order[k];
; 3045 :                   // scan out an mcu's worth of this component; that's just determined
; 3046 :                   // by the basic H and V specified for the component
; 3047 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 3048 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 3049 :                         int x2 = (i*z->img_comp[n].h + x);
; 3050 :                         int y2 = (j*z->img_comp[n].v + y);
; 3051 :                         short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
; 3052 :                         if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3053 :                            return 0;
; 3054 :                      }
; 3055 :                   }
; 3056 :                }
; 3057 :                // after all interleaved components, that's an interleaved MCU,
; 3058 :                // so now count down the restart interval
; 3059 :                if (--z->todo <= 0) {
; 3060 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3061 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3062 :                   stbi__jpeg_reset(z);
; 3063 :                }
; 3064 :             }
; 3065 :          }
; 3066 :          return 1;
; 3067 :       }
; 3068 :    }
; 3069 : }
; 3070 : 
; 3071 : static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
; 3072 : {
; 3073 :    int i;
; 3074 :    for (i=0; i < 64; ++i)
; 3075 :       data[i] *= dequant[i];
; 3076 : }
; 3077 : 
; 3078 : static void stbi__jpeg_finish(stbi__jpeg *z)
; 3079 : {
; 3080 :    if (z->progressive) {
; 3081 :       // dequantize and idct the data
; 3082 :       int i,j,n;
; 3083 :       for (n=0; n < z->s->img_n; ++n) {
; 3084 :          int w = (z->img_comp[n].x+7) >> 3;
; 3085 :          int h = (z->img_comp[n].y+7) >> 3;
; 3086 :          for (j=0; j < h; ++j) {
; 3087 :             for (i=0; i < w; ++i) {
; 3088 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3089 :                stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
; 3090 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 3091 :             }
; 3092 :          }
; 3093 :       }
; 3094 :    }
; 3095 : }
; 3096 : 
; 3097 : static int stbi__process_marker(stbi__jpeg *z, int m)
; 3098 : {
; 3099 :    int L;
; 3100 :    switch (m) {
; 3101 :       case STBI__MARKER_none: // no marker found
; 3102 :          return stbi__err("expected marker","Corrupt JPEG");
; 3103 : 
; 3104 :       case 0xDD: // DRI - specify restart interval
; 3105 :          if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
; 3106 :          z->restart_interval = stbi__get16be(z->s);
; 3107 :          return 1;
; 3108 : 
; 3109 :       case 0xDB: // DQT - define quantization table
; 3110 :          L = stbi__get16be(z->s)-2;
; 3111 :          while (L > 0) {
; 3112 :             int q = stbi__get8(z->s);
; 3113 :             int p = q >> 4, sixteen = (p != 0);
; 3114 :             int t = q & 15,i;
; 3115 :             if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
; 3116 :             if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");
; 3117 : 
; 3118 :             for (i=0; i < 64; ++i)
; 3119 :                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
; 3120 :             L -= (sixteen ? 129 : 65);
; 3121 :          }
; 3122 :          return L==0;
; 3123 : 
; 3124 :       case 0xC4: // DHT - define huffman table
; 3125 :          L = stbi__get16be(z->s)-2;
; 3126 :          while (L > 0) {
; 3127 :             stbi_uc *v;
; 3128 :             int sizes[16],i,n=0;
; 3129 :             int q = stbi__get8(z->s);
; 3130 :             int tc = q >> 4;
; 3131 :             int th = q & 15;
; 3132 :             if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
; 3133 :             for (i=0; i < 16; ++i) {
; 3134 :                sizes[i] = stbi__get8(z->s);
; 3135 :                n += sizes[i];
; 3136 :             }
; 3137 :             if(n > 256) return stbi__err("bad DHT header","Corrupt JPEG"); // Loop over i < n would write past end of values!
; 3138 :             L -= 17;
; 3139 :             if (tc == 0) {
; 3140 :                if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
; 3141 :                v = z->huff_dc[th].values;
; 3142 :             } else {
; 3143 :                if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
; 3144 :                v = z->huff_ac[th].values;
; 3145 :             }
; 3146 :             for (i=0; i < n; ++i)
; 3147 :                v[i] = stbi__get8(z->s);
; 3148 :             if (tc != 0)
; 3149 :                stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
; 3150 :             L -= n;
; 3151 :          }
; 3152 :          return L==0;
; 3153 :    }
; 3154 : 
; 3155 :    // check for comment block or APP blocks
; 3156 :    if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
; 3157 :       L = stbi__get16be(z->s);
; 3158 :       if (L < 2) {
; 3159 :          if (m == 0xFE)
; 3160 :             return stbi__err("bad COM len","Corrupt JPEG");
; 3161 :          else
; 3162 :             return stbi__err("bad APP len","Corrupt JPEG");
; 3163 :       }
; 3164 :       L -= 2;
; 3165 : 
; 3166 :       if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
; 3167 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3168 :          int ok = 1;
; 3169 :          int i;
; 3170 :          for (i=0; i < 5; ++i)
; 3171 :             if (stbi__get8(z->s) != tag[i])
; 3172 :                ok = 0;
; 3173 :          L -= 5;
; 3174 :          if (ok)
; 3175 :             z->jfif = 1;
; 3176 :       } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;
; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)
; 3181 :             if (stbi__get8(z->s) != tag[i])
; 3182 :                ok = 0;
; 3183 :          L -= 6;
; 3184 :          if (ok) {
; 3185 :             stbi__get8(z->s); // version
; 3186 :             stbi__get16be(z->s); // flags0
; 3187 :             stbi__get16be(z->s); // flags1
; 3188 :             z->app14_color_transform = stbi__get8(z->s); // color transform
; 3189 :             L -= 6;
; 3190 :          }
; 3191 :       }
; 3192 : 
; 3193 :       stbi__skip(z->s, L);
; 3194 :       return 1;
; 3195 :    }
; 3196 : 
; 3197 :    return stbi__err("unknown marker","Corrupt JPEG");
; 3198 : }
; 3199 : 
; 3200 : // after we see SOS
; 3201 : static int stbi__process_scan_header(stbi__jpeg *z)
; 3202 : {
; 3203 :    int i;
; 3204 :    int Ls = stbi__get16be(z->s);
; 3205 :    z->scan_n = stbi__get8(z->s);
; 3206 :    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
; 3207 :    if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
; 3208 :    for (i=0; i < z->scan_n; ++i) {
; 3209 :       int id = stbi__get8(z->s), which;
; 3210 :       int q = stbi__get8(z->s);
; 3211 :       for (which = 0; which < z->s->img_n; ++which)
; 3212 :          if (z->img_comp[which].id == id)
; 3213 :             break;
; 3214 :       if (which == z->s->img_n) return 0; // no match
; 3215 :       z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
; 3216 :       z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
; 3217 :       z->order[i] = which;
; 3218 :    }
; 3219 : 
; 3220 :    {
; 3221 :       int aa;
; 3222 :       z->spec_start = stbi__get8(z->s);
; 3223 :       z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
; 3224 :       aa = stbi__get8(z->s);
; 3225 :       z->succ_high = (aa >> 4);
; 3226 :       z->succ_low  = (aa & 15);
; 3227 :       if (z->progressive) {
; 3228 :          if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
; 3229 :             return stbi__err("bad SOS", "Corrupt JPEG");
; 3230 :       } else {
; 3231 :          if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3232 :          if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3233 :          z->spec_end = 63;
; 3234 :       }
; 3235 :    }
; 3236 : 
; 3237 :    return 1;
; 3238 : }
; 3239 : 
; 3240 : static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
; 3241 : {
; 3242 :    int i;
; 3243 :    for (i=0; i < ncomp; ++i) {

	add	rdi, 96					; 00000060H
	sub	rbx, r14
	jne	SHORT $LL172@load_jpeg_
$LN171@load_jpeg_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	mov	QWORD PTR [rdx+rcx], rax

; 3921 :       if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

	xor	eax, eax
$LN372@load_jpeg_:
	mov	rsi, QWORD PTR [rsp+368]
	mov	r13, QWORD PTR [rsp+360]
$LN1@load_jpeg_:

; 4023 :    }
; 4024 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 376				; 00000178H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z ENDP	; load_jpeg_image
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
_TEXT	SEGMENT
s$ = 64
x$ = 72
y$ = 80
comp$ = 88
req_comp$dead$ = 96
ri$dead$ = 104
?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__jpeg_load, COMDAT

; 4027 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	r14, rcx
	mov	rbx, r9

; 985  :     return STBI_MALLOC(size);

	mov	ecx, 18568				; 00004888H

; 4027 : {

	mov	rsi, r8
	mov	rbp, rdx

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc
	mov	rdi, rax

; 4028 :    unsigned char* result;
; 4029 :    stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
; 4030 :    if (!j) return stbi__errpuc("outofmem", "Out of memory");

	test	rax, rax
	jne	SHORT $LN2@stbi__jpeg

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	mov	QWORD PTR [rdx+rcx], rax

; 4028 :    unsigned char* result;
; 4029 :    stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
; 4030 :    if (!j) return stbi__errpuc("outofmem", "Out of memory");

	xor	eax, eax
	jmp	SHORT $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 4031 :    memset(j, 0, sizeof(stbi__jpeg));

	lea	rcx, QWORD PTR [rax+8]
	xor	edx, edx
	mov	r8d, 18560				; 00004880H
	call	memset

; 4032 :    STBI_NOTUSED(ri);
; 4033 :    j->s = s;
; 4034 :    stbi__setup_jpeg(j);

	mov	rcx, rdi
	mov	QWORD PTR [rdi], r14
	call	?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__setup_jpeg

; 4035 :    result = load_jpeg_image(j, x,y,comp,req_comp);

	mov	r8, rsi
	mov	DWORD PTR [rsp+32], 4
	mov	rdx, rbp
	mov	rcx, rdi
	mov	r9, rbx
	call	?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z ; load_jpeg_image

; 4036 :    STBI_FREE(j);

	mov	rcx, rdi
	mov	rbx, rax
	call	QWORD PTR __imp_free

; 4037 :    return result;

	mov	rax, rbx
$LN1@stbi__jpeg:

; 4038 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__jpeg_load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__jpeg_test, COMDAT

; 4041 : {

	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 985  :     return STBI_MALLOC(size);

	mov	ecx, 18568				; 00004888H
	call	QWORD PTR __imp_malloc
	mov	rbx, rax

; 4042 :    int r;
; 4043 :    stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
; 4044 :    if (!j) return stbi__err("outofmem", "Out of memory");

	test	rax, rax
	jne	SHORT $LN2@stbi__jpeg

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	mov	QWORD PTR [rdx+rcx], rax

; 4042 :    int r;
; 4043 :    stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
; 4044 :    if (!j) return stbi__err("outofmem", "Out of memory");

	xor	eax, eax

; 4051 :    return r;
; 4052 : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@stbi__jpeg:

; 4045 :    memset(j, 0, sizeof(stbi__jpeg));

	lea	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+48], rsi
	xor	edx, edx
	mov	r8d, 18560				; 00004880H
	call	memset

; 4046 :    j->s = s;
; 4047 :    stbi__setup_jpeg(j);

	mov	rcx, rbx
	mov	QWORD PTR [rbx], rdi
	call	?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__setup_jpeg

; 3366 :    z->jfif = 0;

	xor	esi, esi

; 3367 :    z->app14_color_transform = -1; // valid values are 0,1,2

	mov	DWORD PTR [rbx+18508], -1

; 3368 :    z->marker = STBI__MARKER_none; // initialize cached marker to empty
; 3369 :    m = stbi__get_marker(z);

	mov	rcx, rbx
	mov	DWORD PTR [rbx+18504], esi
	mov	BYTE PTR [rbx+18472], 255		; 000000ffH
	call	?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker

; 3370 :    if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");

	cmp	al, 216					; 000000d8H
	je	SHORT $LN13@stbi__jpeg

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_06CLMBLEP@no?5SOI@
	mov	QWORD PTR [rdx+rcx], rax

; 3370 :    if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");

	jmp	SHORT $LN8@stbi__jpeg
$LN13@stbi__jpeg:

; 3371 :    if (scan == STBI__SCAN_type) return 1;

	mov	esi, 1
$LN8@stbi__jpeg:

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	rdx, QWORD PTR [rdi+208]

; 4048 :    r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
; 4049 :    stbi__rewind(s);
; 4050 :    STBI_FREE(j);

	mov	rcx, rbx

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	QWORD PTR [rdi+192], rdx

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	rdx, QWORD PTR [rdi+216]
	mov	QWORD PTR [rdi+200], rdx

; 4048 :    r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
; 4049 :    stbi__rewind(s);
; 4050 :    STBI_FREE(j);

	call	QWORD PTR __imp_free

; 4051 :    return r;
; 4052 : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	eax, esi
	mov	rsi, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__jpeg_test
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__bitreverse16@@YAHH@Z
_TEXT	SEGMENT
n$ = 8
?stbi__bitreverse16@@YAHH@Z PROC			; stbi__bitreverse16, COMDAT

; 4107 :   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);

	mov	eax, ecx
	and	ecx, 21845				; 00005555H
	sar	eax, 1
	add	ecx, ecx
	and	eax, 21845				; 00005555H
	or	eax, ecx

; 4108 :   n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);

	mov	edx, eax
	and	eax, 13107				; 00003333H
	shr	edx, 2
	shl	eax, 2
	and	edx, 13107				; 00003333H
	or	edx, eax

; 4109 :   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);

	mov	ecx, edx
	and	edx, 3855				; 00000f0fH
	shr	ecx, 4
	and	ecx, 3855				; 00000f0fH
	shl	edx, 4
	or	ecx, edx

; 4110 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);

	movzx	eax, cl
	shl	eax, 8
	shr	ecx, 8
	or	eax, ecx

; 4111 :   return n;
; 4112 : }

	ret	0
?stbi__bitreverse16@@YAHH@Z ENDP			; stbi__bitreverse16
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__bit_reverse@@YAHHH@Z
_TEXT	SEGMENT
v$ = 8
bits$ = 16
?stbi__bit_reverse@@YAHHH@Z PROC			; stbi__bit_reverse, COMDAT

; 4107 :   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);

	mov	eax, ecx

; 4115 : {

	mov	r8d, edx

; 4107 :   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);

	sar	eax, 1
	and	ecx, 21845				; 00005555H
	add	ecx, ecx
	and	eax, 21845				; 00005555H
	or	eax, ecx

; 4108 :   n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);

	mov	edx, eax
	and	eax, 13107				; 00003333H
	shl	eax, 2
	shr	edx, 2
	and	edx, 13107				; 00003333H
	or	edx, eax

; 4109 :   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);

	mov	ecx, edx
	and	edx, 3855				; 00000f0fH
	shr	ecx, 4
	and	ecx, 3855				; 00000f0fH
	shl	edx, 4
	or	ecx, edx

; 4110 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);

	movzx	eax, cl

; 4116 :    STBI_ASSERT(bits <= 16);
; 4117 :    // to bit reverse n bits, reverse 16 and shift
; 4118 :    // e.g. 11 bits, bit reverse and shift away 5
; 4119 :    return stbi__bitreverse16(v) >> (16-bits);

	shr	ecx, 8

; 4110 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);

	shl	eax, 8
	or	eax, ecx

; 4116 :    STBI_ASSERT(bits <= 16);
; 4117 :    // to bit reverse n bits, reverse 16 and shift
; 4118 :    // e.g. 11 bits, bit reverse and shift away 5
; 4119 :    return stbi__bitreverse16(v) >> (16-bits);

	mov	ecx, 16
	sub	ecx, r8d
	sar	eax, cl

; 4120 : }

	ret	0
?stbi__bit_reverse@@YAHHH@Z ENDP			; stbi__bit_reverse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
_TEXT	SEGMENT
next_code$ = 32
sizes$ = 96
__$ArrayPad$ = 176
z$ = 240
sizelist$ = 248
num$ = 256
?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z PROC ; stbi__zbuild_huffman, COMDAT

; 4123 : {

	mov	r11, rsp
	push	rbx
	push	rbp
	push	rdi
	push	r14
	push	r15
	sub	rsp, 192				; 000000c0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	xorps	xmm0, xmm0
	mov	r15d, r8d

; 4124 :    int i,k=0;
; 4125 :    int code, next_code[16], sizes[17];
; 4126 : 
; 4127 :    // DEFLATE spec for generating codes
; 4128 :    memset(sizes, 0, sizeof(sizes));

	movups	XMMWORD PTR sizes$[rsp], xmm0
	mov	r14, rdx
	xor	eax, eax
	movups	XMMWORD PTR sizes$[rsp+16], xmm0
	xor	edi, edi
	mov	DWORD PTR [r11-72], eax

; 4129 :    memset(z->fast, 0, sizeof(z->fast));

	xor	edx, edx
	mov	r8d, 1024				; 00000400H
	movups	XMMWORD PTR [r11-104], xmm0
	mov	rbx, rcx
	mov	ebp, edi
	movups	XMMWORD PTR [r11-88], xmm0
	call	memset

; 4130 :    for (i=0; i < num; ++i)

	test	r15d, r15d
	jle	SHORT $LN3@stbi__zbui

; 4123 : {

	mov	rcx, r14
	mov	edx, r15d
	npad	11
$LL4@stbi__zbui:

; 4131 :       ++sizes[sizelist[i]];

	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	inc	DWORD PTR sizes$[rsp+rax*4]
	sub	rdx, 1
	jne	SHORT $LL4@stbi__zbui
$LN3@stbi__zbui:

; 4132 :    sizes[0] = 0;

	mov	DWORD PTR sizes$[rsp], edi

; 4133 :    for (i=1; i < 16; ++i)

	mov	ecx, 1
	npad	6
$LL7@stbi__zbui:

; 4134 :       if (sizes[i] > (1 << i))

	movsxd	rdx, ecx
	mov	eax, 1
	shl	eax, cl
	cmp	DWORD PTR sizes$[rsp+rdx*4], eax
	jg	$LN35@stbi__zbui

; 4133 :    for (i=1; i < 16; ++i)

	inc	ecx
	cmp	ecx, 16
	jl	SHORT $LL7@stbi__zbui

; 4136 :    code = 0;
; 4137 :    for (i=1; i < 16; ++i) {

	mov	r10d, 1
	mov	QWORD PTR [rsp+256], rsi
	mov	r8d, edi
	lea	r11d, QWORD PTR [r10+14]
$LL10@stbi__zbui:

; 4138 :       next_code[i] = code;

	movsxd	r9, r10d

; 4139 :       z->firstcode[i] = (stbi__uint16) code;
; 4140 :       z->firstsymbol[i] = (stbi__uint16) k;
; 4141 :       code = (code + sizes[i]);

	mov	esi, DWORD PTR sizes$[rsp+r9*4]
	mov	DWORD PTR next_code$[rsp+r9*4], r8d
	mov	WORD PTR [rbx+r9*2+1024], r8w
	add	r8d, esi
	mov	WORD PTR [rbx+r9*2+1124], bp

; 4142 :       if (sizes[i])

	test	esi, esi
	je	SHORT $LN18@stbi__zbui

; 4143 :          if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");

	mov	ecx, r10d
	lea	eax, DWORD PTR [r8-1]
	mov	edx, 1
	shl	edx, cl
	cmp	eax, edx
	jge	$LN36@stbi__zbui
$LN18@stbi__zbui:

; 4144 :       z->maxcode[i] = code << (16-i); // preshift for inner loop

	mov	ecx, r11d
	mov	eax, r8d
	shl	eax, cl

; 4145 :       code <<= 1;

	add	r8d, r8d

; 4146 :       k += sizes[i];

	add	ebp, esi
	mov	DWORD PTR [rbx+r9*4+1056], eax
	inc	r10d
	dec	r11d
	test	r11d, r11d
	jg	SHORT $LL10@stbi__zbui

; 4147 :    }
; 4148 :    z->maxcode[16] = 0x10000; // sentinel

	mov	DWORD PTR [rbx+1120], 65536		; 00010000H

; 4149 :    for (i=0; i < num; ++i) {

	test	r15d, r15d
	jle	$LN12@stbi__zbui
	npad	1
$LL13@stbi__zbui:

; 4150 :       int s = sizelist[i];

	movzx	r9d, BYTE PTR [r14]

; 4151 :       if (s) {

	test	r9d, r9d
	je	$LN11@stbi__zbui

; 4152 :          int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];

	movzx	eax, WORD PTR [rbx+r9*2+1024]
	lea	r11, QWORD PTR next_code$[rsp]
	movzx	ecx, WORD PTR [rbx+r9*2+1124]
	lea	r11, QWORD PTR [r11+r9*4]
	mov	r10d, DWORD PTR [r11]
	sub	ecx, eax

; 4153 :          stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);

	movzx	r8d, r9w
	shl	r8w, 9
	or	r8w, di
	lea	eax, DWORD PTR [r10+rcx]

; 4154 :          z->size [c] = (stbi_uc     ) s;

	cdqe
	mov	BYTE PTR [rax+rbx+1156], r9b

; 4155 :          z->value[c] = (stbi__uint16) i;

	mov	WORD PTR [rbx+rax*2+1444], di

; 4156 :          if (s <= STBI__ZFAST_BITS) {

	cmp	r9d, 9
	ja	$LN15@stbi__zbui

; 4107 :   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);

	mov	ecx, r10d
	mov	eax, r10d
	and	eax, 21845				; 00005555H
	sar	ecx, 1
	add	eax, eax
	and	ecx, 21845				; 00005555H
	or	ecx, eax

; 4108 :   n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);

	mov	eax, ecx
	and	ecx, 13107				; 00003333H
	shr	eax, 2
	and	eax, 13107				; 00003333H
	shl	ecx, 2
	or	eax, ecx

; 4119 :    return stbi__bitreverse16(v) >> (16-bits);

	mov	ecx, 16

; 4109 :   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);

	mov	edx, eax

; 4119 :    return stbi__bitreverse16(v) >> (16-bits);

	sub	ecx, r9d

; 4109 :   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);

	and	eax, 3855				; 00000f0fH
	shr	edx, 4
	shl	eax, 4
	and	edx, 3855				; 00000f0fH
	or	edx, eax

; 4157 :             int j = stbi__bit_reverse(next_code[s],s);

	mov	eax, edx

; 4110 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);

	movzx	edx, dl

; 4157 :             int j = stbi__bit_reverse(next_code[s],s);

	sar	eax, 8

; 4110 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);

	movzx	eax, al
	shl	edx, 8
	or	eax, edx

; 4119 :    return stbi__bitreverse16(v) >> (16-bits);

	sar	eax, cl

; 4158 :             while (j < (1 << STBI__ZFAST_BITS)) {

	cmp	eax, 512				; 00000200H
	jge	SHORT $LN15@stbi__zbui
	mov	ecx, r9d
	mov	edx, 1
	shl	edx, cl
	npad	10
$LL14@stbi__zbui:

; 4159 :                z->fast[j] = fastv;

	movsxd	rcx, eax

; 4160 :                j += (1 << s);

	add	eax, edx
	mov	WORD PTR [rbx+rcx*2], r8w
	cmp	eax, 512				; 00000200H
	jl	SHORT $LL14@stbi__zbui
$LN15@stbi__zbui:

; 4161 :             }
; 4162 :          }
; 4163 :          ++next_code[s];

	lea	ecx, DWORD PTR [r10+1]
	mov	DWORD PTR [r11], ecx
$LN11@stbi__zbui:

; 4149 :    for (i=0; i < num; ++i) {

	inc	edi
	inc	r14
	cmp	edi, r15d
	jl	$LL13@stbi__zbui
$LN12@stbi__zbui:

; 4164 :       }
; 4165 :    }
; 4166 :    return 1;

	mov	eax, 1
$LN62@stbi__zbui:
	mov	rsi, QWORD PTR [rsp+256]
$LN1@stbi__zbui:

; 4167 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 192				; 000000c0H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN36@stbi__zbui:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BA@MDNKOBMC@bad?5codelengths@
	mov	QWORD PTR [rdx+rcx], rax

; 4143 :          if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");

	xor	eax, eax
	jmp	SHORT $LN62@stbi__zbui
$LN35@stbi__zbui:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_09EOHLEIKL@bad?5sizes@
	mov	QWORD PTR [rdx+rcx], rax

; 4135 :          return stbi__err("bad sizes", "Corrupt PNG");

	xor	eax, eax
	jmp	SHORT $LN1@stbi__zbui
?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z ENDP ; stbi__zbuild_huffman
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z
_TEXT	SEGMENT
z$ = 8
?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z PROC			; stbi__zeof, COMDAT

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

	mov	rdx, QWORD PTR [rcx+8]
	xor	eax, eax
	cmp	QWORD PTR [rcx], rdx
	setae	al

; 4192 : }

	ret	0
?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z ENDP			; stbi__zeof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z
_TEXT	SEGMENT
z$ = 8
?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z PROC		; stbi__zget8, COMDAT

; 4195 : {

	mov	rdx, rcx

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

	mov	rcx, QWORD PTR [rcx]
	cmp	rcx, QWORD PTR [rdx+8]

; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;

	jb	SHORT $LN3@stbi__zget
	xor	al, al

; 4197 : }

	ret	0
$LN3@stbi__zget:

; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;

	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	mov	QWORD PTR [rdx], rcx

; 4197 : }

	ret	0
?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z ENDP		; stbi__zget8
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z
_TEXT	SEGMENT
z$ = 8
?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z PROC		; stbi__fill_bits, COMDAT

; 4200 : {

	mov	rax, rcx
	npad	13
$LL4@stbi__fill:

; 4201 :    do {
; 4202 :       if (z->code_buffer >= (1U << z->num_bits)) {

	mov	r8d, DWORD PTR [rax+16]
	mov	edx, 1
	mov	r9d, DWORD PTR [rax+20]
	mov	ecx, r8d
	shl	edx, cl
	cmp	r9d, edx
	jae	SHORT $LN14@stbi__fill

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

	mov	rcx, QWORD PTR [rax]
	cmp	rcx, QWORD PTR [rax+8]

; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;

	jb	SHORT $LN9@stbi__fill
	xor	dl, dl
	jmp	SHORT $LN10@stbi__fill
$LN9@stbi__fill:
	movzx	edx, BYTE PTR [rcx]
	inc	rcx
	mov	QWORD PTR [rax], rcx
$LN10@stbi__fill:

; 4204 :         return;
; 4205 :       }
; 4206 :       z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;

	movzx	edx, dl
	mov	ecx, r8d
	shl	edx, cl

; 4207 :       z->num_bits += 8;

	lea	ecx, DWORD PTR [r8+8]
	or	edx, r9d
	mov	DWORD PTR [rax+16], ecx
	mov	DWORD PTR [rax+20], edx

; 4208 :    } while (z->num_bits <= 24);

	cmp	ecx, 24
	jg	SHORT $LN3@stbi__fill
	jmp	SHORT $LL4@stbi__fill
$LN14@stbi__fill:

; 4203 :         z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */

	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], rcx
$LN3@stbi__fill:

; 4209 : }

	ret	0
?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z ENDP		; stbi__fill_bits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z
_TEXT	SEGMENT
z$ = 48
n$ = 56
?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z PROC		; stbi__zreceive, COMDAT

; 4212 : {

	sub	rsp, 40					; 00000028H
	mov	r11d, edx
	mov	r10, rcx

; 4213 :    unsigned int k;
; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

	cmp	DWORD PTR [rcx+16], edx
	jge	SHORT $LN2@stbi__zrec
	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
$LN2@stbi__zrec:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

	mov	r8d, DWORD PTR [r10+20]

; 4216 :    z->code_buffer >>= n;

	mov	ecx, r11d

; 4217 :    z->num_bits -= n;

	sub	DWORD PTR [r10+16], r11d
	mov	eax, r8d
	shr	eax, cl
	mov	DWORD PTR [r10+20], eax
	mov	eax, 1
	shl	eax, cl
	dec	eax
	and	eax, r8d

; 4218 :    return k;
; 4219 : }

	add	rsp, 40					; 00000028H
	ret	0
?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ENDP		; stbi__zreceive
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z
_TEXT	SEGMENT
a$ = 8
z$ = 16
?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z PROC ; stbi__zhuffman_decode_slowpath, COMDAT

; 4119 :    return stbi__bitreverse16(v) >> (16-bits);

	mov	r10d, DWORD PTR [rcx+20]

; 4222 : {

	mov	r11, rcx

; 4107 :   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);

	mov	r8d, r10d
	mov	eax, r10d
	sar	r8d, 1
	and	eax, 21845				; 00005555H
	add	eax, eax
	and	r8d, 21845				; 00005555H
	or	r8d, eax

; 4222 : {

	mov	r9, rdx

; 4108 :   n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);

	mov	ecx, r8d
	and	r8d, 13107				; 00003333H
	shr	ecx, 2
	and	ecx, 13107				; 00003333H
	shl	r8d, 2
	or	ecx, r8d

; 4109 :   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);

	mov	eax, ecx
	and	ecx, 3855				; 00000f0fH
	shr	eax, 4
	and	eax, 3855				; 00000f0fH
	shl	ecx, 4
	or	eax, ecx

; 4228 :       if (k < z->maxcode[s])

	lea	rcx, QWORD PTR [rdx+1096]

; 4110 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);

	movzx	r8d, al
	shr	eax, 8
	shl	r8d, 8
	or	r8d, eax

; 4223 :    int b,s,k;
; 4224 :    // not resolved by fast table, so compute it the slow way
; 4225 :    // use jpeg approach, which requires MSbits at top
; 4226 :    k = stbi__bit_reverse(a->code_buffer, 16);
; 4227 :    for (s=STBI__ZFAST_BITS+1; ; ++s)

	mov	eax, 10

; 4228 :       if (k < z->maxcode[s])

	cmp	r8d, DWORD PTR [rcx]
	jl	SHORT $LN6@stbi__zhuf
$LL4@stbi__zhuf:

; 4223 :    int b,s,k;
; 4224 :    // not resolved by fast table, so compute it the slow way
; 4225 :    // use jpeg approach, which requires MSbits at top
; 4226 :    k = stbi__bit_reverse(a->code_buffer, 16);
; 4227 :    for (s=STBI__ZFAST_BITS+1; ; ++s)

	inc	eax
	lea	rcx, QWORD PTR [rcx+4]

; 4228 :       if (k < z->maxcode[s])

	cmp	r8d, DWORD PTR [rcx]
	jge	SHORT $LL4@stbi__zhuf

; 4229 :          break;
; 4230 :    if (s >= 16) return -1; // invalid code!

	cmp	eax, 16
	jge	SHORT $LN20@stbi__zhuf
$LN6@stbi__zhuf:

; 4231 :    // code size is s, so:
; 4232 :    b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];

	movsxd	rdx, eax
	mov	ecx, 16
	sub	ecx, eax
	sar	r8d, cl
	movzx	ecx, WORD PTR [r9+rdx*2+1024]
	sub	r8d, ecx
	movzx	ecx, WORD PTR [r9+rdx*2+1124]
	add	r8d, ecx

; 4233 :    if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!

	cmp	r8d, 288				; 00000120H
	jge	SHORT $LN20@stbi__zhuf

; 4234 :    if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.

	movsxd	rdx, r8d
	movzx	ecx, BYTE PTR [rdx+r9+1156]
	cmp	ecx, eax
	jne	SHORT $LN20@stbi__zhuf

; 4235 :    a->code_buffer >>= s;

	mov	ecx, eax
	shr	r10d, cl

; 4236 :    a->num_bits -= s;

	sub	DWORD PTR [r11+16], eax
	mov	DWORD PTR [r11+20], r10d

; 4237 :    return z->value[b];

	movzx	eax, WORD PTR [r9+rdx*2+1444]

; 4238 : }

	ret	0
$LN20@stbi__zhuf:

; 4234 :    if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.

	mov	eax, -1

; 4238 : }

	ret	0
?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ENDP ; stbi__zhuffman_decode_slowpath
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z
_TEXT	SEGMENT
a$ = 48
z$ = 56
?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z PROC ; stbi__zhuffman_decode, COMDAT

; 4241 : {

	sub	rsp, 40					; 00000028H

; 4242 :    int b,s;
; 4243 :    if (a->num_bits < 16) {

	cmp	DWORD PTR [rcx+16], 16
	mov	r11, rdx
	mov	r10, rcx
	jge	SHORT $LN2@stbi__zhuf

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx], rax

; 4244 :       if (stbi__zeof(a)) {

	jb	SHORT $LN3@stbi__zhuf

; 4245 :          return -1;   /* report error for unexpected end of data. */

	mov	eax, -1

; 4257 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@stbi__zhuf:

; 4246 :       }
; 4247 :       stbi__fill_bits(a);

	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
$LN2@stbi__zhuf:

; 4248 :    }
; 4249 :    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];

	mov	edx, DWORD PTR [r10+20]
	mov	eax, edx
	and	eax, 511				; 000001ffH
	movzx	eax, WORD PTR [r11+rax*2]

; 4250 :    if (b) {

	test	eax, eax
	je	SHORT $LN4@stbi__zhuf

; 4251 :       s = b >> 9;

	mov	ecx, eax
	shr	ecx, 9

; 4252 :       a->code_buffer >>= s;
; 4253 :       a->num_bits -= s;

	sub	DWORD PTR [r10+16], ecx
	shr	edx, cl
	mov	DWORD PTR [r10+20], edx

; 4254 :       return b & 511;

	and	eax, 511				; 000001ffH

; 4257 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@stbi__zhuf:

; 4255 :    }
; 4256 :    return stbi__zhuffman_decode_slowpath(a, z);

	mov	rdx, r11
	mov	rcx, r10

; 4257 : }

	add	rsp, 40					; 00000028H

; 4255 :    }
; 4256 :    return stbi__zhuffman_decode_slowpath(a, z);

	jmp	?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode_slowpath
?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ENDP ; stbi__zhuffman_decode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z
_TEXT	SEGMENT
z$ = 48
zout$ = 56
n$ = 64
?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z PROC		; stbi__zexpand, COMDAT

; 4260 : {

	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 4261 :    char *q;
; 4262 :    unsigned int cur, limit, old_limit;
; 4263 :    z->zout = zout;
; 4264 :    if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");

	cmp	DWORD PTR [rcx+48], 0
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR [rcx+24], rdx
	jne	SHORT $LN4@stbi__zexp

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BE@IBFIPFO@output?5buffer?5limit@
	mov	QWORD PTR [rdx+rcx], rax

; 4261 :    char *q;
; 4262 :    unsigned int cur, limit, old_limit;
; 4263 :    z->zout = zout;
; 4264 :    if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");

	xor	eax, eax

; 4279 : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@stbi__zexp:

; 4265 :    cur   = (unsigned int) (z->zout - z->zout_start);

	sub	edi, DWORD PTR [rcx+32]

; 4266 :    limit = old_limit = (unsigned) (z->zout_end - z->zout_start);

	mov	ecx, DWORD PTR [rcx+40]

; 4267 :    if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");

	mov	eax, edi
	sub	ecx, DWORD PTR [rbx+32]
	not	eax
	cmp	eax, r8d
	jae	SHORT $LN17@stbi__zexp
$LN18@stbi__zexp:

; 4279 : }

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	mov	QWORD PTR [rdx+rcx], rax
	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN17@stbi__zexp:

; 4268 :    while (cur + n > limit) {

	lea	eax, DWORD PTR [rdi+r8]
	cmp	eax, ecx
	jbe	SHORT $LN3@stbi__zexp
$LL2@stbi__zexp:

; 4269 :       if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");

	cmp	ecx, 2147483647				; 7fffffffH
	ja	SHORT $LN18@stbi__zexp

; 4270 :       limit *= 2;

	add	ecx, ecx
	cmp	eax, ecx
	ja	SHORT $LL2@stbi__zexp
$LN3@stbi__zexp:

; 4271 :    }
; 4272 :    q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);

	mov	edx, ecx
	mov	QWORD PTR [rsp+48], rsi
	mov	esi, ecx
	mov	rcx, QWORD PTR [rbx+32]
	call	QWORD PTR __imp_realloc
	mov	rcx, rax

; 4273 :    STBI_NOTUSED(old_limit);
; 4274 :    if (q == NULL) return stbi__err("outofmem", "Out of memory");

	test	rax, rax
	jne	SHORT $LN7@stbi__zexp

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rsi, QWORD PTR [rsp+48]
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	mov	QWORD PTR [rdx+rcx], rax

; 4273 :    STBI_NOTUSED(old_limit);
; 4274 :    if (q == NULL) return stbi__err("outofmem", "Out of memory");

	xor	eax, eax

; 4279 : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN7@stbi__zexp:

; 4275 :    z->zout_start = q;
; 4276 :    z->zout       = q + cur;

	mov	eax, edi
	add	rax, rcx
	mov	QWORD PTR [rbx+32], rcx
	mov	QWORD PTR [rbx+24], rax

; 4277 :    z->zout_end   = q + limit;

	lea	rax, QWORD PTR [rsi+rcx]
	mov	rsi, QWORD PTR [rsp+48]
	mov	QWORD PTR [rbx+40], rax

; 4278 :    return 1;

	mov	eax, 1

; 4279 : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z ENDP		; stbi__zexpand
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z
_TEXT	SEGMENT
a$ = 64
?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z PROC	; stbi__parse_huffman_block, COMDAT

; 4296 : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r15
	sub	rsp, 32					; 00000020H

; 4297 :    char *zout = a->zout;

	mov	rsi, QWORD PTR [rcx+24]
	lea	r12, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [rsp+64], rbp
	mov	rbx, rcx
	mov	QWORD PTR [rsp+72], r14
	npad	5
$LL2@stbi__pars:

; 4243 :    if (a->num_bits < 16) {

	cmp	DWORD PTR [rbx+16], 16
	jge	SHORT $LN31@stbi__pars

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

	mov	rax, QWORD PTR [rbx+8]
	cmp	QWORD PTR [rbx], rax

; 4244 :       if (stbi__zeof(a)) {

	jae	$LN79@stbi__pars

; 4245 :          return -1;   /* report error for unexpected end of data. */
; 4246 :       }
; 4247 :       stbi__fill_bits(a);

	mov	rcx, rbx
	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
$LN31@stbi__pars:

; 4248 :    }
; 4249 :    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];

	mov	edx, DWORD PTR [rbx+20]
	mov	eax, edx
	and	eax, 511				; 000001ffH
	movzx	edi, WORD PTR [rbx+rax*2+52]

; 4250 :    if (b) {

	test	edi, edi
	je	SHORT $LN33@stbi__pars

; 4251 :       s = b >> 9;

	mov	ecx, edi
	shr	ecx, 9

; 4252 :       a->code_buffer >>= s;
; 4253 :       a->num_bits -= s;

	sub	DWORD PTR [rbx+16], ecx
	shr	edx, cl
	mov	DWORD PTR [rbx+20], edx

; 4254 :       return b & 511;

	and	edi, 511				; 000001ffH
	jmp	SHORT $LN30@stbi__pars
$LN33@stbi__pars:

; 4255 :    }
; 4256 :    return stbi__zhuffman_decode_slowpath(a, z);

	lea	rdx, QWORD PTR [rbx+52]
	mov	rcx, rbx
	call	?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode_slowpath
	mov	edi, eax
$LN30@stbi__pars:

; 4298 :    for(;;) {
; 4299 :       int z = stbi__zhuffman_decode(a, &a->z_length);
; 4300 :       if (z < 256) {

	cmp	edi, 256				; 00000100H
	jge	SHORT $LN11@stbi__pars

; 4301 :          if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes

	test	edi, edi
	js	$LN79@stbi__pars

; 4302 :          if (zout >= a->zout_end) {

	cmp	rsi, QWORD PTR [rbx+40]
	jb	SHORT $LN14@stbi__pars

; 4303 :             if (!stbi__zexpand(a, zout, 1)) return 0;

	mov	r8d, 1
	mov	rdx, rsi
	mov	rcx, rbx
	call	?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z ; stbi__zexpand
	test	eax, eax
	je	$LN67@stbi__pars

; 4304 :             zout = a->zout;

	mov	rsi, QWORD PTR [rbx+24]
$LN14@stbi__pars:

; 4305 :          }
; 4306 :          *zout++ = (char) z;

	mov	BYTE PTR [rsi], dil
	inc	rsi

; 4307 :       } else {

	jmp	$LL2@stbi__pars
$LN11@stbi__pars:

; 4308 :          stbi_uc *p;
; 4309 :          int len,dist;
; 4310 :          if (z == 256) {

	je	$LN63@stbi__pars

; 4313 :          }
; 4314 :          if (z >= 286) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, length codes 286 and 287 must not appear in compressed data

	cmp	edi, 286				; 0000011eH
	jge	$LN79@stbi__pars

; 4315 :          z -= 257;
; 4316 :          len = stbi__zlength_base[z];

	movsxd	rax, edi

; 4317 :          if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);

	mov	r10d, DWORD PTR ?stbi__zlength_extra@@3QBHB[r12+rax*4-1028]
	mov	edi, DWORD PTR ?stbi__zlength_base@@3QBHB[r12+rax*4-1028]
	test	r10d, r10d
	je	SHORT $LN77@stbi__pars

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

	cmp	DWORD PTR [rbx+16], r10d
	jge	SHORT $LN42@stbi__pars
	mov	rcx, rbx
	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
$LN42@stbi__pars:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

	mov	edx, DWORD PTR [rbx+20]

; 4216 :    z->code_buffer >>= n;

	mov	ecx, r10d

; 4217 :    z->num_bits -= n;

	sub	DWORD PTR [rbx+16], r10d
	mov	eax, edx
	shr	eax, cl
	mov	DWORD PTR [rbx+20], eax
	mov	eax, 1
	shl	eax, cl
	dec	eax
	and	eax, edx

; 4317 :          if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);

	add	edi, eax
$LN77@stbi__pars:

; 4243 :    if (a->num_bits < 16) {

	cmp	DWORD PTR [rbx+16], 16
	jge	SHORT $LN45@stbi__pars

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

	mov	rax, QWORD PTR [rbx+8]
	cmp	QWORD PTR [rbx], rax

; 4244 :       if (stbi__zeof(a)) {

	jae	$LN79@stbi__pars

; 4245 :          return -1;   /* report error for unexpected end of data. */
; 4246 :       }
; 4247 :       stbi__fill_bits(a);

	mov	rcx, rbx
	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
$LN45@stbi__pars:

; 4248 :    }
; 4249 :    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];

	mov	edx, DWORD PTR [rbx+20]
	mov	eax, edx
	and	eax, 511				; 000001ffH
	movzx	eax, WORD PTR [rbx+rax*2+2072]

; 4250 :    if (b) {

	test	eax, eax
	je	SHORT $LN47@stbi__pars

; 4251 :       s = b >> 9;

	mov	ecx, eax
	shr	ecx, 9

; 4252 :       a->code_buffer >>= s;
; 4253 :       a->num_bits -= s;

	sub	DWORD PTR [rbx+16], ecx
	shr	edx, cl
	mov	DWORD PTR [rbx+20], edx

; 4254 :       return b & 511;

	and	eax, 511				; 000001ffH
	jmp	SHORT $LN44@stbi__pars
$LN47@stbi__pars:

; 4255 :    }
; 4256 :    return stbi__zhuffman_decode_slowpath(a, z);

	lea	rdx, QWORD PTR [rbx+2072]
	mov	rcx, rbx
	call	?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode_slowpath
$LN44@stbi__pars:

; 4318 :          z = stbi__zhuffman_decode(a, &a->z_distance);
; 4319 :          if (z < 0 || z >= 30) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data

	cmp	eax, 29
	ja	$LN79@stbi__pars

; 4320 :          dist = stbi__zdist_base[z];

	cdqe

; 4321 :          if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);

	mov	r10d, DWORD PTR ?stbi__zdist_extra@@3QBHB[r12+rax*4]
	mov	r14d, DWORD PTR ?stbi__zdist_base@@3QBHB[r12+rax*4]
	test	r10d, r10d
	je	SHORT $LN76@stbi__pars

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

	cmp	DWORD PTR [rbx+16], r10d
	jge	SHORT $LN54@stbi__pars
	mov	rcx, rbx
	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
$LN54@stbi__pars:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

	mov	edx, DWORD PTR [rbx+20]

; 4216 :    z->code_buffer >>= n;

	mov	ecx, r10d

; 4217 :    z->num_bits -= n;

	sub	DWORD PTR [rbx+16], r10d
	mov	eax, edx
	shr	eax, cl
	mov	DWORD PTR [rbx+20], eax
	mov	eax, 1
	shl	eax, cl
	dec	eax
	and	eax, edx

; 4321 :          if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);

	add	r14d, eax
$LN76@stbi__pars:

; 4322 :          if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");

	mov	rax, rsi
	movsxd	rbp, r14d
	sub	rax, QWORD PTR [rbx+32]
	cmp	rax, rbp
	jl	$LN66@stbi__pars

; 4323 :          if (zout + len > a->zout_end) {

	movsxd	rax, edi
	add	rax, rsi
	cmp	rax, QWORD PTR [rbx+40]
	jbe	SHORT $LN23@stbi__pars

; 4324 :             if (!stbi__zexpand(a, zout, len)) return 0;

	mov	r8d, edi
	mov	rdx, rsi
	mov	rcx, rbx
	call	?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z ; stbi__zexpand
	test	eax, eax
	je	SHORT $LN67@stbi__pars

; 4325 :             zout = a->zout;

	mov	rsi, QWORD PTR [rbx+24]
$LN23@stbi__pars:

; 4326 :          }
; 4327 :          p = (stbi_uc *) (zout - dist);

	mov	rcx, rsi
	sub	rcx, rbp

; 4328 :          if (dist == 1) { // run of one byte; common in images.

	cmp	r14d, 1
	jne	SHORT $LN25@stbi__pars

; 4330 :             if (len) { do *zout++ = v; while (--len); }

	test	edi, edi
	je	$LL2@stbi__pars

; 4329 :             stbi_uc v = *p;

	movzx	edx, BYTE PTR [rcx]
	mov	r8, rdi
	mov	rcx, rsi
	call	memset
	add	rsi, rdi

; 4331 :          } else {

	jmp	$LL2@stbi__pars
$LN25@stbi__pars:

; 4332 :             if (len) { do *zout++ = *p++; while (--len); }

	test	edi, edi
	je	$LL2@stbi__pars
	npad	3
$LL10@stbi__pars:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rsi], al
	inc	rsi
	sub	edi, 1
	jne	SHORT $LL10@stbi__pars

; 4333 :          }
; 4334 :       }
; 4335 :    }

	jmp	$LL2@stbi__pars
$LN79@stbi__pars:

; 4336 : }

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
	mov	QWORD PTR [rdx+rcx], rax
$LN67@stbi__pars:
	xor	eax, eax
	jmp	SHORT $LN3@stbi__pars
$LN66@stbi__pars:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08DIAPIMGJ@bad?5dist@
	mov	QWORD PTR [rdx+rcx], rax

; 4322 :          if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");

	xor	eax, eax
	jmp	SHORT $LN3@stbi__pars
$LN63@stbi__pars:

; 4311 :             a->zout = zout;

	mov	QWORD PTR [rbx+24], rsi

; 4312 :             return 1;

	mov	eax, 1
$LN3@stbi__pars:

; 4336 : }

	mov	r14, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r12
	pop	rdi
	ret	0
?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z ENDP	; stbi__parse_huffman_block
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z
_TEXT	SEGMENT
z_codelength$ = 32
codelength_sizes$ = 2064
lencodes$ = 2096
__$ArrayPad$ = 2560
a$ = 2624
?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z PROC ; stbi__compute_huffman_codes, COMDAT

; 4339 : {

	push	rbx
	push	rbp
	push	r12
	push	r14
	push	r15
	sub	rsp, 2576				; 00000a10H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

	cmp	DWORD PTR [rcx+16], 5

; 4339 : {

	mov	rbx, rcx

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

	jge	SHORT $LN44@stbi__comp
	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
$LN44@stbi__comp:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

	mov	ecx, DWORD PTR [rbx+20]

; 4216 :    z->code_buffer >>= n;

	mov	eax, ecx

; 4217 :    z->num_bits -= n;

	add	DWORD PTR [rbx+16], -5
	and	ecx, 31
	shr	eax, 5

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

	cmp	DWORD PTR [rbx+16], 5

; 4216 :    z->code_buffer >>= n;

	mov	DWORD PTR [rbx+20], eax

; 4340 :    static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
; 4341 :    stbi__zhuffman z_codelength;
; 4342 :    stbi_uc lencodes[286+32+137];//padding for maximum single op
; 4343 :    stbi_uc codelength_sizes[19];
; 4344 :    int i,n;
; 4345 : 
; 4346 :    int hlit  = stbi__zreceive(a,5) + 257;

	lea	r12d, DWORD PTR [rcx+257]

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

	jge	SHORT $LN47@stbi__comp
	mov	rcx, rbx
	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
$LN47@stbi__comp:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

	mov	r14d, DWORD PTR [rbx+20]

; 4216 :    z->code_buffer >>= n;

	mov	eax, r14d

; 4217 :    z->num_bits -= n;

	add	DWORD PTR [rbx+16], -5
	and	r14d, 31
	shr	eax, 5

; 4347 :    int hdist = stbi__zreceive(a,5) + 1;

	inc	r14d

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

	cmp	DWORD PTR [rbx+16], 4

; 4216 :    z->code_buffer >>= n;

	mov	DWORD PTR [rbx+20], eax

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

	jge	SHORT $LN50@stbi__comp
	mov	rcx, rbx
	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
$LN50@stbi__comp:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

	mov	ecx, DWORD PTR [rbx+20]

; 4349 :    int ntot  = hlit + hdist;

	lea	ebp, DWORD PTR [r14+r12]

; 4217 :    z->num_bits -= n;

	mov	edx, DWORD PTR [rbx+16]
	mov	eax, ecx
	shr	eax, 4
	add	edx, -4
	mov	DWORD PTR [rbx+20], eax
	and	ecx, 15

; 4350 : 
; 4351 :    memset(codelength_sizes, 0, sizeof(codelength_sizes));

	xor	eax, eax
	mov	QWORD PTR [rsp+2640], rdi

; 4352 :    for (i=0; i < hclen; ++i) {

	xor	r15d, r15d

; 4217 :    z->num_bits -= n;

	mov	DWORD PTR [rbx+16], edx

; 4348 :    int hclen = stbi__zreceive(a,4) + 4;

	add	ecx, 4

; 4350 : 
; 4351 :    memset(codelength_sizes, 0, sizeof(codelength_sizes));

	mov	WORD PTR codelength_sizes$[rsp+16], ax
	xorps	xmm0, xmm0

; 4352 :    for (i=0; i < hclen; ++i) {

	mov	r11d, ecx
	movups	XMMWORD PTR codelength_sizes$[rsp], xmm0
	mov	BYTE PTR codelength_sizes$[rsp+18], al
	je	SHORT $LN3@stbi__comp
	mov	r10d, r15d
	lea	rdi, OFFSET FLAT:?length_dezigzag@?1??stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z@4QBEB
$LL4@stbi__comp:

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

	cmp	edx, 3
	jge	SHORT $LN35@stbi__comp
	mov	rcx, rbx
	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
$LN35@stbi__comp:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

	mov	ecx, DWORD PTR [rbx+20]

; 4216 :    z->code_buffer >>= n;

	mov	eax, ecx

; 4217 :    z->num_bits -= n;

	add	DWORD PTR [rbx+16], -3
	and	cl, 7
	mov	edx, DWORD PTR [rbx+16]
	shr	eax, 3
	mov	DWORD PTR [rbx+20], eax

; 4353 :       int s = stbi__zreceive(a,3);
; 4354 :       codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;

	movzx	eax, BYTE PTR [r10+rdi]
	inc	r10
	mov	BYTE PTR codelength_sizes$[rsp+rax], cl
	cmp	r10, r11
	jl	SHORT $LL4@stbi__comp
$LN3@stbi__comp:

; 4355 :    }
; 4356 :    if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

	mov	r8d, 19
	mov	QWORD PTR [rsp+2632], rsi
	lea	rdx, QWORD PTR codelength_sizes$[rsp]
	lea	rcx, QWORD PTR z_codelength$[rsp]
	call	?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z ; stbi__zbuild_huffman
	test	eax, eax
	je	$LN72@stbi__comp

; 4357 : 
; 4358 :    n = 0;

	mov	esi, r15d
$LL5@stbi__comp:

; 4243 :    if (a->num_bits < 16) {

	cmp	DWORD PTR [rbx+16], 16
	jge	SHORT $LN25@stbi__comp

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

	mov	rax, QWORD PTR [rbx+8]
	cmp	QWORD PTR [rbx], rax

; 4244 :       if (stbi__zeof(a)) {

	jae	$LN9@stbi__comp

; 4245 :          return -1;   /* report error for unexpected end of data. */
; 4246 :       }
; 4247 :       stbi__fill_bits(a);

	mov	rcx, rbx
	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
$LN25@stbi__comp:

; 4248 :    }
; 4249 :    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];

	mov	edx, DWORD PTR [rbx+20]
	mov	eax, edx
	and	eax, 511				; 000001ffH
	movzx	eax, WORD PTR z_codelength$[rsp+rax*2]

; 4250 :    if (b) {

	test	eax, eax
	je	SHORT $LN27@stbi__comp

; 4251 :       s = b >> 9;

	mov	ecx, eax
	shr	ecx, 9

; 4252 :       a->code_buffer >>= s;
; 4253 :       a->num_bits -= s;

	sub	DWORD PTR [rbx+16], ecx
	shr	edx, cl
	mov	DWORD PTR [rbx+20], edx

; 4254 :       return b & 511;

	and	eax, 511				; 000001ffH
	jmp	SHORT $LN24@stbi__comp
$LN27@stbi__comp:

; 4255 :    }
; 4256 :    return stbi__zhuffman_decode_slowpath(a, z);

	lea	rdx, QWORD PTR z_codelength$[rsp]
	mov	rcx, rbx
	call	?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode_slowpath
$LN24@stbi__comp:

; 4360 :       int c = stbi__zhuffman_decode(a, &z_codelength);
; 4361 :       if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");

	cmp	eax, 18
	ja	$LN9@stbi__comp

; 4362 :       if (c < 16)

	cmp	eax, 16
	jge	SHORT $LN10@stbi__comp

; 4363 :          lencodes[n++] = (stbi_uc) c;

	movsxd	rcx, esi
	mov	edi, 1
	mov	BYTE PTR lencodes$[rsp+rcx], al
	jmp	$LN11@stbi__comp
$LN10@stbi__comp:

; 4364 :       else {
; 4365 :          stbi_uc fill = 0;

	xor	r10b, r10b

; 4366 :          if (c == 16) {

	cmp	eax, 16
	jne	SHORT $LN12@stbi__comp

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

	cmp	DWORD PTR [rbx+16], 2
	jge	SHORT $LN32@stbi__comp
	mov	rcx, rbx
	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
$LN32@stbi__comp:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

	mov	edi, DWORD PTR [rbx+20]

; 4216 :    z->code_buffer >>= n;

	mov	eax, edi

; 4217 :    z->num_bits -= n;

	add	DWORD PTR [rbx+16], -2
	and	edi, 3
	shr	eax, 2

; 4367 :             c = stbi__zreceive(a,2)+3;

	add	edi, 3

; 4216 :    z->code_buffer >>= n;

	mov	DWORD PTR [rbx+20], eax

; 4368 :             if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");

	test	esi, esi
	je	$LN9@stbi__comp

; 4369 :             fill = lencodes[n-1];

	movsxd	rax, esi
	movzx	r10d, BYTE PTR lencodes$[rsp+rax-1]
	jmp	SHORT $LN18@stbi__comp
$LN12@stbi__comp:

; 4370 :          } else if (c == 17) {

	cmp	eax, 17
	jne	SHORT $LN15@stbi__comp

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

	cmp	DWORD PTR [rbx+16], 3
	jge	SHORT $LN38@stbi__comp
	mov	rcx, rbx
	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
$LN38@stbi__comp:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

	mov	edi, DWORD PTR [rbx+20]

; 4216 :    z->code_buffer >>= n;

	mov	eax, edi

; 4217 :    z->num_bits -= n;

	add	DWORD PTR [rbx+16], -3
	and	edi, 7
	shr	eax, 3

; 4371 :             c = stbi__zreceive(a,3)+3;

	add	edi, 3
	jmp	SHORT $LN99@stbi__comp
$LN15@stbi__comp:

; 4372 :          } else if (c == 18) {

	cmp	eax, 18
	jne	$LN9@stbi__comp

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

	cmp	DWORD PTR [rbx+16], 7
	jge	SHORT $LN41@stbi__comp
	mov	rcx, rbx
	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
$LN41@stbi__comp:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

	mov	edi, DWORD PTR [rbx+20]

; 4216 :    z->code_buffer >>= n;

	mov	eax, edi

; 4217 :    z->num_bits -= n;

	add	DWORD PTR [rbx+16], -7
	and	edi, 127				; 0000007fH
	shr	eax, 7

; 4373 :             c = stbi__zreceive(a,7)+11;

	add	edi, 11
$LN99@stbi__comp:

; 4374 :          } else {
; 4375 :             return stbi__err("bad codelengths", "Corrupt PNG");
; 4376 :          }
; 4377 :          if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");

	mov	DWORD PTR [rbx+20], eax
$LN18@stbi__comp:
	mov	eax, ebp
	sub	eax, esi
	cmp	eax, edi
	jl	SHORT $LN9@stbi__comp

; 4378 :          memset(lencodes+n, fill, c);

	movsxd	rax, esi
	lea	rcx, QWORD PTR lencodes$[rsp]
	add	rcx, rax
	mov	r8d, edi
	movzx	edx, r10b
	call	memset
$LN11@stbi__comp:

; 4359 :    while (n < ntot) {

	add	esi, edi
	cmp	esi, ebp
	jl	$LL5@stbi__comp

; 4379 :          n += c;
; 4380 :       }
; 4381 :    }
; 4382 :    if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");

	jne	SHORT $LN9@stbi__comp

; 4383 :    if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;

	lea	rcx, QWORD PTR [rbx+52]
	mov	r8d, r12d
	lea	rdx, QWORD PTR lencodes$[rsp]
	call	?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z ; stbi__zbuild_huffman
	test	eax, eax
	je	SHORT $LN72@stbi__comp

; 4384 :    if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;

	mov	ecx, r12d
	lea	rdx, QWORD PTR lencodes$[rsp]
	add	rdx, rcx
	mov	r8d, r14d
	lea	rcx, QWORD PTR [rbx+2072]
	call	?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z ; stbi__zbuild_huffman
	test	eax, eax
	setne	r15b
	mov	eax, r15d
	jmp	SHORT $LN1@stbi__comp
$LN9@stbi__comp:

; 4385 :    return 1;
; 4386 : }

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BA@MDNKOBMC@bad?5codelengths@
	mov	QWORD PTR [rdx+rcx], rax
$LN72@stbi__comp:
	xor	eax, eax
$LN1@stbi__comp:
	mov	rdi, QWORD PTR [rsp+2640]
	mov	rsi, QWORD PTR [rsp+2632]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 2576				; 00000a10H
	pop	r15
	pop	r14
	pop	r12
	pop	rbp
	pop	rbx
	ret	0
?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z ENDP ; stbi__compute_huffman_codes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z
_TEXT	SEGMENT
header$ = 48
a$ = 48
?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z PROC ; stbi__parse_uncompressed_block, COMDAT

; 4389 : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 4390 :    stbi_uc header[4];
; 4391 :    int len,nlen,k;
; 4392 :    if (a->num_bits & 7)

	mov	ecx, DWORD PTR [rcx+16]
	mov	r10d, ecx
	and	r10d, 7
	je	SHORT $LN39@stbi__pars

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

	cmp	ecx, r10d
	jge	SHORT $LN14@stbi__pars
	mov	rcx, rbx
	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
$LN14@stbi__pars:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);
; 4216 :    z->code_buffer >>= n;

	mov	eax, DWORD PTR [rbx+20]
	mov	ecx, r10d
	shr	eax, cl

; 4217 :    z->num_bits -= n;

	sub	DWORD PTR [rbx+16], r10d
	mov	ecx, DWORD PTR [rbx+16]
	mov	DWORD PTR [rbx+20], eax
$LN39@stbi__pars:

; 4393 :       stbi__zreceive(a, a->num_bits & 7); // discard
; 4394 :    // drain the bit-packed data into header
; 4395 :    k = 0;

	xor	r8d, r8d
	mov	eax, ecx

; 4396 :    while (a->num_bits > 0) {

	test	ecx, ecx
	jle	SHORT $LN3@stbi__pars
	mov	ecx, DWORD PTR [rbx+20]
	lea	rdx, QWORD PTR header$[rsp]

; 4217 :    z->num_bits -= n;

	movzx	r9d, cl
	npad	7
$LL2@stbi__pars:

; 4397 :       header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
; 4398 :       a->code_buffer >>= 8;

	shr	ecx, 8
	inc	r8d
	mov	BYTE PTR [rdx], r9b
	lea	rdx, QWORD PTR [rdx+1]

; 4399 :       a->num_bits -= 8;

	sub	eax, 8
	mov	DWORD PTR [rbx+20], ecx
	movzx	r9d, cl
	test	eax, eax
	jg	SHORT $LL2@stbi__pars
	mov	DWORD PTR [rbx+16], eax
$LN3@stbi__pars:

; 4400 :    }
; 4401 :    if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");

	test	eax, eax
	jns	SHORT $LN29@stbi__pars
$LN55@stbi__pars:

; 4415 : }

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0N@IECDHMDI@zlib?5corrupt@
	mov	QWORD PTR [rdx+rcx], rax
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN29@stbi__pars:
	movsxd	rcx, r8d

; 4402 :    // now fill header the normal way
; 4403 :    while (k < 4)

	cmp	rcx, 4
	jge	SHORT $LN40@stbi__pars

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

	mov	r8, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rbx]
$LL4@stbi__pars:
	cmp	rax, r8

; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;

	jb	SHORT $LN20@stbi__pars
	xor	dl, dl
	jmp	SHORT $LN21@stbi__pars
$LN20@stbi__pars:
	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx], rax
$LN21@stbi__pars:

; 4404 :       header[k++] = stbi__zget8(a);

	mov	BYTE PTR header$[rsp+rcx], dl
	inc	rcx
	cmp	rcx, 4
	jl	SHORT $LL4@stbi__pars
$LN40@stbi__pars:

; 4405 :    len  = header[1] * 256 + header[0];

	movzx	eax, BYTE PTR header$[rsp]
	movzx	r8d, BYTE PTR header$[rsp+1]

; 4406 :    nlen = header[3] * 256 + header[2];
; 4407 :    if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");

	movzx	ecx, BYTE PTR header$[rsp+3]
	shl	r8d, 8
	add	r8d, eax
	shl	ecx, 8
	movzx	eax, BYTE PTR header$[rsp+2]
	add	ecx, eax
	mov	eax, r8d
	xor	eax, 65535				; 0000ffffH
	cmp	ecx, eax
	jne	SHORT $LN55@stbi__pars

; 4408 :    if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");

	mov	rcx, QWORD PTR [rbx]
	mov	QWORD PTR [rsp+56], rdi
	mov	edi, r8d
	add	rcx, rdi
	cmp	rcx, QWORD PTR [rbx+8]
	jbe	SHORT $LN9@stbi__pars

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BB@PIPBCKIA@read?5past?5buffer@
	mov	QWORD PTR [rdx+rcx], rax
$LN54@stbi__pars:
	mov	rdi, QWORD PTR [rsp+56]

; 4408 :    if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");

	xor	eax, eax

; 4415 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN9@stbi__pars:

; 4409 :    if (a->zout + len > a->zout_end)

	mov	rdx, QWORD PTR [rbx+24]
	lea	rax, QWORD PTR [r8+rdx]
	cmp	rax, QWORD PTR [rbx+40]
	jbe	SHORT $LN41@stbi__pars

; 4410 :       if (!stbi__zexpand(a, a->zout, len)) return 0;

	mov	rcx, rbx
	call	?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z ; stbi__zexpand
	test	eax, eax
	je	SHORT $LN54@stbi__pars
$LN41@stbi__pars:

; 4411 :    memcpy(a->zout, a->zbuffer, len);

	mov	rdx, QWORD PTR [rbx]
	mov	r8, rdi
	mov	rcx, QWORD PTR [rbx+24]
	call	memcpy

; 4412 :    a->zbuffer += len;

	add	QWORD PTR [rbx], rdi

; 4413 :    a->zout += len;
; 4414 :    return 1;

	mov	eax, 1
	add	QWORD PTR [rbx+24], rdi
	mov	rdi, QWORD PTR [rsp+56]

; 4415 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z ENDP ; stbi__parse_uncompressed_block
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z
_TEXT	SEGMENT
a$ = 8
?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z PROC	; stbi__parse_zlib_header, COMDAT

; 4418 : {

	mov	rdx, rcx

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

	mov	rcx, QWORD PTR [rcx]
	mov	r9, QWORD PTR [rdx+8]
	cmp	rcx, r9

; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;

	jae	$LN29@stbi__pars
	movzx	eax, BYTE PTR [rcx]
	lea	r10, QWORD PTR [rcx+1]

; 4419 :    int cmf   = stbi__zget8(a);
; 4420 :    int cm    = cmf & 15;

	mov	r11d, eax

; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;

	mov	QWORD PTR [rdx], r10

; 4419 :    int cmf   = stbi__zget8(a);
; 4420 :    int cm    = cmf & 15;

	and	r11d, 15
	mov	r8d, eax

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

	cmp	r10, r9

; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;

	jae	$LN29@stbi__pars
	movzx	ecx, BYTE PTR [r10]
	lea	rax, QWORD PTR [r10+1]
	mov	QWORD PTR [rdx], rax

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

	cmp	rax, r9

; 4421 :    /* int cinfo = cmf >> 4; */
; 4422 :    int flg   = stbi__zget8(a);
; 4423 :    if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec

	jae	SHORT $LN29@stbi__pars

; 4424 :    if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec

	shl	r8d, 8
	mov	eax, 138547333				; 08421085H
	add	r8d, ecx
	mul	r8d
	mov	eax, r8d
	sub	eax, edx
	shr	eax, 1
	add	eax, edx
	shr	eax, 4
	imul	eax, eax, 31
	cmp	r8d, eax
	jne	SHORT $LN29@stbi__pars

; 4425 :    if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png

	test	cl, 32					; 00000020H
	je	SHORT $LN4@stbi__pars

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88

; 4429 : }

	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB

; 978  :    stbi__g_failure_reason = str;

	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0P@DOGMHEBI@no?5preset?5dict@

; 4429 : }

	mov	QWORD PTR [rdx+rcx], rax
	xor	eax, eax
	ret	0
$LN4@stbi__pars:

; 4426 :    if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png

	cmp	r11d, 8
	je	SHORT $LN5@stbi__pars

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88

; 4429 : }

	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB

; 978  :    stbi__g_failure_reason = str;

	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BA@MCNBDLPD@bad?5compression@

; 4429 : }

	mov	QWORD PTR [rdx+rcx], rax
	xor	eax, eax
	ret	0
$LN5@stbi__pars:

; 4427 :    // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
; 4428 :    return 1;

	mov	eax, 1

; 4429 : }

	ret	0
$LN29@stbi__pars:
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BA@OBKOPAFL@bad?5zlib?5header@
	mov	QWORD PTR [rdx+rcx], rax
	xor	eax, eax
	ret	0
?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z ENDP	; stbi__parse_zlib_header
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z
_TEXT	SEGMENT
a$ = 48
parse_header$ = 56
?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z PROC		; stbi__parse_zlib, COMDAT

; 4461 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 4462 :    int final, type;
; 4463 :    if (parse_header)

	test	edx, edx
	je	$LN6@stbi__pars

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

	mov	rcx, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rbx+8]
	cmp	rcx, rdx

; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;

	jae	SHORT $LN64@stbi__pars
	movzx	eax, BYTE PTR [rcx]
	lea	r9, QWORD PTR [rcx+1]

; 4420 :    int cm    = cmf & 15;

	mov	r10d, eax

; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;

	mov	QWORD PTR [rbx], r9

; 4420 :    int cm    = cmf & 15;

	and	r10d, 15
	mov	r8d, eax

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

	cmp	r9, rdx

; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;

	jae	SHORT $LN64@stbi__pars
	movzx	ecx, BYTE PTR [r9]
	lea	rax, QWORD PTR [r9+1]
	mov	QWORD PTR [rbx], rax

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

	cmp	rax, rdx

; 4423 :    if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec

	jae	SHORT $LN64@stbi__pars

; 4424 :    if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec

	shl	r8d, 8
	mov	eax, 138547333				; 08421085H
	add	r8d, ecx
	mul	r8d
	mov	eax, r8d
	sub	eax, edx
	shr	eax, 1
	add	eax, edx
	shr	eax, 4
	imul	eax, eax, 31
	cmp	r8d, eax
	je	SHORT $LN21@stbi__pars
$LN64@stbi__pars:

; 4481 :          }
; 4482 :          if (!stbi__parse_huffman_block(a)) return 0;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BA@OBKOPAFL@bad?5zlib?5header@
	mov	QWORD PTR [rdx+rcx], rax
$LN60@stbi__pars:
	xor	eax, eax

; 4485 :    return 1;
; 4486 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN21@stbi__pars:

; 4425 :    if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png

	test	cl, 32					; 00000020H
	je	SHORT $LN22@stbi__pars

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0P@DOGMHEBI@no?5preset?5dict@

; 4481 :          }
; 4482 :          if (!stbi__parse_huffman_block(a)) return 0;

	mov	QWORD PTR [rdx+rcx], rax
	xor	eax, eax

; 4485 :    return 1;
; 4486 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN22@stbi__pars:

; 4426 :    if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png

	cmp	r10d, 8
	je	SHORT $LN6@stbi__pars

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BA@MCNBDLPD@bad?5compression@

; 4481 :          }
; 4482 :          if (!stbi__parse_huffman_block(a)) return 0;

	mov	QWORD PTR [rdx+rcx], rax
	xor	eax, eax

; 4485 :    return 1;
; 4486 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@stbi__pars:

; 4464 :       if (!stbi__parse_zlib_header(a)) return 0;
; 4465 :    a->num_bits = 0;

	xor	eax, eax
	mov	QWORD PTR [rbx+16], rax
	npad	7
$LL4@stbi__pars:

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

	cmp	DWORD PTR [rbx+16], 1
	jge	SHORT $LN48@stbi__pars
	mov	rcx, rbx
	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
$LN48@stbi__pars:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

	mov	eax, DWORD PTR [rbx+20]
	mov	edi, eax

; 4217 :    z->num_bits -= n;

	dec	DWORD PTR [rbx+16]
	and	edi, 1
	shr	eax, 1

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

	cmp	DWORD PTR [rbx+16], 2

; 4216 :    z->code_buffer >>= n;

	mov	DWORD PTR [rbx+20], eax

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

	jge	SHORT $LN51@stbi__pars
	mov	rcx, rbx
	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
$LN51@stbi__pars:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

	mov	eax, DWORD PTR [rbx+20]
	mov	ecx, eax

; 4217 :    z->num_bits -= n;

	add	DWORD PTR [rbx+16], -2
	shr	eax, 2
	mov	DWORD PTR [rbx+20], eax
	and	ecx, 3

; 4466 :    a->code_buffer = 0;
; 4467 :    do {
; 4468 :       final = stbi__zreceive(a,1);
; 4469 :       type = stbi__zreceive(a,2);
; 4470 :       if (type == 0) {

	jne	SHORT $LN7@stbi__pars

; 4471 :          if (!stbi__parse_uncompressed_block(a)) return 0;

	mov	rcx, rbx
	call	?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z ; stbi__parse_uncompressed_block
	jmp	SHORT $LN81@stbi__pars
$LN7@stbi__pars:

; 4472 :       } else if (type == 3) {

	cmp	ecx, 3
	je	$LN60@stbi__pars

; 4473 :          return 0;
; 4474 :       } else {
; 4475 :          if (type == 1) {

	cmp	ecx, 1
	jne	SHORT $LN12@stbi__pars

; 4476 :             // use fixed code lengths
; 4477 :             if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;

	lea	rcx, QWORD PTR [rbx+52]
	mov	r8d, 288				; 00000120H
	lea	rdx, OFFSET FLAT:?stbi__zdefault_length@@3QBEB
	call	?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z ; stbi__zbuild_huffman
	test	eax, eax
	je	$LN60@stbi__pars

; 4478 :             if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;

	lea	rcx, QWORD PTR [rbx+2072]
	mov	r8d, 32					; 00000020H
	lea	rdx, OFFSET FLAT:?stbi__zdefault_distance@@3QBEB
	call	?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z ; stbi__zbuild_huffman

; 4479 :          } else {

	jmp	SHORT $LN83@stbi__pars
$LN12@stbi__pars:

; 4480 :             if (!stbi__compute_huffman_codes(a)) return 0;

	mov	rcx, rbx
	call	?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z ; stbi__compute_huffman_codes
$LN83@stbi__pars:

; 4481 :          }
; 4482 :          if (!stbi__parse_huffman_block(a)) return 0;

	test	eax, eax
	je	$LN60@stbi__pars
	mov	rcx, rbx
	call	?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z ; stbi__parse_huffman_block
$LN81@stbi__pars:

; 4483 :       }
; 4484 :    } while (!final);

	test	eax, eax
	je	$LN60@stbi__pars
	test	edi, edi
	je	$LL4@stbi__pars

; 4485 :    return 1;
; 4486 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	eax, 1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z ENDP		; stbi__parse_zlib
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z
_TEXT	SEGMENT
a$ = 8
obuf$ = 16
olen$ = 24
exp$dead$ = 32
parse_header$ = 40
?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z PROC	; stbi__do_zlib, COMDAT

; 4490 :    a->zout_start = obuf;
; 4491 :    a->zout       = obuf;
; 4492 :    a->zout_end   = obuf + olen;

	movsxd	rax, r8d
	add	rax, rdx
	mov	QWORD PTR [rcx+32], rdx
	mov	QWORD PTR [rcx+24], rdx

; 4493 :    a->z_expandable = exp;
; 4494 : 
; 4495 :    return stbi__parse_zlib(a, parse_header);

	mov	edx, DWORD PTR parse_header$[rsp]
	mov	QWORD PTR [rcx+40], rax
	mov	DWORD PTR [rcx+48], 1
	jmp	?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z ; stbi__parse_zlib
?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ENDP	; stbi__do_zlib
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT stbi_zlib_decode_malloc_guesssize_headerflag
_TEXT	SEGMENT
a$ = 32
__$ArrayPad$ = 4128
buffer$ = 4192
len$ = 4200
initial_size$ = 4208
outlen$ = 4216
parse_header$ = 4224
stbi_zlib_decode_malloc_guesssize_headerflag PROC	; COMDAT

; 4520 : {

$LN16:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	mov	eax, 4152				; 00001038H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 4521 :    stbi__zbuf a;
; 4522 :    char *p = (char *) stbi__malloc(initial_size);

	movsxd	rsi, r8d
	mov	rdi, rcx

; 985  :     return STBI_MALLOC(size);

	mov	rcx, rsi

; 4520 : {

	movsxd	rbp, edx
	mov	rbx, r9

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc

; 4523 :    if (p == NULL) return NULL;

	test	rax, rax
	je	SHORT $LN14@stbi_zlib_

; 4495 :    return stbi__parse_zlib(a, parse_header);

	mov	edx, DWORD PTR parse_header$[rsp]
	lea	rcx, QWORD PTR a$[rsp]
	mov	QWORD PTR a$[rsp+32], rax

; 4525 :    a.zbuffer_end = (stbi_uc *) buffer + len;

	add	rbp, rdi

; 4491 :    a->zout       = obuf;

	mov	QWORD PTR a$[rsp+24], rax

; 4492 :    a->zout_end   = obuf + olen;

	add	rax, rsi
	mov	QWORD PTR a$[rsp+40], rax

; 4524 :    a.zbuffer = (stbi_uc *) buffer;

	mov	QWORD PTR a$[rsp], rdi

; 4525 :    a.zbuffer_end = (stbi_uc *) buffer + len;

	mov	QWORD PTR a$[rsp+8], rbp

; 4493 :    a->z_expandable = exp;

	mov	DWORD PTR a$[rsp+48], 1

; 4494 : 
; 4495 :    return stbi__parse_zlib(a, parse_header);

	call	?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z ; stbi__parse_zlib

; 4526 :    if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {

	test	eax, eax
	je	SHORT $LN3@stbi_zlib_

; 4527 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);

	test	rbx, rbx
	je	SHORT $LN5@stbi_zlib_
	mov	eax, DWORD PTR a$[rsp+24]
	sub	eax, DWORD PTR a$[rsp+32]
	mov	DWORD PTR [rbx], eax
$LN5@stbi_zlib_:

; 4528 :       return a.zout_start;

	mov	rax, QWORD PTR a$[rsp+32]
	jmp	SHORT $LN4@stbi_zlib_
$LN3@stbi_zlib_:

; 4529 :    } else {
; 4530 :       STBI_FREE(a.zout_start);

	mov	rcx, QWORD PTR a$[rsp+32]
	call	QWORD PTR __imp_free
$LN14@stbi_zlib_:

; 4531 :       return NULL;
; 4532 :    }
; 4533 : }

	xor	eax, eax
$LN4@stbi_zlib_:
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 4152				; 00001038H
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
stbi_zlib_decode_malloc_guesssize_headerflag ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z PROC ; stbi__get_chunk_header, COMDAT

; 4592 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx

; 1704 :    stbi__uint32 z = stbi__get16be(s);

	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 1705 :    return (z << 16) + stbi__get16be(s);

	mov	rcx, rsi
	mov	edi, eax
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	shl	edi, 16

; 1704 :    stbi__uint32 z = stbi__get16be(s);

	mov	rcx, rsi

; 1705 :    return (z << 16) + stbi__get16be(s);

	add	edi, eax

; 1704 :    stbi__uint32 z = stbi__get16be(s);

	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 1705 :    return (z << 16) + stbi__get16be(s);

	mov	rcx, rsi
	mov	ebx, eax
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 4593 :    stbi__pngchunk c;
; 4594 :    c.length = stbi__get32be(s);
; 4595 :    c.type   = stbi__get32be(s);
; 4596 :    return c;
; 4597 : }

	mov	rsi, QWORD PTR [rsp+56]

; 1705 :    return (z << 16) + stbi__get16be(s);

	shl	ebx, 16
	add	eax, ebx

; 4593 :    stbi__pngchunk c;
; 4594 :    c.length = stbi__get32be(s);
; 4595 :    c.type   = stbi__get32be(s);
; 4596 :    return c;
; 4597 : }

	mov	rbx, QWORD PTR [rsp+48]
	shl	rax, 32					; 00000020H
	or	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z ENDP ; stbi__get_chunk_header
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__check_png_header@@YAHPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__check_png_header@@YAHPEAUstbi__context@@@Z PROC	; stbi__check_png_header, COMDAT

; 4600 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	lea	rsi, OFFSET FLAT:?png_sig@?1??stbi__check_png_header@@YAHPEAUstbi__context@@@Z@4QBEB
	xor	edi, edi
	npad	5
$LL4@stbi__chec:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN8@stbi__chec

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN7@stbi__chec
$LN8@stbi__chec:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN9@stbi__chec

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN7@stbi__chec
$LN9@stbi__chec:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN7@stbi__chec:

; 4604 :       if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");

	cmp	cl, BYTE PTR [rdi+rsi]
	jne	SHORT $LN14@stbi__chec

; 4601 :    static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
; 4602 :    int i;
; 4603 :    for (i=0; i < 8; ++i)

	inc	rdi
	cmp	rdi, 8
	jl	SHORT $LL4@stbi__chec

; 4605 :    return 1;

	mov	eax, 1

; 4606 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN14@stbi__chec:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88

; 4606 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]

; 978  :    stbi__g_failure_reason = str;

	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0M@DMDNBACF@bad?5png?5sig@
	mov	QWORD PTR [rdx+rcx], rax

; 4604 :       if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");

	xor	eax, eax

; 4606 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__check_png_header@@YAHPEAUstbi__context@@@Z ENDP	; stbi__check_png_header
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__paeth@@YAHHHH@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
c$ = 24
?stbi__paeth@@YAHHHH@Z PROC				; stbi__paeth, COMDAT

; 4637 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi

; 4638 :    int p = a + b - c;

	mov	r9d, ecx
	mov	edi, edx
	sub	r9d, r8d
	mov	ebx, ecx
	lea	r10d, DWORD PTR [r9+rdx]

; 4639 :    int pa = abs(p-a);

	mov	eax, r10d

; 4640 :    int pb = abs(p-b);
; 4641 :    int pc = abs(p-c);

	sub	r10d, r8d
	sub	eax, ecx
	cdq
	mov	r11d, eax
	mov	eax, r9d
	xor	r11d, edx
	sub	r11d, edx
	cdq
	mov	ecx, eax
	mov	eax, r10d
	xor	ecx, edx
	sub	ecx, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 4642 :    if (pa <= pb && pa <= pc) return a;

	cmp	r11d, ecx
	jg	SHORT $LN2@stbi__paet
	cmp	r11d, eax
	jg	SHORT $LN2@stbi__paet
	mov	eax, ebx

; 4643 :    if (pb <= pc) return b;
; 4644 :    return c;
; 4645 : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
$LN2@stbi__paet:
	mov	rbx, QWORD PTR [rsp+8]
	cmp	ecx, eax
	cmovle	r8d, edi
	mov	rdi, QWORD PTR [rsp+16]
	mov	eax, r8d
	ret	0
?stbi__paeth@@YAHHHH@Z ENDP				; stbi__paeth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z
_TEXT	SEGMENT
img_n$1$ = 32
nk$1$ = 40
prior$4$ = 40
width$1$ = 48
j$1$ = 52
filter_bytes$1$ = 56
img_width_bytes$1$ = 60
stride$1$ = 64
cur$9$ = 72
$T1 = 80
$T2 = 88
$T3 = 96
tv5525 = 104
tv5458 = 112
tv5461 = 120
tv5460 = 128
cur$1$ = 136
a$1$ = 208
a$ = 208
raw$ = 216
raw_len$ = 224
out_n$ = 232
x$ = 240
y$ = 248
depth$ = 256
color$ = 264
?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z PROC ; stbi__create_png_image_raw, COMDAT

; 4651 : {

	mov	QWORD PTR [rsp+16], rbx
	mov	DWORD PTR [rsp+32], r9d
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 144				; 00000090H
	mov	r14d, DWORD PTR depth$[rsp]

; 4652 :    int bytes = (depth == 16? 2 : 1);

	xor	r13d, r13d
	cmp	r14d, 16
	mov	r10d, r13d
	mov	rsi, rcx
	mov	r15d, r9d

; 4653 :    stbi__context *s = a->s;
; 4654 :    stbi__uint32 i,j,stride = x*out_n*bytes;

	mov	ecx, DWORD PTR x$[rsp]
	sete	r10b
	inc	r10d

; 4655 :    stbi__uint32 img_len, img_width_bytes;
; 4656 :    int k;
; 4657 :    int img_n = s->img_n; // copy it into a local for later
; 4658 : 
; 4659 :    int output_bytes = out_n*bytes;
; 4660 :    int filter_bytes = img_n*bytes;
; 4661 :    int width = x;

	mov	DWORD PTR width$1$[rsp], ecx
	mov	ebx, r10d
	mov	ebp, r8d
	mov	rax, QWORD PTR [rsi]
	mov	rdi, rdx
	mov	r8d, DWORD PTR y$[rsp]
	imul	ebx, r9d
	mov	eax, DWORD PTR [rax+8]
	mov	r12d, eax
	imul	r12d, r10d
	mov	DWORD PTR img_n$1$[rsp], eax
	mov	r9d, ebx
	imul	r9d, ecx
	mov	DWORD PTR filter_bytes$1$[rsp], r12d
	mov	DWORD PTR stride$1$[rsp], r9d

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	$LN381@stbi__crea
	test	r8d, r8d
	js	$LN381@stbi__crea

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN383@stbi__crea

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, 2147483647				; 7fffffffH
	div	r8d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	$LN381@stbi__crea
$LN383@stbi__crea:
	imul	ecx, r8d

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	$LN381@stbi__crea
	test	ebx, ebx
	js	$LN381@stbi__crea

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN382@stbi__crea

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	ebx

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	$LN381@stbi__crea
$LN382@stbi__crea:
	mov	eax, r8d
	imul	eax, r9d

; 1056 :    return stbi__malloc(a*b*c + add);

	movsxd	rcx, eax

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc

; 4662 : 
; 4663 :    STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
; 4664 :    a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into

	mov	QWORD PTR [rsi+24], rax

; 985  :     return STBI_MALLOC(size);

	mov	r10, rax

; 4665 :    if (!a->out) return stbi__err("outofmem", "Out of memory");

	test	rax, rax
	je	$LN380@stbi__crea

; 1014 :    if (a < 0 || b < 0) return 0;

	movsxd	r9, DWORD PTR img_n$1$[rsp]
	test	r9d, r9d
	js	$LN377@stbi__crea

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	mov	r11d, DWORD PTR x$[rsp]
	test	r11d, r11d
	je	SHORT $LN379@stbi__crea

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, 2147483647				; 7fffffffH
	div	r11d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	r9d, eax
	jg	$LN377@stbi__crea
$LN379@stbi__crea:
	mov	edx, r9d
	imul	edx, r11d
	mov	DWORD PTR a$1$[rsp], edx

; 1014 :    if (a < 0 || b < 0) return 0;

	test	edx, edx
	js	$LN377@stbi__crea
	test	r14d, r14d
	js	$LN377@stbi__crea

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN378@stbi__crea

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, 2147483647				; 7fffffffH
	div	r14d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	mov	edx, DWORD PTR a$1$[rsp]
	cmp	edx, eax
	jg	$LN377@stbi__crea
$LN378@stbi__crea:
	mov	eax, edx
	imul	eax, r14d

; 1007 :    return a <= INT_MAX - b;

	cmp	eax, 2147483640				; 7ffffff8H

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	jg	$LN377@stbi__crea

; 4668 :    img_width_bytes = (((img_n * x * depth) + 7) >> 3);

	mov	esi, DWORD PTR y$[rsp]
	mov	r8d, edx
	imul	r8d, r14d
	add	r8d, 7
	shr	r8d, 3
	mov	DWORD PTR img_width_bytes$1$[rsp], r8d

; 4669 :    img_len = (img_width_bytes + 1) * y;

	lea	eax, DWORD PTR [r8+1]
	imul	eax, esi

; 4670 : 
; 4671 :    // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
; 4672 :    // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
; 4673 :    // so just check for raw_len < img_len always.
; 4674 :    if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");

	cmp	ebp, eax
	jae	SHORT $LN100@stbi__crea

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BC@BHMPBBMG@not?5enough?5pixels@

; 4670 : 
; 4671 :    // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
; 4672 :    // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
; 4673 :    // so just check for raw_len < img_len always.
; 4674 :    if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");

	jmp	$LN633@stbi__crea
$LN100@stbi__crea:

; 4675 : 
; 4676 :    for (j=0; j < y; ++j) {

	mov	QWORD PTR $T1[rsp], r10
	mov	ecx, r13d
	mov	DWORD PTR j$1$[rsp], ecx
	lea	rbp, OFFSET FLAT:__ImageBase
	test	esi, esi
	je	$LN3@stbi__crea

; 4677 :       stbi_uc *cur = a->out + stride*j;

	movsxd	r15, r12d
	mov	QWORD PTR $T2[rsp], r9
	mov	r9, r10
	mov	QWORD PTR $T3[rsp], r15
	movsxd	rbp, ebx
	mov	DWORD PTR a$1$[rsp], edx
	mov	QWORD PTR $T1[rsp], r10
	mov	QWORD PTR cur$1$[rsp], r10
	npad	15
$LL4@stbi__crea:
	mov	edx, DWORD PTR stride$1$[rsp]
	mov	esi, ecx
	imul	esi, edx
	add	rsi, r9

; 4678 :       stbi_uc *prior;
; 4679 :       int filter = *raw++;

	movzx	r9d, BYTE PTR [rdi]
	inc	rdi
	mov	QWORD PTR cur$9$[rsp], rsi
	mov	rbx, rsi

; 4680 : 
; 4681 :       if (filter > 4)

	cmp	r9d, 4
	ja	$LN252@stbi__crea

; 4683 : 
; 4684 :       if (depth < 8) {

	cmp	r14d, 8
	jge	SHORT $LN102@stbi__crea

; 4685 :          if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");

	cmp	r8d, r11d
	ja	$LN253@stbi__crea

; 4686 :          cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place

	mov	eax, DWORD PTR out_n$[rsp]

; 4687 :          filter_bytes = 1;

	mov	r12d, 1
	imul	eax, r11d
	mov	r15d, r12d
	mov	DWORD PTR filter_bytes$1$[rsp], r12d
	mov	QWORD PTR $T3[rsp], r12

; 4688 :          width = img_width_bytes;

	mov	DWORD PTR width$1$[rsp], r8d
	sub	eax, r8d
	add	rbx, rax
$LN102@stbi__crea:

; 4689 :       }
; 4690 :       prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above

	mov	r14, rbx
	sub	r14, rdx

; 4691 : 
; 4692 :       // if first row, use special filter that doesn't sample previous row
; 4693 :       if (j == 0) filter = first_row_filter[filter];

	test	ecx, ecx
	lea	rcx, OFFSET FLAT:__ImageBase
	jne	SHORT $LN104@stbi__crea
	movzx	r9d, BYTE PTR ?first_row_filter@@3PAEA[r9+rcx]
$LN104@stbi__crea:

; 4694 : 
; 4695 :       // handle first byte explicitly
; 4696 :       for (k=0; k < filter_bytes; ++k) {

	test	r15, r15
	jle	$LN6@stbi__crea
	mov	r11, r14
	mov	r10, rbx
	sub	r11, rdi
	mov	rdx, rdi
	sub	r10, rdi
	mov	r8, r15
$LL7@stbi__crea:

; 4697 :          switch (filter) {

	cmp	r9d, 6
	ja	SHORT $LN5@stbi__crea
	movsxd	rax, r9d
	mov	eax, DWORD PTR $LN391@stbi__crea[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN5@stbi__crea:

; 4694 : 
; 4695 :       // handle first byte explicitly
; 4696 :       for (k=0; k < filter_bytes; ++k) {

	inc	rdx
	sub	r8, 1
	je	$LN486@stbi__crea
	lea	rcx, OFFSET FLAT:__ImageBase
	jmp	SHORT $LL7@stbi__crea
	npad	3
$LL399@stbi__crea:

; 4698 :             case STBI__F_none       : cur[k] = raw[k]; break;

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [r10+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	sub	r8, 1
	je	$LN486@stbi__crea

; 4697 :          switch (filter) {

	jmp	SHORT $LL399@stbi__crea
	npad	9
$LL400@stbi__crea:

; 4699 :             case STBI__F_sub        : cur[k] = raw[k]; break;

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [r10+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	sub	r8, 1
	je	$LN486@stbi__crea

; 4697 :          switch (filter) {

	jmp	SHORT $LL400@stbi__crea
	npad	9
$LL440@stbi__crea:

; 4700 :             case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;

	movzx	eax, BYTE PTR [r11+rdx]
	add	al, BYTE PTR [rdx]
	mov	BYTE PTR [r10+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	sub	r8, 1
	je	SHORT $LN486@stbi__crea

; 4697 :          switch (filter) {

	jmp	SHORT $LL440@stbi__crea
	npad	9
$LL441@stbi__crea:

; 4701 :             case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;

	movzx	eax, BYTE PTR [r11+rdx]
	lea	rdx, QWORD PTR [rdx+1]
	shr	al, 1
	add	al, BYTE PTR [rdx-1]
	mov	BYTE PTR [r10+rdx-1], al
	sub	r8, 1
	je	SHORT $LN486@stbi__crea

; 4697 :          switch (filter) {

	jmp	SHORT $LL441@stbi__crea
	npad	5
$LL442@stbi__crea:

; 4702 :             case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;

	movzx	eax, BYTE PTR [r11+rdx]
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	mov	ecx, r13d
	cmovne	ecx, eax
	add	cl, BYTE PTR [rdx-1]
	mov	BYTE PTR [r10+rdx-1], cl
	sub	r8, 1
	je	SHORT $LN486@stbi__crea

; 4697 :          switch (filter) {

	jmp	SHORT $LL442@stbi__crea
$LL443@stbi__crea:

; 4703 :             case STBI__F_avg_first  : cur[k] = raw[k]; break;

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [r10+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	sub	r8, 1
	je	SHORT $LN486@stbi__crea

; 4697 :          switch (filter) {

	jmp	SHORT $LL443@stbi__crea
	npad	12
$LL444@stbi__crea:

; 4704 :             case STBI__F_paeth_first: cur[k] = raw[k]; break;

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [r10+rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	sub	r8, 1
	jne	SHORT $LL444@stbi__crea
$LN486@stbi__crea:

; 4705 :          }
; 4706 :       }
; 4707 : 
; 4708 :       if (depth == 8) {

	mov	r11d, DWORD PTR x$[rsp]
$LN6@stbi__crea:
	mov	eax, DWORD PTR depth$[rsp]
	cmp	eax, 8
	jne	SHORT $LN112@stbi__crea

; 4709 :          if (img_n != out_n)

	movsxd	rax, DWORD PTR out_n$[rsp]
	mov	rcx, QWORD PTR $T2[rsp]
	cmp	DWORD PTR img_n$1$[rsp], eax
	je	SHORT $LN114@stbi__crea

; 4710 :             cur[img_n] = 255; // first pixel

	mov	BYTE PTR [rcx+rbx], 255			; 000000ffH
$LN114@stbi__crea:

; 4711 :          raw += img_n;
; 4712 :          cur += out_n;
; 4713 :          prior += out_n;

	add	rdi, rcx
	add	r14, rax
	mov	QWORD PTR prior$4$[rsp], r14
	mov	r10, rdi
	mov	rdx, rdi
	mov	r8, r14
	add	rbx, rax
	jmp	SHORT $LN376@stbi__crea
$LN112@stbi__crea:

; 4714 :       } else if (depth == 16) {

	cmp	eax, 16
	jne	SHORT $LN115@stbi__crea

; 4715 :          if (img_n != out_n) {

	mov	ecx, DWORD PTR img_n$1$[rsp]
	cmp	ecx, DWORD PTR out_n$[rsp]
	je	SHORT $LN117@stbi__crea

; 4716 :             cur[filter_bytes]   = 255; // first pixel top byte

	mov	WORD PTR [r15+rbx], 65535		; 0000ffffH
$LN117@stbi__crea:

; 4717 :             cur[filter_bytes+1] = 255; // first pixel bottom byte
; 4718 :          }
; 4719 :          raw += filter_bytes;
; 4720 :          cur += output_bytes;
; 4721 :          prior += output_bytes;

	add	r14, rbp
	movsxd	rax, r12d
	add	rdi, rax
	mov	QWORD PTR prior$4$[rsp], r14
	mov	r10, rdi
	mov	rdx, rdi
	add	rbx, rbp
	mov	r8, r14

; 4722 :       } else {

	jmp	SHORT $LN376@stbi__crea
$LN115@stbi__crea:

; 4723 :          raw += 1;
; 4724 :          cur += 1;
; 4725 :          prior += 1;
; 4726 :       }
; 4727 : 
; 4728 :       // this is a little gross, so that we don't switch per-pixel or per-component
; 4729 :       if (depth < 8 || img_n == out_n) {

	inc	rdi
	inc	r14
	mov	r10, rdi
	inc	rbx
	mov	QWORD PTR prior$4$[rsp], r14
	mov	rdx, rdi
	mov	r8, r14
	cmp	eax, 8
	jl	$LN120@stbi__crea
$LN376@stbi__crea:
	mov	eax, DWORD PTR img_n$1$[rsp]
	cmp	eax, DWORD PTR out_n$[rsp]
	je	$LN120@stbi__crea

; 4743 :          }
; 4744 :          #undef STBI__CASE
; 4745 :          raw += nk;
; 4746 :       } else {
; 4747 :          STBI_ASSERT(img_n+1 == out_n);
; 4748 :          #define STBI__CASE(f) \
; 4749 :              case f:     \
; 4750 :                 for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
; 4751 :                    for (k=0; k < filter_bytes; ++k)
; 4752 :          switch (filter) {

	cmp	r9d, 6
	ja	$LN69@stbi__crea
	lea	r8, OFFSET FLAT:__ImageBase
	movsxd	rax, r9d
	mov	rdi, rdx
	mov	ecx, DWORD PTR $LN390@stbi__crea[r8+rax*4]
	add	rcx, r8
	jmp	rcx
$LN128@stbi__crea:

; 4753 :             STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;

	lea	eax, DWORD PTR [r11-1]
	cmp	eax, 1
	jb	$LN69@stbi__crea
	movsxd	r10, r12d
	mov	r9d, eax
$LL34@stbi__crea:
	test	r15, r15
	jle	SHORT $LN32@stbi__crea
	mov	r8, rdi
	mov	rcx, rbx
	sub	r8, rbx
	mov	rdx, r15
	npad	13
$LL284@stbi__crea:
	movzx	eax, BYTE PTR [r8+rcx]
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	sub	rdx, 1
	jne	SHORT $LL284@stbi__crea
$LN32@stbi__crea:
	mov	BYTE PTR [r15+rbx], 255			; 000000ffH
	add	rdi, r10
	add	rbx, rbp
	sub	r9, 1
	jne	SHORT $LL34@stbi__crea
	jmp	$LN69@stbi__crea
$LN129@stbi__crea:

; 4754 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;

	lea	eax, DWORD PTR [r11-1]
	cmp	eax, 1
	jb	$LN69@stbi__crea
	movsxd	r11, r12d
	mov	r10d, eax
	npad	6
$LL40@stbi__crea:
	test	r15, r15
	jle	SHORT $LN38@stbi__crea
	mov	r8, rbx
	mov	r9, rbx
	sub	r8, rbp
	mov	rcx, rdi
	sub	r8, rdi
	mov	rdx, r15
	sub	r9, rdi
	npad	6
$LL43@stbi__crea:
	movzx	eax, BYTE PTR [r8+rcx]
	add	al, BYTE PTR [rcx]
	mov	BYTE PTR [rcx+r9], al
	lea	rcx, QWORD PTR [rcx+1]
	sub	rdx, 1
	jne	SHORT $LL43@stbi__crea
$LN38@stbi__crea:
	mov	BYTE PTR [r15+rbx], 255			; 000000ffH
	add	rdi, r11
	add	rbx, rbp
	sub	r10, 1
	jne	SHORT $LL40@stbi__crea
	jmp	$LN69@stbi__crea
$LN130@stbi__crea:

; 4755 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;

	lea	eax, DWORD PTR [r11-1]
	cmp	eax, 1
	jb	$LN69@stbi__crea
	movsxd	rsi, r12d
	mov	r11d, eax
	npad	2
$LL46@stbi__crea:
	mov	rdx, r13
	test	r12d, r12d
	jle	$LN287@stbi__crea
	cmp	r12d, 8
	jb	$LN287@stbi__crea
	lea	eax, DWORD PTR [r12-1]
	movsxd	rcx, eax
	lea	rax, QWORD PTR [rcx+rdi]
	lea	r8, QWORD PTR [rcx+rbx]
	cmp	rbx, rax
	ja	SHORT $LN290@stbi__crea
	cmp	r8, rdi
	jae	$LN287@stbi__crea
$LN290@stbi__crea:
	lea	rax, QWORD PTR [rcx+r14]
	cmp	rbx, rax
	ja	SHORT $LN291@stbi__crea
	cmp	r8, r14
	jae	$LN287@stbi__crea
$LN291@stbi__crea:
	cmp	r12d, 64				; 00000040H
	jb	$LN374@stbi__crea
	mov	ecx, r12d
	and	ecx, -2147483585			; ffffffff8000003fH
	jge	SHORT $LN389@stbi__crea
	dec	ecx
	or	ecx, -64				; ffffffffffffffc0H
	inc	ecx
$LN389@stbi__crea:
	mov	eax, r12d
	sub	eax, ecx
	mov	r8, r14
	movsxd	r9, eax
	sub	r8, rdi
	lea	rax, QWORD PTR [rdi+16]
	mov	rcx, rbx
	sub	rcx, rdi
	npad	6
$LL49@stbi__crea:
	movdqu	xmm0, XMMWORD PTR [rax-16]
	add	rdx, 64					; 00000040H
	movdqu	xmm1, XMMWORD PTR [r8+rax-16]
	movdqu	xmm2, XMMWORD PTR [rax+r8]
	lea	rax, QWORD PTR [rax+64]
	paddb	xmm1, xmm0
	movdqu	xmm0, XMMWORD PTR [rax-64]
	movdqu	XMMWORD PTR [rcx+rax-80], xmm1
	paddb	xmm2, xmm0
	movdqu	xmm0, XMMWORD PTR [rax-48]
	movdqu	xmm1, XMMWORD PTR [r8+rax-48]
	movdqu	XMMWORD PTR [rax+rcx-64], xmm2
	paddb	xmm1, xmm0
	movdqu	xmm0, XMMWORD PTR [rax-32]
	movdqu	xmm2, XMMWORD PTR [r8+rax-32]
	movdqu	XMMWORD PTR [rcx+rax-48], xmm1
	paddb	xmm2, xmm0
	movdqu	XMMWORD PTR [rcx+rax-32], xmm2
	cmp	rdx, r9
	jl	SHORT $LL49@stbi__crea
	mov	eax, r12d
	and	al, 63					; 0000003fH
	cmp	al, 8
	jb	SHORT $LN287@stbi__crea
	jmp	SHORT $LN289@stbi__crea
$LN374@stbi__crea:
	mov	r8, r14
	sub	r8, rdi
$LN289@stbi__crea:
	mov	ecx, r12d
	and	ecx, -2147483641			; ffffffff80000007H
	jge	SHORT $LN388@stbi__crea
	dec	ecx
	or	ecx, -8
	inc	ecx
$LN388@stbi__crea:
	mov	eax, r12d
	sub	eax, ecx
	mov	rcx, rbx
	movsxd	r9, eax
	sub	rcx, rdi
	lea	rax, QWORD PTR [rdx+rdi]
	npad	7
$LL288@stbi__crea:
	movq	xmm1, QWORD PTR [rax+r8]
	add	rdx, 8
	movq	xmm0, QWORD PTR [rax]
	lea	rax, QWORD PTR [rax+8]
	paddb	xmm1, xmm0
	movq	QWORD PTR [rax+rcx-8], xmm1
	cmp	rdx, r9
	jl	SHORT $LL288@stbi__crea
$LN287@stbi__crea:
	cmp	rdx, r15
	jge	SHORT $LN44@stbi__crea
	mov	r9, r14
	lea	rcx, QWORD PTR [rdx+rdi]
	mov	r10, rbx
	sub	r9, rdi
	sub	r10, rdi
	mov	r8, r15
	sub	r8, rdx
	npad	4
$LL286@stbi__crea:
	movzx	eax, BYTE PTR [rcx+r9]
	add	al, BYTE PTR [rcx]
	mov	BYTE PTR [rcx+r10], al
	lea	rcx, QWORD PTR [rcx+1]
	sub	r8, 1
	jne	SHORT $LL286@stbi__crea
$LN44@stbi__crea:
	mov	BYTE PTR [r15+rbx], 255			; 000000ffH
	add	rdi, rsi
	add	rbx, rbp
	add	r14, rbp
	sub	r11, 1
	jne	$LL46@stbi__crea
	mov	rsi, QWORD PTR cur$9$[rsp]
	jmp	$LN69@stbi__crea
$LN131@stbi__crea:

; 4756 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;

	lea	eax, DWORD PTR [r11-1]
	cmp	eax, 1
	jb	$LN69@stbi__crea
	movsxd	r12, r12d
	mov	esi, eax
	npad	7
$LL52@stbi__crea:
	test	r15, r15
	jle	SHORT $LN50@stbi__crea
	mov	r8, rbx
	mov	r10, rdi
	sub	r8, rbp
	sub	r10, r14
	sub	r8, r14
	mov	r11, rbx
	sub	r11, r14
	mov	rdx, r14
	mov	r9, r15
$LL55@stbi__crea:
	movzx	ecx, BYTE PTR [r8+rdx]
	movzx	eax, BYTE PTR [rdx]
	lea	rdx, QWORD PTR [rdx+1]
	add	ecx, eax
	shr	ecx, 1
	add	cl, BYTE PTR [r10+rdx-1]
	mov	BYTE PTR [r11+rdx-1], cl
	sub	r9, 1
	jne	SHORT $LL55@stbi__crea
$LN50@stbi__crea:
	mov	BYTE PTR [r15+rbx], 255			; 000000ffH
	add	rdi, r12
	add	rbx, rbp
	add	r14, rbp
	sub	rsi, 1
	jne	SHORT $LL52@stbi__crea
	mov	rsi, QWORD PTR cur$9$[rsp]
	jmp	$LN69@stbi__crea
$LN132@stbi__crea:

; 4757 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;

	lea	ecx, DWORD PTR [r11-1]
	cmp	ecx, 1
	jb	$LN69@stbi__crea
	movsxd	rax, r12d
	mov	QWORD PTR tv5525[rsp], rax
	mov	eax, ecx
	mov	rcx, QWORD PTR tv5525[rsp]
	mov	QWORD PTR tv5458[rsp], rax
	npad	1
$LL58@stbi__crea:
	test	r15, r15
	jle	SHORT $LN56@stbi__crea
	mov	r13, r14
	mov	rsi, rbx
	sub	rsi, rbp
	sub	r13, rbx
	mov	rax, rbp
	mov	r12, r15
	sub	rax, rbx
	lea	rcx, QWORD PTR [rax+r14]
	lea	r15, QWORD PTR [rcx]
	lea	r14, QWORD PTR [rdi+rax]
	npad	11
$LL61@stbi__crea:
	movzx	r8d, BYTE PTR [rsi+r13]
	movzx	edx, BYTE PTR [r15+rsi]
	movzx	ecx, BYTE PTR [rsi]
	call	?stbi__paeth@@YAHHHH@Z			; stbi__paeth
	add	al, BYTE PTR [r14+rsi]
	mov	BYTE PTR [rsi+rbp], al
	lea	rsi, QWORD PTR [rsi+1]
	sub	r12, 1
	jne	SHORT $LL61@stbi__crea
	mov	r14, QWORD PTR prior$4$[rsp]
	mov	r15, QWORD PTR $T3[rsp]
	mov	rax, QWORD PTR tv5458[rsp]
	mov	rcx, QWORD PTR tv5525[rsp]
$LN56@stbi__crea:
	add	r14, rbp
	mov	BYTE PTR [r15+rbx], 255			; 000000ffH
	add	rbx, rbp
	mov	QWORD PTR prior$4$[rsp], r14
	add	rdi, rcx
	sub	rax, 1
	mov	QWORD PTR tv5458[rsp], rax
	jne	$LL58@stbi__crea
	mov	rsi, QWORD PTR cur$9$[rsp]
	jmp	$LN69@stbi__crea
$LN133@stbi__crea:

; 4758 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;

	lea	eax, DWORD PTR [r11-1]
	cmp	eax, 1
	jb	$LN69@stbi__crea
	movsxd	r11, r12d
	mov	r10d, eax
$LL64@stbi__crea:
	test	r15, r15
	jle	SHORT $LN62@stbi__crea
	mov	r8, rbx
	mov	r9, rbx
	sub	r8, rbp
	mov	rcx, rdi
	sub	r8, rdi
	mov	rdx, r15
	sub	r9, rdi
$LL67@stbi__crea:
	movzx	eax, BYTE PTR [r8+rcx]
	lea	rcx, QWORD PTR [rcx+1]
	shr	al, 1
	add	al, BYTE PTR [rcx-1]
	mov	BYTE PTR [r9+rcx-1], al
	sub	rdx, 1
	jne	SHORT $LL67@stbi__crea
$LN62@stbi__crea:
	mov	BYTE PTR [r15+rbx], 255			; 000000ffH
	add	rdi, r11
	add	rbx, rbp
	sub	r10, 1
	jne	SHORT $LL64@stbi__crea
	jmp	SHORT $LN69@stbi__crea
$LN134@stbi__crea:

; 4759 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;

	lea	eax, DWORD PTR [r11-1]
	cmp	eax, 1
	jb	SHORT $LN69@stbi__crea
	movsxd	r11, r12d
	mov	r10d, eax
	npad	5
$LL70@stbi__crea:
	test	r15, r15
	jle	SHORT $LN68@stbi__crea
	mov	r8, rbx
	mov	r9, rbx
	sub	r8, rbp
	mov	rcx, rdi
	sub	r8, rdi
	mov	rdx, r15
	sub	r9, rdi
	npad	6
$LL73@stbi__crea:

; 4642 :    if (pa <= pb && pa <= pc) return a;

	movzx	eax, BYTE PTR [r8+rcx]

; 4759 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;

	add	al, BYTE PTR [rcx]
	mov	BYTE PTR [r9+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	sub	rdx, 1
	jne	SHORT $LL73@stbi__crea
$LN68@stbi__crea:
	mov	BYTE PTR [r15+rbx], 255			; 000000ffH
	add	rdi, r11
	add	rbx, rbp
	sub	r10, 1
	jne	SHORT $LL70@stbi__crea
$LN69@stbi__crea:

; 4760 :          }
; 4761 :          #undef STBI__CASE
; 4762 : 
; 4763 :          // the loop above sets the high byte of the pixels' alpha, but for
; 4764 :          // 16 bit png files we also need the low byte set. we'll do that here.
; 4765 :          if (depth == 16) {

	mov	r14d, DWORD PTR depth$[rsp]
	cmp	r14d, 16
	jne	$LN479@stbi__crea

; 4767 :             for (i=0; i < x; ++i,cur+=output_bytes) {

	mov	r11d, DWORD PTR x$[rsp]
	test	r11d, r11d
	je	$LN2@stbi__crea

; 4766 :             cur = a->out + stride*j; // start at the beginning of the row again

	mov	eax, r11d
	npad	4
$LL76@stbi__crea:

; 4768 :                cur[filter_bytes+1] = 255;

	mov	BYTE PTR [r15+rsi+1], 255		; 000000ffH
	add	rsi, rbp
	sub	rax, 1
	jne	SHORT $LL76@stbi__crea

; 4685 :          if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");

	jmp	$LN2@stbi__crea
$LN120@stbi__crea:

; 4730 :          int nk = (width - 1)*filter_bytes;

	mov	r13d, DWORD PTR width$1$[rsp]
	dec	r13d
	imul	r13d, r12d
	mov	DWORD PTR nk$1$[rsp], r13d

; 4731 :          #define STBI__CASE(f) \
; 4732 :              case f:     \
; 4733 :                 for (k=0; k < nk; ++k)
; 4734 :          switch (filter) {

	cmp	r9d, 6
	ja	$LN28@stbi__crea
	lea	rdx, OFFSET FLAT:__ImageBase
	movsxd	rax, r9d
	movsxd	rsi, r13d
	mov	ecx, DWORD PTR $LN387@stbi__crea[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN121@stbi__crea:

; 4735 :             // "none" filter turns into a memcpy here; make that explicit.
; 4736 :             case STBI__F_none:         memcpy(cur, raw, nk); break;

	mov	r8, rsi
	mov	rdx, rdi
	mov	rcx, rbx
	call	memcpy
	jmp	$LN28@stbi__crea
$LN122@stbi__crea:

; 4737 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;

	test	r13d, r13d
	jle	$LN28@stbi__crea
	sub	rbx, rdi
	mov	rcx, rdi
	mov	rdx, rbx
	sub	rdx, r15
$LL14@stbi__crea:
	movzx	eax, BYTE PTR [rdx+rcx]
	add	al, BYTE PTR [rcx]
	mov	BYTE PTR [rcx+rbx], al
	lea	rcx, QWORD PTR [rcx+1]
	sub	rsi, 1
	jne	SHORT $LL14@stbi__crea
	jmp	$LN28@stbi__crea
$LN123@stbi__crea:

; 4738 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;

	xor	eax, eax
	mov	edx, eax
	test	r13d, r13d
	jle	$LN293@stbi__crea
	cmp	r13d, 8
	jb	$LN293@stbi__crea
	lea	eax, DWORD PTR [r13-1]
	movsxd	rcx, eax
	lea	rax, QWORD PTR [rdi+rcx]
	lea	r9, QWORD PTR [rbx+rcx]
	cmp	rbx, rax
	ja	SHORT $LN296@stbi__crea
	cmp	r9, rdi
	jae	$LN293@stbi__crea
$LN296@stbi__crea:
	lea	rax, QWORD PTR [r14+rcx]
	cmp	rbx, rax
	ja	SHORT $LN297@stbi__crea
	cmp	r9, r14
	jae	$LN293@stbi__crea
$LN297@stbi__crea:
	cmp	r13d, 64				; 00000040H
	jb	$LN375@stbi__crea
	mov	ecx, r13d
	and	ecx, -2147483585			; ffffffff8000003fH
	jge	SHORT $LN386@stbi__crea
	dec	ecx
	or	ecx, -64				; ffffffffffffffc0H
	inc	ecx
$LN386@stbi__crea:
	mov	eax, r13d
	sub	eax, ecx
	mov	r8, r14
	movsxd	r9, eax
	sub	r8, rdi
	lea	rax, QWORD PTR [rdi+16]
	mov	rcx, rbx
	sub	rcx, rdi
	npad	14
$LL17@stbi__crea:
	movdqu	xmm0, XMMWORD PTR [rax-16]
	add	rdx, 64					; 00000040H
	movdqu	xmm1, XMMWORD PTR [r8+rax-16]
	movdqu	xmm2, XMMWORD PTR [rax+r8]
	lea	rax, QWORD PTR [rax+64]
	paddb	xmm1, xmm0
	movdqu	xmm0, XMMWORD PTR [rax-64]
	movdqu	XMMWORD PTR [rcx+rax-80], xmm1
	paddb	xmm2, xmm0
	movdqu	xmm0, XMMWORD PTR [rax-48]
	movdqu	xmm1, XMMWORD PTR [r8+rax-48]
	movdqu	XMMWORD PTR [rax+rcx-64], xmm2
	paddb	xmm1, xmm0
	movdqu	xmm0, XMMWORD PTR [rax-32]
	movdqu	xmm2, XMMWORD PTR [r8+rax-32]
	movdqu	XMMWORD PTR [rcx+rax-48], xmm1
	paddb	xmm2, xmm0
	movdqu	XMMWORD PTR [rcx+rax-32], xmm2
	cmp	rdx, r9
	jl	SHORT $LL17@stbi__crea
	mov	eax, r13d
	and	al, 63					; 0000003fH
	cmp	al, 8
	jb	SHORT $LN293@stbi__crea
	jmp	SHORT $LN295@stbi__crea
$LN375@stbi__crea:
	sub	r8, r10
$LN295@stbi__crea:
	mov	ecx, r13d
	and	ecx, -2147483641			; ffffffff80000007H
	jge	SHORT $LN385@stbi__crea
	dec	ecx
	or	ecx, -8
	inc	ecx
$LN385@stbi__crea:
	mov	eax, r13d
	sub	eax, ecx
	mov	rcx, rbx
	movsxd	r9, eax
	sub	rcx, rdi
	lea	rax, QWORD PTR [rdi+rdx]
	npad	10
$LL294@stbi__crea:
	movq	xmm1, QWORD PTR [rax+r8]
	add	rdx, 8
	movq	xmm0, QWORD PTR [rax]
	lea	rax, QWORD PTR [rax+8]
	paddb	xmm1, xmm0
	movq	QWORD PTR [rax+rcx-8], xmm1
	cmp	rdx, r9
	jl	SHORT $LL294@stbi__crea
$LN293@stbi__crea:
	cmp	rdx, rsi
	jge	$LN28@stbi__crea
	sub	r14, rdi
	lea	rcx, QWORD PTR [rdi+rdx]
	sub	rbx, rdi
	sub	rsi, rdx
	npad	9
$LL292@stbi__crea:
	movzx	eax, BYTE PTR [rcx+r14]
	add	al, BYTE PTR [rcx]
	mov	BYTE PTR [rcx+rbx], al
	lea	rcx, QWORD PTR [rcx+1]
	sub	rsi, 1
	jne	SHORT $LL292@stbi__crea
	jmp	$LN28@stbi__crea
$LN124@stbi__crea:

; 4739 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;

	test	r13d, r13d
	jle	$LN28@stbi__crea
	sub	rbx, r14
	mov	r8, rdi
	mov	rdx, rbx
	sub	rdx, r15
	sub	r8, r14
$LL20@stbi__crea:
	movzx	ecx, BYTE PTR [r14+rdx]
	movzx	eax, BYTE PTR [r14]
	lea	r14, QWORD PTR [r14+1]
	add	ecx, eax
	shr	ecx, 1
	add	cl, BYTE PTR [r14+r8-1]
	mov	BYTE PTR [r14+rbx-1], cl
	sub	rsi, 1
	jne	SHORT $LL20@stbi__crea
	jmp	$LN28@stbi__crea
$LN125@stbi__crea:

; 4740 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;

	test	r13d, r13d
	jle	$LN28@stbi__crea
	sub	r14, rbx
	mov	r12, rbx
	sub	r12, r15
	mov	rax, rdi
	sub	rax, rbx
	lea	r13, QWORD PTR [r15+r14]
	lea	rbx, QWORD PTR [rax+r15]
	npad	9
$LL23@stbi__crea:
	movzx	r8d, BYTE PTR [r14+r12]
	movzx	edx, BYTE PTR [r12+r13]
	movzx	ecx, BYTE PTR [r12]
	call	?stbi__paeth@@YAHHHH@Z			; stbi__paeth
	add	al, BYTE PTR [rbx+r12]
	mov	BYTE PTR [r15+r12], al
	lea	r12, QWORD PTR [r12+1]
	sub	rsi, 1
	jne	SHORT $LL23@stbi__crea
	mov	r13d, DWORD PTR nk$1$[rsp]
	jmp	SHORT $LN28@stbi__crea
$LN126@stbi__crea:

; 4741 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;

	test	r13d, r13d
	jle	SHORT $LN28@stbi__crea
	sub	rbx, rdi
	mov	rcx, rdi
	mov	rdx, rbx
	sub	rdx, r15
	npad	1
$LL26@stbi__crea:
	movzx	eax, BYTE PTR [rdx+rcx]
	lea	rcx, QWORD PTR [rcx+1]
	shr	al, 1
	add	al, BYTE PTR [rcx-1]
	mov	BYTE PTR [rcx+rbx-1], al
	sub	rsi, 1
	jne	SHORT $LL26@stbi__crea
	jmp	SHORT $LN28@stbi__crea
$LN127@stbi__crea:

; 4742 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;

	test	r13d, r13d
	jle	SHORT $LN28@stbi__crea
	sub	rbx, rdi
	mov	rcx, rdi
	mov	rdx, rbx
	sub	rdx, r15
	npad	6
$LL29@stbi__crea:

; 4642 :    if (pa <= pb && pa <= pc) return a;

	movzx	eax, BYTE PTR [rcx+rdx]

; 4742 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;

	add	al, BYTE PTR [rcx]
	mov	BYTE PTR [rcx+rbx], al
	lea	rcx, QWORD PTR [rcx+1]
	sub	rsi, 1
	jne	SHORT $LL29@stbi__crea
$LN28@stbi__crea:

; 4760 :          }
; 4761 :          #undef STBI__CASE
; 4762 : 
; 4763 :          // the loop above sets the high byte of the pixels' alpha, but for
; 4764 :          // 16 bit png files we also need the low byte set. we'll do that here.
; 4765 :          if (depth == 16) {

	mov	r14d, DWORD PTR depth$[rsp]
	movsxd	rax, r13d
	add	rdi, rax
$LN479@stbi__crea:

; 4675 : 
; 4676 :    for (j=0; j < y; ++j) {

	mov	r11d, DWORD PTR x$[rsp]
$LN2@stbi__crea:
	mov	ecx, DWORD PTR j$1$[rsp]
	xor	r13d, r13d
	mov	esi, DWORD PTR y$[rsp]
	inc	ecx
	mov	r8d, DWORD PTR img_width_bytes$1$[rsp]
	mov	DWORD PTR j$1$[rsp], ecx
	cmp	ecx, esi
	jae	SHORT $LN478@stbi__crea
	mov	r12d, DWORD PTR filter_bytes$1$[rsp]
	mov	r9, QWORD PTR $T1[rsp]
	jmp	$LL4@stbi__crea
$LN253@stbi__crea:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0O@MKGNGALN@invalid?5width@

; 4685 :          if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");

	jmp	$LN633@stbi__crea
$LN252@stbi__crea:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0P@FBBCPGMN@invalid?5filter@

; 4682 :          return stbi__err("invalid filter","Corrupt PNG");

	jmp	$LN633@stbi__crea
$LN478@stbi__crea:

; 4675 : 
; 4676 :    for (j=0; j < y; ++j) {

	mov	edx, DWORD PTR a$1$[rsp]
	lea	rbp, OFFSET FLAT:__ImageBase
	mov	r10, QWORD PTR cur$1$[rsp]
	mov	r15d, DWORD PTR out_n$[rsp]
$LN3@stbi__crea:

; 4769 :             }
; 4770 :          }
; 4771 :       }
; 4772 :    }
; 4773 : 
; 4774 :    // we make a separate pass to expand bits to pixels; for performance,
; 4775 :    // this could run two scanlines behind the above code, so it won't
; 4776 :    // intefere with filtering but will still be in the cache.
; 4777 :    if (depth < 8) {

	movsxd	rbx, DWORD PTR depth$[rsp]
	cmp	ebx, 8
	jge	$LN136@stbi__crea

; 4778 :       for (j=0; j < y; ++j) {

	test	esi, esi
	je	$LN96@stbi__crea

; 4781 :          // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
; 4782 :          // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
; 4783 :          stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

	mov	r12d, DWORD PTR color$[rsp]
	lea	r14, QWORD PTR ?stbi__depth_scale_table@@3QBEB[rbx]
	add	r14, rbp
	movsxd	rsi, r11d
	mov	ebp, r15d
	mov	r15d, r8d
	imul	ebp, r11d
	npad	5
$LL79@stbi__crea:

; 4779 :          stbi_uc *cur = a->out + stride*j;

	mov	rax, QWORD PTR $T1[rsp]
	mov	ecx, r13d
	imul	ecx, DWORD PTR stride$1$[rsp]

; 4780 :          stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;

	mov	r9, rbp
	sub	r9, r15
	add	r9, rcx
	add	r9, rax
	lea	r11, QWORD PTR [rcx+rax]
	mov	r8, r11

; 4781 :          // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
; 4782 :          // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
; 4783 :          stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

	test	r12d, r12d
	jne	SHORT $LN159@stbi__crea
	movzx	r10d, BYTE PTR [r14]
	jmp	SHORT $LN160@stbi__crea
$LN159@stbi__crea:
	mov	r10b, 1
$LN160@stbi__crea:

; 4784 : 
; 4785 :          // note that the final byte might overshoot and write more data than desired.
; 4786 :          // we can allocate enough data that this never writes out of memory, but it
; 4787 :          // could also overwrite the next scanline. can it overwrite non-empty data
; 4788 :          // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
; 4789 :          // so we need to explicitly clamp the final ones
; 4790 : 
; 4791 :          if (depth == 4) {

	mov	ecx, edx
	mov	DWORD PTR a$1$[rsp], ecx
	cmp	ebx, 4
	jne	SHORT $LN138@stbi__crea

; 4792 :             for (k=x*img_n; k >= 2; k-=2, ++in) {

	mov	edi, ecx
	cmp	ecx, 2
	jl	SHORT $LN81@stbi__crea
	mov	ebx, ecx
	mov	DWORD PTR a$1$[rsp], ecx
	shr	rbx, 1
	mov	eax, ebx
	neg	eax
	lea	edi, DWORD PTR [rcx+rax*2]
	npad	10
$LL82@stbi__crea:

; 4793 :                *cur++ = scale * ((*in >> 4)       );

	movzx	eax, BYTE PTR [r9]
	shr	al, 4
	movzx	edx, al
	movzx	ecx, r10b
	imul	edx, ecx

; 4794 :                *cur++ = scale * ((*in     ) & 0x0f);

	movzx	ecx, r10b
	mov	BYTE PTR [r8], dl
	movzx	eax, BYTE PTR [r9]
	inc	r9
	and	al, 15
	movzx	edx, al
	imul	edx, ecx
	mov	BYTE PTR [r8+1], dl
	add	r8, 2
	sub	rbx, 1
	jne	SHORT $LL82@stbi__crea
$LN81@stbi__crea:

; 4795 :             }
; 4796 :             if (k > 0) *cur++ = scale * ((*in >> 4)       );

	test	edi, edi
	jle	$LN153@stbi__crea
	movzx	eax, BYTE PTR [r9]
	shr	al, 4
	movzx	edx, al
	movzx	ecx, r10b
	imul	edx, ecx
	mov	BYTE PTR [r8], dl
	jmp	$LN153@stbi__crea
$LN138@stbi__crea:

; 4797 :          } else if (depth == 2) {

	cmp	ebx, 2
	jne	$LN141@stbi__crea

; 4798 :             for (k=x*img_n; k >= 4; k-=4, ++in) {

	mov	rdi, rcx
	cmp	ecx, 4
	jl	SHORT $LN84@stbi__crea
	mov	rbx, rcx
	mov	DWORD PTR a$1$[rsp], ecx
	shr	rbx, 2
	mov	eax, ebx
	neg	eax
	lea	edi, DWORD PTR [rcx+rax*4]
	npad	4
$LL85@stbi__crea:

; 4799 :                *cur++ = scale * ((*in >> 6)       );

	movzx	eax, BYTE PTR [r9]
	shr	al, 6
	movzx	edx, al
	movzx	ecx, r10b
	imul	edx, ecx

; 4800 :                *cur++ = scale * ((*in >> 4) & 0x03);

	movzx	eax, r10b
	mov	BYTE PTR [r8], dl
	movzx	ecx, BYTE PTR [r9]
	shr	cl, 4
	and	cl, 3
	movzx	ecx, cl
	imul	ecx, eax

; 4801 :                *cur++ = scale * ((*in >> 2) & 0x03);

	movzx	eax, r10b
	mov	BYTE PTR [r8+1], cl
	movzx	ecx, BYTE PTR [r9]
	shr	cl, 2
	and	cl, 3
	movzx	ecx, cl
	imul	ecx, eax
	mov	BYTE PTR [r8+2], cl

; 4802 :                *cur++ = scale * ((*in     ) & 0x03);

	movzx	eax, BYTE PTR [r9]
	inc	r9
	and	al, 3
	movzx	ecx, r10b
	movzx	edx, al
	imul	edx, ecx
	mov	BYTE PTR [r8+3], dl
	add	r8, 4
	sub	rbx, 1
	jne	SHORT $LL85@stbi__crea
$LN84@stbi__crea:

; 4803 :             }
; 4804 :             if (k > 0) *cur++ = scale * ((*in >> 6)       );

	test	edi, edi
	jle	SHORT $LN143@stbi__crea
	movzx	eax, BYTE PTR [r9]
	shr	al, 6
	movzx	edx, al
	movzx	ecx, r10b
	imul	edx, ecx
	mov	BYTE PTR [r8], dl
	inc	r8
$LN143@stbi__crea:

; 4805 :             if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);

	cmp	edi, 1
	jle	SHORT $LN144@stbi__crea
	movzx	ecx, BYTE PTR [r9]
	shr	cl, 4
	and	cl, 3
	movzx	eax, r10b
	movzx	ecx, cl
	imul	ecx, eax
	mov	BYTE PTR [r8], cl
	inc	r8
$LN144@stbi__crea:

; 4806 :             if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);

	cmp	edi, 2
	jle	$LN153@stbi__crea
	movzx	ecx, BYTE PTR [r9]
	shr	cl, 2
	and	cl, 3
	jmp	$LN634@stbi__crea
$LN141@stbi__crea:

; 4807 :          } else if (depth == 1) {

	cmp	ebx, 1
	jne	$LN153@stbi__crea

; 4808 :             for (k=x*img_n; k >= 8; k-=8, ++in) {

	mov	DWORD PTR a$1$[rsp], ecx
	mov	rbx, rcx
	cmp	ecx, 8
	jl	$LN87@stbi__crea
	mov	rdi, rcx
	mov	DWORD PTR a$1$[rsp], ecx
	shr	rdi, 3
	mov	eax, edi
	neg	eax
	lea	ebx, DWORD PTR [rcx+rax*8]
	npad	8
$LL88@stbi__crea:

; 4809 :                *cur++ = scale * ((*in >> 7)       );

	movzx	eax, BYTE PTR [r9]
	shr	al, 7
	movzx	edx, al
	movzx	ecx, r10b
	imul	edx, ecx

; 4810 :                *cur++ = scale * ((*in >> 6) & 0x01);

	movzx	eax, r10b
	mov	BYTE PTR [r8], dl
	movzx	ecx, BYTE PTR [r9]
	shr	cl, 6
	and	cl, 1
	movzx	ecx, cl
	imul	ecx, eax

; 4811 :                *cur++ = scale * ((*in >> 5) & 0x01);

	movzx	eax, r10b
	mov	BYTE PTR [r8+1], cl
	movzx	ecx, BYTE PTR [r9]
	shr	cl, 5
	and	cl, 1
	movzx	ecx, cl
	imul	ecx, eax

; 4812 :                *cur++ = scale * ((*in >> 4) & 0x01);

	movzx	eax, r10b
	mov	BYTE PTR [r8+2], cl
	movzx	ecx, BYTE PTR [r9]
	shr	cl, 4
	and	cl, 1
	movzx	ecx, cl
	imul	ecx, eax

; 4813 :                *cur++ = scale * ((*in >> 3) & 0x01);

	movzx	eax, r10b
	mov	BYTE PTR [r8+3], cl
	movzx	ecx, BYTE PTR [r9]
	shr	cl, 3
	and	cl, 1
	movzx	ecx, cl
	imul	ecx, eax

; 4814 :                *cur++ = scale * ((*in >> 2) & 0x01);

	movzx	eax, r10b
	mov	BYTE PTR [r8+4], cl
	movzx	ecx, BYTE PTR [r9]
	shr	cl, 2
	and	cl, 1
	movzx	ecx, cl
	imul	ecx, eax

; 4815 :                *cur++ = scale * ((*in >> 1) & 0x01);

	movzx	eax, r10b
	mov	BYTE PTR [r8+5], cl
	movzx	ecx, BYTE PTR [r9]
	shr	cl, 1
	and	cl, 1
	movzx	ecx, cl
	imul	ecx, eax
	mov	BYTE PTR [r8+6], cl

; 4816 :                *cur++ = scale * ((*in     ) & 0x01);

	movzx	eax, BYTE PTR [r9]
	inc	r9
	and	al, 1
	movzx	ecx, r10b
	movzx	edx, al
	imul	edx, ecx
	mov	BYTE PTR [r8+7], dl
	add	r8, 8
	sub	rdi, 1
	jne	$LL88@stbi__crea
$LN87@stbi__crea:

; 4817 :             }
; 4818 :             if (k > 0) *cur++ = scale * ((*in >> 7)       );

	test	ebx, ebx
	jle	SHORT $LN147@stbi__crea
	movzx	eax, BYTE PTR [r9]
	shr	al, 7
	movzx	edx, al
	movzx	ecx, r10b
	imul	edx, ecx
	mov	BYTE PTR [r8], dl
	inc	r8
$LN147@stbi__crea:

; 4819 :             if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);

	cmp	ebx, 1
	jle	SHORT $LN148@stbi__crea
	movzx	ecx, BYTE PTR [r9]
	shr	cl, 6
	and	cl, 1
	movzx	eax, r10b
	movzx	ecx, cl
	imul	ecx, eax
	mov	BYTE PTR [r8], cl
	inc	r8
$LN148@stbi__crea:

; 4820 :             if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);

	cmp	ebx, 2
	jle	SHORT $LN149@stbi__crea
	movzx	ecx, BYTE PTR [r9]
	shr	cl, 5
	and	cl, 1
	movzx	eax, r10b
	movzx	ecx, cl
	imul	ecx, eax
	mov	BYTE PTR [r8], cl
	inc	r8
$LN149@stbi__crea:

; 4821 :             if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);

	cmp	ebx, 3
	jle	SHORT $LN150@stbi__crea
	movzx	ecx, BYTE PTR [r9]
	shr	cl, 4
	and	cl, 1
	movzx	eax, r10b
	movzx	ecx, cl
	imul	ecx, eax
	mov	BYTE PTR [r8], cl
	inc	r8
$LN150@stbi__crea:

; 4822 :             if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);

	cmp	ebx, 4
	jle	SHORT $LN151@stbi__crea
	movzx	ecx, BYTE PTR [r9]
	shr	cl, 3
	and	cl, 1
	movzx	eax, r10b
	movzx	ecx, cl
	imul	ecx, eax
	mov	BYTE PTR [r8], cl
	inc	r8
$LN151@stbi__crea:

; 4823 :             if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);

	cmp	ebx, 5
	jle	SHORT $LN152@stbi__crea
	movzx	ecx, BYTE PTR [r9]
	shr	cl, 2
	and	cl, 1
	movzx	eax, r10b
	movzx	ecx, cl
	imul	ecx, eax
	mov	BYTE PTR [r8], cl
	inc	r8
$LN152@stbi__crea:

; 4824 :             if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);

	cmp	ebx, 6
	jle	SHORT $LN153@stbi__crea
	movzx	ecx, BYTE PTR [r9]
	shr	cl, 1
	and	cl, 1
$LN634@stbi__crea:

; 4825 :          }
; 4826 :          if (img_n != out_n) {

	movzx	eax, r10b
	movzx	ecx, cl
	imul	ecx, eax
	mov	BYTE PTR [r8], cl
$LN153@stbi__crea:
	mov	eax, DWORD PTR img_n$1$[rsp]
	cmp	eax, DWORD PTR out_n$[rsp]
	je	$LN77@stbi__crea

; 4827 :             int q;
; 4828 :             // insert alpha = 255
; 4829 :             cur = a->out + stride*j;

	lea	rcx, QWORD PTR [rsi-1]

; 4830 :             if (img_n == 1) {

	cmp	eax, 1
	jne	SHORT $LN155@stbi__crea

; 4831 :                for (q=x-1; q >= 0; --q) {

	test	rcx, rcx
	js	SHORT $LN77@stbi__crea
	npad	8
$LL91@stbi__crea:

; 4832 :                   cur[q*2+1] = 255;

	mov	BYTE PTR [r11+rcx*2+1], 255		; 000000ffH

; 4833 :                   cur[q*2+0] = cur[q];

	movzx	eax, BYTE PTR [rcx+r11]
	mov	BYTE PTR [r11+rcx*2], al
	sub	rcx, 1
	jns	SHORT $LL91@stbi__crea

; 4834 :                }
; 4835 :             } else {

	jmp	SHORT $LN77@stbi__crea
$LN155@stbi__crea:

; 4836 :                STBI_ASSERT(img_n == 3);
; 4837 :                for (q=x-1; q >= 0; --q) {

	test	rcx, rcx
	js	SHORT $LN77@stbi__crea
	lea	r8, QWORD PTR [rcx*2+1]
	add	r8, r11
	lea	rdx, QWORD PTR [rcx*4+2]
	add	r8, rcx
	add	rdx, r11
	npad	11
$LL94@stbi__crea:
	sub	rcx, 1

; 4838 :                   cur[q*4+3] = 255;

	mov	BYTE PTR [rdx+1], 255			; 000000ffH

; 4839 :                   cur[q*4+2] = cur[q*3+2];

	movzx	eax, BYTE PTR [r8+1]
	lea	r8, QWORD PTR [r8-3]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx-4]

; 4840 :                   cur[q*4+1] = cur[q*3+1];

	movzx	eax, BYTE PTR [r8+3]
	mov	BYTE PTR [rdx+3], al

; 4841 :                   cur[q*4+0] = cur[q*3+0];

	movzx	eax, BYTE PTR [r8+2]
	mov	BYTE PTR [rdx+2], al
	jns	SHORT $LL94@stbi__crea
$LN77@stbi__crea:

; 4778 :       for (j=0; j < y; ++j) {

	mov	edx, DWORD PTR a$1$[rsp]
	inc	r13d
	mov	ebx, DWORD PTR depth$[rsp]
	cmp	r13d, DWORD PTR y$[rsp]
	jb	$LL79@stbi__crea

; 4856 :       }
; 4857 :    }
; 4858 : 
; 4859 :    return 1;

	mov	eax, 1
	jmp	$LN1@stbi__crea
$LN136@stbi__crea:

; 4842 :                }
; 4843 :             }
; 4844 :          }
; 4845 :       }
; 4846 :    } else if (depth == 16) {

	cmp	ebx, 16
	jne	SHORT $LN96@stbi__crea

; 4852 :       stbi__uint16 *cur16 = (stbi__uint16*)cur;
; 4853 : 
; 4854 :       for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {

	imul	r15d, r11d
	mov	r8, r10
	imul	r15d, esi
	test	r15d, r15d
	je	SHORT $LN96@stbi__crea

; 4847 :       // force the image data from big-endian to platform-native.
; 4848 :       // this is done in a separate pass due to the decoding relying
; 4849 :       // on the data being untouched, but could probably be done
; 4850 :       // per-line during decode if care is taken.
; 4851 :       stbi_uc *cur = a->out;

	mov	r9d, r15d
	npad	6
$LL97@stbi__crea:

; 4855 :          *cur16 = (cur[0] << 8) | cur[1];

	movzx	edx, BYTE PTR [r10]
	lea	r10, QWORD PTR [r10+2]
	movzx	ecx, BYTE PTR [r8+1]
	lea	r8, QWORD PTR [r8+2]
	shl	dx, 8
	or	dx, cx
	mov	WORD PTR [r8-2], dx
	sub	r9, 1
	jne	SHORT $LL97@stbi__crea
$LN96@stbi__crea:

; 4856 :       }
; 4857 :    }
; 4858 : 
; 4859 :    return 1;

	mov	eax, 1
	jmp	SHORT $LN1@stbi__crea
$LN377@stbi__crea:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@

; 4666 : 
; 4667 :    if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");

	jmp	SHORT $LN633@stbi__crea
$LN381@stbi__crea:

; 1055 :    if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;

	mov	QWORD PTR [rsi+24], r13
$LN380@stbi__crea:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
$LN633@stbi__crea:

; 4860 : }

	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	QWORD PTR [rdx+rcx], rax
	xor	eax, eax
$LN1@stbi__crea:
	mov	rbx, QWORD PTR [rsp+216]
	add	rsp, 144				; 00000090H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN391@stbi__crea:
	DD	$LL399@stbi__crea
	DD	$LL400@stbi__crea
	DD	$LL440@stbi__crea
	DD	$LL441@stbi__crea
	DD	$LL442@stbi__crea
	DD	$LL443@stbi__crea
	DD	$LL444@stbi__crea
$LN390@stbi__crea:
	DD	$LN128@stbi__crea
	DD	$LN129@stbi__crea
	DD	$LN130@stbi__crea
	DD	$LN131@stbi__crea
	DD	$LN132@stbi__crea
	DD	$LN133@stbi__crea
	DD	$LN134@stbi__crea
$LN387@stbi__crea:
	DD	$LN121@stbi__crea
	DD	$LN122@stbi__crea
	DD	$LN123@stbi__crea
	DD	$LN124@stbi__crea
	DD	$LN125@stbi__crea
	DD	$LN126@stbi__crea
	DD	$LN127@stbi__crea
?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z ENDP ; stbi__create_png_image_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
_TEXT	SEGMENT
tv919 = 64
p$1$ = 68
tv928 = 72
tv936 = 76
tv934 = 80
x$1$ = 84
y$1$ = 88
tv918 = 92
tv929 = 96
img_len$1$ = 100
final$1$ = 104
tv916 = 112
tv930 = 120
xspc$1 = 128
xorig$2 = 160
yspc$3 = 192
yorig$4 = 224
a$ = 336
image_data$ = 344
image_data_len$ = 352
out_n$ = 360
depth$ = 368
color$ = 376
j$1$ = 384
interlaced$ = 384
?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z PROC ; stbi__create_png_image, COMDAT

; 4863 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rdi
	push	r12
	push	r14
	sub	rsp, 288				; 00000120H

; 4864 :    int bytes = (depth == 16 ? 2 : 1);

	xor	ebx, ebx
	mov	rdi, rdx
	mov	edx, DWORD PTR depth$[rsp]
	mov	ebp, ebx
	cmp	edx, 16
	mov	r12, rcx

; 4865 :    int out_bytes = out_n * bytes;

	mov	rcx, QWORD PTR [rcx]
	mov	r14d, r8d
	sete	bpl
	inc	ebp
	imul	ebp, r9d

; 4866 :    stbi_uc *final;
; 4867 :    int p;
; 4868 :    if (!interlaced)

	cmp	DWORD PTR interlaced$[rsp], ebx
	jne	SHORT $LN11@stbi__crea

; 4869 :       return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

	mov	eax, DWORD PTR color$[rsp]
	mov	DWORD PTR [rsp+56], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rsp+48], edx
	mov	rdx, rdi
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [rcx]
	mov	rcx, r12
	mov	DWORD PTR [rsp+32], eax
	call	?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z ; stbi__create_png_image_raw

; 4905 : }

	add	rsp, 288				; 00000120H
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN11@stbi__crea:

; 4870 : 
; 4871 :    // de-interlacing
; 4872 :    final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);

	mov	r8d, DWORD PTR [rcx+4]
	mov	ecx, DWORD PTR [rcx]
	mov	QWORD PTR [rsp+280], rsi

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	$LN53@stbi__crea
	test	r8d, r8d
	js	$LN53@stbi__crea

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN57@stbi__crea

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	r8d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	$LN53@stbi__crea
$LN57@stbi__crea:
	imul	ecx, r8d

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	$LN53@stbi__crea
	test	ebp, ebp
	js	$LN53@stbi__crea

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN17@stbi__crea

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	ebp

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	$LN53@stbi__crea
$LN17@stbi__crea:

; 1056 :    return stbi__malloc(a*b*c + add);

	imul	ecx, ebp
	movsxd	rcx, ecx

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc
	mov	QWORD PTR final$1$[rsp], rax

; 4873 :    if (!final) return stbi__err("outofmem", "Out of memory");

	test	rax, rax
	je	$LN53@stbi__crea
	mov	QWORD PTR [rsp+272], r13

; 4874 :    for (p=0; p < 7; ++p) {

	mov	r9d, ebx
	mov	QWORD PTR [rsp+264], r15
	mov	r13, rbx
	mov	DWORD PTR p$1$[rsp], ebx
	mov	QWORD PTR tv916[rsp], rbx
	npad	10
$LL4@stbi__crea:

; 4875 :       int xorig[] = { 0,4,0,2,0,1,0 };

	movdqa	xmm0, XMMWORD PTR __xmm@00000002000000000000000400000000

; 4876 :       int yorig[] = { 0,0,4,0,2,0,1 };
; 4877 :       int xspc[]  = { 8,8,4,4,2,2,1 };
; 4878 :       int yspc[]  = { 8,8,8,4,4,2,2 };
; 4879 :       int i,j,x,y;
; 4880 :       // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
; 4881 :       x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];

	xor	edx, edx
	mov	r8, QWORD PTR [r12]
	movdqu	XMMWORD PTR xorig$2[rsp], xmm0
	mov	DWORD PTR xspc$1[rsp+16], 2
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000040000000000000000
	movdqu	XMMWORD PTR yorig$4[rsp], xmm0
	mov	DWORD PTR xspc$1[rsp+20], 2
	movdqa	xmm0, XMMWORD PTR __xmm@00000004000000040000000800000008
	movdqu	XMMWORD PTR xspc$1[rsp], xmm0
	mov	DWORD PTR xspc$1[rsp+24], 1
	mov	r10d, DWORD PTR xspc$1[rsp+r13]
	mov	ecx, r10d
	movdqa	xmm0, XMMWORD PTR __xmm@00000004000000080000000800000008
	mov	DWORD PTR xorig$2[rsp+16], ebx
	mov	QWORD PTR xorig$2[rsp+20], 1
	mov	eax, DWORD PTR xorig$2[rsp+r13]
	sub	ecx, eax
	mov	DWORD PTR tv934[rsp], eax
	mov	eax, DWORD PTR [r8]
	dec	eax
	mov	QWORD PTR yorig$4[rsp+16], 2
	add	eax, ecx
	mov	DWORD PTR yorig$4[rsp+24], 1
	div	r10d
	movdqu	XMMWORD PTR yspc$3[rsp], xmm0
	mov	r15d, eax

; 4882 :       y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];

	mov	eax, DWORD PTR yorig$4[rsp+r13]
	mov	DWORD PTR yspc$3[rsp+16], 4
	mov	DWORD PTR yspc$3[rsp+20], 2
	mov	DWORD PTR yspc$3[rsp+24], 2
	mov	esi, DWORD PTR yspc$3[rsp+r13]
	mov	DWORD PTR tv936[rsp], r10d
	mov	DWORD PTR x$1$[rsp], r15d
	mov	DWORD PTR tv929[rsp], esi
	mov	DWORD PTR tv928[rsp], eax

; 4883 :       if (x && y) {

	test	r15d, r15d
	je	$LN2@stbi__crea

; 4882 :       y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];

	mov	ecx, DWORD PTR [r8+4]
	xor	edx, edx
	sub	ecx, eax
	lea	eax, DWORD PTR [rcx-1]
	add	eax, esi
	div	esi
	mov	DWORD PTR y$1$[rsp], eax
	mov	edi, eax

; 4883 :       if (x && y) {

	test	eax, eax
	je	$LN2@stbi__crea

; 4884 :          stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;

	mov	eax, DWORD PTR depth$[rsp]
	mov	ebx, r15d
	imul	ebx, DWORD PTR [r8+8]

; 4885 :          if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {

	mov	r8d, r14d
	mov	ecx, DWORD PTR color$[rsp]
	mov	r9d, DWORD PTR out_n$[rsp]
	mov	rdx, QWORD PTR image_data$[rsp]
	mov	DWORD PTR [rsp+56], ecx
	mov	rcx, r12
	imul	ebx, eax
	mov	DWORD PTR [rsp+48], eax
	mov	DWORD PTR [rsp+40], edi
	mov	DWORD PTR [rsp+32], r15d
	add	ebx, 7
	sar	ebx, 3
	inc	ebx
	imul	ebx, edi
	mov	DWORD PTR img_len$1$[rsp], ebx
	call	?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z ; stbi__create_png_image_raw
	test	eax, eax
	je	$LN43@stbi__crea

; 4888 :          }
; 4889 :          for (j=0; j < y; ++j) {

	xor	r14d, r14d
	mov	DWORD PTR j$1$[rsp], r14d
	test	edi, edi
	jle	$LN6@stbi__crea
	xor	r13d, r13d
	mov	eax, r15d
	imul	eax, ebp
	mov	DWORD PTR tv919[rsp], r13d
	mov	DWORD PTR tv918[rsp], eax
$LL7@stbi__crea:

; 4890 :             for (i=0; i < x; ++i) {

	test	r15d, r15d
	jle	$LN5@stbi__crea

; 4891 :                int out_y = j*yspc[p]+yorig[p];
; 4892 :                int out_x = i*xspc[p]+xorig[p];
; 4893 :                memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,

	mov	r8, QWORD PTR a$[rsp]
	mov	edi, esi
	mov	r12d, DWORD PTR tv936[rsp]
	mov	esi, r13d
	mov	ebx, DWORD PTR tv934[rsp]
	imul	edi, r14d
	mov	r14, QWORD PTR [r8]
	imul	r12d, ebp
	movsxd	r13, ebp
	add	edi, DWORD PTR tv928[rsp]
	imul	edi, ebp
	imul	ebx, ebp
	npad	4
$LL10@stbi__crea:
	mov	rax, QWORD PTR final$1$[rsp]
	movsxd	rdx, esi
	add	rdx, QWORD PTR [r8+24]
	mov	r8d, edi
	imul	r8d, DWORD PTR [r14]
	movsxd	rcx, ebx
	add	rax, r8
	mov	r8, r13
	add	rcx, rax
	call	memcpy
	mov	r8, QWORD PTR a$[rsp]
	add	esi, ebp
	add	ebx, r12d
	sub	r15, 1
	jne	SHORT $LL10@stbi__crea
	mov	r14d, DWORD PTR j$1$[rsp]
	mov	r13d, DWORD PTR tv919[rsp]
	mov	r15d, DWORD PTR x$1$[rsp]
	mov	edi, DWORD PTR y$1$[rsp]
	mov	eax, DWORD PTR tv918[rsp]
	mov	esi, DWORD PTR tv929[rsp]
$LN5@stbi__crea:

; 4888 :          }
; 4889 :          for (j=0; j < y; ++j) {

	inc	r14d
	add	r13d, eax
	mov	DWORD PTR j$1$[rsp], r14d
	mov	DWORD PTR tv919[rsp], r13d
	cmp	r14d, edi
	jl	$LL7@stbi__crea
	mov	ebx, DWORD PTR img_len$1$[rsp]
	mov	r12, QWORD PTR a$[rsp]
	mov	r13, QWORD PTR tv916[rsp]
$LN6@stbi__crea:

; 4894 :                       a->out + (j*x+i)*out_bytes, out_bytes);
; 4895 :             }
; 4896 :          }
; 4897 :          STBI_FREE(a->out);

	mov	rcx, QWORD PTR [r12+24]
	call	QWORD PTR __imp_free

; 4898 :          image_data += img_len;
; 4899 :          image_data_len -= img_len;

	mov	r14d, DWORD PTR image_data_len$[rsp]
	mov	r9d, DWORD PTR p$1$[rsp]
	sub	r14d, ebx
	mov	eax, ebx
	add	QWORD PTR image_data$[rsp], rax
	xor	ebx, ebx
	mov	DWORD PTR image_data_len$[rsp], r14d
$LN2@stbi__crea:

; 4874 :    for (p=0; p < 7; ++p) {

	inc	r9d
	add	r13, 4
	mov	DWORD PTR p$1$[rsp], r9d
	mov	QWORD PTR tv916[rsp], r13
	cmp	r9d, 7
	jl	$LL4@stbi__crea

; 4900 :       }
; 4901 :    }
; 4902 :    a->out = final;

	mov	rax, QWORD PTR final$1$[rsp]
	mov	QWORD PTR [r12+24], rax

; 4903 : 
; 4904 :    return 1;

	mov	eax, 1
$LN76@stbi__crea:
	mov	r13, QWORD PTR [rsp+272]
	mov	r15, QWORD PTR [rsp+264]
$LN74@stbi__crea:
	mov	rsi, QWORD PTR [rsp+280]

; 4905 : }

	add	rsp, 288				; 00000120H
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN43@stbi__crea:

; 4886 :             STBI_FREE(final);

	mov	rcx, QWORD PTR final$1$[rsp]
	call	QWORD PTR __imp_free

; 4887 :             return 0;

	xor	eax, eax
	jmp	SHORT $LN76@stbi__crea
$LN53@stbi__crea:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	mov	QWORD PTR [rdx+rcx], rax

; 4873 :    if (!final) return stbi__err("outofmem", "Out of memory");

	xor	eax, eax
	jmp	SHORT $LN74@stbi__crea
?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z ENDP ; stbi__create_png_image
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z
_TEXT	SEGMENT
z$ = 8
tc$ = 16
out_n$ = 24
?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z PROC ; stbi__compute_transparency, COMDAT

; 4909 :    stbi__context *s = z->s;

	mov	rax, QWORD PTR [rcx]

; 4910 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;

	mov	r10d, DWORD PTR [rax+4]
	imul	r10d, DWORD PTR [rax]

; 4911 :    stbi_uc *p = z->out;

	mov	rax, QWORD PTR [rcx+24]

; 4918 :       for (i=0; i < pixel_count; ++i) {

	test	r10d, r10d
	je	SHORT $LN20@stbi__comp

; 4912 : 
; 4913 :    // compute color-based transparency, assuming we've
; 4914 :    // already got 255 as the alpha value in the output
; 4915 :    STBI_ASSERT(out_n == 2 || out_n == 4);
; 4916 : 
; 4917 :    if (out_n == 2) {

	cmp	r8d, 2
	jne	SHORT $LN8@stbi__comp

; 4919 :          p[1] = (p[0] == tc[0] ? 0 : 255);

	movzx	r8d, BYTE PTR [rdx]
	xor	r9d, r9d
	mov	edx, r10d
	npad	12
$LL4@stbi__comp:
	cmp	BYTE PTR [rax], r8b

; 4920 :          p += 2;

	lea	rax, QWORD PTR [rax+2]
	mov	ecx, 255				; 000000ffH
	cmove	ecx, r9d
	mov	BYTE PTR [rax-1], cl
	sub	rdx, 1
	jne	SHORT $LL4@stbi__comp

; 4927 :       }
; 4928 :    }
; 4929 :    return 1;
; 4930 : }

	mov	eax, 1
	ret	0
$LN8@stbi__comp:

; 4921 :       }
; 4922 :    } else {
; 4923 :       for (i=0; i < pixel_count; ++i) {
; 4924 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])

	movzx	r9d, BYTE PTR [rdx]
	mov	r8d, r10d
$LL7@stbi__comp:
	cmp	BYTE PTR [rax], r9b
	jne	SHORT $LN10@stbi__comp
	movzx	ecx, BYTE PTR [rdx+1]
	cmp	BYTE PTR [rax+1], cl
	jne	SHORT $LN10@stbi__comp
	movzx	ecx, BYTE PTR [rdx+2]
	cmp	BYTE PTR [rax+2], cl
	jne	SHORT $LN10@stbi__comp

; 4925 :             p[3] = 0;

	mov	BYTE PTR [rax+3], 0
$LN10@stbi__comp:

; 4926 :          p += 4;

	add	rax, 4
	sub	r8, 1
	jne	SHORT $LL7@stbi__comp
$LN20@stbi__comp:

; 4927 :       }
; 4928 :    }
; 4929 :    return 1;
; 4930 : }

	mov	eax, 1
	ret	0
?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z ENDP ; stbi__compute_transparency
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z
_TEXT	SEGMENT
z$ = 8
tc$ = 16
out_n$ = 24
?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z PROC ; stbi__compute_transparency16, COMDAT

; 4934 :    stbi__context *s = z->s;

	mov	rax, QWORD PTR [rcx]

; 4935 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;

	mov	r9d, DWORD PTR [rax+4]
	imul	r9d, DWORD PTR [rax]

; 4936 :    stbi__uint16 *p = (stbi__uint16*) z->out;

	mov	rax, QWORD PTR [rcx+24]

; 4943 :       for (i = 0; i < pixel_count; ++i) {

	test	r9d, r9d
	je	SHORT $LN20@stbi__comp

; 4937 : 
; 4938 :    // compute color-based transparency, assuming we've
; 4939 :    // already got 65535 as the alpha value in the output
; 4940 :    STBI_ASSERT(out_n == 2 || out_n == 4);
; 4941 : 
; 4942 :    if (out_n == 2) {

	cmp	r8d, 2
	jne	SHORT $LN8@stbi__comp

; 4944 :          p[1] = (p[0] == tc[0] ? 0 : 65535);

	movzx	r8d, WORD PTR [rdx]
	mov	edx, r9d
	xor	r9d, r9d
	npad	12
$LL4@stbi__comp:
	cmp	WORD PTR [rax], r8w

; 4945 :          p += 2;

	lea	rax, QWORD PTR [rax+4]
	mov	ecx, 65535				; 0000ffffH
	cmove	cx, r9w
	mov	WORD PTR [rax-2], cx
	sub	rdx, 1
	jne	SHORT $LL4@stbi__comp

; 4952 :       }
; 4953 :    }
; 4954 :    return 1;
; 4955 : }

	lea	eax, QWORD PTR [rdx+1]
	ret	0
$LN8@stbi__comp:

; 4946 :       }
; 4947 :    } else {
; 4948 :       for (i = 0; i < pixel_count; ++i) {
; 4949 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])

	movzx	r10d, WORD PTR [rdx]
	mov	r8d, r9d
	xor	r9d, r9d
	npad	6
$LL7@stbi__comp:
	cmp	WORD PTR [rax], r10w
	jne	SHORT $LN10@stbi__comp
	movzx	ecx, WORD PTR [rdx+2]
	cmp	WORD PTR [rax+2], cx
	jne	SHORT $LN10@stbi__comp
	movzx	ecx, WORD PTR [rdx+4]
	cmp	WORD PTR [rax+4], cx
	jne	SHORT $LN10@stbi__comp

; 4950 :             p[3] = 0;

	mov	WORD PTR [rax+6], r9w
$LN10@stbi__comp:

; 4951 :          p += 4;

	add	rax, 8
	sub	r8, 1
	jne	SHORT $LL7@stbi__comp
$LN20@stbi__comp:

; 4952 :       }
; 4953 :    }
; 4954 :    return 1;
; 4955 : }

	mov	eax, 1
	ret	0
?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z ENDP ; stbi__compute_transparency16
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z
_TEXT	SEGMENT
a$ = 64
palette$ = 72
len$dead$ = 80
pal_img_n$ = 88
?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z PROC ; stbi__expand_png_palette, COMDAT

; 4958 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 4959 :    stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;

	mov	rax, QWORD PTR [rcx]
	mov	ebp, r9d

; 4960 :    stbi_uc *p, *temp_out, *orig = a->out;

	mov	rbx, QWORD PTR [rcx+24]
	mov	rdi, rdx
	mov	r15, rcx
	mov	esi, DWORD PTR [rax+4]
	imul	esi, DWORD PTR [rax]

; 1014 :    if (a < 0 || b < 0) return 0;

	test	esi, esi
	js	$LN40@stbi__expa
	test	r9d, r9d
	js	$LN40@stbi__expa

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	mov	ecx, esi
	jne	SHORT $LN22@stbi__expa
	imul	ecx, ebp
	jmp	SHORT $LN42@stbi__expa
$LN22@stbi__expa:

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx

; 1024 :    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);

	imul	ecx, ebp

; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	div	ebp

; 1024 :    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);

	cmp	esi, eax
	jg	$LN40@stbi__expa
$LN42@stbi__expa:

; 1049 :    return stbi__malloc(a*b + add);

	movsxd	rcx, ecx

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc
	mov	r14, rax

; 4961 : 
; 4962 :    p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
; 4963 :    if (p == NULL) return stbi__err("outofmem", "Out of memory");

	test	rax, rax
	je	$LN40@stbi__expa

; 4969 :       for (i=0; i < pixel_count; ++i) {

	test	esi, esi
	je	SHORT $LN6@stbi__expa

; 4964 : 
; 4965 :    // between here and free(out) below, exitting would leak
; 4966 :    temp_out = p;
; 4967 : 
; 4968 :    if (pal_img_n == 3) {

	mov	r8d, esi
	lea	rdx, QWORD PTR [rax+2]
	cmp	ebp, 3
	jne	SHORT $LL7@stbi__expa
$LL4@stbi__expa:

; 4970 :          int n = orig[i]*4;

	movzx	ecx, BYTE PTR [rbx]

; 4971 :          p[0] = palette[n  ];
; 4972 :          p[1] = palette[n+1];
; 4973 :          p[2] = palette[n+2];
; 4974 :          p += 3;

	lea	rdx, QWORD PTR [rdx+3]
	lea	rbx, QWORD PTR [rbx+1]
	movzx	eax, BYTE PTR [rdi+rcx*4]
	mov	BYTE PTR [rdx-5], al
	movzx	eax, BYTE PTR [rdi+rcx*4+1]
	movzx	ecx, BYTE PTR [rdi+rcx*4+2]
	mov	BYTE PTR [rdx-3], cl
	mov	BYTE PTR [rdx-4], al
	sub	r8, 1
	jne	SHORT $LL4@stbi__expa

; 4975 :       }
; 4976 :    } else {

	jmp	SHORT $LN6@stbi__expa
	npad	5
$LL7@stbi__expa:

; 4977 :       for (i=0; i < pixel_count; ++i) {
; 4978 :          int n = orig[i]*4;

	movzx	ecx, BYTE PTR [rbx]

; 4979 :          p[0] = palette[n  ];
; 4980 :          p[1] = palette[n+1];
; 4981 :          p[2] = palette[n+2];
; 4982 :          p[3] = palette[n+3];
; 4983 :          p += 4;

	lea	rdx, QWORD PTR [rdx+4]
	lea	rbx, QWORD PTR [rbx+1]
	movzx	eax, BYTE PTR [rdi+rcx*4]
	mov	BYTE PTR [rdx-6], al
	movzx	eax, BYTE PTR [rdi+rcx*4+1]
	mov	BYTE PTR [rdx-5], al
	movzx	eax, BYTE PTR [rdi+rcx*4+2]
	movzx	ecx, BYTE PTR [rdi+rcx*4+3]
	mov	BYTE PTR [rdx-3], cl
	mov	BYTE PTR [rdx-4], al
	sub	r8, 1
	jne	SHORT $LL7@stbi__expa
$LN6@stbi__expa:

; 4984 :       }
; 4985 :    }
; 4986 :    STBI_FREE(a->out);

	mov	rcx, QWORD PTR [r15+24]
	call	QWORD PTR __imp_free

; 4987 :    a->out = temp_out;
; 4988 : 
; 4989 :    STBI_NOTUSED(len);
; 4990 : 
; 4991 :    return 1;

	mov	eax, 1
	mov	QWORD PTR [r15+24], r14
	jmp	SHORT $LN1@stbi__expa
$LN40@stbi__expa:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	mov	QWORD PTR [rdx+rcx], rax

; 4961 : 
; 4962 :    p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
; 4963 :    if (p == NULL) return stbi__err("outofmem", "Out of memory");

	xor	eax, eax
$LN1@stbi__expa:

; 4992 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z ENDP ; stbi__expand_png_palette
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z
_TEXT	SEGMENT
z$ = 16
?stbi__de_iphone@@YAXPEAUstbi__png@@@Z PROC		; stbi__de_iphone, COMDAT

; 5035 : {

	sub	rsp, 8

; 5036 :    stbi__context *s = z->s;

	mov	rax, QWORD PTR [rcx]

; 5037 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 5038 :    stbi_uc *p = z->out;

	mov	rcx, QWORD PTR [rcx+24]
	mov	edx, DWORD PTR [rax+4]
	imul	edx, DWORD PTR [rax]

; 5039 : 
; 5040 :    if (s->img_out_n == 3) {  // convert bgr to rgb

	cmp	DWORD PTR [rax+12], 3
	jne	SHORT $LN11@stbi__de_i

; 5041 :       for (i=0; i < pixel_count; ++i) {

	test	edx, edx
	je	$LN9@stbi__de_i
	mov	r8d, edx
	npad	14
$LL4@stbi__de_i:

; 5042 :          stbi_uc t = p[0];

	movzx	edx, BYTE PTR [rcx]

; 5043 :          p[0] = p[2];

	movzx	eax, BYTE PTR [rcx+2]
	mov	BYTE PTR [rcx], al

; 5044 :          p[2] = t;

	mov	BYTE PTR [rcx+2], dl

; 5045 :          p += 3;

	lea	rcx, QWORD PTR [rcx+3]
	sub	r8, 1
	jne	SHORT $LL4@stbi__de_i

; 5072 :          }
; 5073 :       }
; 5074 :    }
; 5075 : }

	add	rsp, 8
	ret	0
$LN11@stbi__de_i:

; 5046 :       }
; 5047 :    } else {
; 5048 :       STBI_ASSERT(s->img_out_n == 4);
; 5049 :       if (stbi__unpremultiply_on_load) {

	mov	rax, QWORD PTR gs:88
	mov	r8d, OFFSET FLAT:?stbi__unpremultiply_on_load_set@@3HA
	mov	rax, QWORD PTR [rax]
	cmp	DWORD PTR [r8+rax], 0
	je	SHORT $LN18@stbi__de_i
	mov	r8d, OFFSET FLAT:?stbi__unpremultiply_on_load_local@@3HA
	mov	eax, DWORD PTR [r8+rax]
	jmp	SHORT $LN19@stbi__de_i
$LN18@stbi__de_i:
	mov	eax, DWORD PTR ?stbi__unpremultiply_on_load_global@@3HA
$LN19@stbi__de_i:

; 5050 :          // convert bgr to rgb and unpremultiply
; 5051 :          for (i=0; i < pixel_count; ++i) {

	test	edx, edx
	je	$LN9@stbi__de_i

; 5046 :       }
; 5047 :    } else {
; 5048 :       STBI_ASSERT(s->img_out_n == 4);
; 5049 :       if (stbi__unpremultiply_on_load) {

	test	eax, eax
	je	SHORT $LN13@stbi__de_i
	mov	QWORD PTR [rsp], rbx

; 5050 :          // convert bgr to rgb and unpremultiply
; 5051 :          for (i=0; i < pixel_count; ++i) {

	mov	r10d, edx
	npad	7
$LL7@stbi__de_i:

; 5052 :             stbi_uc a = p[3];

	movzx	eax, BYTE PTR [rcx+3]

; 5053 :             stbi_uc t = p[0];

	movzx	r11d, BYTE PTR [rcx]
	movzx	ebx, BYTE PTR [rcx+2]

; 5054 :             if (a) {

	test	al, al
	je	SHORT $LN15@stbi__de_i

; 5055 :                stbi_uc half = a / 2;

	mov	r8d, eax
	mov	r9d, eax

; 5056 :                p[0] = (p[2] * 255 + half) / a;
; 5057 :                p[1] = (p[1] * 255 + half) / a;

	movzx	eax, BYTE PTR [rcx+1]
	xor	edx, edx
	imul	eax, eax, 255				; 000000ffH
	shr	r8d, 1
	add	eax, r8d
	div	r9d

; 5058 :                p[2] = ( t   * 255 + half) / a;

	xor	edx, edx
	mov	BYTE PTR [rcx+1], al
	imul	eax, r11d, 255				; 000000ffH
	add	eax, r8d
	div	r9d
	xor	edx, edx
	mov	r11d, eax
	imul	eax, ebx, 255				; 000000ffH
	add	eax, r8d
	div	r9d

; 5059 :             } else {

	jmp	SHORT $LN16@stbi__de_i
$LN15@stbi__de_i:

; 5060 :                p[0] = p[2];
; 5061 :                p[2] = t;

	movzx	eax, bl
$LN16@stbi__de_i:

; 5062 :             }
; 5063 :             p += 4;

	mov	BYTE PTR [rcx], al
	mov	BYTE PTR [rcx+2], r11b
	add	rcx, 4
	sub	r10, 1
	jne	SHORT $LL7@stbi__de_i

; 5064 :          }
; 5065 :       } else {

	mov	rbx, QWORD PTR [rsp]

; 5072 :          }
; 5073 :       }
; 5074 :    }
; 5075 : }

	add	rsp, 8
	ret	0
$LN13@stbi__de_i:

; 5066 :          // convert bgr to rgb
; 5067 :          for (i=0; i < pixel_count; ++i) {

	mov	r8d, edx
	npad	1
$LL10@stbi__de_i:

; 5068 :             stbi_uc t = p[0];

	movzx	edx, BYTE PTR [rcx]

; 5069 :             p[0] = p[2];

	movzx	eax, BYTE PTR [rcx+2]
	mov	BYTE PTR [rcx], al

; 5070 :             p[2] = t;

	mov	BYTE PTR [rcx+2], dl

; 5071 :             p += 4;

	lea	rcx, QWORD PTR [rcx+4]
	sub	r8, 1
	jne	SHORT $LL10@stbi__de_i
$LN9@stbi__de_i:

; 5072 :          }
; 5073 :       }
; 5074 :    }
; 5075 : }

	add	rsp, 8
	ret	0
?stbi__de_iphone@@YAXPEAUstbi__png@@@Z ENDP		; stbi__de_iphone
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z
_TEXT	SEGMENT
pal_img_n$1$ = 64
has_trans$1$ = 65
first$1$ = 68
ioff$1$ = 72
is_iphone$1$ = 76
interlace$1$ = 80
color$1$ = 84
pal_len$1$ = 88
c$1 = 96
a$2 = 112
tc$ = 4208
tc16$ = 4212
palette$ = 4224
__$ArrayPad$ = 5248
z$ = 5312
scan$dead$ = 5320
req_comp$dead$ = 5328
?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z PROC	; stbi__parse_png_file, COMDAT

; 5080 : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-5008]
	mov	eax, 5264				; 00001490H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 5081 :    stbi_uc palette[1024], pal_img_n=0;
; 5082 :    stbi_uc has_trans=0, tc[3]={0};
; 5083 :    stbi__uint16 tc16[3];
; 5084 :    stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
; 5085 :    int first=1,k,interlace=0, color=0, is_iphone=0;
; 5086 :    stbi__context *s = z->s;

	mov	rbx, QWORD PTR [rcx]
	xor	edx, edx
	xor	eax, eax

; 5087 : 
; 5088 :    z->expanded = NULL;

	mov	QWORD PTR [rcx+16], rdx
	xor	r15b, r15b

; 5089 :    z->idata = NULL;

	mov	QWORD PTR [rcx+8], rdx
	mov	r12, rcx

; 5090 :    z->out = NULL;

	mov	QWORD PTR [rcx+24], rdx
	mov	BYTE PTR has_trans$1$[rsp], r15b

; 5091 : 
; 5092 :    if (!stbi__check_png_header(s)) return 0;

	mov	rcx, rbx
	mov	r15d, 1
	mov	BYTE PTR pal_img_n$1$[rsp], 0
	mov	DWORD PTR first$1$[rsp], r15d
	mov	r13d, edx
	mov	WORD PTR tc$[rbp-256], ax
	mov	r14d, edx
	mov	BYTE PTR tc$[rbp-254], al
	mov	DWORD PTR ioff$1$[rsp], edx
	mov	DWORD PTR interlace$1$[rsp], edx
	mov	DWORD PTR color$1$[rsp], edx
	mov	DWORD PTR is_iphone$1$[rsp], edx
	call	?stbi__check_png_header@@YAHPEAUstbi__context@@@Z ; stbi__check_png_header
	test	eax, eax
	je	$LN325@stbi__pars
	npad	1
$LL2@stbi__pars:

; 1704 :    stbi__uint32 z = stbi__get16be(s);

	mov	rcx, rbx
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 1705 :    return (z << 16) + stbi__get16be(s);

	mov	rcx, rbx
	mov	esi, eax
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	shl	esi, 16

; 1704 :    stbi__uint32 z = stbi__get16be(s);

	mov	rcx, rbx

; 1705 :    return (z << 16) + stbi__get16be(s);

	add	esi, eax

; 4594 :    c.length = stbi__get32be(s);

	mov	DWORD PTR c$1[rsp], esi

; 1704 :    stbi__uint32 z = stbi__get16be(s);

	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 1705 :    return (z << 16) + stbi__get16be(s);

	mov	rcx, rbx
	mov	edi, eax
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	shl	edi, 16
	lea	edx, DWORD PTR [rdi+rax]

; 4595 :    c.type   = stbi__get32be(s);

	mov	DWORD PTR c$1[rsp+4], edx

; 5093 : 
; 5094 :    if (scan == STBI__SCAN_type) return 1;
; 5095 : 
; 5096 :    for (;;) {
; 5097 :       stbi__pngchunk c = stbi__get_chunk_header(s);

	mov	rax, QWORD PTR c$1[rsp]

; 5098 :       switch (c.type) {

	mov	rcx, rax
	shr	rcx, 32					; 00000020H
	cmp	ecx, 1229472850				; 49484452H
	ja	$LN99@stbi__pars
	je	$LN24@stbi__pars
	cmp	ecx, 1130840649				; 43674249H
	je	$LN23@stbi__pars
	cmp	ecx, 1229209940				; 49444154H
	je	SHORT $LN61@stbi__pars
	cmp	ecx, 1229278788				; 49454e44H
	jne	$LN93@stbi__pars

; 5196 :          }
; 5197 : 
; 5198 :          case STBI__PNG_TYPE('I','E','N','D'): {
; 5199 :             stbi__uint32 raw_len, bpl;
; 5200 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	test	r15d, r15d
	jne	$LN352@stbi__pars

; 5201 :             if (scan != STBI__SCAN_load) return 1;
; 5202 :             if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");

	mov	rdi, QWORD PTR [r12+8]
	test	rdi, rdi
	jne	$LN75@stbi__pars

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_07MLPECBNA@no?5IDAT@

; 5201 :             if (scan != STBI__SCAN_load) return 1;
; 5202 :             if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");

	jmp	$LN614@stbi__pars
$LN61@stbi__pars:

; 5170 :          }
; 5171 : 
; 5172 :          case STBI__PNG_TYPE('I','D','A','T'): {
; 5173 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	test	r15d, r15d
	jne	$LN352@stbi__pars

; 5174 :             if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");

	cmp	BYTE PTR pal_img_n$1$[rsp], r15b
	je	SHORT $LN63@stbi__pars
	test	r14d, r14d
	je	$LN322@stbi__pars
$LN63@stbi__pars:

; 5175 :             if (scan == STBI__SCAN_header) {
; 5176 :                // header scan definitely stops at first IDAT
; 5177 :                if (pal_img_n)
; 5178 :                   s->img_n = pal_img_n;
; 5179 :                return 1;
; 5180 :             }
; 5181 :             if (c.length > (1u << 30)) return stbi__err("IDAT size limit", "IDAT section larger than 2^30 bytes");

	cmp	esi, 1073741824				; 40000000H
	ja	$LN324@stbi__pars

; 5182 :             if ((int)(ioff + c.length) < (int)ioff) return 0;

	mov	ecx, DWORD PTR ioff$1$[rsp]
	lea	edi, DWORD PTR [rsi+rcx]
	cmp	edi, ecx
	jl	$LN325@stbi__pars

; 5183 :             if (ioff + c.length > idata_limit) {

	cmp	edi, r13d
	jbe	SHORT $LN461@stbi__pars

; 5184 :                stbi__uint32 idata_limit_old = idata_limit;
; 5185 :                stbi_uc *p;
; 5186 :                if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;

	test	r13d, r13d
	jne	SHORT $LN316@stbi__pars
	mov	r13d, 4096				; 00001000H
	cmp	esi, r13d
	cmova	r13d, eax
$LN316@stbi__pars:

; 5187 :                while (ioff + c.length > idata_limit)

	cmp	edi, r13d
	jbe	SHORT $LN20@stbi__pars
$LL19@stbi__pars:

; 5188 :                   idata_limit *= 2;

	add	r13d, r13d
	cmp	edi, r13d
	ja	SHORT $LL19@stbi__pars
$LN20@stbi__pars:

; 5189 :                STBI_NOTUSED(idata_limit_old);
; 5190 :                p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");

	mov	rcx, QWORD PTR [r12+8]
	mov	edx, r13d
	call	QWORD PTR __imp_realloc
	test	rax, rax
	je	$LN446@stbi__pars

; 5191 :                z->idata = p;

	mov	ecx, DWORD PTR ioff$1$[rsp]
	mov	QWORD PTR [r12+8], rax
$LN461@stbi__pars:

; 5192 :             }
; 5193 :             if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");

	mov	edx, ecx
	mov	r8d, esi
	add	rdx, QWORD PTR [r12+8]
	mov	rcx, rbx
	call	?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn
	test	eax, eax
	je	$LN327@stbi__pars

; 5194 :             ioff += c.length;

	mov	DWORD PTR ioff$1$[rsp], edi

; 5195 :             break;

	jmp	$LN8@stbi__pars
$LN23@stbi__pars:

; 5099 :          case STBI__PNG_TYPE('C','g','B','I'):
; 5100 :             is_iphone = 1;

	mov	DWORD PTR is_iphone$1$[rsp], 1

; 1647 :       return;

	jmp	$LN613@stbi__pars
$LN24@stbi__pars:

; 5101 :             stbi__skip(s, c.length);
; 5102 :             break;
; 5103 :          case STBI__PNG_TYPE('I','H','D','R'): {
; 5104 :             int comp,filter;
; 5105 :             if (!first) return stbi__err("multiple IHDR","Corrupt PNG");

	test	r15d, r15d
	je	$LN328@stbi__pars

; 5106 :             first = 0;

	mov	DWORD PTR first$1$[rsp], 0
	cmp	esi, 13

; 5107 :             if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");

	jne	$LN329@stbi__pars

; 1704 :    stbi__uint32 z = stbi__get16be(s);

	mov	rcx, rbx
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 1705 :    return (z << 16) + stbi__get16be(s);

	mov	rcx, rbx
	mov	edi, eax
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	shl	edi, 16

; 1704 :    stbi__uint32 z = stbi__get16be(s);

	mov	rcx, rbx

; 1705 :    return (z << 16) + stbi__get16be(s);

	add	eax, edi

; 5108 :             s->img_x = stbi__get32be(s);

	mov	DWORD PTR [rbx], eax

; 1704 :    stbi__uint32 z = stbi__get16be(s);

	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 1705 :    return (z << 16) + stbi__get16be(s);

	mov	rcx, rbx
	mov	edi, eax
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	shl	edi, 16
	lea	ecx, DWORD PTR [rax+rdi]

; 5109 :             s->img_y = stbi__get32be(s);

	mov	DWORD PTR [rbx+4], ecx

; 5110 :             if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

	cmp	ecx, 16777216				; 01000000H
	ja	$LN340@stbi__pars

; 5111 :             if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

	cmp	DWORD PTR [rbx], 16777216		; 01000000H
	ja	$LN340@stbi__pars

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN161@stbi__pars

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN610@stbi__pars
$LN161@stbi__pars:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN162@stbi__pars

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN610@stbi__pars
$LN162@stbi__pars:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN610@stbi__pars:

; 5112 :             z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");

	mov	rax, rbx
	mov	edx, 48					; 00000030H
	movzx	eax, cl
	mov	DWORD PTR [r12+32], eax
	lea	rdi, QWORD PTR [rbx+rdx]
	cmp	eax, 16
	ja	$LN332@stbi__pars
	mov	ecx, 65814				; 00010116H
	bt	ecx, eax
	jae	$LN332@stbi__pars

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN167@stbi__pars

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN166@stbi__pars
$LN167@stbi__pars:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi], 0
	je	SHORT $LN168@stbi__pars

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN166@stbi__pars
$LN168@stbi__pars:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN166@stbi__pars:

; 5113 :             color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");

	movzx	esi, cl
	mov	DWORD PTR color$1$[rsp], esi
	cmp	esi, 6
	ja	$LN334@stbi__pars

; 5114 :             if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");

	cmp	esi, 3
	jne	SHORT $LN32@stbi__pars
	cmp	DWORD PTR [r12+32], 16
	je	$LN334@stbi__pars

; 5115 :             if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");

	mov	BYTE PTR pal_img_n$1$[rsp], sil
	jmp	SHORT $LN34@stbi__pars
$LN32@stbi__pars:
	test	sil, 1
	jne	$LN334@stbi__pars
$LN34@stbi__pars:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN611@stbi__pars

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi], 0
	je	SHORT $LN184@stbi__pars

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN611@stbi__pars:

; 5116 :             comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	test	cl, cl
	jne	$LN336@stbi__pars
$LN184@stbi__pars:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN612@stbi__pars

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi], 0
	je	SHORT $LN206@stbi__pars

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN612@stbi__pars:

; 5117 :             filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	test	cl, cl
	jne	$LN337@stbi__pars
$LN206@stbi__pars:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN219@stbi__pars

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN218@stbi__pars
$LN219@stbi__pars:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi], 0
	je	SHORT $LN220@stbi__pars

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN218@stbi__pars
$LN220@stbi__pars:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN218@stbi__pars:

; 5118 :             interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");

	movzx	r15d, cl
	mov	DWORD PTR interlace$1$[rsp], r15d
	cmp	r15d, 1
	ja	$LN338@stbi__pars

; 5119 :             if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");

	mov	ecx, DWORD PTR [rbx]
	test	ecx, ecx
	je	$LN39@stbi__pars
	mov	r9d, DWORD PTR [rbx+4]
	test	r9d, r9d
	je	$LN39@stbi__pars

; 5120 :             if (!pal_img_n) {

	xor	edx, edx
	mov	eax, 1073741824				; 40000000H
	div	ecx
	cmp	BYTE PTR pal_img_n$1$[rsp], 0
	jne	SHORT $LN40@stbi__pars

; 5121 :                s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
; 5122 :                if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");

	xor	edx, edx
	mov	r8d, esi
	shr	r8d, 2
	mov	ecx, esi
	and	ecx, 2
	and	r8d, 1
	or	ecx, 1
	add	r8d, ecx
	div	r8d
	mov	DWORD PTR [rbx+8], r8d
	cmp	eax, r9d
	jae	$LN486@stbi__pars
$LN340@stbi__pars:

; 5260 : }

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
	jmp	$LN614@stbi__pars
$LN40@stbi__pars:

; 5123 :             } else {
; 5124 :                // if paletted, then pal_n is our final components, and
; 5125 :                // img_n is # components to decompress/filter.
; 5126 :                s->img_n = 1;
; 5127 :                if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");

	shr	eax, 2
	mov	DWORD PTR [rbx+8], 1
	cmp	eax, r9d
	jb	SHORT $LN340@stbi__pars

; 5128 :             }
; 5129 :             // even with SCAN_header, have to scan to see if we have a tRNS
; 5130 :             break;

	jmp	$LN486@stbi__pars
$LN99@stbi__pars:

; 5098 :       switch (c.type) {

	cmp	ecx, 1347179589				; 504c5445H
	je	$LN44@stbi__pars
	cmp	ecx, 1951551059				; 74524e53H
	je	SHORT $LN48@stbi__pars
$LN93@stbi__pars:

; 5238 :          }
; 5239 : 
; 5240 :          default:
; 5241 :             // if critical, fail
; 5242 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	test	r15d, r15d
	jne	$LN352@stbi__pars

; 5243 :             if ((c.type & (1 << 29)) == 0) {

	bt	edx, 29
	jae	$LN343@stbi__pars
$LN613@stbi__pars:

; 1704 :    stbi__uint32 z = stbi__get16be(s);

	test	esi, esi
	je	$LN8@stbi__pars
	jns	SHORT $LN144@stbi__pars
	mov	rax, QWORD PTR [rbx+200]
	mov	QWORD PTR [rbx+192], rax
	jmp	$LN8@stbi__pars
$LN144@stbi__pars:
	cmp	QWORD PTR [rbx+16], 0
	je	SHORT $LN463@stbi__pars
	mov	ecx, DWORD PTR [rbx+200]
	sub	ecx, DWORD PTR [rbx+192]
	cmp	ecx, esi
	jge	SHORT $LN463@stbi__pars
	mov	rax, QWORD PTR [rbx+200]
	sub	esi, ecx
	mov	rcx, QWORD PTR [rbx+40]
	mov	edx, esi
	mov	QWORD PTR [rbx+192], rax
	call	QWORD PTR [rbx+24]
	jmp	$LN8@stbi__pars
$LN463@stbi__pars:
	movsxd	rax, esi
	add	QWORD PTR [rbx+192], rax
	jmp	$LN8@stbi__pars
$LN48@stbi__pars:

; 5143 :             }
; 5144 :             break;
; 5145 :          }
; 5146 : 
; 5147 :          case STBI__PNG_TYPE('t','R','N','S'): {
; 5148 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	test	r15d, r15d
	jne	$LN352@stbi__pars

; 5149 :             if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");

	cmp	QWORD PTR [r12+8], 0
	jne	$LN345@stbi__pars

; 5150 :             if (pal_img_n) {

	cmp	BYTE PTR pal_img_n$1$[rsp], r15b
	je	$LN51@stbi__pars

; 5151 :                if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
; 5152 :                if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");

	test	r14d, r14d
	je	$LN347@stbi__pars

; 5153 :                if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");

	cmp	esi, r14d
	ja	$LN348@stbi__pars

; 5154 :                pal_img_n = 4;

	xor	edi, edi
	mov	BYTE PTR pal_img_n$1$[rsp], 4

; 5155 :                for (i=0; i < c.length; ++i)

	test	esi, esi
	je	$LN8@stbi__pars
$LL12@stbi__pars:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN171@stbi__pars

; 1615 :       return *s->img_buffer++;

	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN170@stbi__pars
$LN171@stbi__pars:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN172@stbi__pars

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN170@stbi__pars
$LN172@stbi__pars:

; 1619 :    }
; 1620 :    return 0;

	xor	dl, dl
$LN170@stbi__pars:

; 5156 :                   palette[i*4+3] = stbi__get8(s);

	lea	eax, DWORD PTR [rdi*4+3]
	inc	edi
	mov	BYTE PTR palette$[rbp+rax-256], dl
	cmp	edi, esi
	jb	SHORT $LL12@stbi__pars

; 5157 :             } else {

	jmp	$LN8@stbi__pars
$LN51@stbi__pars:

; 5158 :                if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");

	mov	ecx, DWORD PTR [rbx+8]
	test	cl, 1
	je	$LN349@stbi__pars

; 5159 :                if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");

	lea	eax, DWORD PTR [rcx+rcx]
	cmp	esi, eax
	jne	$LN348@stbi__pars

; 5160 :                has_trans = 1;
; 5161 :                // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.
; 5162 :                if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }
; 5163 :                if (z->depth == 16) {

	xor	esi, esi
	mov	BYTE PTR has_trans$1$[rsp], 1
	cmp	DWORD PTR [r12+32], 16
	jne	SHORT $LN59@stbi__pars

; 5164 :                   for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is

	test	ecx, ecx
	jle	$LN8@stbi__pars
	lea	rdi, QWORD PTR tc16$[rbp-256]
$LL15@stbi__pars:
	mov	rcx, rbx
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	inc	esi
	mov	WORD PTR [rdi], ax
	lea	rdi, QWORD PTR [rdi+2]
	cmp	esi, DWORD PTR [rbx+8]
	jl	SHORT $LL15@stbi__pars

; 5165 :                } else {

	jmp	$LN8@stbi__pars
$LN59@stbi__pars:

; 5166 :                   for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger

	test	ecx, ecx
	jle	$LN8@stbi__pars
	lea	rdi, QWORD PTR tc$[rbp-256]
	lea	r15, OFFSET FLAT:?stbi__depth_scale_table@@3QBEB
$LL18@stbi__pars:
	mov	rcx, rbx
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	movsxd	rcx, DWORD PTR [r12+32]
	lea	rdi, QWORD PTR [rdi+1]
	movzx	eax, al
	inc	esi
	movzx	edx, BYTE PTR [rcx+r15]
	imul	eax, edx
	mov	BYTE PTR [rdi-1], al
	cmp	esi, DWORD PTR [rbx+8]
	jl	SHORT $LL18@stbi__pars

; 5167 :                }
; 5168 :             }
; 5169 :             break;

	jmp	$LN486@stbi__pars
$LN44@stbi__pars:

; 5131 :          }
; 5132 : 
; 5133 :          case STBI__PNG_TYPE('P','L','T','E'):  {
; 5134 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	test	r15d, r15d
	jne	$LN352@stbi__pars

; 5135 :             if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");

	cmp	esi, 768				; 00000300H
	ja	$LN354@stbi__pars

; 5136 :             pal_len = c.length / 3;

	mov	eax, -1431655765			; aaaaaaabH
	mul	esi
	mov	r14d, edx
	shr	r14d, 1
	mov	DWORD PTR pal_len$1$[rsp], r14d

; 5137 :             if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");

	lea	eax, DWORD PTR [r14+r14*2]
	cmp	eax, esi
	jne	$LN354@stbi__pars

; 5138 :             for (i=0; i < pal_len; ++i) {

	test	r14d, r14d
	je	$LN486@stbi__pars

; 5191 :                z->idata = p;

	lea	rdi, QWORD PTR [rbx+48]
	npad	1
$LL9@stbi__pars:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rdx, QWORD PTR [rbx+192]
	mov	rsi, rdi
	cmp	rdx, QWORD PTR [rbx+200]
	jae	SHORT $LN109@stbi__pars

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rdx]
	inc	rdx
	mov	QWORD PTR [rbx+192], rdx
	jmp	SHORT $LN108@stbi__pars
$LN109@stbi__pars:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi], 0
	je	SHORT $LN110@stbi__pars

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	lea	rdx, QWORD PTR [rax+1]
	mov	QWORD PTR [rbx+192], rdx
	jmp	SHORT $LN108@stbi__pars
$LN110@stbi__pars:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN108@stbi__pars:

; 5139 :                palette[i*4+0] = stbi__get8(s);

	lea	r14d, DWORD PTR [r15*4]
	mov	BYTE PTR palette$[rbp+r14-256], cl

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rdx, QWORD PTR [rbx+200]
	jae	SHORT $LN113@stbi__pars

; 1615 :       return *s->img_buffer++;

	movzx	r8d, BYTE PTR [rdx]
	lea	rdi, QWORD PTR [rbx+48]
	inc	rdx
	mov	QWORD PTR [rbx+192], rdx
	jmp	SHORT $LN112@stbi__pars
$LN113@stbi__pars:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi], 0
	je	SHORT $LN114@stbi__pars

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	r8d, BYTE PTR [rax]
	lea	rdx, QWORD PTR [rax+1]
	mov	QWORD PTR [rbx+192], rdx
	jmp	SHORT $LN112@stbi__pars
$LN114@stbi__pars:

; 1619 :    }
; 1620 :    return 0;

	xor	r8b, r8b
$LN112@stbi__pars:

; 5140 :                palette[i*4+1] = stbi__get8(s);

	lea	eax, DWORD PTR [r14+1]
	mov	BYTE PTR palette$[rbp+rax-256], r8b

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rdx, QWORD PTR [rbx+200]
	jae	SHORT $LN117@stbi__pars

; 1615 :       return *s->img_buffer++;

	movzx	r8d, BYTE PTR [rdx]
	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN116@stbi__pars
$LN117@stbi__pars:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rsi], 0
	mov	rdi, rsi
	je	SHORT $LN118@stbi__pars

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	r8d, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN116@stbi__pars
$LN118@stbi__pars:

; 1619 :    }
; 1620 :    return 0;

	xor	r8b, r8b
$LN116@stbi__pars:

; 5141 :                palette[i*4+2] = stbi__get8(s);

	lea	eax, DWORD PTR [r14+2]
	inc	r15d
	mov	BYTE PTR palette$[rbp+rax-256], r8b

; 5142 :                palette[i*4+3] = 255;

	lea	eax, DWORD PTR [r14+3]
	mov	r14d, DWORD PTR pal_len$1$[rsp]
	mov	BYTE PTR palette$[rbp+rax-256], 255	; 000000ffH
	cmp	r15d, r14d
	jb	$LL9@stbi__pars
$LN486@stbi__pars:

; 1704 :    stbi__uint32 z = stbi__get16be(s);

	mov	r15d, DWORD PTR first$1$[rsp]
$LN8@stbi__pars:
	mov	rcx, rbx
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 1705 :    return (z << 16) + stbi__get16be(s);

	mov	rcx, rbx
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 5253 :             }
; 5254 :             stbi__skip(s, c.length);
; 5255 :             break;
; 5256 :       }
; 5257 :       // end of PNG chunk, read and skip CRC
; 5258 :       stbi__get32be(s);
; 5259 :    }

	jmp	$LL2@stbi__pars
$LN75@stbi__pars:

; 5203 :             // initial guess for decoded data size to avoid unnecessary reallocs
; 5204 :             bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component

	mov	eax, DWORD PTR [rbx]
	imul	eax, DWORD PTR [r12+32]
	add	eax, 7
	shr	eax, 3

; 5205 :             raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;

	imul	eax, DWORD PTR [rbx+8]
	inc	eax
	imul	eax, DWORD PTR [rbx+4]

; 4522 :    char *p = (char *) stbi__malloc(initial_size);

	movsxd	rsi, eax

; 985  :     return STBI_MALLOC(size);

	mov	rcx, rsi
	call	QWORD PTR __imp_malloc
	mov	rcx, rax

; 4523 :    if (p == NULL) return NULL;

	test	rax, rax
	jne	SHORT $LN193@stbi__pars
	mov	QWORD PTR [r12+16], rax
	jmp	$LN325@stbi__pars
$LN193@stbi__pars:

; 4525 :    a.zbuffer_end = (stbi_uc *) buffer + len;

	movsxd	rax, DWORD PTR ioff$1$[rsp]

; 5206 :             z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);

	xor	r13d, r13d
	mov	r14d, DWORD PTR is_iphone$1$[rsp]

; 4525 :    a.zbuffer_end = (stbi_uc *) buffer + len;

	add	rax, rdi
	mov	QWORD PTR a$2[rsp+8], rax

; 5206 :             z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);

	mov	edx, r13d

; 4492 :    a->zout_end   = obuf + olen;

	lea	rax, QWORD PTR [rsi+rcx]
	mov	QWORD PTR a$2[rbp-224], rcx
	mov	QWORD PTR a$2[rbp-232], rcx

; 5206 :             z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);

	test	r14d, r14d

; 4495 :    return stbi__parse_zlib(a, parse_header);

	lea	rcx, QWORD PTR a$2[rsp]

; 4524 :    a.zbuffer = (stbi_uc *) buffer;

	mov	QWORD PTR a$2[rsp], rdi

; 5206 :             z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);

	sete	dl

; 4492 :    a->zout_end   = obuf + olen;

	mov	QWORD PTR a$2[rbp-216], rax

; 4493 :    a->z_expandable = exp;

	mov	DWORD PTR a$2[rbp-208], 1

; 4494 : 
; 4495 :    return stbi__parse_zlib(a, parse_header);

	call	?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z ; stbi__parse_zlib

; 4526 :    if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {

	test	eax, eax
	je	$LN194@stbi__pars

; 4527 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4528 :       return a.zout_start;

	mov	rax, QWORD PTR a$2[rbp-224]
	mov	edi, DWORD PTR a$2[rbp-232]
	sub	edi, DWORD PTR a$2[rbp-224]

; 5206 :             z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);

	mov	QWORD PTR [r12+16], rax

; 5207 :             if (z->expanded == NULL) return 0; // zlib should set error

	test	rax, rax
	je	$LN325@stbi__pars

; 5208 :             STBI_FREE(z->idata); z->idata = NULL;

	mov	rcx, QWORD PTR [r12+8]
	call	QWORD PTR __imp_free

; 5209 :             if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)

	movzx	esi, BYTE PTR pal_img_n$1$[rsp]
	mov	QWORD PTR [r12+8], r13
	mov	eax, DWORD PTR [rbx+8]
	lea	r9d, DWORD PTR [rax+1]
	cmp	r9d, 4
	jne	SHORT $LN80@stbi__pars
	test	sil, sil
	je	$LN488@stbi__pars
$LN80@stbi__pars:
	movzx	r15d, BYTE PTR has_trans$1$[rsp]
	test	r15b, r15b
	jne	SHORT $LN78@stbi__pars

; 5211 :             else
; 5212 :                s->img_out_n = s->img_n;

	mov	r9d, eax
$LN78@stbi__pars:

; 5213 :             if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;

	mov	eax, DWORD PTR interlace$1$[rsp]
	mov	r8d, edi
	mov	ecx, DWORD PTR color$1$[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, r12
	mov	DWORD PTR [rbx+12], r9d
	mov	eax, DWORD PTR [r12+32]
	mov	rdx, QWORD PTR [r12+16]
	mov	DWORD PTR [rsp+32], eax
	call	?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z ; stbi__create_png_image
	test	eax, eax
	je	$LN325@stbi__pars

; 5214 :             if (has_trans) {

	test	r15b, r15b
	je	$LN276@stbi__pars

; 5215 :                if (z->depth == 16) {

	mov	rcx, QWORD PTR [r12]
	mov	eax, DWORD PTR [rcx+4]
	imul	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [r12+32], 16
	mov	rcx, QWORD PTR [r12+24]
	jne	SHORT $LN83@stbi__pars

; 4943 :       for (i = 0; i < pixel_count; ++i) {

	test	eax, eax
	je	$LN276@stbi__pars

; 4927 :       }
; 4928 :    }
; 4929 :    return 1;
; 4930 : }
; 4931 : 
; 4932 : static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
; 4933 : {
; 4934 :    stbi__context *s = z->s;
; 4935 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 4936 :    stbi__uint16 *p = (stbi__uint16*) z->out;
; 4937 : 
; 4938 :    // compute color-based transparency, assuming we've
; 4939 :    // already got 65535 as the alpha value in the output
; 4940 :    STBI_ASSERT(out_n == 2 || out_n == 4);
; 4941 : 
; 4942 :    if (out_n == 2) {

	cmp	DWORD PTR [rbx+12], 2
	jne	SHORT $LN267@stbi__pars
	movzx	r8d, WORD PTR tc16$[rbp-256]
	mov	edx, eax
$LL263@stbi__pars:

; 4944 :          p[1] = (p[0] == tc[0] ? 0 : 65535);

	cmp	WORD PTR [rcx], r8w

; 4945 :          p += 2;

	lea	rcx, QWORD PTR [rcx+4]
	mov	eax, 65535				; 0000ffffH
	cmove	ax, r13w
	mov	WORD PTR [rcx-2], ax
	sub	rdx, 1
	jne	SHORT $LL263@stbi__pars

; 4946 :       }
; 4947 :    } else {

	jmp	$LN276@stbi__pars
$LN488@stbi__pars:

; 5209 :             if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)

	movzx	r15d, BYTE PTR has_trans$1$[rsp]

; 5210 :                s->img_out_n = s->img_n+1;

	jmp	$LN78@stbi__pars
$LN267@stbi__pars:
	movzx	edx, WORD PTR tc16$[rbp-252]
	movzx	r8d, WORD PTR tc16$[rbp-254]
	movzx	r9d, WORD PTR tc16$[rbp-256]
$LL266@stbi__pars:

; 4949 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])

	cmp	WORD PTR [rcx], r9w
	jne	SHORT $LN269@stbi__pars
	cmp	WORD PTR [rcx+2], r8w
	jne	SHORT $LN269@stbi__pars
	cmp	WORD PTR [rcx+4], dx
	jne	SHORT $LN269@stbi__pars

; 4950 :             p[3] = 0;

	mov	WORD PTR [rcx+6], r13w
$LN269@stbi__pars:

; 4951 :          p += 4;

	add	rcx, 8
	sub	rax, 1
	jne	SHORT $LL266@stbi__pars

; 5216 :                   if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
; 5217 :                } else {

	jmp	SHORT $LN276@stbi__pars
$LN83@stbi__pars:

; 4918 :       for (i=0; i < pixel_count; ++i) {

	test	eax, eax
	je	SHORT $LN276@stbi__pars

; 4596 :    return c;
; 4597 : }
; 4598 : 
; 4599 : static int stbi__check_png_header(stbi__context *s)
; 4600 : {
; 4601 :    static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
; 4602 :    int i;
; 4603 :    for (i=0; i < 8; ++i)
; 4604 :       if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
; 4605 :    return 1;
; 4606 : }
; 4607 : 
; 4608 : typedef struct
; 4609 : {
; 4610 :    stbi__context *s;
; 4611 :    stbi_uc *idata, *expanded, *out;
; 4612 :    int depth;
; 4613 : } stbi__png;
; 4614 : 
; 4615 : 
; 4616 : enum {
; 4617 :    STBI__F_none=0,
; 4618 :    STBI__F_sub=1,
; 4619 :    STBI__F_up=2,
; 4620 :    STBI__F_avg=3,
; 4621 :    STBI__F_paeth=4,
; 4622 :    // synthetic filters used for first scanline to avoid needing a dummy row of 0s
; 4623 :    STBI__F_avg_first,
; 4624 :    STBI__F_paeth_first
; 4625 : };
; 4626 : 
; 4627 : static stbi_uc first_row_filter[5] =
; 4628 : {
; 4629 :    STBI__F_none,
; 4630 :    STBI__F_sub,
; 4631 :    STBI__F_none,
; 4632 :    STBI__F_avg_first,
; 4633 :    STBI__F_paeth_first
; 4634 : };
; 4635 : 
; 4636 : static int stbi__paeth(int a, int b, int c)
; 4637 : {
; 4638 :    int p = a + b - c;
; 4639 :    int pa = abs(p-a);
; 4640 :    int pb = abs(p-b);
; 4641 :    int pc = abs(p-c);
; 4642 :    if (pa <= pb && pa <= pc) return a;
; 4643 :    if (pb <= pc) return b;
; 4644 :    return c;
; 4645 : }
; 4646 : 
; 4647 : static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };
; 4648 : 
; 4649 : // create the png data from post-deflated data
; 4650 : static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
; 4651 : {
; 4652 :    int bytes = (depth == 16? 2 : 1);
; 4653 :    stbi__context *s = a->s;
; 4654 :    stbi__uint32 i,j,stride = x*out_n*bytes;
; 4655 :    stbi__uint32 img_len, img_width_bytes;
; 4656 :    int k;
; 4657 :    int img_n = s->img_n; // copy it into a local for later
; 4658 : 
; 4659 :    int output_bytes = out_n*bytes;
; 4660 :    int filter_bytes = img_n*bytes;
; 4661 :    int width = x;
; 4662 : 
; 4663 :    STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
; 4664 :    a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
; 4665 :    if (!a->out) return stbi__err("outofmem", "Out of memory");
; 4666 : 
; 4667 :    if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
; 4668 :    img_width_bytes = (((img_n * x * depth) + 7) >> 3);
; 4669 :    img_len = (img_width_bytes + 1) * y;
; 4670 : 
; 4671 :    // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
; 4672 :    // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
; 4673 :    // so just check for raw_len < img_len always.
; 4674 :    if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");
; 4675 : 
; 4676 :    for (j=0; j < y; ++j) {
; 4677 :       stbi_uc *cur = a->out + stride*j;
; 4678 :       stbi_uc *prior;
; 4679 :       int filter = *raw++;
; 4680 : 
; 4681 :       if (filter > 4)
; 4682 :          return stbi__err("invalid filter","Corrupt PNG");
; 4683 : 
; 4684 :       if (depth < 8) {
; 4685 :          if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");
; 4686 :          cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
; 4687 :          filter_bytes = 1;
; 4688 :          width = img_width_bytes;
; 4689 :       }
; 4690 :       prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above
; 4691 : 
; 4692 :       // if first row, use special filter that doesn't sample previous row
; 4693 :       if (j == 0) filter = first_row_filter[filter];
; 4694 : 
; 4695 :       // handle first byte explicitly
; 4696 :       for (k=0; k < filter_bytes; ++k) {
; 4697 :          switch (filter) {
; 4698 :             case STBI__F_none       : cur[k] = raw[k]; break;
; 4699 :             case STBI__F_sub        : cur[k] = raw[k]; break;
; 4700 :             case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
; 4701 :             case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;
; 4702 :             case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;
; 4703 :             case STBI__F_avg_first  : cur[k] = raw[k]; break;
; 4704 :             case STBI__F_paeth_first: cur[k] = raw[k]; break;
; 4705 :          }
; 4706 :       }
; 4707 : 
; 4708 :       if (depth == 8) {
; 4709 :          if (img_n != out_n)
; 4710 :             cur[img_n] = 255; // first pixel
; 4711 :          raw += img_n;
; 4712 :          cur += out_n;
; 4713 :          prior += out_n;
; 4714 :       } else if (depth == 16) {
; 4715 :          if (img_n != out_n) {
; 4716 :             cur[filter_bytes]   = 255; // first pixel top byte
; 4717 :             cur[filter_bytes+1] = 255; // first pixel bottom byte
; 4718 :          }
; 4719 :          raw += filter_bytes;
; 4720 :          cur += output_bytes;
; 4721 :          prior += output_bytes;
; 4722 :       } else {
; 4723 :          raw += 1;
; 4724 :          cur += 1;
; 4725 :          prior += 1;
; 4726 :       }
; 4727 : 
; 4728 :       // this is a little gross, so that we don't switch per-pixel or per-component
; 4729 :       if (depth < 8 || img_n == out_n) {
; 4730 :          int nk = (width - 1)*filter_bytes;
; 4731 :          #define STBI__CASE(f) \
; 4732 :              case f:     \
; 4733 :                 for (k=0; k < nk; ++k)
; 4734 :          switch (filter) {
; 4735 :             // "none" filter turns into a memcpy here; make that explicit.
; 4736 :             case STBI__F_none:         memcpy(cur, raw, nk); break;
; 4737 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;
; 4738 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
; 4739 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;
; 4740 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;
; 4741 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;
; 4742 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;
; 4743 :          }
; 4744 :          #undef STBI__CASE
; 4745 :          raw += nk;
; 4746 :       } else {
; 4747 :          STBI_ASSERT(img_n+1 == out_n);
; 4748 :          #define STBI__CASE(f) \
; 4749 :              case f:     \
; 4750 :                 for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
; 4751 :                    for (k=0; k < filter_bytes; ++k)
; 4752 :          switch (filter) {
; 4753 :             STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;
; 4754 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;
; 4755 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
; 4756 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;
; 4757 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;
; 4758 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;
; 4759 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;
; 4760 :          }
; 4761 :          #undef STBI__CASE
; 4762 : 
; 4763 :          // the loop above sets the high byte of the pixels' alpha, but for
; 4764 :          // 16 bit png files we also need the low byte set. we'll do that here.
; 4765 :          if (depth == 16) {
; 4766 :             cur = a->out + stride*j; // start at the beginning of the row again
; 4767 :             for (i=0; i < x; ++i,cur+=output_bytes) {
; 4768 :                cur[filter_bytes+1] = 255;
; 4769 :             }
; 4770 :          }
; 4771 :       }
; 4772 :    }
; 4773 : 
; 4774 :    // we make a separate pass to expand bits to pixels; for performance,
; 4775 :    // this could run two scanlines behind the above code, so it won't
; 4776 :    // intefere with filtering but will still be in the cache.
; 4777 :    if (depth < 8) {
; 4778 :       for (j=0; j < y; ++j) {
; 4779 :          stbi_uc *cur = a->out + stride*j;
; 4780 :          stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
; 4781 :          // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
; 4782 :          // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
; 4783 :          stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range
; 4784 : 
; 4785 :          // note that the final byte might overshoot and write more data than desired.
; 4786 :          // we can allocate enough data that this never writes out of memory, but it
; 4787 :          // could also overwrite the next scanline. can it overwrite non-empty data
; 4788 :          // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
; 4789 :          // so we need to explicitly clamp the final ones
; 4790 : 
; 4791 :          if (depth == 4) {
; 4792 :             for (k=x*img_n; k >= 2; k-=2, ++in) {
; 4793 :                *cur++ = scale * ((*in >> 4)       );
; 4794 :                *cur++ = scale * ((*in     ) & 0x0f);
; 4795 :             }
; 4796 :             if (k > 0) *cur++ = scale * ((*in >> 4)       );
; 4797 :          } else if (depth == 2) {
; 4798 :             for (k=x*img_n; k >= 4; k-=4, ++in) {
; 4799 :                *cur++ = scale * ((*in >> 6)       );
; 4800 :                *cur++ = scale * ((*in >> 4) & 0x03);
; 4801 :                *cur++ = scale * ((*in >> 2) & 0x03);
; 4802 :                *cur++ = scale * ((*in     ) & 0x03);
; 4803 :             }
; 4804 :             if (k > 0) *cur++ = scale * ((*in >> 6)       );
; 4805 :             if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
; 4806 :             if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
; 4807 :          } else if (depth == 1) {
; 4808 :             for (k=x*img_n; k >= 8; k-=8, ++in) {
; 4809 :                *cur++ = scale * ((*in >> 7)       );
; 4810 :                *cur++ = scale * ((*in >> 6) & 0x01);
; 4811 :                *cur++ = scale * ((*in >> 5) & 0x01);
; 4812 :                *cur++ = scale * ((*in >> 4) & 0x01);
; 4813 :                *cur++ = scale * ((*in >> 3) & 0x01);
; 4814 :                *cur++ = scale * ((*in >> 2) & 0x01);
; 4815 :                *cur++ = scale * ((*in >> 1) & 0x01);
; 4816 :                *cur++ = scale * ((*in     ) & 0x01);
; 4817 :             }
; 4818 :             if (k > 0) *cur++ = scale * ((*in >> 7)       );
; 4819 :             if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
; 4820 :             if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
; 4821 :             if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
; 4822 :             if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
; 4823 :             if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
; 4824 :             if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
; 4825 :          }
; 4826 :          if (img_n != out_n) {
; 4827 :             int q;
; 4828 :             // insert alpha = 255
; 4829 :             cur = a->out + stride*j;
; 4830 :             if (img_n == 1) {
; 4831 :                for (q=x-1; q >= 0; --q) {
; 4832 :                   cur[q*2+1] = 255;
; 4833 :                   cur[q*2+0] = cur[q];
; 4834 :                }
; 4835 :             } else {
; 4836 :                STBI_ASSERT(img_n == 3);
; 4837 :                for (q=x-1; q >= 0; --q) {
; 4838 :                   cur[q*4+3] = 255;
; 4839 :                   cur[q*4+2] = cur[q*3+2];
; 4840 :                   cur[q*4+1] = cur[q*3+1];
; 4841 :                   cur[q*4+0] = cur[q*3+0];
; 4842 :                }
; 4843 :             }
; 4844 :          }
; 4845 :       }
; 4846 :    } else if (depth == 16) {
; 4847 :       // force the image data from big-endian to platform-native.
; 4848 :       // this is done in a separate pass due to the decoding relying
; 4849 :       // on the data being untouched, but could probably be done
; 4850 :       // per-line during decode if care is taken.
; 4851 :       stbi_uc *cur = a->out;
; 4852 :       stbi__uint16 *cur16 = (stbi__uint16*)cur;
; 4853 : 
; 4854 :       for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {
; 4855 :          *cur16 = (cur[0] << 8) | cur[1];
; 4856 :       }
; 4857 :    }
; 4858 : 
; 4859 :    return 1;
; 4860 : }
; 4861 : 
; 4862 : static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
; 4863 : {
; 4864 :    int bytes = (depth == 16 ? 2 : 1);
; 4865 :    int out_bytes = out_n * bytes;
; 4866 :    stbi_uc *final;
; 4867 :    int p;
; 4868 :    if (!interlaced)
; 4869 :       return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);
; 4870 : 
; 4871 :    // de-interlacing
; 4872 :    final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
; 4873 :    if (!final) return stbi__err("outofmem", "Out of memory");
; 4874 :    for (p=0; p < 7; ++p) {
; 4875 :       int xorig[] = { 0,4,0,2,0,1,0 };
; 4876 :       int yorig[] = { 0,0,4,0,2,0,1 };
; 4877 :       int xspc[]  = { 8,8,4,4,2,2,1 };
; 4878 :       int yspc[]  = { 8,8,8,4,4,2,2 };
; 4879 :       int i,j,x,y;
; 4880 :       // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
; 4881 :       x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
; 4882 :       y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
; 4883 :       if (x && y) {
; 4884 :          stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
; 4885 :          if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
; 4886 :             STBI_FREE(final);
; 4887 :             return 0;
; 4888 :          }
; 4889 :          for (j=0; j < y; ++j) {
; 4890 :             for (i=0; i < x; ++i) {
; 4891 :                int out_y = j*yspc[p]+yorig[p];
; 4892 :                int out_x = i*xspc[p]+xorig[p];
; 4893 :                memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
; 4894 :                       a->out + (j*x+i)*out_bytes, out_bytes);
; 4895 :             }
; 4896 :          }
; 4897 :          STBI_FREE(a->out);
; 4898 :          image_data += img_len;
; 4899 :          image_data_len -= img_len;
; 4900 :       }
; 4901 :    }
; 4902 :    a->out = final;
; 4903 : 
; 4904 :    return 1;
; 4905 : }
; 4906 : 
; 4907 : static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
; 4908 : {
; 4909 :    stbi__context *s = z->s;
; 4910 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 4911 :    stbi_uc *p = z->out;
; 4912 : 
; 4913 :    // compute color-based transparency, assuming we've
; 4914 :    // already got 255 as the alpha value in the output
; 4915 :    STBI_ASSERT(out_n == 2 || out_n == 4);
; 4916 : 
; 4917 :    if (out_n == 2) {

	cmp	DWORD PTR [rbx+12], 2
	jne	SHORT $LN278@stbi__pars
	movzx	r8d, BYTE PTR tc$[rbp-256]
	mov	edx, eax
	npad	5
$LL274@stbi__pars:

; 4919 :          p[1] = (p[0] == tc[0] ? 0 : 255);

	cmp	BYTE PTR [rcx], r8b

; 4920 :          p += 2;

	lea	rcx, QWORD PTR [rcx+2]
	mov	eax, 255				; 000000ffH
	cmove	eax, r13d
	mov	BYTE PTR [rcx-1], al
	sub	rdx, 1
	jne	SHORT $LL274@stbi__pars

; 4921 :       }
; 4922 :    } else {

	jmp	SHORT $LN276@stbi__pars
$LN278@stbi__pars:
	movzx	edx, BYTE PTR tc$[rbp-254]
	movzx	r8d, BYTE PTR tc$[rbp-255]
	movzx	r9d, BYTE PTR tc$[rbp-256]
$LL277@stbi__pars:

; 4923 :       for (i=0; i < pixel_count; ++i) {
; 4924 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])

	cmp	BYTE PTR [rcx], r9b
	jne	SHORT $LN280@stbi__pars
	cmp	BYTE PTR [rcx+1], r8b
	jne	SHORT $LN280@stbi__pars
	cmp	BYTE PTR [rcx+2], dl
	jne	SHORT $LN280@stbi__pars

; 4925 :             p[3] = 0;

	mov	BYTE PTR [rcx+3], r13b
$LN280@stbi__pars:

; 4926 :          p += 4;

	add	rcx, 4
	sub	rax, 1
	jne	SHORT $LL277@stbi__pars
$LN276@stbi__pars:

; 5218 :                   if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
; 5219 :                }
; 5220 :             }
; 5221 :             if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)

	test	r14d, r14d
	je	$LN290@stbi__pars
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax]
	mov	eax, OFFSET FLAT:?stbi__de_iphone_flag_set@@3HA
	cmp	DWORD PTR [rax+rdx], r13d
	je	SHORT $LN97@stbi__pars
	mov	eax, OFFSET FLAT:?stbi__de_iphone_flag_local@@3HA
	mov	eax, DWORD PTR [rax+rdx]
	jmp	SHORT $LN98@stbi__pars
$LN97@stbi__pars:
	mov	eax, DWORD PTR ?stbi__de_iphone_flag_global@@3HA
$LN98@stbi__pars:
	test	eax, eax
	je	$LN290@stbi__pars
	cmp	DWORD PTR [rbx+12], 2
	jle	$LN290@stbi__pars

; 5036 :    stbi__context *s = z->s;

	mov	rax, QWORD PTR [r12]

; 5037 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 5038 :    stbi_uc *p = z->out;

	mov	r10, QWORD PTR [r12+24]
	mov	ecx, DWORD PTR [rax+4]
	imul	ecx, DWORD PTR [rax]

; 5039 : 
; 5040 :    if (s->img_out_n == 3) {  // convert bgr to rgb

	cmp	DWORD PTR [rax+12], 3
	jne	SHORT $LN292@stbi__pars

; 5041 :       for (i=0; i < pixel_count; ++i) {

	test	ecx, ecx
	je	$LN290@stbi__pars
	mov	edx, ecx
	npad	15
$LL285@stbi__pars:

; 5042 :          stbi_uc t = p[0];

	movzx	ecx, BYTE PTR [r10]

; 5043 :          p[0] = p[2];

	movzx	eax, BYTE PTR [r10+2]
	mov	BYTE PTR [r10], al

; 5044 :          p[2] = t;

	mov	BYTE PTR [r10+2], cl

; 5045 :          p += 3;

	lea	r10, QWORD PTR [r10+3]
	sub	rdx, 1
	jne	SHORT $LL285@stbi__pars

; 5046 :       }
; 5047 :    } else {

	jmp	$LN290@stbi__pars
$LN292@stbi__pars:

; 5048 :       STBI_ASSERT(s->img_out_n == 4);
; 5049 :       if (stbi__unpremultiply_on_load) {

	mov	eax, OFFSET FLAT:?stbi__unpremultiply_on_load_set@@3HA
	cmp	DWORD PTR [rax+rdx], r13d
	je	SHORT $LN299@stbi__pars
	mov	eax, OFFSET FLAT:?stbi__unpremultiply_on_load_local@@3HA
	mov	eax, DWORD PTR [rax+rdx]
	jmp	SHORT $LN300@stbi__pars
$LN299@stbi__pars:
	mov	eax, DWORD PTR ?stbi__unpremultiply_on_load_global@@3HA
$LN300@stbi__pars:

; 5050 :          // convert bgr to rgb and unpremultiply
; 5051 :          for (i=0; i < pixel_count; ++i) {

	test	ecx, ecx
	je	$LN290@stbi__pars

; 5048 :       STBI_ASSERT(s->img_out_n == 4);
; 5049 :       if (stbi__unpremultiply_on_load) {

	test	eax, eax
	je	SHORT $LN294@stbi__pars

; 5050 :          // convert bgr to rgb and unpremultiply
; 5051 :          for (i=0; i < pixel_count; ++i) {

	mov	edi, ecx
	npad	8
$LL288@stbi__pars:

; 5052 :             stbi_uc a = p[3];

	movzx	eax, BYTE PTR [r10+3]

; 5053 :             stbi_uc t = p[0];

	movzx	r11d, BYTE PTR [r10]
	movzx	ecx, BYTE PTR [r10+2]

; 5054 :             if (a) {

	test	al, al
	je	SHORT $LN296@stbi__pars

; 5055 :                stbi_uc half = a / 2;

	mov	r8d, eax
	mov	r9d, eax

; 5056 :                p[0] = (p[2] * 255 + half) / a;
; 5057 :                p[1] = (p[1] * 255 + half) / a;

	movzx	eax, BYTE PTR [r10+1]
	xor	edx, edx
	imul	eax, eax, 255				; 000000ffH
	shr	r8d, 1
	add	eax, r8d
	div	r9d

; 5058 :                p[2] = ( t   * 255 + half) / a;

	xor	edx, edx
	mov	BYTE PTR [r10+1], al
	imul	eax, r11d, 255				; 000000ffH
	add	eax, r8d
	div	r9d
	xor	edx, edx
	mov	r11d, eax
	imul	eax, ecx, 255				; 000000ffH
	add	eax, r8d
	div	r9d

; 5059 :             } else {

	jmp	SHORT $LN297@stbi__pars
$LN296@stbi__pars:

; 5060 :                p[0] = p[2];
; 5061 :                p[2] = t;

	movzx	eax, cl
$LN297@stbi__pars:

; 5062 :             }
; 5063 :             p += 4;

	mov	BYTE PTR [r10], al
	mov	BYTE PTR [r10+2], r11b
	add	r10, 4
	sub	rdi, 1
	jne	SHORT $LL288@stbi__pars

; 5064 :          }
; 5065 :       } else {

	jmp	SHORT $LN290@stbi__pars
$LN294@stbi__pars:

; 5066 :          // convert bgr to rgb
; 5067 :          for (i=0; i < pixel_count; ++i) {

	mov	edx, ecx
	npad	4
$LL291@stbi__pars:

; 5068 :             stbi_uc t = p[0];

	movzx	ecx, BYTE PTR [r10]

; 5069 :             p[0] = p[2];

	movzx	eax, BYTE PTR [r10+2]
	mov	BYTE PTR [r10], al

; 5070 :             p[2] = t;

	mov	BYTE PTR [r10+2], cl

; 5071 :             p += 4;

	lea	r10, QWORD PTR [r10+4]
	sub	rdx, 1
	jne	SHORT $LL291@stbi__pars
$LN290@stbi__pars:

; 5222 :                stbi__de_iphone(z);
; 5223 :             if (pal_img_n) {

	test	sil, sil
	je	$LN88@stbi__pars

; 5224 :                // pal_img_n == 3 or 4
; 5225 :                s->img_n = pal_img_n; // record the actual colors we had

	movzx	eax, sil
	mov	DWORD PTR [rbx+8], eax

; 5226 :                s->img_out_n = pal_img_n;
; 5227 :                if (req_comp >= 3) s->img_out_n = req_comp;

	mov	DWORD PTR [rbx+12], 4

; 4959 :    stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;

	mov	rax, QWORD PTR [r12]

; 4960 :    stbi_uc *p, *temp_out, *orig = a->out;

	mov	rdi, QWORD PTR [r12+24]
	mov	esi, DWORD PTR [rax+4]
	imul	esi, DWORD PTR [rax]

; 1014 :    if (a < 0 || b < 0) return 0;

	test	esi, esi
	js	$LN446@stbi__pars

; 1024 :    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);

	lea	eax, DWORD PTR [rsi*4]
	cmp	esi, 536870911				; 1fffffffH
	jg	SHORT $LN446@stbi__pars

; 1049 :    return stbi__malloc(a*b + add);

	movsxd	rcx, eax

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc
	mov	r14, rax

; 4963 :    if (p == NULL) return stbi__err("outofmem", "Out of memory");

	test	rax, rax
	je	SHORT $LN446@stbi__pars

; 4964 : 
; 4965 :    // between here and free(out) below, exitting would leak
; 4966 :    temp_out = p;
; 4967 : 
; 4968 :    if (pal_img_n == 3) {
; 4969 :       for (i=0; i < pixel_count; ++i) {
; 4970 :          int n = orig[i]*4;
; 4971 :          p[0] = palette[n  ];
; 4972 :          p[1] = palette[n+1];
; 4973 :          p[2] = palette[n+2];
; 4974 :          p += 3;
; 4975 :       }
; 4976 :    } else {
; 4977 :       for (i=0; i < pixel_count; ++i) {

	test	esi, esi
	je	SHORT $LN235@stbi__pars

; 5191 :                z->idata = p;

	lea	r8, QWORD PTR [rax+2]
	mov	r9d, esi
$LL236@stbi__pars:

; 4978 :          int n = orig[i]*4;

	movzx	edx, BYTE PTR [rdi]

; 4979 :          p[0] = palette[n  ];
; 4980 :          p[1] = palette[n+1];
; 4981 :          p[2] = palette[n+2];
; 4982 :          p[3] = palette[n+3];
; 4983 :          p += 4;

	lea	r8, QWORD PTR [r8+4]
	lea	rdi, QWORD PTR [rdi+1]
	movzx	eax, BYTE PTR palette$[rbp+rdx*4-256]
	movzx	ecx, BYTE PTR palette$[rbp+rdx*4-253]
	mov	BYTE PTR [r8-6], al
	movzx	eax, BYTE PTR palette$[rbp+rdx*4-255]
	mov	BYTE PTR [r8-5], al
	movzx	eax, BYTE PTR palette$[rbp+rdx*4-254]
	mov	BYTE PTR [r8-4], al
	mov	BYTE PTR [r8-3], cl
	sub	r9, 1
	jne	SHORT $LL236@stbi__pars
$LN235@stbi__pars:

; 4984 :       }
; 4985 :    }
; 4986 :    STBI_FREE(a->out);

	mov	rcx, QWORD PTR [r12+24]
	call	QWORD PTR __imp_free

; 4987 :    a->out = temp_out;

	mov	QWORD PTR [r12+24], r14

; 5191 :                z->idata = p;

	jmp	SHORT $LN92@stbi__pars
$LN446@stbi__pars:

; 5260 : }

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	jmp	$LN614@stbi__pars
$LN88@stbi__pars:

; 5228 :                if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
; 5229 :                   return 0;
; 5230 :             } else if (has_trans) {

	test	r15b, r15b
	je	SHORT $LN92@stbi__pars

; 5231 :                // non-paletted image with tRNS -> source image has (constant) alpha
; 5232 :                ++s->img_n;

	inc	DWORD PTR [rbx+8]
$LN92@stbi__pars:

; 5233 :             }
; 5234 :             STBI_FREE(z->expanded); z->expanded = NULL;

	mov	rcx, QWORD PTR [r12+16]
	call	QWORD PTR __imp_free

; 5235 :             // end of PNG chunk, read and skip CRC
; 5236 :             stbi__get32be(s);

	mov	rcx, rbx
	mov	QWORD PTR [r12+16], r13
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be

; 5237 :             return 1;

	mov	eax, 1
	jmp	$LN3@stbi__pars
$LN194@stbi__pars:

; 4530 :       STBI_FREE(a.zout_start);

	mov	rcx, QWORD PTR a$2[rbp-224]
	call	QWORD PTR __imp_free

; 4531 :       return NULL;

	mov	QWORD PTR [r12+16], r13

; 5191 :                z->idata = p;

	jmp	$LN325@stbi__pars
$LN322@stbi__pars:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_07CKIELOEH@no?5PLTE@

; 5174 :             if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");

	jmp	$LN614@stbi__pars
$LN327@stbi__pars:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_09MNNCNKEO@outofdata@

; 5192 :             }
; 5193 :             if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");

	jmp	$LN614@stbi__pars
$LN324@stbi__pars:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BA@PLHGLONG@IDAT?5size?5limit@

; 5175 :             if (scan == STBI__SCAN_header) {
; 5176 :                // header scan definitely stops at first IDAT
; 5177 :                if (pal_img_n)
; 5178 :                   s->img_n = pal_img_n;
; 5179 :                return 1;
; 5180 :             }
; 5181 :             if (c.length > (1u << 30)) return stbi__err("IDAT size limit", "IDAT section larger than 2^30 bytes");

	jmp	$LN614@stbi__pars
$LN334@stbi__pars:

; 5260 : }

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_09MBBNGCKB@bad?5ctype@
	jmp	$LN614@stbi__pars
$LN336@stbi__pars:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BA@MDMBDDFG@bad?5comp?5method@

; 5116 :             comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");

	jmp	$LN614@stbi__pars
$LN337@stbi__pars:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BC@GHLIKKMD@bad?5filter?5method@

; 5117 :             filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");

	jmp	$LN614@stbi__pars
$LN39@stbi__pars:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0O@FNFBHCOO@0?9pixel?5image@

; 5119 :             if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");

	jmp	$LN614@stbi__pars
$LN338@stbi__pars:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BF@JCGDPBAA@bad?5interlace?5method@

; 5118 :             interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");

	jmp	$LN614@stbi__pars
$LN332@stbi__pars:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only@

; 5112 :             z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");

	jmp	$LN614@stbi__pars
$LN329@stbi__pars:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0N@POJLKMKK@bad?5IHDR?5len@

; 5107 :             if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");

	jmp	$LN614@stbi__pars
$LN328@stbi__pars:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0O@KBHBNJOK@multiple?5IHDR@

; 5101 :             stbi__skip(s, c.length);
; 5102 :             break;
; 5103 :          case STBI__PNG_TYPE('I','H','D','R'): {
; 5104 :             int comp,filter;
; 5105 :             if (!first) return stbi__err("multiple IHDR","Corrupt PNG");

	jmp	$LN614@stbi__pars
$LN343@stbi__pars:

; 5244 :                #ifndef STBI_NO_FAILURE_STRINGS
; 5245 :                // not threadsafe
; 5246 :                static char invalid_chunk[] = "XXXX PNG chunk not known";
; 5247 :                invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);

	mov	eax, edx

; 5248 :                invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
; 5249 :                invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
; 5250 :                invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);

	mov	BYTE PTR ?invalid_chunk@?JM@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA+3, dl
	shr	eax, 24
	mov	BYTE PTR ?invalid_chunk@?JM@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA, al
	mov	eax, edx
	shr	eax, 16
	mov	BYTE PTR ?invalid_chunk@?JM@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA+1, al
	mov	eax, edx
	shr	eax, 8
	mov	BYTE PTR ?invalid_chunk@?JM@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA+2, al

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:?invalid_chunk@?JM@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA

; 5251 :                #endif
; 5252 :                return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");

	jmp	$LN614@stbi__pars
$LN348@stbi__pars:

; 5260 : }

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0N@KDLCCKCH@bad?5tRNS?5len@
	jmp	SHORT $LN614@stbi__pars
$LN347@stbi__pars:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE@

; 5151 :                if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
; 5152 :                if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");

	jmp	SHORT $LN614@stbi__pars
$LN349@stbi__pars:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha@

; 5158 :                if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");

	jmp	SHORT $LN614@stbi__pars
$LN345@stbi__pars:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT@

; 5149 :             if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");

	jmp	SHORT $LN614@stbi__pars
$LN354@stbi__pars:

; 5260 : }

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0N@JCPAJAKB@invalid?5PLTE@
	jmp	SHORT $LN614@stbi__pars
$LN352@stbi__pars:
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0P@JEAFOMAF@first?5not?5IHDR@
$LN614@stbi__pars:
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	QWORD PTR [rdx+rcx], rax
$LN325@stbi__pars:
	xor	eax, eax
$LN3@stbi__pars:
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+5264]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z ENDP	; stbi__parse_png_file
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z
_TEXT	SEGMENT
p$ = 80
x$ = 88
y$ = 96
n$ = 104
req_comp$dead$ = 112
ri$ = 120
?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__do_png, COMDAT

; 5263 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 5264 :    void *result=NULL;

	xor	ebp, ebp
	mov	r14, r8
	mov	r15, rdx
	mov	rsi, r9

; 5265 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
; 5266 :    if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {

	xor	edx, edx
	mov	rbx, rcx
	mov	edi, ebp
	lea	r8d, QWORD PTR [rbp+4]
	call	?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z ; stbi__parse_png_file
	test	eax, eax
	je	$LN13@stbi__do_p

; 5267 :       if (p->depth <= 8)

	mov	eax, DWORD PTR [rbx+32]
	cmp	eax, 8
	jg	SHORT $LN5@stbi__do_p

; 5268 :          ri->bits_per_channel = 8;

	lea	eax, QWORD PTR [rbp+8]
	jmp	SHORT $LN8@stbi__do_p
$LN5@stbi__do_p:

; 5269 :       else if (p->depth == 16)

	cmp	eax, 16
	jne	$LN7@stbi__do_p
$LN8@stbi__do_p:

; 5270 :          ri->bits_per_channel = 16;
; 5271 :       else
; 5272 :          return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
; 5273 :       result = p->out;

	mov	rcx, QWORD PTR ri$[rsp]
	mov	DWORD PTR [rcx], eax

; 5274 :       p->out = NULL;
; 5275 :       if (req_comp && req_comp != p->s->img_out_n) {

	mov	r8, QWORD PTR [rbx]
	mov	rdi, QWORD PTR [rbx+24]
	mov	QWORD PTR [rbx+24], rbp
	mov	edx, DWORD PTR [r8+12]
	cmp	edx, 4
	je	SHORT $LN19@stbi__do_p

; 5276 :          if (ri->bits_per_channel == 8)

	mov	eax, DWORD PTR [r8+4]
	cmp	DWORD PTR [rcx], 8
	mov	rcx, rdi
	mov	r9d, DWORD PTR [r8]
	mov	DWORD PTR [rsp+32], eax
	jne	SHORT $LN10@stbi__do_p

; 5277 :             result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

	mov	r8d, 4
	call	?stbi__convert_format@@YAPEAEPEAEHHII@Z	; stbi__convert_format
	jmp	SHORT $LN27@stbi__do_p
$LN10@stbi__do_p:

; 5278 :          else
; 5279 :             result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

	call	?stbi__convert_format16@@YAPEAGPEAGHHII@Z ; stbi__convert_format16
$LN27@stbi__do_p:

; 5280 :          p->s->img_out_n = req_comp;

	mov	r8, QWORD PTR [rbx]
	mov	rdi, rax
	mov	DWORD PTR [r8+12], 4

; 5281 :          if (result == NULL) return result;

	test	rax, rax
	je	SHORT $LN28@stbi__do_p
$LN19@stbi__do_p:

; 5282 :       }
; 5283 :       *x = p->s->img_x;

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [r15], eax

; 5284 :       *y = p->s->img_y;

	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [r14], eax

; 5285 :       if (n) *n = p->s->img_n;

	test	rsi, rsi
	je	SHORT $LN13@stbi__do_p
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rsi], eax
$LN13@stbi__do_p:

; 5286 :    }
; 5287 :    STBI_FREE(p->out);      p->out      = NULL;

	mov	rcx, QWORD PTR [rbx+24]
	call	QWORD PTR __imp_free

; 5288 :    STBI_FREE(p->expanded); p->expanded = NULL;

	mov	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+24], rbp
	call	QWORD PTR __imp_free

; 5289 :    STBI_FREE(p->idata);    p->idata    = NULL;

	mov	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rbx+16], rbp
	call	QWORD PTR __imp_free

; 5290 : 
; 5291 :    return result;

	mov	rax, rdi
	mov	QWORD PTR [rbx+8], rbp
$LN1@stbi__do_p:

; 5292 : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN7@stbi__do_p:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BF@NOEEEFMF@bad?5bits_per_channel@
	mov	QWORD PTR [rdx+rcx], rax
$LN28@stbi__do_p:

; 5292 : }

	xor	eax, eax
	jmp	SHORT $LN1@stbi__do_p
?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__do_png
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
_TEXT	SEGMENT
p$ = 48
__$ArrayPad$ = 88
s$ = 144
x$ = 152
y$ = 160
comp$ = 168
req_comp$dead$ = 176
ri$ = 184
?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__png_load, COMDAT

; 5295 : {

	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, QWORD PTR ri$[rsp]
	mov	r15, r8
	mov	r14, rdx

; 5296 :    stbi__png p;
; 5297 :    p.s = s;

	mov	QWORD PTR p$[rsp], rcx

; 5264 :    void *result=NULL;

	xor	ebx, ebx

; 5265 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
; 5266 :    if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {

	lea	rcx, QWORD PTR p$[rsp]
	xor	edx, edx

; 5295 : {

	mov	rdi, r9

; 5266 :    if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {

	lea	r8d, QWORD PTR [rbx+4]
	call	?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z ; stbi__parse_png_file
	test	eax, eax
	je	$LN22@stbi__png_

; 5267 :       if (p->depth <= 8)

	mov	eax, DWORD PTR p$[rsp+32]
	cmp	eax, 8
	jg	SHORT $LN7@stbi__png_

; 5268 :          ri->bits_per_channel = 8;

	lea	eax, QWORD PTR [rbx+8]
	jmp	SHORT $LN10@stbi__png_
$LN7@stbi__png_:

; 5269 :       else if (p->depth == 16)

	cmp	eax, 16
	jne	$LN9@stbi__png_
$LN10@stbi__png_:

; 5270 :          ri->bits_per_channel = 16;
; 5271 :       else
; 5272 :          return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
; 5273 :       result = p->out;

	mov	DWORD PTR [rsi], eax

; 5274 :       p->out = NULL;
; 5275 :       if (req_comp && req_comp != p->s->img_out_n) {

	mov	rcx, QWORD PTR p$[rsp]
	mov	rbx, QWORD PTR p$[rsp+24]
	mov	QWORD PTR p$[rsp+24], 0
	mov	edx, DWORD PTR [rcx+12]
	cmp	edx, 4
	je	SHORT $LN14@stbi__png_

; 5276 :          if (ri->bits_per_channel == 8)

	mov	r9d, DWORD PTR [rcx]
	cmp	eax, 8
	mov	eax, DWORD PTR [rcx+4]
	mov	rcx, rbx
	mov	DWORD PTR [rsp+32], eax
	jne	SHORT $LN12@stbi__png_

; 5277 :             result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

	mov	r8d, 4
	call	?stbi__convert_format@@YAPEAEPEAEHHII@Z	; stbi__convert_format
	jmp	SHORT $LN30@stbi__png_
$LN12@stbi__png_:

; 5278 :          else
; 5279 :             result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

	call	?stbi__convert_format16@@YAPEAGPEAGHHII@Z ; stbi__convert_format16
$LN30@stbi__png_:

; 5280 :          p->s->img_out_n = req_comp;

	mov	rbx, rax
	mov	rax, QWORD PTR p$[rsp]
	mov	DWORD PTR [rax+12], 4

; 5281 :          if (result == NULL) return result;

	test	rbx, rbx
	je	$LN31@stbi__png_
	mov	rcx, QWORD PTR p$[rsp]
$LN14@stbi__png_:

; 5282 :       }
; 5283 :       *x = p->s->img_x;

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r14], eax

; 5284 :       *y = p->s->img_y;

	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [r15], eax

; 5285 :       if (n) *n = p->s->img_n;

	test	rdi, rdi
	je	SHORT $LN22@stbi__png_
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rdi], eax
$LN22@stbi__png_:

; 5286 :    }
; 5287 :    STBI_FREE(p->out);      p->out      = NULL;

	mov	rcx, QWORD PTR p$[rsp+24]
	call	QWORD PTR __imp_free

; 5288 :    STBI_FREE(p->expanded); p->expanded = NULL;

	mov	rcx, QWORD PTR p$[rsp+16]
	mov	QWORD PTR p$[rsp+24], 0
	call	QWORD PTR __imp_free

; 5289 :    STBI_FREE(p->idata);    p->idata    = NULL;

	mov	rcx, QWORD PTR p$[rsp+8]
	mov	QWORD PTR p$[rsp+16], 0
	call	QWORD PTR __imp_free

; 5298 :    return stbi__do_png(&p, x,y,comp,req_comp, ri);

	mov	rax, rbx
$LN3@stbi__png_:

; 5299 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN9@stbi__png_:

; 978  :    stbi__g_failure_reason = str;

	mov	rcx, QWORD PTR gs:88
	mov	r8d, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rdx, QWORD PTR [rcx]
	lea	rcx, OFFSET FLAT:??_C@_0BF@NOEEEFMF@bad?5bits_per_channel@
	mov	QWORD PTR [r8+rdx], rcx
$LN31@stbi__png_:

; 5299 : }

	xor	eax, eax
	jmp	SHORT $LN3@stbi__png_
?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__png_load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__png_test@@YAHPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__png_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__png_test, COMDAT

; 5302 : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 5303 :    int r;
; 5304 :    r = stbi__check_png_header(s);

	call	?stbi__check_png_header@@YAHPEAUstbi__context@@@Z ; stbi__check_png_header

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	rdx, QWORD PTR [rbx+208]
	mov	QWORD PTR [rbx+192], rdx

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	rdx, QWORD PTR [rbx+216]
	mov	QWORD PTR [rbx+200], rdx

; 5305 :    stbi__rewind(s);
; 5306 :    return r;
; 5307 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stbi__png_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__png_test
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z PROC	; stbi__bmp_test_raw, COMDAT

; 5346 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rcx+192]

; 5346 : {

	mov	rdi, rcx

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rcx+200]
	jb	SHORT $LN34@stbi__bmp_

; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rcx+48], 0
	je	$LN21@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi+192]
$LN34@stbi__bmp_:

; 5347 :    int r;
; 5348 :    int sz;
; 5349 :    if (stbi__get8(s) != 'B') return 0;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	cmp	cl, 66					; 00000042H
	jne	$LN21@stbi__bmp_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rdi+200]
	jb	SHORT $LN35@stbi__bmp_

; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], 0
	je	$LN21@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi+192]
$LN35@stbi__bmp_:

; 5350 :    if (stbi__get8(s) != 'M') return 0;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	cmp	cl, 77					; 0000004dH
	jne	SHORT $LN21@stbi__bmp_

; 1722 :    stbi__uint32 z = stbi__get16le(s);

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5351 :    stbi__get32le(s); // discard filesize
; 5352 :    stbi__get16le(s); // discard reserved

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5353 :    stbi__get16le(s); // discard reserved

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1722 :    stbi__uint32 z = stbi__get16le(s);

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1722 :    stbi__uint32 z = stbi__get16le(s);

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;

	mov	rcx, rdi
	mov	ebx, eax
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	shl	eax, 16
	add	eax, ebx

; 5354 :    stbi__get32le(s); // discard data offset
; 5355 :    sz = stbi__get32le(s);
; 5356 :    r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);

	cmp	eax, 56					; 00000038H
	ja	SHORT $LN23@stbi__bmp_
	mov	rdx, 72058693549559808			; 0100010000001000H
	bt	rdx, rax
	jb	SHORT $LN5@stbi__bmp_
$LN23@stbi__bmp_:
	cmp	eax, 108				; 0000006cH
	je	SHORT $LN5@stbi__bmp_
	cmp	eax, 124				; 0000007cH
	jne	SHORT $LN21@stbi__bmp_
$LN5@stbi__bmp_:
	mov	eax, 1

; 5357 :    return r;
; 5358 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN21@stbi__bmp_:
	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z ENDP	; stbi__bmp_test_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__bmp_test@@YAHPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__bmp_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__bmp_test, COMDAT

; 5361 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rcx+192]

; 5361 : {

	mov	rdi, rcx

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rcx+200]
	jb	SHORT $LN38@stbi__bmp_

; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rcx+48], 0
	je	$LN26@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi+192]
$LN38@stbi__bmp_:

; 5349 :    if (stbi__get8(s) != 'B') return 0;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	cmp	cl, 66					; 00000042H
	jne	$LN26@stbi__bmp_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rdi+200]
	jb	SHORT $LN39@stbi__bmp_

; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], 0
	je	$LN26@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi+192]
$LN39@stbi__bmp_:

; 5350 :    if (stbi__get8(s) != 'M') return 0;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	cmp	cl, 77					; 0000004dH
	jne	SHORT $LN26@stbi__bmp_

; 1722 :    stbi__uint32 z = stbi__get16le(s);

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5352 :    stbi__get16le(s); // discard reserved

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5353 :    stbi__get16le(s); // discard reserved

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1722 :    stbi__uint32 z = stbi__get16le(s);

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1722 :    stbi__uint32 z = stbi__get16le(s);

	mov	rcx, rdi
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;

	mov	rcx, rdi
	mov	ebx, eax
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	shl	eax, 16
	add	eax, ebx

; 5356 :    r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);

	cmp	eax, 56					; 00000038H
	ja	SHORT $LN27@stbi__bmp_
	mov	rdx, 72058693549559808			; 0100010000001000H
	bt	rdx, rax
	jb	SHORT $LN7@stbi__bmp_
$LN27@stbi__bmp_:
	cmp	eax, 108				; 0000006cH
	je	SHORT $LN7@stbi__bmp_
	cmp	eax, 124				; 0000007cH
	jne	SHORT $LN26@stbi__bmp_
$LN7@stbi__bmp_:
	mov	eax, 1

; 5357 :    return r;

	jmp	SHORT $LN3@stbi__bmp_
$LN26@stbi__bmp_:

; 889  :    s->img_buffer = s->img_buffer_original;

	xor	eax, eax
$LN3@stbi__bmp_:
	mov	rcx, QWORD PTR [rdi+208]

; 5362 :    int r = stbi__bmp_test_raw(s);
; 5363 :    stbi__rewind(s);
; 5364 :    return r;
; 5365 : }

	mov	rbx, QWORD PTR [rsp+48]

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	QWORD PTR [rdi+192], rcx

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	rcx, QWORD PTR [rdi+216]
	mov	QWORD PTR [rdi+200], rcx

; 5362 :    int r = stbi__bmp_test_raw(s);
; 5363 :    stbi__rewind(s);
; 5364 :    return r;
; 5365 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__bmp_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__bmp_test
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__high_bit@@YAHI@Z
_TEXT	SEGMENT
z$ = 8
?stbi__high_bit@@YAHI@Z PROC				; stbi__high_bit, COMDAT

; 5370 : {

	mov	eax, ecx

; 5371 :    int n=0;
; 5372 :    if (z == 0) return -1;

	test	ecx, ecx
	jne	SHORT $LN2@stbi__high
	mov	eax, -1

; 5379 : }

	ret	0
$LN2@stbi__high:

; 5373 :    if (z >= 0x10000) { n += 16; z >>= 16; }
; 5374 :    if (z >= 0x00100) { n +=  8; z >>=  8; }

	shr	ecx, 16
	mov	edx, 16
	cmp	eax, 65536				; 00010000H
	cmovb	ecx, eax
	xor	r8d, r8d
	cmp	eax, 65536				; 00010000H
	cmovb	edx, r8d
	cmp	ecx, 256				; 00000100H
	jb	SHORT $LN4@stbi__high
	add	edx, 8
	shr	ecx, 8
$LN4@stbi__high:

; 5375 :    if (z >= 0x00010) { n +=  4; z >>=  4; }
; 5376 :    if (z >= 0x00004) { n +=  2; z >>=  2; }

	mov	r8d, ecx
	lea	eax, DWORD PTR [rdx+4]
	shr	r8d, 4
	cmp	ecx, 16
	cmovb	eax, edx
	cmovb	r8d, ecx

; 5377 :    if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }

	cmp	r8d, 4
	mov	ecx, r8d
	lea	edx, DWORD PTR [rax+2]
	cmovb	edx, eax
	shr	ecx, 2
	cmp	r8d, 4
	cmovb	ecx, r8d

; 5378 :    return n;

	cmp	ecx, 2
	lea	eax, DWORD PTR [rdx+1]
	cmovb	eax, edx

; 5379 : }

	ret	0
?stbi__high_bit@@YAHI@Z ENDP				; stbi__high_bit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__bitcount@@YAHI@Z
_TEXT	SEGMENT
a$ = 8
?stbi__bitcount@@YAHI@Z PROC				; stbi__bitcount, COMDAT

; 5383 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2

	mov	edx, ecx
	and	ecx, 1431655765				; 55555555H
	shr	edx, 1
	and	edx, 1431655765				; 55555555H
	add	edx, ecx

; 5384 :    a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4

	mov	eax, edx
	and	edx, 858993459				; 33333333H
	shr	eax, 2
	and	eax, 858993459				; 33333333H
	add	eax, edx

; 5385 :    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits

	mov	ecx, eax
	shr	ecx, 4
	add	ecx, eax
	and	ecx, 252645135				; 0f0f0f0fH

; 5386 :    a = (a + (a >> 8)); // max 16 per 8 bits

	mov	eax, ecx
	shr	eax, 8
	add	ecx, eax

; 5387 :    a = (a + (a >> 16)); // max 32 per 8 bits

	mov	eax, ecx
	shr	eax, 16
	add	eax, ecx

; 5388 :    return a & 0xff;

	movzx	eax, al

; 5389 : }

	ret	0
?stbi__bitcount@@YAHI@Z ENDP				; stbi__bitcount
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__shiftsigned@@YAHIHH@Z
_TEXT	SEGMENT
v$ = 8
shift$ = 16
bits$ = 24
?stbi__shiftsigned@@YAHIHH@Z PROC			; stbi__shiftsigned, COMDAT

; 5395 : {

	mov	r9d, ecx

; 5396 :    static unsigned int mul_table[9] = {
; 5397 :       0,
; 5398 :       0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
; 5399 :       0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
; 5400 :    };
; 5401 :    static unsigned int shift_table[9] = {
; 5402 :       0, 0,0,1,0,2,4,6,0,
; 5403 :    };
; 5404 :    if (shift < 0)

	test	edx, edx
	jns	SHORT $LN2@stbi__shif

; 5405 :       v <<= -shift;

	neg	edx
	movzx	ecx, dl
	shl	r9d, cl
	jmp	SHORT $LN3@stbi__shif
$LN2@stbi__shif:

; 5406 :    else
; 5407 :       v >>= shift;

	mov	ecx, edx
	shr	r9d, cl
$LN3@stbi__shif:

; 5408 :    STBI_ASSERT(v < 256);
; 5409 :    v >>= (8-bits);
; 5410 :    STBI_ASSERT(bits >= 0 && bits <= 8);
; 5411 :    return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];

	movsxd	rax, r8d
	mov	ecx, 8
	sub	ecx, r8d
	shr	r9d, cl
	lea	rcx, OFFSET FLAT:__ImageBase
	imul	r9d, DWORD PTR ?mul_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA[rcx+rax*4]
	mov	ecx, DWORD PTR ?shift_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA[rcx+rax*4]
	sar	r9d, cl
	mov	eax, r9d

; 5412 : }

	ret	0
?stbi__shiftsigned@@YAHIHH@Z ENDP			; stbi__shiftsigned
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__bmp_set_mask_defaults@@YAHPEAUstbi__bmp_data@@H@Z
_TEXT	SEGMENT
info$ = 8
compress$ = 16
?stbi__bmp_set_mask_defaults@@YAHPEAUstbi__bmp_data@@H@Z PROC ; stbi__bmp_set_mask_defaults, COMDAT

; 5423 :    // BI_BITFIELDS specifies masks explicitly, don't override
; 5424 :    if (compress == 3)

	cmp	edx, 3
	je	SHORT $LN7@stbi__bmp_

; 5425 :       return 1;
; 5426 : 
; 5427 :    if (compress == 0) {

	test	edx, edx
	jne	SHORT $LN3@stbi__bmp_

; 5428 :       if (info->bpp == 16) {

	mov	eax, DWORD PTR [rcx]
	cmp	eax, 16
	jne	SHORT $LN4@stbi__bmp_

; 5429 :          info->mr = 31u << 10;

	mov	DWORD PTR [rcx+12], 31744		; 00007c00H

; 5430 :          info->mg = 31u <<  5;

	mov	DWORD PTR [rcx+16], 992			; 000003e0H

; 5431 :          info->mb = 31u <<  0;

	mov	DWORD PTR [rcx+20], 31
$LN7@stbi__bmp_:

; 5441 :       }
; 5442 :       return 1;

	mov	eax, 1

; 5445 : }

	ret	0
$LN4@stbi__bmp_:

; 5432 :       } else if (info->bpp == 32) {

	cmp	eax, 32					; 00000020H
	jne	SHORT $LN6@stbi__bmp_

; 5433 :          info->mr = 0xffu << 16;
; 5434 :          info->mg = 0xffu <<  8;
; 5435 :          info->mb = 0xffu <<  0;
; 5436 :          info->ma = 0xffu << 24;
; 5437 :          info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0

	xor	eax, eax
	mov	DWORD PTR [rcx+12], 16711680		; 00ff0000H
	mov	DWORD PTR [rcx+28], eax

; 5441 :       }
; 5442 :       return 1;

	mov	eax, 1
	mov	DWORD PTR [rcx+16], 65280		; 0000ff00H
	mov	DWORD PTR [rcx+20], 255			; 000000ffH
	mov	DWORD PTR [rcx+24], -16777216		; ff000000H

; 5445 : }

	ret	0
$LN6@stbi__bmp_:

; 5438 :       } else {
; 5439 :          // otherwise, use defaults, which is all-0
; 5440 :          info->mr = info->mg = info->mb = info->ma = 0;

	xor	eax, eax
	mov	QWORD PTR [rcx+20], rax
	mov	QWORD PTR [rcx+12], rax

; 5441 :       }
; 5442 :       return 1;

	mov	eax, 1

; 5445 : }

	ret	0
$LN3@stbi__bmp_:

; 5443 :    }
; 5444 :    return 0; // error

	xor	eax, eax

; 5445 : }

	ret	0
?stbi__bmp_set_mask_defaults@@YAHPEAUstbi__bmp_data@@H@Z ENDP ; stbi__bmp_set_mask_defaults
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z
_TEXT	SEGMENT
s$ = 48
info$ = 56
?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z PROC ; stbi__bmp_parse_header, COMDAT

; 5448 : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rcx+192]

; 5448 : {

	mov	rsi, rdx
	mov	rbx, rcx

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rcx+200]
	jb	SHORT $LN108@stbi__bmp_

; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rcx+48], 0
	je	$LN6@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN108@stbi__bmp_:

; 5449 :    int hsz;
; 5450 :    if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 66					; 00000042H
	jne	$LN6@stbi__bmp_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN109@stbi__bmp_

; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	$LN6@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN109@stbi__bmp_:

; 5449 :    int hsz;
; 5450 :    if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 77					; 0000004dH
	jne	$LN6@stbi__bmp_

; 1722 :    stbi__uint32 z = stbi__get16le(s);

	mov	rcx, rbx

; 5449 :    int hsz;
; 5450 :    if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");

	mov	QWORD PTR [rsp+48], rbp

; 1722 :    stbi__uint32 z = stbi__get16le(s);

	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;

	mov	rcx, rbx
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5451 :    stbi__get32le(s); // discard filesize
; 5452 :    stbi__get16le(s); // discard reserved

	mov	rcx, rbx
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5453 :    stbi__get16le(s); // discard reserved

	mov	rcx, rbx
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1722 :    stbi__uint32 z = stbi__get16le(s);

	mov	rcx, rbx
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;

	mov	rcx, rbx
	mov	edi, eax
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	shl	eax, 16

; 1722 :    stbi__uint32 z = stbi__get16le(s);

	mov	rcx, rbx

; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;

	add	eax, edi

; 5454 :    info->offset = stbi__get32le(s);

	mov	DWORD PTR [rsi+4], eax

; 1722 :    stbi__uint32 z = stbi__get16le(s);

	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;

	mov	rcx, rbx
	mov	edi, eax
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	ebp, eax

; 5457 :    info->extra_read = 14;

	mov	DWORD PTR [rsi+32], 14
	xor	eax, eax

; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;

	shl	ebp, 16
	add	ebp, edi

; 5455 :    info->hsz = hsz = stbi__get32le(s);
; 5456 :    info->mr = info->mg = info->mb = info->ma = 0;

	mov	QWORD PTR [rsi+20], rax
	mov	DWORD PTR [rsi+8], ebp
	mov	QWORD PTR [rsi+12], rax

; 5458 : 
; 5459 :    if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");

	cmp	DWORD PTR [rsi+4], eax
	jl	$LN25@stbi__bmp_

; 5460 : 
; 5461 :    if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");

	cmp	ebp, 56					; 00000038H
	ja	SHORT $LN73@stbi__bmp_
	mov	rcx, 72058693549559808			; 0100010000001000H
	bt	rcx, rbp
	jb	SHORT $LN8@stbi__bmp_
$LN73@stbi__bmp_:
	cmp	ebp, 108				; 0000006cH
	je	SHORT $LN8@stbi__bmp_
	cmp	ebp, 124				; 0000007cH
	je	SHORT $LN8@stbi__bmp_

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0M@KHBIBJBG@unknown?5BMP@
$LN110@stbi__bmp_:
	mov	QWORD PTR [rdx+rcx], rax

; 5498 :                   // ?!?!?
; 5499 :                   return stbi__errpuc("bad BMP", "bad BMP");

	xor	eax, eax
$LN107@stbi__bmp_:
	mov	rbp, QWORD PTR [rsp+48]

; 5527 : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN8@stbi__bmp_:

; 5462 :    if (hsz == 12) {

	mov	rcx, rbx
	cmp	ebp, 12
	jne	SHORT $LN9@stbi__bmp_

; 5463 :       s->img_x = stbi__get16le(s);

	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5464 :       s->img_y = stbi__get16le(s);

	mov	rcx, rbx
	mov	DWORD PTR [rbx], eax
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5465 :    } else {

	jmp	SHORT $LN10@stbi__bmp_
$LN9@stbi__bmp_:

; 5466 :       s->img_x = stbi__get32le(s);

	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5467 :       s->img_y = stbi__get32le(s);

	mov	rcx, rbx
	mov	DWORD PTR [rbx], eax
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
$LN10@stbi__bmp_:

; 5468 :    }
; 5469 :    if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");

	mov	rcx, rbx
	mov	DWORD PTR [rbx+4], eax
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	cmp	eax, 1
	jne	$LN25@stbi__bmp_

; 5470 :    info->bpp = stbi__get16le(s);

	mov	rcx, rbx
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	DWORD PTR [rsi], eax

; 5471 :    if (hsz != 12) {

	cmp	ebp, 12
	je	$LN30@stbi__bmp_

; 5472 :       int compress = stbi__get32le(s);

	mov	rcx, rbx
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	edi, eax

; 5473 :       if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");

	lea	ecx, DWORD PTR [rax-1]
	cmp	ecx, 1
	jbe	$LN14@stbi__bmp_

; 5474 :       if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes

	cmp	eax, 4
	jl	SHORT $LN15@stbi__bmp_

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0N@ODCBCBFN@BMP?5JPEG?1PNG@

; 5474 :       if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes

	jmp	$LN110@stbi__bmp_
$LN15@stbi__bmp_:

; 5475 :       if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel

	cmp	edi, 3
	jne	SHORT $LN16@stbi__bmp_
	mov	eax, DWORD PTR [rsi]
	sub	eax, 16
	test	eax, -17				; ffffffefH
	jne	$LN25@stbi__bmp_
$LN16@stbi__bmp_:

; 5476 :       stbi__get32le(s); // discard sizeof

	mov	rcx, rbx
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5477 :       stbi__get32le(s); // discard hres

	mov	rcx, rbx
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5478 :       stbi__get32le(s); // discard vres

	mov	rcx, rbx
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5479 :       stbi__get32le(s); // discard colorsused

	mov	rcx, rbx
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5480 :       stbi__get32le(s); // discard max important

	mov	rcx, rbx
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5481 :       if (hsz == 40 || hsz == 56) {

	cmp	ebp, 40					; 00000028H
	je	$LN20@stbi__bmp_
	cmp	ebp, 56					; 00000038H
	je	$LN72@stbi__bmp_

; 5500 :                }
; 5501 :             } else
; 5502 :                return stbi__errpuc("bad BMP", "bad BMP");
; 5503 :          }
; 5504 :       } else {
; 5505 :          // V4/V5 header
; 5506 :          int i;
; 5507 :          if (hsz != 108 && hsz != 124)

	lea	eax, DWORD PTR [rbp-108]
	test	eax, -17				; ffffffefH
	jne	$LN25@stbi__bmp_

; 5508 :             return stbi__errpuc("bad BMP", "bad BMP");
; 5509 :          info->mr = stbi__get32le(s);

	mov	rcx, rbx
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5510 :          info->mg = stbi__get32le(s);

	mov	rcx, rbx
	mov	DWORD PTR [rsi+12], eax
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5511 :          info->mb = stbi__get32le(s);

	mov	rcx, rbx
	mov	DWORD PTR [rsi+16], eax
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5512 :          info->ma = stbi__get32le(s);

	mov	rcx, rbx
	mov	DWORD PTR [rsi+20], eax
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	DWORD PTR [rsi+24], eax

; 5513 :          if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs

	cmp	edi, 3
	je	SHORT $LN29@stbi__bmp_

; 5514 :             stbi__bmp_set_mask_defaults(info, compress);

	mov	edx, edi
	mov	rcx, rsi
	call	?stbi__bmp_set_mask_defaults@@YAHPEAUstbi__bmp_data@@H@Z ; stbi__bmp_set_mask_defaults
$LN29@stbi__bmp_:

; 5515 :          stbi__get32le(s); // discard color space

	mov	rcx, rbx
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	edi, 12
	npad	4
$LL4@stbi__bmp_:

; 1722 :    stbi__uint32 z = stbi__get16le(s);

	mov	rcx, rbx
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;

	mov	rcx, rbx
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5516 :          for (i=0; i < 12; ++i)

	sub	rdi, 1
	jne	SHORT $LL4@stbi__bmp_

; 5517 :             stbi__get32le(s); // discard color space parameters
; 5518 :          if (hsz == 124) {

	cmp	ebp, 124				; 0000007cH
	jne	SHORT $LN30@stbi__bmp_

; 5519 :             stbi__get32le(s); // discard rendering intent

	mov	rcx, rbx
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5520 :             stbi__get32le(s); // discard offset of profile data

	mov	rcx, rbx
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5521 :             stbi__get32le(s); // discard size of profile data

	mov	rcx, rbx
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5522 :             stbi__get32le(s); // discard reserved

	mov	rcx, rbx
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
$LN30@stbi__bmp_:

; 5523 :          }
; 5524 :       }
; 5525 :    }
; 5526 :    return (void *) 1;

	mov	eax, 1
	jmp	$LN107@stbi__bmp_
$LN72@stbi__bmp_:

; 5482 :          if (hsz == 56) {
; 5483 :             stbi__get32le(s);

	mov	rcx, rbx
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5484 :             stbi__get32le(s);

	mov	rcx, rbx
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5485 :             stbi__get32le(s);

	mov	rcx, rbx
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5486 :             stbi__get32le(s);

	mov	rcx, rbx
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
$LN20@stbi__bmp_:

; 5487 :          }
; 5488 :          if (info->bpp == 16 || info->bpp == 32) {

	mov	eax, DWORD PTR [rsi]
	sub	eax, 16
	test	eax, -17				; ffffffefH
	jne	SHORT $LN30@stbi__bmp_

; 5489 :             if (compress == 0) {

	test	edi, edi
	jne	SHORT $LN23@stbi__bmp_

; 5490 :                stbi__bmp_set_mask_defaults(info, compress);

	xor	edx, edx
	mov	rcx, rsi
	call	?stbi__bmp_set_mask_defaults@@YAHPEAUstbi__bmp_data@@H@Z ; stbi__bmp_set_mask_defaults

; 5523 :          }
; 5524 :       }
; 5525 :    }
; 5526 :    return (void *) 1;

	lea	eax, QWORD PTR [rdi+1]
	jmp	$LN107@stbi__bmp_
$LN23@stbi__bmp_:

; 5491 :             } else if (compress == 3) {

	cmp	edi, 3
	jne	SHORT $LN25@stbi__bmp_

; 5492 :                info->mr = stbi__get32le(s);

	mov	rcx, rbx
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5493 :                info->mg = stbi__get32le(s);

	mov	rcx, rbx
	mov	DWORD PTR [rsi+12], eax
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5494 :                info->mb = stbi__get32le(s);

	mov	rcx, rbx
	mov	DWORD PTR [rsi+16], eax
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5495 :                info->extra_read += 12;

	add	DWORD PTR [rsi+32], 12

; 5496 :                // not documented, but generated by photoshop and handled by mspaint
; 5497 :                if (info->mr == info->mg && info->mg == info->mb) {

	mov	ecx, DWORD PTR [rsi+16]
	mov	DWORD PTR [rsi+20], eax
	cmp	DWORD PTR [rsi+12], ecx
	jne	SHORT $LN30@stbi__bmp_
	cmp	ecx, eax
	jne	$LN30@stbi__bmp_
$LN25@stbi__bmp_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_07IEJCHBDI@bad?5BMP@

; 5498 :                   // ?!?!?
; 5499 :                   return stbi__errpuc("bad BMP", "bad BMP");

	jmp	$LN110@stbi__bmp_
$LN14@stbi__bmp_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_07IMHMNOIB@BMP?5RLE@

; 5473 :       if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");

	jmp	$LN110@stbi__bmp_
$LN6@stbi__bmp_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88

; 5527 : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]

; 978  :    stbi__g_failure_reason = str;

	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_07IANEBNLB@not?5BMP@
	mov	QWORD PTR [rdx+rcx], rax

; 5449 :    int hsz;
; 5450 :    if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");

	xor	eax, eax

; 5527 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z ENDP ; stbi__bmp_parse_header
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
_TEXT	SEGMENT
j$3$ = 32
info$5$ = 32
bshift$1$ = 36
info$2$ = 36
tv3456 = 40
info$4$ = 40
mg$1$ = 44
ma$1$ = 48
ashift$1$ = 52
pad$2$ = 56
tv3454 = 60
tv3455 = 64
$T1 = 72
info$3$ = 80
rshift$1$ = 84
gshift$1$ = 88
mb$1$ = 92
tv3453 = 96
tv3452 = 100
tv3451 = 104
tv3450 = 108
tv3449 = 112
tv3529 = 116
out$1$ = 120
tv3445 = 128
info$ = 136
tv3448 = 176
tv3447 = 184
tv3446 = 192
pal$ = 208
s$ = 1296
x$ = 1304
y$ = 1312
comp$ = 1320
all_a$1$ = 1328
req_comp$dead$ = 1328
j$1$ = 1336
z$1$ = 1336
mr$1$ = 1336
ri$dead$ = 1336
?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__bmp_load, COMDAT

; 5531 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rbx
	push	r12
	push	r13
	lea	rbp, QWORD PTR [rsp-1000]
	sub	rsp, 1256				; 000004e8H

; 5532 :    stbi_uc *out;
; 5533 :    unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
; 5534 :    stbi_uc pal[256][4];
; 5535 :    int psize=0,i,j,width;

	xor	r13d, r13d

; 5536 :    int flip_vertically, pad, target;
; 5537 :    stbi__bmp_data info;
; 5538 :    STBI_NOTUSED(ri);
; 5539 : 
; 5540 :    info.all_a = 255;

	mov	DWORD PTR info$[rbp-228], 255		; 000000ffH

; 5541 :    if (stbi__bmp_parse_header(s, &info) == NULL)

	lea	rdx, QWORD PTR info$[rbp-256]
	mov	r12d, r13d
	mov	rbx, rcx
	call	?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z ; stbi__bmp_parse_header
	test	rax, rax
	je	SHORT $LN447@stbi__bmp_

; 5542 :       return NULL; // error code already set
; 5543 : 
; 5544 :    flip_vertically = ((int) s->img_y) > 0;

	mov	eax, DWORD PTR [rbx+4]
	mov	DWORD PTR tv3529[rsp], eax

; 5545 :    s->img_y = abs((int) s->img_y);

	cdq
	mov	r8d, eax
	xor	r8d, edx
	sub	r8d, edx
	mov	DWORD PTR [rbx+4], r8d

; 5546 : 
; 5547 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

	cmp	r8d, 16777216				; 01000000H
	jbe	SHORT $LN36@stbi__bmp_
$LN448@stbi__bmp_:

; 5731 : }

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
	mov	QWORD PTR [rdx+rcx], rax
$LN447@stbi__bmp_:
	xor	eax, eax
	add	rsp, 1256				; 000004e8H
	pop	r13
	pop	r12
	pop	rbx
	pop	rbp
	ret	0
$LN36@stbi__bmp_:

; 5548 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

	mov	r9d, DWORD PTR [rbx]
	cmp	r9d, 16777216				; 01000000H
	ja	SHORT $LN448@stbi__bmp_

; 5549 : 
; 5550 :    mr = info.mr;

	mov	eax, DWORD PTR info$[rbp-244]

; 5551 :    mg = info.mg;
; 5552 :    mb = info.mb;
; 5553 :    ma = info.ma;

	mov	r10d, DWORD PTR info$[rbp-232]
	mov	DWORD PTR mr$1$[rbp-256], eax
	mov	eax, DWORD PTR info$[rbp-240]
	mov	DWORD PTR mg$1$[rsp], eax
	mov	eax, DWORD PTR info$[rbp-236]
	mov	QWORD PTR [rsp+1248], rdi

; 5554 :    all_a = info.all_a;
; 5555 : 
; 5556 :    if (info.hsz == 12) {

	mov	edi, DWORD PTR info$[rbp-248]
	mov	DWORD PTR mb$1$[rsp], eax
	mov	eax, DWORD PTR info$[rbp-228]
	mov	QWORD PTR [rsp+1240], r14
	mov	r14d, DWORD PTR info$[rbp-252]
	mov	DWORD PTR all_a$1$[rbp-256], eax
	mov	eax, DWORD PTR info$[rbp-224]
	mov	QWORD PTR [rsp+1232], r15
	mov	r15d, DWORD PTR info$[rbp-256]
	mov	DWORD PTR info$5$[rsp], eax
	mov	DWORD PTR ma$1$[rsp], r10d
	mov	DWORD PTR info$4$[rsp], r14d
	mov	DWORD PTR info$2$[rsp], edi
	mov	DWORD PTR info$3$[rsp], r15d
	cmp	edi, 12
	jne	SHORT $LN38@stbi__bmp_

; 5557 :       if (info.bpp < 24)

	cmp	r15d, 24
	jge	SHORT $LN304@stbi__bmp_

; 5558 :          psize = (info.offset - info.extra_read - 24) / 3;

	mov	ecx, r14d
	sub	ecx, eax
	mov	eax, 1431655766				; 55555556H
	sub	ecx, 24
	imul	ecx
	mov	r12d, edx
	shr	r12d, 31
	add	r12d, edx

; 5559 :    } else {

	jmp	SHORT $LN41@stbi__bmp_
$LN38@stbi__bmp_:

; 5560 :       if (info.bpp < 16)

	cmp	r15d, 16
	jge	SHORT $LN304@stbi__bmp_

; 5561 :          psize = (info.offset - info.extra_read - info.hsz) >> 2;

	mov	r12d, r14d
	sub	r12d, eax
	sub	r12d, edi
	sar	r12d, 2
$LN41@stbi__bmp_:

; 5562 :    }
; 5563 :    if (psize == 0) {

	test	r12d, r12d
	jne	SHORT $LN46@stbi__bmp_
$LN304@stbi__bmp_:

; 5564 :       // accept some number of extra bytes after the header, but if the offset points either to before
; 5565 :       // the header ends or implies a large amount of extra data, reject the file as malformed
; 5566 :       int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);

	mov	ecx, DWORD PTR [rbx+192]
	sub	ecx, DWORD PTR [rbx+208]
	add	ecx, DWORD PTR [rbx+184]

; 5567 :       int header_limit = 1024; // max we actually read is below 256 bytes currently.
; 5568 :       int extra_data_limit = 256*4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.
; 5569 :       if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {

	lea	eax, DWORD PTR [rcx-1]
	cmp	eax, 1023				; 000003ffH
	ja	$LN44@stbi__bmp_

; 5571 :       }
; 5572 :       // we established that bytes_read_so_far is positive and sensible.
; 5573 :       // the first half of this test rejects offsets that are either too small positives, or
; 5574 :       // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn
; 5575 :       // ensures the number computed in the second half of the test can't overflow.
; 5576 :       if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {

	cmp	r14d, ecx
	jl	$LN47@stbi__bmp_
	mov	edx, r14d
	sub	edx, ecx
	cmp	edx, 1024				; 00000400H
	jg	$LN47@stbi__bmp_

; 5578 :       } else {
; 5579 :          stbi__skip(s, info.offset - bytes_read_so_far);

	mov	rcx, rbx
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip
	mov	r8d, DWORD PTR [rbx+4]
	mov	r9d, DWORD PTR [rbx]
	mov	r10d, DWORD PTR ma$1$[rsp]
$LN46@stbi__bmp_:

; 5580 :       }
; 5581 :    }
; 5582 : 
; 5583 :    if (info.bpp == 24 && ma == 0xff000000)

	cmp	r15d, 24
	jne	SHORT $LN48@stbi__bmp_
	cmp	r10d, -16777216				; ff000000H
	jne	SHORT $LN48@stbi__bmp_

; 5584 :       s->img_n = 3;

	lea	eax, QWORD PTR [r15-21]
	jmp	SHORT $LN49@stbi__bmp_
$LN48@stbi__bmp_:

; 5585 :    else
; 5586 :       s->img_n = ma ? 4 : 3;

	test	r10d, r10d
	mov	eax, r13d
	setne	al
	add	eax, 3
$LN49@stbi__bmp_:

; 5587 :    if (req_comp && req_comp >= 3) // we can directly decode 3 or 4

	mov	DWORD PTR [rbx+8], eax

; 1014 :    if (a < 0 || b < 0) return 0;

	test	r9d, r9d
	js	$LN314@stbi__bmp_

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	jne	SHORT $LN138@stbi__bmp_
	lea	ecx, DWORD PTR [r9*4]
	jmp	SHORT $LN322@stbi__bmp_
$LN138@stbi__bmp_:

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	r9d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	eax, 4
	jl	$LN314@stbi__bmp_
	lea	ecx, DWORD PTR [r9*4]

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	$LN314@stbi__bmp_
$LN322@stbi__bmp_:
	test	r8d, r8d
	js	$LN314@stbi__bmp_

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN315@stbi__bmp_

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	r8d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	$LN314@stbi__bmp_
$LN315@stbi__bmp_:
	mov	QWORD PTR [rsp+1296], rsi

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	test	r9d, r9d
	je	SHORT $LN442@stbi__bmp_

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	r9d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	eax, 4
	jl	$LN305@stbi__bmp_
$LN442@stbi__bmp_:

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	lea	ecx, DWORD PTR [r9*4]
	test	r8d, r8d
	je	SHORT $LN177@stbi__bmp_

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	r8d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	$LN305@stbi__bmp_
$LN177@stbi__bmp_:

; 1056 :    return stbi__malloc(a*b*c + add);

	imul	r8d, r9d
	shl	r8d, 2
	movsxd	rcx, r8d

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc
	mov	QWORD PTR out$1$[rsp], rax
	mov	rsi, rax

; 5595 : 
; 5596 :    out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
; 5597 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");

	test	rax, rax
	je	$LN305@stbi__bmp_

; 5598 :    if (info.bpp < 16) {

	cmp	r15d, 16
	jge	$LN54@stbi__bmp_

; 5599 :       int z=0;

	mov	DWORD PTR z$1$[rbp-256], r13d
	mov	edi, r13d

; 5600 :       if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }

	test	r12d, r12d
	je	$LN57@stbi__bmp_
	cmp	r12d, 256				; 00000100H
	jg	$LN57@stbi__bmp_

; 5601 :       for (i=0; i < psize; ++i) {

	test	r12d, r12d
	jle	$LN307@stbi__bmp_
	mov	esi, DWORD PTR info$2$[rsp]
	lea	r14, QWORD PTR [rbx+48]
	mov	r15, r13
	movsxd	rdi, r12d
	npad	4
$LL4@stbi__bmp_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN233@stbi__bmp_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN232@stbi__bmp_
$LN233@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	lea	r14, QWORD PTR [rbx+48]
	je	SHORT $LN234@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN232@stbi__bmp_
$LN234@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN232@stbi__bmp_:

; 5602 :          pal[i][2] = stbi__get8(s);

	mov	r13, r14
	mov	BYTE PTR pal$[rbp+r15*4-254], cl

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN229@stbi__bmp_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN228@stbi__bmp_
$LN229@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r14], 0
	je	SHORT $LN230@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN228@stbi__bmp_
$LN230@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN228@stbi__bmp_:

; 5603 :          pal[i][1] = stbi__get8(s);

	mov	BYTE PTR pal$[rbp+r15*4-255], cl

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN225@stbi__bmp_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	lea	r14, QWORD PTR [rbx+48]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN224@stbi__bmp_
$LN225@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r14], 0
	je	SHORT $LN226@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN224@stbi__bmp_
$LN226@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN224@stbi__bmp_:

; 5604 :          pal[i][0] = stbi__get8(s);

	mov	BYTE PTR pal$[rbp+r15*4-256], cl

; 5605 :          if (info.hsz != 12) stbi__get8(s);

	cmp	esi, 12
	je	SHORT $LN240@stbi__bmp_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN239@stbi__bmp_

; 1615 :       return *s->img_buffer++;

	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN240@stbi__bmp_
$LN239@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r13], 0
	je	SHORT $LN240@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	inc	QWORD PTR [rbx+192]
$LN240@stbi__bmp_:

; 5606 :          pal[i][3] = 255;

	mov	BYTE PTR pal$[rbp+r15*4-253], 255	; 000000ffH
	inc	r15
	cmp	r15, rdi
	jl	$LL4@stbi__bmp_
	mov	edi, DWORD PTR z$1$[rbp-256]
	xor	r13d, r13d
	mov	rsi, QWORD PTR out$1$[rsp]
	mov	r14d, DWORD PTR info$4$[rsp]
	mov	r15d, DWORD PTR info$3$[rsp]
$LN307@stbi__bmp_:

; 5607 :       }
; 5608 :       stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));

	cmp	DWORD PTR info$2$[rsp], 12
	mov	eax, r13d
	mov	rcx, rbx
	setne	al
	add	eax, 3
	imul	eax, r12d
	sub	r14d, eax
	sub	r14d, DWORD PTR info$5$[rsp]
	sub	r14d, DWORD PTR info$2$[rsp]
	mov	edx, r14d
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 5609 :       if (info.bpp == 1) width = (s->img_x + 7) >> 3;

	cmp	r15d, 1
	jne	SHORT $LN59@stbi__bmp_
	mov	r12d, DWORD PTR [rbx]
	add	r12d, 7
	shr	r12d, 3
	jmp	SHORT $LN64@stbi__bmp_
$LN59@stbi__bmp_:

; 5610 :       else if (info.bpp == 4) width = (s->img_x + 1) >> 1;

	cmp	r15d, 4
	jne	SHORT $LN61@stbi__bmp_
	mov	r12d, DWORD PTR [rbx]
	inc	r12d
	shr	r12d, 1
	jmp	SHORT $LN64@stbi__bmp_
$LN61@stbi__bmp_:

; 5611 :       else if (info.bpp == 8) width = s->img_x;

	cmp	r15d, 8
	jne	$LN63@stbi__bmp_
	mov	r12d, DWORD PTR [rbx]
$LN64@stbi__bmp_:

; 5613 :       pad = (-width)&3;

	mov	eax, DWORD PTR [rbx+4]
	neg	r12d
	and	r12d, 3

; 5614 :       if (info.bpp == 1) {

	mov	edx, eax
	cmp	r15d, 1
	jne	$LN65@stbi__bmp_

; 5615 :          for (j=0; j < (int) s->img_y; ++j) {

	mov	DWORD PTR j$1$[rbp-256], r13d
	test	eax, eax
	jle	$LN306@stbi__bmp_
	mov	rdi, r13
	npad	8
$LL7@stbi__bmp_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]

; 5616 :             int bit_offset = 7, v = stbi__get8(s);

	mov	r14d, 7

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN217@stbi__bmp_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN443@stbi__bmp_
$LN217@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN218@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN443@stbi__bmp_
$LN218@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN443@stbi__bmp_:

; 5616 :             int bit_offset = 7, v = stbi__get8(s);

	mov	edx, 48					; 00000030H

; 5617 :             for (i=0; i < (int) s->img_x; ++i) {

	xor	r15d, r15d
	mov	rax, rbx
	lea	r13, QWORD PTR [rdx+rbx]
	movzx	edx, cl
	cmp	DWORD PTR [rbx], r15d
	jle	$LN324@stbi__bmp_
$LL10@stbi__bmp_:

; 5618 :                int color = (v>>bit_offset)&0x1;

	mov	eax, edx
	mov	ecx, r14d
	sar	eax, cl
	and	eax, 1

; 5619 :                out[z++] = pal[color][0];

	lea	rcx, QWORD PTR [rax*4]
	movzx	eax, BYTE PTR pal$[rbp+rcx-256]
	mov	BYTE PTR [rdi+rsi], al

; 5620 :                out[z++] = pal[color][1];

	movzx	eax, BYTE PTR pal$[rbp+rcx-255]
	mov	BYTE PTR [rdi+rsi+1], al

; 5621 :                out[z++] = pal[color][2];

	movzx	eax, BYTE PTR pal$[rbp+rcx-254]
	mov	BYTE PTR [rdi+rsi+2], al

; 5622 :                if (target == 4) out[z++] = 255;
; 5623 :                if (i+1 == (int) s->img_x) break;

	lea	eax, DWORD PTR [r15+1]
	mov	BYTE PTR [rdi+rsi+3], 255		; 000000ffH
	mov	r15d, eax
	mov	ecx, DWORD PTR [rbx]
	add	rdi, 4
	cmp	eax, ecx
	je	SHORT $LN324@stbi__bmp_

; 5624 :                if((--bit_offset) < 0) {

	sub	r14d, 1
	jns	SHORT $LN292@stbi__bmp_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]

; 5625 :                   bit_offset = 7;

	mov	r14d, 7

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN203@stbi__bmp_

; 1615 :       return *s->img_buffer++;

	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN202@stbi__bmp_
$LN203@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r13], 0
	je	SHORT $LN204@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	mov	ecx, DWORD PTR [rbx]
	jmp	SHORT $LN202@stbi__bmp_
$LN204@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

	xor	dl, dl
$LN202@stbi__bmp_:

; 5626 :                   v = stbi__get8(s);

	movzx	edx, dl
$LN292@stbi__bmp_:

; 5617 :             for (i=0; i < (int) s->img_x; ++i) {

	cmp	r15d, ecx
	jl	$LL10@stbi__bmp_
$LN324@stbi__bmp_:

; 1644 :    if (n == 0) return;  // already there!

	test	r12d, r12d
	je	SHORT $LN5@stbi__bmp_

; 1645 :    if (n < 0) {
; 1646 :       s->img_buffer = s->img_buffer_end;
; 1647 :       return;
; 1648 :    }
; 1649 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], 0
	je	SHORT $LN111@stbi__bmp_

; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);

	mov	ecx, DWORD PTR [rbx+200]
	sub	ecx, DWORD PTR [rbx+192]

; 1651 :       if (blen < n) {

	cmp	ecx, r12d
	jge	SHORT $LN111@stbi__bmp_

; 1652 :          s->img_buffer = s->img_buffer_end;

	mov	rax, QWORD PTR [rbx+200]

; 1653 :          (s->io.skip)(s->io_user_data, n - blen);

	mov	edx, r12d
	sub	edx, ecx
	mov	QWORD PTR [rbx+192], rax
	mov	rcx, QWORD PTR [rbx+40]
	call	QWORD PTR [rbx+24]

; 1654 :          return;

	jmp	SHORT $LN5@stbi__bmp_
$LN111@stbi__bmp_:

; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;

	mov	eax, r12d
	add	QWORD PTR [rbx+192], rax
$LN5@stbi__bmp_:

; 5615 :          for (j=0; j < (int) s->img_y; ++j) {

	mov	ecx, DWORD PTR j$1$[rbp-256]
	mov	eax, DWORD PTR [rbx+4]
	inc	ecx
	mov	DWORD PTR j$1$[rbp-256], ecx
	mov	edx, eax
	cmp	ecx, eax
	jl	$LL7@stbi__bmp_

; 5627 :                }
; 5628 :             }
; 5629 :             stbi__skip(s, pad);
; 5630 :          }
; 5631 :       } else {

	jmp	$LN306@stbi__bmp_
$LN65@stbi__bmp_:

; 5632 :          for (j=0; j < (int) s->img_y; ++j) {

	test	eax, eax
	jle	$LN306@stbi__bmp_
$LL13@stbi__bmp_:

; 5633 :             for (i=0; i < (int) s->img_x; i += 2) {

	xor	r14d, r14d
	cmp	DWORD PTR [rbx], r14d
	jle	$LN325@stbi__bmp_
	npad	1
$LL16@stbi__bmp_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN122@stbi__bmp_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN444@stbi__bmp_
$LN122@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN123@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN444@stbi__bmp_
$LN123@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN444@stbi__bmp_:

; 5634 :                int v=stbi__get8(s),v2=0;

	mov	edx, 48					; 00000030H
	xor	r8d, r8d
	mov	rax, rbx
	movzx	eax, cl
	lea	r9, QWORD PTR [rdx+rbx]

; 5635 :                if (info.bpp == 4) {

	cmp	r15d, 4
	jne	SHORT $LN70@stbi__bmp_

; 5636 :                   v2 = v & 15;

	mov	r8d, eax
	and	r8d, 15

; 5637 :                   v >>= 4;

	shr	eax, 4
$LN70@stbi__bmp_:

; 5638 :                }
; 5639 :                out[z++] = pal[v][0];

	movsxd	rcx, edi
	lea	rdx, QWORD PTR [rax*4]
	movzx	eax, BYTE PTR pal$[rbp+rdx-256]
	inc	edi
	mov	BYTE PTR [rcx+rsi], al

; 5640 :                out[z++] = pal[v][1];

	movzx	eax, BYTE PTR pal$[rbp+rdx-255]
	movsxd	rcx, edi
	inc	edi
	mov	BYTE PTR [rcx+rsi], al

; 5641 :                out[z++] = pal[v][2];

	movzx	eax, BYTE PTR pal$[rbp+rdx-254]
	movsxd	rcx, edi
	inc	edi
	mov	BYTE PTR [rcx+rsi], al

; 5642 :                if (target == 4) out[z++] = 255;

	movsxd	rax, edi
	inc	edi
	mov	BYTE PTR [rax+rsi], 255			; 000000ffH

; 5643 :                if (i+1 == (int) s->img_x) break;

	lea	eax, DWORD PTR [r14+1]
	cmp	eax, DWORD PTR [rbx]
	je	$LN325@stbi__bmp_

; 5644 :                v = (info.bpp == 8) ? stbi__get8(s) : v2;

	cmp	r15d, 8
	jne	SHORT $LN97@stbi__bmp_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN199@stbi__bmp_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN198@stbi__bmp_
$LN199@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r9], 0
	je	SHORT $LN200@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN198@stbi__bmp_
$LN200@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN198@stbi__bmp_:

; 5644 :                v = (info.bpp == 8) ? stbi__get8(s) : v2;

	movzx	r8d, cl
$LN97@stbi__bmp_:

; 5645 :                out[z++] = pal[v][0];

	movsxd	rcx, edi
	lea	rdx, QWORD PTR [r8*4]
	movzx	eax, BYTE PTR pal$[rbp+rdx-256]
	inc	edi
	add	r14d, 2
	mov	BYTE PTR [rcx+rsi], al

; 5646 :                out[z++] = pal[v][1];

	movzx	eax, BYTE PTR pal$[rbp+rdx-255]
	movsxd	rcx, edi
	inc	edi
	mov	BYTE PTR [rcx+rsi], al

; 5647 :                out[z++] = pal[v][2];

	movzx	eax, BYTE PTR pal$[rbp+rdx-254]
	movsxd	rcx, edi
	inc	edi
	mov	BYTE PTR [rcx+rsi], al

; 5648 :                if (target == 4) out[z++] = 255;

	movsxd	rax, edi
	inc	edi
	mov	BYTE PTR [rax+rsi], 255			; 000000ffH
	cmp	r14d, DWORD PTR [rbx]
	jl	$LL16@stbi__bmp_
$LN325@stbi__bmp_:

; 1644 :    if (n == 0) return;  // already there!

	test	r12d, r12d
	je	SHORT $LN11@stbi__bmp_

; 1645 :    if (n < 0) {
; 1646 :       s->img_buffer = s->img_buffer_end;
; 1647 :       return;
; 1648 :    }
; 1649 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], 0
	je	SHORT $LN308@stbi__bmp_

; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);

	mov	ecx, DWORD PTR [rbx+200]
	sub	ecx, DWORD PTR [rbx+192]

; 1651 :       if (blen < n) {

	cmp	ecx, r12d
	jge	SHORT $LN308@stbi__bmp_

; 1652 :          s->img_buffer = s->img_buffer_end;

	mov	rax, QWORD PTR [rbx+200]

; 1653 :          (s->io.skip)(s->io_user_data, n - blen);

	mov	edx, r12d
	sub	edx, ecx
	mov	QWORD PTR [rbx+192], rax
	mov	rcx, QWORD PTR [rbx+40]
	call	QWORD PTR [rbx+24]

; 1654 :          return;

	jmp	SHORT $LN11@stbi__bmp_
$LN308@stbi__bmp_:

; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;

	mov	eax, r12d
	add	QWORD PTR [rbx+192], rax
$LN11@stbi__bmp_:

; 5632 :          for (j=0; j < (int) s->img_y; ++j) {

	mov	eax, DWORD PTR [rbx+4]
	inc	r13d
	mov	edx, eax
	cmp	r13d, eax
	jl	$LL13@stbi__bmp_

; 5649 :             }
; 5650 :             stbi__skip(s, pad);
; 5651 :          }
; 5652 :       }
; 5653 :    } else {

	jmp	$LN306@stbi__bmp_
$LN63@stbi__bmp_:

; 5612 :       else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }

	mov	rcx, rsi
	call	QWORD PTR __imp_free

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_07JNJHIMGH@bad?5bpp@
$LN446@stbi__bmp_:
	mov	QWORD PTR [rdx+rcx], rax

; 5667 :       }
; 5668 :       if (!easy) {
; 5669 :          if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }

	xor	eax, eax
$LN441@stbi__bmp_:
	mov	rsi, QWORD PTR [rsp+1296]
$LN440@stbi__bmp_:
	mov	rdi, QWORD PTR [rsp+1248]
	mov	r14, QWORD PTR [rsp+1240]
	mov	r15, QWORD PTR [rsp+1232]

; 5731 : }

	add	rsp, 1256				; 000004e8H
	pop	r13
	pop	r12
	pop	rbx
	pop	rbp
	ret	0
$LN57@stbi__bmp_:

; 5600 :       if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }

	mov	rcx, rsi
	call	QWORD PTR __imp_free

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_07MALOAKCI@invalid@

; 5600 :       if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }

	jmp	SHORT $LN446@stbi__bmp_
$LN54@stbi__bmp_:

; 5654 :       int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
; 5655 :       int z = 0;
; 5656 :       int easy=0;
; 5657 :       stbi__skip(s, info.offset - info.extra_read - info.hsz);

	sub	r14d, DWORD PTR info$5$[rsp]
	mov	rcx, rbx
	sub	r14d, edi
	mov	DWORD PTR rshift$1$[rsp], r13d
	mov	edx, r14d
	mov	DWORD PTR gshift$1$[rsp], r13d
	mov	DWORD PTR bshift$1$[rsp], r13d
	mov	DWORD PTR ashift$1$[rsp], r13d
	mov	r12d, r13d
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 5658 :       if (info.bpp == 24) width = 3 * s->img_x;

	cmp	r15d, 24
	jne	SHORT $LN74@stbi__bmp_
	mov	eax, DWORD PTR [rbx]
	lea	r8d, DWORD PTR [rax+rax*2]
	jmp	SHORT $LN77@stbi__bmp_
$LN74@stbi__bmp_:

; 5659 :       else if (info.bpp == 16) width = 2*s->img_x;

	cmp	r15d, 16
	jne	SHORT $LN76@stbi__bmp_
	mov	r8d, DWORD PTR [rbx]
	add	r8d, r8d
	jmp	SHORT $LN77@stbi__bmp_
$LN76@stbi__bmp_:

; 5660 :       else /* bpp = 32 and pad = 0 */ width=0;

	xor	r8d, r8d
$LN77@stbi__bmp_:

; 5661 :       pad = (-width) & 3;

	neg	r8d
	and	r8d, 3
	mov	DWORD PTR pad$2$[rsp], r8d

; 5662 :       if (info.bpp == 24) {

	cmp	r15d, 24
	jne	SHORT $LN78@stbi__bmp_

; 5663 :          easy = 1;

	mov	edi, 1
$LN445@stbi__bmp_:

; 5676 :       }
; 5677 :       for (j=0; j < (int) s->img_y; ++j) {

	mov	QWORD PTR $T1[rsp], rdi
	mov	r9d, r13d
	mov	r10d, r13d
	mov	r11d, r13d
	mov	r14d, r13d
	jmp	$LN85@stbi__bmp_
$LN78@stbi__bmp_:

; 5664 :       } else if (info.bpp == 32) {

	mov	r9d, DWORD PTR mb$1$[rsp]
	xor	edi, edi
	mov	r10d, DWORD PTR mg$1$[rsp]
	mov	QWORD PTR $T1[rsp], rdi
	cmp	r15d, 32				; 00000020H
	jne	SHORT $LN310@stbi__bmp_

; 5665 :          if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)

	mov	QWORD PTR $T1[rsp], rdi
	cmp	r9d, 255				; 000000ffH
	jne	SHORT $LN310@stbi__bmp_
	mov	QWORD PTR $T1[rsp], rdi
	cmp	r10d, 65280				; 0000ff00H
	jne	SHORT $LN310@stbi__bmp_
	cmp	DWORD PTR mr$1$[rbp-256], 16711680	; 00ff0000H
	mov	QWORD PTR $T1[rsp], rdi
	jne	SHORT $LN310@stbi__bmp_
	mov	r15d, DWORD PTR ma$1$[rsp]
	mov	QWORD PTR $T1[rsp], rdi
	cmp	r15d, -16777216				; ff000000H
	jne	SHORT $LN328@stbi__bmp_

; 5666 :             easy = 2;

	mov	edi, 2
	jmp	SHORT $LN445@stbi__bmp_
$LN310@stbi__bmp_:

; 5667 :       }
; 5668 :       if (!easy) {
; 5669 :          if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }

	mov	r12d, DWORD PTR mr$1$[rbp-256]
	test	r12d, r12d
	je	$LN84@stbi__bmp_
	test	r10d, r10d
	je	$LN84@stbi__bmp_
	test	r9d, r9d
	je	$LN84@stbi__bmp_

; 5665 :          if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)

	mov	r15d, DWORD PTR ma$1$[rsp]
	jmp	SHORT $LN319@stbi__bmp_
$LN328@stbi__bmp_:
	mov	r12d, DWORD PTR mr$1$[rbp-256]
$LN319@stbi__bmp_:

; 5670 :          // right shift amt to put high bit in position #7
; 5671 :          rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);

	mov	ecx, r12d
	call	?stbi__high_bit@@YAHI@Z			; stbi__high_bit
	sub	eax, 7

; 5383 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2

	mov	edx, r12d
	shr	edx, 1
	mov	ecx, r12d
	and	edx, 1431655765				; 55555555H

; 5670 :          // right shift amt to put high bit in position #7
; 5671 :          rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);

	mov	DWORD PTR rshift$1$[rsp], eax

; 5383 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2

	and	ecx, 1431655765				; 55555555H
	add	edx, ecx

; 5384 :    a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4

	mov	ecx, edx
	and	edx, 858993459				; 33333333H
	shr	ecx, 2
	and	ecx, 858993459				; 33333333H
	add	ecx, edx

; 5385 :    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits

	mov	edx, ecx
	shr	edx, 4
	add	edx, ecx

; 5672 :          gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);

	mov	ecx, r10d

; 5385 :    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits

	and	edx, 252645135				; 0f0f0f0fH

; 5386 :    a = (a + (a >> 8)); // max 16 per 8 bits

	mov	eax, edx
	shr	eax, 8
	add	edx, eax

; 5387 :    a = (a + (a >> 16)); // max 32 per 8 bits

	mov	eax, edx
	shr	eax, 16
	add	eax, edx

; 5388 :    return a & 0xff;

	movzx	r11d, al

; 5672 :          gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);

	call	?stbi__high_bit@@YAHI@Z			; stbi__high_bit
	sub	eax, 7

; 5383 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2

	mov	edx, r10d
	shr	edx, 1
	mov	ecx, r10d
	and	edx, 1431655765				; 55555555H

; 5672 :          gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);

	mov	DWORD PTR gshift$1$[rsp], eax

; 5383 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2

	and	ecx, 1431655765				; 55555555H
	add	edx, ecx

; 5384 :    a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4

	mov	ecx, edx
	and	edx, 858993459				; 33333333H
	shr	ecx, 2
	and	ecx, 858993459				; 33333333H
	add	ecx, edx

; 5385 :    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits

	mov	edx, ecx
	shr	edx, 4
	add	edx, ecx

; 5673 :          bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);

	mov	ecx, r9d

; 5385 :    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits

	and	edx, 252645135				; 0f0f0f0fH

; 5386 :    a = (a + (a >> 8)); // max 16 per 8 bits

	mov	eax, edx
	shr	eax, 8
	add	edx, eax

; 5387 :    a = (a + (a >> 16)); // max 32 per 8 bits

	mov	eax, edx
	shr	eax, 16
	add	eax, edx

; 5388 :    return a & 0xff;

	movzx	r10d, al

; 5673 :          bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);

	call	?stbi__high_bit@@YAHI@Z			; stbi__high_bit
	sub	eax, 7

; 5383 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2

	mov	edx, r9d
	shr	edx, 1
	mov	ecx, r9d
	and	edx, 1431655765				; 55555555H

; 5673 :          bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);

	mov	DWORD PTR bshift$1$[rsp], eax

; 5383 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2

	and	ecx, 1431655765				; 55555555H
	add	edx, ecx

; 5384 :    a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4

	mov	ecx, edx
	and	edx, 858993459				; 33333333H
	shr	ecx, 2
	and	ecx, 858993459				; 33333333H
	add	ecx, edx

; 5385 :    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits

	mov	edx, ecx
	shr	edx, 4
	add	edx, ecx

; 5674 :          ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);

	mov	ecx, r15d

; 5385 :    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits

	and	edx, 252645135				; 0f0f0f0fH

; 5386 :    a = (a + (a >> 8)); // max 16 per 8 bits

	mov	eax, edx
	shr	eax, 8
	add	edx, eax

; 5387 :    a = (a + (a >> 16)); // max 32 per 8 bits

	mov	eax, edx
	shr	eax, 16
	add	eax, edx

; 5388 :    return a & 0xff;

	movzx	r9d, al

; 5674 :          ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);

	call	?stbi__high_bit@@YAHI@Z			; stbi__high_bit
	lea	r14d, DWORD PTR [rax-7]

; 5383 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2

	mov	edx, r15d

; 5674 :          ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);

	mov	DWORD PTR ashift$1$[rsp], r14d

; 5383 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2

	shr	edx, 1
	mov	ecx, r15d
	and	edx, 1431655765				; 55555555H
	and	ecx, 1431655765				; 55555555H
	add	edx, ecx

; 5384 :    a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4

	mov	ecx, edx
	and	edx, 858993459				; 33333333H
	shr	ecx, 2
	and	ecx, 858993459				; 33333333H
	add	ecx, edx

; 5385 :    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits

	mov	edx, ecx
	shr	edx, 4
	add	edx, ecx
	and	edx, 252645135				; 0f0f0f0fH

; 5386 :    a = (a + (a >> 8)); // max 16 per 8 bits

	mov	eax, edx
	shr	eax, 8
	add	edx, eax

; 5387 :    a = (a + (a >> 16)); // max 32 per 8 bits

	mov	eax, edx
	shr	eax, 16
	add	eax, edx

; 5388 :    return a & 0xff;

	movzx	r12d, al

; 5675 :          if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }

	cmp	r11d, 8
	ja	$LN84@stbi__bmp_
	cmp	r10d, 8
	ja	$LN84@stbi__bmp_
	cmp	r9d, 8
	ja	$LN84@stbi__bmp_
	cmp	r12d, 8
	ja	$LN84@stbi__bmp_
	mov	r8d, DWORD PTR pad$2$[rsp]
$LN85@stbi__bmp_:

; 5676 :       }
; 5677 :       for (j=0; j < (int) s->img_y; ++j) {

	mov	eax, DWORD PTR [rbx+4]
	xor	r15d, r15d
	mov	DWORD PTR j$3$[rsp], r15d
	mov	edx, eax
	test	eax, eax
	jle	$LN306@stbi__bmp_

; 5405 :       v <<= -shift;

	mov	eax, DWORD PTR rshift$1$[rsp]
	neg	eax

; 5409 :    v >>= (8-bits);

	mov	QWORD PTR tv3445[rbp-256], r12

; 5405 :       v <<= -shift;

	mov	DWORD PTR tv3456[rsp], eax

; 5406 :    else
; 5407 :       v >>= shift;
; 5408 :    STBI_ASSERT(v < 256);
; 5409 :    v >>= (8-bits);

	mov	eax, 8
	mov	ecx, eax
	sub	ecx, r11d
	mov	DWORD PTR tv3455[rsp], ecx

; 5405 :       v <<= -shift;

	mov	ecx, DWORD PTR gshift$1$[rsp]
	neg	ecx
	mov	DWORD PTR tv3454[rsp], ecx

; 5406 :    else
; 5407 :       v >>= shift;
; 5408 :    STBI_ASSERT(v < 256);
; 5409 :    v >>= (8-bits);

	mov	ecx, eax
	sub	ecx, r10d
	mov	DWORD PTR tv3453[rsp], ecx

; 5405 :       v <<= -shift;

	mov	ecx, DWORD PTR bshift$1$[rsp]
	neg	ecx
	mov	DWORD PTR tv3452[rsp], ecx

; 5406 :    else
; 5407 :       v >>= shift;
; 5408 :    STBI_ASSERT(v < 256);
; 5409 :    v >>= (8-bits);

	mov	ecx, eax
	sub	ecx, r9d
	mov	DWORD PTR tv3451[rsp], ecx

; 5405 :       v <<= -shift;

	mov	ecx, r14d
	neg	ecx

; 5406 :    else
; 5407 :       v >>= shift;
; 5408 :    STBI_ASSERT(v < 256);
; 5409 :    v >>= (8-bits);

	sub	eax, r12d
	mov	DWORD PTR tv3450[rsp], ecx
	mov	DWORD PTR tv3449[rsp], eax
	mov	eax, r11d
	mov	QWORD PTR tv3448[rbp-256], rax
	mov	eax, r9d
	mov	ecx, r10d
	mov	QWORD PTR tv3446[rbp-256], rax
	mov	QWORD PTR tv3447[rbp-256], rcx
	npad	5
$LL19@stbi__bmp_:

; 5678 :          if (easy) {

	mov	eax, DWORD PTR [rbx]
	movsxd	rcx, r13d
	test	rdi, rdi
	je	$LN87@stbi__bmp_

; 5679 :             for (i=0; i < (int) s->img_x; ++i) {

	xor	r12d, r12d
	test	eax, eax
	jle	$LN326@stbi__bmp_
	lea	r14, QWORD PTR [rcx+rsi]
	mov	rsi, QWORD PTR $T1[rsp]
	lea	rdi, QWORD PTR [rbx+48]
	npad	10
$LL22@stbi__bmp_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN157@stbi__bmp_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN156@stbi__bmp_
$LN157@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	lea	rdi, QWORD PTR [rbx+48]
	je	SHORT $LN158@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN156@stbi__bmp_
$LN158@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN156@stbi__bmp_:

; 5680 :                unsigned char a;
; 5681 :                out[z+2] = stbi__get8(s);

	mov	BYTE PTR [r14+2], cl
	mov	r15, rdi

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN153@stbi__bmp_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN152@stbi__bmp_
$LN153@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi], 0
	je	SHORT $LN154@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN152@stbi__bmp_
$LN154@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN152@stbi__bmp_:

; 5682 :                out[z+1] = stbi__get8(s);

	mov	BYTE PTR [r14+1], cl

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN149@stbi__bmp_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	lea	rdi, QWORD PTR [rbx+48]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN148@stbi__bmp_
$LN149@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi], 0
	je	SHORT $LN150@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN148@stbi__bmp_
$LN150@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN148@stbi__bmp_:

; 5683 :                out[z+0] = stbi__get8(s);

	mov	BYTE PTR [r14], cl

; 5684 :                z += 3;
; 5685 :                a = (easy == 2 ? stbi__get8(s) : 255);

	cmp	rsi, 2
	jne	SHORT $LN99@stbi__bmp_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN207@stbi__bmp_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN100@stbi__bmp_
$LN207@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r15], 0
	je	SHORT $LN208@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN100@stbi__bmp_
$LN208@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl

; 5684 :                z += 3;
; 5685 :                a = (easy == 2 ? stbi__get8(s) : 255);

	jmp	SHORT $LN100@stbi__bmp_
$LN99@stbi__bmp_:
	mov	cl, 255					; 000000ffH
$LN100@stbi__bmp_:

; 5686 :                all_a |= a;
; 5687 :                if (target == 4) out[z++] = a;

	mov	BYTE PTR [r14+3], cl
	add	r13d, 4
	movzx	eax, cl
	add	r14, 4
	or	DWORD PTR all_a$1$[rbp-256], eax
	inc	r12d
	cmp	r12d, DWORD PTR [rbx]
	jl	$LL22@stbi__bmp_

; 5688 :             }
; 5689 :          } else {

	mov	rsi, QWORD PTR out$1$[rsp]
	mov	rdi, QWORD PTR $T1[rsp]
	mov	r8d, DWORD PTR pad$2$[rsp]
	mov	r12, QWORD PTR tv3445[rbp-256]
$LN327@stbi__bmp_:

; 1644 :    if (n == 0) return;  // already there!

	mov	r15d, DWORD PTR j$3$[rsp]
$LN24@stbi__bmp_:
	test	r8d, r8d
	je	$LN17@stbi__bmp_

; 1645 :    if (n < 0) {
; 1646 :       s->img_buffer = s->img_buffer_end;
; 1647 :       return;
; 1648 :    }
; 1649 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], 0
	je	$LN309@stbi__bmp_

; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);

	mov	ecx, DWORD PTR [rbx+200]
	sub	ecx, DWORD PTR [rbx+192]

; 1651 :       if (blen < n) {

	cmp	ecx, r8d
	jge	$LN309@stbi__bmp_

; 1652 :          s->img_buffer = s->img_buffer_end;

	mov	rax, QWORD PTR [rbx+200]

; 1653 :          (s->io.skip)(s->io_user_data, n - blen);

	mov	edx, r8d
	sub	edx, ecx
	mov	QWORD PTR [rbx+192], rax
	mov	rcx, QWORD PTR [rbx+40]
	call	QWORD PTR [rbx+24]

; 1654 :          return;

	mov	r8d, DWORD PTR pad$2$[rsp]
	jmp	$LN17@stbi__bmp_
$LN87@stbi__bmp_:

; 5690 :             int bpp = info.bpp;
; 5691 :             for (i=0; i < (int) s->img_x; ++i) {

	xor	r15d, r15d
	test	eax, eax
	jle	SHORT $LN327@stbi__bmp_
	lea	r14, QWORD PTR [rcx+rsi]
	mov	esi, DWORD PTR info$3$[rsp]
	lea	rdi, OFFSET FLAT:__ImageBase
	npad	2
$LL25@stbi__bmp_:

; 5692 :                stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));

	mov	rcx, rbx
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	cmp	esi, 16
	jne	SHORT $LN101@stbi__bmp_
	mov	r8d, eax
	jmp	SHORT $LN102@stbi__bmp_
$LN101@stbi__bmp_:

; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;

	mov	rcx, rbx
	mov	edi, eax
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	r8d, eax
	shl	r8d, 16
	add	r8d, edi

; 5692 :                stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));

	lea	rdi, OFFSET FLAT:__ImageBase
$LN102@stbi__bmp_:

; 5411 :    return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];

	mov	r9d, DWORD PTR rshift$1$[rsp]

; 5693 :                unsigned int a;
; 5694 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));

	mov	edx, r8d
	and	edx, DWORD PTR mr$1$[rbp-256]

; 5411 :    return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];

	mov	ecx, r9d
	mov	r11, QWORD PTR tv3448[rbp-256]
	mov	eax, edx
	mov	r10, QWORD PTR tv3447[rbp-256]
	shr	eax, cl
	mov	ecx, DWORD PTR tv3456[rsp]
	shl	edx, cl
	mov	ecx, DWORD PTR tv3455[rsp]
	test	r9d, r9d
	mov	r9d, DWORD PTR gshift$1$[rsp]
	cmovns	edx, eax
	shr	edx, cl
	imul	edx, DWORD PTR ?mul_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA[rdi+r11*4]
	mov	ecx, DWORD PTR ?shift_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA[rdi+r11*4]
	sar	edx, cl
	mov	ecx, r9d

; 5693 :                unsigned int a;
; 5694 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));

	mov	BYTE PTR [r14], dl

; 5695 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));

	mov	edx, r8d
	and	edx, DWORD PTR mg$1$[rsp]

; 5411 :    return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];

	mov	eax, edx
	shr	eax, cl
	mov	ecx, DWORD PTR tv3454[rsp]
	shl	edx, cl
	mov	ecx, DWORD PTR tv3453[rsp]
	test	r9d, r9d
	mov	r9d, DWORD PTR bshift$1$[rsp]
	cmovns	edx, eax
	shr	edx, cl
	imul	edx, DWORD PTR ?mul_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA[rdi+r10*4]
	mov	ecx, DWORD PTR ?shift_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA[rdi+r10*4]
	sar	edx, cl
	mov	ecx, r9d

; 5695 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));

	mov	BYTE PTR [r14+1], dl

; 5696 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));

	mov	edx, r8d
	and	edx, DWORD PTR mb$1$[rsp]

; 5411 :    return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];

	mov	eax, edx
	shr	eax, cl
	mov	ecx, DWORD PTR tv3452[rsp]
	shl	edx, cl
	mov	ecx, DWORD PTR tv3451[rsp]
	test	r9d, r9d
	mov	r9, QWORD PTR tv3446[rbp-256]
	cmovns	edx, eax

; 5697 :                a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);

	mov	eax, DWORD PTR ma$1$[rsp]

; 5409 :    v >>= (8-bits);

	shr	edx, cl

; 5410 :    STBI_ASSERT(bits >= 0 && bits <= 8);
; 5411 :    return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];

	imul	edx, DWORD PTR ?mul_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA[rdi+r9*4]
	mov	ecx, DWORD PTR ?shift_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA[rdi+r9*4]
	sar	edx, cl

; 5696 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));

	mov	BYTE PTR [r14+2], dl

; 5697 :                a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);

	test	eax, eax
	je	SHORT $LN103@stbi__bmp_

; 5411 :    return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];

	mov	edx, DWORD PTR ashift$1$[rsp]

; 5697 :                a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);

	and	r8d, eax

; 5411 :    return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];

	mov	eax, r8d
	mov	ecx, edx
	shr	eax, cl
	mov	ecx, DWORD PTR tv3450[rsp]
	shl	r8d, cl
	mov	ecx, DWORD PTR tv3449[rsp]
	test	edx, edx
	cmovns	r8d, eax
	shr	r8d, cl
	imul	r8d, DWORD PTR ?mul_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA[rdi+r12*4]
	mov	ecx, DWORD PTR ?shift_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA[rdi+r12*4]
	sar	r8d, cl

; 5697 :                a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);

	jmp	SHORT $LN104@stbi__bmp_
$LN103@stbi__bmp_:
	mov	r8d, 255				; 000000ffH
$LN104@stbi__bmp_:

; 5698 :                all_a |= a;

	or	DWORD PTR all_a$1$[rbp-256], r8d

; 5699 :                if (target == 4) out[z++] = STBI__BYTECAST(a);

	add	r13d, 4
	mov	BYTE PTR [r14+3], r8b
	inc	r15d
	add	r14, 4
	cmp	r15d, DWORD PTR [rbx]
	jl	$LL25@stbi__bmp_

; 5679 :             for (i=0; i < (int) s->img_x; ++i) {

	mov	rsi, QWORD PTR out$1$[rsp]
	mov	rdi, QWORD PTR $T1[rsp]
	mov	r8d, DWORD PTR pad$2$[rsp]
	jmp	$LN327@stbi__bmp_
$LN326@stbi__bmp_:
	mov	r12, QWORD PTR tv3445[rbp-256]
	jmp	$LN24@stbi__bmp_
$LN309@stbi__bmp_:

; 1657 :    s->img_buffer += n;

	mov	eax, r8d
	add	QWORD PTR [rbx+192], rax
$LN17@stbi__bmp_:

; 5676 :       }
; 5677 :       for (j=0; j < (int) s->img_y; ++j) {

	mov	eax, DWORD PTR [rbx+4]
	inc	r15d
	mov	DWORD PTR j$3$[rsp], r15d
	mov	edx, eax
	cmp	r15d, eax
	jl	$LL19@stbi__bmp_
$LN306@stbi__bmp_:

; 5700 :             }
; 5701 :          }
; 5702 :          stbi__skip(s, pad);
; 5703 :       }
; 5704 :    }
; 5705 : 
; 5706 :    // if alpha channel is all 0s, replace with all 255s
; 5707 :    if (target == 4 && all_a == 0)

	cmp	DWORD PTR all_a$1$[rbp-256], 0
	jne	SHORT $LN27@stbi__bmp_

; 5708 :       for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)

	imul	eax, DWORD PTR [rbx]
	lea	eax, DWORD PTR [rax*4-1]
	movsxd	rcx, eax
	test	eax, eax
	js	SHORT $LN27@stbi__bmp_
	npad	6
$LL28@stbi__bmp_:

; 5709 :          out[i] = 255;

	mov	BYTE PTR [rcx+rsi], 255			; 000000ffH
	sub	rcx, 4
	jns	SHORT $LL28@stbi__bmp_
	mov	edx, DWORD PTR [rbx+4]
$LN27@stbi__bmp_:

; 5710 : 
; 5711 :    if (flip_vertically) {

	cmp	DWORD PTR tv3529[rsp], 0
	jle	SHORT $LN30@stbi__bmp_

; 5712 :       stbi_uc t;
; 5713 :       for (j=0; j < (int) s->img_y>>1; ++j) {

	xor	r10d, r10d
	test	edx, -2
	jle	SHORT $LN30@stbi__bmp_
	npad	1
$LL31@stbi__bmp_:

; 5714 :          stbi_uc *p1 = out +      j     *s->img_x*target;

	mov	ecx, DWORD PTR [rbx]

; 5715 :          stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;

	sub	edx, r10d
	dec	edx
	mov	r9d, ecx
	imul	edx, ecx

; 5716 :          for (i=0; i < (int) s->img_x*target; ++i) {

	xor	r8d, r8d
	imul	r9d, r10d
	lea	eax, DWORD PTR [rcx*4]
	shl	edx, 2
	mov	r11d, edx
	add	rdx, rsi
	shl	r9d, 2
	test	eax, eax
	jle	SHORT $LN29@stbi__bmp_

; 5714 :          stbi_uc *p1 = out +      j     *s->img_x*target;

	sub	r9, r11
	npad	1
$LL34@stbi__bmp_:

; 5717 :             t = p1[i]; p1[i] = p2[i]; p2[i] = t;

	movzx	eax, BYTE PTR [rdx]
	inc	r8d
	movzx	ecx, BYTE PTR [rdx+r9]
	mov	BYTE PTR [rdx+r9], al
	mov	BYTE PTR [rdx], cl
	lea	rdx, QWORD PTR [rdx+1]
	mov	eax, DWORD PTR [rbx]
	shl	eax, 2
	cmp	r8d, eax
	jl	SHORT $LL34@stbi__bmp_
$LN29@stbi__bmp_:

; 5712 :       stbi_uc t;
; 5713 :       for (j=0; j < (int) s->img_y>>1; ++j) {

	mov	edx, DWORD PTR [rbx+4]
	inc	r10d
	mov	eax, edx
	sar	eax, 1
	cmp	r10d, eax
	jl	SHORT $LL31@stbi__bmp_
$LN30@stbi__bmp_:

; 5718 :          }
; 5719 :       }
; 5720 :    }
; 5721 : 
; 5722 :    if (req_comp && req_comp != target) {
; 5723 :       out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
; 5724 :       if (out == NULL) return out; // stbi__convert_format frees input on failure
; 5725 :    }
; 5726 : 
; 5727 :    *x = s->img_x;

	mov	eax, DWORD PTR [rbx]
	mov	rcx, QWORD PTR x$[rbp-256]
	mov	DWORD PTR [rcx], eax

; 5728 :    *y = s->img_y;

	mov	rcx, QWORD PTR y$[rbp-256]
	mov	eax, DWORD PTR [rbx+4]
	mov	DWORD PTR [rcx], eax

; 5729 :    if (comp) *comp = s->img_n;

	mov	rcx, QWORD PTR comp$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN95@stbi__bmp_
	mov	eax, DWORD PTR [rbx+8]
	mov	DWORD PTR [rcx], eax
$LN95@stbi__bmp_:

; 5730 :    return out;

	mov	rax, rsi
	jmp	$LN441@stbi__bmp_
$LN84@stbi__bmp_:

; 5667 :       }
; 5668 :       if (!easy) {
; 5669 :          if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }

	mov	rcx, rsi
	call	QWORD PTR __imp_free

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_09DAEBACAB@bad?5masks@

; 5667 :       }
; 5668 :       if (!easy) {
; 5669 :          if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }

	jmp	$LN446@stbi__bmp_
$LN305@stbi__bmp_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@

; 5595 : 
; 5596 :    out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
; 5597 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");

	jmp	$LN446@stbi__bmp_
$LN314@stbi__bmp_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
	mov	QWORD PTR [rdx+rcx], rax

; 5588 :       target = req_comp;
; 5589 :    else
; 5590 :       target = s->img_n; // if they want monochrome, we'll post-convert
; 5591 : 
; 5592 :    // sanity-check size
; 5593 :    if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
; 5594 :       return stbi__errpuc("too large", "Corrupt BMP");

	xor	eax, eax
	jmp	$LN440@stbi__bmp_
$LN47@stbi__bmp_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0L@JDPIFELH@bad?5offset@
	mov	QWORD PTR [rdx+rcx], rax

; 5577 :          return stbi__errpuc("bad offset", "Corrupt BMP");

	xor	eax, eax
	jmp	$LN440@stbi__bmp_
$LN44@stbi__bmp_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0L@PJHPAMCH@bad?5header@
	mov	QWORD PTR [rdx+rcx], rax

; 5570 :          return stbi__errpuc("bad header", "Corrupt BMP");

	xor	eax, eax
	jmp	$LN440@stbi__bmp_
?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__bmp_load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__tga_get_comp@@YAHHHPEAH@Z
_TEXT	SEGMENT
bits_per_pixel$ = 8
is_grey$ = 16
is_rgb16$ = 24
?stbi__tga_get_comp@@YAHHHPEAH@Z PROC			; stbi__tga_get_comp, COMDAT

; 5740 :    // only RGB or RGBA (incl. 16bit) or grey allowed
; 5741 :    if (is_rgb16) *is_rgb16 = 0;

	test	r8, r8
	je	SHORT $LN4@stbi__tga_
	mov	DWORD PTR [r8], 0
$LN4@stbi__tga_:

; 5742 :    switch(bits_per_pixel) {

	mov	r9d, ecx
	sub	r9d, 8
	je	SHORT $LN5@stbi__tga_
	sub	r9d, 7
	je	SHORT $LN7@stbi__tga_
	sub	r9d, 1
	je	SHORT $LN6@stbi__tga_
	sub	r9d, 8
	je	SHORT $LN10@stbi__tga_
	cmp	r9d, 8
	je	SHORT $LN10@stbi__tga_

; 5750 :       default: return 0;

	xor	eax, eax

; 5751 :    }
; 5752 : }

	ret	0
$LN10@stbi__tga_:

; 5748 :       case 24: // fallthrough
; 5749 :       case 32: return bits_per_pixel/8;

	mov	eax, ecx
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3

; 5751 :    }
; 5752 : }

	ret	0
$LN6@stbi__tga_:

; 5744 :       case 16: if(is_grey) return STBI_grey_alpha;

	test	edx, edx
	je	SHORT $LN7@stbi__tga_
	mov	eax, 2

; 5751 :    }
; 5752 : }

	ret	0
$LN7@stbi__tga_:

; 5745 :                // fallthrough
; 5746 :       case 15: if(is_rgb16) *is_rgb16 = 1;

	test	r8, r8
	je	SHORT $LN9@stbi__tga_
	mov	DWORD PTR [r8], 1
$LN9@stbi__tga_:

; 5747 :                return STBI_rgb;

	mov	eax, 3

; 5751 :    }
; 5752 : }

	ret	0
$LN5@stbi__tga_:

; 5743 :       case 8:  return STBI_grey;

	mov	eax, 1

; 5751 :    }
; 5752 : }

	ret	0
?stbi__tga_get_comp@@YAHHHPEAH@Z ENDP			; stbi__tga_get_comp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__tga_test@@YAHPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 64
?stbi__tga_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__tga_test, COMDAT

; 5820 : {

	push	rbx
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 5821 :    int res = 0;

	xor	r14d, r14d

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rcx, QWORD PTR [rcx+192]
	cmp	rcx, QWORD PTR [rbx+200]
	jae	SHORT $LN22@stbi__tga_

; 1615 :       return *s->img_buffer++;

	inc	rcx
	mov	QWORD PTR [rbx+192], rcx
	jmp	SHORT $LN23@stbi__tga_
$LN22@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], r14d
	je	SHORT $LN23@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	inc	QWORD PTR [rbx+192]
	mov	rcx, QWORD PTR [rbx+192]
$LN23@stbi__tga_:
	mov	QWORD PTR [rsp+64], rbp
	mov	QWORD PTR [rsp+72], rsi

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rcx, QWORD PTR [rbx+200]
	jae	SHORT $LN26@stbi__tga_

; 1615 :       return *s->img_buffer++;

	movzx	ebp, BYTE PTR [rcx]
	inc	rcx
	jmp	SHORT $LN99@stbi__tga_
$LN26@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], r14d
	je	SHORT $LN27@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ebp, BYTE PTR [rax]
	lea	rcx, QWORD PTR [rax+1]
$LN99@stbi__tga_:

; 5822 :    int sz, tga_color_type;
; 5823 :    stbi__get8(s);      //   discard Offset
; 5824 :    tga_color_type = stbi__get8(s);   //   color type

	mov	QWORD PTR [rbx+192], rcx
	movzx	esi, bpl

; 5825 :    if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed

	cmp	bpl, 1
	ja	$errorEnd$103
	jmp	SHORT $LN62@stbi__tga_
$LN27@stbi__tga_:

; 1620 :    return 0;

	xor	bpl, bpl
	movzx	esi, bpl
$LN62@stbi__tga_:
	mov	QWORD PTR [rsp+80], r15

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rcx, QWORD PTR [rbx+200]
	jae	SHORT $LN30@stbi__tga_

; 1615 :       return *s->img_buffer++;

	movzx	edx, BYTE PTR [rcx]
	inc	rcx
	jmp	SHORT $LN29@stbi__tga_
$LN30@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], r14d
	je	SHORT $LN31@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edx, BYTE PTR [rax]
	lea	rcx, QWORD PTR [rax+1]
	jmp	SHORT $LN29@stbi__tga_
$LN31@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

	xor	dl, dl
$LN29@stbi__tga_:

; 5826 :    sz = stbi__get8(s);   //   image type
; 5827 :    if ( tga_color_type == 1 ) { // colormapped (paletted) image

	mov	r15d, 16875776				; 01018100H
	cmp	sil, 1
	jne	$LN4@stbi__tga_

; 5828 :       if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9

	dec	dl
	test	dl, 247					; 000000f7H
	jne	$LN98@stbi__tga_

; 1649 :    if (s->io.read) {

	mov	esi, 4
	cmp	QWORD PTR [rbx+16], r14
	je	SHORT $LN37@stbi__tga_

; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);

	mov	r8d, DWORD PTR [rbx+200]
	sub	r8d, ecx

; 1651 :       if (blen < n) {

	cmp	r8d, esi
	jge	SHORT $LN37@stbi__tga_

; 1652 :          s->img_buffer = s->img_buffer_end;

	mov	rax, QWORD PTR [rbx+200]

; 1653 :          (s->io.skip)(s->io_user_data, n - blen);

	mov	edx, esi
	mov	rcx, QWORD PTR [rbx+40]
	sub	edx, r8d
	mov	QWORD PTR [rbx+192], rax
	call	QWORD PTR [rbx+24]

; 1654 :          return;

	jmp	SHORT $LN33@stbi__tga_
$LN37@stbi__tga_:

; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;

	lea	rax, QWORD PTR [rcx+4]
	mov	QWORD PTR [rbx+192], rax
$LN33@stbi__tga_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN40@stbi__tga_

; 1615 :       return *s->img_buffer++;

	lea	r8, QWORD PTR [rax+1]
	mov	rdx, r8
	jmp	SHORT $LN100@stbi__tga_
$LN40@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], r14d
	je	$LN98@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	lea	rdx, QWORD PTR [rax+1]
	mov	r8d, edx
$LN100@stbi__tga_:

; 5829 :       stbi__skip(s,4);       // skip index of first colormap entry and number of entries
; 5830 :       sz = stbi__get8(s);    //   check bits per palette color entry
; 5831 :       if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

	movzx	ecx, BYTE PTR [rax]
	cmp	cl, 24
	ja	SHORT $LN67@stbi__tga_
	movzx	eax, cl
	bt	r15d, eax
	jb	SHORT $LN8@stbi__tga_
$LN67@stbi__tga_:
	cmp	cl, 32					; 00000020H
	jne	$LN98@stbi__tga_
$LN8@stbi__tga_:

; 1649 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], r14
	je	SHORT $LN47@stbi__tga_

; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);

	mov	ecx, DWORD PTR [rbx+200]
	sub	ecx, r8d

; 1651 :       if (blen < n) {

	cmp	ecx, esi
	jge	SHORT $LN47@stbi__tga_

; 1652 :          s->img_buffer = s->img_buffer_end;

	mov	rax, QWORD PTR [rbx+200]

; 1653 :          (s->io.skip)(s->io_user_data, n - blen);

	sub	esi, ecx
	mov	rcx, QWORD PTR [rbx+40]
	mov	edx, esi
	mov	QWORD PTR [rbx+192], rax
	call	QWORD PTR [rbx+24]

; 1654 :          return;

	jmp	SHORT $LN49@stbi__tga_
$LN47@stbi__tga_:

; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;

	lea	rax, QWORD PTR [rdx+4]

; 5832 :       stbi__skip(s,4);       // skip image x and y origin
; 5833 :    } else { // "normal" image w/o colormap

	jmp	SHORT $LN101@stbi__tga_
$LN4@stbi__tga_:

; 5834 :       if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE

	lea	eax, DWORD PTR [rdx-2]
	test	al, 246					; 000000f6H
	jne	SHORT $LN69@stbi__tga_
	cmp	dl, 11
	jne	SHORT $LN10@stbi__tga_
$LN69@stbi__tga_:
	cmp	dl, 11
	jne	$LN98@stbi__tga_
$LN10@stbi__tga_:

; 1649 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], r14
	je	SHORT $LN53@stbi__tga_

; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);

	mov	r8d, DWORD PTR [rbx+200]
	sub	r8d, ecx

; 1651 :       if (blen < n) {

	cmp	r8d, 9
	jge	SHORT $LN53@stbi__tga_

; 1652 :          s->img_buffer = s->img_buffer_end;

	mov	rax, QWORD PTR [rbx+200]

; 1653 :          (s->io.skip)(s->io_user_data, n - blen);

	mov	edx, 9
	mov	rcx, QWORD PTR [rbx+40]
	sub	edx, r8d
	mov	QWORD PTR [rbx+192], rax
	call	QWORD PTR [rbx+24]

; 1654 :          return;

	jmp	SHORT $LN49@stbi__tga_
$LN53@stbi__tga_:

; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;

	lea	rax, QWORD PTR [rcx+9]
$LN101@stbi__tga_:

; 5835 :       stbi__skip(s,9); // skip colormap specification and image x/y origin
; 5836 :    }
; 5837 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width

	mov	QWORD PTR [rbx+192], rax
$LN49@stbi__tga_:
	mov	rcx, rbx
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	cmp	eax, 1
	jl	SHORT $LN98@stbi__tga_

; 5838 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height

	mov	rcx, rbx
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	cmp	eax, 1
	jl	SHORT $LN98@stbi__tga_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rcx, QWORD PTR [rbx+192]
	cmp	rcx, QWORD PTR [rbx+200]
	jae	SHORT $LN56@stbi__tga_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rcx]
	jmp	SHORT $LN55@stbi__tga_
$LN56@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], r14d
	je	SHORT $LN57@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	jmp	SHORT $LN55@stbi__tga_
$LN57@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN55@stbi__tga_:

; 5839 :    sz = stbi__get8(s);   //   bits per pixel
; 5840 :    if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index

	cmp	bpl, 1
	jne	SHORT $LN16@stbi__tga_
	cmp	cl, 8
	je	SHORT $LN18@stbi__tga_
	cmp	cl, 16
	jne	SHORT $LN98@stbi__tga_
$LN16@stbi__tga_:

; 5841 :    if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

	cmp	cl, 24
	ja	SHORT $LN71@stbi__tga_
	movzx	eax, cl
	bt	r15d, eax
	jb	SHORT $LN18@stbi__tga_
$LN71@stbi__tga_:
	cmp	cl, 32					; 00000020H
	jne	SHORT $LN98@stbi__tga_
$LN18@stbi__tga_:

; 5842 : 
; 5843 :    res = 1; // if we got this far, everything's good and we can return 1 instead of 0

	mov	r14d, 1
$LN98@stbi__tga_:
	mov	r15, QWORD PTR [rsp+80]
$errorEnd$103:

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	rcx, QWORD PTR [rbx+208]

; 5844 : 
; 5845 : errorEnd:
; 5846 :    stbi__rewind(s);
; 5847 :    return res;

	mov	eax, r14d
	mov	rsi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+64]

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	QWORD PTR [rbx+192], rcx

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	rcx, QWORD PTR [rbx+216]
	mov	QWORD PTR [rbx+200], rcx

; 5848 : }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rbx
	ret	0
?stbi__tga_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__tga_test
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z
_TEXT	SEGMENT
s$ = 48
out$ = 56
?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z PROC ; stbi__tga_read_rgb16, COMDAT

; 5852 : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 5853 :    stbi__uint16 px = (stbi__uint16)stbi__get16le(s);

	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5854 :    stbi__uint16 fiveBitMask = 31;
; 5855 :    // we have 3 channels with 5bits each
; 5856 :    int r = (px >> 10) & fiveBitMask;

	movzx	r8d, ax
	mov	eax, r8d
	shr	eax, 10
	and	eax, 31

; 5857 :    int g = (px >> 5) & fiveBitMask;
; 5858 :    int b = px & fiveBitMask;
; 5859 :    // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
; 5860 :    out[0] = (stbi_uc)((r * 255)/31);

	imul	ecx, eax, 255				; 000000ffH
	mov	eax, -2078209981			; ffffffff84210843H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	mov	eax, r8d
	shr	eax, 5
	and	r8d, 31
	and	eax, 31
	mov	BYTE PTR [rbx], dl

; 5861 :    out[1] = (stbi_uc)((g * 255)/31);

	imul	ecx, eax, 255				; 000000ffH
	mov	eax, -2078209981			; ffffffff84210843H
	imul	ecx

; 5862 :    out[2] = (stbi_uc)((b * 255)/31);

	mov	eax, -2078209981			; ffffffff84210843H
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31
	add	edx, ecx
	imul	ecx, r8d, 255				; 000000ffH
	mov	BYTE PTR [rbx+1], dl
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	mov	BYTE PTR [rbx+2], dl

; 5863 : 
; 5864 :    // some people claim that the most significant bit might be used for alpha
; 5865 :    // (possibly if an alpha-bit is set in the "image descriptor byte")
; 5866 :    // but that only made 16bit test images completely translucent..
; 5867 :    // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
; 5868 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z ENDP ; stbi__tga_read_rgb16
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
_TEXT	SEGMENT
$T1 = 48
tga_comp$4$ = 52
tga_palette_start$1$ = 52
tga_rgb16$4$ = 56
tga_offset$1$ = 56
tga_width$1$ = 60
comp$GSCopy$1$ = 64
tga_data$1$ = 64
tv2840 = 72
$T2 = 76
tga_palette_len$1$ = 80
$T3 = 88
tga_bits_per_pixel$1$ = 92
tga_inverted$1$ = 96
y$GSCopy$1$ = 104
tv2667 = 104
x$GSCopy$1$ = 112
tv2666 = 112
tga_palette$1$ = 120
tv2668 = 128
tv2643 = 128
raw_data$ = 136
__$ArrayPad$ = 144
s$ = 240
x$ = 248
y$ = 256
comp$ = 264
req_comp$dead$ = 272
ri$dead$ = 280
?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__tga_load, COMDAT

; 5871 : {

	push	rbx
	push	rbp
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 176				; 000000b0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rcx+192]

; 5871 : {

	mov	rbx, rcx
	mov	QWORD PTR comp$GSCopy$1$[rsp], r9
	mov	QWORD PTR y$GSCopy$1$[rsp], r8
	mov	QWORD PTR x$GSCopy$1$[rsp], rdx

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rcx+200]
	jae	SHORT $LN67@stbi__tga_

; 1615 :       return *s->img_buffer++;

	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rcx+192], rax
	jmp	SHORT $LN349@stbi__tga_
$LN67@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rcx+48], 0
	je	SHORT $LN68@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN349@stbi__tga_
$LN68@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

	xor	dl, dl
$LN349@stbi__tga_:

; 5872 :    //   read in the TGA header stuff
; 5873 :    int tga_offset = stbi__get8(s);

	mov	ecx, 48					; 00000030H
	mov	r8, rbx
	mov	QWORD PTR [rsp+168], rsi
	lea	r12, QWORD PTR [rcx+rbx]
	movzx	ecx, dl
	mov	DWORD PTR tga_offset$1$[rsp], ecx
	mov	QWORD PTR tv2643[rsp], r12

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN71@stbi__tga_

; 1615 :       return *s->img_buffer++;

	movzx	esi, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN350@stbi__tga_
$LN71@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r12], 0
	je	SHORT $LN72@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	esi, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN350@stbi__tga_
$LN72@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

	xor	sil, sil
$LN350@stbi__tga_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	BYTE PTR $T1[rsp], sil
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN75@stbi__tga_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN74@stbi__tga_
$LN75@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r12], 0
	je	SHORT $LN76@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN74@stbi__tga_
$LN76@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN74@stbi__tga_:

; 5874 :    int tga_indexed = stbi__get8(s);
; 5875 :    int tga_image_type = stbi__get8(s);

	movzx	ebp, cl

; 5876 :    int tga_is_RLE = 0;
; 5877 :    int tga_palette_start = stbi__get16le(s);

	mov	rcx, rbx
	mov	DWORD PTR tv2840[rsp], ebp
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5878 :    int tga_palette_len = stbi__get16le(s);

	mov	rcx, rbx
	mov	DWORD PTR tga_palette_start$1$[rsp], eax
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rcx, QWORD PTR [rbx+192]

; 5878 :    int tga_palette_len = stbi__get16le(s);

	mov	DWORD PTR tga_palette_len$1$[rsp], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rcx, QWORD PTR [rbx+200]
	jae	SHORT $LN79@stbi__tga_

; 1615 :       return *s->img_buffer++;

	movzx	edx, BYTE PTR [rcx]
	inc	rcx
	mov	QWORD PTR [rbx+192], rcx
	jmp	SHORT $LN78@stbi__tga_
$LN79@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r12], 0
	je	SHORT $LN80@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN78@stbi__tga_
$LN80@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

	xor	dl, dl
$LN78@stbi__tga_:

; 5879 :    int tga_palette_bits = stbi__get8(s);
; 5880 :    int tga_x_origin = stbi__get16le(s);

	mov	rcx, rbx
	movzx	edi, dl
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5881 :    int tga_y_origin = stbi__get16le(s);

	mov	rcx, rbx
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5882 :    int tga_width = stbi__get16le(s);

	mov	rcx, rbx
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5883 :    int tga_height = stbi__get16le(s);

	mov	rcx, rbx
	mov	DWORD PTR tga_width$1$[rsp], eax
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	DWORD PTR $T2[rsp], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN83@stbi__tga_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN82@stbi__tga_
$LN83@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r12], 0
	je	SHORT $LN84@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN82@stbi__tga_
$LN84@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN82@stbi__tga_:

; 5884 :    int tga_bits_per_pixel = stbi__get8(s);

	movzx	r10d, cl
	mov	DWORD PTR tga_bits_per_pixel$1$[rsp], r10d

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN87@stbi__tga_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN86@stbi__tga_
$LN87@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r12], 0
	je	SHORT $LN88@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	mov	r10d, DWORD PTR tga_bits_per_pixel$1$[rsp]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN86@stbi__tga_
$LN88@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN86@stbi__tga_:

; 5885 :    int tga_comp, tga_rgb16=0;
; 5886 :    int tga_inverted = stbi__get8(s);
; 5887 :    // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
; 5888 :    //   image data
; 5889 :    unsigned char *tga_data;
; 5890 :    unsigned char *tga_palette = NULL;
; 5891 :    int i, j;
; 5892 :    unsigned char raw_data[4] = {0};
; 5893 :    int RLE_count = 0;
; 5894 :    int RLE_repeating = 0;
; 5895 :    int read_next_pixel = 1;
; 5896 :    STBI_NOTUSED(ri);
; 5897 :    STBI_NOTUSED(tga_x_origin); // @TODO
; 5898 :    STBI_NOTUSED(tga_y_origin); // @TODO
; 5899 : 
; 5900 :    if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

	mov	r8d, DWORD PTR $T2[rsp]
	xor	r15d, r15d
	movzx	eax, cl
	mov	r14d, r15d
	mov	QWORD PTR tga_palette$1$[rsp], r15
	mov	DWORD PTR raw_data$[rsp], r15d
	lea	r13d, QWORD PTR [r15+1]
	cmp	r8d, 16777216				; 01000000H
	jg	$LN257@stbi__tga_

; 5901 :    if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

	mov	r9d, DWORD PTR tga_width$1$[rsp]
	cmp	r9d, 16777216				; 01000000H
	jg	$LN257@stbi__tga_

; 5902 : 
; 5903 :    //   do a tiny bit of precessing
; 5904 :    if ( tga_image_type >= 8 )
; 5905 :    {
; 5906 :       tga_image_type -= 8;
; 5907 :       tga_is_RLE = 1;
; 5908 :    }
; 5909 :    tga_inverted = 1 - ((tga_inverted >> 5) & 1);

	cmp	ebp, 8
	lea	edx, DWORD PTR [rbp-8]
	mov	ecx, r13d
	cmovb	edx, ebp
	shr	eax, 5
	and	eax, r13d

; 5910 : 
; 5911 :    //   If I'm paletted, then I'll use the number of bits from the palette
; 5912 :    if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);

	mov	ebp, r15d
	sub	ecx, eax
	mov	DWORD PTR tga_inverted$1$[rsp], ecx
	test	sil, sil
	je	SHORT $LN32@stbi__tga_

; 5742 :    switch(bits_per_pixel) {

	mov	ecx, edi
	sub	ecx, 8
	je	SHORT $LN98@stbi__tga_
	sub	ecx, 7
	je	SHORT $LN113@stbi__tga_
	sub	ecx, r13d
	je	SHORT $LN113@stbi__tga_
	sub	ecx, 8
	je	SHORT $LN103@stbi__tga_
	cmp	ecx, 8
	jne	SHORT $LN259@stbi__tga_

; 5745 :                // fallthrough
; 5746 :       case 15: if(is_rgb16) *is_rgb16 = 1;
; 5747 :                return STBI_rgb;
; 5748 :       case 24: // fallthrough
; 5749 :       case 32: return bits_per_pixel/8;

	jmp	SHORT $LN103@stbi__tga_
$LN98@stbi__tga_:

; 5743 :       case 8:  return STBI_grey;

	mov	edi, r13d

; 5910 : 
; 5911 :    //   If I'm paletted, then I'll use the number of bits from the palette
; 5912 :    if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);

	jmp	SHORT $LN107@stbi__tga_
$LN32@stbi__tga_:

; 5742 :    switch(bits_per_pixel) {

	mov	ecx, r10d
	sub	ecx, 8
	je	SHORT $LN111@stbi__tga_
	sub	ecx, 7
	je	SHORT $LN113@stbi__tga_
	sub	ecx, r13d
	je	SHORT $LN112@stbi__tga_
	sub	ecx, 8
	je	SHORT $LN116@stbi__tga_
	cmp	ecx, 8
	jne	SHORT $LN259@stbi__tga_
$LN116@stbi__tga_:

; 5745 :                // fallthrough
; 5746 :       case 15: if(is_rgb16) *is_rgb16 = 1;
; 5747 :                return STBI_rgb;
; 5748 :       case 24: // fallthrough
; 5749 :       case 32: return bits_per_pixel/8;

	mov	edi, r10d
$LN103@stbi__tga_:

; 5914 : 
; 5915 :    if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency

	shr	edi, 3
$LN107@stbi__tga_:
	mov	esi, edi
	test	edi, edi
	jne	SHORT $LN34@stbi__tga_
$LN259@stbi__tga_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0L@DMAPJJO@bad?5format@

; 5916 :       return stbi__errpuc("bad format", "Can't find out TGA pixelformat");

	jmp	$LN351@stbi__tga_
$LN112@stbi__tga_:

; 5913 :    else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

	cmp	edx, 3

; 5744 :       case 16: if(is_grey) return STBI_grey_alpha;

	jne	SHORT $LN113@stbi__tga_
	mov	edi, 2
	mov	esi, edi
	jmp	SHORT $LN34@stbi__tga_
$LN113@stbi__tga_:

; 5917 : 
; 5918 :    //   tga info
; 5919 :    *x = tga_width;

	mov	edi, 3
	mov	ebp, r13d
	mov	esi, edi
	jmp	SHORT $LN34@stbi__tga_
$LN111@stbi__tga_:

; 5743 :       case 8:  return STBI_grey;

	mov	edi, r13d
	mov	esi, r13d
$LN34@stbi__tga_:

; 5917 : 
; 5918 :    //   tga info
; 5919 :    *x = tga_width;

	mov	rax, QWORD PTR x$GSCopy$1$[rsp]
	mov	DWORD PTR [rax], r9d

; 5920 :    *y = tga_height;

	mov	rax, QWORD PTR y$GSCopy$1$[rsp]
	mov	DWORD PTR [rax], r8d

; 5921 :    if (comp) *comp = tga_comp;

	mov	rax, QWORD PTR comp$GSCopy$1$[rsp]
	test	rax, rax
	je	SHORT $LN35@stbi__tga_
	mov	DWORD PTR [rax], edi
$LN35@stbi__tga_:

; 1014 :    if (a < 0 || b < 0) return 0;

	test	r9d, r9d
	js	$LN257@stbi__tga_
	test	r8d, r8d
	js	$LN257@stbi__tga_

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN258@stbi__tga_

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	r8d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	r9d, eax
	jg	$LN257@stbi__tga_
$LN258@stbi__tga_:
	mov	ecx, r8d
	imul	ecx, r9d

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	$LN257@stbi__tga_

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx
	mov	eax, 2147483647				; 7fffffffH
	div	edi

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	$LN257@stbi__tga_

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	test	r8d, r8d
	je	SHORT $LN260@stbi__tga_

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	r8d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	r9d, eax
	jg	$LN250@stbi__tga_
$LN260@stbi__tga_:

; 1056 :    return stbi__malloc(a*b*c + add);

	mov	eax, edi
	imul	eax, r8d
	imul	eax, r9d
	movsxd	rcx, eax

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc
	mov	QWORD PTR tga_data$1$[rsp], rax

; 5922 : 
; 5923 :    if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
; 5924 :       return stbi__errpuc("too large", "Corrupt TGA");
; 5925 : 
; 5926 :    tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
; 5927 :    if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

	test	rax, rax
	je	$LN250@stbi__tga_

; 5928 : 
; 5929 :    // skip to the data's starting position (offset usually = 0)
; 5930 :    stbi__skip(s, tga_offset );

	mov	edx, DWORD PTR tga_offset$1$[rsp]
	mov	rcx, rbx
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 5931 : 
; 5932 :    if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {

	cmp	BYTE PTR $T1[rsp], r14b
	jne	$LN249@stbi__tga_
	mov	edx, DWORD PTR tv2840[rsp]
	mov	DWORD PTR tga_rgb16$4$[rsp], ebp
	mov	DWORD PTR tga_comp$4$[rsp], edi
	cmp	edx, 8
	jae	$LN45@stbi__tga_
	mov	DWORD PTR tga_rgb16$4$[rsp], ebp
	mov	DWORD PTR tga_comp$4$[rsp], edi
	test	ebp, ebp
	jne	$LN45@stbi__tga_

; 5933 :       for (i=0; i < tga_height; ++i) {

	mov	r13d, DWORD PTR $T2[rsp]
	mov	DWORD PTR tga_rgb16$4$[rsp], ebp
	test	r13d, r13d
	jle	$LN226@stbi__tga_

; 5934 :          int row = tga_inverted ? tga_height -i - 1 : i;

	mov	r15d, edi
	mov	DWORD PTR tga_rgb16$4$[rsp], ebp
	imul	r15d, DWORD PTR tga_width$1$[rsp]
	cmp	DWORD PTR tga_inverted$1$[rsp], r14d
	mov	r14d, r13d
	je	SHORT $LN62@stbi__tga_
	mov	eax, r15d
	neg	eax
	movsxd	r12, eax
	lea	eax, DWORD PTR [r13-1]
	imul	eax, edi
	imul	eax, DWORD PTR tga_width$1$[rsp]
	movsxd	rsi, eax
	add	rsi, QWORD PTR tga_data$1$[rsp]
	npad	2
$LL4@stbi__tga_:

; 5935 :          stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
; 5936 :          stbi__getn(s, tga_row, tga_width * tga_comp);

	mov	r8d, r15d
	mov	rdx, rsi
	mov	rcx, rbx
	call	?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn
	add	rsi, r12
	sub	r14, 1
	jne	SHORT $LL4@stbi__tga_

; 5937 :       }
; 5938 :    } else  {

	mov	edx, DWORD PTR tga_width$1$[rsp]
	mov	ebp, r13d
	imul	ebp, edx
	mov	esi, edi
	jmp	$LN58@stbi__tga_
$LN62@stbi__tga_:

; 5933 :       for (i=0; i < tga_height; ++i) {

	mov	rsi, QWORD PTR tga_data$1$[rsp]
	movsxd	r12, r15d
$LL220@stbi__tga_:

; 5935 :          stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
; 5936 :          stbi__getn(s, tga_row, tga_width * tga_comp);

	mov	r8d, r15d
	mov	rdx, rsi
	mov	rcx, rbx
	call	?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn
	add	rsi, r12
	sub	r14, 1
	jne	SHORT $LL220@stbi__tga_
$LN226@stbi__tga_:

; 5937 :       }
; 5938 :    } else  {

	mov	edx, DWORD PTR tga_width$1$[rsp]
	mov	ebp, r13d
	imul	ebp, edx
	mov	esi, edi
	jmp	$LN58@stbi__tga_
$LN249@stbi__tga_:

; 5939 :       //   do I need to load a palette?
; 5940 :       if ( tga_indexed)
; 5941 :       {
; 5942 :          if (tga_palette_len == 0) {  /* you have to have at least one entry! */

	cmp	DWORD PTR tga_palette_len$1$[rsp], r14d
	jne	SHORT $LN41@stbi__tga_

; 5943 :             STBI_FREE(tga_data);

	mov	rcx, QWORD PTR tga_data$1$[rsp]
$LN352@stbi__tga_:

; 6073 : }

	call	QWORD PTR __imp_free
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0M@ILLOCNCO@bad?5palette@
	jmp	$LN351@stbi__tga_
$LN41@stbi__tga_:

; 5944 :             return stbi__errpuc("bad palette", "Corrupt TGA");
; 5945 :          }
; 5946 : 
; 5947 :          //   any data to skip? (offset usually = 0)
; 5948 :          stbi__skip(s, tga_palette_start );

	mov	edx, DWORD PTR tga_palette_start$1$[rsp]
	mov	rcx, rbx
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 1014 :    if (a < 0 || b < 0) return 0;

	mov	ecx, DWORD PTR tga_palette_len$1$[rsp]
	test	ecx, ecx
	js	$LN251@stbi__tga_

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	xor	edx, edx

; 1024 :    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);

	imul	esi, ecx

; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	div	edi

; 1024 :    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);

	cmp	ecx, eax
	jg	$LN251@stbi__tga_

; 1049 :    return stbi__malloc(a*b + add);

	movsxd	rcx, esi

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc
	mov	QWORD PTR tga_palette$1$[rsp], rax

; 5949 :          //   load the palette
; 5950 :          tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
; 5951 :          if (!tga_palette) {

	test	rax, rax
	je	$LN251@stbi__tga_

; 5953 :             return stbi__errpuc("outofmem", "Out of memory");
; 5954 :          }
; 5955 :          if (tga_rgb16) {

	mov	DWORD PTR tga_rgb16$4$[rsp], ebp
	mov	DWORD PTR tga_comp$4$[rsp], edi
	test	ebp, ebp
	je	$LN43@stbi__tga_

; 5956 :             stbi_uc *pal_entry = tga_palette;

	mov	rsi, rax

; 5957 :             STBI_ASSERT(tga_comp == STBI_rgb);
; 5958 :             for (i=0; i < tga_palette_len; ++i) {

	mov	eax, DWORD PTR tga_palette_len$1$[rsp]
	test	eax, eax
	jle	SHORT $LN271@stbi__tga_

; 5956 :             stbi_uc *pal_entry = tga_palette;

	mov	r12d, edi
	mov	r14d, eax
	npad	10
$LL7@stbi__tga_:

; 5959 :                stbi__tga_read_rgb16(s, pal_entry);

	mov	rdx, rsi
	mov	rcx, rbx
	call	?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z ; stbi__tga_read_rgb16

; 5960 :                pal_entry += tga_comp;

	add	rsi, r12
	sub	r14, r13
	jne	SHORT $LL7@stbi__tga_
	mov	r12, QWORD PTR tv2643[rsp]
	mov	r14d, r15d
$LN271@stbi__tga_:

; 5966 :          }
; 5967 :       }
; 5968 :       //   load the data
; 5969 :       for (i=0; i < tga_width * tga_height; ++i)

	mov	edx, DWORD PTR tv2840[rsp]
$LN45@stbi__tga_:
	mov	ebp, DWORD PTR $T2[rsp]
	mov	eax, DWORD PTR tga_width$1$[rsp]
	imul	ebp, eax

; 6002 :                for (j = 0; j < tga_comp; ++j) {

	mov	esi, edi
	mov	DWORD PTR $T3[rsp], ebp
	test	ebp, ebp
	je	$LN9@stbi__tga_

; 5966 :          }
; 5967 :       }
; 5968 :       //   load the data
; 5969 :       for (i=0; i < tga_width * tga_height; ++i)

	movsxd	rax, edi
	lea	rcx, QWORD PTR raw_data$[rsp]
	mov	QWORD PTR tv2668[rsp], rax
	mov	rax, QWORD PTR tga_data$1$[rsp]
	sub	rax, rcx
	mov	ecx, ebp
	mov	QWORD PTR tv2666[rsp], rcx
	mov	ebp, r15d
	mov	QWORD PTR tv2667[rsp], rax
$LL10@stbi__tga_:

; 5970 :       {
; 5971 :          //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
; 5972 :          if ( tga_is_RLE )

	cmp	edx, 8
	jb	$LN252@stbi__tga_

; 5973 :          {
; 5974 :             if ( RLE_count == 0 )

	test	r14d, r14d
	jne	$LN48@stbi__tga_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN170@stbi__tga_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN169@stbi__tga_
$LN43@stbi__tga_:

; 5961 :             }
; 5962 :          } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {

	mov	r8d, esi
	mov	rdx, rax
	mov	rcx, rbx
	call	?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn
	test	eax, eax
	jne	$LN271@stbi__tga_

; 5963 :                STBI_FREE(tga_data);

	mov	rcx, QWORD PTR tga_data$1$[rsp]
	call	QWORD PTR __imp_free

; 5964 :                STBI_FREE(tga_palette);

	mov	rcx, QWORD PTR tga_palette$1$[rsp]

; 5965 :                return stbi__errpuc("bad palette", "Corrupt TGA");

	jmp	$LN352@stbi__tga_
$LN170@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r12], r15d
	je	SHORT $LN171@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN169@stbi__tga_
$LN171@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN169@stbi__tga_:

; 5975 :             {
; 5976 :                //   yep, get the next byte as a RLE command
; 5977 :                int RLE_cmd = stbi__get8(s);

	movzx	eax, cl

; 5978 :                RLE_count = 1 + (RLE_cmd & 127);

	mov	r14d, eax
	and	r14d, 127				; 0000007fH
	inc	r14d

; 5979 :                RLE_repeating = RLE_cmd >> 7;

	shr	eax, 7

; 5980 :                read_next_pixel = 1;

	mov	ebp, eax
	jmp	SHORT $LN252@stbi__tga_
$LN48@stbi__tga_:

; 5981 :             } else if ( !RLE_repeating )

	test	ebp, ebp
	je	SHORT $LN252@stbi__tga_

; 5982 :             {
; 5983 :                read_next_pixel = 1;
; 5984 :             }
; 5985 :          } else
; 5986 :          {
; 5987 :             read_next_pixel = 1;
; 5988 :          }
; 5989 :          //   OK, if I need to read a pixel, do it now
; 5990 :          if ( read_next_pixel )

	test	r13d, r13d
	je	$LN51@stbi__tga_
$LN252@stbi__tga_:

; 5991 :          {
; 5992 :             //   load however much data we did have
; 5993 :             if ( tga_indexed )

	cmp	BYTE PTR $T1[rsp], r15b
	je	$LN52@stbi__tga_

; 5994 :             {
; 5995 :                // read in index, then perform the lookup
; 5996 :                int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);

	cmp	DWORD PTR tga_bits_per_pixel$1$[rsp], 8
	jne	SHORT $LN64@stbi__tga_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN174@stbi__tga_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax

; 5994 :             {
; 5995 :                // read in index, then perform the lookup
; 5996 :                int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);

	movzx	eax, cl
	jmp	SHORT $LN65@stbi__tga_
$LN174@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r12], r15d
	je	SHORT $LN175@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax

; 5994 :             {
; 5995 :                // read in index, then perform the lookup
; 5996 :                int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);

	movzx	eax, cl
	jmp	SHORT $LN65@stbi__tga_
$LN175@stbi__tga_:

; 1620 :    return 0;

	xor	cl, cl

; 5994 :             {
; 5995 :                // read in index, then perform the lookup
; 5996 :                int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);

	movzx	eax, cl
	jmp	SHORT $LN65@stbi__tga_
$LN64@stbi__tga_:
	mov	rcx, rbx
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
$LN65@stbi__tga_:

; 6002 :                for (j = 0; j < tga_comp; ++j) {

	test	rsi, rsi
	je	$LN15@stbi__tga_

; 5997 :                if ( pal_idx >= tga_palette_len ) {
; 5998 :                   // invalid index
; 5999 :                   pal_idx = 0;
; 6000 :                }
; 6001 :                pal_idx *= tga_comp;

	cmp	eax, DWORD PTR tga_palette_len$1$[rsp]
	mov	ecx, r15d
	mov	r8, rsi
	cmovl	ecx, eax
	imul	ecx, edi
	movsxd	rdx, ecx
	lea	rcx, QWORD PTR raw_data$[rsp]
	add	rdx, QWORD PTR tga_palette$1$[rsp]
	call	memcpy

; 6003 :                   raw_data[j] = tga_palette[pal_idx+j];
; 6004 :                }
; 6005 :             } else if(tga_rgb16) {

	jmp	$LN15@stbi__tga_
$LN52@stbi__tga_:
	cmp	DWORD PTR tga_rgb16$4$[rsp], r15d
	je	$LN55@stbi__tga_

; 5853 :    stbi__uint16 px = (stbi__uint16)stbi__get16le(s);

	mov	rcx, rbx
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5854 :    stbi__uint16 fiveBitMask = 31;
; 5855 :    // we have 3 channels with 5bits each
; 5856 :    int r = (px >> 10) & fiveBitMask;

	movzx	r8d, ax
	mov	eax, r8d
	shr	eax, 10
	and	eax, 31

; 5857 :    int g = (px >> 5) & fiveBitMask;
; 5858 :    int b = px & fiveBitMask;
; 5859 :    // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
; 5860 :    out[0] = (stbi_uc)((r * 255)/31);

	imul	ecx, eax, 255				; 000000ffH
	mov	eax, -2078209981			; ffffffff84210843H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	mov	eax, r8d
	shr	eax, 5
	and	r8d, 31
	and	eax, 31
	mov	BYTE PTR raw_data$[rsp], dl

; 5861 :    out[1] = (stbi_uc)((g * 255)/31);

	imul	ecx, eax, 255				; 000000ffH
	mov	eax, -2078209981			; ffffffff84210843H
	imul	ecx
	add	edx, ecx

; 5862 :    out[2] = (stbi_uc)((b * 255)/31);

	imul	ecx, r8d, 255				; 000000ffH
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	mov	eax, -2078209981			; ffffffff84210843H
	mov	BYTE PTR raw_data$[rsp+1], dl
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	mov	BYTE PTR raw_data$[rsp+2], dl

; 6006 :                STBI_ASSERT(tga_comp == STBI_rgb);
; 6007 :                stbi__tga_read_rgb16(s, raw_data);
; 6008 :             } else {

	jmp	SHORT $LN15@stbi__tga_
$LN55@stbi__tga_:

; 6009 :                //   read in the data raw
; 6010 :                for (j = 0; j < tga_comp; ++j) {

	mov	rdi, r15
	test	rsi, rsi
	je	SHORT $LN15@stbi__tga_
	npad	3
$LL16@stbi__tga_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN140@stbi__tga_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN139@stbi__tga_
$LN140@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r12], r15d
	je	SHORT $LN141@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN139@stbi__tga_
$LN141@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN139@stbi__tga_:

; 6011 :                   raw_data[j] = stbi__get8(s);

	mov	BYTE PTR raw_data$[rsp+rdi], cl
	inc	rdi
	cmp	rdi, rsi
	jl	SHORT $LL16@stbi__tga_
$LN15@stbi__tga_:
	mov	rax, QWORD PTR tv2667[rsp]

; 6012 :                }
; 6013 :             }
; 6014 :             //   clear the reading flag for the next pixel
; 6015 :             read_next_pixel = 0;

	mov	r13d, r15d
	mov	rcx, QWORD PTR tv2666[rsp]
$LN51@stbi__tga_:

; 6016 :          } // end of reading a pixel
; 6017 : 
; 6018 :          // copy data
; 6019 :          for (j = 0; j < tga_comp; ++j)

	mov	rdi, r15
	test	rsi, rsi
	je	SHORT $LN18@stbi__tga_

; 6020 :            tga_data[i*tga_comp+j] = raw_data[j];

	lea	rcx, QWORD PTR raw_data$[rsp]
	mov	r8, rsi
	add	rcx, rax
	lea	rdx, QWORD PTR raw_data$[rsp]
	call	memcpy
$LL223@stbi__tga_:

; 6016 :          } // end of reading a pixel
; 6017 : 
; 6018 :          // copy data
; 6019 :          for (j = 0; j < tga_comp; ++j)

	inc	rdi
	cmp	rdi, rsi
	jl	SHORT $LL223@stbi__tga_
	mov	rax, QWORD PTR tv2667[rsp]
	mov	rcx, QWORD PTR tv2666[rsp]
$LN18@stbi__tga_:

; 5966 :          }
; 5967 :       }
; 5968 :       //   load the data
; 5969 :       for (i=0; i < tga_width * tga_height; ++i)

	add	rax, QWORD PTR tv2668[rsp]

; 6021 : 
; 6022 :          //   in case we're in RLE mode, keep counting down
; 6023 :          --RLE_count;

	dec	r14d
	mov	edi, DWORD PTR tga_comp$4$[rsp]
	sub	rcx, 1
	mov	edx, DWORD PTR tv2840[rsp]
	mov	QWORD PTR tv2666[rsp], rcx
	mov	QWORD PTR tv2667[rsp], rax
	jne	$LL10@stbi__tga_
	mov	ebp, DWORD PTR $T3[rsp]
	mov	eax, DWORD PTR tga_width$1$[rsp]
$LN9@stbi__tga_:

; 6024 :       }
; 6025 :       //   do I need to invert the image?
; 6026 :       if ( tga_inverted )

	mov	r13d, DWORD PTR $T2[rsp]
	cmp	DWORD PTR tga_inverted$1$[rsp], r15d
	je	SHORT $LN21@stbi__tga_

; 6027 :       {
; 6028 :          for (j = 0; j*2 < tga_height; ++j)

	test	r13d, r13d
	jle	SHORT $LN21@stbi__tga_
	mov	r14, QWORD PTR tga_data$1$[rsp]
	lea	r10d, DWORD PTR [r13-1]
	imul	r10d, edi
	mov	r11d, edi
	imul	r11d, eax
	mov	ebx, r15d
	imul	r10d, eax
$LL22@stbi__tga_:

; 6029 :          {
; 6030 :             int index1 = j * tga_width * tga_comp;

	mov	r8d, r11d

; 6031 :             int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
; 6032 :             for (i = tga_width * tga_comp; i > 0; --i)

	test	r11d, r11d
	jle	SHORT $LN20@stbi__tga_

; 6029 :          {
; 6030 :             int index1 = j * tga_width * tga_comp;

	movsxd	rax, ebx
	movsxd	r9, r10d
	sub	r9, rax
	lea	rdx, QWORD PTR [rax+r14]
	npad	10
$LL25@stbi__tga_:

; 6033 :             {
; 6034 :                unsigned char temp = tga_data[index1];
; 6035 :                tga_data[index1] = tga_data[index2];

	movzx	eax, BYTE PTR [r9+rdx]
	dec	r8d
	movzx	ecx, BYTE PTR [rdx]
	mov	BYTE PTR [rdx], al

; 6036 :                tga_data[index2] = temp;

	mov	BYTE PTR [r9+rdx], cl

; 6037 :                ++index1;

	lea	rdx, QWORD PTR [rdx+1]
	test	r8d, r8d
	jg	SHORT $LL25@stbi__tga_
$LN20@stbi__tga_:

; 6027 :       {
; 6028 :          for (j = 0; j*2 < tga_height; ++j)

	add	ebx, r11d
	sub	r10d, r11d
	add	r15d, 2
	cmp	r15d, r13d
	jl	SHORT $LL22@stbi__tga_
$LN21@stbi__tga_:

; 6038 :                ++index2;
; 6039 :             }
; 6040 :          }
; 6041 :       }
; 6042 :       //   clear my palette, if I had one
; 6043 :       if ( tga_palette != NULL )

	mov	rax, QWORD PTR tga_palette$1$[rsp]
	test	rax, rax
	je	SHORT $LN270@stbi__tga_

; 6044 :       {
; 6045 :          STBI_FREE( tga_palette );

	mov	rcx, rax
	call	QWORD PTR __imp_free
$LN270@stbi__tga_:

; 6046 :       }
; 6047 :    }
; 6048 : 
; 6049 :    // swap RGB - if the source data was RGB16, it already is in the right order
; 6050 :    if (tga_comp >= 3 && !tga_rgb16)

	mov	edx, DWORD PTR tga_width$1$[rsp]
$LN58@stbi__tga_:
	mov	rax, QWORD PTR tga_data$1$[rsp]
	cmp	edi, 3
	jb	SHORT $LN27@stbi__tga_
	cmp	DWORD PTR tga_rgb16$4$[rsp], 0
	jne	SHORT $LN27@stbi__tga_

; 6051 :    {
; 6052 :       unsigned char* tga_pixel = tga_data;

	mov	r8, rax

; 6053 :       for (i=0; i < tga_width * tga_height; ++i)

	test	ebp, ebp
	je	SHORT $LN27@stbi__tga_

; 6051 :    {
; 6052 :       unsigned char* tga_pixel = tga_data;

	mov	r10d, ebp
	npad	5
$LL28@stbi__tga_:

; 6054 :       {
; 6055 :          unsigned char temp = tga_pixel[0];

	movzx	ecx, BYTE PTR [r8]

; 6056 :          tga_pixel[0] = tga_pixel[2];

	movzx	eax, BYTE PTR [r8+2]
	mov	BYTE PTR [r8], al

; 6057 :          tga_pixel[2] = temp;

	mov	BYTE PTR [r8+2], cl

; 6058 :          tga_pixel += tga_comp;

	add	r8, rsi
	sub	r10, 1
	jne	SHORT $LL28@stbi__tga_

; 6046 :       }
; 6047 :    }
; 6048 : 
; 6049 :    // swap RGB - if the source data was RGB16, it already is in the right order
; 6050 :    if (tga_comp >= 3 && !tga_rgb16)

	mov	rax, QWORD PTR tga_data$1$[rsp]
$LN27@stbi__tga_:

; 6059 :       }
; 6060 :    }
; 6061 : 
; 6062 :    // convert to target component count
; 6063 :    if (req_comp && req_comp != tga_comp)

	cmp	edi, 4
	je	SHORT $LN1@stbi__tga_

; 6064 :       tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

	mov	r9d, edx
	mov	DWORD PTR [rsp+32], r13d
	mov	edx, edi
	mov	r8d, 4
	mov	rcx, rax
	call	?stbi__convert_format@@YAPEAEPEAEHHII@Z	; stbi__convert_format

; 6065 : 
; 6066 :    //   the things I do to get rid of an error message, and yet keep
; 6067 :    //   Microsoft's C compilers happy... [8^(
; 6068 :    tga_palette_start = tga_palette_len = tga_palette_bits =
; 6069 :          tga_x_origin = tga_y_origin = 0;
; 6070 :    STBI_NOTUSED(tga_palette_start);
; 6071 :    //   OK, done
; 6072 :    return tga_data;

	jmp	SHORT $LN1@stbi__tga_
$LN251@stbi__tga_:

; 5952 :             STBI_FREE(tga_data);

	mov	rcx, QWORD PTR tga_data$1$[rsp]
	call	QWORD PTR __imp_free
$LN250@stbi__tga_:

; 6073 : }

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	jmp	SHORT $LN351@stbi__tga_
$LN257@stbi__tga_:
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
$LN351@stbi__tga_:
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	QWORD PTR [rdx+rcx], rax
	xor	eax, eax
$LN1@stbi__tga_:
	mov	rsi, QWORD PTR [rsp+168]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 176				; 000000b0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__tga_load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__psd_test@@YAHPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__psd_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__psd_test, COMDAT

; 6081 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 1704 :    stbi__uint32 z = stbi__get16be(s);

	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 1705 :    return (z << 16) + stbi__get16be(s);

	mov	rcx, rdi
	mov	ebx, eax
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	rcx, QWORD PTR [rdi+208]

; 6082 :    int r = (stbi__get32be(s) == 0x38425053);

	xor	edx, edx

; 1705 :    return (z << 16) + stbi__get16be(s);

	shl	ebx, 16
	add	eax, ebx

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	QWORD PTR [rdi+192], rcx

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	rcx, QWORD PTR [rdi+216]

; 6082 :    int r = (stbi__get32be(s) == 0x38425053);

	cmp	eax, 943870035				; 38425053H

; 6085 : }

	mov	rbx, QWORD PTR [rsp+48]
	sete	dl

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	QWORD PTR [rdi+200], rcx

; 6083 :    stbi__rewind(s);
; 6084 :    return r;

	mov	eax, edx

; 6085 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__psd_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__psd_test
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z
_TEXT	SEGMENT
s$ = 64
p$ = 72
pixelCount$ = 80
?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z PROC ; stbi__psd_decode_rle, COMDAT

; 6088 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 6089 :    int count, nleft, len;
; 6090 : 
; 6091 :    count = 0;

	xor	r15d, r15d
	mov	r12d, r8d
	mov	rdi, rdx
	mov	rbx, rcx

; 6092 :    while ((nleft = pixelCount - count) > 0) {

	mov	r14d, r8d
	test	r8d, r8d
	jle	$LN41@stbi__psd_
	npad	10
$LL2@stbi__psd_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN17@stbi__psd_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN16@stbi__psd_
$LN17@stbi__psd_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN18@stbi__psd_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN16@stbi__psd_
$LN18@stbi__psd_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN16@stbi__psd_:

; 6093 :       len = stbi__get8(s);

	movzx	ebp, cl

; 6094 :       if (len == 128) {

	cmp	ebp, 128				; 00000080H
	je	$LN7@stbi__psd_

; 6095 :          // No-op.
; 6096 :       } else if (len < 128) {

	jae	SHORT $LN10@stbi__psd_

; 6097 :          // Copy next len+1 bytes literally.
; 6098 :          len++;

	inc	ebp

; 6099 :          if (len > nleft) return 0; // corrupt data

	cmp	ebp, r14d
	ja	$LN32@stbi__psd_

; 6100 :          count += len;

	add	r15d, ebp
	npad	12
$LL4@stbi__psd_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN21@stbi__psd_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN20@stbi__psd_
$LN21@stbi__psd_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN22@stbi__psd_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN20@stbi__psd_
$LN22@stbi__psd_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN20@stbi__psd_:

; 6101 :          while (len) {
; 6102 :             *p = stbi__get8(s);

	mov	BYTE PTR [rdi], cl

; 6103 :             p += 4;

	add	rdi, 4

; 6104 :             len--;

	sub	ebp, 1
	jne	SHORT $LL4@stbi__psd_

; 6105 :          }
; 6106 :       } else if (len > 128) {

	jmp	SHORT $LN7@stbi__psd_
$LN10@stbi__psd_:
	jbe	SHORT $LN7@stbi__psd_

; 6107 :          stbi_uc   val;
; 6108 :          // Next -len+1 bytes in the dest are replicated from next source byte.
; 6109 :          // (Interpret len as a negative 8-bit int.)
; 6110 :          len = 257 - len;

	mov	esi, 257				; 00000101H
	sub	esi, ebp

; 6111 :          if (len > nleft) return 0; // corrupt data

	cmp	esi, r14d
	jg	$LN32@stbi__psd_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN25@stbi__psd_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN24@stbi__psd_
$LN25@stbi__psd_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN26@stbi__psd_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN24@stbi__psd_
$LN26@stbi__psd_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN24@stbi__psd_:

; 6112 :          val = stbi__get8(s);
; 6113 :          count += len;

	add	r15d, esi

; 6114 :          while (len) {

	test	esi, esi
	je	SHORT $LN7@stbi__psd_
	npad	7
$LL6@stbi__psd_:

; 6115 :             *p = val;

	mov	BYTE PTR [rdi], cl

; 6116 :             p += 4;

	add	rdi, 4

; 6117 :             len--;

	sub	esi, 1
	jne	SHORT $LL6@stbi__psd_
$LN7@stbi__psd_:

; 6092 :    while ((nleft = pixelCount - count) > 0) {

	mov	r14d, r12d
	sub	r14d, r15d
	test	r14d, r14d
	jg	$LL2@stbi__psd_
$LN41@stbi__psd_:

; 6118 :          }
; 6119 :       }
; 6120 :    }
; 6121 : 
; 6122 :    return 1;

	mov	eax, 1
$LN1@stbi__psd_:

; 6123 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
$LN32@stbi__psd_:

; 6111 :          if (len > nleft) return 0; // corrupt data

	xor	eax, eax
	jmp	SHORT $LN1@stbi__psd_
?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z ENDP ; stbi__psd_decode_rle
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
_TEXT	SEGMENT
$T1 = 32
out$1$ = 40
s$ = 112
x$ = 120
y$ = 128
comp$ = 136
bitdepth$1$ = 144
req_comp$dead$ = 144
ri$ = 152
$T2 = 160
bpc$dead$ = 160
?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z PROC ; stbi__psd_load, COMDAT

; 6126 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rdi
	sub	rsp, 88					; 00000058H
	mov	rdi, rcx

; 1704 :    stbi__uint32 z = stbi__get16be(s);

	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 1705 :    return (z << 16) + stbi__get16be(s);

	mov	rcx, rdi
	mov	ebx, eax
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	shl	ebx, 16
	add	eax, ebx

; 6127 :    int pixelCount;
; 6128 :    int channelCount, compression;
; 6129 :    int channel, i;
; 6130 :    int bitdepth;
; 6131 :    int w,h;
; 6132 :    stbi_uc *out;
; 6133 :    STBI_NOTUSED(ri);
; 6134 : 
; 6135 :    // Check identifier
; 6136 :    if (stbi__get32be(s) != 0x38425053)   // "8BPS"

	cmp	eax, 943870035				; 38425053H
	je	SHORT $LN32@stbi__psd_

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_07ECNCNLIK@not?5PSD@
	mov	QWORD PTR [rdx+rcx], rax

; 6137 :       return stbi__errpuc("not PSD", "Corrupt PSD image");

	xor	eax, eax

; 6324 : }

	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rbx
	ret	0
$LN32@stbi__psd_:

; 6138 : 
; 6139 :    // Check file type version.
; 6140 :    if (stbi__get16be(s) != 1)

	mov	rcx, rdi
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	cmp	eax, 1
	je	SHORT $LN33@stbi__psd_

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0O@CHBCDKKC@wrong?5version@
	mov	QWORD PTR [rdx+rcx], rax

; 6141 :       return stbi__errpuc("wrong version", "Unsupported version of PSD image");

	xor	eax, eax

; 6324 : }

	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rbx
	ret	0
$LN33@stbi__psd_:

; 1649 :    if (s->io.read) {

	cmp	QWORD PTR [rdi+16], 0
	mov	QWORD PTR [rsp+64], r13
	je	SHORT $LN201@stbi__psd_

; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);

	mov	ecx, DWORD PTR [rdi+200]
	sub	ecx, DWORD PTR [rdi+192]

; 1651 :       if (blen < n) {

	cmp	ecx, 6
	jge	SHORT $LN201@stbi__psd_

; 1652 :          s->img_buffer = s->img_buffer_end;

	mov	rax, QWORD PTR [rdi+200]

; 1653 :          (s->io.skip)(s->io_user_data, n - blen);

	mov	edx, 6
	sub	edx, ecx
	mov	QWORD PTR [rdi+192], rax
	mov	rcx, QWORD PTR [rdi+40]
	call	QWORD PTR [rdi+24]

; 1654 :          return;

	jmp	SHORT $LN75@stbi__psd_
$LN201@stbi__psd_:

; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;

	add	QWORD PTR [rdi+192], 6
$LN75@stbi__psd_:

; 6142 : 
; 6143 :    // Skip 6 reserved bytes.
; 6144 :    stbi__skip(s, 6 );
; 6145 : 
; 6146 :    // Read the number of channels (R, G, B, A, etc).
; 6147 :    channelCount = stbi__get16be(s);

	mov	rcx, rdi
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	r13d, eax

; 6148 :    if (channelCount < 0 || channelCount > 16)

	cmp	eax, 16
	ja	$LN35@stbi__psd_
	mov	QWORD PTR [rsp+56], r14

; 6150 : 
; 6151 :    // Read the rows and columns of the image.
; 6152 :    h = stbi__get32be(s);

	mov	rcx, rdi
	mov	QWORD PTR [rsp+48], r15
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be

; 6153 :    w = stbi__get32be(s);

	mov	rcx, rdi
	mov	DWORD PTR $T1[rsp], eax
	mov	r15d, eax
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	mov	DWORD PTR $T2[rsp], eax
	mov	r14d, eax

; 6154 : 
; 6155 :    if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

	cmp	r15d, 16777216				; 01000000H
	jg	$LN204@stbi__psd_

; 6156 :    if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

	cmp	eax, 16777216				; 01000000H
	jg	$LN204@stbi__psd_

; 6157 : 
; 6158 :    // Make sure the depth is 8 bits.
; 6159 :    bitdepth = stbi__get16be(s);

	mov	rcx, rdi
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	DWORD PTR bitdepth$1$[rsp], eax

; 6160 :    if (bitdepth != 8 && bitdepth != 16)

	lea	ecx, DWORD PTR [rax-8]
	test	ecx, -9					; fffffff7H
	je	SHORT $LN38@stbi__psd_

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BG@NOLDLPP@unsupported?5bit?5depth@
	mov	QWORD PTR [rdx+rcx], rax

; 6161 :       return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");

	xor	eax, eax
	jmp	$LN273@stbi__psd_
$LN38@stbi__psd_:

; 6162 : 
; 6163 :    // Make sure the color mode is RGB.
; 6164 :    // Valid options are:
; 6165 :    //   0: Bitmap
; 6166 :    //   1: Grayscale
; 6167 :    //   2: Indexed color
; 6168 :    //   3: RGB color
; 6169 :    //   4: CMYK color
; 6170 :    //   7: Multichannel
; 6171 :    //   8: Duotone
; 6172 :    //   9: Lab color
; 6173 :    if (stbi__get16be(s) != 3)

	mov	rcx, rdi
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	cmp	eax, 3
	je	SHORT $LN39@stbi__psd_

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BD@IOGGBMNK@wrong?5color?5format@
	mov	QWORD PTR [rdx+rcx], rax

; 6174 :       return stbi__errpuc("wrong color format", "PSD is not in RGB color format");

	xor	eax, eax
	jmp	$LN273@stbi__psd_
$LN39@stbi__psd_:

; 6175 : 
; 6176 :    // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
; 6177 :    stbi__skip(s,stbi__get32be(s) );

	mov	rcx, rdi
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	mov	edx, eax
	mov	rcx, rdi
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 6178 : 
; 6179 :    // Skip the image resources.  (resolution, pen tool paths, etc)
; 6180 :    stbi__skip(s, stbi__get32be(s) );

	mov	rcx, rdi
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	mov	edx, eax
	mov	rcx, rdi
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 6181 : 
; 6182 :    // Skip the reserved data.
; 6183 :    stbi__skip(s, stbi__get32be(s) );

	mov	rcx, rdi
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	mov	edx, eax
	mov	rcx, rdi
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 6184 : 
; 6185 :    // Find out if the data is compressed.
; 6186 :    // Known values:
; 6187 :    //   0: no compression
; 6188 :    //   1: RLE compressed
; 6189 :    compression = stbi__get16be(s);

	mov	rcx, rdi
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	ebx, eax

; 6190 :    if (compression > 1)

	cmp	eax, 1
	jle	SHORT $LN40@stbi__psd_

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BA@MCNBDLPD@bad?5compression@
	mov	QWORD PTR [rdx+rcx], rax

; 6191 :       return stbi__errpuc("bad compression", "PSD has an unknown compression format");

	xor	eax, eax
	jmp	$LN273@stbi__psd_
$LN40@stbi__psd_:

; 1014 :    if (a < 0 || b < 0) return 0;

	test	r14d, r14d
	js	$LN204@stbi__psd_

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	jne	SHORT $LN100@stbi__psd_
	lea	ecx, DWORD PTR [r14*4]
	jmp	SHORT $LN207@stbi__psd_
$LN100@stbi__psd_:

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	r14d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	eax, 4
	jl	$LN204@stbi__psd_
	lea	ecx, DWORD PTR [r14*4]

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	$LN204@stbi__psd_
$LN207@stbi__psd_:
	test	r15d, r15d
	js	$LN204@stbi__psd_

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN205@stbi__psd_

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	r15d

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, eax
	jg	$LN204@stbi__psd_
$LN205@stbi__psd_:
	mov	QWORD PTR [rsp+112], rbp
	mov	ebp, r15d
	imul	ebp, r14d
	mov	QWORD PTR [rsp+72], r12

; 6196 : 
; 6197 :    // Create the destination image.
; 6198 : 
; 6199 :    if (!compression && bitdepth == 16 && bpc == 16) {
; 6200 :       out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
; 6201 :       ri->bits_per_channel = 16;
; 6202 :    } else
; 6203 :       out = (stbi_uc *) stbi__malloc(4 * w*h);

	lea	eax, DWORD PTR [rbp*4]
	movsxd	rcx, eax

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc
	mov	QWORD PTR out$1$[rsp], rax
	mov	r12, rax

; 6204 : 
; 6205 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");

	test	rax, rax
	jne	SHORT $LN44@stbi__psd_

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	mov	QWORD PTR [rdx+rcx], rax

; 6204 : 
; 6205 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");

	xor	eax, eax
	jmp	$LN275@stbi__psd_
$LN44@stbi__psd_:
	mov	QWORD PTR [rsp+80], rsi

; 6206 :    pixelCount = w*h;
; 6207 : 
; 6208 :    // Initialize the data to zero.
; 6209 :    //memset( out, 0, pixelCount * 4 );
; 6210 : 
; 6211 :    // Finally, the image data.
; 6212 :    if (compression) {

	test	ebx, ebx
	je	$LN45@stbi__psd_

; 6213 :       // RLE as used by .PSD and .TIFF
; 6214 :       // Loop until you get the number of unpacked bytes you are expecting:
; 6215 :       //     Read the next source byte into n.
; 6216 :       //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
; 6217 :       //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
; 6218 :       //     Else if n is 128, noop.
; 6219 :       // Endloop
; 6220 : 
; 6221 :       // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
; 6222 :       // which we're going to just skip.
; 6223 :       stbi__skip(s, h * channelCount * 2 );

	mov	edx, r15d
	mov	rcx, rdi
	imul	edx, r13d
	add	edx, edx
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 6224 : 
; 6225 :       // Read the RLE data by channel.
; 6226 :       for (channel = 0; channel < 4; channel++) {

	xor	esi, esi
	mov	eax, 255				; 000000ffH
	mov	ebx, esi
$LL4@stbi__psd_:

; 6227 :          stbi_uc *p;
; 6228 : 
; 6229 :          p = out+channel;

	movsxd	rdx, ebx
	add	rdx, r12

; 6230 :          if (channel >= channelCount) {

	cmp	ebx, r13d
	jl	SHORT $LN47@stbi__psd_

; 6231 :             // Fill this channel with default data.
; 6232 :             for (i = 0; i < pixelCount; i++, p += 4)

	test	ebp, ebp
	jle	SHORT $LN2@stbi__psd_

; 6233 :                *p = (channel == 3 ? 255 : 0);

	cmp	ebx, 3
	mov	ecx, esi
	cmove	ecx, eax
	mov	eax, ebp
	npad	3
$LL7@stbi__psd_:
	mov	BYTE PTR [rdx], cl
	lea	rdx, QWORD PTR [rdx+4]
	sub	rax, 1
	jne	SHORT $LL7@stbi__psd_

; 6234 :          } else {

	jmp	SHORT $LN277@stbi__psd_
$LN47@stbi__psd_:

; 6235 :             // Read the RLE data.
; 6236 :             if (!stbi__psd_decode_rle(s, p, pixelCount)) {

	mov	r8d, ebp
	mov	rcx, rdi
	call	?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__psd_decode_rle
	test	eax, eax
	je	SHORT $LN154@stbi__psd_
$LN277@stbi__psd_:

; 6224 : 
; 6225 :       // Read the RLE data by channel.
; 6226 :       for (channel = 0; channel < 4; channel++) {

	mov	eax, 255				; 000000ffH
$LN2@stbi__psd_:
	inc	ebx
	cmp	ebx, 4
	jl	SHORT $LL4@stbi__psd_

; 6235 :             // Read the RLE data.
; 6236 :             if (!stbi__psd_decode_rle(s, p, pixelCount)) {

	jmp	$LN9@stbi__psd_
$LN154@stbi__psd_:

; 6237 :                STBI_FREE(out);

	mov	rcx, r12
	call	QWORD PTR __imp_free

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_07DPPMCAKL@corrupt@
	mov	QWORD PTR [rdx+rcx], rax

; 6238 :                return stbi__errpuc("corrupt", "bad RLE data");

	xor	eax, eax
$LN276@stbi__psd_:
	mov	rsi, QWORD PTR [rsp+80]
$LN275@stbi__psd_:
	mov	rbp, QWORD PTR [rsp+112]
	mov	r12, QWORD PTR [rsp+72]
$LN273@stbi__psd_:
	mov	r14, QWORD PTR [rsp+56]
	mov	r15, QWORD PTR [rsp+48]
	mov	r13, QWORD PTR [rsp+64]

; 6324 : }

	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rbx
	ret	0
$LN45@stbi__psd_:

; 6239 :             }
; 6240 :          }
; 6241 :       }
; 6242 : 
; 6243 :    } else {
; 6244 :       // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
; 6245 :       // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.
; 6246 : 
; 6247 :       // Read the data by channel.
; 6248 :       for (channel = 0; channel < 4; channel++) {

	xor	esi, esi
	mov	r15, r12
	mov	r14d, esi
	mov	ecx, 255				; 000000ffH
$LL10@stbi__psd_:

; 6249 :          if (channel >= channelCount) {

	cmp	r14d, r13d
	jl	SHORT $LN50@stbi__psd_

; 6258 :                stbi_uc val = channel == 3 ? 255 : 0;

	cmp	r14d, 3
	mov	edx, esi
	mov	rax, r15
	cmove	edx, ecx

; 6259 :                for (i = 0; i < pixelCount; i++, p += 4)

	test	ebp, ebp
	jle	$LN8@stbi__psd_

; 6250 :             // Fill this channel with default data.
; 6251 :             if (bitdepth == 16 && bpc == 16) {
; 6252 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
; 6253 :                stbi__uint16 val = channel == 3 ? 65535 : 0;
; 6254 :                for (i = 0; i < pixelCount; i++, q += 4)
; 6255 :                   *q = val;
; 6256 :             } else {
; 6257 :                stbi_uc *p = out+channel;

	mov	ecx, ebp
$LL16@stbi__psd_:

; 6260 :                   *p = val;

	mov	BYTE PTR [rax], dl
	lea	rax, QWORD PTR [rax+4]
	sub	rcx, 1
	jne	SHORT $LL16@stbi__psd_

; 6261 :             }
; 6262 :          } else {

	jmp	$LN278@stbi__psd_
$LN50@stbi__psd_:

; 6263 :             if (ri->bits_per_channel == 16) {    // output bpc

	mov	rax, QWORD PTR ri$[rsp]
	cmp	DWORD PTR [rax], 16
	jne	SHORT $LN54@stbi__psd_

; 6264 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;

	mov	rbx, r12

; 6265 :                for (i = 0; i < pixelCount; i++, q += 4)

	test	ebp, ebp
	jle	$LN8@stbi__psd_

; 6264 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;

	mov	esi, ebp
	npad	3
$LL19@stbi__psd_:

; 6266 :                   *q = (stbi__uint16) stbi__get16be(s);

	mov	rcx, rdi
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	WORD PTR [rbx], ax
	lea	rbx, QWORD PTR [rbx+8]
	sub	rsi, 1
	jne	SHORT $LL19@stbi__psd_
	jmp	$LN279@stbi__psd_
$LN54@stbi__psd_:

; 6267 :             } else {
; 6268 :                stbi_uc *p = out+channel;
; 6269 :                if (bitdepth == 16) {  // input bpc

	cmp	DWORD PTR bitdepth$1$[rsp], 16
	mov	rbx, r15
	jne	SHORT $LN56@stbi__psd_

; 6270 :                   for (i = 0; i < pixelCount; i++, p += 4)

	test	ebp, ebp
	jle	SHORT $LN8@stbi__psd_
	mov	esi, ebp
	npad	3
$LL22@stbi__psd_:

; 6271 :                      *p = (stbi_uc) (stbi__get16be(s) >> 8);

	mov	rcx, rdi
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	sar	eax, 8
	mov	BYTE PTR [rbx], al
	lea	rbx, QWORD PTR [rbx+4]
	sub	rsi, 1
	jne	SHORT $LL22@stbi__psd_
	jmp	SHORT $LN279@stbi__psd_
$LN56@stbi__psd_:

; 6272 :                } else {
; 6273 :                   for (i = 0; i < pixelCount; i++, p += 4)

	test	ebp, ebp
	jle	SHORT $LN8@stbi__psd_
	mov	esi, ebp
	npad	1
$LL25@stbi__psd_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rdi+192]
	cmp	rax, QWORD PTR [rdi+200]
	jae	SHORT $LN115@stbi__psd_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN114@stbi__psd_
$LN115@stbi__psd_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi+48], 0
	je	SHORT $LN116@stbi__psd_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rdi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi+192], rax
	jmp	SHORT $LN114@stbi__psd_
$LN116@stbi__psd_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN114@stbi__psd_:

; 6274 :                      *p = stbi__get8(s);

	mov	BYTE PTR [rbx], cl
	add	rbx, 4
	sub	rsi, 1
	jne	SHORT $LL25@stbi__psd_
$LN279@stbi__psd_:

; 6239 :             }
; 6240 :          }
; 6241 :       }
; 6242 : 
; 6243 :    } else {
; 6244 :       // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
; 6245 :       // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.
; 6246 : 
; 6247 :       // Read the data by channel.
; 6248 :       for (channel = 0; channel < 4; channel++) {

	xor	esi, esi
$LN278@stbi__psd_:
	mov	ecx, 255				; 000000ffH
$LN8@stbi__psd_:
	inc	r14d
	add	r12, 2
	inc	r15
	cmp	r14d, 4
	jl	$LL10@stbi__psd_
	mov	r12, QWORD PTR out$1$[rsp]
	mov	r14d, DWORD PTR $T2[rsp]
	mov	r15d, DWORD PTR $T1[rsp]
$LN9@stbi__psd_:

; 6275 :                }
; 6276 :             }
; 6277 :          }
; 6278 :       }
; 6279 :    }
; 6280 : 
; 6281 :    // remove weird white matte from PSD
; 6282 :    if (channelCount >= 4) {

	cmp	r13d, 4
	jl	$LN182@stbi__psd_

; 6283 :       if (ri->bits_per_channel == 16) {

	mov	rax, QWORD PTR ri$[rsp]
	movsxd	rdx, ebp
	cmp	DWORD PTR [rax], 16
	jne	$LN59@stbi__psd_

; 6284 :          for (i=0; i < w*h; ++i) {

	movss	xmm3, DWORD PTR __real@477fff00
	mov	r10d, 65533				; 0000fffdH
	movss	xmm4, DWORD PTR __real@3f800000
	cmp	rdx, 4
	jl	$LC176@stbi__psd_
	lea	r8, QWORD PTR [rdx-4]
	shr	r8, 2
	lea	rcx, QWORD PTR [r12+10]
	inc	r8
	lea	rsi, QWORD PTR [r8*4]
	npad	12
$LL181@stbi__psd_:

; 6285 :             stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
; 6286 :             if (pixel[3] != 0 && pixel[3] != 65535) {

	movzx	r9d, WORD PTR [rcx-4]
	lea	eax, DWORD PTR [r9-1]
	cmp	ax, r10w
	ja	SHORT $LN177@stbi__psd_

; 6287 :                float a = pixel[3] / 65535.0f;
; 6288 :                float ra = 1.0f / a;
; 6289 :                float inv_a = 65535.0f * (1 - ra);
; 6290 :                pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);

	movzx	eax, WORD PTR [rcx-10]
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, r9d
	movaps	xmm2, xmm4
	movaps	xmm1, xmm4
	divss	xmm0, xmm3
	divss	xmm2, xmm0
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, eax
	subss	xmm1, xmm2
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	WORD PTR [rcx-10], ax

; 6291 :                pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);

	movzx	eax, WORD PTR [rcx-8]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	WORD PTR [rcx-8], ax

; 6292 :                pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);

	movzx	eax, WORD PTR [rcx-6]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR [rcx-6], ax
$LN177@stbi__psd_:

; 6285 :             stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
; 6286 :             if (pixel[3] != 0 && pixel[3] != 65535) {

	movzx	r9d, WORD PTR [rcx+4]
	lea	eax, DWORD PTR [r9-1]
	cmp	ax, r10w
	ja	SHORT $LN178@stbi__psd_

; 6287 :                float a = pixel[3] / 65535.0f;
; 6288 :                float ra = 1.0f / a;
; 6289 :                float inv_a = 65535.0f * (1 - ra);
; 6290 :                pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);

	movzx	eax, WORD PTR [rcx-2]
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, r9d
	movaps	xmm2, xmm4
	movaps	xmm1, xmm4
	divss	xmm0, xmm3
	divss	xmm2, xmm0
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, eax
	subss	xmm1, xmm2
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	WORD PTR [rcx-2], ax

; 6291 :                pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);

	movzx	eax, WORD PTR [rcx]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	WORD PTR [rcx], ax

; 6292 :                pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);

	movzx	eax, WORD PTR [rcx+2]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR [rcx+2], ax
$LN178@stbi__psd_:

; 6285 :             stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
; 6286 :             if (pixel[3] != 0 && pixel[3] != 65535) {

	movzx	r9d, WORD PTR [rcx+12]
	lea	eax, DWORD PTR [r9-1]
	cmp	ax, r10w
	ja	SHORT $LN179@stbi__psd_

; 6287 :                float a = pixel[3] / 65535.0f;
; 6288 :                float ra = 1.0f / a;
; 6289 :                float inv_a = 65535.0f * (1 - ra);
; 6290 :                pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);

	movzx	eax, WORD PTR [rcx+6]
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, r9d
	movaps	xmm2, xmm4
	movaps	xmm1, xmm4
	divss	xmm0, xmm3
	divss	xmm2, xmm0
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, eax
	subss	xmm1, xmm2
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	WORD PTR [rcx+6], ax

; 6291 :                pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);

	movzx	eax, WORD PTR [rcx+8]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	WORD PTR [rcx+8], ax

; 6292 :                pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);

	movzx	eax, WORD PTR [rcx+10]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR [rcx+10], ax
$LN179@stbi__psd_:

; 6285 :             stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
; 6286 :             if (pixel[3] != 0 && pixel[3] != 65535) {

	movzx	r9d, WORD PTR [rcx+20]
	lea	eax, DWORD PTR [r9-1]
	cmp	ax, r10w
	ja	SHORT $LN180@stbi__psd_

; 6287 :                float a = pixel[3] / 65535.0f;
; 6288 :                float ra = 1.0f / a;
; 6289 :                float inv_a = 65535.0f * (1 - ra);
; 6290 :                pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);

	movzx	eax, WORD PTR [rcx+14]
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, r9d
	movaps	xmm2, xmm4
	movaps	xmm1, xmm4
	divss	xmm0, xmm3
	divss	xmm2, xmm0
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, eax
	subss	xmm1, xmm2
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	WORD PTR [rcx+14], ax

; 6291 :                pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);

	movzx	eax, WORD PTR [rcx+16]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	WORD PTR [rcx+16], ax

; 6292 :                pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);

	movzx	eax, WORD PTR [rcx+18]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR [rcx+18], ax
$LN180@stbi__psd_:
	add	rcx, 32					; 00000020H
	sub	r8, 1
	jne	$LL181@stbi__psd_
$LC176@stbi__psd_:

; 6284 :          for (i=0; i < w*h; ++i) {

	cmp	rsi, rdx
	jge	$LN182@stbi__psd_
	lea	rcx, QWORD PTR [rsi*8+2]
	add	rcx, r12
	sub	rdx, rsi
$LC28@stbi__psd_:

; 6285 :             stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
; 6286 :             if (pixel[3] != 0 && pixel[3] != 65535) {

	movzx	r8d, WORD PTR [rcx+4]
	lea	eax, DWORD PTR [r8-1]
	cmp	ax, r10w
	ja	SHORT $LN26@stbi__psd_

; 6287 :                float a = pixel[3] / 65535.0f;
; 6288 :                float ra = 1.0f / a;
; 6289 :                float inv_a = 65535.0f * (1 - ra);
; 6290 :                pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);

	movzx	eax, WORD PTR [rcx-2]
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, r8d
	movaps	xmm2, xmm4
	movaps	xmm1, xmm4
	divss	xmm0, xmm3
	divss	xmm2, xmm0
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, eax
	subss	xmm1, xmm2
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	WORD PTR [rcx-2], ax

; 6291 :                pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);

	movzx	eax, WORD PTR [rcx]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	WORD PTR [rcx], ax

; 6292 :                pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);

	movzx	eax, WORD PTR [rcx+2]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR [rcx+2], ax
$LN26@stbi__psd_:

; 6284 :          for (i=0; i < w*h; ++i) {

	add	rcx, 8
	sub	rdx, 1
	jne	$LC28@stbi__psd_

; 6293 :             }
; 6294 :          }
; 6295 :       } else {

	jmp	$LN182@stbi__psd_
$LN59@stbi__psd_:

; 6296 :          for (i=0; i < w*h; ++i) {

	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm4, DWORD PTR __real@437f0000
	cmp	rdx, 4
	jl	$LC183@stbi__psd_
	lea	r8, QWORD PTR [rdx-4]
	shr	r8, 2
	lea	rcx, QWORD PTR [r12+5]
	inc	r8
	lea	rsi, QWORD PTR [r8*4]
	npad	4
$LL188@stbi__psd_:

; 6297 :             unsigned char *pixel = out + 4*i;
; 6298 :             if (pixel[3] != 0 && pixel[3] != 255) {

	movzx	r9d, BYTE PTR [rcx-2]
	lea	eax, DWORD PTR [r9-1]
	cmp	al, 253					; 000000fdH
	ja	SHORT $LN184@stbi__psd_

; 6299 :                float a = pixel[3] / 255.0f;
; 6300 :                float ra = 1.0f / a;
; 6301 :                float inv_a = 255.0f * (1 - ra);
; 6302 :                pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);

	movzx	eax, BYTE PTR [rcx-5]
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, r9d
	movaps	xmm2, xmm3
	movaps	xmm1, xmm3
	divss	xmm0, xmm4
	divss	xmm2, xmm0
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, eax
	subss	xmm1, xmm2
	mulss	xmm0, xmm2
	mulss	xmm1, xmm4
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	BYTE PTR [rcx-5], al

; 6303 :                pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);

	movzx	eax, BYTE PTR [rcx-4]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	BYTE PTR [rcx-4], al

; 6304 :                pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);

	movzx	eax, BYTE PTR [rcx-3]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	BYTE PTR [rcx-3], al
$LN184@stbi__psd_:

; 6297 :             unsigned char *pixel = out + 4*i;
; 6298 :             if (pixel[3] != 0 && pixel[3] != 255) {

	movzx	r9d, BYTE PTR [rcx+2]
	lea	eax, DWORD PTR [r9-1]
	cmp	al, 253					; 000000fdH
	ja	SHORT $LN185@stbi__psd_

; 6299 :                float a = pixel[3] / 255.0f;
; 6300 :                float ra = 1.0f / a;
; 6301 :                float inv_a = 255.0f * (1 - ra);
; 6302 :                pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);

	movzx	eax, BYTE PTR [rcx-1]
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, r9d
	movaps	xmm2, xmm3
	movaps	xmm1, xmm3
	divss	xmm0, xmm4
	divss	xmm2, xmm0
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, eax
	subss	xmm1, xmm2
	mulss	xmm0, xmm2
	mulss	xmm1, xmm4
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	BYTE PTR [rcx-1], al

; 6303 :                pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);

	movzx	eax, BYTE PTR [rcx]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	BYTE PTR [rcx], al

; 6304 :                pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);

	movzx	eax, BYTE PTR [rcx+1]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	BYTE PTR [rcx+1], al
$LN185@stbi__psd_:

; 6297 :             unsigned char *pixel = out + 4*i;
; 6298 :             if (pixel[3] != 0 && pixel[3] != 255) {

	movzx	r9d, BYTE PTR [rcx+6]
	lea	eax, DWORD PTR [r9-1]
	cmp	al, 253					; 000000fdH
	ja	SHORT $LN186@stbi__psd_

; 6299 :                float a = pixel[3] / 255.0f;
; 6300 :                float ra = 1.0f / a;
; 6301 :                float inv_a = 255.0f * (1 - ra);
; 6302 :                pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);

	movzx	eax, BYTE PTR [rcx+3]
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, r9d
	movaps	xmm2, xmm3
	movaps	xmm1, xmm3
	divss	xmm0, xmm4
	divss	xmm2, xmm0
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, eax
	subss	xmm1, xmm2
	mulss	xmm0, xmm2
	mulss	xmm1, xmm4
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	BYTE PTR [rcx+3], al

; 6303 :                pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);

	movzx	eax, BYTE PTR [rcx+4]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	BYTE PTR [rcx+4], al

; 6304 :                pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);

	movzx	eax, BYTE PTR [rcx+5]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	BYTE PTR [rcx+5], al
$LN186@stbi__psd_:

; 6297 :             unsigned char *pixel = out + 4*i;
; 6298 :             if (pixel[3] != 0 && pixel[3] != 255) {

	movzx	r9d, BYTE PTR [rcx+10]
	lea	eax, DWORD PTR [r9-1]
	cmp	al, 253					; 000000fdH
	ja	SHORT $LN187@stbi__psd_

; 6299 :                float a = pixel[3] / 255.0f;
; 6300 :                float ra = 1.0f / a;
; 6301 :                float inv_a = 255.0f * (1 - ra);
; 6302 :                pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);

	movzx	eax, BYTE PTR [rcx+7]
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, r9d
	movaps	xmm2, xmm3
	movaps	xmm1, xmm3
	divss	xmm0, xmm4
	divss	xmm2, xmm0
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, eax
	subss	xmm1, xmm2
	mulss	xmm0, xmm2
	mulss	xmm1, xmm4
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	BYTE PTR [rcx+7], al

; 6303 :                pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);

	movzx	eax, BYTE PTR [rcx+8]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	BYTE PTR [rcx+8], al

; 6304 :                pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);

	movzx	eax, BYTE PTR [rcx+9]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	BYTE PTR [rcx+9], al
$LN187@stbi__psd_:
	add	rcx, 16
	sub	r8, 1
	jne	$LL188@stbi__psd_
$LC183@stbi__psd_:

; 6296 :          for (i=0; i < w*h; ++i) {

	cmp	rsi, rdx
	jge	$LN182@stbi__psd_
	lea	rcx, QWORD PTR [rsi*4+1]
	add	rcx, r12
	sub	rdx, rsi
$LC31@stbi__psd_:

; 6297 :             unsigned char *pixel = out + 4*i;
; 6298 :             if (pixel[3] != 0 && pixel[3] != 255) {

	movzx	r8d, BYTE PTR [rcx+2]
	lea	eax, DWORD PTR [r8-1]
	cmp	al, 253					; 000000fdH
	ja	SHORT $LN29@stbi__psd_

; 6299 :                float a = pixel[3] / 255.0f;
; 6300 :                float ra = 1.0f / a;
; 6301 :                float inv_a = 255.0f * (1 - ra);
; 6302 :                pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);

	movzx	eax, BYTE PTR [rcx-1]
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, r8d
	movaps	xmm2, xmm3
	movaps	xmm1, xmm3
	divss	xmm0, xmm4
	divss	xmm2, xmm0
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, eax
	subss	xmm1, xmm2
	mulss	xmm0, xmm2
	mulss	xmm1, xmm4
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	BYTE PTR [rcx-1], al

; 6303 :                pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);

	movzx	eax, BYTE PTR [rcx]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	mov	BYTE PTR [rcx], al

; 6304 :                pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);

	movzx	eax, BYTE PTR [rcx+1]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	BYTE PTR [rcx+1], al
$LN29@stbi__psd_:

; 6296 :          for (i=0; i < w*h; ++i) {

	add	rcx, 4
	sub	rdx, 1
	jne	$LC31@stbi__psd_
$LN182@stbi__psd_:

; 6305 :             }
; 6306 :          }
; 6307 :       }
; 6308 :    }
; 6309 : 
; 6310 :    // convert to desired output format
; 6311 :    if (req_comp && req_comp != 4) {
; 6312 :       if (ri->bits_per_channel == 16)
; 6313 :          out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
; 6314 :       else
; 6315 :          out = stbi__convert_format(out, 4, req_comp, w, h);
; 6316 :       if (out == NULL) return out; // stbi__convert_format frees input on failure
; 6317 :    }
; 6318 : 
; 6319 :    if (comp) *comp = 4;

	mov	rax, QWORD PTR comp$[rsp]
	test	rax, rax
	je	SHORT $LN67@stbi__psd_
	mov	DWORD PTR [rax], 4
$LN67@stbi__psd_:

; 6320 :    *y = h;

	mov	rax, QWORD PTR y$[rsp]
	mov	DWORD PTR [rax], r15d

; 6321 :    *x = w;

	mov	rax, QWORD PTR x$[rsp]
	mov	DWORD PTR [rax], r14d

; 6322 : 
; 6323 :    return out;

	mov	rax, r12
	jmp	$LN276@stbi__psd_
$LN204@stbi__psd_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
	mov	QWORD PTR [rdx+rcx], rax

; 6192 : 
; 6193 :    // Check size
; 6194 :    if (!stbi__mad3sizes_valid(4, w, h, 0))
; 6195 :       return stbi__errpuc("too large", "Corrupt PSD");

	xor	eax, eax
	jmp	$LN273@stbi__psd_
$LN35@stbi__psd_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	r13, QWORD PTR [rsp+64]
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BE@PJBNGDBE@wrong?5channel?5count@
	mov	QWORD PTR [rdx+rcx], rax

; 6149 :       return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");

	xor	eax, eax

; 6324 : }

	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rbx
	ret	0
?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z ENDP ; stbi__psd_load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z
_TEXT	SEGMENT
s$ = 48
str$ = 56
?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z PROC	; stbi__pic_is4, COMDAT

; 6336 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rbx, rcx
	xor	edi, edi
	npad	9
$LL4@stbi__pic_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN8@stbi__pic_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN7@stbi__pic_
$LN8@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN9@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN7@stbi__pic_
$LN9@stbi__pic_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN7@stbi__pic_:

; 6339 :       if (stbi__get8(s) != (stbi_uc)str[i])

	cmp	cl, BYTE PTR [rdi+rsi]
	jne	SHORT $LN12@stbi__pic_

; 6337 :    int i;
; 6338 :    for (i=0; i<4; ++i)

	inc	rdi
	cmp	rdi, 4
	jl	SHORT $LL4@stbi__pic_

; 6340 :          return 0;
; 6341 : 
; 6342 :    return 1;

	mov	eax, 1

; 6343 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN12@stbi__pic_:
	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ENDP	; stbi__pic_is4
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z PROC	; stbi__pic_test_core, COMDAT

; 6346 : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 6347 :    int i;
; 6348 : 
; 6349 :    if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))

	lea	rdx, OFFSET FLAT:??_C@_04KBFEPHFH@S?$IA?v4@
	mov	rbx, rcx
	call	?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ; stbi__pic_is4
	test	eax, eax
	je	SHORT $LN16@stbi__pic_
	mov	QWORD PTR [rsp+48], rdi

; 6350 :       return 0;
; 6351 : 
; 6352 :    for(i=0;i<84;++i)

	mov	edi, 84					; 00000054H
	npad	13
$LL4@stbi__pic_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN9@stbi__pic_

; 1615 :       return *s->img_buffer++;

	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN2@stbi__pic_
$LN9@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN2@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	inc	QWORD PTR [rbx+192]
$LN2@stbi__pic_:

; 6350 :       return 0;
; 6351 : 
; 6352 :    for(i=0;i<84;++i)

	sub	rdi, 1
	jne	SHORT $LL4@stbi__pic_
	mov	rdi, QWORD PTR [rsp+48]

; 6353 :       stbi__get8(s);
; 6354 : 
; 6355 :    if (!stbi__pic_is4(s,"PICT"))

	lea	rdx, OFFSET FLAT:??_C@_04ELNJHLFH@PICT@
	mov	rcx, rbx
	call	?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ; stbi__pic_is4
	xor	ecx, ecx
	test	eax, eax
	setne	cl
	mov	eax, ecx

; 6357 : 
; 6358 :    return 1;
; 6359 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN16@stbi__pic_:

; 6356 :       return 0;

	xor	eax, eax

; 6357 : 
; 6358 :    return 1;
; 6359 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z ENDP	; stbi__pic_test_core
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z
_TEXT	SEGMENT
s$ = 48
channel$ = 56
dest$ = 64
?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z PROC	; stbi__readval, COMDAT

; 6367 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rbp, r8
	mov	r14d, edx
	mov	rbx, rcx

; 6368 :    int mask=0x80, i;

	mov	esi, 128				; 00000080H
	xor	edi, edi
	npad	6
$LL4@stbi__read:

; 6371 :       if (channel & mask) {

	test	esi, r14d
	je	$LN2@stbi__read

; 1628 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], 0
	je	SHORT $LN25@stbi__read

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	rax, QWORD PTR [rbx+32]
	mov	rcx, QWORD PTR [rbx+40]
	call	rax
	test	eax, eax
	jne	SHORT $LN10@stbi__read
	lea	rcx, QWORD PTR [rbx+48]
	jmp	SHORT $LN26@stbi__read
$LN10@stbi__read:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

	cmp	DWORD PTR [rbx+48], 0
	lea	rax, QWORD PTR [rbx+48]
	jne	SHORT $LN23@stbi__read
$LN27@stbi__read:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08GGMBIFE@bad?5file@
	mov	QWORD PTR [rdx+rcx], rax

; 6372 :          if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");

	xor	eax, eax
	jmp	SHORT $LN1@stbi__read
$LN25@stbi__read:
	lea	rax, QWORD PTR [rbx+48]
$LN23@stbi__read:
	mov	rcx, rax
	mov	rax, QWORD PTR [rbx+200]
	cmp	QWORD PTR [rbx+192], rax
	jae	SHORT $LN27@stbi__read
$LN26@stbi__read:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN16@stbi__read

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN15@stbi__read
$LN16@stbi__read:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rcx], 0
	je	SHORT $LN17@stbi__read

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN15@stbi__read
$LN17@stbi__read:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN15@stbi__read:

; 6373 :          dest[i]=stbi__get8(s);

	mov	BYTE PTR [rdi+rbp], cl
$LN2@stbi__read:

; 6369 : 
; 6370 :    for (i=0; i<4; ++i, mask>>=1) {

	inc	rdi
	sar	esi, 1
	cmp	rdi, 4
	jl	$LL4@stbi__read

; 6374 :       }
; 6375 :    }
; 6376 : 
; 6377 :    return dest;

	mov	rax, rbp
$LN1@stbi__read:

; 6378 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ENDP	; stbi__readval
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__copyval@@YAXHPEAEPEBE@Z
_TEXT	SEGMENT
channel$ = 8
dest$ = 16
src$ = 24
?stbi__copyval@@YAXHPEAEPEBE@Z PROC			; stbi__copyval, COMDAT

; 6382 :    int mask=0x80,i;
; 6383 : 
; 6384 :    for (i=0;i<4; ++i, mask>>=1)
; 6385 :       if (channel&mask)

	test	cl, cl
	jns	SHORT $LN2@stbi__copy

; 6386 :          dest[i]=src[i];

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rdx], al
$LN2@stbi__copy:

; 6382 :    int mask=0x80,i;
; 6383 : 
; 6384 :    for (i=0;i<4; ++i, mask>>=1)
; 6385 :       if (channel&mask)

	test	cl, 64					; 00000040H
	je	SHORT $LN10@stbi__copy

; 6386 :          dest[i]=src[i];

	movzx	eax, BYTE PTR [r8+1]
	mov	BYTE PTR [rdx+1], al
$LN10@stbi__copy:

; 6382 :    int mask=0x80,i;
; 6383 : 
; 6384 :    for (i=0;i<4; ++i, mask>>=1)
; 6385 :       if (channel&mask)

	test	cl, 32					; 00000020H
	je	SHORT $LN12@stbi__copy

; 6386 :          dest[i]=src[i];

	movzx	eax, BYTE PTR [r8+2]
	mov	BYTE PTR [rdx+2], al
$LN12@stbi__copy:

; 6382 :    int mask=0x80,i;
; 6383 : 
; 6384 :    for (i=0;i<4; ++i, mask>>=1)
; 6385 :       if (channel&mask)

	test	cl, 16
	je	SHORT $LN14@stbi__copy

; 6386 :          dest[i]=src[i];

	movzx	eax, BYTE PTR [r8+3]
	mov	BYTE PTR [rdx+3], al
$LN14@stbi__copy:

; 6387 : }

	ret	0
?stbi__copyval@@YAXHPEAEPEBE@Z ENDP			; stbi__copyval
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z
_TEXT	SEGMENT
width$GSCopy$1$ = 32
height$1$ = 36
y$1$ = 40
tv1729 = 44
$T1 = 48
$T2 = 56
result$GSCopy$1$ = 64
tv1744 = 72
value$3 = 80
value$4 = 84
packets$ = 88
__$ArrayPad$ = 120
s$ = 192
width$ = 200
height$ = 208
comp$ = 216
result$ = 224
?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z PROC ; stbi__pic_load_core, COMDAT

; 6390 : {

	mov	r11, rsp
	push	rbp
	push	r13
	push	r14
	push	r15
	sub	rsp, 152				; 00000098H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rax, QWORD PTR result$[rsp]
	lea	rbp, QWORD PTR [r11-96]
	mov	QWORD PTR [r11+24], rbx

; 6391 :    int act_comp=0,num_packets=0,y,chained;

	xor	r14d, r14d
	mov	QWORD PTR [r11-40], rsi
	mov	r15, r9
	mov	QWORD PTR result$GSCopy$1$[rsp], rax
	mov	r13, rcx
	mov	QWORD PTR [r11-48], rdi
	xor	eax, eax
	mov	QWORD PTR [r11-56], r12
	mov	DWORD PTR height$1$[rsp], r8d
	mov	DWORD PTR width$GSCopy$1$[rsp], edx
$LL4@stbi__pic_:

; 6392 :    stbi__pic_packet packets[10];
; 6393 : 
; 6394 :    // this will (should...) cater for even some bizarre stuff like having data
; 6395 :     // for the same channel in multiple packets.
; 6396 :    do {
; 6397 :       stbi__pic_packet *packet;
; 6398 : 
; 6399 :       if (num_packets==sizeof(packets)/sizeof(packets[0]))

	cmp	rax, 10
	je	$LN128@stbi__pic_

; 6400 :          return stbi__errpuc("bad format","too many packets");
; 6401 : 
; 6402 :       packet = &packets[num_packets++];

	inc	rax
	mov	rdi, rbp
	mov	QWORD PTR $T1[rsp], rax
	add	rbp, 3

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [r13+192]
	cmp	rax, QWORD PTR [r13+200]
	jae	SHORT $LN57@stbi__pic_

; 1615 :       return *s->img_buffer++;

	movzx	esi, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [r13+192], rax
	jmp	SHORT $LN262@stbi__pic_
$LN57@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r13+48], 0
	je	SHORT $LN58@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, r13
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [r13+192]
	movzx	esi, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [r13+192], rax
	jmp	SHORT $LN262@stbi__pic_
$LN58@stbi__pic_:

; 1619 :    }
; 1620 :    return 0;

	xor	sil, sil
$LN262@stbi__pic_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rcx, r13
	mov	edx, 48					; 00000030H
	lea	r12, QWORD PTR [rdx+rcx]
	cmp	rax, QWORD PTR [r13+200]
	jae	SHORT $LN61@stbi__pic_

; 1615 :       return *s->img_buffer++;

	movzx	ebx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [r13+192], rax
	jmp	SHORT $LN60@stbi__pic_
$LN61@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r12], 0
	je	SHORT $LN62@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, r13
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [r13+192]
	movzx	ebx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [r13+192], rax
	jmp	SHORT $LN60@stbi__pic_
$LN62@stbi__pic_:

; 1619 :    }
; 1620 :    return 0;

	xor	bl, bl
$LN60@stbi__pic_:

; 6403 : 
; 6404 :       chained = stbi__get8(s);
; 6405 :       packet->size    = stbi__get8(s);

	mov	BYTE PTR [rdi], bl

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [r13+200]
	jae	SHORT $LN65@stbi__pic_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [r13+192], rax
	jmp	SHORT $LN64@stbi__pic_
$LN65@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r12], 0
	je	SHORT $LN66@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, r13
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [r13+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [r13+192], rax
	jmp	SHORT $LN64@stbi__pic_
$LN66@stbi__pic_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN64@stbi__pic_:

; 6406 :       packet->type    = stbi__get8(s);

	mov	BYTE PTR [rdi+1], cl

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [r13+200]
	jae	SHORT $LN69@stbi__pic_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [r13+192], rax
	jmp	SHORT $LN68@stbi__pic_
$LN69@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r12], 0
	je	SHORT $LN70@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, r13
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [r13+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [r13+192], rax
	jmp	SHORT $LN68@stbi__pic_
$LN70@stbi__pic_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN68@stbi__pic_:

; 6407 :       packet->channel = stbi__get8(s);
; 6408 : 
; 6409 :       act_comp |= packet->channel;

	movzx	eax, cl
	or	r14d, eax
	mov	BYTE PTR [rdi+2], cl

; 1628 :    if (s->io.read) {

	cmp	QWORD PTR [r13+16], 0
	je	SHORT $LN190@stbi__pic_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	rax, QWORD PTR [r13+32]
	mov	rcx, QWORD PTR [r13+40]
	call	rax
	test	eax, eax
	je	SHORT $LN196@stbi__pic_

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

	cmp	DWORD PTR [r12], 0
	je	$LN134@stbi__pic_
$LN190@stbi__pic_:

; 6410 : 
; 6411 :       if (stbi__at_eof(s))          return stbi__errpuc("bad file","file too short (reading packets)");

	mov	rax, QWORD PTR [r13+200]
	cmp	QWORD PTR [r13+192], rax
	jae	$LN134@stbi__pic_
$LN196@stbi__pic_:

; 6412 :       if (packet->size != 8)  return stbi__errpuc("bad format","packet isn't 8bpp");

	cmp	bl, 8
	jne	$LN128@stbi__pic_

; 6413 :    } while (chained);

	mov	rax, QWORD PTR $T1[rsp]
	test	sil, sil
	jne	$LL4@stbi__pic_

; 6414 : 
; 6415 :    *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

	test	r14b, 16
	mov	eax, 0
	setne	al

; 6416 : 
; 6417 :    for(y=0; y<height; ++y) {

	xor	ecx, ecx
	add	eax, 3
	mov	DWORD PTR y$1$[rsp], ecx
	mov	DWORD PTR [r15], eax
	cmp	DWORD PTR height$1$[rsp], ecx
	jle	$LN202@stbi__pic_

; 6414 : 
; 6415 :    *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

	mov	ebp, DWORD PTR width$GSCopy$1$[rsp]
	xor	edx, edx
	mov	rax, QWORD PTR $T1[rsp]
	mov	r9d, DWORD PTR height$1$[rsp]
	mov	DWORD PTR tv1729[rsp], edx
	lea	r8d, DWORD PTR [rbp*4]
	npad	11
$LL7@stbi__pic_:

; 6418 :       int packet_idx;
; 6419 : 
; 6420 :       for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {

	mov	QWORD PTR $T2[rsp], 0
	test	rax, rax
	jle	$LN5@stbi__pic_
	movsxd	rax, edx
	lea	r15, QWORD PTR packets$[rsp+2]
	add	rax, QWORD PTR result$GSCopy$1$[rsp]
	mov	QWORD PTR tv1744[rsp], rax
	npad	12
$LL10@stbi__pic_:

; 6421 :          stbi__pic_packet *packet = &packets[packet_idx];
; 6422 :          stbi_uc *dest = result+y*width*4;
; 6423 : 
; 6424 :          switch (packet->type) {

	movzx	ecx, BYTE PTR [r15-1]
	mov	rbx, rax
	test	ecx, ecx
	je	$LN33@stbi__pic_
	sub	ecx, 1
	je	$LN35@stbi__pic_
	cmp	ecx, 1
	jne	$LN128@stbi__pic_

; 6455 :                   }
; 6456 :                }
; 6457 :                break;
; 6458 : 
; 6459 :             case 2: {//Mixed RLE
; 6460 :                int left=width;

	mov	r14d, ebp

; 6461 :                while (left>0) {

	test	ebp, ebp
	jle	$LN8@stbi__pic_
	npad	3
$LL21@stbi__pic_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [r13+192]
	cmp	rax, QWORD PTR [r13+200]
	jae	SHORT $LN87@stbi__pic_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [r13+192], rax
	jmp	SHORT $LN86@stbi__pic_
$LN87@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r12], 0
	je	SHORT $LN88@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, r13
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [r13+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [r13+192], rax
	jmp	SHORT $LN86@stbi__pic_
$LN88@stbi__pic_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN86@stbi__pic_:

; 1628 :    if (s->io.read) {

	cmp	QWORD PTR [r13+16], 0

; 6462 :                   int count = stbi__get8(s), i;

	movzx	esi, cl

; 1628 :    if (s->io.read) {

	je	SHORT $LN192@stbi__pic_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	rax, QWORD PTR [r13+32]
	mov	rcx, QWORD PTR [r13+40]
	call	rax
	test	eax, eax
	je	SHORT $LN195@stbi__pic_

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

	cmp	DWORD PTR [r12], 0
	je	$LN134@stbi__pic_
$LN192@stbi__pic_:

; 6463 :                   if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");

	mov	rax, QWORD PTR [r13+200]
	cmp	QWORD PTR [r13+192], rax
	jae	$LN134@stbi__pic_
$LN195@stbi__pic_:

; 6464 : 
; 6465 :                   if (count >= 128) { // Repeated

	cmp	esi, 128				; 00000080H
	jb	$LN41@stbi__pic_

; 6466 :                      stbi_uc value[4];
; 6467 : 
; 6468 :                      if (count==128)

	jne	SHORT $LN43@stbi__pic_

; 6469 :                         count = stbi__get16be(s);

	mov	rcx, r13
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	esi, eax
	jmp	SHORT $LN44@stbi__pic_
$LN43@stbi__pic_:

; 6470 :                      else
; 6471 :                         count -= 127;

	sub	esi, 127				; 0000007fH
$LN44@stbi__pic_:

; 6472 :                      if (count > left)

	cmp	esi, r14d
	jg	$LN134@stbi__pic_

; 6473 :                         return stbi__errpuc("bad file","scanline overrun");
; 6474 : 
; 6475 :                      if (!stbi__readval(s,packet->channel,value))

	movzx	edi, BYTE PTR [r15]
	lea	r8, QWORD PTR value$3[rsp]
	mov	edx, edi
	mov	rcx, r13
	call	?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ; stbi__readval
	test	rax, rax
	je	$LN139@stbi__pic_

; 6476 :                         return 0;
; 6477 : 
; 6478 :                      for(i=0;i<count;++i, dest += 4)

	test	esi, esi
	jle	$LN27@stbi__pic_
	mov	eax, DWORD PTR value$3[rsp]
	movzx	edx, BYTE PTR value$3[rsp+3]
	movzx	r8d, BYTE PTR value$3[rsp+2]
	movzx	r9d, BYTE PTR value$3[rsp+1]
	mov	ecx, esi
	npad	2
$LL25@stbi__pic_:

; 6385 :       if (channel&mask)

	test	dil, dil
	jns	SHORT $LN100@stbi__pic_

; 6386 :          dest[i]=src[i];

	mov	BYTE PTR [rbx], al
$LN100@stbi__pic_:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;
; 1636 : }
; 1637 : #endif
; 1638 : 
; 1639 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
; 1640 : // nothing
; 1641 : #else
; 1642 : static void stbi__skip(stbi__context *s, int n)
; 1643 : {
; 1644 :    if (n == 0) return;  // already there!
; 1645 :    if (n < 0) {
; 1646 :       s->img_buffer = s->img_buffer_end;
; 1647 :       return;
; 1648 :    }
; 1649 :    if (s->io.read) {
; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1651 :       if (blen < n) {
; 1652 :          s->img_buffer = s->img_buffer_end;
; 1653 :          (s->io.skip)(s->io_user_data, n - blen);
; 1654 :          return;
; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;
; 1658 : }
; 1659 : #endif
; 1660 : 
; 1661 : #if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
; 1662 : // nothing
; 1663 : #else
; 1664 : static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
; 1665 : {
; 1666 :    if (s->io.read) {
; 1667 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1668 :       if (blen < n) {
; 1669 :          int res, count;
; 1670 : 
; 1671 :          memcpy(buffer, s->img_buffer, blen);
; 1672 : 
; 1673 :          count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
; 1674 :          res = (count == (n-blen));
; 1675 :          s->img_buffer = s->img_buffer_end;
; 1676 :          return res;
; 1677 :       }
; 1678 :    }
; 1679 : 
; 1680 :    if (s->img_buffer+n <= s->img_buffer_end) {
; 1681 :       memcpy(buffer, s->img_buffer, n);
; 1682 :       s->img_buffer += n;
; 1683 :       return 1;
; 1684 :    } else
; 1685 :       return 0;
; 1686 : }
; 1687 : #endif
; 1688 : 
; 1689 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1690 : // nothing
; 1691 : #else
; 1692 : static int stbi__get16be(stbi__context *s)
; 1693 : {
; 1694 :    int z = stbi__get8(s);
; 1695 :    return (z << 8) + stbi__get8(s);
; 1696 : }
; 1697 : #endif
; 1698 : 
; 1699 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1700 : // nothing
; 1701 : #else
; 1702 : static stbi__uint32 stbi__get32be(stbi__context *s)
; 1703 : {
; 1704 :    stbi__uint32 z = stbi__get16be(s);
; 1705 :    return (z << 16) + stbi__get16be(s);
; 1706 : }
; 1707 : #endif
; 1708 : 
; 1709 : #if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
; 1710 : // nothing
; 1711 : #else
; 1712 : static int stbi__get16le(stbi__context *s)
; 1713 : {
; 1714 :    int z = stbi__get8(s);
; 1715 :    return z + (stbi__get8(s) << 8);
; 1716 : }
; 1717 : #endif
; 1718 : 
; 1719 : #ifndef STBI_NO_BMP
; 1720 : static stbi__uint32 stbi__get32le(stbi__context *s)
; 1721 : {
; 1722 :    stbi__uint32 z = stbi__get16le(s);
; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;
; 1724 :    return z;
; 1725 : }
; 1726 : #endif
; 1727 : 
; 1728 : #define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
; 1729 : 
; 1730 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1731 : // nothing
; 1732 : #else
; 1733 : //////////////////////////////////////////////////////////////////////////////
; 1734 : //
; 1735 : //  generic converter from built-in img_n to req_comp
; 1736 : //    individual types do this automatically as much as possible (e.g. jpeg
; 1737 : //    does all cases internally since it needs to colorspace convert anyway,
; 1738 : //    and it never has alpha, so very few cases ). png can automatically
; 1739 : //    interleave an alpha=255 channel, but falls back to this for other cases
; 1740 : //
; 1741 : //  assume data buffer is malloced, so malloc a new one and free that one
; 1742 : //  only failure mode is malloc failing
; 1743 : 
; 1744 : static stbi_uc stbi__compute_y(int r, int g, int b)
; 1745 : {
; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1747 : }
; 1748 : #endif
; 1749 : 
; 1750 : #if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1751 : // nothing
; 1752 : #else
; 1753 : static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1754 : {
; 1755 :    int i,j;
; 1756 :    unsigned char *good;
; 1757 : 
; 1758 :    if (req_comp == img_n) return data;
; 1759 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1760 : 
; 1761 :    good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
; 1762 :    if (good == NULL) {
; 1763 :       STBI_FREE(data);
; 1764 :       return stbi__errpuc("outofmem", "Out of memory");
; 1765 :    }
; 1766 : 
; 1767 :    for (j=0; j < (int) y; ++j) {
; 1768 :       unsigned char *src  = data + j * x * img_n   ;
; 1769 :       unsigned char *dest = good + j * x * req_comp;
; 1770 : 
; 1771 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1772 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1773 :       // convert source image with img_n components to one with req_comp components;
; 1774 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1775 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1776 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
; 1777 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1778 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
; 1779 :          STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
; 1780 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1781 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
; 1782 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
; 1783 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1784 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
; 1785 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1786 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1787 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
; 1788 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
; 1789 :       }
; 1790 :       #undef STBI__CASE
; 1791 :    }
; 1792 : 
; 1793 :    STBI_FREE(data);
; 1794 :    return good;
; 1795 : }
; 1796 : #endif
; 1797 : 
; 1798 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1799 : // nothing
; 1800 : #else
; 1801 : static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
; 1802 : {
; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1804 : }
; 1805 : #endif
; 1806 : 
; 1807 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1808 : // nothing
; 1809 : #else
; 1810 : static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1811 : {
; 1812 :    int i,j;
; 1813 :    stbi__uint16 *good;
; 1814 : 
; 1815 :    if (req_comp == img_n) return data;
; 1816 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1817 : 
; 1818 :    good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
; 1819 :    if (good == NULL) {
; 1820 :       STBI_FREE(data);
; 1821 :       return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1822 :    }
; 1823 : 
; 1824 :    for (j=0; j < (int) y; ++j) {
; 1825 :       stbi__uint16 *src  = data + j * x * img_n   ;
; 1826 :       stbi__uint16 *dest = good + j * x * req_comp;
; 1827 : 
; 1828 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1829 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1830 :       // convert source image with img_n components to one with req_comp components;
; 1831 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1832 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1833 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
; 1834 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1835 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
; 1836 :          STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
; 1837 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1838 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
; 1839 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
; 1840 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1841 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
; 1842 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1843 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1844 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
; 1845 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
; 1846 :       }
; 1847 :       #undef STBI__CASE
; 1848 :    }
; 1849 : 
; 1850 :    STBI_FREE(data);
; 1851 :    return good;
; 1852 : }
; 1853 : #endif
; 1854 : 
; 1855 : #ifndef STBI_NO_LINEAR
; 1856 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
; 1857 : {
; 1858 :    int i,k,n;
; 1859 :    float *output;
; 1860 :    if (!data) return NULL;
; 1861 :    output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
; 1862 :    if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
; 1863 :    // compute number of non-alpha components
; 1864 :    if (comp & 1) n = comp; else n = comp-1;
; 1865 :    for (i=0; i < x*y; ++i) {
; 1866 :       for (k=0; k < n; ++k) {
; 1867 :          output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
; 1868 :       }
; 1869 :    }
; 1870 :    if (n < comp) {
; 1871 :       for (i=0; i < x*y; ++i) {
; 1872 :          output[i*comp + n] = data[i*comp + n]/255.0f;
; 1873 :       }
; 1874 :    }
; 1875 :    STBI_FREE(data);
; 1876 :    return output;
; 1877 : }
; 1878 : #endif
; 1879 : 
; 1880 : #ifndef STBI_NO_HDR
; 1881 : #define stbi__float2int(x)   ((int) (x))
; 1882 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
; 1883 : {
; 1884 :    int i,k,n;
; 1885 :    stbi_uc *output;
; 1886 :    if (!data) return NULL;
; 1887 :    output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
; 1888 :    if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
; 1889 :    // compute number of non-alpha components
; 1890 :    if (comp & 1) n = comp; else n = comp-1;
; 1891 :    for (i=0; i < x*y; ++i) {
; 1892 :       for (k=0; k < n; ++k) {
; 1893 :          float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
; 1894 :          if (z < 0) z = 0;
; 1895 :          if (z > 255) z = 255;
; 1896 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1897 :       }
; 1898 :       if (k < comp) {
; 1899 :          float z = data[i*comp+k] * 255 + 0.5f;
; 1900 :          if (z < 0) z = 0;
; 1901 :          if (z > 255) z = 255;
; 1902 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1903 :       }
; 1904 :    }
; 1905 :    STBI_FREE(data);
; 1906 :    return output;
; 1907 : }
; 1908 : #endif
; 1909 : 
; 1910 : //////////////////////////////////////////////////////////////////////////////
; 1911 : //
; 1912 : //  "baseline" JPEG/JFIF decoder
; 1913 : //
; 1914 : //    simple implementation
; 1915 : //      - doesn't support delayed output of y-dimension
; 1916 : //      - simple interface (only one output format: 8-bit interleaved RGB)
; 1917 : //      - doesn't try to recover corrupt jpegs
; 1918 : //      - doesn't allow partial loading, loading multiple at once
; 1919 : //      - still fast on x86 (copying globals into locals doesn't help x86)
; 1920 : //      - allocates lots of intermediate memory (full size of all components)
; 1921 : //        - non-interleaved case requires this anyway
; 1922 : //        - allows good upsampling (see next)
; 1923 : //    high-quality
; 1924 : //      - upsampled channels are bilinearly interpolated, even across blocks
; 1925 : //      - quality integer IDCT derived from IJG's 'slow'
; 1926 : //    performance
; 1927 : //      - fast huffman; reasonable integer IDCT
; 1928 : //      - some SIMD kernels for common paths on targets with SSE2/NEON
; 1929 : //      - uses a lot of intermediate memory, could cache poorly
; 1930 : 
; 1931 : #ifndef STBI_NO_JPEG
; 1932 : 
; 1933 : // huffman decoding acceleration
; 1934 : #define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
; 1935 : 
; 1936 : typedef struct
; 1937 : {
; 1938 :    stbi_uc  fast[1 << FAST_BITS];
; 1939 :    // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
; 1940 :    stbi__uint16 code[256];
; 1941 :    stbi_uc  values[256];
; 1942 :    stbi_uc  size[257];
; 1943 :    unsigned int maxcode[18];
; 1944 :    int    delta[17];   // old 'firstsymbol' - old 'firstcode'
; 1945 : } stbi__huffman;
; 1946 : 
; 1947 : typedef struct
; 1948 : {
; 1949 :    stbi__context *s;
; 1950 :    stbi__huffman huff_dc[4];
; 1951 :    stbi__huffman huff_ac[4];
; 1952 :    stbi__uint16 dequant[4][64];
; 1953 :    stbi__int16 fast_ac[4][1 << FAST_BITS];
; 1954 : 
; 1955 : // sizes for components, interleaved MCUs
; 1956 :    int img_h_max, img_v_max;
; 1957 :    int img_mcu_x, img_mcu_y;
; 1958 :    int img_mcu_w, img_mcu_h;
; 1959 : 
; 1960 : // definition of jpeg image component
; 1961 :    struct
; 1962 :    {
; 1963 :       int id;
; 1964 :       int h,v;
; 1965 :       int tq;
; 1966 :       int hd,ha;
; 1967 :       int dc_pred;
; 1968 : 
; 1969 :       int x,y,w2,h2;
; 1970 :       stbi_uc *data;
; 1971 :       void *raw_data, *raw_coeff;
; 1972 :       stbi_uc *linebuf;
; 1973 :       short   *coeff;   // progressive only
; 1974 :       int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
; 1975 :    } img_comp[4];
; 1976 : 
; 1977 :    stbi__uint32   code_buffer; // jpeg entropy-coded buffer
; 1978 :    int            code_bits;   // number of valid bits
; 1979 :    unsigned char  marker;      // marker seen while filling entropy buffer
; 1980 :    int            nomore;      // flag if we saw a marker so must stop
; 1981 : 
; 1982 :    int            progressive;
; 1983 :    int            spec_start;
; 1984 :    int            spec_end;
; 1985 :    int            succ_high;
; 1986 :    int            succ_low;
; 1987 :    int            eob_run;
; 1988 :    int            jfif;
; 1989 :    int            app14_color_transform; // Adobe APP14 tag
; 1990 :    int            rgb;
; 1991 : 
; 1992 :    int scan_n, order[4];
; 1993 :    int restart_interval, todo;
; 1994 : 
; 1995 : // kernels
; 1996 :    void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
; 1997 :    void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
; 1998 :    stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
; 1999 : } stbi__jpeg;
; 2000 : 
; 2001 : static int stbi__build_huffman(stbi__huffman *h, int *count)
; 2002 : {
; 2003 :    int i,j,k=0;
; 2004 :    unsigned int code;
; 2005 :    // build size list for each symbol (from JPEG spec)
; 2006 :    for (i=0; i < 16; ++i) {
; 2007 :       for (j=0; j < count[i]; ++j) {
; 2008 :          h->size[k++] = (stbi_uc) (i+1);
; 2009 :          if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");
; 2010 :       }
; 2011 :    }
; 2012 :    h->size[k] = 0;
; 2013 : 
; 2014 :    // compute actual symbols (from jpeg spec)
; 2015 :    code = 0;
; 2016 :    k = 0;
; 2017 :    for(j=1; j <= 16; ++j) {
; 2018 :       // compute delta to add to code to compute symbol id
; 2019 :       h->delta[j] = k - code;
; 2020 :       if (h->size[k] == j) {
; 2021 :          while (h->size[k] == j)
; 2022 :             h->code[k++] = (stbi__uint16) (code++);
; 2023 :          if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
; 2024 :       }
; 2025 :       // compute largest code + 1 for this size, preshifted as needed later
; 2026 :       h->maxcode[j] = code << (16-j);
; 2027 :       code <<= 1;
; 2028 :    }
; 2029 :    h->maxcode[j] = 0xffffffff;
; 2030 : 
; 2031 :    // build non-spec acceleration table; 255 is flag for not-accelerated
; 2032 :    memset(h->fast, 255, 1 << FAST_BITS);
; 2033 :    for (i=0; i < k; ++i) {
; 2034 :       int s = h->size[i];
; 2035 :       if (s <= FAST_BITS) {
; 2036 :          int c = h->code[i] << (FAST_BITS-s);
; 2037 :          int m = 1 << (FAST_BITS-s);
; 2038 :          for (j=0; j < m; ++j) {
; 2039 :             h->fast[c+j] = (stbi_uc) i;
; 2040 :          }
; 2041 :       }
; 2042 :    }
; 2043 :    return 1;
; 2044 : }
; 2045 : 
; 2046 : // build a table that decodes both magnitude and value of small ACs in
; 2047 : // one go.
; 2048 : static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
; 2049 : {
; 2050 :    int i;
; 2051 :    for (i=0; i < (1 << FAST_BITS); ++i) {
; 2052 :       stbi_uc fast = h->fast[i];
; 2053 :       fast_ac[i] = 0;
; 2054 :       if (fast < 255) {
; 2055 :          int rs = h->values[fast];
; 2056 :          int run = (rs >> 4) & 15;
; 2057 :          int magbits = rs & 15;
; 2058 :          int len = h->size[fast];
; 2059 : 
; 2060 :          if (magbits && len + magbits <= FAST_BITS) {
; 2061 :             // magnitude code followed by receive_extend code
; 2062 :             int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
; 2063 :             int m = 1 << (magbits - 1);
; 2064 :             if (k < m) k += (~0U << magbits) + 1;
; 2065 :             // if the result is small enough, we can fit it in fast_ac table
; 2066 :             if (k >= -128 && k <= 127)
; 2067 :                fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
; 2068 :          }
; 2069 :       }
; 2070 :    }
; 2071 : }
; 2072 : 
; 2073 : static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
; 2074 : {
; 2075 :    do {
; 2076 :       unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
; 2077 :       if (b == 0xff) {
; 2078 :          int c = stbi__get8(j->s);
; 2079 :          while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
; 2080 :          if (c != 0) {
; 2081 :             j->marker = (unsigned char) c;
; 2082 :             j->nomore = 1;
; 2083 :             return;
; 2084 :          }
; 2085 :       }
; 2086 :       j->code_buffer |= b << (24 - j->code_bits);
; 2087 :       j->code_bits += 8;
; 2088 :    } while (j->code_bits <= 24);
; 2089 : }
; 2090 : 
; 2091 : // (1 << n) - 1
; 2092 : static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
; 2093 : 
; 2094 : // decode a jpeg huffman value from the bitstream
; 2095 : stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
; 2096 : {
; 2097 :    unsigned int temp;
; 2098 :    int c,k;
; 2099 : 
; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2105 :    k = h->fast[c];
; 2106 :    if (k < 255) {
; 2107 :       int s = h->size[k];
; 2108 :       if (s > j->code_bits)
; 2109 :          return -1;
; 2110 :       j->code_buffer <<= s;
; 2111 :       j->code_bits -= s;
; 2112 :       return h->values[k];
; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;
; 2122 :    for (k=FAST_BITS+1 ; ; ++k)
; 2123 :       if (temp < h->maxcode[k])
; 2124 :          break;
; 2125 :    if (k == 17) {
; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;
; 2128 :       return -1;
; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)
; 2132 :       return -1;
; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!
; 2137 :        return -1;
; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;
; 2142 :    j->code_buffer <<= k;
; 2143 :    return h->values[c];
; 2144 : }
; 2145 : 
; 2146 : // bias[n] = (-1<<n) + 1
; 2147 : static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};
; 2148 : 
; 2149 : // combined JPEG 'receive' and JPEG 'extend', since baseline
; 2150 : // always extends everything it receives.
; 2151 : stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
; 2152 : {
; 2153 :    unsigned int k;
; 2154 :    int sgn;
; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
; 2159 :    k = stbi_lrot(j->code_buffer, n);
; 2160 :    j->code_buffer = k & ~stbi__bmask[n];
; 2161 :    k &= stbi__bmask[n];
; 2162 :    j->code_bits -= n;
; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));
; 2164 : }
; 2165 : 
; 2166 : // get some unsigned bits
; 2167 : stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
; 2168 : {
; 2169 :    unsigned int k;
; 2170 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2171 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2172 :    k = stbi_lrot(j->code_buffer, n);
; 2173 :    j->code_buffer = k & ~stbi__bmask[n];
; 2174 :    k &= stbi__bmask[n];
; 2175 :    j->code_bits -= n;
; 2176 :    return k;
; 2177 : }
; 2178 : 
; 2179 : stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
; 2180 : {
; 2181 :    unsigned int k;
; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2184 :    k = j->code_buffer;
; 2185 :    j->code_buffer <<= 1;
; 2186 :    --j->code_bits;
; 2187 :    return k & 0x80000000;
; 2188 : }
; 2189 : 
; 2190 : // given a value that's at position X in the zigzag stream,
; 2191 : // where does it appear in the 8x8 matrix coded as row-major?
; 2192 : static const stbi_uc stbi__jpeg_dezigzag[64+15] =
; 2193 : {
; 2194 :     0,  1,  8, 16,  9,  2,  3, 10,
; 2195 :    17, 24, 32, 25, 18, 11,  4,  5,
; 2196 :    12, 19, 26, 33, 40, 48, 41, 34,
; 2197 :    27, 20, 13,  6,  7, 14, 21, 28,
; 2198 :    35, 42, 49, 56, 57, 50, 43, 36,
; 2199 :    29, 22, 15, 23, 30, 37, 44, 51,
; 2200 :    58, 59, 52, 45, 38, 31, 39, 46,
; 2201 :    53, 60, 61, 54, 47, 55, 62, 63,
; 2202 :    // let corrupt input sample past end
; 2203 :    63, 63, 63, 63, 63, 63, 63, 63,
; 2204 :    63, 63, 63, 63, 63, 63, 63
; 2205 : };
; 2206 : 
; 2207 : // decode one 64-entry block--
; 2208 : static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
; 2209 : {
; 2210 :    int diff,dc,k;
; 2211 :    int t;
; 2212 : 
; 2213 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2214 :    t = stbi__jpeg_huff_decode(j, hdc);
; 2215 :    if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");
; 2216 : 
; 2217 :    // 0 all the ac values now so we can do it 32-bits at a time
; 2218 :    memset(data,0,64*sizeof(data[0]));
; 2219 : 
; 2220 :    diff = t ? stbi__extend_receive(j, t) : 0;
; 2221 :    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");
; 2222 :    dc = j->img_comp[b].dc_pred + diff;
; 2223 :    j->img_comp[b].dc_pred = dc;
; 2224 :    if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2225 :    data[0] = (short) (dc * dequant[0]);
; 2226 : 
; 2227 :    // decode AC components, see JPEG spec
; 2228 :    k = 1;
; 2229 :    do {
; 2230 :       unsigned int zig;
; 2231 :       int c,r,s;
; 2232 :       if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2233 :       c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2234 :       r = fac[c];
; 2235 :       if (r) { // fast-AC path
; 2236 :          k += (r >> 4) & 15; // run
; 2237 :          s = r & 15; // combined length
; 2238 :          if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2239 :          j->code_buffer <<= s;
; 2240 :          j->code_bits -= s;
; 2241 :          // decode into unzigzag'd location
; 2242 :          zig = stbi__jpeg_dezigzag[k++];
; 2243 :          data[zig] = (short) ((r >> 8) * dequant[zig]);
; 2244 :       } else {
; 2245 :          int rs = stbi__jpeg_huff_decode(j, hac);
; 2246 :          if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2247 :          s = rs & 15;
; 2248 :          r = rs >> 4;
; 2249 :          if (s == 0) {
; 2250 :             if (rs != 0xf0) break; // end block
; 2251 :             k += 16;
; 2252 :          } else {
; 2253 :             k += r;
; 2254 :             // decode into unzigzag'd location
; 2255 :             zig = stbi__jpeg_dezigzag[k++];
; 2256 :             data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
; 2257 :          }
; 2258 :       }
; 2259 :    } while (k < 64);
; 2260 :    return 1;
; 2261 : }
; 2262 : 
; 2263 : static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
; 2264 : {
; 2265 :    int diff,dc;
; 2266 :    int t;
; 2267 :    if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2268 : 
; 2269 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2270 : 
; 2271 :    if (j->succ_high == 0) {
; 2272 :       // first scan for DC coefficient, must be first
; 2273 :       memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
; 2274 :       t = stbi__jpeg_huff_decode(j, hdc);
; 2275 :       if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2276 :       diff = t ? stbi__extend_receive(j, t) : 0;
; 2277 : 
; 2278 :       if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");
; 2279 :       dc = j->img_comp[b].dc_pred + diff;
; 2280 :       j->img_comp[b].dc_pred = dc;
; 2281 :       if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2282 :       data[0] = (short) (dc * (1 << j->succ_low));
; 2283 :    } else {
; 2284 :       // refinement scan for DC coefficient
; 2285 :       if (stbi__jpeg_get_bit(j))
; 2286 :          data[0] += (short) (1 << j->succ_low);
; 2287 :    }
; 2288 :    return 1;
; 2289 : }
; 2290 : 
; 2291 : // @OPTIMIZE: store non-zigzagged during the decode passes,
; 2292 : // and only de-zigzag when dequantizing
; 2293 : static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
; 2294 : {
; 2295 :    int k;
; 2296 :    if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2297 : 
; 2298 :    if (j->succ_high == 0) {
; 2299 :       int shift = j->succ_low;
; 2300 : 
; 2301 :       if (j->eob_run) {
; 2302 :          --j->eob_run;
; 2303 :          return 1;
; 2304 :       }
; 2305 : 
; 2306 :       k = j->spec_start;
; 2307 :       do {
; 2308 :          unsigned int zig;
; 2309 :          int c,r,s;
; 2310 :          if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2311 :          c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2312 :          r = fac[c];
; 2313 :          if (r) { // fast-AC path
; 2314 :             k += (r >> 4) & 15; // run
; 2315 :             s = r & 15; // combined length
; 2316 :             if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2317 :             j->code_buffer <<= s;
; 2318 :             j->code_bits -= s;
; 2319 :             zig = stbi__jpeg_dezigzag[k++];
; 2320 :             data[zig] = (short) ((r >> 8) * (1 << shift));
; 2321 :          } else {
; 2322 :             int rs = stbi__jpeg_huff_decode(j, hac);
; 2323 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2324 :             s = rs & 15;
; 2325 :             r = rs >> 4;
; 2326 :             if (s == 0) {
; 2327 :                if (r < 15) {
; 2328 :                   j->eob_run = (1 << r);
; 2329 :                   if (r)
; 2330 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2331 :                   --j->eob_run;
; 2332 :                   break;
; 2333 :                }
; 2334 :                k += 16;
; 2335 :             } else {
; 2336 :                k += r;
; 2337 :                zig = stbi__jpeg_dezigzag[k++];
; 2338 :                data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
; 2339 :             }
; 2340 :          }
; 2341 :       } while (k <= j->spec_end);
; 2342 :    } else {
; 2343 :       // refinement scan for these AC coefficients
; 2344 : 
; 2345 :       short bit = (short) (1 << j->succ_low);
; 2346 : 
; 2347 :       if (j->eob_run) {
; 2348 :          --j->eob_run;
; 2349 :          for (k = j->spec_start; k <= j->spec_end; ++k) {
; 2350 :             short *p = &data[stbi__jpeg_dezigzag[k]];
; 2351 :             if (*p != 0)
; 2352 :                if (stbi__jpeg_get_bit(j))
; 2353 :                   if ((*p & bit)==0) {
; 2354 :                      if (*p > 0)
; 2355 :                         *p += bit;
; 2356 :                      else
; 2357 :                         *p -= bit;
; 2358 :                   }
; 2359 :          }
; 2360 :       } else {
; 2361 :          k = j->spec_start;
; 2362 :          do {
; 2363 :             int r,s;
; 2364 :             int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
; 2365 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2366 :             s = rs & 15;
; 2367 :             r = rs >> 4;
; 2368 :             if (s == 0) {
; 2369 :                if (r < 15) {
; 2370 :                   j->eob_run = (1 << r) - 1;
; 2371 :                   if (r)
; 2372 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2373 :                   r = 64; // force end of block
; 2374 :                } else {
; 2375 :                   // r=15 s=0 should write 16 0s, so we just do
; 2376 :                   // a run of 15 0s and then write s (which is 0),
; 2377 :                   // so we don't have to do anything special here
; 2378 :                }
; 2379 :             } else {
; 2380 :                if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
; 2381 :                // sign bit
; 2382 :                if (stbi__jpeg_get_bit(j))
; 2383 :                   s = bit;
; 2384 :                else
; 2385 :                   s = -bit;
; 2386 :             }
; 2387 : 
; 2388 :             // advance by r
; 2389 :             while (k <= j->spec_end) {
; 2390 :                short *p = &data[stbi__jpeg_dezigzag[k++]];
; 2391 :                if (*p != 0) {
; 2392 :                   if (stbi__jpeg_get_bit(j))
; 2393 :                      if ((*p & bit)==0) {
; 2394 :                         if (*p > 0)
; 2395 :                            *p += bit;
; 2396 :                         else
; 2397 :                            *p -= bit;
; 2398 :                      }
; 2399 :                } else {
; 2400 :                   if (r == 0) {
; 2401 :                      *p = (short) s;
; 2402 :                      break;
; 2403 :                   }
; 2404 :                   --r;
; 2405 :                }
; 2406 :             }
; 2407 :          } while (k <= j->spec_end);
; 2408 :       }
; 2409 :    }
; 2410 :    return 1;
; 2411 : }
; 2412 : 
; 2413 : // take a -128..127 value and stbi__clamp it and convert to 0..255
; 2414 : stbi_inline static stbi_uc stbi__clamp(int x)
; 2415 : {
; 2416 :    // trick to use a single test to catch both cases
; 2417 :    if ((unsigned int) x > 255) {
; 2418 :       if (x < 0) return 0;
; 2419 :       if (x > 255) return 255;
; 2420 :    }
; 2421 :    return (stbi_uc) x;
; 2422 : }
; 2423 : 
; 2424 : #define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
; 2425 : #define stbi__fsh(x)  ((x) * 4096)
; 2426 : 
; 2427 : // derived from jidctint -- DCT_ISLOW
; 2428 : #define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
; 2429 :    int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
; 2430 :    p2 = s2;                                    \
; 2431 :    p3 = s6;                                    \
; 2432 :    p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
; 2433 :    t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
; 2434 :    t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
; 2435 :    p2 = s0;                                    \
; 2436 :    p3 = s4;                                    \
; 2437 :    t0 = stbi__fsh(p2+p3);                      \
; 2438 :    t1 = stbi__fsh(p2-p3);                      \
; 2439 :    x0 = t0+t3;                                 \
; 2440 :    x3 = t0-t3;                                 \
; 2441 :    x1 = t1+t2;                                 \
; 2442 :    x2 = t1-t2;                                 \
; 2443 :    t0 = s7;                                    \
; 2444 :    t1 = s5;                                    \
; 2445 :    t2 = s3;                                    \
; 2446 :    t3 = s1;                                    \
; 2447 :    p3 = t0+t2;                                 \
; 2448 :    p4 = t1+t3;                                 \
; 2449 :    p1 = t0+t3;                                 \
; 2450 :    p2 = t1+t2;                                 \
; 2451 :    p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
; 2452 :    t0 = t0*stbi__f2f( 0.298631336f);           \
; 2453 :    t1 = t1*stbi__f2f( 2.053119869f);           \
; 2454 :    t2 = t2*stbi__f2f( 3.072711026f);           \
; 2455 :    t3 = t3*stbi__f2f( 1.501321110f);           \
; 2456 :    p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
; 2457 :    p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
; 2458 :    p3 = p3*stbi__f2f(-1.961570560f);           \
; 2459 :    p4 = p4*stbi__f2f(-0.390180644f);           \
; 2460 :    t3 += p1+p4;                                \
; 2461 :    t2 += p2+p3;                                \
; 2462 :    t1 += p2+p4;                                \
; 2463 :    t0 += p1+p3;
; 2464 : 
; 2465 : static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
; 2466 : {
; 2467 :    int i,val[64],*v=val;
; 2468 :    stbi_uc *o;
; 2469 :    short *d = data;
; 2470 : 
; 2471 :    // columns
; 2472 :    for (i=0; i < 8; ++i,++d, ++v) {
; 2473 :       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2474 :       if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2475 :            && d[40]==0 && d[48]==0 && d[56]==0) {
; 2476 :          //    no shortcut                 0     seconds
; 2477 :          //    (1|2|3|4|5|6|7)==0          0     seconds
; 2478 :          //    all separate               -0.047 seconds
; 2479 :          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2480 :          int dcterm = d[0]*4;
; 2481 :          v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
; 2482 :       } else {
; 2483 :          STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
; 2484 :          // constants scaled things up by 1<<12; let's bring them back
; 2485 :          // down, but keep 2 extra bits of precision
; 2486 :          x0 += 512; x1 += 512; x2 += 512; x3 += 512;
; 2487 :          v[ 0] = (x0+t3) >> 10;
; 2488 :          v[56] = (x0-t3) >> 10;
; 2489 :          v[ 8] = (x1+t2) >> 10;
; 2490 :          v[48] = (x1-t2) >> 10;
; 2491 :          v[16] = (x2+t1) >> 10;
; 2492 :          v[40] = (x2-t1) >> 10;
; 2493 :          v[24] = (x3+t0) >> 10;
; 2494 :          v[32] = (x3-t0) >> 10;
; 2495 :       }
; 2496 :    }
; 2497 : 
; 2498 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
; 2499 :       // no fast case since the first 1D IDCT spread components out
; 2500 :       STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
; 2501 :       // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2502 :       // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2503 :       // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2504 :       // so we want to round that, which means adding 0.5 * 1<<17,
; 2505 :       // aka 65536. Also, we'll end up with -128 to 127 that we want
; 2506 :       // to encode as 0..255 by adding 128, so we'll add that before the shift
; 2507 :       x0 += 65536 + (128<<17);
; 2508 :       x1 += 65536 + (128<<17);
; 2509 :       x2 += 65536 + (128<<17);
; 2510 :       x3 += 65536 + (128<<17);
; 2511 :       // tried computing the shifts into temps, or'ing the temps to see
; 2512 :       // if any were out of range, but that was slower
; 2513 :       o[0] = stbi__clamp((x0+t3) >> 17);
; 2514 :       o[7] = stbi__clamp((x0-t3) >> 17);
; 2515 :       o[1] = stbi__clamp((x1+t2) >> 17);
; 2516 :       o[6] = stbi__clamp((x1-t2) >> 17);
; 2517 :       o[2] = stbi__clamp((x2+t1) >> 17);
; 2518 :       o[5] = stbi__clamp((x2-t1) >> 17);
; 2519 :       o[3] = stbi__clamp((x3+t0) >> 17);
; 2520 :       o[4] = stbi__clamp((x3-t0) >> 17);
; 2521 :    }
; 2522 : }
; 2523 : 
; 2524 : #ifdef STBI_SSE2
; 2525 : // sse2 integer IDCT. not the fastest possible implementation but it
; 2526 : // produces bit-identical results to the generic C version so it's
; 2527 : // fully "transparent".
; 2528 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2529 : {
; 2530 :    // This is constructed to match our regular (generic) integer IDCT exactly.
; 2531 :    __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2532 :    __m128i tmp;
; 2533 : 
; 2534 :    // dot product constant: even elems=x, odd elems=y
; 2535 :    #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2536 : 
; 2537 :    // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2538 :    // out(1) = c1[even]*x + c1[odd]*y
; 2539 :    #define dct_rot(out0,out1, x,y,c0,c1) \
; 2540 :       __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2541 :       __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2542 :       __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2543 :       __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2544 :       __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2545 :       __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2546 : 
; 2547 :    // out = in << 12  (in 16-bit, out 32-bit)
; 2548 :    #define dct_widen(out, in) \
; 2549 :       __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2550 :       __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2551 : 
; 2552 :    // wide add
; 2553 :    #define dct_wadd(out, a, b) \
; 2554 :       __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2555 :       __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2556 : 
; 2557 :    // wide sub
; 2558 :    #define dct_wsub(out, a, b) \
; 2559 :       __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2560 :       __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2561 : 
; 2562 :    // butterfly a/b, add bias, then shift by "s" and pack
; 2563 :    #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2564 :       { \
; 2565 :          __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2566 :          __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2567 :          dct_wadd(sum, abiased, b); \
; 2568 :          dct_wsub(dif, abiased, b); \
; 2569 :          out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2570 :          out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2571 :       }
; 2572 : 
; 2573 :    // 8-bit interleave step (for transposes)
; 2574 :    #define dct_interleave8(a, b) \
; 2575 :       tmp = a; \
; 2576 :       a = _mm_unpacklo_epi8(a, b); \
; 2577 :       b = _mm_unpackhi_epi8(tmp, b)
; 2578 : 
; 2579 :    // 16-bit interleave step (for transposes)
; 2580 :    #define dct_interleave16(a, b) \
; 2581 :       tmp = a; \
; 2582 :       a = _mm_unpacklo_epi16(a, b); \
; 2583 :       b = _mm_unpackhi_epi16(tmp, b)
; 2584 : 
; 2585 :    #define dct_pass(bias,shift) \
; 2586 :       { \
; 2587 :          /* even part */ \
; 2588 :          dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2589 :          __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2590 :          __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2591 :          dct_widen(t0e, sum04); \
; 2592 :          dct_widen(t1e, dif04); \
; 2593 :          dct_wadd(x0, t0e, t3e); \
; 2594 :          dct_wsub(x3, t0e, t3e); \
; 2595 :          dct_wadd(x1, t1e, t2e); \
; 2596 :          dct_wsub(x2, t1e, t2e); \
; 2597 :          /* odd part */ \
; 2598 :          dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2599 :          dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2600 :          __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2601 :          __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2602 :          dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2603 :          dct_wadd(x4, y0o, y4o); \
; 2604 :          dct_wadd(x5, y1o, y5o); \
; 2605 :          dct_wadd(x6, y2o, y5o); \
; 2606 :          dct_wadd(x7, y3o, y4o); \
; 2607 :          dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2608 :          dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2609 :          dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2610 :          dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2611 :       }
; 2612 : 
; 2613 :    __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
; 2614 :    __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
; 2615 :    __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
; 2616 :    __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
; 2617 :    __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
; 2618 :    __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
; 2619 :    __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
; 2620 :    __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
; 2621 : 
; 2622 :    // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2623 :    __m128i bias_0 = _mm_set1_epi32(512);
; 2624 :    __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
; 2625 : 
; 2626 :    // load
; 2627 :    row0 = _mm_load_si128((const __m128i *) (data + 0*8));
; 2628 :    row1 = _mm_load_si128((const __m128i *) (data + 1*8));
; 2629 :    row2 = _mm_load_si128((const __m128i *) (data + 2*8));
; 2630 :    row3 = _mm_load_si128((const __m128i *) (data + 3*8));
; 2631 :    row4 = _mm_load_si128((const __m128i *) (data + 4*8));
; 2632 :    row5 = _mm_load_si128((const __m128i *) (data + 5*8));
; 2633 :    row6 = _mm_load_si128((const __m128i *) (data + 6*8));
; 2634 :    row7 = _mm_load_si128((const __m128i *) (data + 7*8));
; 2635 : 
; 2636 :    // column pass
; 2637 :    dct_pass(bias_0, 10);
; 2638 : 
; 2639 :    {
; 2640 :       // 16bit 8x8 transpose pass 1
; 2641 :       dct_interleave16(row0, row4);
; 2642 :       dct_interleave16(row1, row5);
; 2643 :       dct_interleave16(row2, row6);
; 2644 :       dct_interleave16(row3, row7);
; 2645 : 
; 2646 :       // transpose pass 2
; 2647 :       dct_interleave16(row0, row2);
; 2648 :       dct_interleave16(row1, row3);
; 2649 :       dct_interleave16(row4, row6);
; 2650 :       dct_interleave16(row5, row7);
; 2651 : 
; 2652 :       // transpose pass 3
; 2653 :       dct_interleave16(row0, row1);
; 2654 :       dct_interleave16(row2, row3);
; 2655 :       dct_interleave16(row4, row5);
; 2656 :       dct_interleave16(row6, row7);
; 2657 :    }
; 2658 : 
; 2659 :    // row pass
; 2660 :    dct_pass(bias_1, 17);
; 2661 : 
; 2662 :    {
; 2663 :       // pack
; 2664 :       __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
; 2665 :       __m128i p1 = _mm_packus_epi16(row2, row3);
; 2666 :       __m128i p2 = _mm_packus_epi16(row4, row5);
; 2667 :       __m128i p3 = _mm_packus_epi16(row6, row7);
; 2668 : 
; 2669 :       // 8bit 8x8 transpose pass 1
; 2670 :       dct_interleave8(p0, p2); // a0e0a1e1...
; 2671 :       dct_interleave8(p1, p3); // c0g0c1g1...
; 2672 : 
; 2673 :       // transpose pass 2
; 2674 :       dct_interleave8(p0, p1); // a0c0e0g0...
; 2675 :       dct_interleave8(p2, p3); // b0d0f0h0...
; 2676 : 
; 2677 :       // transpose pass 3
; 2678 :       dct_interleave8(p0, p2); // a0b0c0d0...
; 2679 :       dct_interleave8(p1, p3); // a4b4c4d4...
; 2680 : 
; 2681 :       // store
; 2682 :       _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
; 2683 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
; 2684 :       _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
; 2685 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
; 2686 :       _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
; 2687 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
; 2688 :       _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
; 2689 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
; 2690 :    }
; 2691 : 
; 2692 : #undef dct_const
; 2693 : #undef dct_rot
; 2694 : #undef dct_widen
; 2695 : #undef dct_wadd
; 2696 : #undef dct_wsub
; 2697 : #undef dct_bfly32o
; 2698 : #undef dct_interleave8
; 2699 : #undef dct_interleave16
; 2700 : #undef dct_pass
; 2701 : }
; 2702 : 
; 2703 : #endif // STBI_SSE2
; 2704 : 
; 2705 : #ifdef STBI_NEON
; 2706 : 
; 2707 : // NEON integer IDCT. should produce bit-identical
; 2708 : // results to the generic C version.
; 2709 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2710 : {
; 2711 :    int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;
; 2712 : 
; 2713 :    int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
; 2714 :    int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
; 2715 :    int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
; 2716 :    int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
; 2717 :    int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
; 2718 :    int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
; 2719 :    int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
; 2720 :    int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
; 2721 :    int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
; 2722 :    int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
; 2723 :    int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
; 2724 :    int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));
; 2725 : 
; 2726 : #define dct_long_mul(out, inq, coeff) \
; 2727 :    int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
; 2728 :    int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)
; 2729 : 
; 2730 : #define dct_long_mac(out, acc, inq, coeff) \
; 2731 :    int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
; 2732 :    int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)
; 2733 : 
; 2734 : #define dct_widen(out, inq) \
; 2735 :    int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
; 2736 :    int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)
; 2737 : 
; 2738 : // wide add
; 2739 : #define dct_wadd(out, a, b) \
; 2740 :    int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
; 2741 :    int32x4_t out##_h = vaddq_s32(a##_h, b##_h)
; 2742 : 
; 2743 : // wide sub
; 2744 : #define dct_wsub(out, a, b) \
; 2745 :    int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
; 2746 :    int32x4_t out##_h = vsubq_s32(a##_h, b##_h)
; 2747 : 
; 2748 : // butterfly a/b, then shift using "shiftop" by "s" and pack
; 2749 : #define dct_bfly32o(out0,out1, a,b,shiftop,s) \
; 2750 :    { \
; 2751 :       dct_wadd(sum, a, b); \
; 2752 :       dct_wsub(dif, a, b); \
; 2753 :       out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
; 2754 :       out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
; 2755 :    }
; 2756 : 
; 2757 : #define dct_pass(shiftop, shift) \
; 2758 :    { \
; 2759 :       /* even part */ \
; 2760 :       int16x8_t sum26 = vaddq_s16(row2, row6); \
; 2761 :       dct_long_mul(p1e, sum26, rot0_0); \
; 2762 :       dct_long_mac(t2e, p1e, row6, rot0_1); \
; 2763 :       dct_long_mac(t3e, p1e, row2, rot0_2); \
; 2764 :       int16x8_t sum04 = vaddq_s16(row0, row4); \
; 2765 :       int16x8_t dif04 = vsubq_s16(row0, row4); \
; 2766 :       dct_widen(t0e, sum04); \
; 2767 :       dct_widen(t1e, dif04); \
; 2768 :       dct_wadd(x0, t0e, t3e); \
; 2769 :       dct_wsub(x3, t0e, t3e); \
; 2770 :       dct_wadd(x1, t1e, t2e); \
; 2771 :       dct_wsub(x2, t1e, t2e); \
; 2772 :       /* odd part */ \
; 2773 :       int16x8_t sum15 = vaddq_s16(row1, row5); \
; 2774 :       int16x8_t sum17 = vaddq_s16(row1, row7); \
; 2775 :       int16x8_t sum35 = vaddq_s16(row3, row5); \
; 2776 :       int16x8_t sum37 = vaddq_s16(row3, row7); \
; 2777 :       int16x8_t sumodd = vaddq_s16(sum17, sum35); \
; 2778 :       dct_long_mul(p5o, sumodd, rot1_0); \
; 2779 :       dct_long_mac(p1o, p5o, sum17, rot1_1); \
; 2780 :       dct_long_mac(p2o, p5o, sum35, rot1_2); \
; 2781 :       dct_long_mul(p3o, sum37, rot2_0); \
; 2782 :       dct_long_mul(p4o, sum15, rot2_1); \
; 2783 :       dct_wadd(sump13o, p1o, p3o); \
; 2784 :       dct_wadd(sump24o, p2o, p4o); \
; 2785 :       dct_wadd(sump23o, p2o, p3o); \
; 2786 :       dct_wadd(sump14o, p1o, p4o); \
; 2787 :       dct_long_mac(x4, sump13o, row7, rot3_0); \
; 2788 :       dct_long_mac(x5, sump24o, row5, rot3_1); \
; 2789 :       dct_long_mac(x6, sump23o, row3, rot3_2); \
; 2790 :       dct_long_mac(x7, sump14o, row1, rot3_3); \
; 2791 :       dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
; 2792 :       dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
; 2793 :       dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
; 2794 :       dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
; 2795 :    }
; 2796 : 
; 2797 :    // load
; 2798 :    row0 = vld1q_s16(data + 0*8);
; 2799 :    row1 = vld1q_s16(data + 1*8);
; 2800 :    row2 = vld1q_s16(data + 2*8);
; 2801 :    row3 = vld1q_s16(data + 3*8);
; 2802 :    row4 = vld1q_s16(data + 4*8);
; 2803 :    row5 = vld1q_s16(data + 5*8);
; 2804 :    row6 = vld1q_s16(data + 6*8);
; 2805 :    row7 = vld1q_s16(data + 7*8);
; 2806 : 
; 2807 :    // add DC bias
; 2808 :    row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));
; 2809 : 
; 2810 :    // column pass
; 2811 :    dct_pass(vrshrn_n_s32, 10);
; 2812 : 
; 2813 :    // 16bit 8x8 transpose
; 2814 :    {
; 2815 : // these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
; 2816 : // whether compilers actually get this is another story, sadly.
; 2817 : #define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
; 2818 : #define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
; 2819 : #define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }
; 2820 : 
; 2821 :       // pass 1
; 2822 :       dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
; 2823 :       dct_trn16(row2, row3);
; 2824 :       dct_trn16(row4, row5);
; 2825 :       dct_trn16(row6, row7);
; 2826 : 
; 2827 :       // pass 2
; 2828 :       dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
; 2829 :       dct_trn32(row1, row3);
; 2830 :       dct_trn32(row4, row6);
; 2831 :       dct_trn32(row5, row7);
; 2832 : 
; 2833 :       // pass 3
; 2834 :       dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
; 2835 :       dct_trn64(row1, row5);
; 2836 :       dct_trn64(row2, row6);
; 2837 :       dct_trn64(row3, row7);
; 2838 : 
; 2839 : #undef dct_trn16
; 2840 : #undef dct_trn32
; 2841 : #undef dct_trn64
; 2842 :    }
; 2843 : 
; 2844 :    // row pass
; 2845 :    // vrshrn_n_s32 only supports shifts up to 16, we need
; 2846 :    // 17. so do a non-rounding shift of 16 first then follow
; 2847 :    // up with a rounding shift by 1.
; 2848 :    dct_pass(vshrn_n_s32, 16);
; 2849 : 
; 2850 :    {
; 2851 :       // pack and round
; 2852 :       uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
; 2853 :       uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
; 2854 :       uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
; 2855 :       uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
; 2856 :       uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
; 2857 :       uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
; 2858 :       uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
; 2859 :       uint8x8_t p7 = vqrshrun_n_s16(row7, 1);
; 2860 : 
; 2861 :       // again, these can translate into one instruction, but often don't.
; 2862 : #define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
; 2863 : #define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
; 2864 : #define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }
; 2865 : 
; 2866 :       // sadly can't use interleaved stores here since we only write
; 2867 :       // 8 bytes to each scan line!
; 2868 : 
; 2869 :       // 8x8 8-bit transpose pass 1
; 2870 :       dct_trn8_8(p0, p1);
; 2871 :       dct_trn8_8(p2, p3);
; 2872 :       dct_trn8_8(p4, p5);
; 2873 :       dct_trn8_8(p6, p7);
; 2874 : 
; 2875 :       // pass 2
; 2876 :       dct_trn8_16(p0, p2);
; 2877 :       dct_trn8_16(p1, p3);
; 2878 :       dct_trn8_16(p4, p6);
; 2879 :       dct_trn8_16(p5, p7);
; 2880 : 
; 2881 :       // pass 3
; 2882 :       dct_trn8_32(p0, p4);
; 2883 :       dct_trn8_32(p1, p5);
; 2884 :       dct_trn8_32(p2, p6);
; 2885 :       dct_trn8_32(p3, p7);
; 2886 : 
; 2887 :       // store
; 2888 :       vst1_u8(out, p0); out += out_stride;
; 2889 :       vst1_u8(out, p1); out += out_stride;
; 2890 :       vst1_u8(out, p2); out += out_stride;
; 2891 :       vst1_u8(out, p3); out += out_stride;
; 2892 :       vst1_u8(out, p4); out += out_stride;
; 2893 :       vst1_u8(out, p5); out += out_stride;
; 2894 :       vst1_u8(out, p6); out += out_stride;
; 2895 :       vst1_u8(out, p7);
; 2896 : 
; 2897 : #undef dct_trn8_8
; 2898 : #undef dct_trn8_16
; 2899 : #undef dct_trn8_32
; 2900 :    }
; 2901 : 
; 2902 : #undef dct_long_mul
; 2903 : #undef dct_long_mac
; 2904 : #undef dct_widen
; 2905 : #undef dct_wadd
; 2906 : #undef dct_wsub
; 2907 : #undef dct_bfly32o
; 2908 : #undef dct_pass
; 2909 : }
; 2910 : 
; 2911 : #endif // STBI_NEON
; 2912 : 
; 2913 : #define STBI__MARKER_none  0xff
; 2914 : // if there's a pending marker from the entropy stream, return that
; 2915 : // otherwise, fetch from the stream and get a marker. if there's no
; 2916 : // marker, return 0xff, which is never a valid marker value
; 2917 : static stbi_uc stbi__get_marker(stbi__jpeg *j)
; 2918 : {
; 2919 :    stbi_uc x;
; 2920 :    if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
; 2921 :    x = stbi__get8(j->s);
; 2922 :    if (x != 0xff) return STBI__MARKER_none;
; 2923 :    while (x == 0xff)
; 2924 :       x = stbi__get8(j->s); // consume repeated 0xff fill bytes
; 2925 :    return x;
; 2926 : }
; 2927 : 
; 2928 : // in each scan, we'll have scan_n components, and the order
; 2929 : // of the components is specified by order[]
; 2930 : #define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
; 2931 : 
; 2932 : // after a restart interval, stbi__jpeg_reset the entropy decoder and
; 2933 : // the dc prediction
; 2934 : static void stbi__jpeg_reset(stbi__jpeg *j)
; 2935 : {
; 2936 :    j->code_bits = 0;
; 2937 :    j->code_buffer = 0;
; 2938 :    j->nomore = 0;
; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
; 2940 :    j->marker = STBI__MARKER_none;
; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
; 2942 :    j->eob_run = 0;
; 2943 :    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2944 :    // since we don't even allow 1<<30 pixels
; 2945 : }
; 2946 : 
; 2947 : static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
; 2948 : {
; 2949 :    stbi__jpeg_reset(z);
; 2950 :    if (!z->progressive) {
; 2951 :       if (z->scan_n == 1) {
; 2952 :          int i,j;
; 2953 :          STBI_SIMD_ALIGN(short, data[64]);
; 2954 :          int n = z->order[0];
; 2955 :          // non-interleaved data, we just need to process one block at a time,
; 2956 :          // in trivial scanline order
; 2957 :          // number of blocks to do just depends on how many actual "pixels" this
; 2958 :          // component has, independent of interleaved MCU blocking and such
; 2959 :          int w = (z->img_comp[n].x+7) >> 3;
; 2960 :          int h = (z->img_comp[n].y+7) >> 3;
; 2961 :          for (j=0; j < h; ++j) {
; 2962 :             for (i=0; i < w; ++i) {
; 2963 :                int ha = z->img_comp[n].ha;
; 2964 :                if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2965 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 2966 :                // every data block is an MCU, so countdown the restart interval
; 2967 :                if (--z->todo <= 0) {
; 2968 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 2969 :                   // if it's NOT a restart, then just bail, so we get corrupt data
; 2970 :                   // rather than no data
; 2971 :                   if (!STBI__RESTART(z->marker)) return 1;
; 2972 :                   stbi__jpeg_reset(z);
; 2973 :                }
; 2974 :             }
; 2975 :          }
; 2976 :          return 1;
; 2977 :       } else { // interleaved
; 2978 :          int i,j,k,x,y;
; 2979 :          STBI_SIMD_ALIGN(short, data[64]);
; 2980 :          for (j=0; j < z->img_mcu_y; ++j) {
; 2981 :             for (i=0; i < z->img_mcu_x; ++i) {
; 2982 :                // scan an interleaved mcu... process scan_n components in order
; 2983 :                for (k=0; k < z->scan_n; ++k) {
; 2984 :                   int n = z->order[k];
; 2985 :                   // scan out an mcu's worth of this component; that's just determined
; 2986 :                   // by the basic H and V specified for the component
; 2987 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 2988 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 2989 :                         int x2 = (i*z->img_comp[n].h + x)*8;
; 2990 :                         int y2 = (j*z->img_comp[n].v + y)*8;
; 2991 :                         int ha = z->img_comp[n].ha;
; 2992 :                         if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2993 :                         z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
; 2994 :                      }
; 2995 :                   }
; 2996 :                }
; 2997 :                // after all interleaved components, that's an interleaved MCU,
; 2998 :                // so now count down the restart interval
; 2999 :                if (--z->todo <= 0) {
; 3000 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3001 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3002 :                   stbi__jpeg_reset(z);
; 3003 :                }
; 3004 :             }
; 3005 :          }
; 3006 :          return 1;
; 3007 :       }
; 3008 :    } else {
; 3009 :       if (z->scan_n == 1) {
; 3010 :          int i,j;
; 3011 :          int n = z->order[0];
; 3012 :          // non-interleaved data, we just need to process one block at a time,
; 3013 :          // in trivial scanline order
; 3014 :          // number of blocks to do just depends on how many actual "pixels" this
; 3015 :          // component has, independent of interleaved MCU blocking and such
; 3016 :          int w = (z->img_comp[n].x+7) >> 3;
; 3017 :          int h = (z->img_comp[n].y+7) >> 3;
; 3018 :          for (j=0; j < h; ++j) {
; 3019 :             for (i=0; i < w; ++i) {
; 3020 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3021 :                if (z->spec_start == 0) {
; 3022 :                   if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3023 :                      return 0;
; 3024 :                } else {
; 3025 :                   int ha = z->img_comp[n].ha;
; 3026 :                   if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
; 3027 :                      return 0;
; 3028 :                }
; 3029 :                // every data block is an MCU, so countdown the restart interval
; 3030 :                if (--z->todo <= 0) {
; 3031 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3032 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3033 :                   stbi__jpeg_reset(z);
; 3034 :                }
; 3035 :             }
; 3036 :          }
; 3037 :          return 1;
; 3038 :       } else { // interleaved
; 3039 :          int i,j,k,x,y;
; 3040 :          for (j=0; j < z->img_mcu_y; ++j) {
; 3041 :             for (i=0; i < z->img_mcu_x; ++i) {
; 3042 :                // scan an interleaved mcu... process scan_n components in order
; 3043 :                for (k=0; k < z->scan_n; ++k) {
; 3044 :                   int n = z->order[k];
; 3045 :                   // scan out an mcu's worth of this component; that's just determined
; 3046 :                   // by the basic H and V specified for the component
; 3047 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 3048 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 3049 :                         int x2 = (i*z->img_comp[n].h + x);
; 3050 :                         int y2 = (j*z->img_comp[n].v + y);
; 3051 :                         short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
; 3052 :                         if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3053 :                            return 0;
; 3054 :                      }
; 3055 :                   }
; 3056 :                }
; 3057 :                // after all interleaved components, that's an interleaved MCU,
; 3058 :                // so now count down the restart interval
; 3059 :                if (--z->todo <= 0) {
; 3060 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3061 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3062 :                   stbi__jpeg_reset(z);
; 3063 :                }
; 3064 :             }
; 3065 :          }
; 3066 :          return 1;
; 3067 :       }
; 3068 :    }
; 3069 : }
; 3070 : 
; 3071 : static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
; 3072 : {
; 3073 :    int i;
; 3074 :    for (i=0; i < 64; ++i)
; 3075 :       data[i] *= dequant[i];
; 3076 : }
; 3077 : 
; 3078 : static void stbi__jpeg_finish(stbi__jpeg *z)
; 3079 : {
; 3080 :    if (z->progressive) {
; 3081 :       // dequantize and idct the data
; 3082 :       int i,j,n;
; 3083 :       for (n=0; n < z->s->img_n; ++n) {
; 3084 :          int w = (z->img_comp[n].x+7) >> 3;
; 3085 :          int h = (z->img_comp[n].y+7) >> 3;
; 3086 :          for (j=0; j < h; ++j) {
; 3087 :             for (i=0; i < w; ++i) {
; 3088 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3089 :                stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
; 3090 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 3091 :             }
; 3092 :          }
; 3093 :       }
; 3094 :    }
; 3095 : }
; 3096 : 
; 3097 : static int stbi__process_marker(stbi__jpeg *z, int m)
; 3098 : {
; 3099 :    int L;
; 3100 :    switch (m) {
; 3101 :       case STBI__MARKER_none: // no marker found
; 3102 :          return stbi__err("expected marker","Corrupt JPEG");
; 3103 : 
; 3104 :       case 0xDD: // DRI - specify restart interval
; 3105 :          if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
; 3106 :          z->restart_interval = stbi__get16be(z->s);
; 3107 :          return 1;
; 3108 : 
; 3109 :       case 0xDB: // DQT - define quantization table
; 3110 :          L = stbi__get16be(z->s)-2;
; 3111 :          while (L > 0) {
; 3112 :             int q = stbi__get8(z->s);
; 3113 :             int p = q >> 4, sixteen = (p != 0);
; 3114 :             int t = q & 15,i;
; 3115 :             if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
; 3116 :             if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");
; 3117 : 
; 3118 :             for (i=0; i < 64; ++i)
; 3119 :                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
; 3120 :             L -= (sixteen ? 129 : 65);
; 3121 :          }
; 3122 :          return L==0;
; 3123 : 
; 3124 :       case 0xC4: // DHT - define huffman table
; 3125 :          L = stbi__get16be(z->s)-2;
; 3126 :          while (L > 0) {
; 3127 :             stbi_uc *v;
; 3128 :             int sizes[16],i,n=0;
; 3129 :             int q = stbi__get8(z->s);
; 3130 :             int tc = q >> 4;
; 3131 :             int th = q & 15;
; 3132 :             if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
; 3133 :             for (i=0; i < 16; ++i) {
; 3134 :                sizes[i] = stbi__get8(z->s);
; 3135 :                n += sizes[i];
; 3136 :             }
; 3137 :             if(n > 256) return stbi__err("bad DHT header","Corrupt JPEG"); // Loop over i < n would write past end of values!
; 3138 :             L -= 17;
; 3139 :             if (tc == 0) {
; 3140 :                if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
; 3141 :                v = z->huff_dc[th].values;
; 3142 :             } else {
; 3143 :                if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
; 3144 :                v = z->huff_ac[th].values;
; 3145 :             }
; 3146 :             for (i=0; i < n; ++i)
; 3147 :                v[i] = stbi__get8(z->s);
; 3148 :             if (tc != 0)
; 3149 :                stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
; 3150 :             L -= n;
; 3151 :          }
; 3152 :          return L==0;
; 3153 :    }
; 3154 : 
; 3155 :    // check for comment block or APP blocks
; 3156 :    if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
; 3157 :       L = stbi__get16be(z->s);
; 3158 :       if (L < 2) {
; 3159 :          if (m == 0xFE)
; 3160 :             return stbi__err("bad COM len","Corrupt JPEG");
; 3161 :          else
; 3162 :             return stbi__err("bad APP len","Corrupt JPEG");
; 3163 :       }
; 3164 :       L -= 2;
; 3165 : 
; 3166 :       if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
; 3167 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3168 :          int ok = 1;
; 3169 :          int i;
; 3170 :          for (i=0; i < 5; ++i)
; 3171 :             if (stbi__get8(z->s) != tag[i])
; 3172 :                ok = 0;
; 3173 :          L -= 5;
; 3174 :          if (ok)
; 3175 :             z->jfif = 1;
; 3176 :       } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;
; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)
; 3181 :             if (stbi__get8(z->s) != tag[i])
; 3182 :                ok = 0;
; 3183 :          L -= 6;
; 3184 :          if (ok) {
; 3185 :             stbi__get8(z->s); // version
; 3186 :             stbi__get16be(z->s); // flags0
; 3187 :             stbi__get16be(z->s); // flags1
; 3188 :             z->app14_color_transform = stbi__get8(z->s); // color transform
; 3189 :             L -= 6;
; 3190 :          }
; 3191 :       }
; 3192 : 
; 3193 :       stbi__skip(z->s, L);
; 3194 :       return 1;
; 3195 :    }
; 3196 : 
; 3197 :    return stbi__err("unknown marker","Corrupt JPEG");
; 3198 : }
; 3199 : 
; 3200 : // after we see SOS
; 3201 : static int stbi__process_scan_header(stbi__jpeg *z)
; 3202 : {
; 3203 :    int i;
; 3204 :    int Ls = stbi__get16be(z->s);
; 3205 :    z->scan_n = stbi__get8(z->s);
; 3206 :    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
; 3207 :    if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
; 3208 :    for (i=0; i < z->scan_n; ++i) {
; 3209 :       int id = stbi__get8(z->s), which;
; 3210 :       int q = stbi__get8(z->s);
; 3211 :       for (which = 0; which < z->s->img_n; ++which)
; 3212 :          if (z->img_comp[which].id == id)
; 3213 :             break;
; 3214 :       if (which == z->s->img_n) return 0; // no match
; 3215 :       z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
; 3216 :       z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
; 3217 :       z->order[i] = which;
; 3218 :    }
; 3219 : 
; 3220 :    {
; 3221 :       int aa;
; 3222 :       z->spec_start = stbi__get8(z->s);
; 3223 :       z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
; 3224 :       aa = stbi__get8(z->s);
; 3225 :       z->succ_high = (aa >> 4);
; 3226 :       z->succ_low  = (aa & 15);
; 3227 :       if (z->progressive) {
; 3228 :          if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
; 3229 :             return stbi__err("bad SOS", "Corrupt JPEG");
; 3230 :       } else {
; 3231 :          if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3232 :          if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3233 :          z->spec_end = 63;
; 3234 :       }
; 3235 :    }
; 3236 : 
; 3237 :    return 1;
; 3238 : }
; 3239 : 
; 3240 : static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
; 3241 : {
; 3242 :    int i;
; 3243 :    for (i=0; i < ncomp; ++i) {
; 3244 :       if (z->img_comp[i].raw_data) {
; 3245 :          STBI_FREE(z->img_comp[i].raw_data);
; 3246 :          z->img_comp[i].raw_data = NULL;
; 3247 :          z->img_comp[i].data = NULL;
; 3248 :       }
; 3249 :       if (z->img_comp[i].raw_coeff) {
; 3250 :          STBI_FREE(z->img_comp[i].raw_coeff);
; 3251 :          z->img_comp[i].raw_coeff = 0;
; 3252 :          z->img_comp[i].coeff = 0;
; 3253 :       }
; 3254 :       if (z->img_comp[i].linebuf) {
; 3255 :          STBI_FREE(z->img_comp[i].linebuf);
; 3256 :          z->img_comp[i].linebuf = NULL;
; 3257 :       }
; 3258 :    }
; 3259 :    return why;
; 3260 : }
; 3261 : 
; 3262 : static int stbi__process_frame_header(stbi__jpeg *z, int scan)
; 3263 : {
; 3264 :    stbi__context *s = z->s;
; 3265 :    int Lf,p,i,q, h_max=1,v_max=1,c;
; 3266 :    Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
; 3267 :    p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
; 3268 :    s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
; 3269 :    s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
; 3270 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 3271 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 3272 :    c = stbi__get8(s);
; 3273 :    if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");
; 3274 :    s->img_n = c;
; 3275 :    for (i=0; i < c; ++i) {
; 3276 :       z->img_comp[i].data = NULL;
; 3277 :       z->img_comp[i].linebuf = NULL;
; 3278 :    }
; 3279 : 
; 3280 :    if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");
; 3281 : 
; 3282 :    z->rgb = 0;
; 3283 :    for (i=0; i < s->img_n; ++i) {
; 3284 :       static const unsigned char rgb[3] = { 'R', 'G', 'B' };
; 3285 :       z->img_comp[i].id = stbi__get8(s);
; 3286 :       if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
; 3287 :          ++z->rgb;
; 3288 :       q = stbi__get8(s);
; 3289 :       z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
; 3290 :       z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
; 3291 :       z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
; 3292 :    }
; 3293 : 
; 3294 :    if (scan != STBI__SCAN_load) return 1;
; 3295 : 
; 3296 :    if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");
; 3297 : 
; 3298 :    for (i=0; i < s->img_n; ++i) {
; 3299 :       if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
; 3300 :       if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
; 3301 :    }
; 3302 : 
; 3303 :    // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
; 3304 :    // and I've never seen a non-corrupted JPEG file actually use them
; 3305 :    for (i=0; i < s->img_n; ++i) {
; 3306 :       if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");
; 3307 :       if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");
; 3308 :    }
; 3309 : 
; 3310 :    // compute interleaved mcu info
; 3311 :    z->img_h_max = h_max;
; 3312 :    z->img_v_max = v_max;
; 3313 :    z->img_mcu_w = h_max * 8;
; 3314 :    z->img_mcu_h = v_max * 8;
; 3315 :    // these sizes can't be more than 17 bits
; 3316 :    z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
; 3317 :    z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;
; 3318 : 
; 3319 :    for (i=0; i < s->img_n; ++i) {
; 3320 :       // number of effective pixels (e.g. for non-interleaved MCU)
; 3321 :       z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
; 3322 :       z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
; 3323 :       // to simplify generation, we'll allocate enough memory to decode
; 3324 :       // the bogus oversized data from using interleaved MCUs and their
; 3325 :       // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
; 3326 :       // discard the extra data until colorspace conversion
; 3327 :       //
; 3328 :       // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
; 3329 :       // so these muls can't overflow with 32-bit ints (which we require)
; 3330 :       z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
; 3331 :       z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
; 3332 :       z->img_comp[i].coeff = 0;
; 3333 :       z->img_comp[i].raw_coeff = 0;
; 3334 :       z->img_comp[i].linebuf = NULL;
; 3335 :       z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
; 3336 :       if (z->img_comp[i].raw_data == NULL)
; 3337 :          return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
; 3338 :       // align blocks for idct using mmx/sse
; 3339 :       z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
; 3340 :       if (z->progressive) {
; 3341 :          // w2, h2 are multiples of 8 (see above)
; 3342 :          z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
; 3343 :          z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
; 3344 :          z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
; 3345 :          if (z->img_comp[i].raw_coeff == NULL)
; 3346 :             return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
; 3347 :          z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
; 3348 :       }
; 3349 :    }
; 3350 : 
; 3351 :    return 1;
; 3352 : }
; 3353 : 
; 3354 : // use comparisons since in some cases we handle more than one case (e.g. SOF)
; 3355 : #define stbi__DNL(x)         ((x) == 0xdc)
; 3356 : #define stbi__SOI(x)         ((x) == 0xd8)
; 3357 : #define stbi__EOI(x)         ((x) == 0xd9)
; 3358 : #define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
; 3359 : #define stbi__SOS(x)         ((x) == 0xda)
; 3360 : 
; 3361 : #define stbi__SOF_progressive(x)   ((x) == 0xc2)
; 3362 : 
; 3363 : static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
; 3364 : {
; 3365 :    int m;
; 3366 :    z->jfif = 0;
; 3367 :    z->app14_color_transform = -1; // valid values are 0,1,2
; 3368 :    z->marker = STBI__MARKER_none; // initialize cached marker to empty
; 3369 :    m = stbi__get_marker(z);
; 3370 :    if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
; 3371 :    if (scan == STBI__SCAN_type) return 1;
; 3372 :    m = stbi__get_marker(z);
; 3373 :    while (!stbi__SOF(m)) {
; 3374 :       if (!stbi__process_marker(z,m)) return 0;
; 3375 :       m = stbi__get_marker(z);
; 3376 :       while (m == STBI__MARKER_none) {
; 3377 :          // some files have extra padding after their blocks, so ok, we'll scan
; 3378 :          if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
; 3379 :          m = stbi__get_marker(z);
; 3380 :       }
; 3381 :    }
; 3382 :    z->progressive = stbi__SOF_progressive(m);
; 3383 :    if (!stbi__process_frame_header(z, scan)) return 0;
; 3384 :    return 1;
; 3385 : }
; 3386 : 
; 3387 : static int stbi__skip_jpeg_junk_at_end(stbi__jpeg *j)
; 3388 : {
; 3389 :    // some JPEGs have junk at end, skip over it but if we find what looks
; 3390 :    // like a valid marker, resume there
; 3391 :    while (!stbi__at_eof(j->s)) {
; 3392 :       int x = stbi__get8(j->s);
; 3393 :       while (x == 255) { // might be a marker
; 3394 :          if (stbi__at_eof(j->s)) return STBI__MARKER_none;
; 3395 :          x = stbi__get8(j->s);
; 3396 :          if (x != 0x00 && x != 0xff) {
; 3397 :             // not a stuffed zero or lead-in to another marker, looks
; 3398 :             // like an actual marker, return it
; 3399 :             return x;
; 3400 :          }
; 3401 :          // stuffed zero has x=0 now which ends the loop, meaning we go
; 3402 :          // back to regular scan loop.
; 3403 :          // repeated 0xff keeps trying to read the next byte of the marker.
; 3404 :       }
; 3405 :    }
; 3406 :    return STBI__MARKER_none;
; 3407 : }
; 3408 : 
; 3409 : // decode image to YCbCr format
; 3410 : static int stbi__decode_jpeg_image(stbi__jpeg *j)
; 3411 : {
; 3412 :    int m;
; 3413 :    for (m = 0; m < 4; m++) {
; 3414 :       j->img_comp[m].raw_data = NULL;
; 3415 :       j->img_comp[m].raw_coeff = NULL;
; 3416 :    }
; 3417 :    j->restart_interval = 0;
; 3418 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
; 3419 :    m = stbi__get_marker(j);
; 3420 :    while (!stbi__EOI(m)) {
; 3421 :       if (stbi__SOS(m)) {
; 3422 :          if (!stbi__process_scan_header(j)) return 0;
; 3423 :          if (!stbi__parse_entropy_coded_data(j)) return 0;
; 3424 :          if (j->marker == STBI__MARKER_none ) {
; 3425 :          j->marker = stbi__skip_jpeg_junk_at_end(j);
; 3426 :             // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
; 3427 :          }
; 3428 :          m = stbi__get_marker(j);
; 3429 :          if (STBI__RESTART(m))
; 3430 :             m = stbi__get_marker(j);
; 3431 :       } else if (stbi__DNL(m)) {
; 3432 :          int Ld = stbi__get16be(j->s);
; 3433 :          stbi__uint32 NL = stbi__get16be(j->s);
; 3434 :          if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
; 3435 :          if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
; 3436 :          m = stbi__get_marker(j);
; 3437 :       } else {
; 3438 :          if (!stbi__process_marker(j, m)) return 1;
; 3439 :          m = stbi__get_marker(j);
; 3440 :       }
; 3441 :    }
; 3442 :    if (j->progressive)
; 3443 :       stbi__jpeg_finish(j);
; 3444 :    return 1;
; 3445 : }
; 3446 : 
; 3447 : // static jfif-centered resampling (across block boundaries)
; 3448 : 
; 3449 : typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
; 3450 :                                     int w, int hs);
; 3451 : 
; 3452 : #define stbi__div4(x) ((stbi_uc) ((x) >> 2))
; 3453 : 
; 3454 : static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3455 : {
; 3456 :    STBI_NOTUSED(out);
; 3457 :    STBI_NOTUSED(in_far);
; 3458 :    STBI_NOTUSED(w);
; 3459 :    STBI_NOTUSED(hs);
; 3460 :    return in_near;
; 3461 : }
; 3462 : 
; 3463 : static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3464 : {
; 3465 :    // need to generate two samples vertically for every one in input
; 3466 :    int i;
; 3467 :    STBI_NOTUSED(hs);
; 3468 :    for (i=0; i < w; ++i)
; 3469 :       out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
; 3470 :    return out;
; 3471 : }
; 3472 : 
; 3473 : static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3474 : {
; 3475 :    // need to generate two samples horizontally for every one in input
; 3476 :    int i;
; 3477 :    stbi_uc *input = in_near;
; 3478 : 
; 3479 :    if (w == 1) {
; 3480 :       // if only one sample, can't do any interpolation
; 3481 :       out[0] = out[1] = input[0];
; 3482 :       return out;
; 3483 :    }
; 3484 : 
; 3485 :    out[0] = input[0];
; 3486 :    out[1] = stbi__div4(input[0]*3 + input[1] + 2);
; 3487 :    for (i=1; i < w-1; ++i) {
; 3488 :       int n = 3*input[i]+2;
; 3489 :       out[i*2+0] = stbi__div4(n+input[i-1]);
; 3490 :       out[i*2+1] = stbi__div4(n+input[i+1]);
; 3491 :    }
; 3492 :    out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
; 3493 :    out[i*2+1] = input[w-1];
; 3494 : 
; 3495 :    STBI_NOTUSED(in_far);
; 3496 :    STBI_NOTUSED(hs);
; 3497 : 
; 3498 :    return out;
; 3499 : }
; 3500 : 
; 3501 : #define stbi__div16(x) ((stbi_uc) ((x) >> 4))
; 3502 : 
; 3503 : static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3504 : {
; 3505 :    // need to generate 2x2 samples for every one in input
; 3506 :    int i,t0,t1;
; 3507 :    if (w == 1) {
; 3508 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
; 3509 :       return out;
; 3510 :    }
; 3511 : 
; 3512 :    t1 = 3*in_near[0] + in_far[0];
; 3513 :    out[0] = stbi__div4(t1+2);
; 3514 :    for (i=1; i < w; ++i) {
; 3515 :       t0 = t1;
; 3516 :       t1 = 3*in_near[i]+in_far[i];
; 3517 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
; 3518 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
; 3519 :    }
; 3520 :    out[w*2-1] = stbi__div4(t1+2);
; 3521 : 
; 3522 :    STBI_NOTUSED(hs);
; 3523 : 
; 3524 :    return out;
; 3525 : }
; 3526 : 
; 3527 : #if defined(STBI_SSE2) || defined(STBI_NEON)
; 3528 : static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3529 : {
; 3530 :    // need to generate 2x2 samples for every one in input
; 3531 :    int i=0,t0,t1;
; 3532 : 
; 3533 :    if (w == 1) {
; 3534 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
; 3535 :       return out;
; 3536 :    }
; 3537 : 
; 3538 :    t1 = 3*in_near[0] + in_far[0];
; 3539 :    // process groups of 8 pixels for as long as we can.
; 3540 :    // note we can't handle the last pixel in a row in this loop
; 3541 :    // because we need to handle the filter boundary conditions.
; 3542 :    for (; i < ((w-1) & ~7); i += 8) {
; 3543 : #if defined(STBI_SSE2)
; 3544 :       // load and perform the vertical filtering pass
; 3545 :       // this uses 3*x + y = 4*x + (y - x)
; 3546 :       __m128i zero  = _mm_setzero_si128();
; 3547 :       __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
; 3548 :       __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
; 3549 :       __m128i farw  = _mm_unpacklo_epi8(farb, zero);
; 3550 :       __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
; 3551 :       __m128i diff  = _mm_sub_epi16(farw, nearw);
; 3552 :       __m128i nears = _mm_slli_epi16(nearw, 2);
; 3553 :       __m128i curr  = _mm_add_epi16(nears, diff); // current row
; 3554 : 
; 3555 :       // horizontal filter works the same based on shifted vers of current
; 3556 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3557 :       // insert the previous pixel value (from t1).
; 3558 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3559 :       // of next block of 8 pixels added in.
; 3560 :       __m128i prv0 = _mm_slli_si128(curr, 2);
; 3561 :       __m128i nxt0 = _mm_srli_si128(curr, 2);
; 3562 :       __m128i prev = _mm_insert_epi16(prv0, t1, 0);
; 3563 :       __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);
; 3564 : 
; 3565 :       // horizontal filter, polyphase implementation since it's convenient:
; 3566 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3567 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3568 :       // note the shared term.
; 3569 :       __m128i bias  = _mm_set1_epi16(8);
; 3570 :       __m128i curs = _mm_slli_epi16(curr, 2);
; 3571 :       __m128i prvd = _mm_sub_epi16(prev, curr);
; 3572 :       __m128i nxtd = _mm_sub_epi16(next, curr);
; 3573 :       __m128i curb = _mm_add_epi16(curs, bias);
; 3574 :       __m128i even = _mm_add_epi16(prvd, curb);
; 3575 :       __m128i odd  = _mm_add_epi16(nxtd, curb);
; 3576 : 
; 3577 :       // interleave even and odd pixels, then undo scaling.
; 3578 :       __m128i int0 = _mm_unpacklo_epi16(even, odd);
; 3579 :       __m128i int1 = _mm_unpackhi_epi16(even, odd);
; 3580 :       __m128i de0  = _mm_srli_epi16(int0, 4);
; 3581 :       __m128i de1  = _mm_srli_epi16(int1, 4);
; 3582 : 
; 3583 :       // pack and write output
; 3584 :       __m128i outv = _mm_packus_epi16(de0, de1);
; 3585 :       _mm_storeu_si128((__m128i *) (out + i*2), outv);
; 3586 : #elif defined(STBI_NEON)
; 3587 :       // load and perform the vertical filtering pass
; 3588 :       // this uses 3*x + y = 4*x + (y - x)
; 3589 :       uint8x8_t farb  = vld1_u8(in_far + i);
; 3590 :       uint8x8_t nearb = vld1_u8(in_near + i);
; 3591 :       int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
; 3592 :       int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
; 3593 :       int16x8_t curr  = vaddq_s16(nears, diff); // current row
; 3594 : 
; 3595 :       // horizontal filter works the same based on shifted vers of current
; 3596 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3597 :       // insert the previous pixel value (from t1).
; 3598 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3599 :       // of next block of 8 pixels added in.
; 3600 :       int16x8_t prv0 = vextq_s16(curr, curr, 7);
; 3601 :       int16x8_t nxt0 = vextq_s16(curr, curr, 1);
; 3602 :       int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
; 3603 :       int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);
; 3604 : 
; 3605 :       // horizontal filter, polyphase implementation since it's convenient:
; 3606 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3607 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3608 :       // note the shared term.
; 3609 :       int16x8_t curs = vshlq_n_s16(curr, 2);
; 3610 :       int16x8_t prvd = vsubq_s16(prev, curr);
; 3611 :       int16x8_t nxtd = vsubq_s16(next, curr);
; 3612 :       int16x8_t even = vaddq_s16(curs, prvd);
; 3613 :       int16x8_t odd  = vaddq_s16(curs, nxtd);
; 3614 : 
; 3615 :       // undo scaling and round, then store with even/odd phases interleaved
; 3616 :       uint8x8x2_t o;
; 3617 :       o.val[0] = vqrshrun_n_s16(even, 4);
; 3618 :       o.val[1] = vqrshrun_n_s16(odd,  4);
; 3619 :       vst2_u8(out + i*2, o);
; 3620 : #endif
; 3621 : 
; 3622 :       // "previous" value for next iter
; 3623 :       t1 = 3*in_near[i+7] + in_far[i+7];
; 3624 :    }
; 3625 : 
; 3626 :    t0 = t1;
; 3627 :    t1 = 3*in_near[i] + in_far[i];
; 3628 :    out[i*2] = stbi__div16(3*t1 + t0 + 8);
; 3629 : 
; 3630 :    for (++i; i < w; ++i) {
; 3631 :       t0 = t1;
; 3632 :       t1 = 3*in_near[i]+in_far[i];
; 3633 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
; 3634 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
; 3635 :    }
; 3636 :    out[w*2-1] = stbi__div4(t1+2);
; 3637 : 
; 3638 :    STBI_NOTUSED(hs);
; 3639 : 
; 3640 :    return out;
; 3641 : }
; 3642 : #endif
; 3643 : 
; 3644 : static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3645 : {
; 3646 :    // resample with nearest-neighbor
; 3647 :    int i,j;
; 3648 :    STBI_NOTUSED(in_far);
; 3649 :    for (i=0; i < w; ++i)
; 3650 :       for (j=0; j < hs; ++j)
; 3651 :          out[i*hs+j] = in_near[i];
; 3652 :    return out;
; 3653 : }
; 3654 : 
; 3655 : // this is a reduced-precision calculation of YCbCr-to-RGB introduced
; 3656 : // to make sure the code produces the same results in both SIMD and scalar
; 3657 : #define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
; 3658 : static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
; 3659 : {
; 3660 :    int i;
; 3661 :    for (i=0; i < count; ++i) {
; 3662 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding
; 3663 :       int r,g,b;
; 3664 :       int cr = pcr[i] - 128;
; 3665 :       int cb = pcb[i] - 128;
; 3666 :       r = y_fixed +  cr* stbi__float2fixed(1.40200f);
; 3667 :       g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
; 3668 :       b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
; 3669 :       r >>= 20;
; 3670 :       g >>= 20;
; 3671 :       b >>= 20;
; 3672 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
; 3673 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
; 3674 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
; 3675 :       out[0] = (stbi_uc)r;
; 3676 :       out[1] = (stbi_uc)g;
; 3677 :       out[2] = (stbi_uc)b;
; 3678 :       out[3] = 255;
; 3679 :       out += step;
; 3680 :    }
; 3681 : }
; 3682 : 
; 3683 : #if defined(STBI_SSE2) || defined(STBI_NEON)
; 3684 : static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
; 3685 : {
; 3686 :    int i = 0;
; 3687 : 
; 3688 : #ifdef STBI_SSE2
; 3689 :    // step == 3 is pretty ugly on the final interleave, and i'm not convinced
; 3690 :    // it's useful in practice (you wouldn't use it for textures, for example).
; 3691 :    // so just accelerate step == 4 case.
; 3692 :    if (step == 4) {
; 3693 :       // this is a fairly straightforward implementation and not super-optimized.
; 3694 :       __m128i signflip  = _mm_set1_epi8(-0x80);
; 3695 :       __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3696 :       __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3697 :       __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3698 :       __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3699 :       __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
; 3700 :       __m128i xw = _mm_set1_epi16(255); // alpha channel
; 3701 : 
; 3702 :       for (; i+7 < count; i += 8) {
; 3703 :          // load
; 3704 :          __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
; 3705 :          __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
; 3706 :          __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
; 3707 :          __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
; 3708 :          __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128
; 3709 : 
; 3710 :          // unpack to short (and left-shift cr, cb by 8)
; 3711 :          __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
; 3712 :          __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
; 3713 :          __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);
; 3714 : 
; 3715 :          // color transform
; 3716 :          __m128i yws = _mm_srli_epi16(yw, 4);
; 3717 :          __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
; 3718 :          __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
; 3719 :          __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
; 3720 :          __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
; 3721 :          __m128i rws = _mm_add_epi16(cr0, yws);
; 3722 :          __m128i gwt = _mm_add_epi16(cb0, yws);
; 3723 :          __m128i bws = _mm_add_epi16(yws, cb1);
; 3724 :          __m128i gws = _mm_add_epi16(gwt, cr1);
; 3725 : 
; 3726 :          // descale
; 3727 :          __m128i rw = _mm_srai_epi16(rws, 4);
; 3728 :          __m128i bw = _mm_srai_epi16(bws, 4);
; 3729 :          __m128i gw = _mm_srai_epi16(gws, 4);
; 3730 : 
; 3731 :          // back to byte, set up for transpose
; 3732 :          __m128i brb = _mm_packus_epi16(rw, bw);
; 3733 :          __m128i gxb = _mm_packus_epi16(gw, xw);
; 3734 : 
; 3735 :          // transpose to interleave channels
; 3736 :          __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
; 3737 :          __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
; 3738 :          __m128i o0 = _mm_unpacklo_epi16(t0, t1);
; 3739 :          __m128i o1 = _mm_unpackhi_epi16(t0, t1);
; 3740 : 
; 3741 :          // store
; 3742 :          _mm_storeu_si128((__m128i *) (out + 0), o0);
; 3743 :          _mm_storeu_si128((__m128i *) (out + 16), o1);
; 3744 :          out += 32;
; 3745 :       }
; 3746 :    }
; 3747 : #endif
; 3748 : 
; 3749 : #ifdef STBI_NEON
; 3750 :    // in this version, step=3 support would be easy to add. but is there demand?
; 3751 :    if (step == 4) {
; 3752 :       // this is a fairly straightforward implementation and not super-optimized.
; 3753 :       uint8x8_t signflip = vdup_n_u8(0x80);
; 3754 :       int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3755 :       int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3756 :       int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3757 :       int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3758 : 
; 3759 :       for (; i+7 < count; i += 8) {
; 3760 :          // load
; 3761 :          uint8x8_t y_bytes  = vld1_u8(y + i);
; 3762 :          uint8x8_t cr_bytes = vld1_u8(pcr + i);
; 3763 :          uint8x8_t cb_bytes = vld1_u8(pcb + i);
; 3764 :          int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
; 3765 :          int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
; 3766 : 
; 3767 :          // expand to s16
; 3768 :          int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
; 3769 :          int16x8_t crw = vshll_n_s8(cr_biased, 7);
; 3770 :          int16x8_t cbw = vshll_n_s8(cb_biased, 7);
; 3771 : 
; 3772 :          // color transform
; 3773 :          int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
; 3774 :          int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
; 3775 :          int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
; 3776 :          int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
; 3777 :          int16x8_t rws = vaddq_s16(yws, cr0);
; 3778 :          int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
; 3779 :          int16x8_t bws = vaddq_s16(yws, cb1);
; 3780 : 
; 3781 :          // undo scaling, round, convert to byte
; 3782 :          uint8x8x4_t o;
; 3783 :          o.val[0] = vqrshrun_n_s16(rws, 4);
; 3784 :          o.val[1] = vqrshrun_n_s16(gws, 4);
; 3785 :          o.val[2] = vqrshrun_n_s16(bws, 4);
; 3786 :          o.val[3] = vdup_n_u8(255);
; 3787 : 
; 3788 :          // store, interleaving r/g/b/a
; 3789 :          vst4_u8(out, o);
; 3790 :          out += 8*4;
; 3791 :       }
; 3792 :    }
; 3793 : #endif
; 3794 : 
; 3795 :    for (; i < count; ++i) {
; 3796 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding
; 3797 :       int r,g,b;
; 3798 :       int cr = pcr[i] - 128;
; 3799 :       int cb = pcb[i] - 128;
; 3800 :       r = y_fixed + cr* stbi__float2fixed(1.40200f);
; 3801 :       g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
; 3802 :       b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
; 3803 :       r >>= 20;
; 3804 :       g >>= 20;
; 3805 :       b >>= 20;
; 3806 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
; 3807 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
; 3808 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
; 3809 :       out[0] = (stbi_uc)r;
; 3810 :       out[1] = (stbi_uc)g;
; 3811 :       out[2] = (stbi_uc)b;
; 3812 :       out[3] = 255;
; 3813 :       out += step;
; 3814 :    }
; 3815 : }
; 3816 : #endif
; 3817 : 
; 3818 : // set up the kernels
; 3819 : static void stbi__setup_jpeg(stbi__jpeg *j)
; 3820 : {
; 3821 :    j->idct_block_kernel = stbi__idct_block;
; 3822 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
; 3823 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;
; 3824 : 
; 3825 : #ifdef STBI_SSE2
; 3826 :    if (stbi__sse2_available()) {
; 3827 :       j->idct_block_kernel = stbi__idct_simd;
; 3828 :       j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3829 :       j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3830 :    }
; 3831 : #endif
; 3832 : 
; 3833 : #ifdef STBI_NEON
; 3834 :    j->idct_block_kernel = stbi__idct_simd;
; 3835 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3836 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3837 : #endif
; 3838 : }
; 3839 : 
; 3840 : // clean up the temporary component buffers
; 3841 : static void stbi__cleanup_jpeg(stbi__jpeg *j)
; 3842 : {
; 3843 :    stbi__free_jpeg_components(j, j->s->img_n, 0);
; 3844 : }
; 3845 : 
; 3846 : typedef struct
; 3847 : {
; 3848 :    resample_row_func resample;
; 3849 :    stbi_uc *line0,*line1;
; 3850 :    int hs,vs;   // expansion factor in each axis
; 3851 :    int w_lores; // horizontal pixels pre-expansion
; 3852 :    int ystep;   // how far through vertical expansion we are
; 3853 :    int ypos;    // which pre-expansion row we're on
; 3854 : } stbi__resample;
; 3855 : 
; 3856 : // fast 0..255 * 0..255 => 0..255 rounded multiplication
; 3857 : static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
; 3858 : {
; 3859 :    unsigned int t = x*y + 128;
; 3860 :    return (stbi_uc) ((t + (t >>8)) >> 8);
; 3861 : }
; 3862 : 
; 3863 : static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
; 3864 : {
; 3865 :    int n, decode_n, is_rgb;
; 3866 :    z->s->img_n = 0; // make stbi__cleanup_jpeg safe
; 3867 : 
; 3868 :    // validate req_comp
; 3869 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
; 3870 : 
; 3871 :    // load a jpeg image from whichever source, but leave in YCbCr format
; 3872 :    if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }
; 3873 : 
; 3874 :    // determine actual number of components to generate
; 3875 :    n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;
; 3876 : 
; 3877 :    is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));
; 3878 : 
; 3879 :    if (z->s->img_n == 3 && n < 3 && !is_rgb)
; 3880 :       decode_n = 1;
; 3881 :    else
; 3882 :       decode_n = z->s->img_n;
; 3883 : 
; 3884 :    // nothing to do if no components requested; check this now to avoid
; 3885 :    // accessing uninitialized coutput[0] later
; 3886 :    if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }
; 3887 : 
; 3888 :    // resample and color-convert
; 3889 :    {
; 3890 :       int k;
; 3891 :       unsigned int i,j;
; 3892 :       stbi_uc *output;
; 3893 :       stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };
; 3894 : 
; 3895 :       stbi__resample res_comp[4];
; 3896 : 
; 3897 :       for (k=0; k < decode_n; ++k) {
; 3898 :          stbi__resample *r = &res_comp[k];
; 3899 : 
; 3900 :          // allocate line buffer big enough for upsampling off the edges
; 3901 :          // with upsample factor of 4
; 3902 :          z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
; 3903 :          if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
; 3904 : 
; 3905 :          r->hs      = z->img_h_max / z->img_comp[k].h;
; 3906 :          r->vs      = z->img_v_max / z->img_comp[k].v;
; 3907 :          r->ystep   = r->vs >> 1;
; 3908 :          r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
; 3909 :          r->ypos    = 0;
; 3910 :          r->line0   = r->line1 = z->img_comp[k].data;
; 3911 : 
; 3912 :          if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
; 3913 :          else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
; 3914 :          else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
; 3915 :          else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
; 3916 :          else                               r->resample = stbi__resample_row_generic;
; 3917 :       }
; 3918 : 
; 3919 :       // can't error after this so, this is safe
; 3920 :       output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
; 3921 :       if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
; 3922 : 
; 3923 :       // now go ahead and resample
; 3924 :       for (j=0; j < z->s->img_y; ++j) {
; 3925 :          stbi_uc *out = output + n * z->s->img_x * j;
; 3926 :          for (k=0; k < decode_n; ++k) {
; 3927 :             stbi__resample *r = &res_comp[k];
; 3928 :             int y_bot = r->ystep >= (r->vs >> 1);
; 3929 :             coutput[k] = r->resample(z->img_comp[k].linebuf,
; 3930 :                                      y_bot ? r->line1 : r->line0,
; 3931 :                                      y_bot ? r->line0 : r->line1,
; 3932 :                                      r->w_lores, r->hs);
; 3933 :             if (++r->ystep >= r->vs) {
; 3934 :                r->ystep = 0;
; 3935 :                r->line0 = r->line1;
; 3936 :                if (++r->ypos < z->img_comp[k].y)
; 3937 :                   r->line1 += z->img_comp[k].w2;
; 3938 :             }
; 3939 :          }
; 3940 :          if (n >= 3) {
; 3941 :             stbi_uc *y = coutput[0];
; 3942 :             if (z->s->img_n == 3) {
; 3943 :                if (is_rgb) {
; 3944 :                   for (i=0; i < z->s->img_x; ++i) {
; 3945 :                      out[0] = y[i];
; 3946 :                      out[1] = coutput[1][i];
; 3947 :                      out[2] = coutput[2][i];
; 3948 :                      out[3] = 255;
; 3949 :                      out += n;
; 3950 :                   }
; 3951 :                } else {
; 3952 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3953 :                }
; 3954 :             } else if (z->s->img_n == 4) {
; 3955 :                if (z->app14_color_transform == 0) { // CMYK
; 3956 :                   for (i=0; i < z->s->img_x; ++i) {
; 3957 :                      stbi_uc m = coutput[3][i];
; 3958 :                      out[0] = stbi__blinn_8x8(coutput[0][i], m);
; 3959 :                      out[1] = stbi__blinn_8x8(coutput[1][i], m);
; 3960 :                      out[2] = stbi__blinn_8x8(coutput[2][i], m);
; 3961 :                      out[3] = 255;
; 3962 :                      out += n;
; 3963 :                   }
; 3964 :                } else if (z->app14_color_transform == 2) { // YCCK
; 3965 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3966 :                   for (i=0; i < z->s->img_x; ++i) {
; 3967 :                      stbi_uc m = coutput[3][i];
; 3968 :                      out[0] = stbi__blinn_8x8(255 - out[0], m);
; 3969 :                      out[1] = stbi__blinn_8x8(255 - out[1], m);
; 3970 :                      out[2] = stbi__blinn_8x8(255 - out[2], m);
; 3971 :                      out += n;
; 3972 :                   }
; 3973 :                } else { // YCbCr + alpha?  Ignore the fourth channel for now
; 3974 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3975 :                }
; 3976 :             } else
; 3977 :                for (i=0; i < z->s->img_x; ++i) {
; 3978 :                   out[0] = out[1] = out[2] = y[i];
; 3979 :                   out[3] = 255; // not used if n==3
; 3980 :                   out += n;
; 3981 :                }
; 3982 :          } else {
; 3983 :             if (is_rgb) {
; 3984 :                if (n == 1)
; 3985 :                   for (i=0; i < z->s->img_x; ++i)
; 3986 :                      *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
; 3987 :                else {
; 3988 :                   for (i=0; i < z->s->img_x; ++i, out += 2) {
; 3989 :                      out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
; 3990 :                      out[1] = 255;
; 3991 :                   }
; 3992 :                }
; 3993 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
; 3994 :                for (i=0; i < z->s->img_x; ++i) {
; 3995 :                   stbi_uc m = coutput[3][i];
; 3996 :                   stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
; 3997 :                   stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
; 3998 :                   stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
; 3999 :                   out[0] = stbi__compute_y(r, g, b);
; 4000 :                   out[1] = 255;
; 4001 :                   out += n;
; 4002 :                }
; 4003 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
; 4004 :                for (i=0; i < z->s->img_x; ++i) {
; 4005 :                   out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
; 4006 :                   out[1] = 255;
; 4007 :                   out += n;
; 4008 :                }
; 4009 :             } else {
; 4010 :                stbi_uc *y = coutput[0];
; 4011 :                if (n == 1)
; 4012 :                   for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
; 4013 :                else
; 4014 :                   for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
; 4015 :             }
; 4016 :          }
; 4017 :       }
; 4018 :       stbi__cleanup_jpeg(z);
; 4019 :       *out_x = z->s->img_x;
; 4020 :       *out_y = z->s->img_y;
; 4021 :       if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
; 4022 :       return output;
; 4023 :    }
; 4024 : }
; 4025 : 
; 4026 : static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 4027 : {
; 4028 :    unsigned char* result;
; 4029 :    stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
; 4030 :    if (!j) return stbi__errpuc("outofmem", "Out of memory");
; 4031 :    memset(j, 0, sizeof(stbi__jpeg));
; 4032 :    STBI_NOTUSED(ri);
; 4033 :    j->s = s;
; 4034 :    stbi__setup_jpeg(j);
; 4035 :    result = load_jpeg_image(j, x,y,comp,req_comp);
; 4036 :    STBI_FREE(j);
; 4037 :    return result;
; 4038 : }
; 4039 : 
; 4040 : static int stbi__jpeg_test(stbi__context *s)
; 4041 : {
; 4042 :    int r;
; 4043 :    stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
; 4044 :    if (!j) return stbi__err("outofmem", "Out of memory");
; 4045 :    memset(j, 0, sizeof(stbi__jpeg));
; 4046 :    j->s = s;
; 4047 :    stbi__setup_jpeg(j);
; 4048 :    r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
; 4049 :    stbi__rewind(s);
; 4050 :    STBI_FREE(j);
; 4051 :    return r;
; 4052 : }
; 4053 : 
; 4054 : static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
; 4055 : {
; 4056 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
; 4057 :       stbi__rewind( j->s );
; 4058 :       return 0;
; 4059 :    }
; 4060 :    if (x) *x = j->s->img_x;
; 4061 :    if (y) *y = j->s->img_y;
; 4062 :    if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
; 4063 :    return 1;
; 4064 : }
; 4065 : 
; 4066 : static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
; 4067 : {
; 4068 :    int result;
; 4069 :    stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
; 4070 :    if (!j) return stbi__err("outofmem", "Out of memory");
; 4071 :    memset(j, 0, sizeof(stbi__jpeg));
; 4072 :    j->s = s;
; 4073 :    result = stbi__jpeg_info_raw(j, x, y, comp);
; 4074 :    STBI_FREE(j);
; 4075 :    return result;
; 4076 : }
; 4077 : #endif
; 4078 : 
; 4079 : // public domain zlib decode    v0.2  Sean Barrett 2006-11-18
; 4080 : //    simple implementation
; 4081 : //      - all input must be provided in an upfront buffer
; 4082 : //      - all output is written to a single output buffer (can malloc/realloc)
; 4083 : //    performance
; 4084 : //      - fast huffman
; 4085 : 
; 4086 : #ifndef STBI_NO_ZLIB
; 4087 : 
; 4088 : // fast-way is faster to check than jpeg huffman, but slow way is slower
; 4089 : #define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
; 4090 : #define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
; 4091 : #define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet
; 4092 : 
; 4093 : // zlib-style huffman encoding
; 4094 : // (jpegs packs from left, zlib from right, so can't share code)
; 4095 : typedef struct
; 4096 : {
; 4097 :    stbi__uint16 fast[1 << STBI__ZFAST_BITS];
; 4098 :    stbi__uint16 firstcode[16];
; 4099 :    int maxcode[17];
; 4100 :    stbi__uint16 firstsymbol[16];
; 4101 :    stbi_uc  size[STBI__ZNSYMS];
; 4102 :    stbi__uint16 value[STBI__ZNSYMS];
; 4103 : } stbi__zhuffman;
; 4104 : 
; 4105 : stbi_inline static int stbi__bitreverse16(int n)
; 4106 : {
; 4107 :   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
; 4108 :   n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
; 4109 :   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
; 4110 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
; 4111 :   return n;
; 4112 : }
; 4113 : 
; 4114 : stbi_inline static int stbi__bit_reverse(int v, int bits)
; 4115 : {
; 4116 :    STBI_ASSERT(bits <= 16);
; 4117 :    // to bit reverse n bits, reverse 16 and shift
; 4118 :    // e.g. 11 bits, bit reverse and shift away 5
; 4119 :    return stbi__bitreverse16(v) >> (16-bits);
; 4120 : }
; 4121 : 
; 4122 : static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
; 4123 : {
; 4124 :    int i,k=0;
; 4125 :    int code, next_code[16], sizes[17];
; 4126 : 
; 4127 :    // DEFLATE spec for generating codes
; 4128 :    memset(sizes, 0, sizeof(sizes));
; 4129 :    memset(z->fast, 0, sizeof(z->fast));
; 4130 :    for (i=0; i < num; ++i)
; 4131 :       ++sizes[sizelist[i]];
; 4132 :    sizes[0] = 0;
; 4133 :    for (i=1; i < 16; ++i)
; 4134 :       if (sizes[i] > (1 << i))
; 4135 :          return stbi__err("bad sizes", "Corrupt PNG");
; 4136 :    code = 0;
; 4137 :    for (i=1; i < 16; ++i) {
; 4138 :       next_code[i] = code;
; 4139 :       z->firstcode[i] = (stbi__uint16) code;
; 4140 :       z->firstsymbol[i] = (stbi__uint16) k;
; 4141 :       code = (code + sizes[i]);
; 4142 :       if (sizes[i])
; 4143 :          if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
; 4144 :       z->maxcode[i] = code << (16-i); // preshift for inner loop
; 4145 :       code <<= 1;
; 4146 :       k += sizes[i];
; 4147 :    }
; 4148 :    z->maxcode[16] = 0x10000; // sentinel
; 4149 :    for (i=0; i < num; ++i) {
; 4150 :       int s = sizelist[i];
; 4151 :       if (s) {
; 4152 :          int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
; 4153 :          stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
; 4154 :          z->size [c] = (stbi_uc     ) s;
; 4155 :          z->value[c] = (stbi__uint16) i;
; 4156 :          if (s <= STBI__ZFAST_BITS) {
; 4157 :             int j = stbi__bit_reverse(next_code[s],s);
; 4158 :             while (j < (1 << STBI__ZFAST_BITS)) {
; 4159 :                z->fast[j] = fastv;
; 4160 :                j += (1 << s);
; 4161 :             }
; 4162 :          }
; 4163 :          ++next_code[s];
; 4164 :       }
; 4165 :    }
; 4166 :    return 1;
; 4167 : }
; 4168 : 
; 4169 : // zlib-from-memory implementation for PNG reading
; 4170 : //    because PNG allows splitting the zlib stream arbitrarily,
; 4171 : //    and it's annoying structurally to have PNG call ZLIB call PNG,
; 4172 : //    we require PNG read all the IDATs and combine them into a single
; 4173 : //    memory buffer
; 4174 : 
; 4175 : typedef struct
; 4176 : {
; 4177 :    stbi_uc *zbuffer, *zbuffer_end;
; 4178 :    int num_bits;
; 4179 :    stbi__uint32 code_buffer;
; 4180 : 
; 4181 :    char *zout;
; 4182 :    char *zout_start;
; 4183 :    char *zout_end;
; 4184 :    int   z_expandable;
; 4185 : 
; 4186 :    stbi__zhuffman z_length, z_distance;
; 4187 : } stbi__zbuf;
; 4188 : 
; 4189 : stbi_inline static int stbi__zeof(stbi__zbuf *z)
; 4190 : {
; 4191 :    return (z->zbuffer >= z->zbuffer_end);
; 4192 : }
; 4193 : 
; 4194 : stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
; 4195 : {
; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;
; 4197 : }
; 4198 : 
; 4199 : static void stbi__fill_bits(stbi__zbuf *z)
; 4200 : {
; 4201 :    do {
; 4202 :       if (z->code_buffer >= (1U << z->num_bits)) {
; 4203 :         z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
; 4204 :         return;
; 4205 :       }
; 4206 :       z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
; 4207 :       z->num_bits += 8;
; 4208 :    } while (z->num_bits <= 24);
; 4209 : }
; 4210 : 
; 4211 : stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
; 4212 : {
; 4213 :    unsigned int k;
; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);
; 4215 :    k = z->code_buffer & ((1 << n) - 1);
; 4216 :    z->code_buffer >>= n;
; 4217 :    z->num_bits -= n;
; 4218 :    return k;
; 4219 : }
; 4220 : 
; 4221 : static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
; 4222 : {
; 4223 :    int b,s,k;
; 4224 :    // not resolved by fast table, so compute it the slow way
; 4225 :    // use jpeg approach, which requires MSbits at top
; 4226 :    k = stbi__bit_reverse(a->code_buffer, 16);
; 4227 :    for (s=STBI__ZFAST_BITS+1; ; ++s)
; 4228 :       if (k < z->maxcode[s])
; 4229 :          break;
; 4230 :    if (s >= 16) return -1; // invalid code!
; 4231 :    // code size is s, so:
; 4232 :    b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
; 4233 :    if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
; 4234 :    if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
; 4235 :    a->code_buffer >>= s;
; 4236 :    a->num_bits -= s;
; 4237 :    return z->value[b];
; 4238 : }
; 4239 : 
; 4240 : stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
; 4241 : {
; 4242 :    int b,s;
; 4243 :    if (a->num_bits < 16) {
; 4244 :       if (stbi__zeof(a)) {
; 4245 :          return -1;   /* report error for unexpected end of data. */
; 4246 :       }
; 4247 :       stbi__fill_bits(a);
; 4248 :    }
; 4249 :    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
; 4250 :    if (b) {
; 4251 :       s = b >> 9;
; 4252 :       a->code_buffer >>= s;
; 4253 :       a->num_bits -= s;
; 4254 :       return b & 511;
; 4255 :    }
; 4256 :    return stbi__zhuffman_decode_slowpath(a, z);
; 4257 : }
; 4258 : 
; 4259 : static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
; 4260 : {
; 4261 :    char *q;
; 4262 :    unsigned int cur, limit, old_limit;
; 4263 :    z->zout = zout;
; 4264 :    if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
; 4265 :    cur   = (unsigned int) (z->zout - z->zout_start);
; 4266 :    limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
; 4267 :    if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");
; 4268 :    while (cur + n > limit) {
; 4269 :       if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");
; 4270 :       limit *= 2;
; 4271 :    }
; 4272 :    q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
; 4273 :    STBI_NOTUSED(old_limit);
; 4274 :    if (q == NULL) return stbi__err("outofmem", "Out of memory");
; 4275 :    z->zout_start = q;
; 4276 :    z->zout       = q + cur;
; 4277 :    z->zout_end   = q + limit;
; 4278 :    return 1;
; 4279 : }
; 4280 : 
; 4281 : static const int stbi__zlength_base[31] = {
; 4282 :    3,4,5,6,7,8,9,10,11,13,
; 4283 :    15,17,19,23,27,31,35,43,51,59,
; 4284 :    67,83,99,115,131,163,195,227,258,0,0 };
; 4285 : 
; 4286 : static const int stbi__zlength_extra[31]=
; 4287 : { 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };
; 4288 : 
; 4289 : static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
; 4290 : 257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};
; 4291 : 
; 4292 : static const int stbi__zdist_extra[32] =
; 4293 : { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
; 4294 : 
; 4295 : static int stbi__parse_huffman_block(stbi__zbuf *a)
; 4296 : {
; 4297 :    char *zout = a->zout;
; 4298 :    for(;;) {
; 4299 :       int z = stbi__zhuffman_decode(a, &a->z_length);
; 4300 :       if (z < 256) {
; 4301 :          if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
; 4302 :          if (zout >= a->zout_end) {
; 4303 :             if (!stbi__zexpand(a, zout, 1)) return 0;
; 4304 :             zout = a->zout;
; 4305 :          }
; 4306 :          *zout++ = (char) z;
; 4307 :       } else {
; 4308 :          stbi_uc *p;
; 4309 :          int len,dist;
; 4310 :          if (z == 256) {
; 4311 :             a->zout = zout;
; 4312 :             return 1;
; 4313 :          }
; 4314 :          if (z >= 286) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, length codes 286 and 287 must not appear in compressed data
; 4315 :          z -= 257;
; 4316 :          len = stbi__zlength_base[z];
; 4317 :          if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
; 4318 :          z = stbi__zhuffman_decode(a, &a->z_distance);
; 4319 :          if (z < 0 || z >= 30) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data
; 4320 :          dist = stbi__zdist_base[z];
; 4321 :          if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
; 4322 :          if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
; 4323 :          if (zout + len > a->zout_end) {
; 4324 :             if (!stbi__zexpand(a, zout, len)) return 0;
; 4325 :             zout = a->zout;
; 4326 :          }
; 4327 :          p = (stbi_uc *) (zout - dist);
; 4328 :          if (dist == 1) { // run of one byte; common in images.
; 4329 :             stbi_uc v = *p;
; 4330 :             if (len) { do *zout++ = v; while (--len); }
; 4331 :          } else {
; 4332 :             if (len) { do *zout++ = *p++; while (--len); }
; 4333 :          }
; 4334 :       }
; 4335 :    }
; 4336 : }
; 4337 : 
; 4338 : static int stbi__compute_huffman_codes(stbi__zbuf *a)
; 4339 : {
; 4340 :    static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
; 4341 :    stbi__zhuffman z_codelength;
; 4342 :    stbi_uc lencodes[286+32+137];//padding for maximum single op
; 4343 :    stbi_uc codelength_sizes[19];
; 4344 :    int i,n;
; 4345 : 
; 4346 :    int hlit  = stbi__zreceive(a,5) + 257;
; 4347 :    int hdist = stbi__zreceive(a,5) + 1;
; 4348 :    int hclen = stbi__zreceive(a,4) + 4;
; 4349 :    int ntot  = hlit + hdist;
; 4350 : 
; 4351 :    memset(codelength_sizes, 0, sizeof(codelength_sizes));
; 4352 :    for (i=0; i < hclen; ++i) {
; 4353 :       int s = stbi__zreceive(a,3);
; 4354 :       codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
; 4355 :    }
; 4356 :    if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;
; 4357 : 
; 4358 :    n = 0;
; 4359 :    while (n < ntot) {
; 4360 :       int c = stbi__zhuffman_decode(a, &z_codelength);
; 4361 :       if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
; 4362 :       if (c < 16)
; 4363 :          lencodes[n++] = (stbi_uc) c;
; 4364 :       else {
; 4365 :          stbi_uc fill = 0;
; 4366 :          if (c == 16) {
; 4367 :             c = stbi__zreceive(a,2)+3;
; 4368 :             if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
; 4369 :             fill = lencodes[n-1];
; 4370 :          } else if (c == 17) {
; 4371 :             c = stbi__zreceive(a,3)+3;
; 4372 :          } else if (c == 18) {
; 4373 :             c = stbi__zreceive(a,7)+11;
; 4374 :          } else {
; 4375 :             return stbi__err("bad codelengths", "Corrupt PNG");
; 4376 :          }
; 4377 :          if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
; 4378 :          memset(lencodes+n, fill, c);
; 4379 :          n += c;
; 4380 :       }
; 4381 :    }
; 4382 :    if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");
; 4383 :    if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
; 4384 :    if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
; 4385 :    return 1;
; 4386 : }
; 4387 : 
; 4388 : static int stbi__parse_uncompressed_block(stbi__zbuf *a)
; 4389 : {
; 4390 :    stbi_uc header[4];
; 4391 :    int len,nlen,k;
; 4392 :    if (a->num_bits & 7)
; 4393 :       stbi__zreceive(a, a->num_bits & 7); // discard
; 4394 :    // drain the bit-packed data into header
; 4395 :    k = 0;
; 4396 :    while (a->num_bits > 0) {
; 4397 :       header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
; 4398 :       a->code_buffer >>= 8;
; 4399 :       a->num_bits -= 8;
; 4400 :    }
; 4401 :    if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");
; 4402 :    // now fill header the normal way
; 4403 :    while (k < 4)
; 4404 :       header[k++] = stbi__zget8(a);
; 4405 :    len  = header[1] * 256 + header[0];
; 4406 :    nlen = header[3] * 256 + header[2];
; 4407 :    if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
; 4408 :    if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
; 4409 :    if (a->zout + len > a->zout_end)
; 4410 :       if (!stbi__zexpand(a, a->zout, len)) return 0;
; 4411 :    memcpy(a->zout, a->zbuffer, len);
; 4412 :    a->zbuffer += len;
; 4413 :    a->zout += len;
; 4414 :    return 1;
; 4415 : }
; 4416 : 
; 4417 : static int stbi__parse_zlib_header(stbi__zbuf *a)
; 4418 : {
; 4419 :    int cmf   = stbi__zget8(a);
; 4420 :    int cm    = cmf & 15;
; 4421 :    /* int cinfo = cmf >> 4; */
; 4422 :    int flg   = stbi__zget8(a);
; 4423 :    if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
; 4424 :    if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
; 4425 :    if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
; 4426 :    if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
; 4427 :    // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
; 4428 :    return 1;
; 4429 : }
; 4430 : 
; 4431 : static const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =
; 4432 : {
; 4433 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4434 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4435 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4436 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4437 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4438 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4439 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4440 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4441 :    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
; 4442 : };
; 4443 : static const stbi_uc stbi__zdefault_distance[32] =
; 4444 : {
; 4445 :    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
; 4446 : };
; 4447 : /*
; 4448 : Init algorithm:
; 4449 : {
; 4450 :    int i;   // use <= to match clearly with spec
; 4451 :    for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
; 4452 :    for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
; 4453 :    for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
; 4454 :    for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;
; 4455 : 
; 4456 :    for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
; 4457 : }
; 4458 : */
; 4459 : 
; 4460 : static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
; 4461 : {
; 4462 :    int final, type;
; 4463 :    if (parse_header)
; 4464 :       if (!stbi__parse_zlib_header(a)) return 0;
; 4465 :    a->num_bits = 0;
; 4466 :    a->code_buffer = 0;
; 4467 :    do {
; 4468 :       final = stbi__zreceive(a,1);
; 4469 :       type = stbi__zreceive(a,2);
; 4470 :       if (type == 0) {
; 4471 :          if (!stbi__parse_uncompressed_block(a)) return 0;
; 4472 :       } else if (type == 3) {
; 4473 :          return 0;
; 4474 :       } else {
; 4475 :          if (type == 1) {
; 4476 :             // use fixed code lengths
; 4477 :             if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
; 4478 :             if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
; 4479 :          } else {
; 4480 :             if (!stbi__compute_huffman_codes(a)) return 0;
; 4481 :          }
; 4482 :          if (!stbi__parse_huffman_block(a)) return 0;
; 4483 :       }
; 4484 :    } while (!final);
; 4485 :    return 1;
; 4486 : }
; 4487 : 
; 4488 : static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
; 4489 : {
; 4490 :    a->zout_start = obuf;
; 4491 :    a->zout       = obuf;
; 4492 :    a->zout_end   = obuf + olen;
; 4493 :    a->z_expandable = exp;
; 4494 : 
; 4495 :    return stbi__parse_zlib(a, parse_header);
; 4496 : }
; 4497 : 
; 4498 : STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
; 4499 : {
; 4500 :    stbi__zbuf a;
; 4501 :    char *p = (char *) stbi__malloc(initial_size);
; 4502 :    if (p == NULL) return NULL;
; 4503 :    a.zbuffer = (stbi_uc *) buffer;
; 4504 :    a.zbuffer_end = (stbi_uc *) buffer + len;
; 4505 :    if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
; 4506 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4507 :       return a.zout_start;
; 4508 :    } else {
; 4509 :       STBI_FREE(a.zout_start);
; 4510 :       return NULL;
; 4511 :    }
; 4512 : }
; 4513 : 
; 4514 : STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
; 4515 : {
; 4516 :    return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
; 4517 : }
; 4518 : 
; 4519 : STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
; 4520 : {
; 4521 :    stbi__zbuf a;
; 4522 :    char *p = (char *) stbi__malloc(initial_size);
; 4523 :    if (p == NULL) return NULL;
; 4524 :    a.zbuffer = (stbi_uc *) buffer;
; 4525 :    a.zbuffer_end = (stbi_uc *) buffer + len;
; 4526 :    if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
; 4527 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4528 :       return a.zout_start;
; 4529 :    } else {
; 4530 :       STBI_FREE(a.zout_start);
; 4531 :       return NULL;
; 4532 :    }
; 4533 : }
; 4534 : 
; 4535 : STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
; 4536 : {
; 4537 :    stbi__zbuf a;
; 4538 :    a.zbuffer = (stbi_uc *) ibuffer;
; 4539 :    a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
; 4540 :    if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
; 4541 :       return (int) (a.zout - a.zout_start);
; 4542 :    else
; 4543 :       return -1;
; 4544 : }
; 4545 : 
; 4546 : STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
; 4547 : {
; 4548 :    stbi__zbuf a;
; 4549 :    char *p = (char *) stbi__malloc(16384);
; 4550 :    if (p == NULL) return NULL;
; 4551 :    a.zbuffer = (stbi_uc *) buffer;
; 4552 :    a.zbuffer_end = (stbi_uc *) buffer+len;
; 4553 :    if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
; 4554 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4555 :       return a.zout_start;
; 4556 :    } else {
; 4557 :       STBI_FREE(a.zout_start);
; 4558 :       return NULL;
; 4559 :    }
; 4560 : }
; 4561 : 
; 4562 : STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
; 4563 : {
; 4564 :    stbi__zbuf a;
; 4565 :    a.zbuffer = (stbi_uc *) ibuffer;
; 4566 :    a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
; 4567 :    if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
; 4568 :       return (int) (a.zout - a.zout_start);
; 4569 :    else
; 4570 :       return -1;
; 4571 : }
; 4572 : #endif
; 4573 : 
; 4574 : // public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
; 4575 : //    simple implementation
; 4576 : //      - only 8-bit samples
; 4577 : //      - no CRC checking
; 4578 : //      - allocates lots of intermediate memory
; 4579 : //        - avoids problem of streaming data between subsystems
; 4580 : //        - avoids explicit window management
; 4581 : //    performance
; 4582 : //      - uses stb_zlib, a PD zlib implementation with fast huffman decoding
; 4583 : 
; 4584 : #ifndef STBI_NO_PNG
; 4585 : typedef struct
; 4586 : {
; 4587 :    stbi__uint32 length;
; 4588 :    stbi__uint32 type;
; 4589 : } stbi__pngchunk;
; 4590 : 
; 4591 : static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
; 4592 : {
; 4593 :    stbi__pngchunk c;
; 4594 :    c.length = stbi__get32be(s);
; 4595 :    c.type   = stbi__get32be(s);
; 4596 :    return c;
; 4597 : }
; 4598 : 
; 4599 : static int stbi__check_png_header(stbi__context *s)
; 4600 : {
; 4601 :    static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
; 4602 :    int i;
; 4603 :    for (i=0; i < 8; ++i)
; 4604 :       if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
; 4605 :    return 1;
; 4606 : }
; 4607 : 
; 4608 : typedef struct
; 4609 : {
; 4610 :    stbi__context *s;
; 4611 :    stbi_uc *idata, *expanded, *out;
; 4612 :    int depth;
; 4613 : } stbi__png;
; 4614 : 
; 4615 : 
; 4616 : enum {
; 4617 :    STBI__F_none=0,
; 4618 :    STBI__F_sub=1,
; 4619 :    STBI__F_up=2,
; 4620 :    STBI__F_avg=3,
; 4621 :    STBI__F_paeth=4,
; 4622 :    // synthetic filters used for first scanline to avoid needing a dummy row of 0s
; 4623 :    STBI__F_avg_first,
; 4624 :    STBI__F_paeth_first
; 4625 : };
; 4626 : 
; 4627 : static stbi_uc first_row_filter[5] =
; 4628 : {
; 4629 :    STBI__F_none,
; 4630 :    STBI__F_sub,
; 4631 :    STBI__F_none,
; 4632 :    STBI__F_avg_first,
; 4633 :    STBI__F_paeth_first
; 4634 : };
; 4635 : 
; 4636 : static int stbi__paeth(int a, int b, int c)
; 4637 : {
; 4638 :    int p = a + b - c;
; 4639 :    int pa = abs(p-a);
; 4640 :    int pb = abs(p-b);
; 4641 :    int pc = abs(p-c);
; 4642 :    if (pa <= pb && pa <= pc) return a;
; 4643 :    if (pb <= pc) return b;
; 4644 :    return c;
; 4645 : }
; 4646 : 
; 4647 : static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };
; 4648 : 
; 4649 : // create the png data from post-deflated data
; 4650 : static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
; 4651 : {
; 4652 :    int bytes = (depth == 16? 2 : 1);
; 4653 :    stbi__context *s = a->s;
; 4654 :    stbi__uint32 i,j,stride = x*out_n*bytes;
; 4655 :    stbi__uint32 img_len, img_width_bytes;
; 4656 :    int k;
; 4657 :    int img_n = s->img_n; // copy it into a local for later
; 4658 : 
; 4659 :    int output_bytes = out_n*bytes;
; 4660 :    int filter_bytes = img_n*bytes;
; 4661 :    int width = x;
; 4662 : 
; 4663 :    STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
; 4664 :    a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
; 4665 :    if (!a->out) return stbi__err("outofmem", "Out of memory");
; 4666 : 
; 4667 :    if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
; 4668 :    img_width_bytes = (((img_n * x * depth) + 7) >> 3);
; 4669 :    img_len = (img_width_bytes + 1) * y;
; 4670 : 
; 4671 :    // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
; 4672 :    // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
; 4673 :    // so just check for raw_len < img_len always.
; 4674 :    if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");
; 4675 : 
; 4676 :    for (j=0; j < y; ++j) {
; 4677 :       stbi_uc *cur = a->out + stride*j;
; 4678 :       stbi_uc *prior;
; 4679 :       int filter = *raw++;
; 4680 : 
; 4681 :       if (filter > 4)
; 4682 :          return stbi__err("invalid filter","Corrupt PNG");
; 4683 : 
; 4684 :       if (depth < 8) {
; 4685 :          if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");
; 4686 :          cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
; 4687 :          filter_bytes = 1;
; 4688 :          width = img_width_bytes;
; 4689 :       }
; 4690 :       prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above
; 4691 : 
; 4692 :       // if first row, use special filter that doesn't sample previous row
; 4693 :       if (j == 0) filter = first_row_filter[filter];
; 4694 : 
; 4695 :       // handle first byte explicitly
; 4696 :       for (k=0; k < filter_bytes; ++k) {
; 4697 :          switch (filter) {
; 4698 :             case STBI__F_none       : cur[k] = raw[k]; break;
; 4699 :             case STBI__F_sub        : cur[k] = raw[k]; break;
; 4700 :             case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
; 4701 :             case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;
; 4702 :             case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;
; 4703 :             case STBI__F_avg_first  : cur[k] = raw[k]; break;
; 4704 :             case STBI__F_paeth_first: cur[k] = raw[k]; break;
; 4705 :          }
; 4706 :       }
; 4707 : 
; 4708 :       if (depth == 8) {
; 4709 :          if (img_n != out_n)
; 4710 :             cur[img_n] = 255; // first pixel
; 4711 :          raw += img_n;
; 4712 :          cur += out_n;
; 4713 :          prior += out_n;
; 4714 :       } else if (depth == 16) {
; 4715 :          if (img_n != out_n) {
; 4716 :             cur[filter_bytes]   = 255; // first pixel top byte
; 4717 :             cur[filter_bytes+1] = 255; // first pixel bottom byte
; 4718 :          }
; 4719 :          raw += filter_bytes;
; 4720 :          cur += output_bytes;
; 4721 :          prior += output_bytes;
; 4722 :       } else {
; 4723 :          raw += 1;
; 4724 :          cur += 1;
; 4725 :          prior += 1;
; 4726 :       }
; 4727 : 
; 4728 :       // this is a little gross, so that we don't switch per-pixel or per-component
; 4729 :       if (depth < 8 || img_n == out_n) {
; 4730 :          int nk = (width - 1)*filter_bytes;
; 4731 :          #define STBI__CASE(f) \
; 4732 :              case f:     \
; 4733 :                 for (k=0; k < nk; ++k)
; 4734 :          switch (filter) {
; 4735 :             // "none" filter turns into a memcpy here; make that explicit.
; 4736 :             case STBI__F_none:         memcpy(cur, raw, nk); break;
; 4737 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;
; 4738 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
; 4739 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;
; 4740 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;
; 4741 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;
; 4742 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;
; 4743 :          }
; 4744 :          #undef STBI__CASE
; 4745 :          raw += nk;
; 4746 :       } else {
; 4747 :          STBI_ASSERT(img_n+1 == out_n);
; 4748 :          #define STBI__CASE(f) \
; 4749 :              case f:     \
; 4750 :                 for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
; 4751 :                    for (k=0; k < filter_bytes; ++k)
; 4752 :          switch (filter) {
; 4753 :             STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;
; 4754 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;
; 4755 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
; 4756 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;
; 4757 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;
; 4758 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;
; 4759 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;
; 4760 :          }
; 4761 :          #undef STBI__CASE
; 4762 : 
; 4763 :          // the loop above sets the high byte of the pixels' alpha, but for
; 4764 :          // 16 bit png files we also need the low byte set. we'll do that here.
; 4765 :          if (depth == 16) {
; 4766 :             cur = a->out + stride*j; // start at the beginning of the row again
; 4767 :             for (i=0; i < x; ++i,cur+=output_bytes) {
; 4768 :                cur[filter_bytes+1] = 255;
; 4769 :             }
; 4770 :          }
; 4771 :       }
; 4772 :    }
; 4773 : 
; 4774 :    // we make a separate pass to expand bits to pixels; for performance,
; 4775 :    // this could run two scanlines behind the above code, so it won't
; 4776 :    // intefere with filtering but will still be in the cache.
; 4777 :    if (depth < 8) {
; 4778 :       for (j=0; j < y; ++j) {
; 4779 :          stbi_uc *cur = a->out + stride*j;
; 4780 :          stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
; 4781 :          // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
; 4782 :          // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
; 4783 :          stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range
; 4784 : 
; 4785 :          // note that the final byte might overshoot and write more data than desired.
; 4786 :          // we can allocate enough data that this never writes out of memory, but it
; 4787 :          // could also overwrite the next scanline. can it overwrite non-empty data
; 4788 :          // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
; 4789 :          // so we need to explicitly clamp the final ones
; 4790 : 
; 4791 :          if (depth == 4) {
; 4792 :             for (k=x*img_n; k >= 2; k-=2, ++in) {
; 4793 :                *cur++ = scale * ((*in >> 4)       );
; 4794 :                *cur++ = scale * ((*in     ) & 0x0f);
; 4795 :             }
; 4796 :             if (k > 0) *cur++ = scale * ((*in >> 4)       );
; 4797 :          } else if (depth == 2) {
; 4798 :             for (k=x*img_n; k >= 4; k-=4, ++in) {
; 4799 :                *cur++ = scale * ((*in >> 6)       );
; 4800 :                *cur++ = scale * ((*in >> 4) & 0x03);
; 4801 :                *cur++ = scale * ((*in >> 2) & 0x03);
; 4802 :                *cur++ = scale * ((*in     ) & 0x03);
; 4803 :             }
; 4804 :             if (k > 0) *cur++ = scale * ((*in >> 6)       );
; 4805 :             if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
; 4806 :             if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
; 4807 :          } else if (depth == 1) {
; 4808 :             for (k=x*img_n; k >= 8; k-=8, ++in) {
; 4809 :                *cur++ = scale * ((*in >> 7)       );
; 4810 :                *cur++ = scale * ((*in >> 6) & 0x01);
; 4811 :                *cur++ = scale * ((*in >> 5) & 0x01);
; 4812 :                *cur++ = scale * ((*in >> 4) & 0x01);
; 4813 :                *cur++ = scale * ((*in >> 3) & 0x01);
; 4814 :                *cur++ = scale * ((*in >> 2) & 0x01);
; 4815 :                *cur++ = scale * ((*in >> 1) & 0x01);
; 4816 :                *cur++ = scale * ((*in     ) & 0x01);
; 4817 :             }
; 4818 :             if (k > 0) *cur++ = scale * ((*in >> 7)       );
; 4819 :             if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
; 4820 :             if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
; 4821 :             if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
; 4822 :             if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
; 4823 :             if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
; 4824 :             if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
; 4825 :          }
; 4826 :          if (img_n != out_n) {
; 4827 :             int q;
; 4828 :             // insert alpha = 255
; 4829 :             cur = a->out + stride*j;
; 4830 :             if (img_n == 1) {
; 4831 :                for (q=x-1; q >= 0; --q) {
; 4832 :                   cur[q*2+1] = 255;
; 4833 :                   cur[q*2+0] = cur[q];
; 4834 :                }
; 4835 :             } else {
; 4836 :                STBI_ASSERT(img_n == 3);
; 4837 :                for (q=x-1; q >= 0; --q) {
; 4838 :                   cur[q*4+3] = 255;
; 4839 :                   cur[q*4+2] = cur[q*3+2];
; 4840 :                   cur[q*4+1] = cur[q*3+1];
; 4841 :                   cur[q*4+0] = cur[q*3+0];
; 4842 :                }
; 4843 :             }
; 4844 :          }
; 4845 :       }
; 4846 :    } else if (depth == 16) {
; 4847 :       // force the image data from big-endian to platform-native.
; 4848 :       // this is done in a separate pass due to the decoding relying
; 4849 :       // on the data being untouched, but could probably be done
; 4850 :       // per-line during decode if care is taken.
; 4851 :       stbi_uc *cur = a->out;
; 4852 :       stbi__uint16 *cur16 = (stbi__uint16*)cur;
; 4853 : 
; 4854 :       for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {
; 4855 :          *cur16 = (cur[0] << 8) | cur[1];
; 4856 :       }
; 4857 :    }
; 4858 : 
; 4859 :    return 1;
; 4860 : }
; 4861 : 
; 4862 : static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
; 4863 : {
; 4864 :    int bytes = (depth == 16 ? 2 : 1);
; 4865 :    int out_bytes = out_n * bytes;
; 4866 :    stbi_uc *final;
; 4867 :    int p;
; 4868 :    if (!interlaced)
; 4869 :       return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);
; 4870 : 
; 4871 :    // de-interlacing
; 4872 :    final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
; 4873 :    if (!final) return stbi__err("outofmem", "Out of memory");
; 4874 :    for (p=0; p < 7; ++p) {
; 4875 :       int xorig[] = { 0,4,0,2,0,1,0 };
; 4876 :       int yorig[] = { 0,0,4,0,2,0,1 };
; 4877 :       int xspc[]  = { 8,8,4,4,2,2,1 };
; 4878 :       int yspc[]  = { 8,8,8,4,4,2,2 };
; 4879 :       int i,j,x,y;
; 4880 :       // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
; 4881 :       x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
; 4882 :       y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
; 4883 :       if (x && y) {
; 4884 :          stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
; 4885 :          if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
; 4886 :             STBI_FREE(final);
; 4887 :             return 0;
; 4888 :          }
; 4889 :          for (j=0; j < y; ++j) {
; 4890 :             for (i=0; i < x; ++i) {
; 4891 :                int out_y = j*yspc[p]+yorig[p];
; 4892 :                int out_x = i*xspc[p]+xorig[p];
; 4893 :                memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
; 4894 :                       a->out + (j*x+i)*out_bytes, out_bytes);
; 4895 :             }
; 4896 :          }
; 4897 :          STBI_FREE(a->out);
; 4898 :          image_data += img_len;
; 4899 :          image_data_len -= img_len;
; 4900 :       }
; 4901 :    }
; 4902 :    a->out = final;
; 4903 : 
; 4904 :    return 1;
; 4905 : }
; 4906 : 
; 4907 : static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
; 4908 : {
; 4909 :    stbi__context *s = z->s;
; 4910 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 4911 :    stbi_uc *p = z->out;
; 4912 : 
; 4913 :    // compute color-based transparency, assuming we've
; 4914 :    // already got 255 as the alpha value in the output
; 4915 :    STBI_ASSERT(out_n == 2 || out_n == 4);
; 4916 : 
; 4917 :    if (out_n == 2) {
; 4918 :       for (i=0; i < pixel_count; ++i) {
; 4919 :          p[1] = (p[0] == tc[0] ? 0 : 255);
; 4920 :          p += 2;
; 4921 :       }
; 4922 :    } else {
; 4923 :       for (i=0; i < pixel_count; ++i) {
; 4924 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
; 4925 :             p[3] = 0;
; 4926 :          p += 4;
; 4927 :       }
; 4928 :    }
; 4929 :    return 1;
; 4930 : }
; 4931 : 
; 4932 : static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
; 4933 : {
; 4934 :    stbi__context *s = z->s;
; 4935 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 4936 :    stbi__uint16 *p = (stbi__uint16*) z->out;
; 4937 : 
; 4938 :    // compute color-based transparency, assuming we've
; 4939 :    // already got 65535 as the alpha value in the output
; 4940 :    STBI_ASSERT(out_n == 2 || out_n == 4);
; 4941 : 
; 4942 :    if (out_n == 2) {
; 4943 :       for (i = 0; i < pixel_count; ++i) {
; 4944 :          p[1] = (p[0] == tc[0] ? 0 : 65535);
; 4945 :          p += 2;
; 4946 :       }
; 4947 :    } else {
; 4948 :       for (i = 0; i < pixel_count; ++i) {
; 4949 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
; 4950 :             p[3] = 0;
; 4951 :          p += 4;
; 4952 :       }
; 4953 :    }
; 4954 :    return 1;
; 4955 : }
; 4956 : 
; 4957 : static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
; 4958 : {
; 4959 :    stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
; 4960 :    stbi_uc *p, *temp_out, *orig = a->out;
; 4961 : 
; 4962 :    p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
; 4963 :    if (p == NULL) return stbi__err("outofmem", "Out of memory");
; 4964 : 
; 4965 :    // between here and free(out) below, exitting would leak
; 4966 :    temp_out = p;
; 4967 : 
; 4968 :    if (pal_img_n == 3) {
; 4969 :       for (i=0; i < pixel_count; ++i) {
; 4970 :          int n = orig[i]*4;
; 4971 :          p[0] = palette[n  ];
; 4972 :          p[1] = palette[n+1];
; 4973 :          p[2] = palette[n+2];
; 4974 :          p += 3;
; 4975 :       }
; 4976 :    } else {
; 4977 :       for (i=0; i < pixel_count; ++i) {
; 4978 :          int n = orig[i]*4;
; 4979 :          p[0] = palette[n  ];
; 4980 :          p[1] = palette[n+1];
; 4981 :          p[2] = palette[n+2];
; 4982 :          p[3] = palette[n+3];
; 4983 :          p += 4;
; 4984 :       }
; 4985 :    }
; 4986 :    STBI_FREE(a->out);
; 4987 :    a->out = temp_out;
; 4988 : 
; 4989 :    STBI_NOTUSED(len);
; 4990 : 
; 4991 :    return 1;
; 4992 : }
; 4993 : 
; 4994 : static int stbi__unpremultiply_on_load_global = 0;
; 4995 : static int stbi__de_iphone_flag_global = 0;
; 4996 : 
; 4997 : STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
; 4998 : {
; 4999 :    stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
; 5000 : }
; 5001 : 
; 5002 : STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
; 5003 : {
; 5004 :    stbi__de_iphone_flag_global = flag_true_if_should_convert;
; 5005 : }
; 5006 : 
; 5007 : #ifndef STBI_THREAD_LOCAL
; 5008 : #define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global
; 5009 : #define stbi__de_iphone_flag  stbi__de_iphone_flag_global
; 5010 : #else
; 5011 : static STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;
; 5012 : static STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;
; 5013 : 
; 5014 : STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
; 5015 : {
; 5016 :    stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
; 5017 :    stbi__unpremultiply_on_load_set = 1;
; 5018 : }
; 5019 : 
; 5020 : STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
; 5021 : {
; 5022 :    stbi__de_iphone_flag_local = flag_true_if_should_convert;
; 5023 :    stbi__de_iphone_flag_set = 1;
; 5024 : }
; 5025 : 
; 5026 : #define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \
; 5027 :                                        ? stbi__unpremultiply_on_load_local      \
; 5028 :                                        : stbi__unpremultiply_on_load_global)
; 5029 : #define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \
; 5030 :                                 ? stbi__de_iphone_flag_local                    \
; 5031 :                                 : stbi__de_iphone_flag_global)
; 5032 : #endif // STBI_THREAD_LOCAL
; 5033 : 
; 5034 : static void stbi__de_iphone(stbi__png *z)
; 5035 : {
; 5036 :    stbi__context *s = z->s;
; 5037 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 5038 :    stbi_uc *p = z->out;
; 5039 : 
; 5040 :    if (s->img_out_n == 3) {  // convert bgr to rgb
; 5041 :       for (i=0; i < pixel_count; ++i) {
; 5042 :          stbi_uc t = p[0];
; 5043 :          p[0] = p[2];
; 5044 :          p[2] = t;
; 5045 :          p += 3;
; 5046 :       }
; 5047 :    } else {
; 5048 :       STBI_ASSERT(s->img_out_n == 4);
; 5049 :       if (stbi__unpremultiply_on_load) {
; 5050 :          // convert bgr to rgb and unpremultiply
; 5051 :          for (i=0; i < pixel_count; ++i) {
; 5052 :             stbi_uc a = p[3];
; 5053 :             stbi_uc t = p[0];
; 5054 :             if (a) {
; 5055 :                stbi_uc half = a / 2;
; 5056 :                p[0] = (p[2] * 255 + half) / a;
; 5057 :                p[1] = (p[1] * 255 + half) / a;
; 5058 :                p[2] = ( t   * 255 + half) / a;
; 5059 :             } else {
; 5060 :                p[0] = p[2];
; 5061 :                p[2] = t;
; 5062 :             }
; 5063 :             p += 4;
; 5064 :          }
; 5065 :       } else {
; 5066 :          // convert bgr to rgb
; 5067 :          for (i=0; i < pixel_count; ++i) {
; 5068 :             stbi_uc t = p[0];
; 5069 :             p[0] = p[2];
; 5070 :             p[2] = t;
; 5071 :             p += 4;
; 5072 :          }
; 5073 :       }
; 5074 :    }
; 5075 : }
; 5076 : 
; 5077 : #define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))
; 5078 : 
; 5079 : static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
; 5080 : {
; 5081 :    stbi_uc palette[1024], pal_img_n=0;
; 5082 :    stbi_uc has_trans=0, tc[3]={0};
; 5083 :    stbi__uint16 tc16[3];
; 5084 :    stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
; 5085 :    int first=1,k,interlace=0, color=0, is_iphone=0;
; 5086 :    stbi__context *s = z->s;
; 5087 : 
; 5088 :    z->expanded = NULL;
; 5089 :    z->idata = NULL;
; 5090 :    z->out = NULL;
; 5091 : 
; 5092 :    if (!stbi__check_png_header(s)) return 0;
; 5093 : 
; 5094 :    if (scan == STBI__SCAN_type) return 1;
; 5095 : 
; 5096 :    for (;;) {
; 5097 :       stbi__pngchunk c = stbi__get_chunk_header(s);
; 5098 :       switch (c.type) {
; 5099 :          case STBI__PNG_TYPE('C','g','B','I'):
; 5100 :             is_iphone = 1;
; 5101 :             stbi__skip(s, c.length);
; 5102 :             break;
; 5103 :          case STBI__PNG_TYPE('I','H','D','R'): {
; 5104 :             int comp,filter;
; 5105 :             if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
; 5106 :             first = 0;
; 5107 :             if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
; 5108 :             s->img_x = stbi__get32be(s);
; 5109 :             s->img_y = stbi__get32be(s);
; 5110 :             if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 5111 :             if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 5112 :             z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
; 5113 :             color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
; 5114 :             if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
; 5115 :             if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
; 5116 :             comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
; 5117 :             filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
; 5118 :             interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
; 5119 :             if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
; 5120 :             if (!pal_img_n) {
; 5121 :                s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
; 5122 :                if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
; 5123 :             } else {
; 5124 :                // if paletted, then pal_n is our final components, and
; 5125 :                // img_n is # components to decompress/filter.
; 5126 :                s->img_n = 1;
; 5127 :                if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
; 5128 :             }
; 5129 :             // even with SCAN_header, have to scan to see if we have a tRNS
; 5130 :             break;
; 5131 :          }
; 5132 : 
; 5133 :          case STBI__PNG_TYPE('P','L','T','E'):  {
; 5134 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5135 :             if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
; 5136 :             pal_len = c.length / 3;
; 5137 :             if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
; 5138 :             for (i=0; i < pal_len; ++i) {
; 5139 :                palette[i*4+0] = stbi__get8(s);
; 5140 :                palette[i*4+1] = stbi__get8(s);
; 5141 :                palette[i*4+2] = stbi__get8(s);
; 5142 :                palette[i*4+3] = 255;
; 5143 :             }
; 5144 :             break;
; 5145 :          }
; 5146 : 
; 5147 :          case STBI__PNG_TYPE('t','R','N','S'): {
; 5148 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5149 :             if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
; 5150 :             if (pal_img_n) {
; 5151 :                if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
; 5152 :                if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
; 5153 :                if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
; 5154 :                pal_img_n = 4;
; 5155 :                for (i=0; i < c.length; ++i)
; 5156 :                   palette[i*4+3] = stbi__get8(s);
; 5157 :             } else {
; 5158 :                if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
; 5159 :                if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
; 5160 :                has_trans = 1;
; 5161 :                // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.
; 5162 :                if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }
; 5163 :                if (z->depth == 16) {
; 5164 :                   for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
; 5165 :                } else {
; 5166 :                   for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
; 5167 :                }
; 5168 :             }
; 5169 :             break;
; 5170 :          }
; 5171 : 
; 5172 :          case STBI__PNG_TYPE('I','D','A','T'): {
; 5173 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5174 :             if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
; 5175 :             if (scan == STBI__SCAN_header) {
; 5176 :                // header scan definitely stops at first IDAT
; 5177 :                if (pal_img_n)
; 5178 :                   s->img_n = pal_img_n;
; 5179 :                return 1;
; 5180 :             }
; 5181 :             if (c.length > (1u << 30)) return stbi__err("IDAT size limit", "IDAT section larger than 2^30 bytes");
; 5182 :             if ((int)(ioff + c.length) < (int)ioff) return 0;
; 5183 :             if (ioff + c.length > idata_limit) {
; 5184 :                stbi__uint32 idata_limit_old = idata_limit;
; 5185 :                stbi_uc *p;
; 5186 :                if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
; 5187 :                while (ioff + c.length > idata_limit)
; 5188 :                   idata_limit *= 2;
; 5189 :                STBI_NOTUSED(idata_limit_old);
; 5190 :                p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
; 5191 :                z->idata = p;
; 5192 :             }
; 5193 :             if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
; 5194 :             ioff += c.length;
; 5195 :             break;
; 5196 :          }
; 5197 : 
; 5198 :          case STBI__PNG_TYPE('I','E','N','D'): {
; 5199 :             stbi__uint32 raw_len, bpl;
; 5200 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5201 :             if (scan != STBI__SCAN_load) return 1;
; 5202 :             if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
; 5203 :             // initial guess for decoded data size to avoid unnecessary reallocs
; 5204 :             bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
; 5205 :             raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
; 5206 :             z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
; 5207 :             if (z->expanded == NULL) return 0; // zlib should set error
; 5208 :             STBI_FREE(z->idata); z->idata = NULL;
; 5209 :             if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
; 5210 :                s->img_out_n = s->img_n+1;
; 5211 :             else
; 5212 :                s->img_out_n = s->img_n;
; 5213 :             if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
; 5214 :             if (has_trans) {
; 5215 :                if (z->depth == 16) {
; 5216 :                   if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
; 5217 :                } else {
; 5218 :                   if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
; 5219 :                }
; 5220 :             }
; 5221 :             if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
; 5222 :                stbi__de_iphone(z);
; 5223 :             if (pal_img_n) {
; 5224 :                // pal_img_n == 3 or 4
; 5225 :                s->img_n = pal_img_n; // record the actual colors we had
; 5226 :                s->img_out_n = pal_img_n;
; 5227 :                if (req_comp >= 3) s->img_out_n = req_comp;
; 5228 :                if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
; 5229 :                   return 0;
; 5230 :             } else if (has_trans) {
; 5231 :                // non-paletted image with tRNS -> source image has (constant) alpha
; 5232 :                ++s->img_n;
; 5233 :             }
; 5234 :             STBI_FREE(z->expanded); z->expanded = NULL;
; 5235 :             // end of PNG chunk, read and skip CRC
; 5236 :             stbi__get32be(s);
; 5237 :             return 1;
; 5238 :          }
; 5239 : 
; 5240 :          default:
; 5241 :             // if critical, fail
; 5242 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5243 :             if ((c.type & (1 << 29)) == 0) {
; 5244 :                #ifndef STBI_NO_FAILURE_STRINGS
; 5245 :                // not threadsafe
; 5246 :                static char invalid_chunk[] = "XXXX PNG chunk not known";
; 5247 :                invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
; 5248 :                invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
; 5249 :                invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
; 5250 :                invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
; 5251 :                #endif
; 5252 :                return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
; 5253 :             }
; 5254 :             stbi__skip(s, c.length);
; 5255 :             break;
; 5256 :       }
; 5257 :       // end of PNG chunk, read and skip CRC
; 5258 :       stbi__get32be(s);
; 5259 :    }
; 5260 : }
; 5261 : 
; 5262 : static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
; 5263 : {
; 5264 :    void *result=NULL;
; 5265 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
; 5266 :    if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
; 5267 :       if (p->depth <= 8)
; 5268 :          ri->bits_per_channel = 8;
; 5269 :       else if (p->depth == 16)
; 5270 :          ri->bits_per_channel = 16;
; 5271 :       else
; 5272 :          return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
; 5273 :       result = p->out;
; 5274 :       p->out = NULL;
; 5275 :       if (req_comp && req_comp != p->s->img_out_n) {
; 5276 :          if (ri->bits_per_channel == 8)
; 5277 :             result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
; 5278 :          else
; 5279 :             result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
; 5280 :          p->s->img_out_n = req_comp;
; 5281 :          if (result == NULL) return result;
; 5282 :       }
; 5283 :       *x = p->s->img_x;
; 5284 :       *y = p->s->img_y;
; 5285 :       if (n) *n = p->s->img_n;
; 5286 :    }
; 5287 :    STBI_FREE(p->out);      p->out      = NULL;
; 5288 :    STBI_FREE(p->expanded); p->expanded = NULL;
; 5289 :    STBI_FREE(p->idata);    p->idata    = NULL;
; 5290 : 
; 5291 :    return result;
; 5292 : }
; 5293 : 
; 5294 : static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5295 : {
; 5296 :    stbi__png p;
; 5297 :    p.s = s;
; 5298 :    return stbi__do_png(&p, x,y,comp,req_comp, ri);
; 5299 : }
; 5300 : 
; 5301 : static int stbi__png_test(stbi__context *s)
; 5302 : {
; 5303 :    int r;
; 5304 :    r = stbi__check_png_header(s);
; 5305 :    stbi__rewind(s);
; 5306 :    return r;
; 5307 : }
; 5308 : 
; 5309 : static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
; 5310 : {
; 5311 :    if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
; 5312 :       stbi__rewind( p->s );
; 5313 :       return 0;
; 5314 :    }
; 5315 :    if (x) *x = p->s->img_x;
; 5316 :    if (y) *y = p->s->img_y;
; 5317 :    if (comp) *comp = p->s->img_n;
; 5318 :    return 1;
; 5319 : }
; 5320 : 
; 5321 : static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
; 5322 : {
; 5323 :    stbi__png p;
; 5324 :    p.s = s;
; 5325 :    return stbi__png_info_raw(&p, x, y, comp);
; 5326 : }
; 5327 : 
; 5328 : static int stbi__png_is16(stbi__context *s)
; 5329 : {
; 5330 :    stbi__png p;
; 5331 :    p.s = s;
; 5332 :    if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
; 5333 : 	   return 0;
; 5334 :    if (p.depth != 16) {
; 5335 :       stbi__rewind(p.s);
; 5336 :       return 0;
; 5337 :    }
; 5338 :    return 1;
; 5339 : }
; 5340 : #endif
; 5341 : 
; 5342 : // Microsoft/Windows BMP image
; 5343 : 
; 5344 : #ifndef STBI_NO_BMP
; 5345 : static int stbi__bmp_test_raw(stbi__context *s)
; 5346 : {
; 5347 :    int r;
; 5348 :    int sz;
; 5349 :    if (stbi__get8(s) != 'B') return 0;
; 5350 :    if (stbi__get8(s) != 'M') return 0;
; 5351 :    stbi__get32le(s); // discard filesize
; 5352 :    stbi__get16le(s); // discard reserved
; 5353 :    stbi__get16le(s); // discard reserved
; 5354 :    stbi__get32le(s); // discard data offset
; 5355 :    sz = stbi__get32le(s);
; 5356 :    r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
; 5357 :    return r;
; 5358 : }
; 5359 : 
; 5360 : static int stbi__bmp_test(stbi__context *s)
; 5361 : {
; 5362 :    int r = stbi__bmp_test_raw(s);
; 5363 :    stbi__rewind(s);
; 5364 :    return r;
; 5365 : }
; 5366 : 
; 5367 : 
; 5368 : // returns 0..31 for the highest set bit
; 5369 : static int stbi__high_bit(unsigned int z)
; 5370 : {
; 5371 :    int n=0;
; 5372 :    if (z == 0) return -1;
; 5373 :    if (z >= 0x10000) { n += 16; z >>= 16; }
; 5374 :    if (z >= 0x00100) { n +=  8; z >>=  8; }
; 5375 :    if (z >= 0x00010) { n +=  4; z >>=  4; }
; 5376 :    if (z >= 0x00004) { n +=  2; z >>=  2; }
; 5377 :    if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
; 5378 :    return n;
; 5379 : }
; 5380 : 
; 5381 : static int stbi__bitcount(unsigned int a)
; 5382 : {
; 5383 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
; 5384 :    a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
; 5385 :    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
; 5386 :    a = (a + (a >> 8)); // max 16 per 8 bits
; 5387 :    a = (a + (a >> 16)); // max 32 per 8 bits
; 5388 :    return a & 0xff;
; 5389 : }
; 5390 : 
; 5391 : // extract an arbitrarily-aligned N-bit value (N=bits)
; 5392 : // from v, and then make it 8-bits long and fractionally
; 5393 : // extend it to full full range.
; 5394 : static int stbi__shiftsigned(unsigned int v, int shift, int bits)
; 5395 : {
; 5396 :    static unsigned int mul_table[9] = {
; 5397 :       0,
; 5398 :       0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
; 5399 :       0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
; 5400 :    };
; 5401 :    static unsigned int shift_table[9] = {
; 5402 :       0, 0,0,1,0,2,4,6,0,
; 5403 :    };
; 5404 :    if (shift < 0)
; 5405 :       v <<= -shift;
; 5406 :    else
; 5407 :       v >>= shift;
; 5408 :    STBI_ASSERT(v < 256);
; 5409 :    v >>= (8-bits);
; 5410 :    STBI_ASSERT(bits >= 0 && bits <= 8);
; 5411 :    return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
; 5412 : }
; 5413 : 
; 5414 : typedef struct
; 5415 : {
; 5416 :    int bpp, offset, hsz;
; 5417 :    unsigned int mr,mg,mb,ma, all_a;
; 5418 :    int extra_read;
; 5419 : } stbi__bmp_data;
; 5420 : 
; 5421 : static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
; 5422 : {
; 5423 :    // BI_BITFIELDS specifies masks explicitly, don't override
; 5424 :    if (compress == 3)
; 5425 :       return 1;
; 5426 : 
; 5427 :    if (compress == 0) {
; 5428 :       if (info->bpp == 16) {
; 5429 :          info->mr = 31u << 10;
; 5430 :          info->mg = 31u <<  5;
; 5431 :          info->mb = 31u <<  0;
; 5432 :       } else if (info->bpp == 32) {
; 5433 :          info->mr = 0xffu << 16;
; 5434 :          info->mg = 0xffu <<  8;
; 5435 :          info->mb = 0xffu <<  0;
; 5436 :          info->ma = 0xffu << 24;
; 5437 :          info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
; 5438 :       } else {
; 5439 :          // otherwise, use defaults, which is all-0
; 5440 :          info->mr = info->mg = info->mb = info->ma = 0;
; 5441 :       }
; 5442 :       return 1;
; 5443 :    }
; 5444 :    return 0; // error
; 5445 : }
; 5446 : 
; 5447 : static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
; 5448 : {
; 5449 :    int hsz;
; 5450 :    if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
; 5451 :    stbi__get32le(s); // discard filesize
; 5452 :    stbi__get16le(s); // discard reserved
; 5453 :    stbi__get16le(s); // discard reserved
; 5454 :    info->offset = stbi__get32le(s);
; 5455 :    info->hsz = hsz = stbi__get32le(s);
; 5456 :    info->mr = info->mg = info->mb = info->ma = 0;
; 5457 :    info->extra_read = 14;
; 5458 : 
; 5459 :    if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");
; 5460 : 
; 5461 :    if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
; 5462 :    if (hsz == 12) {
; 5463 :       s->img_x = stbi__get16le(s);
; 5464 :       s->img_y = stbi__get16le(s);
; 5465 :    } else {
; 5466 :       s->img_x = stbi__get32le(s);
; 5467 :       s->img_y = stbi__get32le(s);
; 5468 :    }
; 5469 :    if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
; 5470 :    info->bpp = stbi__get16le(s);
; 5471 :    if (hsz != 12) {
; 5472 :       int compress = stbi__get32le(s);
; 5473 :       if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
; 5474 :       if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes
; 5475 :       if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel
; 5476 :       stbi__get32le(s); // discard sizeof
; 5477 :       stbi__get32le(s); // discard hres
; 5478 :       stbi__get32le(s); // discard vres
; 5479 :       stbi__get32le(s); // discard colorsused
; 5480 :       stbi__get32le(s); // discard max important
; 5481 :       if (hsz == 40 || hsz == 56) {
; 5482 :          if (hsz == 56) {
; 5483 :             stbi__get32le(s);
; 5484 :             stbi__get32le(s);
; 5485 :             stbi__get32le(s);
; 5486 :             stbi__get32le(s);
; 5487 :          }
; 5488 :          if (info->bpp == 16 || info->bpp == 32) {
; 5489 :             if (compress == 0) {
; 5490 :                stbi__bmp_set_mask_defaults(info, compress);
; 5491 :             } else if (compress == 3) {
; 5492 :                info->mr = stbi__get32le(s);
; 5493 :                info->mg = stbi__get32le(s);
; 5494 :                info->mb = stbi__get32le(s);
; 5495 :                info->extra_read += 12;
; 5496 :                // not documented, but generated by photoshop and handled by mspaint
; 5497 :                if (info->mr == info->mg && info->mg == info->mb) {
; 5498 :                   // ?!?!?
; 5499 :                   return stbi__errpuc("bad BMP", "bad BMP");
; 5500 :                }
; 5501 :             } else
; 5502 :                return stbi__errpuc("bad BMP", "bad BMP");
; 5503 :          }
; 5504 :       } else {
; 5505 :          // V4/V5 header
; 5506 :          int i;
; 5507 :          if (hsz != 108 && hsz != 124)
; 5508 :             return stbi__errpuc("bad BMP", "bad BMP");
; 5509 :          info->mr = stbi__get32le(s);
; 5510 :          info->mg = stbi__get32le(s);
; 5511 :          info->mb = stbi__get32le(s);
; 5512 :          info->ma = stbi__get32le(s);
; 5513 :          if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
; 5514 :             stbi__bmp_set_mask_defaults(info, compress);
; 5515 :          stbi__get32le(s); // discard color space
; 5516 :          for (i=0; i < 12; ++i)
; 5517 :             stbi__get32le(s); // discard color space parameters
; 5518 :          if (hsz == 124) {
; 5519 :             stbi__get32le(s); // discard rendering intent
; 5520 :             stbi__get32le(s); // discard offset of profile data
; 5521 :             stbi__get32le(s); // discard size of profile data
; 5522 :             stbi__get32le(s); // discard reserved
; 5523 :          }
; 5524 :       }
; 5525 :    }
; 5526 :    return (void *) 1;
; 5527 : }
; 5528 : 
; 5529 : 
; 5530 : static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5531 : {
; 5532 :    stbi_uc *out;
; 5533 :    unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
; 5534 :    stbi_uc pal[256][4];
; 5535 :    int psize=0,i,j,width;
; 5536 :    int flip_vertically, pad, target;
; 5537 :    stbi__bmp_data info;
; 5538 :    STBI_NOTUSED(ri);
; 5539 : 
; 5540 :    info.all_a = 255;
; 5541 :    if (stbi__bmp_parse_header(s, &info) == NULL)
; 5542 :       return NULL; // error code already set
; 5543 : 
; 5544 :    flip_vertically = ((int) s->img_y) > 0;
; 5545 :    s->img_y = abs((int) s->img_y);
; 5546 : 
; 5547 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5548 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5549 : 
; 5550 :    mr = info.mr;
; 5551 :    mg = info.mg;
; 5552 :    mb = info.mb;
; 5553 :    ma = info.ma;
; 5554 :    all_a = info.all_a;
; 5555 : 
; 5556 :    if (info.hsz == 12) {
; 5557 :       if (info.bpp < 24)
; 5558 :          psize = (info.offset - info.extra_read - 24) / 3;
; 5559 :    } else {
; 5560 :       if (info.bpp < 16)
; 5561 :          psize = (info.offset - info.extra_read - info.hsz) >> 2;
; 5562 :    }
; 5563 :    if (psize == 0) {
; 5564 :       // accept some number of extra bytes after the header, but if the offset points either to before
; 5565 :       // the header ends or implies a large amount of extra data, reject the file as malformed
; 5566 :       int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);
; 5567 :       int header_limit = 1024; // max we actually read is below 256 bytes currently.
; 5568 :       int extra_data_limit = 256*4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.
; 5569 :       if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {
; 5570 :          return stbi__errpuc("bad header", "Corrupt BMP");
; 5571 :       }
; 5572 :       // we established that bytes_read_so_far is positive and sensible.
; 5573 :       // the first half of this test rejects offsets that are either too small positives, or
; 5574 :       // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn
; 5575 :       // ensures the number computed in the second half of the test can't overflow.
; 5576 :       if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {
; 5577 :          return stbi__errpuc("bad offset", "Corrupt BMP");
; 5578 :       } else {
; 5579 :          stbi__skip(s, info.offset - bytes_read_so_far);
; 5580 :       }
; 5581 :    }
; 5582 : 
; 5583 :    if (info.bpp == 24 && ma == 0xff000000)
; 5584 :       s->img_n = 3;
; 5585 :    else
; 5586 :       s->img_n = ma ? 4 : 3;
; 5587 :    if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
; 5588 :       target = req_comp;
; 5589 :    else
; 5590 :       target = s->img_n; // if they want monochrome, we'll post-convert
; 5591 : 
; 5592 :    // sanity-check size
; 5593 :    if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
; 5594 :       return stbi__errpuc("too large", "Corrupt BMP");
; 5595 : 
; 5596 :    out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
; 5597 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");
; 5598 :    if (info.bpp < 16) {
; 5599 :       int z=0;
; 5600 :       if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
; 5601 :       for (i=0; i < psize; ++i) {
; 5602 :          pal[i][2] = stbi__get8(s);
; 5603 :          pal[i][1] = stbi__get8(s);
; 5604 :          pal[i][0] = stbi__get8(s);
; 5605 :          if (info.hsz != 12) stbi__get8(s);
; 5606 :          pal[i][3] = 255;
; 5607 :       }
; 5608 :       stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
; 5609 :       if (info.bpp == 1) width = (s->img_x + 7) >> 3;
; 5610 :       else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
; 5611 :       else if (info.bpp == 8) width = s->img_x;
; 5612 :       else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
; 5613 :       pad = (-width)&3;
; 5614 :       if (info.bpp == 1) {
; 5615 :          for (j=0; j < (int) s->img_y; ++j) {
; 5616 :             int bit_offset = 7, v = stbi__get8(s);
; 5617 :             for (i=0; i < (int) s->img_x; ++i) {
; 5618 :                int color = (v>>bit_offset)&0x1;
; 5619 :                out[z++] = pal[color][0];
; 5620 :                out[z++] = pal[color][1];
; 5621 :                out[z++] = pal[color][2];
; 5622 :                if (target == 4) out[z++] = 255;
; 5623 :                if (i+1 == (int) s->img_x) break;
; 5624 :                if((--bit_offset) < 0) {
; 5625 :                   bit_offset = 7;
; 5626 :                   v = stbi__get8(s);
; 5627 :                }
; 5628 :             }
; 5629 :             stbi__skip(s, pad);
; 5630 :          }
; 5631 :       } else {
; 5632 :          for (j=0; j < (int) s->img_y; ++j) {
; 5633 :             for (i=0; i < (int) s->img_x; i += 2) {
; 5634 :                int v=stbi__get8(s),v2=0;
; 5635 :                if (info.bpp == 4) {
; 5636 :                   v2 = v & 15;
; 5637 :                   v >>= 4;
; 5638 :                }
; 5639 :                out[z++] = pal[v][0];
; 5640 :                out[z++] = pal[v][1];
; 5641 :                out[z++] = pal[v][2];
; 5642 :                if (target == 4) out[z++] = 255;
; 5643 :                if (i+1 == (int) s->img_x) break;
; 5644 :                v = (info.bpp == 8) ? stbi__get8(s) : v2;
; 5645 :                out[z++] = pal[v][0];
; 5646 :                out[z++] = pal[v][1];
; 5647 :                out[z++] = pal[v][2];
; 5648 :                if (target == 4) out[z++] = 255;
; 5649 :             }
; 5650 :             stbi__skip(s, pad);
; 5651 :          }
; 5652 :       }
; 5653 :    } else {
; 5654 :       int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
; 5655 :       int z = 0;
; 5656 :       int easy=0;
; 5657 :       stbi__skip(s, info.offset - info.extra_read - info.hsz);
; 5658 :       if (info.bpp == 24) width = 3 * s->img_x;
; 5659 :       else if (info.bpp == 16) width = 2*s->img_x;
; 5660 :       else /* bpp = 32 and pad = 0 */ width=0;
; 5661 :       pad = (-width) & 3;
; 5662 :       if (info.bpp == 24) {
; 5663 :          easy = 1;
; 5664 :       } else if (info.bpp == 32) {
; 5665 :          if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
; 5666 :             easy = 2;
; 5667 :       }
; 5668 :       if (!easy) {
; 5669 :          if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
; 5670 :          // right shift amt to put high bit in position #7
; 5671 :          rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
; 5672 :          gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
; 5673 :          bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
; 5674 :          ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
; 5675 :          if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
; 5676 :       }
; 5677 :       for (j=0; j < (int) s->img_y; ++j) {
; 5678 :          if (easy) {
; 5679 :             for (i=0; i < (int) s->img_x; ++i) {
; 5680 :                unsigned char a;
; 5681 :                out[z+2] = stbi__get8(s);
; 5682 :                out[z+1] = stbi__get8(s);
; 5683 :                out[z+0] = stbi__get8(s);
; 5684 :                z += 3;
; 5685 :                a = (easy == 2 ? stbi__get8(s) : 255);
; 5686 :                all_a |= a;
; 5687 :                if (target == 4) out[z++] = a;
; 5688 :             }
; 5689 :          } else {
; 5690 :             int bpp = info.bpp;
; 5691 :             for (i=0; i < (int) s->img_x; ++i) {
; 5692 :                stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
; 5693 :                unsigned int a;
; 5694 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
; 5695 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
; 5696 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
; 5697 :                a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
; 5698 :                all_a |= a;
; 5699 :                if (target == 4) out[z++] = STBI__BYTECAST(a);
; 5700 :             }
; 5701 :          }
; 5702 :          stbi__skip(s, pad);
; 5703 :       }
; 5704 :    }
; 5705 : 
; 5706 :    // if alpha channel is all 0s, replace with all 255s
; 5707 :    if (target == 4 && all_a == 0)
; 5708 :       for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
; 5709 :          out[i] = 255;
; 5710 : 
; 5711 :    if (flip_vertically) {
; 5712 :       stbi_uc t;
; 5713 :       for (j=0; j < (int) s->img_y>>1; ++j) {
; 5714 :          stbi_uc *p1 = out +      j     *s->img_x*target;
; 5715 :          stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
; 5716 :          for (i=0; i < (int) s->img_x*target; ++i) {
; 5717 :             t = p1[i]; p1[i] = p2[i]; p2[i] = t;
; 5718 :          }
; 5719 :       }
; 5720 :    }
; 5721 : 
; 5722 :    if (req_comp && req_comp != target) {
; 5723 :       out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
; 5724 :       if (out == NULL) return out; // stbi__convert_format frees input on failure
; 5725 :    }
; 5726 : 
; 5727 :    *x = s->img_x;
; 5728 :    *y = s->img_y;
; 5729 :    if (comp) *comp = s->img_n;
; 5730 :    return out;
; 5731 : }
; 5732 : #endif
; 5733 : 
; 5734 : // Targa Truevision - TGA
; 5735 : // by Jonathan Dummer
; 5736 : #ifndef STBI_NO_TGA
; 5737 : // returns STBI_rgb or whatever, 0 on error
; 5738 : static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
; 5739 : {
; 5740 :    // only RGB or RGBA (incl. 16bit) or grey allowed
; 5741 :    if (is_rgb16) *is_rgb16 = 0;
; 5742 :    switch(bits_per_pixel) {
; 5743 :       case 8:  return STBI_grey;
; 5744 :       case 16: if(is_grey) return STBI_grey_alpha;
; 5745 :                // fallthrough
; 5746 :       case 15: if(is_rgb16) *is_rgb16 = 1;
; 5747 :                return STBI_rgb;
; 5748 :       case 24: // fallthrough
; 5749 :       case 32: return bits_per_pixel/8;
; 5750 :       default: return 0;
; 5751 :    }
; 5752 : }
; 5753 : 
; 5754 : static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
; 5755 : {
; 5756 :     int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
; 5757 :     int sz, tga_colormap_type;
; 5758 :     stbi__get8(s);                   // discard Offset
; 5759 :     tga_colormap_type = stbi__get8(s); // colormap type
; 5760 :     if( tga_colormap_type > 1 ) {
; 5761 :         stbi__rewind(s);
; 5762 :         return 0;      // only RGB or indexed allowed
; 5763 :     }
; 5764 :     tga_image_type = stbi__get8(s); // image type
; 5765 :     if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
; 5766 :         if (tga_image_type != 1 && tga_image_type != 9) {
; 5767 :             stbi__rewind(s);
; 5768 :             return 0;
; 5769 :         }
; 5770 :         stbi__skip(s,4);       // skip index of first colormap entry and number of entries
; 5771 :         sz = stbi__get8(s);    //   check bits per palette color entry
; 5772 :         if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
; 5773 :             stbi__rewind(s);
; 5774 :             return 0;
; 5775 :         }
; 5776 :         stbi__skip(s,4);       // skip image x and y origin
; 5777 :         tga_colormap_bpp = sz;
; 5778 :     } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
; 5779 :         if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
; 5780 :             stbi__rewind(s);
; 5781 :             return 0; // only RGB or grey allowed, +/- RLE
; 5782 :         }
; 5783 :         stbi__skip(s,9); // skip colormap specification and image x/y origin
; 5784 :         tga_colormap_bpp = 0;
; 5785 :     }
; 5786 :     tga_w = stbi__get16le(s);
; 5787 :     if( tga_w < 1 ) {
; 5788 :         stbi__rewind(s);
; 5789 :         return 0;   // test width
; 5790 :     }
; 5791 :     tga_h = stbi__get16le(s);
; 5792 :     if( tga_h < 1 ) {
; 5793 :         stbi__rewind(s);
; 5794 :         return 0;   // test height
; 5795 :     }
; 5796 :     tga_bits_per_pixel = stbi__get8(s); // bits per pixel
; 5797 :     stbi__get8(s); // ignore alpha bits
; 5798 :     if (tga_colormap_bpp != 0) {
; 5799 :         if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
; 5800 :             // when using a colormap, tga_bits_per_pixel is the size of the indexes
; 5801 :             // I don't think anything but 8 or 16bit indexes makes sense
; 5802 :             stbi__rewind(s);
; 5803 :             return 0;
; 5804 :         }
; 5805 :         tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
; 5806 :     } else {
; 5807 :         tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
; 5808 :     }
; 5809 :     if(!tga_comp) {
; 5810 :       stbi__rewind(s);
; 5811 :       return 0;
; 5812 :     }
; 5813 :     if (x) *x = tga_w;
; 5814 :     if (y) *y = tga_h;
; 5815 :     if (comp) *comp = tga_comp;
; 5816 :     return 1;                   // seems to have passed everything
; 5817 : }
; 5818 : 
; 5819 : static int stbi__tga_test(stbi__context *s)
; 5820 : {
; 5821 :    int res = 0;
; 5822 :    int sz, tga_color_type;
; 5823 :    stbi__get8(s);      //   discard Offset
; 5824 :    tga_color_type = stbi__get8(s);   //   color type
; 5825 :    if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
; 5826 :    sz = stbi__get8(s);   //   image type
; 5827 :    if ( tga_color_type == 1 ) { // colormapped (paletted) image
; 5828 :       if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
; 5829 :       stbi__skip(s,4);       // skip index of first colormap entry and number of entries
; 5830 :       sz = stbi__get8(s);    //   check bits per palette color entry
; 5831 :       if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
; 5832 :       stbi__skip(s,4);       // skip image x and y origin
; 5833 :    } else { // "normal" image w/o colormap
; 5834 :       if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
; 5835 :       stbi__skip(s,9); // skip colormap specification and image x/y origin
; 5836 :    }
; 5837 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
; 5838 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
; 5839 :    sz = stbi__get8(s);   //   bits per pixel
; 5840 :    if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
; 5841 :    if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
; 5842 : 
; 5843 :    res = 1; // if we got this far, everything's good and we can return 1 instead of 0
; 5844 : 
; 5845 : errorEnd:
; 5846 :    stbi__rewind(s);
; 5847 :    return res;
; 5848 : }
; 5849 : 
; 5850 : // read 16bit value and convert to 24bit RGB
; 5851 : static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
; 5852 : {
; 5853 :    stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
; 5854 :    stbi__uint16 fiveBitMask = 31;
; 5855 :    // we have 3 channels with 5bits each
; 5856 :    int r = (px >> 10) & fiveBitMask;
; 5857 :    int g = (px >> 5) & fiveBitMask;
; 5858 :    int b = px & fiveBitMask;
; 5859 :    // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
; 5860 :    out[0] = (stbi_uc)((r * 255)/31);
; 5861 :    out[1] = (stbi_uc)((g * 255)/31);
; 5862 :    out[2] = (stbi_uc)((b * 255)/31);
; 5863 : 
; 5864 :    // some people claim that the most significant bit might be used for alpha
; 5865 :    // (possibly if an alpha-bit is set in the "image descriptor byte")
; 5866 :    // but that only made 16bit test images completely translucent..
; 5867 :    // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
; 5868 : }
; 5869 : 
; 5870 : static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5871 : {
; 5872 :    //   read in the TGA header stuff
; 5873 :    int tga_offset = stbi__get8(s);
; 5874 :    int tga_indexed = stbi__get8(s);
; 5875 :    int tga_image_type = stbi__get8(s);
; 5876 :    int tga_is_RLE = 0;
; 5877 :    int tga_palette_start = stbi__get16le(s);
; 5878 :    int tga_palette_len = stbi__get16le(s);
; 5879 :    int tga_palette_bits = stbi__get8(s);
; 5880 :    int tga_x_origin = stbi__get16le(s);
; 5881 :    int tga_y_origin = stbi__get16le(s);
; 5882 :    int tga_width = stbi__get16le(s);
; 5883 :    int tga_height = stbi__get16le(s);
; 5884 :    int tga_bits_per_pixel = stbi__get8(s);
; 5885 :    int tga_comp, tga_rgb16=0;
; 5886 :    int tga_inverted = stbi__get8(s);
; 5887 :    // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
; 5888 :    //   image data
; 5889 :    unsigned char *tga_data;
; 5890 :    unsigned char *tga_palette = NULL;
; 5891 :    int i, j;
; 5892 :    unsigned char raw_data[4] = {0};
; 5893 :    int RLE_count = 0;
; 5894 :    int RLE_repeating = 0;
; 5895 :    int read_next_pixel = 1;
; 5896 :    STBI_NOTUSED(ri);
; 5897 :    STBI_NOTUSED(tga_x_origin); // @TODO
; 5898 :    STBI_NOTUSED(tga_y_origin); // @TODO
; 5899 : 
; 5900 :    if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5901 :    if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5902 : 
; 5903 :    //   do a tiny bit of precessing
; 5904 :    if ( tga_image_type >= 8 )
; 5905 :    {
; 5906 :       tga_image_type -= 8;
; 5907 :       tga_is_RLE = 1;
; 5908 :    }
; 5909 :    tga_inverted = 1 - ((tga_inverted >> 5) & 1);
; 5910 : 
; 5911 :    //   If I'm paletted, then I'll use the number of bits from the palette
; 5912 :    if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
; 5913 :    else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);
; 5914 : 
; 5915 :    if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
; 5916 :       return stbi__errpuc("bad format", "Can't find out TGA pixelformat");
; 5917 : 
; 5918 :    //   tga info
; 5919 :    *x = tga_width;
; 5920 :    *y = tga_height;
; 5921 :    if (comp) *comp = tga_comp;
; 5922 : 
; 5923 :    if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
; 5924 :       return stbi__errpuc("too large", "Corrupt TGA");
; 5925 : 
; 5926 :    tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
; 5927 :    if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");
; 5928 : 
; 5929 :    // skip to the data's starting position (offset usually = 0)
; 5930 :    stbi__skip(s, tga_offset );
; 5931 : 
; 5932 :    if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
; 5933 :       for (i=0; i < tga_height; ++i) {
; 5934 :          int row = tga_inverted ? tga_height -i - 1 : i;
; 5935 :          stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
; 5936 :          stbi__getn(s, tga_row, tga_width * tga_comp);
; 5937 :       }
; 5938 :    } else  {
; 5939 :       //   do I need to load a palette?
; 5940 :       if ( tga_indexed)
; 5941 :       {
; 5942 :          if (tga_palette_len == 0) {  /* you have to have at least one entry! */
; 5943 :             STBI_FREE(tga_data);
; 5944 :             return stbi__errpuc("bad palette", "Corrupt TGA");
; 5945 :          }
; 5946 : 
; 5947 :          //   any data to skip? (offset usually = 0)
; 5948 :          stbi__skip(s, tga_palette_start );
; 5949 :          //   load the palette
; 5950 :          tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
; 5951 :          if (!tga_palette) {
; 5952 :             STBI_FREE(tga_data);
; 5953 :             return stbi__errpuc("outofmem", "Out of memory");
; 5954 :          }
; 5955 :          if (tga_rgb16) {
; 5956 :             stbi_uc *pal_entry = tga_palette;
; 5957 :             STBI_ASSERT(tga_comp == STBI_rgb);
; 5958 :             for (i=0; i < tga_palette_len; ++i) {
; 5959 :                stbi__tga_read_rgb16(s, pal_entry);
; 5960 :                pal_entry += tga_comp;
; 5961 :             }
; 5962 :          } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
; 5963 :                STBI_FREE(tga_data);
; 5964 :                STBI_FREE(tga_palette);
; 5965 :                return stbi__errpuc("bad palette", "Corrupt TGA");
; 5966 :          }
; 5967 :       }
; 5968 :       //   load the data
; 5969 :       for (i=0; i < tga_width * tga_height; ++i)
; 5970 :       {
; 5971 :          //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
; 5972 :          if ( tga_is_RLE )
; 5973 :          {
; 5974 :             if ( RLE_count == 0 )
; 5975 :             {
; 5976 :                //   yep, get the next byte as a RLE command
; 5977 :                int RLE_cmd = stbi__get8(s);
; 5978 :                RLE_count = 1 + (RLE_cmd & 127);
; 5979 :                RLE_repeating = RLE_cmd >> 7;
; 5980 :                read_next_pixel = 1;
; 5981 :             } else if ( !RLE_repeating )
; 5982 :             {
; 5983 :                read_next_pixel = 1;
; 5984 :             }
; 5985 :          } else
; 5986 :          {
; 5987 :             read_next_pixel = 1;
; 5988 :          }
; 5989 :          //   OK, if I need to read a pixel, do it now
; 5990 :          if ( read_next_pixel )
; 5991 :          {
; 5992 :             //   load however much data we did have
; 5993 :             if ( tga_indexed )
; 5994 :             {
; 5995 :                // read in index, then perform the lookup
; 5996 :                int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
; 5997 :                if ( pal_idx >= tga_palette_len ) {
; 5998 :                   // invalid index
; 5999 :                   pal_idx = 0;
; 6000 :                }
; 6001 :                pal_idx *= tga_comp;
; 6002 :                for (j = 0; j < tga_comp; ++j) {
; 6003 :                   raw_data[j] = tga_palette[pal_idx+j];
; 6004 :                }
; 6005 :             } else if(tga_rgb16) {
; 6006 :                STBI_ASSERT(tga_comp == STBI_rgb);
; 6007 :                stbi__tga_read_rgb16(s, raw_data);
; 6008 :             } else {
; 6009 :                //   read in the data raw
; 6010 :                for (j = 0; j < tga_comp; ++j) {
; 6011 :                   raw_data[j] = stbi__get8(s);
; 6012 :                }
; 6013 :             }
; 6014 :             //   clear the reading flag for the next pixel
; 6015 :             read_next_pixel = 0;
; 6016 :          } // end of reading a pixel
; 6017 : 
; 6018 :          // copy data
; 6019 :          for (j = 0; j < tga_comp; ++j)
; 6020 :            tga_data[i*tga_comp+j] = raw_data[j];
; 6021 : 
; 6022 :          //   in case we're in RLE mode, keep counting down
; 6023 :          --RLE_count;
; 6024 :       }
; 6025 :       //   do I need to invert the image?
; 6026 :       if ( tga_inverted )
; 6027 :       {
; 6028 :          for (j = 0; j*2 < tga_height; ++j)
; 6029 :          {
; 6030 :             int index1 = j * tga_width * tga_comp;
; 6031 :             int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
; 6032 :             for (i = tga_width * tga_comp; i > 0; --i)
; 6033 :             {
; 6034 :                unsigned char temp = tga_data[index1];
; 6035 :                tga_data[index1] = tga_data[index2];
; 6036 :                tga_data[index2] = temp;
; 6037 :                ++index1;
; 6038 :                ++index2;
; 6039 :             }
; 6040 :          }
; 6041 :       }
; 6042 :       //   clear my palette, if I had one
; 6043 :       if ( tga_palette != NULL )
; 6044 :       {
; 6045 :          STBI_FREE( tga_palette );
; 6046 :       }
; 6047 :    }
; 6048 : 
; 6049 :    // swap RGB - if the source data was RGB16, it already is in the right order
; 6050 :    if (tga_comp >= 3 && !tga_rgb16)
; 6051 :    {
; 6052 :       unsigned char* tga_pixel = tga_data;
; 6053 :       for (i=0; i < tga_width * tga_height; ++i)
; 6054 :       {
; 6055 :          unsigned char temp = tga_pixel[0];
; 6056 :          tga_pixel[0] = tga_pixel[2];
; 6057 :          tga_pixel[2] = temp;
; 6058 :          tga_pixel += tga_comp;
; 6059 :       }
; 6060 :    }
; 6061 : 
; 6062 :    // convert to target component count
; 6063 :    if (req_comp && req_comp != tga_comp)
; 6064 :       tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);
; 6065 : 
; 6066 :    //   the things I do to get rid of an error message, and yet keep
; 6067 :    //   Microsoft's C compilers happy... [8^(
; 6068 :    tga_palette_start = tga_palette_len = tga_palette_bits =
; 6069 :          tga_x_origin = tga_y_origin = 0;
; 6070 :    STBI_NOTUSED(tga_palette_start);
; 6071 :    //   OK, done
; 6072 :    return tga_data;
; 6073 : }
; 6074 : #endif
; 6075 : 
; 6076 : // *************************************************************************************************
; 6077 : // Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB
; 6078 : 
; 6079 : #ifndef STBI_NO_PSD
; 6080 : static int stbi__psd_test(stbi__context *s)
; 6081 : {
; 6082 :    int r = (stbi__get32be(s) == 0x38425053);
; 6083 :    stbi__rewind(s);
; 6084 :    return r;
; 6085 : }
; 6086 : 
; 6087 : static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
; 6088 : {
; 6089 :    int count, nleft, len;
; 6090 : 
; 6091 :    count = 0;
; 6092 :    while ((nleft = pixelCount - count) > 0) {
; 6093 :       len = stbi__get8(s);
; 6094 :       if (len == 128) {
; 6095 :          // No-op.
; 6096 :       } else if (len < 128) {
; 6097 :          // Copy next len+1 bytes literally.
; 6098 :          len++;
; 6099 :          if (len > nleft) return 0; // corrupt data
; 6100 :          count += len;
; 6101 :          while (len) {
; 6102 :             *p = stbi__get8(s);
; 6103 :             p += 4;
; 6104 :             len--;
; 6105 :          }
; 6106 :       } else if (len > 128) {
; 6107 :          stbi_uc   val;
; 6108 :          // Next -len+1 bytes in the dest are replicated from next source byte.
; 6109 :          // (Interpret len as a negative 8-bit int.)
; 6110 :          len = 257 - len;
; 6111 :          if (len > nleft) return 0; // corrupt data
; 6112 :          val = stbi__get8(s);
; 6113 :          count += len;
; 6114 :          while (len) {
; 6115 :             *p = val;
; 6116 :             p += 4;
; 6117 :             len--;
; 6118 :          }
; 6119 :       }
; 6120 :    }
; 6121 : 
; 6122 :    return 1;
; 6123 : }
; 6124 : 
; 6125 : static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
; 6126 : {
; 6127 :    int pixelCount;
; 6128 :    int channelCount, compression;
; 6129 :    int channel, i;
; 6130 :    int bitdepth;
; 6131 :    int w,h;
; 6132 :    stbi_uc *out;
; 6133 :    STBI_NOTUSED(ri);
; 6134 : 
; 6135 :    // Check identifier
; 6136 :    if (stbi__get32be(s) != 0x38425053)   // "8BPS"
; 6137 :       return stbi__errpuc("not PSD", "Corrupt PSD image");
; 6138 : 
; 6139 :    // Check file type version.
; 6140 :    if (stbi__get16be(s) != 1)
; 6141 :       return stbi__errpuc("wrong version", "Unsupported version of PSD image");
; 6142 : 
; 6143 :    // Skip 6 reserved bytes.
; 6144 :    stbi__skip(s, 6 );
; 6145 : 
; 6146 :    // Read the number of channels (R, G, B, A, etc).
; 6147 :    channelCount = stbi__get16be(s);
; 6148 :    if (channelCount < 0 || channelCount > 16)
; 6149 :       return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");
; 6150 : 
; 6151 :    // Read the rows and columns of the image.
; 6152 :    h = stbi__get32be(s);
; 6153 :    w = stbi__get32be(s);
; 6154 : 
; 6155 :    if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 6156 :    if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 6157 : 
; 6158 :    // Make sure the depth is 8 bits.
; 6159 :    bitdepth = stbi__get16be(s);
; 6160 :    if (bitdepth != 8 && bitdepth != 16)
; 6161 :       return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");
; 6162 : 
; 6163 :    // Make sure the color mode is RGB.
; 6164 :    // Valid options are:
; 6165 :    //   0: Bitmap
; 6166 :    //   1: Grayscale
; 6167 :    //   2: Indexed color
; 6168 :    //   3: RGB color
; 6169 :    //   4: CMYK color
; 6170 :    //   7: Multichannel
; 6171 :    //   8: Duotone
; 6172 :    //   9: Lab color
; 6173 :    if (stbi__get16be(s) != 3)
; 6174 :       return stbi__errpuc("wrong color format", "PSD is not in RGB color format");
; 6175 : 
; 6176 :    // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
; 6177 :    stbi__skip(s,stbi__get32be(s) );
; 6178 : 
; 6179 :    // Skip the image resources.  (resolution, pen tool paths, etc)
; 6180 :    stbi__skip(s, stbi__get32be(s) );
; 6181 : 
; 6182 :    // Skip the reserved data.
; 6183 :    stbi__skip(s, stbi__get32be(s) );
; 6184 : 
; 6185 :    // Find out if the data is compressed.
; 6186 :    // Known values:
; 6187 :    //   0: no compression
; 6188 :    //   1: RLE compressed
; 6189 :    compression = stbi__get16be(s);
; 6190 :    if (compression > 1)
; 6191 :       return stbi__errpuc("bad compression", "PSD has an unknown compression format");
; 6192 : 
; 6193 :    // Check size
; 6194 :    if (!stbi__mad3sizes_valid(4, w, h, 0))
; 6195 :       return stbi__errpuc("too large", "Corrupt PSD");
; 6196 : 
; 6197 :    // Create the destination image.
; 6198 : 
; 6199 :    if (!compression && bitdepth == 16 && bpc == 16) {
; 6200 :       out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
; 6201 :       ri->bits_per_channel = 16;
; 6202 :    } else
; 6203 :       out = (stbi_uc *) stbi__malloc(4 * w*h);
; 6204 : 
; 6205 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");
; 6206 :    pixelCount = w*h;
; 6207 : 
; 6208 :    // Initialize the data to zero.
; 6209 :    //memset( out, 0, pixelCount * 4 );
; 6210 : 
; 6211 :    // Finally, the image data.
; 6212 :    if (compression) {
; 6213 :       // RLE as used by .PSD and .TIFF
; 6214 :       // Loop until you get the number of unpacked bytes you are expecting:
; 6215 :       //     Read the next source byte into n.
; 6216 :       //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
; 6217 :       //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
; 6218 :       //     Else if n is 128, noop.
; 6219 :       // Endloop
; 6220 : 
; 6221 :       // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
; 6222 :       // which we're going to just skip.
; 6223 :       stbi__skip(s, h * channelCount * 2 );
; 6224 : 
; 6225 :       // Read the RLE data by channel.
; 6226 :       for (channel = 0; channel < 4; channel++) {
; 6227 :          stbi_uc *p;
; 6228 : 
; 6229 :          p = out+channel;
; 6230 :          if (channel >= channelCount) {
; 6231 :             // Fill this channel with default data.
; 6232 :             for (i = 0; i < pixelCount; i++, p += 4)
; 6233 :                *p = (channel == 3 ? 255 : 0);
; 6234 :          } else {
; 6235 :             // Read the RLE data.
; 6236 :             if (!stbi__psd_decode_rle(s, p, pixelCount)) {
; 6237 :                STBI_FREE(out);
; 6238 :                return stbi__errpuc("corrupt", "bad RLE data");
; 6239 :             }
; 6240 :          }
; 6241 :       }
; 6242 : 
; 6243 :    } else {
; 6244 :       // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
; 6245 :       // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.
; 6246 : 
; 6247 :       // Read the data by channel.
; 6248 :       for (channel = 0; channel < 4; channel++) {
; 6249 :          if (channel >= channelCount) {
; 6250 :             // Fill this channel with default data.
; 6251 :             if (bitdepth == 16 && bpc == 16) {
; 6252 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
; 6253 :                stbi__uint16 val = channel == 3 ? 65535 : 0;
; 6254 :                for (i = 0; i < pixelCount; i++, q += 4)
; 6255 :                   *q = val;
; 6256 :             } else {
; 6257 :                stbi_uc *p = out+channel;
; 6258 :                stbi_uc val = channel == 3 ? 255 : 0;
; 6259 :                for (i = 0; i < pixelCount; i++, p += 4)
; 6260 :                   *p = val;
; 6261 :             }
; 6262 :          } else {
; 6263 :             if (ri->bits_per_channel == 16) {    // output bpc
; 6264 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
; 6265 :                for (i = 0; i < pixelCount; i++, q += 4)
; 6266 :                   *q = (stbi__uint16) stbi__get16be(s);
; 6267 :             } else {
; 6268 :                stbi_uc *p = out+channel;
; 6269 :                if (bitdepth == 16) {  // input bpc
; 6270 :                   for (i = 0; i < pixelCount; i++, p += 4)
; 6271 :                      *p = (stbi_uc) (stbi__get16be(s) >> 8);
; 6272 :                } else {
; 6273 :                   for (i = 0; i < pixelCount; i++, p += 4)
; 6274 :                      *p = stbi__get8(s);
; 6275 :                }
; 6276 :             }
; 6277 :          }
; 6278 :       }
; 6279 :    }
; 6280 : 
; 6281 :    // remove weird white matte from PSD
; 6282 :    if (channelCount >= 4) {
; 6283 :       if (ri->bits_per_channel == 16) {
; 6284 :          for (i=0; i < w*h; ++i) {
; 6285 :             stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
; 6286 :             if (pixel[3] != 0 && pixel[3] != 65535) {
; 6287 :                float a = pixel[3] / 65535.0f;
; 6288 :                float ra = 1.0f / a;
; 6289 :                float inv_a = 65535.0f * (1 - ra);
; 6290 :                pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
; 6291 :                pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
; 6292 :                pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
; 6293 :             }
; 6294 :          }
; 6295 :       } else {
; 6296 :          for (i=0; i < w*h; ++i) {
; 6297 :             unsigned char *pixel = out + 4*i;
; 6298 :             if (pixel[3] != 0 && pixel[3] != 255) {
; 6299 :                float a = pixel[3] / 255.0f;
; 6300 :                float ra = 1.0f / a;
; 6301 :                float inv_a = 255.0f * (1 - ra);
; 6302 :                pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
; 6303 :                pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
; 6304 :                pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
; 6305 :             }
; 6306 :          }
; 6307 :       }
; 6308 :    }
; 6309 : 
; 6310 :    // convert to desired output format
; 6311 :    if (req_comp && req_comp != 4) {
; 6312 :       if (ri->bits_per_channel == 16)
; 6313 :          out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
; 6314 :       else
; 6315 :          out = stbi__convert_format(out, 4, req_comp, w, h);
; 6316 :       if (out == NULL) return out; // stbi__convert_format frees input on failure
; 6317 :    }
; 6318 : 
; 6319 :    if (comp) *comp = 4;
; 6320 :    *y = h;
; 6321 :    *x = w;
; 6322 : 
; 6323 :    return out;
; 6324 : }
; 6325 : #endif
; 6326 : 
; 6327 : // *************************************************************************************************
; 6328 : // Softimage PIC loader
; 6329 : // by Tom Seddon
; 6330 : //
; 6331 : // See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
; 6332 : // See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/
; 6333 : 
; 6334 : #ifndef STBI_NO_PIC
; 6335 : static int stbi__pic_is4(stbi__context *s,const char *str)
; 6336 : {
; 6337 :    int i;
; 6338 :    for (i=0; i<4; ++i)
; 6339 :       if (stbi__get8(s) != (stbi_uc)str[i])
; 6340 :          return 0;
; 6341 : 
; 6342 :    return 1;
; 6343 : }
; 6344 : 
; 6345 : static int stbi__pic_test_core(stbi__context *s)
; 6346 : {
; 6347 :    int i;
; 6348 : 
; 6349 :    if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
; 6350 :       return 0;
; 6351 : 
; 6352 :    for(i=0;i<84;++i)
; 6353 :       stbi__get8(s);
; 6354 : 
; 6355 :    if (!stbi__pic_is4(s,"PICT"))
; 6356 :       return 0;
; 6357 : 
; 6358 :    return 1;
; 6359 : }
; 6360 : 
; 6361 : typedef struct
; 6362 : {
; 6363 :    stbi_uc size,type,channel;
; 6364 : } stbi__pic_packet;
; 6365 : 
; 6366 : static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
; 6367 : {
; 6368 :    int mask=0x80, i;
; 6369 : 
; 6370 :    for (i=0; i<4; ++i, mask>>=1) {
; 6371 :       if (channel & mask) {
; 6372 :          if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
; 6373 :          dest[i]=stbi__get8(s);
; 6374 :       }
; 6375 :    }
; 6376 : 
; 6377 :    return dest;
; 6378 : }
; 6379 : 
; 6380 : static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
; 6381 : {
; 6382 :    int mask=0x80,i;
; 6383 : 
; 6384 :    for (i=0;i<4; ++i, mask>>=1)
; 6385 :       if (channel&mask)

	test	dil, 64					; 00000040H
	je	SHORT $LN151@stbi__pic_

; 6386 :          dest[i]=src[i];

	mov	BYTE PTR [rbx+1], r9b
$LN151@stbi__pic_:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;
; 1636 : }
; 1637 : #endif
; 1638 : 
; 1639 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
; 1640 : // nothing
; 1641 : #else
; 1642 : static void stbi__skip(stbi__context *s, int n)
; 1643 : {
; 1644 :    if (n == 0) return;  // already there!
; 1645 :    if (n < 0) {
; 1646 :       s->img_buffer = s->img_buffer_end;
; 1647 :       return;
; 1648 :    }
; 1649 :    if (s->io.read) {
; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1651 :       if (blen < n) {
; 1652 :          s->img_buffer = s->img_buffer_end;
; 1653 :          (s->io.skip)(s->io_user_data, n - blen);
; 1654 :          return;
; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;
; 1658 : }
; 1659 : #endif
; 1660 : 
; 1661 : #if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
; 1662 : // nothing
; 1663 : #else
; 1664 : static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
; 1665 : {
; 1666 :    if (s->io.read) {
; 1667 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1668 :       if (blen < n) {
; 1669 :          int res, count;
; 1670 : 
; 1671 :          memcpy(buffer, s->img_buffer, blen);
; 1672 : 
; 1673 :          count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
; 1674 :          res = (count == (n-blen));
; 1675 :          s->img_buffer = s->img_buffer_end;
; 1676 :          return res;
; 1677 :       }
; 1678 :    }
; 1679 : 
; 1680 :    if (s->img_buffer+n <= s->img_buffer_end) {
; 1681 :       memcpy(buffer, s->img_buffer, n);
; 1682 :       s->img_buffer += n;
; 1683 :       return 1;
; 1684 :    } else
; 1685 :       return 0;
; 1686 : }
; 1687 : #endif
; 1688 : 
; 1689 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1690 : // nothing
; 1691 : #else
; 1692 : static int stbi__get16be(stbi__context *s)
; 1693 : {
; 1694 :    int z = stbi__get8(s);
; 1695 :    return (z << 8) + stbi__get8(s);
; 1696 : }
; 1697 : #endif
; 1698 : 
; 1699 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1700 : // nothing
; 1701 : #else
; 1702 : static stbi__uint32 stbi__get32be(stbi__context *s)
; 1703 : {
; 1704 :    stbi__uint32 z = stbi__get16be(s);
; 1705 :    return (z << 16) + stbi__get16be(s);
; 1706 : }
; 1707 : #endif
; 1708 : 
; 1709 : #if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
; 1710 : // nothing
; 1711 : #else
; 1712 : static int stbi__get16le(stbi__context *s)
; 1713 : {
; 1714 :    int z = stbi__get8(s);
; 1715 :    return z + (stbi__get8(s) << 8);
; 1716 : }
; 1717 : #endif
; 1718 : 
; 1719 : #ifndef STBI_NO_BMP
; 1720 : static stbi__uint32 stbi__get32le(stbi__context *s)
; 1721 : {
; 1722 :    stbi__uint32 z = stbi__get16le(s);
; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;
; 1724 :    return z;
; 1725 : }
; 1726 : #endif
; 1727 : 
; 1728 : #define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
; 1729 : 
; 1730 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1731 : // nothing
; 1732 : #else
; 1733 : //////////////////////////////////////////////////////////////////////////////
; 1734 : //
; 1735 : //  generic converter from built-in img_n to req_comp
; 1736 : //    individual types do this automatically as much as possible (e.g. jpeg
; 1737 : //    does all cases internally since it needs to colorspace convert anyway,
; 1738 : //    and it never has alpha, so very few cases ). png can automatically
; 1739 : //    interleave an alpha=255 channel, but falls back to this for other cases
; 1740 : //
; 1741 : //  assume data buffer is malloced, so malloc a new one and free that one
; 1742 : //  only failure mode is malloc failing
; 1743 : 
; 1744 : static stbi_uc stbi__compute_y(int r, int g, int b)
; 1745 : {
; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1747 : }
; 1748 : #endif
; 1749 : 
; 1750 : #if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1751 : // nothing
; 1752 : #else
; 1753 : static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1754 : {
; 1755 :    int i,j;
; 1756 :    unsigned char *good;
; 1757 : 
; 1758 :    if (req_comp == img_n) return data;
; 1759 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1760 : 
; 1761 :    good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
; 1762 :    if (good == NULL) {
; 1763 :       STBI_FREE(data);
; 1764 :       return stbi__errpuc("outofmem", "Out of memory");
; 1765 :    }
; 1766 : 
; 1767 :    for (j=0; j < (int) y; ++j) {
; 1768 :       unsigned char *src  = data + j * x * img_n   ;
; 1769 :       unsigned char *dest = good + j * x * req_comp;
; 1770 : 
; 1771 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1772 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1773 :       // convert source image with img_n components to one with req_comp components;
; 1774 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1775 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1776 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
; 1777 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1778 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
; 1779 :          STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
; 1780 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1781 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
; 1782 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
; 1783 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1784 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
; 1785 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1786 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1787 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
; 1788 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
; 1789 :       }
; 1790 :       #undef STBI__CASE
; 1791 :    }
; 1792 : 
; 1793 :    STBI_FREE(data);
; 1794 :    return good;
; 1795 : }
; 1796 : #endif
; 1797 : 
; 1798 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1799 : // nothing
; 1800 : #else
; 1801 : static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
; 1802 : {
; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1804 : }
; 1805 : #endif
; 1806 : 
; 1807 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1808 : // nothing
; 1809 : #else
; 1810 : static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1811 : {
; 1812 :    int i,j;
; 1813 :    stbi__uint16 *good;
; 1814 : 
; 1815 :    if (req_comp == img_n) return data;
; 1816 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1817 : 
; 1818 :    good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
; 1819 :    if (good == NULL) {
; 1820 :       STBI_FREE(data);
; 1821 :       return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1822 :    }
; 1823 : 
; 1824 :    for (j=0; j < (int) y; ++j) {
; 1825 :       stbi__uint16 *src  = data + j * x * img_n   ;
; 1826 :       stbi__uint16 *dest = good + j * x * req_comp;
; 1827 : 
; 1828 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1829 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1830 :       // convert source image with img_n components to one with req_comp components;
; 1831 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1832 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1833 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
; 1834 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1835 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
; 1836 :          STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
; 1837 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1838 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
; 1839 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
; 1840 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1841 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
; 1842 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1843 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1844 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
; 1845 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
; 1846 :       }
; 1847 :       #undef STBI__CASE
; 1848 :    }
; 1849 : 
; 1850 :    STBI_FREE(data);
; 1851 :    return good;
; 1852 : }
; 1853 : #endif
; 1854 : 
; 1855 : #ifndef STBI_NO_LINEAR
; 1856 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
; 1857 : {
; 1858 :    int i,k,n;
; 1859 :    float *output;
; 1860 :    if (!data) return NULL;
; 1861 :    output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
; 1862 :    if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
; 1863 :    // compute number of non-alpha components
; 1864 :    if (comp & 1) n = comp; else n = comp-1;
; 1865 :    for (i=0; i < x*y; ++i) {
; 1866 :       for (k=0; k < n; ++k) {
; 1867 :          output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
; 1868 :       }
; 1869 :    }
; 1870 :    if (n < comp) {
; 1871 :       for (i=0; i < x*y; ++i) {
; 1872 :          output[i*comp + n] = data[i*comp + n]/255.0f;
; 1873 :       }
; 1874 :    }
; 1875 :    STBI_FREE(data);
; 1876 :    return output;
; 1877 : }
; 1878 : #endif
; 1879 : 
; 1880 : #ifndef STBI_NO_HDR
; 1881 : #define stbi__float2int(x)   ((int) (x))
; 1882 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
; 1883 : {
; 1884 :    int i,k,n;
; 1885 :    stbi_uc *output;
; 1886 :    if (!data) return NULL;
; 1887 :    output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
; 1888 :    if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
; 1889 :    // compute number of non-alpha components
; 1890 :    if (comp & 1) n = comp; else n = comp-1;
; 1891 :    for (i=0; i < x*y; ++i) {
; 1892 :       for (k=0; k < n; ++k) {
; 1893 :          float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
; 1894 :          if (z < 0) z = 0;
; 1895 :          if (z > 255) z = 255;
; 1896 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1897 :       }
; 1898 :       if (k < comp) {
; 1899 :          float z = data[i*comp+k] * 255 + 0.5f;
; 1900 :          if (z < 0) z = 0;
; 1901 :          if (z > 255) z = 255;
; 1902 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1903 :       }
; 1904 :    }
; 1905 :    STBI_FREE(data);
; 1906 :    return output;
; 1907 : }
; 1908 : #endif
; 1909 : 
; 1910 : //////////////////////////////////////////////////////////////////////////////
; 1911 : //
; 1912 : //  "baseline" JPEG/JFIF decoder
; 1913 : //
; 1914 : //    simple implementation
; 1915 : //      - doesn't support delayed output of y-dimension
; 1916 : //      - simple interface (only one output format: 8-bit interleaved RGB)
; 1917 : //      - doesn't try to recover corrupt jpegs
; 1918 : //      - doesn't allow partial loading, loading multiple at once
; 1919 : //      - still fast on x86 (copying globals into locals doesn't help x86)
; 1920 : //      - allocates lots of intermediate memory (full size of all components)
; 1921 : //        - non-interleaved case requires this anyway
; 1922 : //        - allows good upsampling (see next)
; 1923 : //    high-quality
; 1924 : //      - upsampled channels are bilinearly interpolated, even across blocks
; 1925 : //      - quality integer IDCT derived from IJG's 'slow'
; 1926 : //    performance
; 1927 : //      - fast huffman; reasonable integer IDCT
; 1928 : //      - some SIMD kernels for common paths on targets with SSE2/NEON
; 1929 : //      - uses a lot of intermediate memory, could cache poorly
; 1930 : 
; 1931 : #ifndef STBI_NO_JPEG
; 1932 : 
; 1933 : // huffman decoding acceleration
; 1934 : #define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
; 1935 : 
; 1936 : typedef struct
; 1937 : {
; 1938 :    stbi_uc  fast[1 << FAST_BITS];
; 1939 :    // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
; 1940 :    stbi__uint16 code[256];
; 1941 :    stbi_uc  values[256];
; 1942 :    stbi_uc  size[257];
; 1943 :    unsigned int maxcode[18];
; 1944 :    int    delta[17];   // old 'firstsymbol' - old 'firstcode'
; 1945 : } stbi__huffman;
; 1946 : 
; 1947 : typedef struct
; 1948 : {
; 1949 :    stbi__context *s;
; 1950 :    stbi__huffman huff_dc[4];
; 1951 :    stbi__huffman huff_ac[4];
; 1952 :    stbi__uint16 dequant[4][64];
; 1953 :    stbi__int16 fast_ac[4][1 << FAST_BITS];
; 1954 : 
; 1955 : // sizes for components, interleaved MCUs
; 1956 :    int img_h_max, img_v_max;
; 1957 :    int img_mcu_x, img_mcu_y;
; 1958 :    int img_mcu_w, img_mcu_h;
; 1959 : 
; 1960 : // definition of jpeg image component
; 1961 :    struct
; 1962 :    {
; 1963 :       int id;
; 1964 :       int h,v;
; 1965 :       int tq;
; 1966 :       int hd,ha;
; 1967 :       int dc_pred;
; 1968 : 
; 1969 :       int x,y,w2,h2;
; 1970 :       stbi_uc *data;
; 1971 :       void *raw_data, *raw_coeff;
; 1972 :       stbi_uc *linebuf;
; 1973 :       short   *coeff;   // progressive only
; 1974 :       int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
; 1975 :    } img_comp[4];
; 1976 : 
; 1977 :    stbi__uint32   code_buffer; // jpeg entropy-coded buffer
; 1978 :    int            code_bits;   // number of valid bits
; 1979 :    unsigned char  marker;      // marker seen while filling entropy buffer
; 1980 :    int            nomore;      // flag if we saw a marker so must stop
; 1981 : 
; 1982 :    int            progressive;
; 1983 :    int            spec_start;
; 1984 :    int            spec_end;
; 1985 :    int            succ_high;
; 1986 :    int            succ_low;
; 1987 :    int            eob_run;
; 1988 :    int            jfif;
; 1989 :    int            app14_color_transform; // Adobe APP14 tag
; 1990 :    int            rgb;
; 1991 : 
; 1992 :    int scan_n, order[4];
; 1993 :    int restart_interval, todo;
; 1994 : 
; 1995 : // kernels
; 1996 :    void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
; 1997 :    void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
; 1998 :    stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
; 1999 : } stbi__jpeg;
; 2000 : 
; 2001 : static int stbi__build_huffman(stbi__huffman *h, int *count)
; 2002 : {
; 2003 :    int i,j,k=0;
; 2004 :    unsigned int code;
; 2005 :    // build size list for each symbol (from JPEG spec)
; 2006 :    for (i=0; i < 16; ++i) {
; 2007 :       for (j=0; j < count[i]; ++j) {
; 2008 :          h->size[k++] = (stbi_uc) (i+1);
; 2009 :          if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");
; 2010 :       }
; 2011 :    }
; 2012 :    h->size[k] = 0;
; 2013 : 
; 2014 :    // compute actual symbols (from jpeg spec)
; 2015 :    code = 0;
; 2016 :    k = 0;
; 2017 :    for(j=1; j <= 16; ++j) {
; 2018 :       // compute delta to add to code to compute symbol id
; 2019 :       h->delta[j] = k - code;
; 2020 :       if (h->size[k] == j) {
; 2021 :          while (h->size[k] == j)
; 2022 :             h->code[k++] = (stbi__uint16) (code++);
; 2023 :          if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
; 2024 :       }
; 2025 :       // compute largest code + 1 for this size, preshifted as needed later
; 2026 :       h->maxcode[j] = code << (16-j);
; 2027 :       code <<= 1;
; 2028 :    }
; 2029 :    h->maxcode[j] = 0xffffffff;
; 2030 : 
; 2031 :    // build non-spec acceleration table; 255 is flag for not-accelerated
; 2032 :    memset(h->fast, 255, 1 << FAST_BITS);
; 2033 :    for (i=0; i < k; ++i) {
; 2034 :       int s = h->size[i];
; 2035 :       if (s <= FAST_BITS) {
; 2036 :          int c = h->code[i] << (FAST_BITS-s);
; 2037 :          int m = 1 << (FAST_BITS-s);
; 2038 :          for (j=0; j < m; ++j) {
; 2039 :             h->fast[c+j] = (stbi_uc) i;
; 2040 :          }
; 2041 :       }
; 2042 :    }
; 2043 :    return 1;
; 2044 : }
; 2045 : 
; 2046 : // build a table that decodes both magnitude and value of small ACs in
; 2047 : // one go.
; 2048 : static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
; 2049 : {
; 2050 :    int i;
; 2051 :    for (i=0; i < (1 << FAST_BITS); ++i) {
; 2052 :       stbi_uc fast = h->fast[i];
; 2053 :       fast_ac[i] = 0;
; 2054 :       if (fast < 255) {
; 2055 :          int rs = h->values[fast];
; 2056 :          int run = (rs >> 4) & 15;
; 2057 :          int magbits = rs & 15;
; 2058 :          int len = h->size[fast];
; 2059 : 
; 2060 :          if (magbits && len + magbits <= FAST_BITS) {
; 2061 :             // magnitude code followed by receive_extend code
; 2062 :             int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
; 2063 :             int m = 1 << (magbits - 1);
; 2064 :             if (k < m) k += (~0U << magbits) + 1;
; 2065 :             // if the result is small enough, we can fit it in fast_ac table
; 2066 :             if (k >= -128 && k <= 127)
; 2067 :                fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
; 2068 :          }
; 2069 :       }
; 2070 :    }
; 2071 : }
; 2072 : 
; 2073 : static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
; 2074 : {
; 2075 :    do {
; 2076 :       unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
; 2077 :       if (b == 0xff) {
; 2078 :          int c = stbi__get8(j->s);
; 2079 :          while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
; 2080 :          if (c != 0) {
; 2081 :             j->marker = (unsigned char) c;
; 2082 :             j->nomore = 1;
; 2083 :             return;
; 2084 :          }
; 2085 :       }
; 2086 :       j->code_buffer |= b << (24 - j->code_bits);
; 2087 :       j->code_bits += 8;
; 2088 :    } while (j->code_bits <= 24);
; 2089 : }
; 2090 : 
; 2091 : // (1 << n) - 1
; 2092 : static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
; 2093 : 
; 2094 : // decode a jpeg huffman value from the bitstream
; 2095 : stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
; 2096 : {
; 2097 :    unsigned int temp;
; 2098 :    int c,k;
; 2099 : 
; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2105 :    k = h->fast[c];
; 2106 :    if (k < 255) {
; 2107 :       int s = h->size[k];
; 2108 :       if (s > j->code_bits)
; 2109 :          return -1;
; 2110 :       j->code_buffer <<= s;
; 2111 :       j->code_bits -= s;
; 2112 :       return h->values[k];
; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;
; 2122 :    for (k=FAST_BITS+1 ; ; ++k)
; 2123 :       if (temp < h->maxcode[k])
; 2124 :          break;
; 2125 :    if (k == 17) {
; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;
; 2128 :       return -1;
; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)
; 2132 :       return -1;
; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!
; 2137 :        return -1;
; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;
; 2142 :    j->code_buffer <<= k;
; 2143 :    return h->values[c];
; 2144 : }
; 2145 : 
; 2146 : // bias[n] = (-1<<n) + 1
; 2147 : static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};
; 2148 : 
; 2149 : // combined JPEG 'receive' and JPEG 'extend', since baseline
; 2150 : // always extends everything it receives.
; 2151 : stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
; 2152 : {
; 2153 :    unsigned int k;
; 2154 :    int sgn;
; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
; 2159 :    k = stbi_lrot(j->code_buffer, n);
; 2160 :    j->code_buffer = k & ~stbi__bmask[n];
; 2161 :    k &= stbi__bmask[n];
; 2162 :    j->code_bits -= n;
; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));
; 2164 : }
; 2165 : 
; 2166 : // get some unsigned bits
; 2167 : stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
; 2168 : {
; 2169 :    unsigned int k;
; 2170 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2171 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2172 :    k = stbi_lrot(j->code_buffer, n);
; 2173 :    j->code_buffer = k & ~stbi__bmask[n];
; 2174 :    k &= stbi__bmask[n];
; 2175 :    j->code_bits -= n;
; 2176 :    return k;
; 2177 : }
; 2178 : 
; 2179 : stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
; 2180 : {
; 2181 :    unsigned int k;
; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2184 :    k = j->code_buffer;
; 2185 :    j->code_buffer <<= 1;
; 2186 :    --j->code_bits;
; 2187 :    return k & 0x80000000;
; 2188 : }
; 2189 : 
; 2190 : // given a value that's at position X in the zigzag stream,
; 2191 : // where does it appear in the 8x8 matrix coded as row-major?
; 2192 : static const stbi_uc stbi__jpeg_dezigzag[64+15] =
; 2193 : {
; 2194 :     0,  1,  8, 16,  9,  2,  3, 10,
; 2195 :    17, 24, 32, 25, 18, 11,  4,  5,
; 2196 :    12, 19, 26, 33, 40, 48, 41, 34,
; 2197 :    27, 20, 13,  6,  7, 14, 21, 28,
; 2198 :    35, 42, 49, 56, 57, 50, 43, 36,
; 2199 :    29, 22, 15, 23, 30, 37, 44, 51,
; 2200 :    58, 59, 52, 45, 38, 31, 39, 46,
; 2201 :    53, 60, 61, 54, 47, 55, 62, 63,
; 2202 :    // let corrupt input sample past end
; 2203 :    63, 63, 63, 63, 63, 63, 63, 63,
; 2204 :    63, 63, 63, 63, 63, 63, 63
; 2205 : };
; 2206 : 
; 2207 : // decode one 64-entry block--
; 2208 : static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
; 2209 : {
; 2210 :    int diff,dc,k;
; 2211 :    int t;
; 2212 : 
; 2213 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2214 :    t = stbi__jpeg_huff_decode(j, hdc);
; 2215 :    if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");
; 2216 : 
; 2217 :    // 0 all the ac values now so we can do it 32-bits at a time
; 2218 :    memset(data,0,64*sizeof(data[0]));
; 2219 : 
; 2220 :    diff = t ? stbi__extend_receive(j, t) : 0;
; 2221 :    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");
; 2222 :    dc = j->img_comp[b].dc_pred + diff;
; 2223 :    j->img_comp[b].dc_pred = dc;
; 2224 :    if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2225 :    data[0] = (short) (dc * dequant[0]);
; 2226 : 
; 2227 :    // decode AC components, see JPEG spec
; 2228 :    k = 1;
; 2229 :    do {
; 2230 :       unsigned int zig;
; 2231 :       int c,r,s;
; 2232 :       if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2233 :       c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2234 :       r = fac[c];
; 2235 :       if (r) { // fast-AC path
; 2236 :          k += (r >> 4) & 15; // run
; 2237 :          s = r & 15; // combined length
; 2238 :          if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2239 :          j->code_buffer <<= s;
; 2240 :          j->code_bits -= s;
; 2241 :          // decode into unzigzag'd location
; 2242 :          zig = stbi__jpeg_dezigzag[k++];
; 2243 :          data[zig] = (short) ((r >> 8) * dequant[zig]);
; 2244 :       } else {
; 2245 :          int rs = stbi__jpeg_huff_decode(j, hac);
; 2246 :          if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2247 :          s = rs & 15;
; 2248 :          r = rs >> 4;
; 2249 :          if (s == 0) {
; 2250 :             if (rs != 0xf0) break; // end block
; 2251 :             k += 16;
; 2252 :          } else {
; 2253 :             k += r;
; 2254 :             // decode into unzigzag'd location
; 2255 :             zig = stbi__jpeg_dezigzag[k++];
; 2256 :             data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
; 2257 :          }
; 2258 :       }
; 2259 :    } while (k < 64);
; 2260 :    return 1;
; 2261 : }
; 2262 : 
; 2263 : static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
; 2264 : {
; 2265 :    int diff,dc;
; 2266 :    int t;
; 2267 :    if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2268 : 
; 2269 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2270 : 
; 2271 :    if (j->succ_high == 0) {
; 2272 :       // first scan for DC coefficient, must be first
; 2273 :       memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
; 2274 :       t = stbi__jpeg_huff_decode(j, hdc);
; 2275 :       if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2276 :       diff = t ? stbi__extend_receive(j, t) : 0;
; 2277 : 
; 2278 :       if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");
; 2279 :       dc = j->img_comp[b].dc_pred + diff;
; 2280 :       j->img_comp[b].dc_pred = dc;
; 2281 :       if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2282 :       data[0] = (short) (dc * (1 << j->succ_low));
; 2283 :    } else {
; 2284 :       // refinement scan for DC coefficient
; 2285 :       if (stbi__jpeg_get_bit(j))
; 2286 :          data[0] += (short) (1 << j->succ_low);
; 2287 :    }
; 2288 :    return 1;
; 2289 : }
; 2290 : 
; 2291 : // @OPTIMIZE: store non-zigzagged during the decode passes,
; 2292 : // and only de-zigzag when dequantizing
; 2293 : static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
; 2294 : {
; 2295 :    int k;
; 2296 :    if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2297 : 
; 2298 :    if (j->succ_high == 0) {
; 2299 :       int shift = j->succ_low;
; 2300 : 
; 2301 :       if (j->eob_run) {
; 2302 :          --j->eob_run;
; 2303 :          return 1;
; 2304 :       }
; 2305 : 
; 2306 :       k = j->spec_start;
; 2307 :       do {
; 2308 :          unsigned int zig;
; 2309 :          int c,r,s;
; 2310 :          if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2311 :          c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2312 :          r = fac[c];
; 2313 :          if (r) { // fast-AC path
; 2314 :             k += (r >> 4) & 15; // run
; 2315 :             s = r & 15; // combined length
; 2316 :             if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2317 :             j->code_buffer <<= s;
; 2318 :             j->code_bits -= s;
; 2319 :             zig = stbi__jpeg_dezigzag[k++];
; 2320 :             data[zig] = (short) ((r >> 8) * (1 << shift));
; 2321 :          } else {
; 2322 :             int rs = stbi__jpeg_huff_decode(j, hac);
; 2323 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2324 :             s = rs & 15;
; 2325 :             r = rs >> 4;
; 2326 :             if (s == 0) {
; 2327 :                if (r < 15) {
; 2328 :                   j->eob_run = (1 << r);
; 2329 :                   if (r)
; 2330 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2331 :                   --j->eob_run;
; 2332 :                   break;
; 2333 :                }
; 2334 :                k += 16;
; 2335 :             } else {
; 2336 :                k += r;
; 2337 :                zig = stbi__jpeg_dezigzag[k++];
; 2338 :                data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
; 2339 :             }
; 2340 :          }
; 2341 :       } while (k <= j->spec_end);
; 2342 :    } else {
; 2343 :       // refinement scan for these AC coefficients
; 2344 : 
; 2345 :       short bit = (short) (1 << j->succ_low);
; 2346 : 
; 2347 :       if (j->eob_run) {
; 2348 :          --j->eob_run;
; 2349 :          for (k = j->spec_start; k <= j->spec_end; ++k) {
; 2350 :             short *p = &data[stbi__jpeg_dezigzag[k]];
; 2351 :             if (*p != 0)
; 2352 :                if (stbi__jpeg_get_bit(j))
; 2353 :                   if ((*p & bit)==0) {
; 2354 :                      if (*p > 0)
; 2355 :                         *p += bit;
; 2356 :                      else
; 2357 :                         *p -= bit;
; 2358 :                   }
; 2359 :          }
; 2360 :       } else {
; 2361 :          k = j->spec_start;
; 2362 :          do {
; 2363 :             int r,s;
; 2364 :             int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
; 2365 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2366 :             s = rs & 15;
; 2367 :             r = rs >> 4;
; 2368 :             if (s == 0) {
; 2369 :                if (r < 15) {
; 2370 :                   j->eob_run = (1 << r) - 1;
; 2371 :                   if (r)
; 2372 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2373 :                   r = 64; // force end of block
; 2374 :                } else {
; 2375 :                   // r=15 s=0 should write 16 0s, so we just do
; 2376 :                   // a run of 15 0s and then write s (which is 0),
; 2377 :                   // so we don't have to do anything special here
; 2378 :                }
; 2379 :             } else {
; 2380 :                if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
; 2381 :                // sign bit
; 2382 :                if (stbi__jpeg_get_bit(j))
; 2383 :                   s = bit;
; 2384 :                else
; 2385 :                   s = -bit;
; 2386 :             }
; 2387 : 
; 2388 :             // advance by r
; 2389 :             while (k <= j->spec_end) {
; 2390 :                short *p = &data[stbi__jpeg_dezigzag[k++]];
; 2391 :                if (*p != 0) {
; 2392 :                   if (stbi__jpeg_get_bit(j))
; 2393 :                      if ((*p & bit)==0) {
; 2394 :                         if (*p > 0)
; 2395 :                            *p += bit;
; 2396 :                         else
; 2397 :                            *p -= bit;
; 2398 :                      }
; 2399 :                } else {
; 2400 :                   if (r == 0) {
; 2401 :                      *p = (short) s;
; 2402 :                      break;
; 2403 :                   }
; 2404 :                   --r;
; 2405 :                }
; 2406 :             }
; 2407 :          } while (k <= j->spec_end);
; 2408 :       }
; 2409 :    }
; 2410 :    return 1;
; 2411 : }
; 2412 : 
; 2413 : // take a -128..127 value and stbi__clamp it and convert to 0..255
; 2414 : stbi_inline static stbi_uc stbi__clamp(int x)
; 2415 : {
; 2416 :    // trick to use a single test to catch both cases
; 2417 :    if ((unsigned int) x > 255) {
; 2418 :       if (x < 0) return 0;
; 2419 :       if (x > 255) return 255;
; 2420 :    }
; 2421 :    return (stbi_uc) x;
; 2422 : }
; 2423 : 
; 2424 : #define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
; 2425 : #define stbi__fsh(x)  ((x) * 4096)
; 2426 : 
; 2427 : // derived from jidctint -- DCT_ISLOW
; 2428 : #define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
; 2429 :    int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
; 2430 :    p2 = s2;                                    \
; 2431 :    p3 = s6;                                    \
; 2432 :    p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
; 2433 :    t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
; 2434 :    t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
; 2435 :    p2 = s0;                                    \
; 2436 :    p3 = s4;                                    \
; 2437 :    t0 = stbi__fsh(p2+p3);                      \
; 2438 :    t1 = stbi__fsh(p2-p3);                      \
; 2439 :    x0 = t0+t3;                                 \
; 2440 :    x3 = t0-t3;                                 \
; 2441 :    x1 = t1+t2;                                 \
; 2442 :    x2 = t1-t2;                                 \
; 2443 :    t0 = s7;                                    \
; 2444 :    t1 = s5;                                    \
; 2445 :    t2 = s3;                                    \
; 2446 :    t3 = s1;                                    \
; 2447 :    p3 = t0+t2;                                 \
; 2448 :    p4 = t1+t3;                                 \
; 2449 :    p1 = t0+t3;                                 \
; 2450 :    p2 = t1+t2;                                 \
; 2451 :    p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
; 2452 :    t0 = t0*stbi__f2f( 0.298631336f);           \
; 2453 :    t1 = t1*stbi__f2f( 2.053119869f);           \
; 2454 :    t2 = t2*stbi__f2f( 3.072711026f);           \
; 2455 :    t3 = t3*stbi__f2f( 1.501321110f);           \
; 2456 :    p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
; 2457 :    p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
; 2458 :    p3 = p3*stbi__f2f(-1.961570560f);           \
; 2459 :    p4 = p4*stbi__f2f(-0.390180644f);           \
; 2460 :    t3 += p1+p4;                                \
; 2461 :    t2 += p2+p3;                                \
; 2462 :    t1 += p2+p4;                                \
; 2463 :    t0 += p1+p3;
; 2464 : 
; 2465 : static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
; 2466 : {
; 2467 :    int i,val[64],*v=val;
; 2468 :    stbi_uc *o;
; 2469 :    short *d = data;
; 2470 : 
; 2471 :    // columns
; 2472 :    for (i=0; i < 8; ++i,++d, ++v) {
; 2473 :       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2474 :       if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2475 :            && d[40]==0 && d[48]==0 && d[56]==0) {
; 2476 :          //    no shortcut                 0     seconds
; 2477 :          //    (1|2|3|4|5|6|7)==0          0     seconds
; 2478 :          //    all separate               -0.047 seconds
; 2479 :          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2480 :          int dcterm = d[0]*4;
; 2481 :          v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
; 2482 :       } else {
; 2483 :          STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
; 2484 :          // constants scaled things up by 1<<12; let's bring them back
; 2485 :          // down, but keep 2 extra bits of precision
; 2486 :          x0 += 512; x1 += 512; x2 += 512; x3 += 512;
; 2487 :          v[ 0] = (x0+t3) >> 10;
; 2488 :          v[56] = (x0-t3) >> 10;
; 2489 :          v[ 8] = (x1+t2) >> 10;
; 2490 :          v[48] = (x1-t2) >> 10;
; 2491 :          v[16] = (x2+t1) >> 10;
; 2492 :          v[40] = (x2-t1) >> 10;
; 2493 :          v[24] = (x3+t0) >> 10;
; 2494 :          v[32] = (x3-t0) >> 10;
; 2495 :       }
; 2496 :    }
; 2497 : 
; 2498 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
; 2499 :       // no fast case since the first 1D IDCT spread components out
; 2500 :       STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
; 2501 :       // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2502 :       // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2503 :       // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2504 :       // so we want to round that, which means adding 0.5 * 1<<17,
; 2505 :       // aka 65536. Also, we'll end up with -128 to 127 that we want
; 2506 :       // to encode as 0..255 by adding 128, so we'll add that before the shift
; 2507 :       x0 += 65536 + (128<<17);
; 2508 :       x1 += 65536 + (128<<17);
; 2509 :       x2 += 65536 + (128<<17);
; 2510 :       x3 += 65536 + (128<<17);
; 2511 :       // tried computing the shifts into temps, or'ing the temps to see
; 2512 :       // if any were out of range, but that was slower
; 2513 :       o[0] = stbi__clamp((x0+t3) >> 17);
; 2514 :       o[7] = stbi__clamp((x0-t3) >> 17);
; 2515 :       o[1] = stbi__clamp((x1+t2) >> 17);
; 2516 :       o[6] = stbi__clamp((x1-t2) >> 17);
; 2517 :       o[2] = stbi__clamp((x2+t1) >> 17);
; 2518 :       o[5] = stbi__clamp((x2-t1) >> 17);
; 2519 :       o[3] = stbi__clamp((x3+t0) >> 17);
; 2520 :       o[4] = stbi__clamp((x3-t0) >> 17);
; 2521 :    }
; 2522 : }
; 2523 : 
; 2524 : #ifdef STBI_SSE2
; 2525 : // sse2 integer IDCT. not the fastest possible implementation but it
; 2526 : // produces bit-identical results to the generic C version so it's
; 2527 : // fully "transparent".
; 2528 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2529 : {
; 2530 :    // This is constructed to match our regular (generic) integer IDCT exactly.
; 2531 :    __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2532 :    __m128i tmp;
; 2533 : 
; 2534 :    // dot product constant: even elems=x, odd elems=y
; 2535 :    #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2536 : 
; 2537 :    // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2538 :    // out(1) = c1[even]*x + c1[odd]*y
; 2539 :    #define dct_rot(out0,out1, x,y,c0,c1) \
; 2540 :       __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2541 :       __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2542 :       __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2543 :       __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2544 :       __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2545 :       __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2546 : 
; 2547 :    // out = in << 12  (in 16-bit, out 32-bit)
; 2548 :    #define dct_widen(out, in) \
; 2549 :       __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2550 :       __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2551 : 
; 2552 :    // wide add
; 2553 :    #define dct_wadd(out, a, b) \
; 2554 :       __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2555 :       __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2556 : 
; 2557 :    // wide sub
; 2558 :    #define dct_wsub(out, a, b) \
; 2559 :       __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2560 :       __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2561 : 
; 2562 :    // butterfly a/b, add bias, then shift by "s" and pack
; 2563 :    #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2564 :       { \
; 2565 :          __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2566 :          __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2567 :          dct_wadd(sum, abiased, b); \
; 2568 :          dct_wsub(dif, abiased, b); \
; 2569 :          out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2570 :          out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2571 :       }
; 2572 : 
; 2573 :    // 8-bit interleave step (for transposes)
; 2574 :    #define dct_interleave8(a, b) \
; 2575 :       tmp = a; \
; 2576 :       a = _mm_unpacklo_epi8(a, b); \
; 2577 :       b = _mm_unpackhi_epi8(tmp, b)
; 2578 : 
; 2579 :    // 16-bit interleave step (for transposes)
; 2580 :    #define dct_interleave16(a, b) \
; 2581 :       tmp = a; \
; 2582 :       a = _mm_unpacklo_epi16(a, b); \
; 2583 :       b = _mm_unpackhi_epi16(tmp, b)
; 2584 : 
; 2585 :    #define dct_pass(bias,shift) \
; 2586 :       { \
; 2587 :          /* even part */ \
; 2588 :          dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2589 :          __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2590 :          __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2591 :          dct_widen(t0e, sum04); \
; 2592 :          dct_widen(t1e, dif04); \
; 2593 :          dct_wadd(x0, t0e, t3e); \
; 2594 :          dct_wsub(x3, t0e, t3e); \
; 2595 :          dct_wadd(x1, t1e, t2e); \
; 2596 :          dct_wsub(x2, t1e, t2e); \
; 2597 :          /* odd part */ \
; 2598 :          dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2599 :          dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2600 :          __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2601 :          __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2602 :          dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2603 :          dct_wadd(x4, y0o, y4o); \
; 2604 :          dct_wadd(x5, y1o, y5o); \
; 2605 :          dct_wadd(x6, y2o, y5o); \
; 2606 :          dct_wadd(x7, y3o, y4o); \
; 2607 :          dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2608 :          dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2609 :          dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2610 :          dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2611 :       }
; 2612 : 
; 2613 :    __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
; 2614 :    __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
; 2615 :    __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
; 2616 :    __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
; 2617 :    __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
; 2618 :    __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
; 2619 :    __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
; 2620 :    __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
; 2621 : 
; 2622 :    // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2623 :    __m128i bias_0 = _mm_set1_epi32(512);
; 2624 :    __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
; 2625 : 
; 2626 :    // load
; 2627 :    row0 = _mm_load_si128((const __m128i *) (data + 0*8));
; 2628 :    row1 = _mm_load_si128((const __m128i *) (data + 1*8));
; 2629 :    row2 = _mm_load_si128((const __m128i *) (data + 2*8));
; 2630 :    row3 = _mm_load_si128((const __m128i *) (data + 3*8));
; 2631 :    row4 = _mm_load_si128((const __m128i *) (data + 4*8));
; 2632 :    row5 = _mm_load_si128((const __m128i *) (data + 5*8));
; 2633 :    row6 = _mm_load_si128((const __m128i *) (data + 6*8));
; 2634 :    row7 = _mm_load_si128((const __m128i *) (data + 7*8));
; 2635 : 
; 2636 :    // column pass
; 2637 :    dct_pass(bias_0, 10);
; 2638 : 
; 2639 :    {
; 2640 :       // 16bit 8x8 transpose pass 1
; 2641 :       dct_interleave16(row0, row4);
; 2642 :       dct_interleave16(row1, row5);
; 2643 :       dct_interleave16(row2, row6);
; 2644 :       dct_interleave16(row3, row7);
; 2645 : 
; 2646 :       // transpose pass 2
; 2647 :       dct_interleave16(row0, row2);
; 2648 :       dct_interleave16(row1, row3);
; 2649 :       dct_interleave16(row4, row6);
; 2650 :       dct_interleave16(row5, row7);
; 2651 : 
; 2652 :       // transpose pass 3
; 2653 :       dct_interleave16(row0, row1);
; 2654 :       dct_interleave16(row2, row3);
; 2655 :       dct_interleave16(row4, row5);
; 2656 :       dct_interleave16(row6, row7);
; 2657 :    }
; 2658 : 
; 2659 :    // row pass
; 2660 :    dct_pass(bias_1, 17);
; 2661 : 
; 2662 :    {
; 2663 :       // pack
; 2664 :       __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
; 2665 :       __m128i p1 = _mm_packus_epi16(row2, row3);
; 2666 :       __m128i p2 = _mm_packus_epi16(row4, row5);
; 2667 :       __m128i p3 = _mm_packus_epi16(row6, row7);
; 2668 : 
; 2669 :       // 8bit 8x8 transpose pass 1
; 2670 :       dct_interleave8(p0, p2); // a0e0a1e1...
; 2671 :       dct_interleave8(p1, p3); // c0g0c1g1...
; 2672 : 
; 2673 :       // transpose pass 2
; 2674 :       dct_interleave8(p0, p1); // a0c0e0g0...
; 2675 :       dct_interleave8(p2, p3); // b0d0f0h0...
; 2676 : 
; 2677 :       // transpose pass 3
; 2678 :       dct_interleave8(p0, p2); // a0b0c0d0...
; 2679 :       dct_interleave8(p1, p3); // a4b4c4d4...
; 2680 : 
; 2681 :       // store
; 2682 :       _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
; 2683 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
; 2684 :       _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
; 2685 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
; 2686 :       _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
; 2687 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
; 2688 :       _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
; 2689 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
; 2690 :    }
; 2691 : 
; 2692 : #undef dct_const
; 2693 : #undef dct_rot
; 2694 : #undef dct_widen
; 2695 : #undef dct_wadd
; 2696 : #undef dct_wsub
; 2697 : #undef dct_bfly32o
; 2698 : #undef dct_interleave8
; 2699 : #undef dct_interleave16
; 2700 : #undef dct_pass
; 2701 : }
; 2702 : 
; 2703 : #endif // STBI_SSE2
; 2704 : 
; 2705 : #ifdef STBI_NEON
; 2706 : 
; 2707 : // NEON integer IDCT. should produce bit-identical
; 2708 : // results to the generic C version.
; 2709 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2710 : {
; 2711 :    int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;
; 2712 : 
; 2713 :    int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
; 2714 :    int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
; 2715 :    int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
; 2716 :    int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
; 2717 :    int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
; 2718 :    int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
; 2719 :    int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
; 2720 :    int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
; 2721 :    int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
; 2722 :    int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
; 2723 :    int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
; 2724 :    int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));
; 2725 : 
; 2726 : #define dct_long_mul(out, inq, coeff) \
; 2727 :    int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
; 2728 :    int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)
; 2729 : 
; 2730 : #define dct_long_mac(out, acc, inq, coeff) \
; 2731 :    int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
; 2732 :    int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)
; 2733 : 
; 2734 : #define dct_widen(out, inq) \
; 2735 :    int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
; 2736 :    int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)
; 2737 : 
; 2738 : // wide add
; 2739 : #define dct_wadd(out, a, b) \
; 2740 :    int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
; 2741 :    int32x4_t out##_h = vaddq_s32(a##_h, b##_h)
; 2742 : 
; 2743 : // wide sub
; 2744 : #define dct_wsub(out, a, b) \
; 2745 :    int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
; 2746 :    int32x4_t out##_h = vsubq_s32(a##_h, b##_h)
; 2747 : 
; 2748 : // butterfly a/b, then shift using "shiftop" by "s" and pack
; 2749 : #define dct_bfly32o(out0,out1, a,b,shiftop,s) \
; 2750 :    { \
; 2751 :       dct_wadd(sum, a, b); \
; 2752 :       dct_wsub(dif, a, b); \
; 2753 :       out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
; 2754 :       out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
; 2755 :    }
; 2756 : 
; 2757 : #define dct_pass(shiftop, shift) \
; 2758 :    { \
; 2759 :       /* even part */ \
; 2760 :       int16x8_t sum26 = vaddq_s16(row2, row6); \
; 2761 :       dct_long_mul(p1e, sum26, rot0_0); \
; 2762 :       dct_long_mac(t2e, p1e, row6, rot0_1); \
; 2763 :       dct_long_mac(t3e, p1e, row2, rot0_2); \
; 2764 :       int16x8_t sum04 = vaddq_s16(row0, row4); \
; 2765 :       int16x8_t dif04 = vsubq_s16(row0, row4); \
; 2766 :       dct_widen(t0e, sum04); \
; 2767 :       dct_widen(t1e, dif04); \
; 2768 :       dct_wadd(x0, t0e, t3e); \
; 2769 :       dct_wsub(x3, t0e, t3e); \
; 2770 :       dct_wadd(x1, t1e, t2e); \
; 2771 :       dct_wsub(x2, t1e, t2e); \
; 2772 :       /* odd part */ \
; 2773 :       int16x8_t sum15 = vaddq_s16(row1, row5); \
; 2774 :       int16x8_t sum17 = vaddq_s16(row1, row7); \
; 2775 :       int16x8_t sum35 = vaddq_s16(row3, row5); \
; 2776 :       int16x8_t sum37 = vaddq_s16(row3, row7); \
; 2777 :       int16x8_t sumodd = vaddq_s16(sum17, sum35); \
; 2778 :       dct_long_mul(p5o, sumodd, rot1_0); \
; 2779 :       dct_long_mac(p1o, p5o, sum17, rot1_1); \
; 2780 :       dct_long_mac(p2o, p5o, sum35, rot1_2); \
; 2781 :       dct_long_mul(p3o, sum37, rot2_0); \
; 2782 :       dct_long_mul(p4o, sum15, rot2_1); \
; 2783 :       dct_wadd(sump13o, p1o, p3o); \
; 2784 :       dct_wadd(sump24o, p2o, p4o); \
; 2785 :       dct_wadd(sump23o, p2o, p3o); \
; 2786 :       dct_wadd(sump14o, p1o, p4o); \
; 2787 :       dct_long_mac(x4, sump13o, row7, rot3_0); \
; 2788 :       dct_long_mac(x5, sump24o, row5, rot3_1); \
; 2789 :       dct_long_mac(x6, sump23o, row3, rot3_2); \
; 2790 :       dct_long_mac(x7, sump14o, row1, rot3_3); \
; 2791 :       dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
; 2792 :       dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
; 2793 :       dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
; 2794 :       dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
; 2795 :    }
; 2796 : 
; 2797 :    // load
; 2798 :    row0 = vld1q_s16(data + 0*8);
; 2799 :    row1 = vld1q_s16(data + 1*8);
; 2800 :    row2 = vld1q_s16(data + 2*8);
; 2801 :    row3 = vld1q_s16(data + 3*8);
; 2802 :    row4 = vld1q_s16(data + 4*8);
; 2803 :    row5 = vld1q_s16(data + 5*8);
; 2804 :    row6 = vld1q_s16(data + 6*8);
; 2805 :    row7 = vld1q_s16(data + 7*8);
; 2806 : 
; 2807 :    // add DC bias
; 2808 :    row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));
; 2809 : 
; 2810 :    // column pass
; 2811 :    dct_pass(vrshrn_n_s32, 10);
; 2812 : 
; 2813 :    // 16bit 8x8 transpose
; 2814 :    {
; 2815 : // these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
; 2816 : // whether compilers actually get this is another story, sadly.
; 2817 : #define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
; 2818 : #define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
; 2819 : #define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }
; 2820 : 
; 2821 :       // pass 1
; 2822 :       dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
; 2823 :       dct_trn16(row2, row3);
; 2824 :       dct_trn16(row4, row5);
; 2825 :       dct_trn16(row6, row7);
; 2826 : 
; 2827 :       // pass 2
; 2828 :       dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
; 2829 :       dct_trn32(row1, row3);
; 2830 :       dct_trn32(row4, row6);
; 2831 :       dct_trn32(row5, row7);
; 2832 : 
; 2833 :       // pass 3
; 2834 :       dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
; 2835 :       dct_trn64(row1, row5);
; 2836 :       dct_trn64(row2, row6);
; 2837 :       dct_trn64(row3, row7);
; 2838 : 
; 2839 : #undef dct_trn16
; 2840 : #undef dct_trn32
; 2841 : #undef dct_trn64
; 2842 :    }
; 2843 : 
; 2844 :    // row pass
; 2845 :    // vrshrn_n_s32 only supports shifts up to 16, we need
; 2846 :    // 17. so do a non-rounding shift of 16 first then follow
; 2847 :    // up with a rounding shift by 1.
; 2848 :    dct_pass(vshrn_n_s32, 16);
; 2849 : 
; 2850 :    {
; 2851 :       // pack and round
; 2852 :       uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
; 2853 :       uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
; 2854 :       uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
; 2855 :       uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
; 2856 :       uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
; 2857 :       uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
; 2858 :       uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
; 2859 :       uint8x8_t p7 = vqrshrun_n_s16(row7, 1);
; 2860 : 
; 2861 :       // again, these can translate into one instruction, but often don't.
; 2862 : #define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
; 2863 : #define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
; 2864 : #define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }
; 2865 : 
; 2866 :       // sadly can't use interleaved stores here since we only write
; 2867 :       // 8 bytes to each scan line!
; 2868 : 
; 2869 :       // 8x8 8-bit transpose pass 1
; 2870 :       dct_trn8_8(p0, p1);
; 2871 :       dct_trn8_8(p2, p3);
; 2872 :       dct_trn8_8(p4, p5);
; 2873 :       dct_trn8_8(p6, p7);
; 2874 : 
; 2875 :       // pass 2
; 2876 :       dct_trn8_16(p0, p2);
; 2877 :       dct_trn8_16(p1, p3);
; 2878 :       dct_trn8_16(p4, p6);
; 2879 :       dct_trn8_16(p5, p7);
; 2880 : 
; 2881 :       // pass 3
; 2882 :       dct_trn8_32(p0, p4);
; 2883 :       dct_trn8_32(p1, p5);
; 2884 :       dct_trn8_32(p2, p6);
; 2885 :       dct_trn8_32(p3, p7);
; 2886 : 
; 2887 :       // store
; 2888 :       vst1_u8(out, p0); out += out_stride;
; 2889 :       vst1_u8(out, p1); out += out_stride;
; 2890 :       vst1_u8(out, p2); out += out_stride;
; 2891 :       vst1_u8(out, p3); out += out_stride;
; 2892 :       vst1_u8(out, p4); out += out_stride;
; 2893 :       vst1_u8(out, p5); out += out_stride;
; 2894 :       vst1_u8(out, p6); out += out_stride;
; 2895 :       vst1_u8(out, p7);
; 2896 : 
; 2897 : #undef dct_trn8_8
; 2898 : #undef dct_trn8_16
; 2899 : #undef dct_trn8_32
; 2900 :    }
; 2901 : 
; 2902 : #undef dct_long_mul
; 2903 : #undef dct_long_mac
; 2904 : #undef dct_widen
; 2905 : #undef dct_wadd
; 2906 : #undef dct_wsub
; 2907 : #undef dct_bfly32o
; 2908 : #undef dct_pass
; 2909 : }
; 2910 : 
; 2911 : #endif // STBI_NEON
; 2912 : 
; 2913 : #define STBI__MARKER_none  0xff
; 2914 : // if there's a pending marker from the entropy stream, return that
; 2915 : // otherwise, fetch from the stream and get a marker. if there's no
; 2916 : // marker, return 0xff, which is never a valid marker value
; 2917 : static stbi_uc stbi__get_marker(stbi__jpeg *j)
; 2918 : {
; 2919 :    stbi_uc x;
; 2920 :    if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
; 2921 :    x = stbi__get8(j->s);
; 2922 :    if (x != 0xff) return STBI__MARKER_none;
; 2923 :    while (x == 0xff)
; 2924 :       x = stbi__get8(j->s); // consume repeated 0xff fill bytes
; 2925 :    return x;
; 2926 : }
; 2927 : 
; 2928 : // in each scan, we'll have scan_n components, and the order
; 2929 : // of the components is specified by order[]
; 2930 : #define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
; 2931 : 
; 2932 : // after a restart interval, stbi__jpeg_reset the entropy decoder and
; 2933 : // the dc prediction
; 2934 : static void stbi__jpeg_reset(stbi__jpeg *j)
; 2935 : {
; 2936 :    j->code_bits = 0;
; 2937 :    j->code_buffer = 0;
; 2938 :    j->nomore = 0;
; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
; 2940 :    j->marker = STBI__MARKER_none;
; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
; 2942 :    j->eob_run = 0;
; 2943 :    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2944 :    // since we don't even allow 1<<30 pixels
; 2945 : }
; 2946 : 
; 2947 : static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
; 2948 : {
; 2949 :    stbi__jpeg_reset(z);
; 2950 :    if (!z->progressive) {
; 2951 :       if (z->scan_n == 1) {
; 2952 :          int i,j;
; 2953 :          STBI_SIMD_ALIGN(short, data[64]);
; 2954 :          int n = z->order[0];
; 2955 :          // non-interleaved data, we just need to process one block at a time,
; 2956 :          // in trivial scanline order
; 2957 :          // number of blocks to do just depends on how many actual "pixels" this
; 2958 :          // component has, independent of interleaved MCU blocking and such
; 2959 :          int w = (z->img_comp[n].x+7) >> 3;
; 2960 :          int h = (z->img_comp[n].y+7) >> 3;
; 2961 :          for (j=0; j < h; ++j) {
; 2962 :             for (i=0; i < w; ++i) {
; 2963 :                int ha = z->img_comp[n].ha;
; 2964 :                if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2965 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 2966 :                // every data block is an MCU, so countdown the restart interval
; 2967 :                if (--z->todo <= 0) {
; 2968 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 2969 :                   // if it's NOT a restart, then just bail, so we get corrupt data
; 2970 :                   // rather than no data
; 2971 :                   if (!STBI__RESTART(z->marker)) return 1;
; 2972 :                   stbi__jpeg_reset(z);
; 2973 :                }
; 2974 :             }
; 2975 :          }
; 2976 :          return 1;
; 2977 :       } else { // interleaved
; 2978 :          int i,j,k,x,y;
; 2979 :          STBI_SIMD_ALIGN(short, data[64]);
; 2980 :          for (j=0; j < z->img_mcu_y; ++j) {
; 2981 :             for (i=0; i < z->img_mcu_x; ++i) {
; 2982 :                // scan an interleaved mcu... process scan_n components in order
; 2983 :                for (k=0; k < z->scan_n; ++k) {
; 2984 :                   int n = z->order[k];
; 2985 :                   // scan out an mcu's worth of this component; that's just determined
; 2986 :                   // by the basic H and V specified for the component
; 2987 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 2988 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 2989 :                         int x2 = (i*z->img_comp[n].h + x)*8;
; 2990 :                         int y2 = (j*z->img_comp[n].v + y)*8;
; 2991 :                         int ha = z->img_comp[n].ha;
; 2992 :                         if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2993 :                         z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
; 2994 :                      }
; 2995 :                   }
; 2996 :                }
; 2997 :                // after all interleaved components, that's an interleaved MCU,
; 2998 :                // so now count down the restart interval
; 2999 :                if (--z->todo <= 0) {
; 3000 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3001 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3002 :                   stbi__jpeg_reset(z);
; 3003 :                }
; 3004 :             }
; 3005 :          }
; 3006 :          return 1;
; 3007 :       }
; 3008 :    } else {
; 3009 :       if (z->scan_n == 1) {
; 3010 :          int i,j;
; 3011 :          int n = z->order[0];
; 3012 :          // non-interleaved data, we just need to process one block at a time,
; 3013 :          // in trivial scanline order
; 3014 :          // number of blocks to do just depends on how many actual "pixels" this
; 3015 :          // component has, independent of interleaved MCU blocking and such
; 3016 :          int w = (z->img_comp[n].x+7) >> 3;
; 3017 :          int h = (z->img_comp[n].y+7) >> 3;
; 3018 :          for (j=0; j < h; ++j) {
; 3019 :             for (i=0; i < w; ++i) {
; 3020 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3021 :                if (z->spec_start == 0) {
; 3022 :                   if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3023 :                      return 0;
; 3024 :                } else {
; 3025 :                   int ha = z->img_comp[n].ha;
; 3026 :                   if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
; 3027 :                      return 0;
; 3028 :                }
; 3029 :                // every data block is an MCU, so countdown the restart interval
; 3030 :                if (--z->todo <= 0) {
; 3031 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3032 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3033 :                   stbi__jpeg_reset(z);
; 3034 :                }
; 3035 :             }
; 3036 :          }
; 3037 :          return 1;
; 3038 :       } else { // interleaved
; 3039 :          int i,j,k,x,y;
; 3040 :          for (j=0; j < z->img_mcu_y; ++j) {
; 3041 :             for (i=0; i < z->img_mcu_x; ++i) {
; 3042 :                // scan an interleaved mcu... process scan_n components in order
; 3043 :                for (k=0; k < z->scan_n; ++k) {
; 3044 :                   int n = z->order[k];
; 3045 :                   // scan out an mcu's worth of this component; that's just determined
; 3046 :                   // by the basic H and V specified for the component
; 3047 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 3048 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 3049 :                         int x2 = (i*z->img_comp[n].h + x);
; 3050 :                         int y2 = (j*z->img_comp[n].v + y);
; 3051 :                         short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
; 3052 :                         if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3053 :                            return 0;
; 3054 :                      }
; 3055 :                   }
; 3056 :                }
; 3057 :                // after all interleaved components, that's an interleaved MCU,
; 3058 :                // so now count down the restart interval
; 3059 :                if (--z->todo <= 0) {
; 3060 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3061 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3062 :                   stbi__jpeg_reset(z);
; 3063 :                }
; 3064 :             }
; 3065 :          }
; 3066 :          return 1;
; 3067 :       }
; 3068 :    }
; 3069 : }
; 3070 : 
; 3071 : static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
; 3072 : {
; 3073 :    int i;
; 3074 :    for (i=0; i < 64; ++i)
; 3075 :       data[i] *= dequant[i];
; 3076 : }
; 3077 : 
; 3078 : static void stbi__jpeg_finish(stbi__jpeg *z)
; 3079 : {
; 3080 :    if (z->progressive) {
; 3081 :       // dequantize and idct the data
; 3082 :       int i,j,n;
; 3083 :       for (n=0; n < z->s->img_n; ++n) {
; 3084 :          int w = (z->img_comp[n].x+7) >> 3;
; 3085 :          int h = (z->img_comp[n].y+7) >> 3;
; 3086 :          for (j=0; j < h; ++j) {
; 3087 :             for (i=0; i < w; ++i) {
; 3088 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3089 :                stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
; 3090 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 3091 :             }
; 3092 :          }
; 3093 :       }
; 3094 :    }
; 3095 : }
; 3096 : 
; 3097 : static int stbi__process_marker(stbi__jpeg *z, int m)
; 3098 : {
; 3099 :    int L;
; 3100 :    switch (m) {
; 3101 :       case STBI__MARKER_none: // no marker found
; 3102 :          return stbi__err("expected marker","Corrupt JPEG");
; 3103 : 
; 3104 :       case 0xDD: // DRI - specify restart interval
; 3105 :          if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
; 3106 :          z->restart_interval = stbi__get16be(z->s);
; 3107 :          return 1;
; 3108 : 
; 3109 :       case 0xDB: // DQT - define quantization table
; 3110 :          L = stbi__get16be(z->s)-2;
; 3111 :          while (L > 0) {
; 3112 :             int q = stbi__get8(z->s);
; 3113 :             int p = q >> 4, sixteen = (p != 0);
; 3114 :             int t = q & 15,i;
; 3115 :             if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
; 3116 :             if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");
; 3117 : 
; 3118 :             for (i=0; i < 64; ++i)
; 3119 :                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
; 3120 :             L -= (sixteen ? 129 : 65);
; 3121 :          }
; 3122 :          return L==0;
; 3123 : 
; 3124 :       case 0xC4: // DHT - define huffman table
; 3125 :          L = stbi__get16be(z->s)-2;
; 3126 :          while (L > 0) {
; 3127 :             stbi_uc *v;
; 3128 :             int sizes[16],i,n=0;
; 3129 :             int q = stbi__get8(z->s);
; 3130 :             int tc = q >> 4;
; 3131 :             int th = q & 15;
; 3132 :             if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
; 3133 :             for (i=0; i < 16; ++i) {
; 3134 :                sizes[i] = stbi__get8(z->s);
; 3135 :                n += sizes[i];
; 3136 :             }
; 3137 :             if(n > 256) return stbi__err("bad DHT header","Corrupt JPEG"); // Loop over i < n would write past end of values!
; 3138 :             L -= 17;
; 3139 :             if (tc == 0) {
; 3140 :                if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
; 3141 :                v = z->huff_dc[th].values;
; 3142 :             } else {
; 3143 :                if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
; 3144 :                v = z->huff_ac[th].values;
; 3145 :             }
; 3146 :             for (i=0; i < n; ++i)
; 3147 :                v[i] = stbi__get8(z->s);
; 3148 :             if (tc != 0)
; 3149 :                stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
; 3150 :             L -= n;
; 3151 :          }
; 3152 :          return L==0;
; 3153 :    }
; 3154 : 
; 3155 :    // check for comment block or APP blocks
; 3156 :    if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
; 3157 :       L = stbi__get16be(z->s);
; 3158 :       if (L < 2) {
; 3159 :          if (m == 0xFE)
; 3160 :             return stbi__err("bad COM len","Corrupt JPEG");
; 3161 :          else
; 3162 :             return stbi__err("bad APP len","Corrupt JPEG");
; 3163 :       }
; 3164 :       L -= 2;
; 3165 : 
; 3166 :       if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
; 3167 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3168 :          int ok = 1;
; 3169 :          int i;
; 3170 :          for (i=0; i < 5; ++i)
; 3171 :             if (stbi__get8(z->s) != tag[i])
; 3172 :                ok = 0;
; 3173 :          L -= 5;
; 3174 :          if (ok)
; 3175 :             z->jfif = 1;
; 3176 :       } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;
; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)
; 3181 :             if (stbi__get8(z->s) != tag[i])
; 3182 :                ok = 0;
; 3183 :          L -= 6;
; 3184 :          if (ok) {
; 3185 :             stbi__get8(z->s); // version
; 3186 :             stbi__get16be(z->s); // flags0
; 3187 :             stbi__get16be(z->s); // flags1
; 3188 :             z->app14_color_transform = stbi__get8(z->s); // color transform
; 3189 :             L -= 6;
; 3190 :          }
; 3191 :       }
; 3192 : 
; 3193 :       stbi__skip(z->s, L);
; 3194 :       return 1;
; 3195 :    }
; 3196 : 
; 3197 :    return stbi__err("unknown marker","Corrupt JPEG");
; 3198 : }
; 3199 : 
; 3200 : // after we see SOS
; 3201 : static int stbi__process_scan_header(stbi__jpeg *z)
; 3202 : {
; 3203 :    int i;
; 3204 :    int Ls = stbi__get16be(z->s);
; 3205 :    z->scan_n = stbi__get8(z->s);
; 3206 :    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
; 3207 :    if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
; 3208 :    for (i=0; i < z->scan_n; ++i) {
; 3209 :       int id = stbi__get8(z->s), which;
; 3210 :       int q = stbi__get8(z->s);
; 3211 :       for (which = 0; which < z->s->img_n; ++which)
; 3212 :          if (z->img_comp[which].id == id)
; 3213 :             break;
; 3214 :       if (which == z->s->img_n) return 0; // no match
; 3215 :       z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
; 3216 :       z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
; 3217 :       z->order[i] = which;
; 3218 :    }
; 3219 : 
; 3220 :    {
; 3221 :       int aa;
; 3222 :       z->spec_start = stbi__get8(z->s);
; 3223 :       z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
; 3224 :       aa = stbi__get8(z->s);
; 3225 :       z->succ_high = (aa >> 4);
; 3226 :       z->succ_low  = (aa & 15);
; 3227 :       if (z->progressive) {
; 3228 :          if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
; 3229 :             return stbi__err("bad SOS", "Corrupt JPEG");
; 3230 :       } else {
; 3231 :          if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3232 :          if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3233 :          z->spec_end = 63;
; 3234 :       }
; 3235 :    }
; 3236 : 
; 3237 :    return 1;
; 3238 : }
; 3239 : 
; 3240 : static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
; 3241 : {
; 3242 :    int i;
; 3243 :    for (i=0; i < ncomp; ++i) {
; 3244 :       if (z->img_comp[i].raw_data) {
; 3245 :          STBI_FREE(z->img_comp[i].raw_data);
; 3246 :          z->img_comp[i].raw_data = NULL;
; 3247 :          z->img_comp[i].data = NULL;
; 3248 :       }
; 3249 :       if (z->img_comp[i].raw_coeff) {
; 3250 :          STBI_FREE(z->img_comp[i].raw_coeff);
; 3251 :          z->img_comp[i].raw_coeff = 0;
; 3252 :          z->img_comp[i].coeff = 0;
; 3253 :       }
; 3254 :       if (z->img_comp[i].linebuf) {
; 3255 :          STBI_FREE(z->img_comp[i].linebuf);
; 3256 :          z->img_comp[i].linebuf = NULL;
; 3257 :       }
; 3258 :    }
; 3259 :    return why;
; 3260 : }
; 3261 : 
; 3262 : static int stbi__process_frame_header(stbi__jpeg *z, int scan)
; 3263 : {
; 3264 :    stbi__context *s = z->s;
; 3265 :    int Lf,p,i,q, h_max=1,v_max=1,c;
; 3266 :    Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
; 3267 :    p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
; 3268 :    s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
; 3269 :    s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
; 3270 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 3271 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 3272 :    c = stbi__get8(s);
; 3273 :    if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");
; 3274 :    s->img_n = c;
; 3275 :    for (i=0; i < c; ++i) {
; 3276 :       z->img_comp[i].data = NULL;
; 3277 :       z->img_comp[i].linebuf = NULL;
; 3278 :    }
; 3279 : 
; 3280 :    if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");
; 3281 : 
; 3282 :    z->rgb = 0;
; 3283 :    for (i=0; i < s->img_n; ++i) {
; 3284 :       static const unsigned char rgb[3] = { 'R', 'G', 'B' };
; 3285 :       z->img_comp[i].id = stbi__get8(s);
; 3286 :       if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
; 3287 :          ++z->rgb;
; 3288 :       q = stbi__get8(s);
; 3289 :       z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
; 3290 :       z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
; 3291 :       z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
; 3292 :    }
; 3293 : 
; 3294 :    if (scan != STBI__SCAN_load) return 1;
; 3295 : 
; 3296 :    if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");
; 3297 : 
; 3298 :    for (i=0; i < s->img_n; ++i) {
; 3299 :       if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
; 3300 :       if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
; 3301 :    }
; 3302 : 
; 3303 :    // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
; 3304 :    // and I've never seen a non-corrupted JPEG file actually use them
; 3305 :    for (i=0; i < s->img_n; ++i) {
; 3306 :       if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");
; 3307 :       if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");
; 3308 :    }
; 3309 : 
; 3310 :    // compute interleaved mcu info
; 3311 :    z->img_h_max = h_max;
; 3312 :    z->img_v_max = v_max;
; 3313 :    z->img_mcu_w = h_max * 8;
; 3314 :    z->img_mcu_h = v_max * 8;
; 3315 :    // these sizes can't be more than 17 bits
; 3316 :    z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
; 3317 :    z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;
; 3318 : 
; 3319 :    for (i=0; i < s->img_n; ++i) {
; 3320 :       // number of effective pixels (e.g. for non-interleaved MCU)
; 3321 :       z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
; 3322 :       z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
; 3323 :       // to simplify generation, we'll allocate enough memory to decode
; 3324 :       // the bogus oversized data from using interleaved MCUs and their
; 3325 :       // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
; 3326 :       // discard the extra data until colorspace conversion
; 3327 :       //
; 3328 :       // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
; 3329 :       // so these muls can't overflow with 32-bit ints (which we require)
; 3330 :       z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
; 3331 :       z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
; 3332 :       z->img_comp[i].coeff = 0;
; 3333 :       z->img_comp[i].raw_coeff = 0;
; 3334 :       z->img_comp[i].linebuf = NULL;
; 3335 :       z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
; 3336 :       if (z->img_comp[i].raw_data == NULL)
; 3337 :          return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
; 3338 :       // align blocks for idct using mmx/sse
; 3339 :       z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
; 3340 :       if (z->progressive) {
; 3341 :          // w2, h2 are multiples of 8 (see above)
; 3342 :          z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
; 3343 :          z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
; 3344 :          z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
; 3345 :          if (z->img_comp[i].raw_coeff == NULL)
; 3346 :             return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
; 3347 :          z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
; 3348 :       }
; 3349 :    }
; 3350 : 
; 3351 :    return 1;
; 3352 : }
; 3353 : 
; 3354 : // use comparisons since in some cases we handle more than one case (e.g. SOF)
; 3355 : #define stbi__DNL(x)         ((x) == 0xdc)
; 3356 : #define stbi__SOI(x)         ((x) == 0xd8)
; 3357 : #define stbi__EOI(x)         ((x) == 0xd9)
; 3358 : #define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
; 3359 : #define stbi__SOS(x)         ((x) == 0xda)
; 3360 : 
; 3361 : #define stbi__SOF_progressive(x)   ((x) == 0xc2)
; 3362 : 
; 3363 : static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
; 3364 : {
; 3365 :    int m;
; 3366 :    z->jfif = 0;
; 3367 :    z->app14_color_transform = -1; // valid values are 0,1,2
; 3368 :    z->marker = STBI__MARKER_none; // initialize cached marker to empty
; 3369 :    m = stbi__get_marker(z);
; 3370 :    if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
; 3371 :    if (scan == STBI__SCAN_type) return 1;
; 3372 :    m = stbi__get_marker(z);
; 3373 :    while (!stbi__SOF(m)) {
; 3374 :       if (!stbi__process_marker(z,m)) return 0;
; 3375 :       m = stbi__get_marker(z);
; 3376 :       while (m == STBI__MARKER_none) {
; 3377 :          // some files have extra padding after their blocks, so ok, we'll scan
; 3378 :          if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
; 3379 :          m = stbi__get_marker(z);
; 3380 :       }
; 3381 :    }
; 3382 :    z->progressive = stbi__SOF_progressive(m);
; 3383 :    if (!stbi__process_frame_header(z, scan)) return 0;
; 3384 :    return 1;
; 3385 : }
; 3386 : 
; 3387 : static int stbi__skip_jpeg_junk_at_end(stbi__jpeg *j)
; 3388 : {
; 3389 :    // some JPEGs have junk at end, skip over it but if we find what looks
; 3390 :    // like a valid marker, resume there
; 3391 :    while (!stbi__at_eof(j->s)) {
; 3392 :       int x = stbi__get8(j->s);
; 3393 :       while (x == 255) { // might be a marker
; 3394 :          if (stbi__at_eof(j->s)) return STBI__MARKER_none;
; 3395 :          x = stbi__get8(j->s);
; 3396 :          if (x != 0x00 && x != 0xff) {
; 3397 :             // not a stuffed zero or lead-in to another marker, looks
; 3398 :             // like an actual marker, return it
; 3399 :             return x;
; 3400 :          }
; 3401 :          // stuffed zero has x=0 now which ends the loop, meaning we go
; 3402 :          // back to regular scan loop.
; 3403 :          // repeated 0xff keeps trying to read the next byte of the marker.
; 3404 :       }
; 3405 :    }
; 3406 :    return STBI__MARKER_none;
; 3407 : }
; 3408 : 
; 3409 : // decode image to YCbCr format
; 3410 : static int stbi__decode_jpeg_image(stbi__jpeg *j)
; 3411 : {
; 3412 :    int m;
; 3413 :    for (m = 0; m < 4; m++) {
; 3414 :       j->img_comp[m].raw_data = NULL;
; 3415 :       j->img_comp[m].raw_coeff = NULL;
; 3416 :    }
; 3417 :    j->restart_interval = 0;
; 3418 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
; 3419 :    m = stbi__get_marker(j);
; 3420 :    while (!stbi__EOI(m)) {
; 3421 :       if (stbi__SOS(m)) {
; 3422 :          if (!stbi__process_scan_header(j)) return 0;
; 3423 :          if (!stbi__parse_entropy_coded_data(j)) return 0;
; 3424 :          if (j->marker == STBI__MARKER_none ) {
; 3425 :          j->marker = stbi__skip_jpeg_junk_at_end(j);
; 3426 :             // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
; 3427 :          }
; 3428 :          m = stbi__get_marker(j);
; 3429 :          if (STBI__RESTART(m))
; 3430 :             m = stbi__get_marker(j);
; 3431 :       } else if (stbi__DNL(m)) {
; 3432 :          int Ld = stbi__get16be(j->s);
; 3433 :          stbi__uint32 NL = stbi__get16be(j->s);
; 3434 :          if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
; 3435 :          if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
; 3436 :          m = stbi__get_marker(j);
; 3437 :       } else {
; 3438 :          if (!stbi__process_marker(j, m)) return 1;
; 3439 :          m = stbi__get_marker(j);
; 3440 :       }
; 3441 :    }
; 3442 :    if (j->progressive)
; 3443 :       stbi__jpeg_finish(j);
; 3444 :    return 1;
; 3445 : }
; 3446 : 
; 3447 : // static jfif-centered resampling (across block boundaries)
; 3448 : 
; 3449 : typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
; 3450 :                                     int w, int hs);
; 3451 : 
; 3452 : #define stbi__div4(x) ((stbi_uc) ((x) >> 2))
; 3453 : 
; 3454 : static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3455 : {
; 3456 :    STBI_NOTUSED(out);
; 3457 :    STBI_NOTUSED(in_far);
; 3458 :    STBI_NOTUSED(w);
; 3459 :    STBI_NOTUSED(hs);
; 3460 :    return in_near;
; 3461 : }
; 3462 : 
; 3463 : static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3464 : {
; 3465 :    // need to generate two samples vertically for every one in input
; 3466 :    int i;
; 3467 :    STBI_NOTUSED(hs);
; 3468 :    for (i=0; i < w; ++i)
; 3469 :       out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
; 3470 :    return out;
; 3471 : }
; 3472 : 
; 3473 : static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3474 : {
; 3475 :    // need to generate two samples horizontally for every one in input
; 3476 :    int i;
; 3477 :    stbi_uc *input = in_near;
; 3478 : 
; 3479 :    if (w == 1) {
; 3480 :       // if only one sample, can't do any interpolation
; 3481 :       out[0] = out[1] = input[0];
; 3482 :       return out;
; 3483 :    }
; 3484 : 
; 3485 :    out[0] = input[0];
; 3486 :    out[1] = stbi__div4(input[0]*3 + input[1] + 2);
; 3487 :    for (i=1; i < w-1; ++i) {
; 3488 :       int n = 3*input[i]+2;
; 3489 :       out[i*2+0] = stbi__div4(n+input[i-1]);
; 3490 :       out[i*2+1] = stbi__div4(n+input[i+1]);
; 3491 :    }
; 3492 :    out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
; 3493 :    out[i*2+1] = input[w-1];
; 3494 : 
; 3495 :    STBI_NOTUSED(in_far);
; 3496 :    STBI_NOTUSED(hs);
; 3497 : 
; 3498 :    return out;
; 3499 : }
; 3500 : 
; 3501 : #define stbi__div16(x) ((stbi_uc) ((x) >> 4))
; 3502 : 
; 3503 : static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3504 : {
; 3505 :    // need to generate 2x2 samples for every one in input
; 3506 :    int i,t0,t1;
; 3507 :    if (w == 1) {
; 3508 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
; 3509 :       return out;
; 3510 :    }
; 3511 : 
; 3512 :    t1 = 3*in_near[0] + in_far[0];
; 3513 :    out[0] = stbi__div4(t1+2);
; 3514 :    for (i=1; i < w; ++i) {
; 3515 :       t0 = t1;
; 3516 :       t1 = 3*in_near[i]+in_far[i];
; 3517 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
; 3518 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
; 3519 :    }
; 3520 :    out[w*2-1] = stbi__div4(t1+2);
; 3521 : 
; 3522 :    STBI_NOTUSED(hs);
; 3523 : 
; 3524 :    return out;
; 3525 : }
; 3526 : 
; 3527 : #if defined(STBI_SSE2) || defined(STBI_NEON)
; 3528 : static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3529 : {
; 3530 :    // need to generate 2x2 samples for every one in input
; 3531 :    int i=0,t0,t1;
; 3532 : 
; 3533 :    if (w == 1) {
; 3534 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
; 3535 :       return out;
; 3536 :    }
; 3537 : 
; 3538 :    t1 = 3*in_near[0] + in_far[0];
; 3539 :    // process groups of 8 pixels for as long as we can.
; 3540 :    // note we can't handle the last pixel in a row in this loop
; 3541 :    // because we need to handle the filter boundary conditions.
; 3542 :    for (; i < ((w-1) & ~7); i += 8) {
; 3543 : #if defined(STBI_SSE2)
; 3544 :       // load and perform the vertical filtering pass
; 3545 :       // this uses 3*x + y = 4*x + (y - x)
; 3546 :       __m128i zero  = _mm_setzero_si128();
; 3547 :       __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
; 3548 :       __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
; 3549 :       __m128i farw  = _mm_unpacklo_epi8(farb, zero);
; 3550 :       __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
; 3551 :       __m128i diff  = _mm_sub_epi16(farw, nearw);
; 3552 :       __m128i nears = _mm_slli_epi16(nearw, 2);
; 3553 :       __m128i curr  = _mm_add_epi16(nears, diff); // current row
; 3554 : 
; 3555 :       // horizontal filter works the same based on shifted vers of current
; 3556 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3557 :       // insert the previous pixel value (from t1).
; 3558 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3559 :       // of next block of 8 pixels added in.
; 3560 :       __m128i prv0 = _mm_slli_si128(curr, 2);
; 3561 :       __m128i nxt0 = _mm_srli_si128(curr, 2);
; 3562 :       __m128i prev = _mm_insert_epi16(prv0, t1, 0);
; 3563 :       __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);
; 3564 : 
; 3565 :       // horizontal filter, polyphase implementation since it's convenient:
; 3566 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3567 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3568 :       // note the shared term.
; 3569 :       __m128i bias  = _mm_set1_epi16(8);
; 3570 :       __m128i curs = _mm_slli_epi16(curr, 2);
; 3571 :       __m128i prvd = _mm_sub_epi16(prev, curr);
; 3572 :       __m128i nxtd = _mm_sub_epi16(next, curr);
; 3573 :       __m128i curb = _mm_add_epi16(curs, bias);
; 3574 :       __m128i even = _mm_add_epi16(prvd, curb);
; 3575 :       __m128i odd  = _mm_add_epi16(nxtd, curb);
; 3576 : 
; 3577 :       // interleave even and odd pixels, then undo scaling.
; 3578 :       __m128i int0 = _mm_unpacklo_epi16(even, odd);
; 3579 :       __m128i int1 = _mm_unpackhi_epi16(even, odd);
; 3580 :       __m128i de0  = _mm_srli_epi16(int0, 4);
; 3581 :       __m128i de1  = _mm_srli_epi16(int1, 4);
; 3582 : 
; 3583 :       // pack and write output
; 3584 :       __m128i outv = _mm_packus_epi16(de0, de1);
; 3585 :       _mm_storeu_si128((__m128i *) (out + i*2), outv);
; 3586 : #elif defined(STBI_NEON)
; 3587 :       // load and perform the vertical filtering pass
; 3588 :       // this uses 3*x + y = 4*x + (y - x)
; 3589 :       uint8x8_t farb  = vld1_u8(in_far + i);
; 3590 :       uint8x8_t nearb = vld1_u8(in_near + i);
; 3591 :       int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
; 3592 :       int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
; 3593 :       int16x8_t curr  = vaddq_s16(nears, diff); // current row
; 3594 : 
; 3595 :       // horizontal filter works the same based on shifted vers of current
; 3596 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3597 :       // insert the previous pixel value (from t1).
; 3598 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3599 :       // of next block of 8 pixels added in.
; 3600 :       int16x8_t prv0 = vextq_s16(curr, curr, 7);
; 3601 :       int16x8_t nxt0 = vextq_s16(curr, curr, 1);
; 3602 :       int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
; 3603 :       int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);
; 3604 : 
; 3605 :       // horizontal filter, polyphase implementation since it's convenient:
; 3606 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3607 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3608 :       // note the shared term.
; 3609 :       int16x8_t curs = vshlq_n_s16(curr, 2);
; 3610 :       int16x8_t prvd = vsubq_s16(prev, curr);
; 3611 :       int16x8_t nxtd = vsubq_s16(next, curr);
; 3612 :       int16x8_t even = vaddq_s16(curs, prvd);
; 3613 :       int16x8_t odd  = vaddq_s16(curs, nxtd);
; 3614 : 
; 3615 :       // undo scaling and round, then store with even/odd phases interleaved
; 3616 :       uint8x8x2_t o;
; 3617 :       o.val[0] = vqrshrun_n_s16(even, 4);
; 3618 :       o.val[1] = vqrshrun_n_s16(odd,  4);
; 3619 :       vst2_u8(out + i*2, o);
; 3620 : #endif
; 3621 : 
; 3622 :       // "previous" value for next iter
; 3623 :       t1 = 3*in_near[i+7] + in_far[i+7];
; 3624 :    }
; 3625 : 
; 3626 :    t0 = t1;
; 3627 :    t1 = 3*in_near[i] + in_far[i];
; 3628 :    out[i*2] = stbi__div16(3*t1 + t0 + 8);
; 3629 : 
; 3630 :    for (++i; i < w; ++i) {
; 3631 :       t0 = t1;
; 3632 :       t1 = 3*in_near[i]+in_far[i];
; 3633 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
; 3634 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
; 3635 :    }
; 3636 :    out[w*2-1] = stbi__div4(t1+2);
; 3637 : 
; 3638 :    STBI_NOTUSED(hs);
; 3639 : 
; 3640 :    return out;
; 3641 : }
; 3642 : #endif
; 3643 : 
; 3644 : static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3645 : {
; 3646 :    // resample with nearest-neighbor
; 3647 :    int i,j;
; 3648 :    STBI_NOTUSED(in_far);
; 3649 :    for (i=0; i < w; ++i)
; 3650 :       for (j=0; j < hs; ++j)
; 3651 :          out[i*hs+j] = in_near[i];
; 3652 :    return out;
; 3653 : }
; 3654 : 
; 3655 : // this is a reduced-precision calculation of YCbCr-to-RGB introduced
; 3656 : // to make sure the code produces the same results in both SIMD and scalar
; 3657 : #define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
; 3658 : static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
; 3659 : {
; 3660 :    int i;
; 3661 :    for (i=0; i < count; ++i) {
; 3662 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding
; 3663 :       int r,g,b;
; 3664 :       int cr = pcr[i] - 128;
; 3665 :       int cb = pcb[i] - 128;
; 3666 :       r = y_fixed +  cr* stbi__float2fixed(1.40200f);
; 3667 :       g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
; 3668 :       b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
; 3669 :       r >>= 20;
; 3670 :       g >>= 20;
; 3671 :       b >>= 20;
; 3672 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
; 3673 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
; 3674 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
; 3675 :       out[0] = (stbi_uc)r;
; 3676 :       out[1] = (stbi_uc)g;
; 3677 :       out[2] = (stbi_uc)b;
; 3678 :       out[3] = 255;
; 3679 :       out += step;
; 3680 :    }
; 3681 : }
; 3682 : 
; 3683 : #if defined(STBI_SSE2) || defined(STBI_NEON)
; 3684 : static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
; 3685 : {
; 3686 :    int i = 0;
; 3687 : 
; 3688 : #ifdef STBI_SSE2
; 3689 :    // step == 3 is pretty ugly on the final interleave, and i'm not convinced
; 3690 :    // it's useful in practice (you wouldn't use it for textures, for example).
; 3691 :    // so just accelerate step == 4 case.
; 3692 :    if (step == 4) {
; 3693 :       // this is a fairly straightforward implementation and not super-optimized.
; 3694 :       __m128i signflip  = _mm_set1_epi8(-0x80);
; 3695 :       __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3696 :       __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3697 :       __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3698 :       __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3699 :       __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
; 3700 :       __m128i xw = _mm_set1_epi16(255); // alpha channel
; 3701 : 
; 3702 :       for (; i+7 < count; i += 8) {
; 3703 :          // load
; 3704 :          __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
; 3705 :          __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
; 3706 :          __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
; 3707 :          __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
; 3708 :          __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128
; 3709 : 
; 3710 :          // unpack to short (and left-shift cr, cb by 8)
; 3711 :          __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
; 3712 :          __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
; 3713 :          __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);
; 3714 : 
; 3715 :          // color transform
; 3716 :          __m128i yws = _mm_srli_epi16(yw, 4);
; 3717 :          __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
; 3718 :          __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
; 3719 :          __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
; 3720 :          __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
; 3721 :          __m128i rws = _mm_add_epi16(cr0, yws);
; 3722 :          __m128i gwt = _mm_add_epi16(cb0, yws);
; 3723 :          __m128i bws = _mm_add_epi16(yws, cb1);
; 3724 :          __m128i gws = _mm_add_epi16(gwt, cr1);
; 3725 : 
; 3726 :          // descale
; 3727 :          __m128i rw = _mm_srai_epi16(rws, 4);
; 3728 :          __m128i bw = _mm_srai_epi16(bws, 4);
; 3729 :          __m128i gw = _mm_srai_epi16(gws, 4);
; 3730 : 
; 3731 :          // back to byte, set up for transpose
; 3732 :          __m128i brb = _mm_packus_epi16(rw, bw);
; 3733 :          __m128i gxb = _mm_packus_epi16(gw, xw);
; 3734 : 
; 3735 :          // transpose to interleave channels
; 3736 :          __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
; 3737 :          __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
; 3738 :          __m128i o0 = _mm_unpacklo_epi16(t0, t1);
; 3739 :          __m128i o1 = _mm_unpackhi_epi16(t0, t1);
; 3740 : 
; 3741 :          // store
; 3742 :          _mm_storeu_si128((__m128i *) (out + 0), o0);
; 3743 :          _mm_storeu_si128((__m128i *) (out + 16), o1);
; 3744 :          out += 32;
; 3745 :       }
; 3746 :    }
; 3747 : #endif
; 3748 : 
; 3749 : #ifdef STBI_NEON
; 3750 :    // in this version, step=3 support would be easy to add. but is there demand?
; 3751 :    if (step == 4) {
; 3752 :       // this is a fairly straightforward implementation and not super-optimized.
; 3753 :       uint8x8_t signflip = vdup_n_u8(0x80);
; 3754 :       int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3755 :       int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3756 :       int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3757 :       int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3758 : 
; 3759 :       for (; i+7 < count; i += 8) {
; 3760 :          // load
; 3761 :          uint8x8_t y_bytes  = vld1_u8(y + i);
; 3762 :          uint8x8_t cr_bytes = vld1_u8(pcr + i);
; 3763 :          uint8x8_t cb_bytes = vld1_u8(pcb + i);
; 3764 :          int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
; 3765 :          int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
; 3766 : 
; 3767 :          // expand to s16
; 3768 :          int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
; 3769 :          int16x8_t crw = vshll_n_s8(cr_biased, 7);
; 3770 :          int16x8_t cbw = vshll_n_s8(cb_biased, 7);
; 3771 : 
; 3772 :          // color transform
; 3773 :          int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
; 3774 :          int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
; 3775 :          int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
; 3776 :          int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
; 3777 :          int16x8_t rws = vaddq_s16(yws, cr0);
; 3778 :          int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
; 3779 :          int16x8_t bws = vaddq_s16(yws, cb1);
; 3780 : 
; 3781 :          // undo scaling, round, convert to byte
; 3782 :          uint8x8x4_t o;
; 3783 :          o.val[0] = vqrshrun_n_s16(rws, 4);
; 3784 :          o.val[1] = vqrshrun_n_s16(gws, 4);
; 3785 :          o.val[2] = vqrshrun_n_s16(bws, 4);
; 3786 :          o.val[3] = vdup_n_u8(255);
; 3787 : 
; 3788 :          // store, interleaving r/g/b/a
; 3789 :          vst4_u8(out, o);
; 3790 :          out += 8*4;
; 3791 :       }
; 3792 :    }
; 3793 : #endif
; 3794 : 
; 3795 :    for (; i < count; ++i) {
; 3796 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding
; 3797 :       int r,g,b;
; 3798 :       int cr = pcr[i] - 128;
; 3799 :       int cb = pcb[i] - 128;
; 3800 :       r = y_fixed + cr* stbi__float2fixed(1.40200f);
; 3801 :       g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
; 3802 :       b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
; 3803 :       r >>= 20;
; 3804 :       g >>= 20;
; 3805 :       b >>= 20;
; 3806 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
; 3807 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
; 3808 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
; 3809 :       out[0] = (stbi_uc)r;
; 3810 :       out[1] = (stbi_uc)g;
; 3811 :       out[2] = (stbi_uc)b;
; 3812 :       out[3] = 255;
; 3813 :       out += step;
; 3814 :    }
; 3815 : }
; 3816 : #endif
; 3817 : 
; 3818 : // set up the kernels
; 3819 : static void stbi__setup_jpeg(stbi__jpeg *j)
; 3820 : {
; 3821 :    j->idct_block_kernel = stbi__idct_block;
; 3822 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
; 3823 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;
; 3824 : 
; 3825 : #ifdef STBI_SSE2
; 3826 :    if (stbi__sse2_available()) {
; 3827 :       j->idct_block_kernel = stbi__idct_simd;
; 3828 :       j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3829 :       j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3830 :    }
; 3831 : #endif
; 3832 : 
; 3833 : #ifdef STBI_NEON
; 3834 :    j->idct_block_kernel = stbi__idct_simd;
; 3835 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3836 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3837 : #endif
; 3838 : }
; 3839 : 
; 3840 : // clean up the temporary component buffers
; 3841 : static void stbi__cleanup_jpeg(stbi__jpeg *j)
; 3842 : {
; 3843 :    stbi__free_jpeg_components(j, j->s->img_n, 0);
; 3844 : }
; 3845 : 
; 3846 : typedef struct
; 3847 : {
; 3848 :    resample_row_func resample;
; 3849 :    stbi_uc *line0,*line1;
; 3850 :    int hs,vs;   // expansion factor in each axis
; 3851 :    int w_lores; // horizontal pixels pre-expansion
; 3852 :    int ystep;   // how far through vertical expansion we are
; 3853 :    int ypos;    // which pre-expansion row we're on
; 3854 : } stbi__resample;
; 3855 : 
; 3856 : // fast 0..255 * 0..255 => 0..255 rounded multiplication
; 3857 : static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
; 3858 : {
; 3859 :    unsigned int t = x*y + 128;
; 3860 :    return (stbi_uc) ((t + (t >>8)) >> 8);
; 3861 : }
; 3862 : 
; 3863 : static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
; 3864 : {
; 3865 :    int n, decode_n, is_rgb;
; 3866 :    z->s->img_n = 0; // make stbi__cleanup_jpeg safe
; 3867 : 
; 3868 :    // validate req_comp
; 3869 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
; 3870 : 
; 3871 :    // load a jpeg image from whichever source, but leave in YCbCr format
; 3872 :    if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }
; 3873 : 
; 3874 :    // determine actual number of components to generate
; 3875 :    n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;
; 3876 : 
; 3877 :    is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));
; 3878 : 
; 3879 :    if (z->s->img_n == 3 && n < 3 && !is_rgb)
; 3880 :       decode_n = 1;
; 3881 :    else
; 3882 :       decode_n = z->s->img_n;
; 3883 : 
; 3884 :    // nothing to do if no components requested; check this now to avoid
; 3885 :    // accessing uninitialized coutput[0] later
; 3886 :    if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }
; 3887 : 
; 3888 :    // resample and color-convert
; 3889 :    {
; 3890 :       int k;
; 3891 :       unsigned int i,j;
; 3892 :       stbi_uc *output;
; 3893 :       stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };
; 3894 : 
; 3895 :       stbi__resample res_comp[4];
; 3896 : 
; 3897 :       for (k=0; k < decode_n; ++k) {
; 3898 :          stbi__resample *r = &res_comp[k];
; 3899 : 
; 3900 :          // allocate line buffer big enough for upsampling off the edges
; 3901 :          // with upsample factor of 4
; 3902 :          z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
; 3903 :          if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
; 3904 : 
; 3905 :          r->hs      = z->img_h_max / z->img_comp[k].h;
; 3906 :          r->vs      = z->img_v_max / z->img_comp[k].v;
; 3907 :          r->ystep   = r->vs >> 1;
; 3908 :          r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
; 3909 :          r->ypos    = 0;
; 3910 :          r->line0   = r->line1 = z->img_comp[k].data;
; 3911 : 
; 3912 :          if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
; 3913 :          else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
; 3914 :          else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
; 3915 :          else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
; 3916 :          else                               r->resample = stbi__resample_row_generic;
; 3917 :       }
; 3918 : 
; 3919 :       // can't error after this so, this is safe
; 3920 :       output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
; 3921 :       if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
; 3922 : 
; 3923 :       // now go ahead and resample
; 3924 :       for (j=0; j < z->s->img_y; ++j) {
; 3925 :          stbi_uc *out = output + n * z->s->img_x * j;
; 3926 :          for (k=0; k < decode_n; ++k) {
; 3927 :             stbi__resample *r = &res_comp[k];
; 3928 :             int y_bot = r->ystep >= (r->vs >> 1);
; 3929 :             coutput[k] = r->resample(z->img_comp[k].linebuf,
; 3930 :                                      y_bot ? r->line1 : r->line0,
; 3931 :                                      y_bot ? r->line0 : r->line1,
; 3932 :                                      r->w_lores, r->hs);
; 3933 :             if (++r->ystep >= r->vs) {
; 3934 :                r->ystep = 0;
; 3935 :                r->line0 = r->line1;
; 3936 :                if (++r->ypos < z->img_comp[k].y)
; 3937 :                   r->line1 += z->img_comp[k].w2;
; 3938 :             }
; 3939 :          }
; 3940 :          if (n >= 3) {
; 3941 :             stbi_uc *y = coutput[0];
; 3942 :             if (z->s->img_n == 3) {
; 3943 :                if (is_rgb) {
; 3944 :                   for (i=0; i < z->s->img_x; ++i) {
; 3945 :                      out[0] = y[i];
; 3946 :                      out[1] = coutput[1][i];
; 3947 :                      out[2] = coutput[2][i];
; 3948 :                      out[3] = 255;
; 3949 :                      out += n;
; 3950 :                   }
; 3951 :                } else {
; 3952 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3953 :                }
; 3954 :             } else if (z->s->img_n == 4) {
; 3955 :                if (z->app14_color_transform == 0) { // CMYK
; 3956 :                   for (i=0; i < z->s->img_x; ++i) {
; 3957 :                      stbi_uc m = coutput[3][i];
; 3958 :                      out[0] = stbi__blinn_8x8(coutput[0][i], m);
; 3959 :                      out[1] = stbi__blinn_8x8(coutput[1][i], m);
; 3960 :                      out[2] = stbi__blinn_8x8(coutput[2][i], m);
; 3961 :                      out[3] = 255;
; 3962 :                      out += n;
; 3963 :                   }
; 3964 :                } else if (z->app14_color_transform == 2) { // YCCK
; 3965 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3966 :                   for (i=0; i < z->s->img_x; ++i) {
; 3967 :                      stbi_uc m = coutput[3][i];
; 3968 :                      out[0] = stbi__blinn_8x8(255 - out[0], m);
; 3969 :                      out[1] = stbi__blinn_8x8(255 - out[1], m);
; 3970 :                      out[2] = stbi__blinn_8x8(255 - out[2], m);
; 3971 :                      out += n;
; 3972 :                   }
; 3973 :                } else { // YCbCr + alpha?  Ignore the fourth channel for now
; 3974 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3975 :                }
; 3976 :             } else
; 3977 :                for (i=0; i < z->s->img_x; ++i) {
; 3978 :                   out[0] = out[1] = out[2] = y[i];
; 3979 :                   out[3] = 255; // not used if n==3
; 3980 :                   out += n;
; 3981 :                }
; 3982 :          } else {
; 3983 :             if (is_rgb) {
; 3984 :                if (n == 1)
; 3985 :                   for (i=0; i < z->s->img_x; ++i)
; 3986 :                      *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
; 3987 :                else {
; 3988 :                   for (i=0; i < z->s->img_x; ++i, out += 2) {
; 3989 :                      out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
; 3990 :                      out[1] = 255;
; 3991 :                   }
; 3992 :                }
; 3993 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
; 3994 :                for (i=0; i < z->s->img_x; ++i) {
; 3995 :                   stbi_uc m = coutput[3][i];
; 3996 :                   stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
; 3997 :                   stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
; 3998 :                   stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
; 3999 :                   out[0] = stbi__compute_y(r, g, b);
; 4000 :                   out[1] = 255;
; 4001 :                   out += n;
; 4002 :                }
; 4003 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
; 4004 :                for (i=0; i < z->s->img_x; ++i) {
; 4005 :                   out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
; 4006 :                   out[1] = 255;
; 4007 :                   out += n;
; 4008 :                }
; 4009 :             } else {
; 4010 :                stbi_uc *y = coutput[0];
; 4011 :                if (n == 1)
; 4012 :                   for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
; 4013 :                else
; 4014 :                   for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
; 4015 :             }
; 4016 :          }
; 4017 :       }
; 4018 :       stbi__cleanup_jpeg(z);
; 4019 :       *out_x = z->s->img_x;
; 4020 :       *out_y = z->s->img_y;
; 4021 :       if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
; 4022 :       return output;
; 4023 :    }
; 4024 : }
; 4025 : 
; 4026 : static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 4027 : {
; 4028 :    unsigned char* result;
; 4029 :    stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
; 4030 :    if (!j) return stbi__errpuc("outofmem", "Out of memory");
; 4031 :    memset(j, 0, sizeof(stbi__jpeg));
; 4032 :    STBI_NOTUSED(ri);
; 4033 :    j->s = s;
; 4034 :    stbi__setup_jpeg(j);
; 4035 :    result = load_jpeg_image(j, x,y,comp,req_comp);
; 4036 :    STBI_FREE(j);
; 4037 :    return result;
; 4038 : }
; 4039 : 
; 4040 : static int stbi__jpeg_test(stbi__context *s)
; 4041 : {
; 4042 :    int r;
; 4043 :    stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
; 4044 :    if (!j) return stbi__err("outofmem", "Out of memory");
; 4045 :    memset(j, 0, sizeof(stbi__jpeg));
; 4046 :    j->s = s;
; 4047 :    stbi__setup_jpeg(j);
; 4048 :    r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
; 4049 :    stbi__rewind(s);
; 4050 :    STBI_FREE(j);
; 4051 :    return r;
; 4052 : }
; 4053 : 
; 4054 : static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
; 4055 : {
; 4056 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
; 4057 :       stbi__rewind( j->s );
; 4058 :       return 0;
; 4059 :    }
; 4060 :    if (x) *x = j->s->img_x;
; 4061 :    if (y) *y = j->s->img_y;
; 4062 :    if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
; 4063 :    return 1;
; 4064 : }
; 4065 : 
; 4066 : static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
; 4067 : {
; 4068 :    int result;
; 4069 :    stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
; 4070 :    if (!j) return stbi__err("outofmem", "Out of memory");
; 4071 :    memset(j, 0, sizeof(stbi__jpeg));
; 4072 :    j->s = s;
; 4073 :    result = stbi__jpeg_info_raw(j, x, y, comp);
; 4074 :    STBI_FREE(j);
; 4075 :    return result;
; 4076 : }
; 4077 : #endif
; 4078 : 
; 4079 : // public domain zlib decode    v0.2  Sean Barrett 2006-11-18
; 4080 : //    simple implementation
; 4081 : //      - all input must be provided in an upfront buffer
; 4082 : //      - all output is written to a single output buffer (can malloc/realloc)
; 4083 : //    performance
; 4084 : //      - fast huffman
; 4085 : 
; 4086 : #ifndef STBI_NO_ZLIB
; 4087 : 
; 4088 : // fast-way is faster to check than jpeg huffman, but slow way is slower
; 4089 : #define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
; 4090 : #define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
; 4091 : #define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet
; 4092 : 
; 4093 : // zlib-style huffman encoding
; 4094 : // (jpegs packs from left, zlib from right, so can't share code)
; 4095 : typedef struct
; 4096 : {
; 4097 :    stbi__uint16 fast[1 << STBI__ZFAST_BITS];
; 4098 :    stbi__uint16 firstcode[16];
; 4099 :    int maxcode[17];
; 4100 :    stbi__uint16 firstsymbol[16];
; 4101 :    stbi_uc  size[STBI__ZNSYMS];
; 4102 :    stbi__uint16 value[STBI__ZNSYMS];
; 4103 : } stbi__zhuffman;
; 4104 : 
; 4105 : stbi_inline static int stbi__bitreverse16(int n)
; 4106 : {
; 4107 :   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
; 4108 :   n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
; 4109 :   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
; 4110 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
; 4111 :   return n;
; 4112 : }
; 4113 : 
; 4114 : stbi_inline static int stbi__bit_reverse(int v, int bits)
; 4115 : {
; 4116 :    STBI_ASSERT(bits <= 16);
; 4117 :    // to bit reverse n bits, reverse 16 and shift
; 4118 :    // e.g. 11 bits, bit reverse and shift away 5
; 4119 :    return stbi__bitreverse16(v) >> (16-bits);
; 4120 : }
; 4121 : 
; 4122 : static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
; 4123 : {
; 4124 :    int i,k=0;
; 4125 :    int code, next_code[16], sizes[17];
; 4126 : 
; 4127 :    // DEFLATE spec for generating codes
; 4128 :    memset(sizes, 0, sizeof(sizes));
; 4129 :    memset(z->fast, 0, sizeof(z->fast));
; 4130 :    for (i=0; i < num; ++i)
; 4131 :       ++sizes[sizelist[i]];
; 4132 :    sizes[0] = 0;
; 4133 :    for (i=1; i < 16; ++i)
; 4134 :       if (sizes[i] > (1 << i))
; 4135 :          return stbi__err("bad sizes", "Corrupt PNG");
; 4136 :    code = 0;
; 4137 :    for (i=1; i < 16; ++i) {
; 4138 :       next_code[i] = code;
; 4139 :       z->firstcode[i] = (stbi__uint16) code;
; 4140 :       z->firstsymbol[i] = (stbi__uint16) k;
; 4141 :       code = (code + sizes[i]);
; 4142 :       if (sizes[i])
; 4143 :          if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
; 4144 :       z->maxcode[i] = code << (16-i); // preshift for inner loop
; 4145 :       code <<= 1;
; 4146 :       k += sizes[i];
; 4147 :    }
; 4148 :    z->maxcode[16] = 0x10000; // sentinel
; 4149 :    for (i=0; i < num; ++i) {
; 4150 :       int s = sizelist[i];
; 4151 :       if (s) {
; 4152 :          int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
; 4153 :          stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
; 4154 :          z->size [c] = (stbi_uc     ) s;
; 4155 :          z->value[c] = (stbi__uint16) i;
; 4156 :          if (s <= STBI__ZFAST_BITS) {
; 4157 :             int j = stbi__bit_reverse(next_code[s],s);
; 4158 :             while (j < (1 << STBI__ZFAST_BITS)) {
; 4159 :                z->fast[j] = fastv;
; 4160 :                j += (1 << s);
; 4161 :             }
; 4162 :          }
; 4163 :          ++next_code[s];
; 4164 :       }
; 4165 :    }
; 4166 :    return 1;
; 4167 : }
; 4168 : 
; 4169 : // zlib-from-memory implementation for PNG reading
; 4170 : //    because PNG allows splitting the zlib stream arbitrarily,
; 4171 : //    and it's annoying structurally to have PNG call ZLIB call PNG,
; 4172 : //    we require PNG read all the IDATs and combine them into a single
; 4173 : //    memory buffer
; 4174 : 
; 4175 : typedef struct
; 4176 : {
; 4177 :    stbi_uc *zbuffer, *zbuffer_end;
; 4178 :    int num_bits;
; 4179 :    stbi__uint32 code_buffer;
; 4180 : 
; 4181 :    char *zout;
; 4182 :    char *zout_start;
; 4183 :    char *zout_end;
; 4184 :    int   z_expandable;
; 4185 : 
; 4186 :    stbi__zhuffman z_length, z_distance;
; 4187 : } stbi__zbuf;
; 4188 : 
; 4189 : stbi_inline static int stbi__zeof(stbi__zbuf *z)
; 4190 : {
; 4191 :    return (z->zbuffer >= z->zbuffer_end);
; 4192 : }
; 4193 : 
; 4194 : stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
; 4195 : {
; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;
; 4197 : }
; 4198 : 
; 4199 : static void stbi__fill_bits(stbi__zbuf *z)
; 4200 : {
; 4201 :    do {
; 4202 :       if (z->code_buffer >= (1U << z->num_bits)) {
; 4203 :         z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
; 4204 :         return;
; 4205 :       }
; 4206 :       z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
; 4207 :       z->num_bits += 8;
; 4208 :    } while (z->num_bits <= 24);
; 4209 : }
; 4210 : 
; 4211 : stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
; 4212 : {
; 4213 :    unsigned int k;
; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);
; 4215 :    k = z->code_buffer & ((1 << n) - 1);
; 4216 :    z->code_buffer >>= n;
; 4217 :    z->num_bits -= n;
; 4218 :    return k;
; 4219 : }
; 4220 : 
; 4221 : static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
; 4222 : {
; 4223 :    int b,s,k;
; 4224 :    // not resolved by fast table, so compute it the slow way
; 4225 :    // use jpeg approach, which requires MSbits at top
; 4226 :    k = stbi__bit_reverse(a->code_buffer, 16);
; 4227 :    for (s=STBI__ZFAST_BITS+1; ; ++s)
; 4228 :       if (k < z->maxcode[s])
; 4229 :          break;
; 4230 :    if (s >= 16) return -1; // invalid code!
; 4231 :    // code size is s, so:
; 4232 :    b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
; 4233 :    if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
; 4234 :    if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
; 4235 :    a->code_buffer >>= s;
; 4236 :    a->num_bits -= s;
; 4237 :    return z->value[b];
; 4238 : }
; 4239 : 
; 4240 : stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
; 4241 : {
; 4242 :    int b,s;
; 4243 :    if (a->num_bits < 16) {
; 4244 :       if (stbi__zeof(a)) {
; 4245 :          return -1;   /* report error for unexpected end of data. */
; 4246 :       }
; 4247 :       stbi__fill_bits(a);
; 4248 :    }
; 4249 :    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
; 4250 :    if (b) {
; 4251 :       s = b >> 9;
; 4252 :       a->code_buffer >>= s;
; 4253 :       a->num_bits -= s;
; 4254 :       return b & 511;
; 4255 :    }
; 4256 :    return stbi__zhuffman_decode_slowpath(a, z);
; 4257 : }
; 4258 : 
; 4259 : static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
; 4260 : {
; 4261 :    char *q;
; 4262 :    unsigned int cur, limit, old_limit;
; 4263 :    z->zout = zout;
; 4264 :    if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
; 4265 :    cur   = (unsigned int) (z->zout - z->zout_start);
; 4266 :    limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
; 4267 :    if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");
; 4268 :    while (cur + n > limit) {
; 4269 :       if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");
; 4270 :       limit *= 2;
; 4271 :    }
; 4272 :    q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
; 4273 :    STBI_NOTUSED(old_limit);
; 4274 :    if (q == NULL) return stbi__err("outofmem", "Out of memory");
; 4275 :    z->zout_start = q;
; 4276 :    z->zout       = q + cur;
; 4277 :    z->zout_end   = q + limit;
; 4278 :    return 1;
; 4279 : }
; 4280 : 
; 4281 : static const int stbi__zlength_base[31] = {
; 4282 :    3,4,5,6,7,8,9,10,11,13,
; 4283 :    15,17,19,23,27,31,35,43,51,59,
; 4284 :    67,83,99,115,131,163,195,227,258,0,0 };
; 4285 : 
; 4286 : static const int stbi__zlength_extra[31]=
; 4287 : { 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };
; 4288 : 
; 4289 : static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
; 4290 : 257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};
; 4291 : 
; 4292 : static const int stbi__zdist_extra[32] =
; 4293 : { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
; 4294 : 
; 4295 : static int stbi__parse_huffman_block(stbi__zbuf *a)
; 4296 : {
; 4297 :    char *zout = a->zout;
; 4298 :    for(;;) {
; 4299 :       int z = stbi__zhuffman_decode(a, &a->z_length);
; 4300 :       if (z < 256) {
; 4301 :          if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
; 4302 :          if (zout >= a->zout_end) {
; 4303 :             if (!stbi__zexpand(a, zout, 1)) return 0;
; 4304 :             zout = a->zout;
; 4305 :          }
; 4306 :          *zout++ = (char) z;
; 4307 :       } else {
; 4308 :          stbi_uc *p;
; 4309 :          int len,dist;
; 4310 :          if (z == 256) {
; 4311 :             a->zout = zout;
; 4312 :             return 1;
; 4313 :          }
; 4314 :          if (z >= 286) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, length codes 286 and 287 must not appear in compressed data
; 4315 :          z -= 257;
; 4316 :          len = stbi__zlength_base[z];
; 4317 :          if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
; 4318 :          z = stbi__zhuffman_decode(a, &a->z_distance);
; 4319 :          if (z < 0 || z >= 30) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data
; 4320 :          dist = stbi__zdist_base[z];
; 4321 :          if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
; 4322 :          if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
; 4323 :          if (zout + len > a->zout_end) {
; 4324 :             if (!stbi__zexpand(a, zout, len)) return 0;
; 4325 :             zout = a->zout;
; 4326 :          }
; 4327 :          p = (stbi_uc *) (zout - dist);
; 4328 :          if (dist == 1) { // run of one byte; common in images.
; 4329 :             stbi_uc v = *p;
; 4330 :             if (len) { do *zout++ = v; while (--len); }
; 4331 :          } else {
; 4332 :             if (len) { do *zout++ = *p++; while (--len); }
; 4333 :          }
; 4334 :       }
; 4335 :    }
; 4336 : }
; 4337 : 
; 4338 : static int stbi__compute_huffman_codes(stbi__zbuf *a)
; 4339 : {
; 4340 :    static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
; 4341 :    stbi__zhuffman z_codelength;
; 4342 :    stbi_uc lencodes[286+32+137];//padding for maximum single op
; 4343 :    stbi_uc codelength_sizes[19];
; 4344 :    int i,n;
; 4345 : 
; 4346 :    int hlit  = stbi__zreceive(a,5) + 257;
; 4347 :    int hdist = stbi__zreceive(a,5) + 1;
; 4348 :    int hclen = stbi__zreceive(a,4) + 4;
; 4349 :    int ntot  = hlit + hdist;
; 4350 : 
; 4351 :    memset(codelength_sizes, 0, sizeof(codelength_sizes));
; 4352 :    for (i=0; i < hclen; ++i) {
; 4353 :       int s = stbi__zreceive(a,3);
; 4354 :       codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
; 4355 :    }
; 4356 :    if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;
; 4357 : 
; 4358 :    n = 0;
; 4359 :    while (n < ntot) {
; 4360 :       int c = stbi__zhuffman_decode(a, &z_codelength);
; 4361 :       if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
; 4362 :       if (c < 16)
; 4363 :          lencodes[n++] = (stbi_uc) c;
; 4364 :       else {
; 4365 :          stbi_uc fill = 0;
; 4366 :          if (c == 16) {
; 4367 :             c = stbi__zreceive(a,2)+3;
; 4368 :             if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
; 4369 :             fill = lencodes[n-1];
; 4370 :          } else if (c == 17) {
; 4371 :             c = stbi__zreceive(a,3)+3;
; 4372 :          } else if (c == 18) {
; 4373 :             c = stbi__zreceive(a,7)+11;
; 4374 :          } else {
; 4375 :             return stbi__err("bad codelengths", "Corrupt PNG");
; 4376 :          }
; 4377 :          if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
; 4378 :          memset(lencodes+n, fill, c);
; 4379 :          n += c;
; 4380 :       }
; 4381 :    }
; 4382 :    if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");
; 4383 :    if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
; 4384 :    if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
; 4385 :    return 1;
; 4386 : }
; 4387 : 
; 4388 : static int stbi__parse_uncompressed_block(stbi__zbuf *a)
; 4389 : {
; 4390 :    stbi_uc header[4];
; 4391 :    int len,nlen,k;
; 4392 :    if (a->num_bits & 7)
; 4393 :       stbi__zreceive(a, a->num_bits & 7); // discard
; 4394 :    // drain the bit-packed data into header
; 4395 :    k = 0;
; 4396 :    while (a->num_bits > 0) {
; 4397 :       header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
; 4398 :       a->code_buffer >>= 8;
; 4399 :       a->num_bits -= 8;
; 4400 :    }
; 4401 :    if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");
; 4402 :    // now fill header the normal way
; 4403 :    while (k < 4)
; 4404 :       header[k++] = stbi__zget8(a);
; 4405 :    len  = header[1] * 256 + header[0];
; 4406 :    nlen = header[3] * 256 + header[2];
; 4407 :    if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
; 4408 :    if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
; 4409 :    if (a->zout + len > a->zout_end)
; 4410 :       if (!stbi__zexpand(a, a->zout, len)) return 0;
; 4411 :    memcpy(a->zout, a->zbuffer, len);
; 4412 :    a->zbuffer += len;
; 4413 :    a->zout += len;
; 4414 :    return 1;
; 4415 : }
; 4416 : 
; 4417 : static int stbi__parse_zlib_header(stbi__zbuf *a)
; 4418 : {
; 4419 :    int cmf   = stbi__zget8(a);
; 4420 :    int cm    = cmf & 15;
; 4421 :    /* int cinfo = cmf >> 4; */
; 4422 :    int flg   = stbi__zget8(a);
; 4423 :    if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
; 4424 :    if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
; 4425 :    if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
; 4426 :    if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
; 4427 :    // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
; 4428 :    return 1;
; 4429 : }
; 4430 : 
; 4431 : static const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =
; 4432 : {
; 4433 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4434 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4435 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4436 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4437 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4438 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4439 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4440 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4441 :    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
; 4442 : };
; 4443 : static const stbi_uc stbi__zdefault_distance[32] =
; 4444 : {
; 4445 :    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
; 4446 : };
; 4447 : /*
; 4448 : Init algorithm:
; 4449 : {
; 4450 :    int i;   // use <= to match clearly with spec
; 4451 :    for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
; 4452 :    for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
; 4453 :    for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
; 4454 :    for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;
; 4455 : 
; 4456 :    for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
; 4457 : }
; 4458 : */
; 4459 : 
; 4460 : static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
; 4461 : {
; 4462 :    int final, type;
; 4463 :    if (parse_header)
; 4464 :       if (!stbi__parse_zlib_header(a)) return 0;
; 4465 :    a->num_bits = 0;
; 4466 :    a->code_buffer = 0;
; 4467 :    do {
; 4468 :       final = stbi__zreceive(a,1);
; 4469 :       type = stbi__zreceive(a,2);
; 4470 :       if (type == 0) {
; 4471 :          if (!stbi__parse_uncompressed_block(a)) return 0;
; 4472 :       } else if (type == 3) {
; 4473 :          return 0;
; 4474 :       } else {
; 4475 :          if (type == 1) {
; 4476 :             // use fixed code lengths
; 4477 :             if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
; 4478 :             if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
; 4479 :          } else {
; 4480 :             if (!stbi__compute_huffman_codes(a)) return 0;
; 4481 :          }
; 4482 :          if (!stbi__parse_huffman_block(a)) return 0;
; 4483 :       }
; 4484 :    } while (!final);
; 4485 :    return 1;
; 4486 : }
; 4487 : 
; 4488 : static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
; 4489 : {
; 4490 :    a->zout_start = obuf;
; 4491 :    a->zout       = obuf;
; 4492 :    a->zout_end   = obuf + olen;
; 4493 :    a->z_expandable = exp;
; 4494 : 
; 4495 :    return stbi__parse_zlib(a, parse_header);
; 4496 : }
; 4497 : 
; 4498 : STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
; 4499 : {
; 4500 :    stbi__zbuf a;
; 4501 :    char *p = (char *) stbi__malloc(initial_size);
; 4502 :    if (p == NULL) return NULL;
; 4503 :    a.zbuffer = (stbi_uc *) buffer;
; 4504 :    a.zbuffer_end = (stbi_uc *) buffer + len;
; 4505 :    if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
; 4506 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4507 :       return a.zout_start;
; 4508 :    } else {
; 4509 :       STBI_FREE(a.zout_start);
; 4510 :       return NULL;
; 4511 :    }
; 4512 : }
; 4513 : 
; 4514 : STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
; 4515 : {
; 4516 :    return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
; 4517 : }
; 4518 : 
; 4519 : STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
; 4520 : {
; 4521 :    stbi__zbuf a;
; 4522 :    char *p = (char *) stbi__malloc(initial_size);
; 4523 :    if (p == NULL) return NULL;
; 4524 :    a.zbuffer = (stbi_uc *) buffer;
; 4525 :    a.zbuffer_end = (stbi_uc *) buffer + len;
; 4526 :    if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
; 4527 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4528 :       return a.zout_start;
; 4529 :    } else {
; 4530 :       STBI_FREE(a.zout_start);
; 4531 :       return NULL;
; 4532 :    }
; 4533 : }
; 4534 : 
; 4535 : STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
; 4536 : {
; 4537 :    stbi__zbuf a;
; 4538 :    a.zbuffer = (stbi_uc *) ibuffer;
; 4539 :    a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
; 4540 :    if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
; 4541 :       return (int) (a.zout - a.zout_start);
; 4542 :    else
; 4543 :       return -1;
; 4544 : }
; 4545 : 
; 4546 : STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
; 4547 : {
; 4548 :    stbi__zbuf a;
; 4549 :    char *p = (char *) stbi__malloc(16384);
; 4550 :    if (p == NULL) return NULL;
; 4551 :    a.zbuffer = (stbi_uc *) buffer;
; 4552 :    a.zbuffer_end = (stbi_uc *) buffer+len;
; 4553 :    if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
; 4554 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4555 :       return a.zout_start;
; 4556 :    } else {
; 4557 :       STBI_FREE(a.zout_start);
; 4558 :       return NULL;
; 4559 :    }
; 4560 : }
; 4561 : 
; 4562 : STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
; 4563 : {
; 4564 :    stbi__zbuf a;
; 4565 :    a.zbuffer = (stbi_uc *) ibuffer;
; 4566 :    a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
; 4567 :    if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
; 4568 :       return (int) (a.zout - a.zout_start);
; 4569 :    else
; 4570 :       return -1;
; 4571 : }
; 4572 : #endif
; 4573 : 
; 4574 : // public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
; 4575 : //    simple implementation
; 4576 : //      - only 8-bit samples
; 4577 : //      - no CRC checking
; 4578 : //      - allocates lots of intermediate memory
; 4579 : //        - avoids problem of streaming data between subsystems
; 4580 : //        - avoids explicit window management
; 4581 : //    performance
; 4582 : //      - uses stb_zlib, a PD zlib implementation with fast huffman decoding
; 4583 : 
; 4584 : #ifndef STBI_NO_PNG
; 4585 : typedef struct
; 4586 : {
; 4587 :    stbi__uint32 length;
; 4588 :    stbi__uint32 type;
; 4589 : } stbi__pngchunk;
; 4590 : 
; 4591 : static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
; 4592 : {
; 4593 :    stbi__pngchunk c;
; 4594 :    c.length = stbi__get32be(s);
; 4595 :    c.type   = stbi__get32be(s);
; 4596 :    return c;
; 4597 : }
; 4598 : 
; 4599 : static int stbi__check_png_header(stbi__context *s)
; 4600 : {
; 4601 :    static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
; 4602 :    int i;
; 4603 :    for (i=0; i < 8; ++i)
; 4604 :       if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
; 4605 :    return 1;
; 4606 : }
; 4607 : 
; 4608 : typedef struct
; 4609 : {
; 4610 :    stbi__context *s;
; 4611 :    stbi_uc *idata, *expanded, *out;
; 4612 :    int depth;
; 4613 : } stbi__png;
; 4614 : 
; 4615 : 
; 4616 : enum {
; 4617 :    STBI__F_none=0,
; 4618 :    STBI__F_sub=1,
; 4619 :    STBI__F_up=2,
; 4620 :    STBI__F_avg=3,
; 4621 :    STBI__F_paeth=4,
; 4622 :    // synthetic filters used for first scanline to avoid needing a dummy row of 0s
; 4623 :    STBI__F_avg_first,
; 4624 :    STBI__F_paeth_first
; 4625 : };
; 4626 : 
; 4627 : static stbi_uc first_row_filter[5] =
; 4628 : {
; 4629 :    STBI__F_none,
; 4630 :    STBI__F_sub,
; 4631 :    STBI__F_none,
; 4632 :    STBI__F_avg_first,
; 4633 :    STBI__F_paeth_first
; 4634 : };
; 4635 : 
; 4636 : static int stbi__paeth(int a, int b, int c)
; 4637 : {
; 4638 :    int p = a + b - c;
; 4639 :    int pa = abs(p-a);
; 4640 :    int pb = abs(p-b);
; 4641 :    int pc = abs(p-c);
; 4642 :    if (pa <= pb && pa <= pc) return a;
; 4643 :    if (pb <= pc) return b;
; 4644 :    return c;
; 4645 : }
; 4646 : 
; 4647 : static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };
; 4648 : 
; 4649 : // create the png data from post-deflated data
; 4650 : static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
; 4651 : {
; 4652 :    int bytes = (depth == 16? 2 : 1);
; 4653 :    stbi__context *s = a->s;
; 4654 :    stbi__uint32 i,j,stride = x*out_n*bytes;
; 4655 :    stbi__uint32 img_len, img_width_bytes;
; 4656 :    int k;
; 4657 :    int img_n = s->img_n; // copy it into a local for later
; 4658 : 
; 4659 :    int output_bytes = out_n*bytes;
; 4660 :    int filter_bytes = img_n*bytes;
; 4661 :    int width = x;
; 4662 : 
; 4663 :    STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
; 4664 :    a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
; 4665 :    if (!a->out) return stbi__err("outofmem", "Out of memory");
; 4666 : 
; 4667 :    if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
; 4668 :    img_width_bytes = (((img_n * x * depth) + 7) >> 3);
; 4669 :    img_len = (img_width_bytes + 1) * y;
; 4670 : 
; 4671 :    // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
; 4672 :    // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
; 4673 :    // so just check for raw_len < img_len always.
; 4674 :    if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");
; 4675 : 
; 4676 :    for (j=0; j < y; ++j) {
; 4677 :       stbi_uc *cur = a->out + stride*j;
; 4678 :       stbi_uc *prior;
; 4679 :       int filter = *raw++;
; 4680 : 
; 4681 :       if (filter > 4)
; 4682 :          return stbi__err("invalid filter","Corrupt PNG");
; 4683 : 
; 4684 :       if (depth < 8) {
; 4685 :          if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");
; 4686 :          cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
; 4687 :          filter_bytes = 1;
; 4688 :          width = img_width_bytes;
; 4689 :       }
; 4690 :       prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above
; 4691 : 
; 4692 :       // if first row, use special filter that doesn't sample previous row
; 4693 :       if (j == 0) filter = first_row_filter[filter];
; 4694 : 
; 4695 :       // handle first byte explicitly
; 4696 :       for (k=0; k < filter_bytes; ++k) {
; 4697 :          switch (filter) {
; 4698 :             case STBI__F_none       : cur[k] = raw[k]; break;
; 4699 :             case STBI__F_sub        : cur[k] = raw[k]; break;
; 4700 :             case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
; 4701 :             case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;
; 4702 :             case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;
; 4703 :             case STBI__F_avg_first  : cur[k] = raw[k]; break;
; 4704 :             case STBI__F_paeth_first: cur[k] = raw[k]; break;
; 4705 :          }
; 4706 :       }
; 4707 : 
; 4708 :       if (depth == 8) {
; 4709 :          if (img_n != out_n)
; 4710 :             cur[img_n] = 255; // first pixel
; 4711 :          raw += img_n;
; 4712 :          cur += out_n;
; 4713 :          prior += out_n;
; 4714 :       } else if (depth == 16) {
; 4715 :          if (img_n != out_n) {
; 4716 :             cur[filter_bytes]   = 255; // first pixel top byte
; 4717 :             cur[filter_bytes+1] = 255; // first pixel bottom byte
; 4718 :          }
; 4719 :          raw += filter_bytes;
; 4720 :          cur += output_bytes;
; 4721 :          prior += output_bytes;
; 4722 :       } else {
; 4723 :          raw += 1;
; 4724 :          cur += 1;
; 4725 :          prior += 1;
; 4726 :       }
; 4727 : 
; 4728 :       // this is a little gross, so that we don't switch per-pixel or per-component
; 4729 :       if (depth < 8 || img_n == out_n) {
; 4730 :          int nk = (width - 1)*filter_bytes;
; 4731 :          #define STBI__CASE(f) \
; 4732 :              case f:     \
; 4733 :                 for (k=0; k < nk; ++k)
; 4734 :          switch (filter) {
; 4735 :             // "none" filter turns into a memcpy here; make that explicit.
; 4736 :             case STBI__F_none:         memcpy(cur, raw, nk); break;
; 4737 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;
; 4738 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
; 4739 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;
; 4740 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;
; 4741 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;
; 4742 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;
; 4743 :          }
; 4744 :          #undef STBI__CASE
; 4745 :          raw += nk;
; 4746 :       } else {
; 4747 :          STBI_ASSERT(img_n+1 == out_n);
; 4748 :          #define STBI__CASE(f) \
; 4749 :              case f:     \
; 4750 :                 for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
; 4751 :                    for (k=0; k < filter_bytes; ++k)
; 4752 :          switch (filter) {
; 4753 :             STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;
; 4754 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;
; 4755 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
; 4756 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;
; 4757 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;
; 4758 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;
; 4759 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;
; 4760 :          }
; 4761 :          #undef STBI__CASE
; 4762 : 
; 4763 :          // the loop above sets the high byte of the pixels' alpha, but for
; 4764 :          // 16 bit png files we also need the low byte set. we'll do that here.
; 4765 :          if (depth == 16) {
; 4766 :             cur = a->out + stride*j; // start at the beginning of the row again
; 4767 :             for (i=0; i < x; ++i,cur+=output_bytes) {
; 4768 :                cur[filter_bytes+1] = 255;
; 4769 :             }
; 4770 :          }
; 4771 :       }
; 4772 :    }
; 4773 : 
; 4774 :    // we make a separate pass to expand bits to pixels; for performance,
; 4775 :    // this could run two scanlines behind the above code, so it won't
; 4776 :    // intefere with filtering but will still be in the cache.
; 4777 :    if (depth < 8) {
; 4778 :       for (j=0; j < y; ++j) {
; 4779 :          stbi_uc *cur = a->out + stride*j;
; 4780 :          stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
; 4781 :          // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
; 4782 :          // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
; 4783 :          stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range
; 4784 : 
; 4785 :          // note that the final byte might overshoot and write more data than desired.
; 4786 :          // we can allocate enough data that this never writes out of memory, but it
; 4787 :          // could also overwrite the next scanline. can it overwrite non-empty data
; 4788 :          // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
; 4789 :          // so we need to explicitly clamp the final ones
; 4790 : 
; 4791 :          if (depth == 4) {
; 4792 :             for (k=x*img_n; k >= 2; k-=2, ++in) {
; 4793 :                *cur++ = scale * ((*in >> 4)       );
; 4794 :                *cur++ = scale * ((*in     ) & 0x0f);
; 4795 :             }
; 4796 :             if (k > 0) *cur++ = scale * ((*in >> 4)       );
; 4797 :          } else if (depth == 2) {
; 4798 :             for (k=x*img_n; k >= 4; k-=4, ++in) {
; 4799 :                *cur++ = scale * ((*in >> 6)       );
; 4800 :                *cur++ = scale * ((*in >> 4) & 0x03);
; 4801 :                *cur++ = scale * ((*in >> 2) & 0x03);
; 4802 :                *cur++ = scale * ((*in     ) & 0x03);
; 4803 :             }
; 4804 :             if (k > 0) *cur++ = scale * ((*in >> 6)       );
; 4805 :             if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
; 4806 :             if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
; 4807 :          } else if (depth == 1) {
; 4808 :             for (k=x*img_n; k >= 8; k-=8, ++in) {
; 4809 :                *cur++ = scale * ((*in >> 7)       );
; 4810 :                *cur++ = scale * ((*in >> 6) & 0x01);
; 4811 :                *cur++ = scale * ((*in >> 5) & 0x01);
; 4812 :                *cur++ = scale * ((*in >> 4) & 0x01);
; 4813 :                *cur++ = scale * ((*in >> 3) & 0x01);
; 4814 :                *cur++ = scale * ((*in >> 2) & 0x01);
; 4815 :                *cur++ = scale * ((*in >> 1) & 0x01);
; 4816 :                *cur++ = scale * ((*in     ) & 0x01);
; 4817 :             }
; 4818 :             if (k > 0) *cur++ = scale * ((*in >> 7)       );
; 4819 :             if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
; 4820 :             if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
; 4821 :             if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
; 4822 :             if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
; 4823 :             if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
; 4824 :             if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
; 4825 :          }
; 4826 :          if (img_n != out_n) {
; 4827 :             int q;
; 4828 :             // insert alpha = 255
; 4829 :             cur = a->out + stride*j;
; 4830 :             if (img_n == 1) {
; 4831 :                for (q=x-1; q >= 0; --q) {
; 4832 :                   cur[q*2+1] = 255;
; 4833 :                   cur[q*2+0] = cur[q];
; 4834 :                }
; 4835 :             } else {
; 4836 :                STBI_ASSERT(img_n == 3);
; 4837 :                for (q=x-1; q >= 0; --q) {
; 4838 :                   cur[q*4+3] = 255;
; 4839 :                   cur[q*4+2] = cur[q*3+2];
; 4840 :                   cur[q*4+1] = cur[q*3+1];
; 4841 :                   cur[q*4+0] = cur[q*3+0];
; 4842 :                }
; 4843 :             }
; 4844 :          }
; 4845 :       }
; 4846 :    } else if (depth == 16) {
; 4847 :       // force the image data from big-endian to platform-native.
; 4848 :       // this is done in a separate pass due to the decoding relying
; 4849 :       // on the data being untouched, but could probably be done
; 4850 :       // per-line during decode if care is taken.
; 4851 :       stbi_uc *cur = a->out;
; 4852 :       stbi__uint16 *cur16 = (stbi__uint16*)cur;
; 4853 : 
; 4854 :       for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {
; 4855 :          *cur16 = (cur[0] << 8) | cur[1];
; 4856 :       }
; 4857 :    }
; 4858 : 
; 4859 :    return 1;
; 4860 : }
; 4861 : 
; 4862 : static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
; 4863 : {
; 4864 :    int bytes = (depth == 16 ? 2 : 1);
; 4865 :    int out_bytes = out_n * bytes;
; 4866 :    stbi_uc *final;
; 4867 :    int p;
; 4868 :    if (!interlaced)
; 4869 :       return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);
; 4870 : 
; 4871 :    // de-interlacing
; 4872 :    final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
; 4873 :    if (!final) return stbi__err("outofmem", "Out of memory");
; 4874 :    for (p=0; p < 7; ++p) {
; 4875 :       int xorig[] = { 0,4,0,2,0,1,0 };
; 4876 :       int yorig[] = { 0,0,4,0,2,0,1 };
; 4877 :       int xspc[]  = { 8,8,4,4,2,2,1 };
; 4878 :       int yspc[]  = { 8,8,8,4,4,2,2 };
; 4879 :       int i,j,x,y;
; 4880 :       // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
; 4881 :       x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
; 4882 :       y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
; 4883 :       if (x && y) {
; 4884 :          stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
; 4885 :          if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
; 4886 :             STBI_FREE(final);
; 4887 :             return 0;
; 4888 :          }
; 4889 :          for (j=0; j < y; ++j) {
; 4890 :             for (i=0; i < x; ++i) {
; 4891 :                int out_y = j*yspc[p]+yorig[p];
; 4892 :                int out_x = i*xspc[p]+xorig[p];
; 4893 :                memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
; 4894 :                       a->out + (j*x+i)*out_bytes, out_bytes);
; 4895 :             }
; 4896 :          }
; 4897 :          STBI_FREE(a->out);
; 4898 :          image_data += img_len;
; 4899 :          image_data_len -= img_len;
; 4900 :       }
; 4901 :    }
; 4902 :    a->out = final;
; 4903 : 
; 4904 :    return 1;
; 4905 : }
; 4906 : 
; 4907 : static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
; 4908 : {
; 4909 :    stbi__context *s = z->s;
; 4910 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 4911 :    stbi_uc *p = z->out;
; 4912 : 
; 4913 :    // compute color-based transparency, assuming we've
; 4914 :    // already got 255 as the alpha value in the output
; 4915 :    STBI_ASSERT(out_n == 2 || out_n == 4);
; 4916 : 
; 4917 :    if (out_n == 2) {
; 4918 :       for (i=0; i < pixel_count; ++i) {
; 4919 :          p[1] = (p[0] == tc[0] ? 0 : 255);
; 4920 :          p += 2;
; 4921 :       }
; 4922 :    } else {
; 4923 :       for (i=0; i < pixel_count; ++i) {
; 4924 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
; 4925 :             p[3] = 0;
; 4926 :          p += 4;
; 4927 :       }
; 4928 :    }
; 4929 :    return 1;
; 4930 : }
; 4931 : 
; 4932 : static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
; 4933 : {
; 4934 :    stbi__context *s = z->s;
; 4935 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 4936 :    stbi__uint16 *p = (stbi__uint16*) z->out;
; 4937 : 
; 4938 :    // compute color-based transparency, assuming we've
; 4939 :    // already got 65535 as the alpha value in the output
; 4940 :    STBI_ASSERT(out_n == 2 || out_n == 4);
; 4941 : 
; 4942 :    if (out_n == 2) {
; 4943 :       for (i = 0; i < pixel_count; ++i) {
; 4944 :          p[1] = (p[0] == tc[0] ? 0 : 65535);
; 4945 :          p += 2;
; 4946 :       }
; 4947 :    } else {
; 4948 :       for (i = 0; i < pixel_count; ++i) {
; 4949 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
; 4950 :             p[3] = 0;
; 4951 :          p += 4;
; 4952 :       }
; 4953 :    }
; 4954 :    return 1;
; 4955 : }
; 4956 : 
; 4957 : static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
; 4958 : {
; 4959 :    stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
; 4960 :    stbi_uc *p, *temp_out, *orig = a->out;
; 4961 : 
; 4962 :    p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
; 4963 :    if (p == NULL) return stbi__err("outofmem", "Out of memory");
; 4964 : 
; 4965 :    // between here and free(out) below, exitting would leak
; 4966 :    temp_out = p;
; 4967 : 
; 4968 :    if (pal_img_n == 3) {
; 4969 :       for (i=0; i < pixel_count; ++i) {
; 4970 :          int n = orig[i]*4;
; 4971 :          p[0] = palette[n  ];
; 4972 :          p[1] = palette[n+1];
; 4973 :          p[2] = palette[n+2];
; 4974 :          p += 3;
; 4975 :       }
; 4976 :    } else {
; 4977 :       for (i=0; i < pixel_count; ++i) {
; 4978 :          int n = orig[i]*4;
; 4979 :          p[0] = palette[n  ];
; 4980 :          p[1] = palette[n+1];
; 4981 :          p[2] = palette[n+2];
; 4982 :          p[3] = palette[n+3];
; 4983 :          p += 4;
; 4984 :       }
; 4985 :    }
; 4986 :    STBI_FREE(a->out);
; 4987 :    a->out = temp_out;
; 4988 : 
; 4989 :    STBI_NOTUSED(len);
; 4990 : 
; 4991 :    return 1;
; 4992 : }
; 4993 : 
; 4994 : static int stbi__unpremultiply_on_load_global = 0;
; 4995 : static int stbi__de_iphone_flag_global = 0;
; 4996 : 
; 4997 : STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
; 4998 : {
; 4999 :    stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
; 5000 : }
; 5001 : 
; 5002 : STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
; 5003 : {
; 5004 :    stbi__de_iphone_flag_global = flag_true_if_should_convert;
; 5005 : }
; 5006 : 
; 5007 : #ifndef STBI_THREAD_LOCAL
; 5008 : #define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global
; 5009 : #define stbi__de_iphone_flag  stbi__de_iphone_flag_global
; 5010 : #else
; 5011 : static STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;
; 5012 : static STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;
; 5013 : 
; 5014 : STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
; 5015 : {
; 5016 :    stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
; 5017 :    stbi__unpremultiply_on_load_set = 1;
; 5018 : }
; 5019 : 
; 5020 : STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
; 5021 : {
; 5022 :    stbi__de_iphone_flag_local = flag_true_if_should_convert;
; 5023 :    stbi__de_iphone_flag_set = 1;
; 5024 : }
; 5025 : 
; 5026 : #define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \
; 5027 :                                        ? stbi__unpremultiply_on_load_local      \
; 5028 :                                        : stbi__unpremultiply_on_load_global)
; 5029 : #define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \
; 5030 :                                 ? stbi__de_iphone_flag_local                    \
; 5031 :                                 : stbi__de_iphone_flag_global)
; 5032 : #endif // STBI_THREAD_LOCAL
; 5033 : 
; 5034 : static void stbi__de_iphone(stbi__png *z)
; 5035 : {
; 5036 :    stbi__context *s = z->s;
; 5037 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 5038 :    stbi_uc *p = z->out;
; 5039 : 
; 5040 :    if (s->img_out_n == 3) {  // convert bgr to rgb
; 5041 :       for (i=0; i < pixel_count; ++i) {
; 5042 :          stbi_uc t = p[0];
; 5043 :          p[0] = p[2];
; 5044 :          p[2] = t;
; 5045 :          p += 3;
; 5046 :       }
; 5047 :    } else {
; 5048 :       STBI_ASSERT(s->img_out_n == 4);
; 5049 :       if (stbi__unpremultiply_on_load) {
; 5050 :          // convert bgr to rgb and unpremultiply
; 5051 :          for (i=0; i < pixel_count; ++i) {
; 5052 :             stbi_uc a = p[3];
; 5053 :             stbi_uc t = p[0];
; 5054 :             if (a) {
; 5055 :                stbi_uc half = a / 2;
; 5056 :                p[0] = (p[2] * 255 + half) / a;
; 5057 :                p[1] = (p[1] * 255 + half) / a;
; 5058 :                p[2] = ( t   * 255 + half) / a;
; 5059 :             } else {
; 5060 :                p[0] = p[2];
; 5061 :                p[2] = t;
; 5062 :             }
; 5063 :             p += 4;
; 5064 :          }
; 5065 :       } else {
; 5066 :          // convert bgr to rgb
; 5067 :          for (i=0; i < pixel_count; ++i) {
; 5068 :             stbi_uc t = p[0];
; 5069 :             p[0] = p[2];
; 5070 :             p[2] = t;
; 5071 :             p += 4;
; 5072 :          }
; 5073 :       }
; 5074 :    }
; 5075 : }
; 5076 : 
; 5077 : #define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))
; 5078 : 
; 5079 : static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
; 5080 : {
; 5081 :    stbi_uc palette[1024], pal_img_n=0;
; 5082 :    stbi_uc has_trans=0, tc[3]={0};
; 5083 :    stbi__uint16 tc16[3];
; 5084 :    stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
; 5085 :    int first=1,k,interlace=0, color=0, is_iphone=0;
; 5086 :    stbi__context *s = z->s;
; 5087 : 
; 5088 :    z->expanded = NULL;
; 5089 :    z->idata = NULL;
; 5090 :    z->out = NULL;
; 5091 : 
; 5092 :    if (!stbi__check_png_header(s)) return 0;
; 5093 : 
; 5094 :    if (scan == STBI__SCAN_type) return 1;
; 5095 : 
; 5096 :    for (;;) {
; 5097 :       stbi__pngchunk c = stbi__get_chunk_header(s);
; 5098 :       switch (c.type) {
; 5099 :          case STBI__PNG_TYPE('C','g','B','I'):
; 5100 :             is_iphone = 1;
; 5101 :             stbi__skip(s, c.length);
; 5102 :             break;
; 5103 :          case STBI__PNG_TYPE('I','H','D','R'): {
; 5104 :             int comp,filter;
; 5105 :             if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
; 5106 :             first = 0;
; 5107 :             if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
; 5108 :             s->img_x = stbi__get32be(s);
; 5109 :             s->img_y = stbi__get32be(s);
; 5110 :             if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 5111 :             if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 5112 :             z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
; 5113 :             color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
; 5114 :             if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
; 5115 :             if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
; 5116 :             comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
; 5117 :             filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
; 5118 :             interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
; 5119 :             if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
; 5120 :             if (!pal_img_n) {
; 5121 :                s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
; 5122 :                if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
; 5123 :             } else {
; 5124 :                // if paletted, then pal_n is our final components, and
; 5125 :                // img_n is # components to decompress/filter.
; 5126 :                s->img_n = 1;
; 5127 :                if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
; 5128 :             }
; 5129 :             // even with SCAN_header, have to scan to see if we have a tRNS
; 5130 :             break;
; 5131 :          }
; 5132 : 
; 5133 :          case STBI__PNG_TYPE('P','L','T','E'):  {
; 5134 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5135 :             if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
; 5136 :             pal_len = c.length / 3;
; 5137 :             if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
; 5138 :             for (i=0; i < pal_len; ++i) {
; 5139 :                palette[i*4+0] = stbi__get8(s);
; 5140 :                palette[i*4+1] = stbi__get8(s);
; 5141 :                palette[i*4+2] = stbi__get8(s);
; 5142 :                palette[i*4+3] = 255;
; 5143 :             }
; 5144 :             break;
; 5145 :          }
; 5146 : 
; 5147 :          case STBI__PNG_TYPE('t','R','N','S'): {
; 5148 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5149 :             if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
; 5150 :             if (pal_img_n) {
; 5151 :                if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
; 5152 :                if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
; 5153 :                if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
; 5154 :                pal_img_n = 4;
; 5155 :                for (i=0; i < c.length; ++i)
; 5156 :                   palette[i*4+3] = stbi__get8(s);
; 5157 :             } else {
; 5158 :                if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
; 5159 :                if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
; 5160 :                has_trans = 1;
; 5161 :                // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.
; 5162 :                if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }
; 5163 :                if (z->depth == 16) {
; 5164 :                   for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
; 5165 :                } else {
; 5166 :                   for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
; 5167 :                }
; 5168 :             }
; 5169 :             break;
; 5170 :          }
; 5171 : 
; 5172 :          case STBI__PNG_TYPE('I','D','A','T'): {
; 5173 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5174 :             if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
; 5175 :             if (scan == STBI__SCAN_header) {
; 5176 :                // header scan definitely stops at first IDAT
; 5177 :                if (pal_img_n)
; 5178 :                   s->img_n = pal_img_n;
; 5179 :                return 1;
; 5180 :             }
; 5181 :             if (c.length > (1u << 30)) return stbi__err("IDAT size limit", "IDAT section larger than 2^30 bytes");
; 5182 :             if ((int)(ioff + c.length) < (int)ioff) return 0;
; 5183 :             if (ioff + c.length > idata_limit) {
; 5184 :                stbi__uint32 idata_limit_old = idata_limit;
; 5185 :                stbi_uc *p;
; 5186 :                if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
; 5187 :                while (ioff + c.length > idata_limit)
; 5188 :                   idata_limit *= 2;
; 5189 :                STBI_NOTUSED(idata_limit_old);
; 5190 :                p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
; 5191 :                z->idata = p;
; 5192 :             }
; 5193 :             if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
; 5194 :             ioff += c.length;
; 5195 :             break;
; 5196 :          }
; 5197 : 
; 5198 :          case STBI__PNG_TYPE('I','E','N','D'): {
; 5199 :             stbi__uint32 raw_len, bpl;
; 5200 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5201 :             if (scan != STBI__SCAN_load) return 1;
; 5202 :             if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
; 5203 :             // initial guess for decoded data size to avoid unnecessary reallocs
; 5204 :             bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
; 5205 :             raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
; 5206 :             z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
; 5207 :             if (z->expanded == NULL) return 0; // zlib should set error
; 5208 :             STBI_FREE(z->idata); z->idata = NULL;
; 5209 :             if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
; 5210 :                s->img_out_n = s->img_n+1;
; 5211 :             else
; 5212 :                s->img_out_n = s->img_n;
; 5213 :             if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
; 5214 :             if (has_trans) {
; 5215 :                if (z->depth == 16) {
; 5216 :                   if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
; 5217 :                } else {
; 5218 :                   if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
; 5219 :                }
; 5220 :             }
; 5221 :             if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
; 5222 :                stbi__de_iphone(z);
; 5223 :             if (pal_img_n) {
; 5224 :                // pal_img_n == 3 or 4
; 5225 :                s->img_n = pal_img_n; // record the actual colors we had
; 5226 :                s->img_out_n = pal_img_n;
; 5227 :                if (req_comp >= 3) s->img_out_n = req_comp;
; 5228 :                if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
; 5229 :                   return 0;
; 5230 :             } else if (has_trans) {
; 5231 :                // non-paletted image with tRNS -> source image has (constant) alpha
; 5232 :                ++s->img_n;
; 5233 :             }
; 5234 :             STBI_FREE(z->expanded); z->expanded = NULL;
; 5235 :             // end of PNG chunk, read and skip CRC
; 5236 :             stbi__get32be(s);
; 5237 :             return 1;
; 5238 :          }
; 5239 : 
; 5240 :          default:
; 5241 :             // if critical, fail
; 5242 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5243 :             if ((c.type & (1 << 29)) == 0) {
; 5244 :                #ifndef STBI_NO_FAILURE_STRINGS
; 5245 :                // not threadsafe
; 5246 :                static char invalid_chunk[] = "XXXX PNG chunk not known";
; 5247 :                invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
; 5248 :                invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
; 5249 :                invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
; 5250 :                invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
; 5251 :                #endif
; 5252 :                return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
; 5253 :             }
; 5254 :             stbi__skip(s, c.length);
; 5255 :             break;
; 5256 :       }
; 5257 :       // end of PNG chunk, read and skip CRC
; 5258 :       stbi__get32be(s);
; 5259 :    }
; 5260 : }
; 5261 : 
; 5262 : static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
; 5263 : {
; 5264 :    void *result=NULL;
; 5265 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
; 5266 :    if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
; 5267 :       if (p->depth <= 8)
; 5268 :          ri->bits_per_channel = 8;
; 5269 :       else if (p->depth == 16)
; 5270 :          ri->bits_per_channel = 16;
; 5271 :       else
; 5272 :          return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
; 5273 :       result = p->out;
; 5274 :       p->out = NULL;
; 5275 :       if (req_comp && req_comp != p->s->img_out_n) {
; 5276 :          if (ri->bits_per_channel == 8)
; 5277 :             result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
; 5278 :          else
; 5279 :             result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
; 5280 :          p->s->img_out_n = req_comp;
; 5281 :          if (result == NULL) return result;
; 5282 :       }
; 5283 :       *x = p->s->img_x;
; 5284 :       *y = p->s->img_y;
; 5285 :       if (n) *n = p->s->img_n;
; 5286 :    }
; 5287 :    STBI_FREE(p->out);      p->out      = NULL;
; 5288 :    STBI_FREE(p->expanded); p->expanded = NULL;
; 5289 :    STBI_FREE(p->idata);    p->idata    = NULL;
; 5290 : 
; 5291 :    return result;
; 5292 : }
; 5293 : 
; 5294 : static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5295 : {
; 5296 :    stbi__png p;
; 5297 :    p.s = s;
; 5298 :    return stbi__do_png(&p, x,y,comp,req_comp, ri);
; 5299 : }
; 5300 : 
; 5301 : static int stbi__png_test(stbi__context *s)
; 5302 : {
; 5303 :    int r;
; 5304 :    r = stbi__check_png_header(s);
; 5305 :    stbi__rewind(s);
; 5306 :    return r;
; 5307 : }
; 5308 : 
; 5309 : static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
; 5310 : {
; 5311 :    if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
; 5312 :       stbi__rewind( p->s );
; 5313 :       return 0;
; 5314 :    }
; 5315 :    if (x) *x = p->s->img_x;
; 5316 :    if (y) *y = p->s->img_y;
; 5317 :    if (comp) *comp = p->s->img_n;
; 5318 :    return 1;
; 5319 : }
; 5320 : 
; 5321 : static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
; 5322 : {
; 5323 :    stbi__png p;
; 5324 :    p.s = s;
; 5325 :    return stbi__png_info_raw(&p, x, y, comp);
; 5326 : }
; 5327 : 
; 5328 : static int stbi__png_is16(stbi__context *s)
; 5329 : {
; 5330 :    stbi__png p;
; 5331 :    p.s = s;
; 5332 :    if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
; 5333 : 	   return 0;
; 5334 :    if (p.depth != 16) {
; 5335 :       stbi__rewind(p.s);
; 5336 :       return 0;
; 5337 :    }
; 5338 :    return 1;
; 5339 : }
; 5340 : #endif
; 5341 : 
; 5342 : // Microsoft/Windows BMP image
; 5343 : 
; 5344 : #ifndef STBI_NO_BMP
; 5345 : static int stbi__bmp_test_raw(stbi__context *s)
; 5346 : {
; 5347 :    int r;
; 5348 :    int sz;
; 5349 :    if (stbi__get8(s) != 'B') return 0;
; 5350 :    if (stbi__get8(s) != 'M') return 0;
; 5351 :    stbi__get32le(s); // discard filesize
; 5352 :    stbi__get16le(s); // discard reserved
; 5353 :    stbi__get16le(s); // discard reserved
; 5354 :    stbi__get32le(s); // discard data offset
; 5355 :    sz = stbi__get32le(s);
; 5356 :    r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
; 5357 :    return r;
; 5358 : }
; 5359 : 
; 5360 : static int stbi__bmp_test(stbi__context *s)
; 5361 : {
; 5362 :    int r = stbi__bmp_test_raw(s);
; 5363 :    stbi__rewind(s);
; 5364 :    return r;
; 5365 : }
; 5366 : 
; 5367 : 
; 5368 : // returns 0..31 for the highest set bit
; 5369 : static int stbi__high_bit(unsigned int z)
; 5370 : {
; 5371 :    int n=0;
; 5372 :    if (z == 0) return -1;
; 5373 :    if (z >= 0x10000) { n += 16; z >>= 16; }
; 5374 :    if (z >= 0x00100) { n +=  8; z >>=  8; }
; 5375 :    if (z >= 0x00010) { n +=  4; z >>=  4; }
; 5376 :    if (z >= 0x00004) { n +=  2; z >>=  2; }
; 5377 :    if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
; 5378 :    return n;
; 5379 : }
; 5380 : 
; 5381 : static int stbi__bitcount(unsigned int a)
; 5382 : {
; 5383 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
; 5384 :    a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
; 5385 :    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
; 5386 :    a = (a + (a >> 8)); // max 16 per 8 bits
; 5387 :    a = (a + (a >> 16)); // max 32 per 8 bits
; 5388 :    return a & 0xff;
; 5389 : }
; 5390 : 
; 5391 : // extract an arbitrarily-aligned N-bit value (N=bits)
; 5392 : // from v, and then make it 8-bits long and fractionally
; 5393 : // extend it to full full range.
; 5394 : static int stbi__shiftsigned(unsigned int v, int shift, int bits)
; 5395 : {
; 5396 :    static unsigned int mul_table[9] = {
; 5397 :       0,
; 5398 :       0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
; 5399 :       0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
; 5400 :    };
; 5401 :    static unsigned int shift_table[9] = {
; 5402 :       0, 0,0,1,0,2,4,6,0,
; 5403 :    };
; 5404 :    if (shift < 0)
; 5405 :       v <<= -shift;
; 5406 :    else
; 5407 :       v >>= shift;
; 5408 :    STBI_ASSERT(v < 256);
; 5409 :    v >>= (8-bits);
; 5410 :    STBI_ASSERT(bits >= 0 && bits <= 8);
; 5411 :    return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
; 5412 : }
; 5413 : 
; 5414 : typedef struct
; 5415 : {
; 5416 :    int bpp, offset, hsz;
; 5417 :    unsigned int mr,mg,mb,ma, all_a;
; 5418 :    int extra_read;
; 5419 : } stbi__bmp_data;
; 5420 : 
; 5421 : static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
; 5422 : {
; 5423 :    // BI_BITFIELDS specifies masks explicitly, don't override
; 5424 :    if (compress == 3)
; 5425 :       return 1;
; 5426 : 
; 5427 :    if (compress == 0) {
; 5428 :       if (info->bpp == 16) {
; 5429 :          info->mr = 31u << 10;
; 5430 :          info->mg = 31u <<  5;
; 5431 :          info->mb = 31u <<  0;
; 5432 :       } else if (info->bpp == 32) {
; 5433 :          info->mr = 0xffu << 16;
; 5434 :          info->mg = 0xffu <<  8;
; 5435 :          info->mb = 0xffu <<  0;
; 5436 :          info->ma = 0xffu << 24;
; 5437 :          info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
; 5438 :       } else {
; 5439 :          // otherwise, use defaults, which is all-0
; 5440 :          info->mr = info->mg = info->mb = info->ma = 0;
; 5441 :       }
; 5442 :       return 1;
; 5443 :    }
; 5444 :    return 0; // error
; 5445 : }
; 5446 : 
; 5447 : static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
; 5448 : {
; 5449 :    int hsz;
; 5450 :    if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
; 5451 :    stbi__get32le(s); // discard filesize
; 5452 :    stbi__get16le(s); // discard reserved
; 5453 :    stbi__get16le(s); // discard reserved
; 5454 :    info->offset = stbi__get32le(s);
; 5455 :    info->hsz = hsz = stbi__get32le(s);
; 5456 :    info->mr = info->mg = info->mb = info->ma = 0;
; 5457 :    info->extra_read = 14;
; 5458 : 
; 5459 :    if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");
; 5460 : 
; 5461 :    if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
; 5462 :    if (hsz == 12) {
; 5463 :       s->img_x = stbi__get16le(s);
; 5464 :       s->img_y = stbi__get16le(s);
; 5465 :    } else {
; 5466 :       s->img_x = stbi__get32le(s);
; 5467 :       s->img_y = stbi__get32le(s);
; 5468 :    }
; 5469 :    if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
; 5470 :    info->bpp = stbi__get16le(s);
; 5471 :    if (hsz != 12) {
; 5472 :       int compress = stbi__get32le(s);
; 5473 :       if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
; 5474 :       if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes
; 5475 :       if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel
; 5476 :       stbi__get32le(s); // discard sizeof
; 5477 :       stbi__get32le(s); // discard hres
; 5478 :       stbi__get32le(s); // discard vres
; 5479 :       stbi__get32le(s); // discard colorsused
; 5480 :       stbi__get32le(s); // discard max important
; 5481 :       if (hsz == 40 || hsz == 56) {
; 5482 :          if (hsz == 56) {
; 5483 :             stbi__get32le(s);
; 5484 :             stbi__get32le(s);
; 5485 :             stbi__get32le(s);
; 5486 :             stbi__get32le(s);
; 5487 :          }
; 5488 :          if (info->bpp == 16 || info->bpp == 32) {
; 5489 :             if (compress == 0) {
; 5490 :                stbi__bmp_set_mask_defaults(info, compress);
; 5491 :             } else if (compress == 3) {
; 5492 :                info->mr = stbi__get32le(s);
; 5493 :                info->mg = stbi__get32le(s);
; 5494 :                info->mb = stbi__get32le(s);
; 5495 :                info->extra_read += 12;
; 5496 :                // not documented, but generated by photoshop and handled by mspaint
; 5497 :                if (info->mr == info->mg && info->mg == info->mb) {
; 5498 :                   // ?!?!?
; 5499 :                   return stbi__errpuc("bad BMP", "bad BMP");
; 5500 :                }
; 5501 :             } else
; 5502 :                return stbi__errpuc("bad BMP", "bad BMP");
; 5503 :          }
; 5504 :       } else {
; 5505 :          // V4/V5 header
; 5506 :          int i;
; 5507 :          if (hsz != 108 && hsz != 124)
; 5508 :             return stbi__errpuc("bad BMP", "bad BMP");
; 5509 :          info->mr = stbi__get32le(s);
; 5510 :          info->mg = stbi__get32le(s);
; 5511 :          info->mb = stbi__get32le(s);
; 5512 :          info->ma = stbi__get32le(s);
; 5513 :          if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
; 5514 :             stbi__bmp_set_mask_defaults(info, compress);
; 5515 :          stbi__get32le(s); // discard color space
; 5516 :          for (i=0; i < 12; ++i)
; 5517 :             stbi__get32le(s); // discard color space parameters
; 5518 :          if (hsz == 124) {
; 5519 :             stbi__get32le(s); // discard rendering intent
; 5520 :             stbi__get32le(s); // discard offset of profile data
; 5521 :             stbi__get32le(s); // discard size of profile data
; 5522 :             stbi__get32le(s); // discard reserved
; 5523 :          }
; 5524 :       }
; 5525 :    }
; 5526 :    return (void *) 1;
; 5527 : }
; 5528 : 
; 5529 : 
; 5530 : static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5531 : {
; 5532 :    stbi_uc *out;
; 5533 :    unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
; 5534 :    stbi_uc pal[256][4];
; 5535 :    int psize=0,i,j,width;
; 5536 :    int flip_vertically, pad, target;
; 5537 :    stbi__bmp_data info;
; 5538 :    STBI_NOTUSED(ri);
; 5539 : 
; 5540 :    info.all_a = 255;
; 5541 :    if (stbi__bmp_parse_header(s, &info) == NULL)
; 5542 :       return NULL; // error code already set
; 5543 : 
; 5544 :    flip_vertically = ((int) s->img_y) > 0;
; 5545 :    s->img_y = abs((int) s->img_y);
; 5546 : 
; 5547 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5548 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5549 : 
; 5550 :    mr = info.mr;
; 5551 :    mg = info.mg;
; 5552 :    mb = info.mb;
; 5553 :    ma = info.ma;
; 5554 :    all_a = info.all_a;
; 5555 : 
; 5556 :    if (info.hsz == 12) {
; 5557 :       if (info.bpp < 24)
; 5558 :          psize = (info.offset - info.extra_read - 24) / 3;
; 5559 :    } else {
; 5560 :       if (info.bpp < 16)
; 5561 :          psize = (info.offset - info.extra_read - info.hsz) >> 2;
; 5562 :    }
; 5563 :    if (psize == 0) {
; 5564 :       // accept some number of extra bytes after the header, but if the offset points either to before
; 5565 :       // the header ends or implies a large amount of extra data, reject the file as malformed
; 5566 :       int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);
; 5567 :       int header_limit = 1024; // max we actually read is below 256 bytes currently.
; 5568 :       int extra_data_limit = 256*4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.
; 5569 :       if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {
; 5570 :          return stbi__errpuc("bad header", "Corrupt BMP");
; 5571 :       }
; 5572 :       // we established that bytes_read_so_far is positive and sensible.
; 5573 :       // the first half of this test rejects offsets that are either too small positives, or
; 5574 :       // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn
; 5575 :       // ensures the number computed in the second half of the test can't overflow.
; 5576 :       if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {
; 5577 :          return stbi__errpuc("bad offset", "Corrupt BMP");
; 5578 :       } else {
; 5579 :          stbi__skip(s, info.offset - bytes_read_so_far);
; 5580 :       }
; 5581 :    }
; 5582 : 
; 5583 :    if (info.bpp == 24 && ma == 0xff000000)
; 5584 :       s->img_n = 3;
; 5585 :    else
; 5586 :       s->img_n = ma ? 4 : 3;
; 5587 :    if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
; 5588 :       target = req_comp;
; 5589 :    else
; 5590 :       target = s->img_n; // if they want monochrome, we'll post-convert
; 5591 : 
; 5592 :    // sanity-check size
; 5593 :    if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
; 5594 :       return stbi__errpuc("too large", "Corrupt BMP");
; 5595 : 
; 5596 :    out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
; 5597 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");
; 5598 :    if (info.bpp < 16) {
; 5599 :       int z=0;
; 5600 :       if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
; 5601 :       for (i=0; i < psize; ++i) {
; 5602 :          pal[i][2] = stbi__get8(s);
; 5603 :          pal[i][1] = stbi__get8(s);
; 5604 :          pal[i][0] = stbi__get8(s);
; 5605 :          if (info.hsz != 12) stbi__get8(s);
; 5606 :          pal[i][3] = 255;
; 5607 :       }
; 5608 :       stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
; 5609 :       if (info.bpp == 1) width = (s->img_x + 7) >> 3;
; 5610 :       else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
; 5611 :       else if (info.bpp == 8) width = s->img_x;
; 5612 :       else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
; 5613 :       pad = (-width)&3;
; 5614 :       if (info.bpp == 1) {
; 5615 :          for (j=0; j < (int) s->img_y; ++j) {
; 5616 :             int bit_offset = 7, v = stbi__get8(s);
; 5617 :             for (i=0; i < (int) s->img_x; ++i) {
; 5618 :                int color = (v>>bit_offset)&0x1;
; 5619 :                out[z++] = pal[color][0];
; 5620 :                out[z++] = pal[color][1];
; 5621 :                out[z++] = pal[color][2];
; 5622 :                if (target == 4) out[z++] = 255;
; 5623 :                if (i+1 == (int) s->img_x) break;
; 5624 :                if((--bit_offset) < 0) {
; 5625 :                   bit_offset = 7;
; 5626 :                   v = stbi__get8(s);
; 5627 :                }
; 5628 :             }
; 5629 :             stbi__skip(s, pad);
; 5630 :          }
; 5631 :       } else {
; 5632 :          for (j=0; j < (int) s->img_y; ++j) {
; 5633 :             for (i=0; i < (int) s->img_x; i += 2) {
; 5634 :                int v=stbi__get8(s),v2=0;
; 5635 :                if (info.bpp == 4) {
; 5636 :                   v2 = v & 15;
; 5637 :                   v >>= 4;
; 5638 :                }
; 5639 :                out[z++] = pal[v][0];
; 5640 :                out[z++] = pal[v][1];
; 5641 :                out[z++] = pal[v][2];
; 5642 :                if (target == 4) out[z++] = 255;
; 5643 :                if (i+1 == (int) s->img_x) break;
; 5644 :                v = (info.bpp == 8) ? stbi__get8(s) : v2;
; 5645 :                out[z++] = pal[v][0];
; 5646 :                out[z++] = pal[v][1];
; 5647 :                out[z++] = pal[v][2];
; 5648 :                if (target == 4) out[z++] = 255;
; 5649 :             }
; 5650 :             stbi__skip(s, pad);
; 5651 :          }
; 5652 :       }
; 5653 :    } else {
; 5654 :       int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
; 5655 :       int z = 0;
; 5656 :       int easy=0;
; 5657 :       stbi__skip(s, info.offset - info.extra_read - info.hsz);
; 5658 :       if (info.bpp == 24) width = 3 * s->img_x;
; 5659 :       else if (info.bpp == 16) width = 2*s->img_x;
; 5660 :       else /* bpp = 32 and pad = 0 */ width=0;
; 5661 :       pad = (-width) & 3;
; 5662 :       if (info.bpp == 24) {
; 5663 :          easy = 1;
; 5664 :       } else if (info.bpp == 32) {
; 5665 :          if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
; 5666 :             easy = 2;
; 5667 :       }
; 5668 :       if (!easy) {
; 5669 :          if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
; 5670 :          // right shift amt to put high bit in position #7
; 5671 :          rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
; 5672 :          gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
; 5673 :          bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
; 5674 :          ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
; 5675 :          if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
; 5676 :       }
; 5677 :       for (j=0; j < (int) s->img_y; ++j) {
; 5678 :          if (easy) {
; 5679 :             for (i=0; i < (int) s->img_x; ++i) {
; 5680 :                unsigned char a;
; 5681 :                out[z+2] = stbi__get8(s);
; 5682 :                out[z+1] = stbi__get8(s);
; 5683 :                out[z+0] = stbi__get8(s);
; 5684 :                z += 3;
; 5685 :                a = (easy == 2 ? stbi__get8(s) : 255);
; 5686 :                all_a |= a;
; 5687 :                if (target == 4) out[z++] = a;
; 5688 :             }
; 5689 :          } else {
; 5690 :             int bpp = info.bpp;
; 5691 :             for (i=0; i < (int) s->img_x; ++i) {
; 5692 :                stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
; 5693 :                unsigned int a;
; 5694 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
; 5695 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
; 5696 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
; 5697 :                a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
; 5698 :                all_a |= a;
; 5699 :                if (target == 4) out[z++] = STBI__BYTECAST(a);
; 5700 :             }
; 5701 :          }
; 5702 :          stbi__skip(s, pad);
; 5703 :       }
; 5704 :    }
; 5705 : 
; 5706 :    // if alpha channel is all 0s, replace with all 255s
; 5707 :    if (target == 4 && all_a == 0)
; 5708 :       for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
; 5709 :          out[i] = 255;
; 5710 : 
; 5711 :    if (flip_vertically) {
; 5712 :       stbi_uc t;
; 5713 :       for (j=0; j < (int) s->img_y>>1; ++j) {
; 5714 :          stbi_uc *p1 = out +      j     *s->img_x*target;
; 5715 :          stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
; 5716 :          for (i=0; i < (int) s->img_x*target; ++i) {
; 5717 :             t = p1[i]; p1[i] = p2[i]; p2[i] = t;
; 5718 :          }
; 5719 :       }
; 5720 :    }
; 5721 : 
; 5722 :    if (req_comp && req_comp != target) {
; 5723 :       out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
; 5724 :       if (out == NULL) return out; // stbi__convert_format frees input on failure
; 5725 :    }
; 5726 : 
; 5727 :    *x = s->img_x;
; 5728 :    *y = s->img_y;
; 5729 :    if (comp) *comp = s->img_n;
; 5730 :    return out;
; 5731 : }
; 5732 : #endif
; 5733 : 
; 5734 : // Targa Truevision - TGA
; 5735 : // by Jonathan Dummer
; 5736 : #ifndef STBI_NO_TGA
; 5737 : // returns STBI_rgb or whatever, 0 on error
; 5738 : static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
; 5739 : {
; 5740 :    // only RGB or RGBA (incl. 16bit) or grey allowed
; 5741 :    if (is_rgb16) *is_rgb16 = 0;
; 5742 :    switch(bits_per_pixel) {
; 5743 :       case 8:  return STBI_grey;
; 5744 :       case 16: if(is_grey) return STBI_grey_alpha;
; 5745 :                // fallthrough
; 5746 :       case 15: if(is_rgb16) *is_rgb16 = 1;
; 5747 :                return STBI_rgb;
; 5748 :       case 24: // fallthrough
; 5749 :       case 32: return bits_per_pixel/8;
; 5750 :       default: return 0;
; 5751 :    }
; 5752 : }
; 5753 : 
; 5754 : static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
; 5755 : {
; 5756 :     int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
; 5757 :     int sz, tga_colormap_type;
; 5758 :     stbi__get8(s);                   // discard Offset
; 5759 :     tga_colormap_type = stbi__get8(s); // colormap type
; 5760 :     if( tga_colormap_type > 1 ) {
; 5761 :         stbi__rewind(s);
; 5762 :         return 0;      // only RGB or indexed allowed
; 5763 :     }
; 5764 :     tga_image_type = stbi__get8(s); // image type
; 5765 :     if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
; 5766 :         if (tga_image_type != 1 && tga_image_type != 9) {
; 5767 :             stbi__rewind(s);
; 5768 :             return 0;
; 5769 :         }
; 5770 :         stbi__skip(s,4);       // skip index of first colormap entry and number of entries
; 5771 :         sz = stbi__get8(s);    //   check bits per palette color entry
; 5772 :         if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
; 5773 :             stbi__rewind(s);
; 5774 :             return 0;
; 5775 :         }
; 5776 :         stbi__skip(s,4);       // skip image x and y origin
; 5777 :         tga_colormap_bpp = sz;
; 5778 :     } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
; 5779 :         if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
; 5780 :             stbi__rewind(s);
; 5781 :             return 0; // only RGB or grey allowed, +/- RLE
; 5782 :         }
; 5783 :         stbi__skip(s,9); // skip colormap specification and image x/y origin
; 5784 :         tga_colormap_bpp = 0;
; 5785 :     }
; 5786 :     tga_w = stbi__get16le(s);
; 5787 :     if( tga_w < 1 ) {
; 5788 :         stbi__rewind(s);
; 5789 :         return 0;   // test width
; 5790 :     }
; 5791 :     tga_h = stbi__get16le(s);
; 5792 :     if( tga_h < 1 ) {
; 5793 :         stbi__rewind(s);
; 5794 :         return 0;   // test height
; 5795 :     }
; 5796 :     tga_bits_per_pixel = stbi__get8(s); // bits per pixel
; 5797 :     stbi__get8(s); // ignore alpha bits
; 5798 :     if (tga_colormap_bpp != 0) {
; 5799 :         if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
; 5800 :             // when using a colormap, tga_bits_per_pixel is the size of the indexes
; 5801 :             // I don't think anything but 8 or 16bit indexes makes sense
; 5802 :             stbi__rewind(s);
; 5803 :             return 0;
; 5804 :         }
; 5805 :         tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
; 5806 :     } else {
; 5807 :         tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
; 5808 :     }
; 5809 :     if(!tga_comp) {
; 5810 :       stbi__rewind(s);
; 5811 :       return 0;
; 5812 :     }
; 5813 :     if (x) *x = tga_w;
; 5814 :     if (y) *y = tga_h;
; 5815 :     if (comp) *comp = tga_comp;
; 5816 :     return 1;                   // seems to have passed everything
; 5817 : }
; 5818 : 
; 5819 : static int stbi__tga_test(stbi__context *s)
; 5820 : {
; 5821 :    int res = 0;
; 5822 :    int sz, tga_color_type;
; 5823 :    stbi__get8(s);      //   discard Offset
; 5824 :    tga_color_type = stbi__get8(s);   //   color type
; 5825 :    if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
; 5826 :    sz = stbi__get8(s);   //   image type
; 5827 :    if ( tga_color_type == 1 ) { // colormapped (paletted) image
; 5828 :       if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
; 5829 :       stbi__skip(s,4);       // skip index of first colormap entry and number of entries
; 5830 :       sz = stbi__get8(s);    //   check bits per palette color entry
; 5831 :       if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
; 5832 :       stbi__skip(s,4);       // skip image x and y origin
; 5833 :    } else { // "normal" image w/o colormap
; 5834 :       if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
; 5835 :       stbi__skip(s,9); // skip colormap specification and image x/y origin
; 5836 :    }
; 5837 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
; 5838 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
; 5839 :    sz = stbi__get8(s);   //   bits per pixel
; 5840 :    if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
; 5841 :    if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
; 5842 : 
; 5843 :    res = 1; // if we got this far, everything's good and we can return 1 instead of 0
; 5844 : 
; 5845 : errorEnd:
; 5846 :    stbi__rewind(s);
; 5847 :    return res;
; 5848 : }
; 5849 : 
; 5850 : // read 16bit value and convert to 24bit RGB
; 5851 : static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
; 5852 : {
; 5853 :    stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
; 5854 :    stbi__uint16 fiveBitMask = 31;
; 5855 :    // we have 3 channels with 5bits each
; 5856 :    int r = (px >> 10) & fiveBitMask;
; 5857 :    int g = (px >> 5) & fiveBitMask;
; 5858 :    int b = px & fiveBitMask;
; 5859 :    // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
; 5860 :    out[0] = (stbi_uc)((r * 255)/31);
; 5861 :    out[1] = (stbi_uc)((g * 255)/31);
; 5862 :    out[2] = (stbi_uc)((b * 255)/31);
; 5863 : 
; 5864 :    // some people claim that the most significant bit might be used for alpha
; 5865 :    // (possibly if an alpha-bit is set in the "image descriptor byte")
; 5866 :    // but that only made 16bit test images completely translucent..
; 5867 :    // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
; 5868 : }
; 5869 : 
; 5870 : static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5871 : {
; 5872 :    //   read in the TGA header stuff
; 5873 :    int tga_offset = stbi__get8(s);
; 5874 :    int tga_indexed = stbi__get8(s);
; 5875 :    int tga_image_type = stbi__get8(s);
; 5876 :    int tga_is_RLE = 0;
; 5877 :    int tga_palette_start = stbi__get16le(s);
; 5878 :    int tga_palette_len = stbi__get16le(s);
; 5879 :    int tga_palette_bits = stbi__get8(s);
; 5880 :    int tga_x_origin = stbi__get16le(s);
; 5881 :    int tga_y_origin = stbi__get16le(s);
; 5882 :    int tga_width = stbi__get16le(s);
; 5883 :    int tga_height = stbi__get16le(s);
; 5884 :    int tga_bits_per_pixel = stbi__get8(s);
; 5885 :    int tga_comp, tga_rgb16=0;
; 5886 :    int tga_inverted = stbi__get8(s);
; 5887 :    // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
; 5888 :    //   image data
; 5889 :    unsigned char *tga_data;
; 5890 :    unsigned char *tga_palette = NULL;
; 5891 :    int i, j;
; 5892 :    unsigned char raw_data[4] = {0};
; 5893 :    int RLE_count = 0;
; 5894 :    int RLE_repeating = 0;
; 5895 :    int read_next_pixel = 1;
; 5896 :    STBI_NOTUSED(ri);
; 5897 :    STBI_NOTUSED(tga_x_origin); // @TODO
; 5898 :    STBI_NOTUSED(tga_y_origin); // @TODO
; 5899 : 
; 5900 :    if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5901 :    if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5902 : 
; 5903 :    //   do a tiny bit of precessing
; 5904 :    if ( tga_image_type >= 8 )
; 5905 :    {
; 5906 :       tga_image_type -= 8;
; 5907 :       tga_is_RLE = 1;
; 5908 :    }
; 5909 :    tga_inverted = 1 - ((tga_inverted >> 5) & 1);
; 5910 : 
; 5911 :    //   If I'm paletted, then I'll use the number of bits from the palette
; 5912 :    if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
; 5913 :    else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);
; 5914 : 
; 5915 :    if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
; 5916 :       return stbi__errpuc("bad format", "Can't find out TGA pixelformat");
; 5917 : 
; 5918 :    //   tga info
; 5919 :    *x = tga_width;
; 5920 :    *y = tga_height;
; 5921 :    if (comp) *comp = tga_comp;
; 5922 : 
; 5923 :    if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
; 5924 :       return stbi__errpuc("too large", "Corrupt TGA");
; 5925 : 
; 5926 :    tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
; 5927 :    if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");
; 5928 : 
; 5929 :    // skip to the data's starting position (offset usually = 0)
; 5930 :    stbi__skip(s, tga_offset );
; 5931 : 
; 5932 :    if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
; 5933 :       for (i=0; i < tga_height; ++i) {
; 5934 :          int row = tga_inverted ? tga_height -i - 1 : i;
; 5935 :          stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
; 5936 :          stbi__getn(s, tga_row, tga_width * tga_comp);
; 5937 :       }
; 5938 :    } else  {
; 5939 :       //   do I need to load a palette?
; 5940 :       if ( tga_indexed)
; 5941 :       {
; 5942 :          if (tga_palette_len == 0) {  /* you have to have at least one entry! */
; 5943 :             STBI_FREE(tga_data);
; 5944 :             return stbi__errpuc("bad palette", "Corrupt TGA");
; 5945 :          }
; 5946 : 
; 5947 :          //   any data to skip? (offset usually = 0)
; 5948 :          stbi__skip(s, tga_palette_start );
; 5949 :          //   load the palette
; 5950 :          tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
; 5951 :          if (!tga_palette) {
; 5952 :             STBI_FREE(tga_data);
; 5953 :             return stbi__errpuc("outofmem", "Out of memory");
; 5954 :          }
; 5955 :          if (tga_rgb16) {
; 5956 :             stbi_uc *pal_entry = tga_palette;
; 5957 :             STBI_ASSERT(tga_comp == STBI_rgb);
; 5958 :             for (i=0; i < tga_palette_len; ++i) {
; 5959 :                stbi__tga_read_rgb16(s, pal_entry);
; 5960 :                pal_entry += tga_comp;
; 5961 :             }
; 5962 :          } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
; 5963 :                STBI_FREE(tga_data);
; 5964 :                STBI_FREE(tga_palette);
; 5965 :                return stbi__errpuc("bad palette", "Corrupt TGA");
; 5966 :          }
; 5967 :       }
; 5968 :       //   load the data
; 5969 :       for (i=0; i < tga_width * tga_height; ++i)
; 5970 :       {
; 5971 :          //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
; 5972 :          if ( tga_is_RLE )
; 5973 :          {
; 5974 :             if ( RLE_count == 0 )
; 5975 :             {
; 5976 :                //   yep, get the next byte as a RLE command
; 5977 :                int RLE_cmd = stbi__get8(s);
; 5978 :                RLE_count = 1 + (RLE_cmd & 127);
; 5979 :                RLE_repeating = RLE_cmd >> 7;
; 5980 :                read_next_pixel = 1;
; 5981 :             } else if ( !RLE_repeating )
; 5982 :             {
; 5983 :                read_next_pixel = 1;
; 5984 :             }
; 5985 :          } else
; 5986 :          {
; 5987 :             read_next_pixel = 1;
; 5988 :          }
; 5989 :          //   OK, if I need to read a pixel, do it now
; 5990 :          if ( read_next_pixel )
; 5991 :          {
; 5992 :             //   load however much data we did have
; 5993 :             if ( tga_indexed )
; 5994 :             {
; 5995 :                // read in index, then perform the lookup
; 5996 :                int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
; 5997 :                if ( pal_idx >= tga_palette_len ) {
; 5998 :                   // invalid index
; 5999 :                   pal_idx = 0;
; 6000 :                }
; 6001 :                pal_idx *= tga_comp;
; 6002 :                for (j = 0; j < tga_comp; ++j) {
; 6003 :                   raw_data[j] = tga_palette[pal_idx+j];
; 6004 :                }
; 6005 :             } else if(tga_rgb16) {
; 6006 :                STBI_ASSERT(tga_comp == STBI_rgb);
; 6007 :                stbi__tga_read_rgb16(s, raw_data);
; 6008 :             } else {
; 6009 :                //   read in the data raw
; 6010 :                for (j = 0; j < tga_comp; ++j) {
; 6011 :                   raw_data[j] = stbi__get8(s);
; 6012 :                }
; 6013 :             }
; 6014 :             //   clear the reading flag for the next pixel
; 6015 :             read_next_pixel = 0;
; 6016 :          } // end of reading a pixel
; 6017 : 
; 6018 :          // copy data
; 6019 :          for (j = 0; j < tga_comp; ++j)
; 6020 :            tga_data[i*tga_comp+j] = raw_data[j];
; 6021 : 
; 6022 :          //   in case we're in RLE mode, keep counting down
; 6023 :          --RLE_count;
; 6024 :       }
; 6025 :       //   do I need to invert the image?
; 6026 :       if ( tga_inverted )
; 6027 :       {
; 6028 :          for (j = 0; j*2 < tga_height; ++j)
; 6029 :          {
; 6030 :             int index1 = j * tga_width * tga_comp;
; 6031 :             int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
; 6032 :             for (i = tga_width * tga_comp; i > 0; --i)
; 6033 :             {
; 6034 :                unsigned char temp = tga_data[index1];
; 6035 :                tga_data[index1] = tga_data[index2];
; 6036 :                tga_data[index2] = temp;
; 6037 :                ++index1;
; 6038 :                ++index2;
; 6039 :             }
; 6040 :          }
; 6041 :       }
; 6042 :       //   clear my palette, if I had one
; 6043 :       if ( tga_palette != NULL )
; 6044 :       {
; 6045 :          STBI_FREE( tga_palette );
; 6046 :       }
; 6047 :    }
; 6048 : 
; 6049 :    // swap RGB - if the source data was RGB16, it already is in the right order
; 6050 :    if (tga_comp >= 3 && !tga_rgb16)
; 6051 :    {
; 6052 :       unsigned char* tga_pixel = tga_data;
; 6053 :       for (i=0; i < tga_width * tga_height; ++i)
; 6054 :       {
; 6055 :          unsigned char temp = tga_pixel[0];
; 6056 :          tga_pixel[0] = tga_pixel[2];
; 6057 :          tga_pixel[2] = temp;
; 6058 :          tga_pixel += tga_comp;
; 6059 :       }
; 6060 :    }
; 6061 : 
; 6062 :    // convert to target component count
; 6063 :    if (req_comp && req_comp != tga_comp)
; 6064 :       tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);
; 6065 : 
; 6066 :    //   the things I do to get rid of an error message, and yet keep
; 6067 :    //   Microsoft's C compilers happy... [8^(
; 6068 :    tga_palette_start = tga_palette_len = tga_palette_bits =
; 6069 :          tga_x_origin = tga_y_origin = 0;
; 6070 :    STBI_NOTUSED(tga_palette_start);
; 6071 :    //   OK, done
; 6072 :    return tga_data;
; 6073 : }
; 6074 : #endif
; 6075 : 
; 6076 : // *************************************************************************************************
; 6077 : // Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB
; 6078 : 
; 6079 : #ifndef STBI_NO_PSD
; 6080 : static int stbi__psd_test(stbi__context *s)
; 6081 : {
; 6082 :    int r = (stbi__get32be(s) == 0x38425053);
; 6083 :    stbi__rewind(s);
; 6084 :    return r;
; 6085 : }
; 6086 : 
; 6087 : static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
; 6088 : {
; 6089 :    int count, nleft, len;
; 6090 : 
; 6091 :    count = 0;
; 6092 :    while ((nleft = pixelCount - count) > 0) {
; 6093 :       len = stbi__get8(s);
; 6094 :       if (len == 128) {
; 6095 :          // No-op.
; 6096 :       } else if (len < 128) {
; 6097 :          // Copy next len+1 bytes literally.
; 6098 :          len++;
; 6099 :          if (len > nleft) return 0; // corrupt data
; 6100 :          count += len;
; 6101 :          while (len) {
; 6102 :             *p = stbi__get8(s);
; 6103 :             p += 4;
; 6104 :             len--;
; 6105 :          }
; 6106 :       } else if (len > 128) {
; 6107 :          stbi_uc   val;
; 6108 :          // Next -len+1 bytes in the dest are replicated from next source byte.
; 6109 :          // (Interpret len as a negative 8-bit int.)
; 6110 :          len = 257 - len;
; 6111 :          if (len > nleft) return 0; // corrupt data
; 6112 :          val = stbi__get8(s);
; 6113 :          count += len;
; 6114 :          while (len) {
; 6115 :             *p = val;
; 6116 :             p += 4;
; 6117 :             len--;
; 6118 :          }
; 6119 :       }
; 6120 :    }
; 6121 : 
; 6122 :    return 1;
; 6123 : }
; 6124 : 
; 6125 : static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
; 6126 : {
; 6127 :    int pixelCount;
; 6128 :    int channelCount, compression;
; 6129 :    int channel, i;
; 6130 :    int bitdepth;
; 6131 :    int w,h;
; 6132 :    stbi_uc *out;
; 6133 :    STBI_NOTUSED(ri);
; 6134 : 
; 6135 :    // Check identifier
; 6136 :    if (stbi__get32be(s) != 0x38425053)   // "8BPS"
; 6137 :       return stbi__errpuc("not PSD", "Corrupt PSD image");
; 6138 : 
; 6139 :    // Check file type version.
; 6140 :    if (stbi__get16be(s) != 1)
; 6141 :       return stbi__errpuc("wrong version", "Unsupported version of PSD image");
; 6142 : 
; 6143 :    // Skip 6 reserved bytes.
; 6144 :    stbi__skip(s, 6 );
; 6145 : 
; 6146 :    // Read the number of channels (R, G, B, A, etc).
; 6147 :    channelCount = stbi__get16be(s);
; 6148 :    if (channelCount < 0 || channelCount > 16)
; 6149 :       return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");
; 6150 : 
; 6151 :    // Read the rows and columns of the image.
; 6152 :    h = stbi__get32be(s);
; 6153 :    w = stbi__get32be(s);
; 6154 : 
; 6155 :    if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 6156 :    if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 6157 : 
; 6158 :    // Make sure the depth is 8 bits.
; 6159 :    bitdepth = stbi__get16be(s);
; 6160 :    if (bitdepth != 8 && bitdepth != 16)
; 6161 :       return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");
; 6162 : 
; 6163 :    // Make sure the color mode is RGB.
; 6164 :    // Valid options are:
; 6165 :    //   0: Bitmap
; 6166 :    //   1: Grayscale
; 6167 :    //   2: Indexed color
; 6168 :    //   3: RGB color
; 6169 :    //   4: CMYK color
; 6170 :    //   7: Multichannel
; 6171 :    //   8: Duotone
; 6172 :    //   9: Lab color
; 6173 :    if (stbi__get16be(s) != 3)
; 6174 :       return stbi__errpuc("wrong color format", "PSD is not in RGB color format");
; 6175 : 
; 6176 :    // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
; 6177 :    stbi__skip(s,stbi__get32be(s) );
; 6178 : 
; 6179 :    // Skip the image resources.  (resolution, pen tool paths, etc)
; 6180 :    stbi__skip(s, stbi__get32be(s) );
; 6181 : 
; 6182 :    // Skip the reserved data.
; 6183 :    stbi__skip(s, stbi__get32be(s) );
; 6184 : 
; 6185 :    // Find out if the data is compressed.
; 6186 :    // Known values:
; 6187 :    //   0: no compression
; 6188 :    //   1: RLE compressed
; 6189 :    compression = stbi__get16be(s);
; 6190 :    if (compression > 1)
; 6191 :       return stbi__errpuc("bad compression", "PSD has an unknown compression format");
; 6192 : 
; 6193 :    // Check size
; 6194 :    if (!stbi__mad3sizes_valid(4, w, h, 0))
; 6195 :       return stbi__errpuc("too large", "Corrupt PSD");
; 6196 : 
; 6197 :    // Create the destination image.
; 6198 : 
; 6199 :    if (!compression && bitdepth == 16 && bpc == 16) {
; 6200 :       out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
; 6201 :       ri->bits_per_channel = 16;
; 6202 :    } else
; 6203 :       out = (stbi_uc *) stbi__malloc(4 * w*h);
; 6204 : 
; 6205 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");
; 6206 :    pixelCount = w*h;
; 6207 : 
; 6208 :    // Initialize the data to zero.
; 6209 :    //memset( out, 0, pixelCount * 4 );
; 6210 : 
; 6211 :    // Finally, the image data.
; 6212 :    if (compression) {
; 6213 :       // RLE as used by .PSD and .TIFF
; 6214 :       // Loop until you get the number of unpacked bytes you are expecting:
; 6215 :       //     Read the next source byte into n.
; 6216 :       //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
; 6217 :       //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
; 6218 :       //     Else if n is 128, noop.
; 6219 :       // Endloop
; 6220 : 
; 6221 :       // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
; 6222 :       // which we're going to just skip.
; 6223 :       stbi__skip(s, h * channelCount * 2 );
; 6224 : 
; 6225 :       // Read the RLE data by channel.
; 6226 :       for (channel = 0; channel < 4; channel++) {
; 6227 :          stbi_uc *p;
; 6228 : 
; 6229 :          p = out+channel;
; 6230 :          if (channel >= channelCount) {
; 6231 :             // Fill this channel with default data.
; 6232 :             for (i = 0; i < pixelCount; i++, p += 4)
; 6233 :                *p = (channel == 3 ? 255 : 0);
; 6234 :          } else {
; 6235 :             // Read the RLE data.
; 6236 :             if (!stbi__psd_decode_rle(s, p, pixelCount)) {
; 6237 :                STBI_FREE(out);
; 6238 :                return stbi__errpuc("corrupt", "bad RLE data");
; 6239 :             }
; 6240 :          }
; 6241 :       }
; 6242 : 
; 6243 :    } else {
; 6244 :       // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
; 6245 :       // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.
; 6246 : 
; 6247 :       // Read the data by channel.
; 6248 :       for (channel = 0; channel < 4; channel++) {
; 6249 :          if (channel >= channelCount) {
; 6250 :             // Fill this channel with default data.
; 6251 :             if (bitdepth == 16 && bpc == 16) {
; 6252 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
; 6253 :                stbi__uint16 val = channel == 3 ? 65535 : 0;
; 6254 :                for (i = 0; i < pixelCount; i++, q += 4)
; 6255 :                   *q = val;
; 6256 :             } else {
; 6257 :                stbi_uc *p = out+channel;
; 6258 :                stbi_uc val = channel == 3 ? 255 : 0;
; 6259 :                for (i = 0; i < pixelCount; i++, p += 4)
; 6260 :                   *p = val;
; 6261 :             }
; 6262 :          } else {
; 6263 :             if (ri->bits_per_channel == 16) {    // output bpc
; 6264 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
; 6265 :                for (i = 0; i < pixelCount; i++, q += 4)
; 6266 :                   *q = (stbi__uint16) stbi__get16be(s);
; 6267 :             } else {
; 6268 :                stbi_uc *p = out+channel;
; 6269 :                if (bitdepth == 16) {  // input bpc
; 6270 :                   for (i = 0; i < pixelCount; i++, p += 4)
; 6271 :                      *p = (stbi_uc) (stbi__get16be(s) >> 8);
; 6272 :                } else {
; 6273 :                   for (i = 0; i < pixelCount; i++, p += 4)
; 6274 :                      *p = stbi__get8(s);
; 6275 :                }
; 6276 :             }
; 6277 :          }
; 6278 :       }
; 6279 :    }
; 6280 : 
; 6281 :    // remove weird white matte from PSD
; 6282 :    if (channelCount >= 4) {
; 6283 :       if (ri->bits_per_channel == 16) {
; 6284 :          for (i=0; i < w*h; ++i) {
; 6285 :             stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
; 6286 :             if (pixel[3] != 0 && pixel[3] != 65535) {
; 6287 :                float a = pixel[3] / 65535.0f;
; 6288 :                float ra = 1.0f / a;
; 6289 :                float inv_a = 65535.0f * (1 - ra);
; 6290 :                pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
; 6291 :                pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
; 6292 :                pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
; 6293 :             }
; 6294 :          }
; 6295 :       } else {
; 6296 :          for (i=0; i < w*h; ++i) {
; 6297 :             unsigned char *pixel = out + 4*i;
; 6298 :             if (pixel[3] != 0 && pixel[3] != 255) {
; 6299 :                float a = pixel[3] / 255.0f;
; 6300 :                float ra = 1.0f / a;
; 6301 :                float inv_a = 255.0f * (1 - ra);
; 6302 :                pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
; 6303 :                pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
; 6304 :                pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
; 6305 :             }
; 6306 :          }
; 6307 :       }
; 6308 :    }
; 6309 : 
; 6310 :    // convert to desired output format
; 6311 :    if (req_comp && req_comp != 4) {
; 6312 :       if (ri->bits_per_channel == 16)
; 6313 :          out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
; 6314 :       else
; 6315 :          out = stbi__convert_format(out, 4, req_comp, w, h);
; 6316 :       if (out == NULL) return out; // stbi__convert_format frees input on failure
; 6317 :    }
; 6318 : 
; 6319 :    if (comp) *comp = 4;
; 6320 :    *y = h;
; 6321 :    *x = w;
; 6322 : 
; 6323 :    return out;
; 6324 : }
; 6325 : #endif
; 6326 : 
; 6327 : // *************************************************************************************************
; 6328 : // Softimage PIC loader
; 6329 : // by Tom Seddon
; 6330 : //
; 6331 : // See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
; 6332 : // See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/
; 6333 : 
; 6334 : #ifndef STBI_NO_PIC
; 6335 : static int stbi__pic_is4(stbi__context *s,const char *str)
; 6336 : {
; 6337 :    int i;
; 6338 :    for (i=0; i<4; ++i)
; 6339 :       if (stbi__get8(s) != (stbi_uc)str[i])
; 6340 :          return 0;
; 6341 : 
; 6342 :    return 1;
; 6343 : }
; 6344 : 
; 6345 : static int stbi__pic_test_core(stbi__context *s)
; 6346 : {
; 6347 :    int i;
; 6348 : 
; 6349 :    if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
; 6350 :       return 0;
; 6351 : 
; 6352 :    for(i=0;i<84;++i)
; 6353 :       stbi__get8(s);
; 6354 : 
; 6355 :    if (!stbi__pic_is4(s,"PICT"))
; 6356 :       return 0;
; 6357 : 
; 6358 :    return 1;
; 6359 : }
; 6360 : 
; 6361 : typedef struct
; 6362 : {
; 6363 :    stbi_uc size,type,channel;
; 6364 : } stbi__pic_packet;
; 6365 : 
; 6366 : static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
; 6367 : {
; 6368 :    int mask=0x80, i;
; 6369 : 
; 6370 :    for (i=0; i<4; ++i, mask>>=1) {
; 6371 :       if (channel & mask) {
; 6372 :          if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
; 6373 :          dest[i]=stbi__get8(s);
; 6374 :       }
; 6375 :    }
; 6376 : 
; 6377 :    return dest;
; 6378 : }
; 6379 : 
; 6380 : static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
; 6381 : {
; 6382 :    int mask=0x80,i;
; 6383 : 
; 6384 :    for (i=0;i<4; ++i, mask>>=1)
; 6385 :       if (channel&mask)

	test	dil, 32					; 00000020H
	je	SHORT $LN153@stbi__pic_

; 6386 :          dest[i]=src[i];

	mov	BYTE PTR [rbx+2], r8b
$LN153@stbi__pic_:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;
; 1636 : }
; 1637 : #endif
; 1638 : 
; 1639 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
; 1640 : // nothing
; 1641 : #else
; 1642 : static void stbi__skip(stbi__context *s, int n)
; 1643 : {
; 1644 :    if (n == 0) return;  // already there!
; 1645 :    if (n < 0) {
; 1646 :       s->img_buffer = s->img_buffer_end;
; 1647 :       return;
; 1648 :    }
; 1649 :    if (s->io.read) {
; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1651 :       if (blen < n) {
; 1652 :          s->img_buffer = s->img_buffer_end;
; 1653 :          (s->io.skip)(s->io_user_data, n - blen);
; 1654 :          return;
; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;
; 1658 : }
; 1659 : #endif
; 1660 : 
; 1661 : #if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
; 1662 : // nothing
; 1663 : #else
; 1664 : static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
; 1665 : {
; 1666 :    if (s->io.read) {
; 1667 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1668 :       if (blen < n) {
; 1669 :          int res, count;
; 1670 : 
; 1671 :          memcpy(buffer, s->img_buffer, blen);
; 1672 : 
; 1673 :          count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
; 1674 :          res = (count == (n-blen));
; 1675 :          s->img_buffer = s->img_buffer_end;
; 1676 :          return res;
; 1677 :       }
; 1678 :    }
; 1679 : 
; 1680 :    if (s->img_buffer+n <= s->img_buffer_end) {
; 1681 :       memcpy(buffer, s->img_buffer, n);
; 1682 :       s->img_buffer += n;
; 1683 :       return 1;
; 1684 :    } else
; 1685 :       return 0;
; 1686 : }
; 1687 : #endif
; 1688 : 
; 1689 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1690 : // nothing
; 1691 : #else
; 1692 : static int stbi__get16be(stbi__context *s)
; 1693 : {
; 1694 :    int z = stbi__get8(s);
; 1695 :    return (z << 8) + stbi__get8(s);
; 1696 : }
; 1697 : #endif
; 1698 : 
; 1699 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1700 : // nothing
; 1701 : #else
; 1702 : static stbi__uint32 stbi__get32be(stbi__context *s)
; 1703 : {
; 1704 :    stbi__uint32 z = stbi__get16be(s);
; 1705 :    return (z << 16) + stbi__get16be(s);
; 1706 : }
; 1707 : #endif
; 1708 : 
; 1709 : #if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
; 1710 : // nothing
; 1711 : #else
; 1712 : static int stbi__get16le(stbi__context *s)
; 1713 : {
; 1714 :    int z = stbi__get8(s);
; 1715 :    return z + (stbi__get8(s) << 8);
; 1716 : }
; 1717 : #endif
; 1718 : 
; 1719 : #ifndef STBI_NO_BMP
; 1720 : static stbi__uint32 stbi__get32le(stbi__context *s)
; 1721 : {
; 1722 :    stbi__uint32 z = stbi__get16le(s);
; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;
; 1724 :    return z;
; 1725 : }
; 1726 : #endif
; 1727 : 
; 1728 : #define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
; 1729 : 
; 1730 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1731 : // nothing
; 1732 : #else
; 1733 : //////////////////////////////////////////////////////////////////////////////
; 1734 : //
; 1735 : //  generic converter from built-in img_n to req_comp
; 1736 : //    individual types do this automatically as much as possible (e.g. jpeg
; 1737 : //    does all cases internally since it needs to colorspace convert anyway,
; 1738 : //    and it never has alpha, so very few cases ). png can automatically
; 1739 : //    interleave an alpha=255 channel, but falls back to this for other cases
; 1740 : //
; 1741 : //  assume data buffer is malloced, so malloc a new one and free that one
; 1742 : //  only failure mode is malloc failing
; 1743 : 
; 1744 : static stbi_uc stbi__compute_y(int r, int g, int b)
; 1745 : {
; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1747 : }
; 1748 : #endif
; 1749 : 
; 1750 : #if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1751 : // nothing
; 1752 : #else
; 1753 : static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1754 : {
; 1755 :    int i,j;
; 1756 :    unsigned char *good;
; 1757 : 
; 1758 :    if (req_comp == img_n) return data;
; 1759 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1760 : 
; 1761 :    good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
; 1762 :    if (good == NULL) {
; 1763 :       STBI_FREE(data);
; 1764 :       return stbi__errpuc("outofmem", "Out of memory");
; 1765 :    }
; 1766 : 
; 1767 :    for (j=0; j < (int) y; ++j) {
; 1768 :       unsigned char *src  = data + j * x * img_n   ;
; 1769 :       unsigned char *dest = good + j * x * req_comp;
; 1770 : 
; 1771 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1772 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1773 :       // convert source image with img_n components to one with req_comp components;
; 1774 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1775 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1776 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
; 1777 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1778 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
; 1779 :          STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
; 1780 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1781 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
; 1782 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
; 1783 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1784 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
; 1785 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1786 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1787 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
; 1788 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
; 1789 :       }
; 1790 :       #undef STBI__CASE
; 1791 :    }
; 1792 : 
; 1793 :    STBI_FREE(data);
; 1794 :    return good;
; 1795 : }
; 1796 : #endif
; 1797 : 
; 1798 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1799 : // nothing
; 1800 : #else
; 1801 : static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
; 1802 : {
; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1804 : }
; 1805 : #endif
; 1806 : 
; 1807 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1808 : // nothing
; 1809 : #else
; 1810 : static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1811 : {
; 1812 :    int i,j;
; 1813 :    stbi__uint16 *good;
; 1814 : 
; 1815 :    if (req_comp == img_n) return data;
; 1816 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1817 : 
; 1818 :    good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
; 1819 :    if (good == NULL) {
; 1820 :       STBI_FREE(data);
; 1821 :       return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1822 :    }
; 1823 : 
; 1824 :    for (j=0; j < (int) y; ++j) {
; 1825 :       stbi__uint16 *src  = data + j * x * img_n   ;
; 1826 :       stbi__uint16 *dest = good + j * x * req_comp;
; 1827 : 
; 1828 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1829 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1830 :       // convert source image with img_n components to one with req_comp components;
; 1831 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1832 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1833 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
; 1834 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1835 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
; 1836 :          STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
; 1837 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1838 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
; 1839 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
; 1840 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1841 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
; 1842 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1843 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1844 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
; 1845 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
; 1846 :       }
; 1847 :       #undef STBI__CASE
; 1848 :    }
; 1849 : 
; 1850 :    STBI_FREE(data);
; 1851 :    return good;
; 1852 : }
; 1853 : #endif
; 1854 : 
; 1855 : #ifndef STBI_NO_LINEAR
; 1856 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
; 1857 : {
; 1858 :    int i,k,n;
; 1859 :    float *output;
; 1860 :    if (!data) return NULL;
; 1861 :    output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
; 1862 :    if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
; 1863 :    // compute number of non-alpha components
; 1864 :    if (comp & 1) n = comp; else n = comp-1;
; 1865 :    for (i=0; i < x*y; ++i) {
; 1866 :       for (k=0; k < n; ++k) {
; 1867 :          output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
; 1868 :       }
; 1869 :    }
; 1870 :    if (n < comp) {
; 1871 :       for (i=0; i < x*y; ++i) {
; 1872 :          output[i*comp + n] = data[i*comp + n]/255.0f;
; 1873 :       }
; 1874 :    }
; 1875 :    STBI_FREE(data);
; 1876 :    return output;
; 1877 : }
; 1878 : #endif
; 1879 : 
; 1880 : #ifndef STBI_NO_HDR
; 1881 : #define stbi__float2int(x)   ((int) (x))
; 1882 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
; 1883 : {
; 1884 :    int i,k,n;
; 1885 :    stbi_uc *output;
; 1886 :    if (!data) return NULL;
; 1887 :    output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
; 1888 :    if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
; 1889 :    // compute number of non-alpha components
; 1890 :    if (comp & 1) n = comp; else n = comp-1;
; 1891 :    for (i=0; i < x*y; ++i) {
; 1892 :       for (k=0; k < n; ++k) {
; 1893 :          float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
; 1894 :          if (z < 0) z = 0;
; 1895 :          if (z > 255) z = 255;
; 1896 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1897 :       }
; 1898 :       if (k < comp) {
; 1899 :          float z = data[i*comp+k] * 255 + 0.5f;
; 1900 :          if (z < 0) z = 0;
; 1901 :          if (z > 255) z = 255;
; 1902 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1903 :       }
; 1904 :    }
; 1905 :    STBI_FREE(data);
; 1906 :    return output;
; 1907 : }
; 1908 : #endif
; 1909 : 
; 1910 : //////////////////////////////////////////////////////////////////////////////
; 1911 : //
; 1912 : //  "baseline" JPEG/JFIF decoder
; 1913 : //
; 1914 : //    simple implementation
; 1915 : //      - doesn't support delayed output of y-dimension
; 1916 : //      - simple interface (only one output format: 8-bit interleaved RGB)
; 1917 : //      - doesn't try to recover corrupt jpegs
; 1918 : //      - doesn't allow partial loading, loading multiple at once
; 1919 : //      - still fast on x86 (copying globals into locals doesn't help x86)
; 1920 : //      - allocates lots of intermediate memory (full size of all components)
; 1921 : //        - non-interleaved case requires this anyway
; 1922 : //        - allows good upsampling (see next)
; 1923 : //    high-quality
; 1924 : //      - upsampled channels are bilinearly interpolated, even across blocks
; 1925 : //      - quality integer IDCT derived from IJG's 'slow'
; 1926 : //    performance
; 1927 : //      - fast huffman; reasonable integer IDCT
; 1928 : //      - some SIMD kernels for common paths on targets with SSE2/NEON
; 1929 : //      - uses a lot of intermediate memory, could cache poorly
; 1930 : 
; 1931 : #ifndef STBI_NO_JPEG
; 1932 : 
; 1933 : // huffman decoding acceleration
; 1934 : #define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
; 1935 : 
; 1936 : typedef struct
; 1937 : {
; 1938 :    stbi_uc  fast[1 << FAST_BITS];
; 1939 :    // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
; 1940 :    stbi__uint16 code[256];
; 1941 :    stbi_uc  values[256];
; 1942 :    stbi_uc  size[257];
; 1943 :    unsigned int maxcode[18];
; 1944 :    int    delta[17];   // old 'firstsymbol' - old 'firstcode'
; 1945 : } stbi__huffman;
; 1946 : 
; 1947 : typedef struct
; 1948 : {
; 1949 :    stbi__context *s;
; 1950 :    stbi__huffman huff_dc[4];
; 1951 :    stbi__huffman huff_ac[4];
; 1952 :    stbi__uint16 dequant[4][64];
; 1953 :    stbi__int16 fast_ac[4][1 << FAST_BITS];
; 1954 : 
; 1955 : // sizes for components, interleaved MCUs
; 1956 :    int img_h_max, img_v_max;
; 1957 :    int img_mcu_x, img_mcu_y;
; 1958 :    int img_mcu_w, img_mcu_h;
; 1959 : 
; 1960 : // definition of jpeg image component
; 1961 :    struct
; 1962 :    {
; 1963 :       int id;
; 1964 :       int h,v;
; 1965 :       int tq;
; 1966 :       int hd,ha;
; 1967 :       int dc_pred;
; 1968 : 
; 1969 :       int x,y,w2,h2;
; 1970 :       stbi_uc *data;
; 1971 :       void *raw_data, *raw_coeff;
; 1972 :       stbi_uc *linebuf;
; 1973 :       short   *coeff;   // progressive only
; 1974 :       int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
; 1975 :    } img_comp[4];
; 1976 : 
; 1977 :    stbi__uint32   code_buffer; // jpeg entropy-coded buffer
; 1978 :    int            code_bits;   // number of valid bits
; 1979 :    unsigned char  marker;      // marker seen while filling entropy buffer
; 1980 :    int            nomore;      // flag if we saw a marker so must stop
; 1981 : 
; 1982 :    int            progressive;
; 1983 :    int            spec_start;
; 1984 :    int            spec_end;
; 1985 :    int            succ_high;
; 1986 :    int            succ_low;
; 1987 :    int            eob_run;
; 1988 :    int            jfif;
; 1989 :    int            app14_color_transform; // Adobe APP14 tag
; 1990 :    int            rgb;
; 1991 : 
; 1992 :    int scan_n, order[4];
; 1993 :    int restart_interval, todo;
; 1994 : 
; 1995 : // kernels
; 1996 :    void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
; 1997 :    void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
; 1998 :    stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
; 1999 : } stbi__jpeg;
; 2000 : 
; 2001 : static int stbi__build_huffman(stbi__huffman *h, int *count)
; 2002 : {
; 2003 :    int i,j,k=0;
; 2004 :    unsigned int code;
; 2005 :    // build size list for each symbol (from JPEG spec)
; 2006 :    for (i=0; i < 16; ++i) {
; 2007 :       for (j=0; j < count[i]; ++j) {
; 2008 :          h->size[k++] = (stbi_uc) (i+1);
; 2009 :          if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");
; 2010 :       }
; 2011 :    }
; 2012 :    h->size[k] = 0;
; 2013 : 
; 2014 :    // compute actual symbols (from jpeg spec)
; 2015 :    code = 0;
; 2016 :    k = 0;
; 2017 :    for(j=1; j <= 16; ++j) {
; 2018 :       // compute delta to add to code to compute symbol id
; 2019 :       h->delta[j] = k - code;
; 2020 :       if (h->size[k] == j) {
; 2021 :          while (h->size[k] == j)
; 2022 :             h->code[k++] = (stbi__uint16) (code++);
; 2023 :          if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
; 2024 :       }
; 2025 :       // compute largest code + 1 for this size, preshifted as needed later
; 2026 :       h->maxcode[j] = code << (16-j);
; 2027 :       code <<= 1;
; 2028 :    }
; 2029 :    h->maxcode[j] = 0xffffffff;
; 2030 : 
; 2031 :    // build non-spec acceleration table; 255 is flag for not-accelerated
; 2032 :    memset(h->fast, 255, 1 << FAST_BITS);
; 2033 :    for (i=0; i < k; ++i) {
; 2034 :       int s = h->size[i];
; 2035 :       if (s <= FAST_BITS) {
; 2036 :          int c = h->code[i] << (FAST_BITS-s);
; 2037 :          int m = 1 << (FAST_BITS-s);
; 2038 :          for (j=0; j < m; ++j) {
; 2039 :             h->fast[c+j] = (stbi_uc) i;
; 2040 :          }
; 2041 :       }
; 2042 :    }
; 2043 :    return 1;
; 2044 : }
; 2045 : 
; 2046 : // build a table that decodes both magnitude and value of small ACs in
; 2047 : // one go.
; 2048 : static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
; 2049 : {
; 2050 :    int i;
; 2051 :    for (i=0; i < (1 << FAST_BITS); ++i) {
; 2052 :       stbi_uc fast = h->fast[i];
; 2053 :       fast_ac[i] = 0;
; 2054 :       if (fast < 255) {
; 2055 :          int rs = h->values[fast];
; 2056 :          int run = (rs >> 4) & 15;
; 2057 :          int magbits = rs & 15;
; 2058 :          int len = h->size[fast];
; 2059 : 
; 2060 :          if (magbits && len + magbits <= FAST_BITS) {
; 2061 :             // magnitude code followed by receive_extend code
; 2062 :             int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
; 2063 :             int m = 1 << (magbits - 1);
; 2064 :             if (k < m) k += (~0U << magbits) + 1;
; 2065 :             // if the result is small enough, we can fit it in fast_ac table
; 2066 :             if (k >= -128 && k <= 127)
; 2067 :                fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
; 2068 :          }
; 2069 :       }
; 2070 :    }
; 2071 : }
; 2072 : 
; 2073 : static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
; 2074 : {
; 2075 :    do {
; 2076 :       unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
; 2077 :       if (b == 0xff) {
; 2078 :          int c = stbi__get8(j->s);
; 2079 :          while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
; 2080 :          if (c != 0) {
; 2081 :             j->marker = (unsigned char) c;
; 2082 :             j->nomore = 1;
; 2083 :             return;
; 2084 :          }
; 2085 :       }
; 2086 :       j->code_buffer |= b << (24 - j->code_bits);
; 2087 :       j->code_bits += 8;
; 2088 :    } while (j->code_bits <= 24);
; 2089 : }
; 2090 : 
; 2091 : // (1 << n) - 1
; 2092 : static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
; 2093 : 
; 2094 : // decode a jpeg huffman value from the bitstream
; 2095 : stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
; 2096 : {
; 2097 :    unsigned int temp;
; 2098 :    int c,k;
; 2099 : 
; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2105 :    k = h->fast[c];
; 2106 :    if (k < 255) {
; 2107 :       int s = h->size[k];
; 2108 :       if (s > j->code_bits)
; 2109 :          return -1;
; 2110 :       j->code_buffer <<= s;
; 2111 :       j->code_bits -= s;
; 2112 :       return h->values[k];
; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;
; 2122 :    for (k=FAST_BITS+1 ; ; ++k)
; 2123 :       if (temp < h->maxcode[k])
; 2124 :          break;
; 2125 :    if (k == 17) {
; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;
; 2128 :       return -1;
; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)
; 2132 :       return -1;
; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!
; 2137 :        return -1;
; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;
; 2142 :    j->code_buffer <<= k;
; 2143 :    return h->values[c];
; 2144 : }
; 2145 : 
; 2146 : // bias[n] = (-1<<n) + 1
; 2147 : static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};
; 2148 : 
; 2149 : // combined JPEG 'receive' and JPEG 'extend', since baseline
; 2150 : // always extends everything it receives.
; 2151 : stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
; 2152 : {
; 2153 :    unsigned int k;
; 2154 :    int sgn;
; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
; 2159 :    k = stbi_lrot(j->code_buffer, n);
; 2160 :    j->code_buffer = k & ~stbi__bmask[n];
; 2161 :    k &= stbi__bmask[n];
; 2162 :    j->code_bits -= n;
; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));
; 2164 : }
; 2165 : 
; 2166 : // get some unsigned bits
; 2167 : stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
; 2168 : {
; 2169 :    unsigned int k;
; 2170 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2171 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2172 :    k = stbi_lrot(j->code_buffer, n);
; 2173 :    j->code_buffer = k & ~stbi__bmask[n];
; 2174 :    k &= stbi__bmask[n];
; 2175 :    j->code_bits -= n;
; 2176 :    return k;
; 2177 : }
; 2178 : 
; 2179 : stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
; 2180 : {
; 2181 :    unsigned int k;
; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2184 :    k = j->code_buffer;
; 2185 :    j->code_buffer <<= 1;
; 2186 :    --j->code_bits;
; 2187 :    return k & 0x80000000;
; 2188 : }
; 2189 : 
; 2190 : // given a value that's at position X in the zigzag stream,
; 2191 : // where does it appear in the 8x8 matrix coded as row-major?
; 2192 : static const stbi_uc stbi__jpeg_dezigzag[64+15] =
; 2193 : {
; 2194 :     0,  1,  8, 16,  9,  2,  3, 10,
; 2195 :    17, 24, 32, 25, 18, 11,  4,  5,
; 2196 :    12, 19, 26, 33, 40, 48, 41, 34,
; 2197 :    27, 20, 13,  6,  7, 14, 21, 28,
; 2198 :    35, 42, 49, 56, 57, 50, 43, 36,
; 2199 :    29, 22, 15, 23, 30, 37, 44, 51,
; 2200 :    58, 59, 52, 45, 38, 31, 39, 46,
; 2201 :    53, 60, 61, 54, 47, 55, 62, 63,
; 2202 :    // let corrupt input sample past end
; 2203 :    63, 63, 63, 63, 63, 63, 63, 63,
; 2204 :    63, 63, 63, 63, 63, 63, 63
; 2205 : };
; 2206 : 
; 2207 : // decode one 64-entry block--
; 2208 : static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
; 2209 : {
; 2210 :    int diff,dc,k;
; 2211 :    int t;
; 2212 : 
; 2213 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2214 :    t = stbi__jpeg_huff_decode(j, hdc);
; 2215 :    if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");
; 2216 : 
; 2217 :    // 0 all the ac values now so we can do it 32-bits at a time
; 2218 :    memset(data,0,64*sizeof(data[0]));
; 2219 : 
; 2220 :    diff = t ? stbi__extend_receive(j, t) : 0;
; 2221 :    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");
; 2222 :    dc = j->img_comp[b].dc_pred + diff;
; 2223 :    j->img_comp[b].dc_pred = dc;
; 2224 :    if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2225 :    data[0] = (short) (dc * dequant[0]);
; 2226 : 
; 2227 :    // decode AC components, see JPEG spec
; 2228 :    k = 1;
; 2229 :    do {
; 2230 :       unsigned int zig;
; 2231 :       int c,r,s;
; 2232 :       if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2233 :       c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2234 :       r = fac[c];
; 2235 :       if (r) { // fast-AC path
; 2236 :          k += (r >> 4) & 15; // run
; 2237 :          s = r & 15; // combined length
; 2238 :          if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2239 :          j->code_buffer <<= s;
; 2240 :          j->code_bits -= s;
; 2241 :          // decode into unzigzag'd location
; 2242 :          zig = stbi__jpeg_dezigzag[k++];
; 2243 :          data[zig] = (short) ((r >> 8) * dequant[zig]);
; 2244 :       } else {
; 2245 :          int rs = stbi__jpeg_huff_decode(j, hac);
; 2246 :          if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2247 :          s = rs & 15;
; 2248 :          r = rs >> 4;
; 2249 :          if (s == 0) {
; 2250 :             if (rs != 0xf0) break; // end block
; 2251 :             k += 16;
; 2252 :          } else {
; 2253 :             k += r;
; 2254 :             // decode into unzigzag'd location
; 2255 :             zig = stbi__jpeg_dezigzag[k++];
; 2256 :             data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
; 2257 :          }
; 2258 :       }
; 2259 :    } while (k < 64);
; 2260 :    return 1;
; 2261 : }
; 2262 : 
; 2263 : static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
; 2264 : {
; 2265 :    int diff,dc;
; 2266 :    int t;
; 2267 :    if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2268 : 
; 2269 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2270 : 
; 2271 :    if (j->succ_high == 0) {
; 2272 :       // first scan for DC coefficient, must be first
; 2273 :       memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
; 2274 :       t = stbi__jpeg_huff_decode(j, hdc);
; 2275 :       if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2276 :       diff = t ? stbi__extend_receive(j, t) : 0;
; 2277 : 
; 2278 :       if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");
; 2279 :       dc = j->img_comp[b].dc_pred + diff;
; 2280 :       j->img_comp[b].dc_pred = dc;
; 2281 :       if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2282 :       data[0] = (short) (dc * (1 << j->succ_low));
; 2283 :    } else {
; 2284 :       // refinement scan for DC coefficient
; 2285 :       if (stbi__jpeg_get_bit(j))
; 2286 :          data[0] += (short) (1 << j->succ_low);
; 2287 :    }
; 2288 :    return 1;
; 2289 : }
; 2290 : 
; 2291 : // @OPTIMIZE: store non-zigzagged during the decode passes,
; 2292 : // and only de-zigzag when dequantizing
; 2293 : static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
; 2294 : {
; 2295 :    int k;
; 2296 :    if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2297 : 
; 2298 :    if (j->succ_high == 0) {
; 2299 :       int shift = j->succ_low;
; 2300 : 
; 2301 :       if (j->eob_run) {
; 2302 :          --j->eob_run;
; 2303 :          return 1;
; 2304 :       }
; 2305 : 
; 2306 :       k = j->spec_start;
; 2307 :       do {
; 2308 :          unsigned int zig;
; 2309 :          int c,r,s;
; 2310 :          if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2311 :          c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2312 :          r = fac[c];
; 2313 :          if (r) { // fast-AC path
; 2314 :             k += (r >> 4) & 15; // run
; 2315 :             s = r & 15; // combined length
; 2316 :             if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2317 :             j->code_buffer <<= s;
; 2318 :             j->code_bits -= s;
; 2319 :             zig = stbi__jpeg_dezigzag[k++];
; 2320 :             data[zig] = (short) ((r >> 8) * (1 << shift));
; 2321 :          } else {
; 2322 :             int rs = stbi__jpeg_huff_decode(j, hac);
; 2323 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2324 :             s = rs & 15;
; 2325 :             r = rs >> 4;
; 2326 :             if (s == 0) {
; 2327 :                if (r < 15) {
; 2328 :                   j->eob_run = (1 << r);
; 2329 :                   if (r)
; 2330 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2331 :                   --j->eob_run;
; 2332 :                   break;
; 2333 :                }
; 2334 :                k += 16;
; 2335 :             } else {
; 2336 :                k += r;
; 2337 :                zig = stbi__jpeg_dezigzag[k++];
; 2338 :                data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
; 2339 :             }
; 2340 :          }
; 2341 :       } while (k <= j->spec_end);
; 2342 :    } else {
; 2343 :       // refinement scan for these AC coefficients
; 2344 : 
; 2345 :       short bit = (short) (1 << j->succ_low);
; 2346 : 
; 2347 :       if (j->eob_run) {
; 2348 :          --j->eob_run;
; 2349 :          for (k = j->spec_start; k <= j->spec_end; ++k) {
; 2350 :             short *p = &data[stbi__jpeg_dezigzag[k]];
; 2351 :             if (*p != 0)
; 2352 :                if (stbi__jpeg_get_bit(j))
; 2353 :                   if ((*p & bit)==0) {
; 2354 :                      if (*p > 0)
; 2355 :                         *p += bit;
; 2356 :                      else
; 2357 :                         *p -= bit;
; 2358 :                   }
; 2359 :          }
; 2360 :       } else {
; 2361 :          k = j->spec_start;
; 2362 :          do {
; 2363 :             int r,s;
; 2364 :             int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
; 2365 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2366 :             s = rs & 15;
; 2367 :             r = rs >> 4;
; 2368 :             if (s == 0) {
; 2369 :                if (r < 15) {
; 2370 :                   j->eob_run = (1 << r) - 1;
; 2371 :                   if (r)
; 2372 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2373 :                   r = 64; // force end of block
; 2374 :                } else {
; 2375 :                   // r=15 s=0 should write 16 0s, so we just do
; 2376 :                   // a run of 15 0s and then write s (which is 0),
; 2377 :                   // so we don't have to do anything special here
; 2378 :                }
; 2379 :             } else {
; 2380 :                if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
; 2381 :                // sign bit
; 2382 :                if (stbi__jpeg_get_bit(j))
; 2383 :                   s = bit;
; 2384 :                else
; 2385 :                   s = -bit;
; 2386 :             }
; 2387 : 
; 2388 :             // advance by r
; 2389 :             while (k <= j->spec_end) {
; 2390 :                short *p = &data[stbi__jpeg_dezigzag[k++]];
; 2391 :                if (*p != 0) {
; 2392 :                   if (stbi__jpeg_get_bit(j))
; 2393 :                      if ((*p & bit)==0) {
; 2394 :                         if (*p > 0)
; 2395 :                            *p += bit;
; 2396 :                         else
; 2397 :                            *p -= bit;
; 2398 :                      }
; 2399 :                } else {
; 2400 :                   if (r == 0) {
; 2401 :                      *p = (short) s;
; 2402 :                      break;
; 2403 :                   }
; 2404 :                   --r;
; 2405 :                }
; 2406 :             }
; 2407 :          } while (k <= j->spec_end);
; 2408 :       }
; 2409 :    }
; 2410 :    return 1;
; 2411 : }
; 2412 : 
; 2413 : // take a -128..127 value and stbi__clamp it and convert to 0..255
; 2414 : stbi_inline static stbi_uc stbi__clamp(int x)
; 2415 : {
; 2416 :    // trick to use a single test to catch both cases
; 2417 :    if ((unsigned int) x > 255) {
; 2418 :       if (x < 0) return 0;
; 2419 :       if (x > 255) return 255;
; 2420 :    }
; 2421 :    return (stbi_uc) x;
; 2422 : }
; 2423 : 
; 2424 : #define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
; 2425 : #define stbi__fsh(x)  ((x) * 4096)
; 2426 : 
; 2427 : // derived from jidctint -- DCT_ISLOW
; 2428 : #define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
; 2429 :    int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
; 2430 :    p2 = s2;                                    \
; 2431 :    p3 = s6;                                    \
; 2432 :    p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
; 2433 :    t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
; 2434 :    t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
; 2435 :    p2 = s0;                                    \
; 2436 :    p3 = s4;                                    \
; 2437 :    t0 = stbi__fsh(p2+p3);                      \
; 2438 :    t1 = stbi__fsh(p2-p3);                      \
; 2439 :    x0 = t0+t3;                                 \
; 2440 :    x3 = t0-t3;                                 \
; 2441 :    x1 = t1+t2;                                 \
; 2442 :    x2 = t1-t2;                                 \
; 2443 :    t0 = s7;                                    \
; 2444 :    t1 = s5;                                    \
; 2445 :    t2 = s3;                                    \
; 2446 :    t3 = s1;                                    \
; 2447 :    p3 = t0+t2;                                 \
; 2448 :    p4 = t1+t3;                                 \
; 2449 :    p1 = t0+t3;                                 \
; 2450 :    p2 = t1+t2;                                 \
; 2451 :    p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
; 2452 :    t0 = t0*stbi__f2f( 0.298631336f);           \
; 2453 :    t1 = t1*stbi__f2f( 2.053119869f);           \
; 2454 :    t2 = t2*stbi__f2f( 3.072711026f);           \
; 2455 :    t3 = t3*stbi__f2f( 1.501321110f);           \
; 2456 :    p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
; 2457 :    p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
; 2458 :    p3 = p3*stbi__f2f(-1.961570560f);           \
; 2459 :    p4 = p4*stbi__f2f(-0.390180644f);           \
; 2460 :    t3 += p1+p4;                                \
; 2461 :    t2 += p2+p3;                                \
; 2462 :    t1 += p2+p4;                                \
; 2463 :    t0 += p1+p3;
; 2464 : 
; 2465 : static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
; 2466 : {
; 2467 :    int i,val[64],*v=val;
; 2468 :    stbi_uc *o;
; 2469 :    short *d = data;
; 2470 : 
; 2471 :    // columns
; 2472 :    for (i=0; i < 8; ++i,++d, ++v) {
; 2473 :       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2474 :       if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2475 :            && d[40]==0 && d[48]==0 && d[56]==0) {
; 2476 :          //    no shortcut                 0     seconds
; 2477 :          //    (1|2|3|4|5|6|7)==0          0     seconds
; 2478 :          //    all separate               -0.047 seconds
; 2479 :          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2480 :          int dcterm = d[0]*4;
; 2481 :          v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
; 2482 :       } else {
; 2483 :          STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
; 2484 :          // constants scaled things up by 1<<12; let's bring them back
; 2485 :          // down, but keep 2 extra bits of precision
; 2486 :          x0 += 512; x1 += 512; x2 += 512; x3 += 512;
; 2487 :          v[ 0] = (x0+t3) >> 10;
; 2488 :          v[56] = (x0-t3) >> 10;
; 2489 :          v[ 8] = (x1+t2) >> 10;
; 2490 :          v[48] = (x1-t2) >> 10;
; 2491 :          v[16] = (x2+t1) >> 10;
; 2492 :          v[40] = (x2-t1) >> 10;
; 2493 :          v[24] = (x3+t0) >> 10;
; 2494 :          v[32] = (x3-t0) >> 10;
; 2495 :       }
; 2496 :    }
; 2497 : 
; 2498 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
; 2499 :       // no fast case since the first 1D IDCT spread components out
; 2500 :       STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
; 2501 :       // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2502 :       // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2503 :       // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2504 :       // so we want to round that, which means adding 0.5 * 1<<17,
; 2505 :       // aka 65536. Also, we'll end up with -128 to 127 that we want
; 2506 :       // to encode as 0..255 by adding 128, so we'll add that before the shift
; 2507 :       x0 += 65536 + (128<<17);
; 2508 :       x1 += 65536 + (128<<17);
; 2509 :       x2 += 65536 + (128<<17);
; 2510 :       x3 += 65536 + (128<<17);
; 2511 :       // tried computing the shifts into temps, or'ing the temps to see
; 2512 :       // if any were out of range, but that was slower
; 2513 :       o[0] = stbi__clamp((x0+t3) >> 17);
; 2514 :       o[7] = stbi__clamp((x0-t3) >> 17);
; 2515 :       o[1] = stbi__clamp((x1+t2) >> 17);
; 2516 :       o[6] = stbi__clamp((x1-t2) >> 17);
; 2517 :       o[2] = stbi__clamp((x2+t1) >> 17);
; 2518 :       o[5] = stbi__clamp((x2-t1) >> 17);
; 2519 :       o[3] = stbi__clamp((x3+t0) >> 17);
; 2520 :       o[4] = stbi__clamp((x3-t0) >> 17);
; 2521 :    }
; 2522 : }
; 2523 : 
; 2524 : #ifdef STBI_SSE2
; 2525 : // sse2 integer IDCT. not the fastest possible implementation but it
; 2526 : // produces bit-identical results to the generic C version so it's
; 2527 : // fully "transparent".
; 2528 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2529 : {
; 2530 :    // This is constructed to match our regular (generic) integer IDCT exactly.
; 2531 :    __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2532 :    __m128i tmp;
; 2533 : 
; 2534 :    // dot product constant: even elems=x, odd elems=y
; 2535 :    #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2536 : 
; 2537 :    // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2538 :    // out(1) = c1[even]*x + c1[odd]*y
; 2539 :    #define dct_rot(out0,out1, x,y,c0,c1) \
; 2540 :       __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2541 :       __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2542 :       __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2543 :       __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2544 :       __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2545 :       __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2546 : 
; 2547 :    // out = in << 12  (in 16-bit, out 32-bit)
; 2548 :    #define dct_widen(out, in) \
; 2549 :       __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2550 :       __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2551 : 
; 2552 :    // wide add
; 2553 :    #define dct_wadd(out, a, b) \
; 2554 :       __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2555 :       __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2556 : 
; 2557 :    // wide sub
; 2558 :    #define dct_wsub(out, a, b) \
; 2559 :       __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2560 :       __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2561 : 
; 2562 :    // butterfly a/b, add bias, then shift by "s" and pack
; 2563 :    #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2564 :       { \
; 2565 :          __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2566 :          __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2567 :          dct_wadd(sum, abiased, b); \
; 2568 :          dct_wsub(dif, abiased, b); \
; 2569 :          out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2570 :          out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2571 :       }
; 2572 : 
; 2573 :    // 8-bit interleave step (for transposes)
; 2574 :    #define dct_interleave8(a, b) \
; 2575 :       tmp = a; \
; 2576 :       a = _mm_unpacklo_epi8(a, b); \
; 2577 :       b = _mm_unpackhi_epi8(tmp, b)
; 2578 : 
; 2579 :    // 16-bit interleave step (for transposes)
; 2580 :    #define dct_interleave16(a, b) \
; 2581 :       tmp = a; \
; 2582 :       a = _mm_unpacklo_epi16(a, b); \
; 2583 :       b = _mm_unpackhi_epi16(tmp, b)
; 2584 : 
; 2585 :    #define dct_pass(bias,shift) \
; 2586 :       { \
; 2587 :          /* even part */ \
; 2588 :          dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2589 :          __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2590 :          __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2591 :          dct_widen(t0e, sum04); \
; 2592 :          dct_widen(t1e, dif04); \
; 2593 :          dct_wadd(x0, t0e, t3e); \
; 2594 :          dct_wsub(x3, t0e, t3e); \
; 2595 :          dct_wadd(x1, t1e, t2e); \
; 2596 :          dct_wsub(x2, t1e, t2e); \
; 2597 :          /* odd part */ \
; 2598 :          dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2599 :          dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2600 :          __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2601 :          __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2602 :          dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2603 :          dct_wadd(x4, y0o, y4o); \
; 2604 :          dct_wadd(x5, y1o, y5o); \
; 2605 :          dct_wadd(x6, y2o, y5o); \
; 2606 :          dct_wadd(x7, y3o, y4o); \
; 2607 :          dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2608 :          dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2609 :          dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2610 :          dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2611 :       }
; 2612 : 
; 2613 :    __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
; 2614 :    __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
; 2615 :    __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
; 2616 :    __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
; 2617 :    __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
; 2618 :    __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
; 2619 :    __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
; 2620 :    __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
; 2621 : 
; 2622 :    // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2623 :    __m128i bias_0 = _mm_set1_epi32(512);
; 2624 :    __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
; 2625 : 
; 2626 :    // load
; 2627 :    row0 = _mm_load_si128((const __m128i *) (data + 0*8));
; 2628 :    row1 = _mm_load_si128((const __m128i *) (data + 1*8));
; 2629 :    row2 = _mm_load_si128((const __m128i *) (data + 2*8));
; 2630 :    row3 = _mm_load_si128((const __m128i *) (data + 3*8));
; 2631 :    row4 = _mm_load_si128((const __m128i *) (data + 4*8));
; 2632 :    row5 = _mm_load_si128((const __m128i *) (data + 5*8));
; 2633 :    row6 = _mm_load_si128((const __m128i *) (data + 6*8));
; 2634 :    row7 = _mm_load_si128((const __m128i *) (data + 7*8));
; 2635 : 
; 2636 :    // column pass
; 2637 :    dct_pass(bias_0, 10);
; 2638 : 
; 2639 :    {
; 2640 :       // 16bit 8x8 transpose pass 1
; 2641 :       dct_interleave16(row0, row4);
; 2642 :       dct_interleave16(row1, row5);
; 2643 :       dct_interleave16(row2, row6);
; 2644 :       dct_interleave16(row3, row7);
; 2645 : 
; 2646 :       // transpose pass 2
; 2647 :       dct_interleave16(row0, row2);
; 2648 :       dct_interleave16(row1, row3);
; 2649 :       dct_interleave16(row4, row6);
; 2650 :       dct_interleave16(row5, row7);
; 2651 : 
; 2652 :       // transpose pass 3
; 2653 :       dct_interleave16(row0, row1);
; 2654 :       dct_interleave16(row2, row3);
; 2655 :       dct_interleave16(row4, row5);
; 2656 :       dct_interleave16(row6, row7);
; 2657 :    }
; 2658 : 
; 2659 :    // row pass
; 2660 :    dct_pass(bias_1, 17);
; 2661 : 
; 2662 :    {
; 2663 :       // pack
; 2664 :       __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
; 2665 :       __m128i p1 = _mm_packus_epi16(row2, row3);
; 2666 :       __m128i p2 = _mm_packus_epi16(row4, row5);
; 2667 :       __m128i p3 = _mm_packus_epi16(row6, row7);
; 2668 : 
; 2669 :       // 8bit 8x8 transpose pass 1
; 2670 :       dct_interleave8(p0, p2); // a0e0a1e1...
; 2671 :       dct_interleave8(p1, p3); // c0g0c1g1...
; 2672 : 
; 2673 :       // transpose pass 2
; 2674 :       dct_interleave8(p0, p1); // a0c0e0g0...
; 2675 :       dct_interleave8(p2, p3); // b0d0f0h0...
; 2676 : 
; 2677 :       // transpose pass 3
; 2678 :       dct_interleave8(p0, p2); // a0b0c0d0...
; 2679 :       dct_interleave8(p1, p3); // a4b4c4d4...
; 2680 : 
; 2681 :       // store
; 2682 :       _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
; 2683 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
; 2684 :       _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
; 2685 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
; 2686 :       _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
; 2687 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
; 2688 :       _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
; 2689 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
; 2690 :    }
; 2691 : 
; 2692 : #undef dct_const
; 2693 : #undef dct_rot
; 2694 : #undef dct_widen
; 2695 : #undef dct_wadd
; 2696 : #undef dct_wsub
; 2697 : #undef dct_bfly32o
; 2698 : #undef dct_interleave8
; 2699 : #undef dct_interleave16
; 2700 : #undef dct_pass
; 2701 : }
; 2702 : 
; 2703 : #endif // STBI_SSE2
; 2704 : 
; 2705 : #ifdef STBI_NEON
; 2706 : 
; 2707 : // NEON integer IDCT. should produce bit-identical
; 2708 : // results to the generic C version.
; 2709 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2710 : {
; 2711 :    int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;
; 2712 : 
; 2713 :    int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
; 2714 :    int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
; 2715 :    int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
; 2716 :    int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
; 2717 :    int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
; 2718 :    int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
; 2719 :    int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
; 2720 :    int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
; 2721 :    int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
; 2722 :    int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
; 2723 :    int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
; 2724 :    int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));
; 2725 : 
; 2726 : #define dct_long_mul(out, inq, coeff) \
; 2727 :    int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
; 2728 :    int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)
; 2729 : 
; 2730 : #define dct_long_mac(out, acc, inq, coeff) \
; 2731 :    int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
; 2732 :    int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)
; 2733 : 
; 2734 : #define dct_widen(out, inq) \
; 2735 :    int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
; 2736 :    int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)
; 2737 : 
; 2738 : // wide add
; 2739 : #define dct_wadd(out, a, b) \
; 2740 :    int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
; 2741 :    int32x4_t out##_h = vaddq_s32(a##_h, b##_h)
; 2742 : 
; 2743 : // wide sub
; 2744 : #define dct_wsub(out, a, b) \
; 2745 :    int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
; 2746 :    int32x4_t out##_h = vsubq_s32(a##_h, b##_h)
; 2747 : 
; 2748 : // butterfly a/b, then shift using "shiftop" by "s" and pack
; 2749 : #define dct_bfly32o(out0,out1, a,b,shiftop,s) \
; 2750 :    { \
; 2751 :       dct_wadd(sum, a, b); \
; 2752 :       dct_wsub(dif, a, b); \
; 2753 :       out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
; 2754 :       out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
; 2755 :    }
; 2756 : 
; 2757 : #define dct_pass(shiftop, shift) \
; 2758 :    { \
; 2759 :       /* even part */ \
; 2760 :       int16x8_t sum26 = vaddq_s16(row2, row6); \
; 2761 :       dct_long_mul(p1e, sum26, rot0_0); \
; 2762 :       dct_long_mac(t2e, p1e, row6, rot0_1); \
; 2763 :       dct_long_mac(t3e, p1e, row2, rot0_2); \
; 2764 :       int16x8_t sum04 = vaddq_s16(row0, row4); \
; 2765 :       int16x8_t dif04 = vsubq_s16(row0, row4); \
; 2766 :       dct_widen(t0e, sum04); \
; 2767 :       dct_widen(t1e, dif04); \
; 2768 :       dct_wadd(x0, t0e, t3e); \
; 2769 :       dct_wsub(x3, t0e, t3e); \
; 2770 :       dct_wadd(x1, t1e, t2e); \
; 2771 :       dct_wsub(x2, t1e, t2e); \
; 2772 :       /* odd part */ \
; 2773 :       int16x8_t sum15 = vaddq_s16(row1, row5); \
; 2774 :       int16x8_t sum17 = vaddq_s16(row1, row7); \
; 2775 :       int16x8_t sum35 = vaddq_s16(row3, row5); \
; 2776 :       int16x8_t sum37 = vaddq_s16(row3, row7); \
; 2777 :       int16x8_t sumodd = vaddq_s16(sum17, sum35); \
; 2778 :       dct_long_mul(p5o, sumodd, rot1_0); \
; 2779 :       dct_long_mac(p1o, p5o, sum17, rot1_1); \
; 2780 :       dct_long_mac(p2o, p5o, sum35, rot1_2); \
; 2781 :       dct_long_mul(p3o, sum37, rot2_0); \
; 2782 :       dct_long_mul(p4o, sum15, rot2_1); \
; 2783 :       dct_wadd(sump13o, p1o, p3o); \
; 2784 :       dct_wadd(sump24o, p2o, p4o); \
; 2785 :       dct_wadd(sump23o, p2o, p3o); \
; 2786 :       dct_wadd(sump14o, p1o, p4o); \
; 2787 :       dct_long_mac(x4, sump13o, row7, rot3_0); \
; 2788 :       dct_long_mac(x5, sump24o, row5, rot3_1); \
; 2789 :       dct_long_mac(x6, sump23o, row3, rot3_2); \
; 2790 :       dct_long_mac(x7, sump14o, row1, rot3_3); \
; 2791 :       dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
; 2792 :       dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
; 2793 :       dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
; 2794 :       dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
; 2795 :    }
; 2796 : 
; 2797 :    // load
; 2798 :    row0 = vld1q_s16(data + 0*8);
; 2799 :    row1 = vld1q_s16(data + 1*8);
; 2800 :    row2 = vld1q_s16(data + 2*8);
; 2801 :    row3 = vld1q_s16(data + 3*8);
; 2802 :    row4 = vld1q_s16(data + 4*8);
; 2803 :    row5 = vld1q_s16(data + 5*8);
; 2804 :    row6 = vld1q_s16(data + 6*8);
; 2805 :    row7 = vld1q_s16(data + 7*8);
; 2806 : 
; 2807 :    // add DC bias
; 2808 :    row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));
; 2809 : 
; 2810 :    // column pass
; 2811 :    dct_pass(vrshrn_n_s32, 10);
; 2812 : 
; 2813 :    // 16bit 8x8 transpose
; 2814 :    {
; 2815 : // these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
; 2816 : // whether compilers actually get this is another story, sadly.
; 2817 : #define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
; 2818 : #define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
; 2819 : #define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }
; 2820 : 
; 2821 :       // pass 1
; 2822 :       dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
; 2823 :       dct_trn16(row2, row3);
; 2824 :       dct_trn16(row4, row5);
; 2825 :       dct_trn16(row6, row7);
; 2826 : 
; 2827 :       // pass 2
; 2828 :       dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
; 2829 :       dct_trn32(row1, row3);
; 2830 :       dct_trn32(row4, row6);
; 2831 :       dct_trn32(row5, row7);
; 2832 : 
; 2833 :       // pass 3
; 2834 :       dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
; 2835 :       dct_trn64(row1, row5);
; 2836 :       dct_trn64(row2, row6);
; 2837 :       dct_trn64(row3, row7);
; 2838 : 
; 2839 : #undef dct_trn16
; 2840 : #undef dct_trn32
; 2841 : #undef dct_trn64
; 2842 :    }
; 2843 : 
; 2844 :    // row pass
; 2845 :    // vrshrn_n_s32 only supports shifts up to 16, we need
; 2846 :    // 17. so do a non-rounding shift of 16 first then follow
; 2847 :    // up with a rounding shift by 1.
; 2848 :    dct_pass(vshrn_n_s32, 16);
; 2849 : 
; 2850 :    {
; 2851 :       // pack and round
; 2852 :       uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
; 2853 :       uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
; 2854 :       uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
; 2855 :       uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
; 2856 :       uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
; 2857 :       uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
; 2858 :       uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
; 2859 :       uint8x8_t p7 = vqrshrun_n_s16(row7, 1);
; 2860 : 
; 2861 :       // again, these can translate into one instruction, but often don't.
; 2862 : #define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
; 2863 : #define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
; 2864 : #define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }
; 2865 : 
; 2866 :       // sadly can't use interleaved stores here since we only write
; 2867 :       // 8 bytes to each scan line!
; 2868 : 
; 2869 :       // 8x8 8-bit transpose pass 1
; 2870 :       dct_trn8_8(p0, p1);
; 2871 :       dct_trn8_8(p2, p3);
; 2872 :       dct_trn8_8(p4, p5);
; 2873 :       dct_trn8_8(p6, p7);
; 2874 : 
; 2875 :       // pass 2
; 2876 :       dct_trn8_16(p0, p2);
; 2877 :       dct_trn8_16(p1, p3);
; 2878 :       dct_trn8_16(p4, p6);
; 2879 :       dct_trn8_16(p5, p7);
; 2880 : 
; 2881 :       // pass 3
; 2882 :       dct_trn8_32(p0, p4);
; 2883 :       dct_trn8_32(p1, p5);
; 2884 :       dct_trn8_32(p2, p6);
; 2885 :       dct_trn8_32(p3, p7);
; 2886 : 
; 2887 :       // store
; 2888 :       vst1_u8(out, p0); out += out_stride;
; 2889 :       vst1_u8(out, p1); out += out_stride;
; 2890 :       vst1_u8(out, p2); out += out_stride;
; 2891 :       vst1_u8(out, p3); out += out_stride;
; 2892 :       vst1_u8(out, p4); out += out_stride;
; 2893 :       vst1_u8(out, p5); out += out_stride;
; 2894 :       vst1_u8(out, p6); out += out_stride;
; 2895 :       vst1_u8(out, p7);
; 2896 : 
; 2897 : #undef dct_trn8_8
; 2898 : #undef dct_trn8_16
; 2899 : #undef dct_trn8_32
; 2900 :    }
; 2901 : 
; 2902 : #undef dct_long_mul
; 2903 : #undef dct_long_mac
; 2904 : #undef dct_widen
; 2905 : #undef dct_wadd
; 2906 : #undef dct_wsub
; 2907 : #undef dct_bfly32o
; 2908 : #undef dct_pass
; 2909 : }
; 2910 : 
; 2911 : #endif // STBI_NEON
; 2912 : 
; 2913 : #define STBI__MARKER_none  0xff
; 2914 : // if there's a pending marker from the entropy stream, return that
; 2915 : // otherwise, fetch from the stream and get a marker. if there's no
; 2916 : // marker, return 0xff, which is never a valid marker value
; 2917 : static stbi_uc stbi__get_marker(stbi__jpeg *j)
; 2918 : {
; 2919 :    stbi_uc x;
; 2920 :    if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
; 2921 :    x = stbi__get8(j->s);
; 2922 :    if (x != 0xff) return STBI__MARKER_none;
; 2923 :    while (x == 0xff)
; 2924 :       x = stbi__get8(j->s); // consume repeated 0xff fill bytes
; 2925 :    return x;
; 2926 : }
; 2927 : 
; 2928 : // in each scan, we'll have scan_n components, and the order
; 2929 : // of the components is specified by order[]
; 2930 : #define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
; 2931 : 
; 2932 : // after a restart interval, stbi__jpeg_reset the entropy decoder and
; 2933 : // the dc prediction
; 2934 : static void stbi__jpeg_reset(stbi__jpeg *j)
; 2935 : {
; 2936 :    j->code_bits = 0;
; 2937 :    j->code_buffer = 0;
; 2938 :    j->nomore = 0;
; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
; 2940 :    j->marker = STBI__MARKER_none;
; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
; 2942 :    j->eob_run = 0;
; 2943 :    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2944 :    // since we don't even allow 1<<30 pixels
; 2945 : }
; 2946 : 
; 2947 : static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
; 2948 : {
; 2949 :    stbi__jpeg_reset(z);
; 2950 :    if (!z->progressive) {
; 2951 :       if (z->scan_n == 1) {
; 2952 :          int i,j;
; 2953 :          STBI_SIMD_ALIGN(short, data[64]);
; 2954 :          int n = z->order[0];
; 2955 :          // non-interleaved data, we just need to process one block at a time,
; 2956 :          // in trivial scanline order
; 2957 :          // number of blocks to do just depends on how many actual "pixels" this
; 2958 :          // component has, independent of interleaved MCU blocking and such
; 2959 :          int w = (z->img_comp[n].x+7) >> 3;
; 2960 :          int h = (z->img_comp[n].y+7) >> 3;
; 2961 :          for (j=0; j < h; ++j) {
; 2962 :             for (i=0; i < w; ++i) {
; 2963 :                int ha = z->img_comp[n].ha;
; 2964 :                if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2965 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 2966 :                // every data block is an MCU, so countdown the restart interval
; 2967 :                if (--z->todo <= 0) {
; 2968 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 2969 :                   // if it's NOT a restart, then just bail, so we get corrupt data
; 2970 :                   // rather than no data
; 2971 :                   if (!STBI__RESTART(z->marker)) return 1;
; 2972 :                   stbi__jpeg_reset(z);
; 2973 :                }
; 2974 :             }
; 2975 :          }
; 2976 :          return 1;
; 2977 :       } else { // interleaved
; 2978 :          int i,j,k,x,y;
; 2979 :          STBI_SIMD_ALIGN(short, data[64]);
; 2980 :          for (j=0; j < z->img_mcu_y; ++j) {
; 2981 :             for (i=0; i < z->img_mcu_x; ++i) {
; 2982 :                // scan an interleaved mcu... process scan_n components in order
; 2983 :                for (k=0; k < z->scan_n; ++k) {
; 2984 :                   int n = z->order[k];
; 2985 :                   // scan out an mcu's worth of this component; that's just determined
; 2986 :                   // by the basic H and V specified for the component
; 2987 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 2988 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 2989 :                         int x2 = (i*z->img_comp[n].h + x)*8;
; 2990 :                         int y2 = (j*z->img_comp[n].v + y)*8;
; 2991 :                         int ha = z->img_comp[n].ha;
; 2992 :                         if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2993 :                         z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
; 2994 :                      }
; 2995 :                   }
; 2996 :                }
; 2997 :                // after all interleaved components, that's an interleaved MCU,
; 2998 :                // so now count down the restart interval
; 2999 :                if (--z->todo <= 0) {
; 3000 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3001 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3002 :                   stbi__jpeg_reset(z);
; 3003 :                }
; 3004 :             }
; 3005 :          }
; 3006 :          return 1;
; 3007 :       }
; 3008 :    } else {
; 3009 :       if (z->scan_n == 1) {
; 3010 :          int i,j;
; 3011 :          int n = z->order[0];
; 3012 :          // non-interleaved data, we just need to process one block at a time,
; 3013 :          // in trivial scanline order
; 3014 :          // number of blocks to do just depends on how many actual "pixels" this
; 3015 :          // component has, independent of interleaved MCU blocking and such
; 3016 :          int w = (z->img_comp[n].x+7) >> 3;
; 3017 :          int h = (z->img_comp[n].y+7) >> 3;
; 3018 :          for (j=0; j < h; ++j) {
; 3019 :             for (i=0; i < w; ++i) {
; 3020 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3021 :                if (z->spec_start == 0) {
; 3022 :                   if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3023 :                      return 0;
; 3024 :                } else {
; 3025 :                   int ha = z->img_comp[n].ha;
; 3026 :                   if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
; 3027 :                      return 0;
; 3028 :                }
; 3029 :                // every data block is an MCU, so countdown the restart interval
; 3030 :                if (--z->todo <= 0) {
; 3031 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3032 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3033 :                   stbi__jpeg_reset(z);
; 3034 :                }
; 3035 :             }
; 3036 :          }
; 3037 :          return 1;
; 3038 :       } else { // interleaved
; 3039 :          int i,j,k,x,y;
; 3040 :          for (j=0; j < z->img_mcu_y; ++j) {
; 3041 :             for (i=0; i < z->img_mcu_x; ++i) {
; 3042 :                // scan an interleaved mcu... process scan_n components in order
; 3043 :                for (k=0; k < z->scan_n; ++k) {
; 3044 :                   int n = z->order[k];
; 3045 :                   // scan out an mcu's worth of this component; that's just determined
; 3046 :                   // by the basic H and V specified for the component
; 3047 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 3048 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 3049 :                         int x2 = (i*z->img_comp[n].h + x);
; 3050 :                         int y2 = (j*z->img_comp[n].v + y);
; 3051 :                         short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
; 3052 :                         if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3053 :                            return 0;
; 3054 :                      }
; 3055 :                   }
; 3056 :                }
; 3057 :                // after all interleaved components, that's an interleaved MCU,
; 3058 :                // so now count down the restart interval
; 3059 :                if (--z->todo <= 0) {
; 3060 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3061 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3062 :                   stbi__jpeg_reset(z);
; 3063 :                }
; 3064 :             }
; 3065 :          }
; 3066 :          return 1;
; 3067 :       }
; 3068 :    }
; 3069 : }
; 3070 : 
; 3071 : static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
; 3072 : {
; 3073 :    int i;
; 3074 :    for (i=0; i < 64; ++i)
; 3075 :       data[i] *= dequant[i];
; 3076 : }
; 3077 : 
; 3078 : static void stbi__jpeg_finish(stbi__jpeg *z)
; 3079 : {
; 3080 :    if (z->progressive) {
; 3081 :       // dequantize and idct the data
; 3082 :       int i,j,n;
; 3083 :       for (n=0; n < z->s->img_n; ++n) {
; 3084 :          int w = (z->img_comp[n].x+7) >> 3;
; 3085 :          int h = (z->img_comp[n].y+7) >> 3;
; 3086 :          for (j=0; j < h; ++j) {
; 3087 :             for (i=0; i < w; ++i) {
; 3088 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3089 :                stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
; 3090 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 3091 :             }
; 3092 :          }
; 3093 :       }
; 3094 :    }
; 3095 : }
; 3096 : 
; 3097 : static int stbi__process_marker(stbi__jpeg *z, int m)
; 3098 : {
; 3099 :    int L;
; 3100 :    switch (m) {
; 3101 :       case STBI__MARKER_none: // no marker found
; 3102 :          return stbi__err("expected marker","Corrupt JPEG");
; 3103 : 
; 3104 :       case 0xDD: // DRI - specify restart interval
; 3105 :          if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
; 3106 :          z->restart_interval = stbi__get16be(z->s);
; 3107 :          return 1;
; 3108 : 
; 3109 :       case 0xDB: // DQT - define quantization table
; 3110 :          L = stbi__get16be(z->s)-2;
; 3111 :          while (L > 0) {
; 3112 :             int q = stbi__get8(z->s);
; 3113 :             int p = q >> 4, sixteen = (p != 0);
; 3114 :             int t = q & 15,i;
; 3115 :             if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
; 3116 :             if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");
; 3117 : 
; 3118 :             for (i=0; i < 64; ++i)
; 3119 :                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
; 3120 :             L -= (sixteen ? 129 : 65);
; 3121 :          }
; 3122 :          return L==0;
; 3123 : 
; 3124 :       case 0xC4: // DHT - define huffman table
; 3125 :          L = stbi__get16be(z->s)-2;
; 3126 :          while (L > 0) {
; 3127 :             stbi_uc *v;
; 3128 :             int sizes[16],i,n=0;
; 3129 :             int q = stbi__get8(z->s);
; 3130 :             int tc = q >> 4;
; 3131 :             int th = q & 15;
; 3132 :             if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
; 3133 :             for (i=0; i < 16; ++i) {
; 3134 :                sizes[i] = stbi__get8(z->s);
; 3135 :                n += sizes[i];
; 3136 :             }
; 3137 :             if(n > 256) return stbi__err("bad DHT header","Corrupt JPEG"); // Loop over i < n would write past end of values!
; 3138 :             L -= 17;
; 3139 :             if (tc == 0) {
; 3140 :                if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
; 3141 :                v = z->huff_dc[th].values;
; 3142 :             } else {
; 3143 :                if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
; 3144 :                v = z->huff_ac[th].values;
; 3145 :             }
; 3146 :             for (i=0; i < n; ++i)
; 3147 :                v[i] = stbi__get8(z->s);
; 3148 :             if (tc != 0)
; 3149 :                stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
; 3150 :             L -= n;
; 3151 :          }
; 3152 :          return L==0;
; 3153 :    }
; 3154 : 
; 3155 :    // check for comment block or APP blocks
; 3156 :    if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
; 3157 :       L = stbi__get16be(z->s);
; 3158 :       if (L < 2) {
; 3159 :          if (m == 0xFE)
; 3160 :             return stbi__err("bad COM len","Corrupt JPEG");
; 3161 :          else
; 3162 :             return stbi__err("bad APP len","Corrupt JPEG");
; 3163 :       }
; 3164 :       L -= 2;
; 3165 : 
; 3166 :       if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
; 3167 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3168 :          int ok = 1;
; 3169 :          int i;
; 3170 :          for (i=0; i < 5; ++i)
; 3171 :             if (stbi__get8(z->s) != tag[i])
; 3172 :                ok = 0;
; 3173 :          L -= 5;
; 3174 :          if (ok)
; 3175 :             z->jfif = 1;
; 3176 :       } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;
; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)
; 3181 :             if (stbi__get8(z->s) != tag[i])
; 3182 :                ok = 0;
; 3183 :          L -= 6;
; 3184 :          if (ok) {
; 3185 :             stbi__get8(z->s); // version
; 3186 :             stbi__get16be(z->s); // flags0
; 3187 :             stbi__get16be(z->s); // flags1
; 3188 :             z->app14_color_transform = stbi__get8(z->s); // color transform
; 3189 :             L -= 6;
; 3190 :          }
; 3191 :       }
; 3192 : 
; 3193 :       stbi__skip(z->s, L);
; 3194 :       return 1;
; 3195 :    }
; 3196 : 
; 3197 :    return stbi__err("unknown marker","Corrupt JPEG");
; 3198 : }
; 3199 : 
; 3200 : // after we see SOS
; 3201 : static int stbi__process_scan_header(stbi__jpeg *z)
; 3202 : {
; 3203 :    int i;
; 3204 :    int Ls = stbi__get16be(z->s);
; 3205 :    z->scan_n = stbi__get8(z->s);
; 3206 :    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
; 3207 :    if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
; 3208 :    for (i=0; i < z->scan_n; ++i) {
; 3209 :       int id = stbi__get8(z->s), which;
; 3210 :       int q = stbi__get8(z->s);
; 3211 :       for (which = 0; which < z->s->img_n; ++which)
; 3212 :          if (z->img_comp[which].id == id)
; 3213 :             break;
; 3214 :       if (which == z->s->img_n) return 0; // no match
; 3215 :       z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
; 3216 :       z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
; 3217 :       z->order[i] = which;
; 3218 :    }
; 3219 : 
; 3220 :    {
; 3221 :       int aa;
; 3222 :       z->spec_start = stbi__get8(z->s);
; 3223 :       z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
; 3224 :       aa = stbi__get8(z->s);
; 3225 :       z->succ_high = (aa >> 4);
; 3226 :       z->succ_low  = (aa & 15);
; 3227 :       if (z->progressive) {
; 3228 :          if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
; 3229 :             return stbi__err("bad SOS", "Corrupt JPEG");
; 3230 :       } else {
; 3231 :          if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3232 :          if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3233 :          z->spec_end = 63;
; 3234 :       }
; 3235 :    }
; 3236 : 
; 3237 :    return 1;
; 3238 : }
; 3239 : 
; 3240 : static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
; 3241 : {
; 3242 :    int i;
; 3243 :    for (i=0; i < ncomp; ++i) {
; 3244 :       if (z->img_comp[i].raw_data) {
; 3245 :          STBI_FREE(z->img_comp[i].raw_data);
; 3246 :          z->img_comp[i].raw_data = NULL;
; 3247 :          z->img_comp[i].data = NULL;
; 3248 :       }
; 3249 :       if (z->img_comp[i].raw_coeff) {
; 3250 :          STBI_FREE(z->img_comp[i].raw_coeff);
; 3251 :          z->img_comp[i].raw_coeff = 0;
; 3252 :          z->img_comp[i].coeff = 0;
; 3253 :       }
; 3254 :       if (z->img_comp[i].linebuf) {
; 3255 :          STBI_FREE(z->img_comp[i].linebuf);
; 3256 :          z->img_comp[i].linebuf = NULL;
; 3257 :       }
; 3258 :    }
; 3259 :    return why;
; 3260 : }
; 3261 : 
; 3262 : static int stbi__process_frame_header(stbi__jpeg *z, int scan)
; 3263 : {
; 3264 :    stbi__context *s = z->s;
; 3265 :    int Lf,p,i,q, h_max=1,v_max=1,c;
; 3266 :    Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
; 3267 :    p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
; 3268 :    s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
; 3269 :    s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
; 3270 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 3271 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 3272 :    c = stbi__get8(s);
; 3273 :    if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");
; 3274 :    s->img_n = c;
; 3275 :    for (i=0; i < c; ++i) {
; 3276 :       z->img_comp[i].data = NULL;
; 3277 :       z->img_comp[i].linebuf = NULL;
; 3278 :    }
; 3279 : 
; 3280 :    if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");
; 3281 : 
; 3282 :    z->rgb = 0;
; 3283 :    for (i=0; i < s->img_n; ++i) {
; 3284 :       static const unsigned char rgb[3] = { 'R', 'G', 'B' };
; 3285 :       z->img_comp[i].id = stbi__get8(s);
; 3286 :       if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
; 3287 :          ++z->rgb;
; 3288 :       q = stbi__get8(s);
; 3289 :       z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
; 3290 :       z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
; 3291 :       z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
; 3292 :    }
; 3293 : 
; 3294 :    if (scan != STBI__SCAN_load) return 1;
; 3295 : 
; 3296 :    if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");
; 3297 : 
; 3298 :    for (i=0; i < s->img_n; ++i) {
; 3299 :       if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
; 3300 :       if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
; 3301 :    }
; 3302 : 
; 3303 :    // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
; 3304 :    // and I've never seen a non-corrupted JPEG file actually use them
; 3305 :    for (i=0; i < s->img_n; ++i) {
; 3306 :       if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");
; 3307 :       if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");
; 3308 :    }
; 3309 : 
; 3310 :    // compute interleaved mcu info
; 3311 :    z->img_h_max = h_max;
; 3312 :    z->img_v_max = v_max;
; 3313 :    z->img_mcu_w = h_max * 8;
; 3314 :    z->img_mcu_h = v_max * 8;
; 3315 :    // these sizes can't be more than 17 bits
; 3316 :    z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
; 3317 :    z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;
; 3318 : 
; 3319 :    for (i=0; i < s->img_n; ++i) {
; 3320 :       // number of effective pixels (e.g. for non-interleaved MCU)
; 3321 :       z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
; 3322 :       z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
; 3323 :       // to simplify generation, we'll allocate enough memory to decode
; 3324 :       // the bogus oversized data from using interleaved MCUs and their
; 3325 :       // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
; 3326 :       // discard the extra data until colorspace conversion
; 3327 :       //
; 3328 :       // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
; 3329 :       // so these muls can't overflow with 32-bit ints (which we require)
; 3330 :       z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
; 3331 :       z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
; 3332 :       z->img_comp[i].coeff = 0;
; 3333 :       z->img_comp[i].raw_coeff = 0;
; 3334 :       z->img_comp[i].linebuf = NULL;
; 3335 :       z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
; 3336 :       if (z->img_comp[i].raw_data == NULL)
; 3337 :          return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
; 3338 :       // align blocks for idct using mmx/sse
; 3339 :       z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
; 3340 :       if (z->progressive) {
; 3341 :          // w2, h2 are multiples of 8 (see above)
; 3342 :          z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
; 3343 :          z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
; 3344 :          z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
; 3345 :          if (z->img_comp[i].raw_coeff == NULL)
; 3346 :             return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
; 3347 :          z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
; 3348 :       }
; 3349 :    }
; 3350 : 
; 3351 :    return 1;
; 3352 : }
; 3353 : 
; 3354 : // use comparisons since in some cases we handle more than one case (e.g. SOF)
; 3355 : #define stbi__DNL(x)         ((x) == 0xdc)
; 3356 : #define stbi__SOI(x)         ((x) == 0xd8)
; 3357 : #define stbi__EOI(x)         ((x) == 0xd9)
; 3358 : #define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
; 3359 : #define stbi__SOS(x)         ((x) == 0xda)
; 3360 : 
; 3361 : #define stbi__SOF_progressive(x)   ((x) == 0xc2)
; 3362 : 
; 3363 : static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
; 3364 : {
; 3365 :    int m;
; 3366 :    z->jfif = 0;
; 3367 :    z->app14_color_transform = -1; // valid values are 0,1,2
; 3368 :    z->marker = STBI__MARKER_none; // initialize cached marker to empty
; 3369 :    m = stbi__get_marker(z);
; 3370 :    if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
; 3371 :    if (scan == STBI__SCAN_type) return 1;
; 3372 :    m = stbi__get_marker(z);
; 3373 :    while (!stbi__SOF(m)) {
; 3374 :       if (!stbi__process_marker(z,m)) return 0;
; 3375 :       m = stbi__get_marker(z);
; 3376 :       while (m == STBI__MARKER_none) {
; 3377 :          // some files have extra padding after their blocks, so ok, we'll scan
; 3378 :          if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
; 3379 :          m = stbi__get_marker(z);
; 3380 :       }
; 3381 :    }
; 3382 :    z->progressive = stbi__SOF_progressive(m);
; 3383 :    if (!stbi__process_frame_header(z, scan)) return 0;
; 3384 :    return 1;
; 3385 : }
; 3386 : 
; 3387 : static int stbi__skip_jpeg_junk_at_end(stbi__jpeg *j)
; 3388 : {
; 3389 :    // some JPEGs have junk at end, skip over it but if we find what looks
; 3390 :    // like a valid marker, resume there
; 3391 :    while (!stbi__at_eof(j->s)) {
; 3392 :       int x = stbi__get8(j->s);
; 3393 :       while (x == 255) { // might be a marker
; 3394 :          if (stbi__at_eof(j->s)) return STBI__MARKER_none;
; 3395 :          x = stbi__get8(j->s);
; 3396 :          if (x != 0x00 && x != 0xff) {
; 3397 :             // not a stuffed zero or lead-in to another marker, looks
; 3398 :             // like an actual marker, return it
; 3399 :             return x;
; 3400 :          }
; 3401 :          // stuffed zero has x=0 now which ends the loop, meaning we go
; 3402 :          // back to regular scan loop.
; 3403 :          // repeated 0xff keeps trying to read the next byte of the marker.
; 3404 :       }
; 3405 :    }
; 3406 :    return STBI__MARKER_none;
; 3407 : }
; 3408 : 
; 3409 : // decode image to YCbCr format
; 3410 : static int stbi__decode_jpeg_image(stbi__jpeg *j)
; 3411 : {
; 3412 :    int m;
; 3413 :    for (m = 0; m < 4; m++) {
; 3414 :       j->img_comp[m].raw_data = NULL;
; 3415 :       j->img_comp[m].raw_coeff = NULL;
; 3416 :    }
; 3417 :    j->restart_interval = 0;
; 3418 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
; 3419 :    m = stbi__get_marker(j);
; 3420 :    while (!stbi__EOI(m)) {
; 3421 :       if (stbi__SOS(m)) {
; 3422 :          if (!stbi__process_scan_header(j)) return 0;
; 3423 :          if (!stbi__parse_entropy_coded_data(j)) return 0;
; 3424 :          if (j->marker == STBI__MARKER_none ) {
; 3425 :          j->marker = stbi__skip_jpeg_junk_at_end(j);
; 3426 :             // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
; 3427 :          }
; 3428 :          m = stbi__get_marker(j);
; 3429 :          if (STBI__RESTART(m))
; 3430 :             m = stbi__get_marker(j);
; 3431 :       } else if (stbi__DNL(m)) {
; 3432 :          int Ld = stbi__get16be(j->s);
; 3433 :          stbi__uint32 NL = stbi__get16be(j->s);
; 3434 :          if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
; 3435 :          if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
; 3436 :          m = stbi__get_marker(j);
; 3437 :       } else {
; 3438 :          if (!stbi__process_marker(j, m)) return 1;
; 3439 :          m = stbi__get_marker(j);
; 3440 :       }
; 3441 :    }
; 3442 :    if (j->progressive)
; 3443 :       stbi__jpeg_finish(j);
; 3444 :    return 1;
; 3445 : }
; 3446 : 
; 3447 : // static jfif-centered resampling (across block boundaries)
; 3448 : 
; 3449 : typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
; 3450 :                                     int w, int hs);
; 3451 : 
; 3452 : #define stbi__div4(x) ((stbi_uc) ((x) >> 2))
; 3453 : 
; 3454 : static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3455 : {
; 3456 :    STBI_NOTUSED(out);
; 3457 :    STBI_NOTUSED(in_far);
; 3458 :    STBI_NOTUSED(w);
; 3459 :    STBI_NOTUSED(hs);
; 3460 :    return in_near;
; 3461 : }
; 3462 : 
; 3463 : static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3464 : {
; 3465 :    // need to generate two samples vertically for every one in input
; 3466 :    int i;
; 3467 :    STBI_NOTUSED(hs);
; 3468 :    for (i=0; i < w; ++i)
; 3469 :       out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
; 3470 :    return out;
; 3471 : }
; 3472 : 
; 3473 : static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3474 : {
; 3475 :    // need to generate two samples horizontally for every one in input
; 3476 :    int i;
; 3477 :    stbi_uc *input = in_near;
; 3478 : 
; 3479 :    if (w == 1) {
; 3480 :       // if only one sample, can't do any interpolation
; 3481 :       out[0] = out[1] = input[0];
; 3482 :       return out;
; 3483 :    }
; 3484 : 
; 3485 :    out[0] = input[0];
; 3486 :    out[1] = stbi__div4(input[0]*3 + input[1] + 2);
; 3487 :    for (i=1; i < w-1; ++i) {
; 3488 :       int n = 3*input[i]+2;
; 3489 :       out[i*2+0] = stbi__div4(n+input[i-1]);
; 3490 :       out[i*2+1] = stbi__div4(n+input[i+1]);
; 3491 :    }
; 3492 :    out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
; 3493 :    out[i*2+1] = input[w-1];
; 3494 : 
; 3495 :    STBI_NOTUSED(in_far);
; 3496 :    STBI_NOTUSED(hs);
; 3497 : 
; 3498 :    return out;
; 3499 : }
; 3500 : 
; 3501 : #define stbi__div16(x) ((stbi_uc) ((x) >> 4))
; 3502 : 
; 3503 : static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3504 : {
; 3505 :    // need to generate 2x2 samples for every one in input
; 3506 :    int i,t0,t1;
; 3507 :    if (w == 1) {
; 3508 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
; 3509 :       return out;
; 3510 :    }
; 3511 : 
; 3512 :    t1 = 3*in_near[0] + in_far[0];
; 3513 :    out[0] = stbi__div4(t1+2);
; 3514 :    for (i=1; i < w; ++i) {
; 3515 :       t0 = t1;
; 3516 :       t1 = 3*in_near[i]+in_far[i];
; 3517 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
; 3518 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
; 3519 :    }
; 3520 :    out[w*2-1] = stbi__div4(t1+2);
; 3521 : 
; 3522 :    STBI_NOTUSED(hs);
; 3523 : 
; 3524 :    return out;
; 3525 : }
; 3526 : 
; 3527 : #if defined(STBI_SSE2) || defined(STBI_NEON)
; 3528 : static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3529 : {
; 3530 :    // need to generate 2x2 samples for every one in input
; 3531 :    int i=0,t0,t1;
; 3532 : 
; 3533 :    if (w == 1) {
; 3534 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
; 3535 :       return out;
; 3536 :    }
; 3537 : 
; 3538 :    t1 = 3*in_near[0] + in_far[0];
; 3539 :    // process groups of 8 pixels for as long as we can.
; 3540 :    // note we can't handle the last pixel in a row in this loop
; 3541 :    // because we need to handle the filter boundary conditions.
; 3542 :    for (; i < ((w-1) & ~7); i += 8) {
; 3543 : #if defined(STBI_SSE2)
; 3544 :       // load and perform the vertical filtering pass
; 3545 :       // this uses 3*x + y = 4*x + (y - x)
; 3546 :       __m128i zero  = _mm_setzero_si128();
; 3547 :       __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
; 3548 :       __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
; 3549 :       __m128i farw  = _mm_unpacklo_epi8(farb, zero);
; 3550 :       __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
; 3551 :       __m128i diff  = _mm_sub_epi16(farw, nearw);
; 3552 :       __m128i nears = _mm_slli_epi16(nearw, 2);
; 3553 :       __m128i curr  = _mm_add_epi16(nears, diff); // current row
; 3554 : 
; 3555 :       // horizontal filter works the same based on shifted vers of current
; 3556 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3557 :       // insert the previous pixel value (from t1).
; 3558 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3559 :       // of next block of 8 pixels added in.
; 3560 :       __m128i prv0 = _mm_slli_si128(curr, 2);
; 3561 :       __m128i nxt0 = _mm_srli_si128(curr, 2);
; 3562 :       __m128i prev = _mm_insert_epi16(prv0, t1, 0);
; 3563 :       __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);
; 3564 : 
; 3565 :       // horizontal filter, polyphase implementation since it's convenient:
; 3566 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3567 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3568 :       // note the shared term.
; 3569 :       __m128i bias  = _mm_set1_epi16(8);
; 3570 :       __m128i curs = _mm_slli_epi16(curr, 2);
; 3571 :       __m128i prvd = _mm_sub_epi16(prev, curr);
; 3572 :       __m128i nxtd = _mm_sub_epi16(next, curr);
; 3573 :       __m128i curb = _mm_add_epi16(curs, bias);
; 3574 :       __m128i even = _mm_add_epi16(prvd, curb);
; 3575 :       __m128i odd  = _mm_add_epi16(nxtd, curb);
; 3576 : 
; 3577 :       // interleave even and odd pixels, then undo scaling.
; 3578 :       __m128i int0 = _mm_unpacklo_epi16(even, odd);
; 3579 :       __m128i int1 = _mm_unpackhi_epi16(even, odd);
; 3580 :       __m128i de0  = _mm_srli_epi16(int0, 4);
; 3581 :       __m128i de1  = _mm_srli_epi16(int1, 4);
; 3582 : 
; 3583 :       // pack and write output
; 3584 :       __m128i outv = _mm_packus_epi16(de0, de1);
; 3585 :       _mm_storeu_si128((__m128i *) (out + i*2), outv);
; 3586 : #elif defined(STBI_NEON)
; 3587 :       // load and perform the vertical filtering pass
; 3588 :       // this uses 3*x + y = 4*x + (y - x)
; 3589 :       uint8x8_t farb  = vld1_u8(in_far + i);
; 3590 :       uint8x8_t nearb = vld1_u8(in_near + i);
; 3591 :       int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
; 3592 :       int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
; 3593 :       int16x8_t curr  = vaddq_s16(nears, diff); // current row
; 3594 : 
; 3595 :       // horizontal filter works the same based on shifted vers of current
; 3596 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3597 :       // insert the previous pixel value (from t1).
; 3598 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3599 :       // of next block of 8 pixels added in.
; 3600 :       int16x8_t prv0 = vextq_s16(curr, curr, 7);
; 3601 :       int16x8_t nxt0 = vextq_s16(curr, curr, 1);
; 3602 :       int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
; 3603 :       int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);
; 3604 : 
; 3605 :       // horizontal filter, polyphase implementation since it's convenient:
; 3606 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3607 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3608 :       // note the shared term.
; 3609 :       int16x8_t curs = vshlq_n_s16(curr, 2);
; 3610 :       int16x8_t prvd = vsubq_s16(prev, curr);
; 3611 :       int16x8_t nxtd = vsubq_s16(next, curr);
; 3612 :       int16x8_t even = vaddq_s16(curs, prvd);
; 3613 :       int16x8_t odd  = vaddq_s16(curs, nxtd);
; 3614 : 
; 3615 :       // undo scaling and round, then store with even/odd phases interleaved
; 3616 :       uint8x8x2_t o;
; 3617 :       o.val[0] = vqrshrun_n_s16(even, 4);
; 3618 :       o.val[1] = vqrshrun_n_s16(odd,  4);
; 3619 :       vst2_u8(out + i*2, o);
; 3620 : #endif
; 3621 : 
; 3622 :       // "previous" value for next iter
; 3623 :       t1 = 3*in_near[i+7] + in_far[i+7];
; 3624 :    }
; 3625 : 
; 3626 :    t0 = t1;
; 3627 :    t1 = 3*in_near[i] + in_far[i];
; 3628 :    out[i*2] = stbi__div16(3*t1 + t0 + 8);
; 3629 : 
; 3630 :    for (++i; i < w; ++i) {
; 3631 :       t0 = t1;
; 3632 :       t1 = 3*in_near[i]+in_far[i];
; 3633 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
; 3634 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
; 3635 :    }
; 3636 :    out[w*2-1] = stbi__div4(t1+2);
; 3637 : 
; 3638 :    STBI_NOTUSED(hs);
; 3639 : 
; 3640 :    return out;
; 3641 : }
; 3642 : #endif
; 3643 : 
; 3644 : static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3645 : {
; 3646 :    // resample with nearest-neighbor
; 3647 :    int i,j;
; 3648 :    STBI_NOTUSED(in_far);
; 3649 :    for (i=0; i < w; ++i)
; 3650 :       for (j=0; j < hs; ++j)
; 3651 :          out[i*hs+j] = in_near[i];
; 3652 :    return out;
; 3653 : }
; 3654 : 
; 3655 : // this is a reduced-precision calculation of YCbCr-to-RGB introduced
; 3656 : // to make sure the code produces the same results in both SIMD and scalar
; 3657 : #define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
; 3658 : static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
; 3659 : {
; 3660 :    int i;
; 3661 :    for (i=0; i < count; ++i) {
; 3662 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding
; 3663 :       int r,g,b;
; 3664 :       int cr = pcr[i] - 128;
; 3665 :       int cb = pcb[i] - 128;
; 3666 :       r = y_fixed +  cr* stbi__float2fixed(1.40200f);
; 3667 :       g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
; 3668 :       b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
; 3669 :       r >>= 20;
; 3670 :       g >>= 20;
; 3671 :       b >>= 20;
; 3672 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
; 3673 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
; 3674 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
; 3675 :       out[0] = (stbi_uc)r;
; 3676 :       out[1] = (stbi_uc)g;
; 3677 :       out[2] = (stbi_uc)b;
; 3678 :       out[3] = 255;
; 3679 :       out += step;
; 3680 :    }
; 3681 : }
; 3682 : 
; 3683 : #if defined(STBI_SSE2) || defined(STBI_NEON)
; 3684 : static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
; 3685 : {
; 3686 :    int i = 0;
; 3687 : 
; 3688 : #ifdef STBI_SSE2
; 3689 :    // step == 3 is pretty ugly on the final interleave, and i'm not convinced
; 3690 :    // it's useful in practice (you wouldn't use it for textures, for example).
; 3691 :    // so just accelerate step == 4 case.
; 3692 :    if (step == 4) {
; 3693 :       // this is a fairly straightforward implementation and not super-optimized.
; 3694 :       __m128i signflip  = _mm_set1_epi8(-0x80);
; 3695 :       __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3696 :       __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3697 :       __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3698 :       __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3699 :       __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
; 3700 :       __m128i xw = _mm_set1_epi16(255); // alpha channel
; 3701 : 
; 3702 :       for (; i+7 < count; i += 8) {
; 3703 :          // load
; 3704 :          __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
; 3705 :          __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
; 3706 :          __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
; 3707 :          __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
; 3708 :          __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128
; 3709 : 
; 3710 :          // unpack to short (and left-shift cr, cb by 8)
; 3711 :          __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
; 3712 :          __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
; 3713 :          __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);
; 3714 : 
; 3715 :          // color transform
; 3716 :          __m128i yws = _mm_srli_epi16(yw, 4);
; 3717 :          __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
; 3718 :          __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
; 3719 :          __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
; 3720 :          __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
; 3721 :          __m128i rws = _mm_add_epi16(cr0, yws);
; 3722 :          __m128i gwt = _mm_add_epi16(cb0, yws);
; 3723 :          __m128i bws = _mm_add_epi16(yws, cb1);
; 3724 :          __m128i gws = _mm_add_epi16(gwt, cr1);
; 3725 : 
; 3726 :          // descale
; 3727 :          __m128i rw = _mm_srai_epi16(rws, 4);
; 3728 :          __m128i bw = _mm_srai_epi16(bws, 4);
; 3729 :          __m128i gw = _mm_srai_epi16(gws, 4);
; 3730 : 
; 3731 :          // back to byte, set up for transpose
; 3732 :          __m128i brb = _mm_packus_epi16(rw, bw);
; 3733 :          __m128i gxb = _mm_packus_epi16(gw, xw);
; 3734 : 
; 3735 :          // transpose to interleave channels
; 3736 :          __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
; 3737 :          __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
; 3738 :          __m128i o0 = _mm_unpacklo_epi16(t0, t1);
; 3739 :          __m128i o1 = _mm_unpackhi_epi16(t0, t1);
; 3740 : 
; 3741 :          // store
; 3742 :          _mm_storeu_si128((__m128i *) (out + 0), o0);
; 3743 :          _mm_storeu_si128((__m128i *) (out + 16), o1);
; 3744 :          out += 32;
; 3745 :       }
; 3746 :    }
; 3747 : #endif
; 3748 : 
; 3749 : #ifdef STBI_NEON
; 3750 :    // in this version, step=3 support would be easy to add. but is there demand?
; 3751 :    if (step == 4) {
; 3752 :       // this is a fairly straightforward implementation and not super-optimized.
; 3753 :       uint8x8_t signflip = vdup_n_u8(0x80);
; 3754 :       int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3755 :       int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3756 :       int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3757 :       int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3758 : 
; 3759 :       for (; i+7 < count; i += 8) {
; 3760 :          // load
; 3761 :          uint8x8_t y_bytes  = vld1_u8(y + i);
; 3762 :          uint8x8_t cr_bytes = vld1_u8(pcr + i);
; 3763 :          uint8x8_t cb_bytes = vld1_u8(pcb + i);
; 3764 :          int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
; 3765 :          int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
; 3766 : 
; 3767 :          // expand to s16
; 3768 :          int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
; 3769 :          int16x8_t crw = vshll_n_s8(cr_biased, 7);
; 3770 :          int16x8_t cbw = vshll_n_s8(cb_biased, 7);
; 3771 : 
; 3772 :          // color transform
; 3773 :          int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
; 3774 :          int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
; 3775 :          int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
; 3776 :          int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
; 3777 :          int16x8_t rws = vaddq_s16(yws, cr0);
; 3778 :          int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
; 3779 :          int16x8_t bws = vaddq_s16(yws, cb1);
; 3780 : 
; 3781 :          // undo scaling, round, convert to byte
; 3782 :          uint8x8x4_t o;
; 3783 :          o.val[0] = vqrshrun_n_s16(rws, 4);
; 3784 :          o.val[1] = vqrshrun_n_s16(gws, 4);
; 3785 :          o.val[2] = vqrshrun_n_s16(bws, 4);
; 3786 :          o.val[3] = vdup_n_u8(255);
; 3787 : 
; 3788 :          // store, interleaving r/g/b/a
; 3789 :          vst4_u8(out, o);
; 3790 :          out += 8*4;
; 3791 :       }
; 3792 :    }
; 3793 : #endif
; 3794 : 
; 3795 :    for (; i < count; ++i) {
; 3796 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding
; 3797 :       int r,g,b;
; 3798 :       int cr = pcr[i] - 128;
; 3799 :       int cb = pcb[i] - 128;
; 3800 :       r = y_fixed + cr* stbi__float2fixed(1.40200f);
; 3801 :       g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
; 3802 :       b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
; 3803 :       r >>= 20;
; 3804 :       g >>= 20;
; 3805 :       b >>= 20;
; 3806 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
; 3807 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
; 3808 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
; 3809 :       out[0] = (stbi_uc)r;
; 3810 :       out[1] = (stbi_uc)g;
; 3811 :       out[2] = (stbi_uc)b;
; 3812 :       out[3] = 255;
; 3813 :       out += step;
; 3814 :    }
; 3815 : }
; 3816 : #endif
; 3817 : 
; 3818 : // set up the kernels
; 3819 : static void stbi__setup_jpeg(stbi__jpeg *j)
; 3820 : {
; 3821 :    j->idct_block_kernel = stbi__idct_block;
; 3822 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
; 3823 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;
; 3824 : 
; 3825 : #ifdef STBI_SSE2
; 3826 :    if (stbi__sse2_available()) {
; 3827 :       j->idct_block_kernel = stbi__idct_simd;
; 3828 :       j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3829 :       j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3830 :    }
; 3831 : #endif
; 3832 : 
; 3833 : #ifdef STBI_NEON
; 3834 :    j->idct_block_kernel = stbi__idct_simd;
; 3835 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3836 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3837 : #endif
; 3838 : }
; 3839 : 
; 3840 : // clean up the temporary component buffers
; 3841 : static void stbi__cleanup_jpeg(stbi__jpeg *j)
; 3842 : {
; 3843 :    stbi__free_jpeg_components(j, j->s->img_n, 0);
; 3844 : }
; 3845 : 
; 3846 : typedef struct
; 3847 : {
; 3848 :    resample_row_func resample;
; 3849 :    stbi_uc *line0,*line1;
; 3850 :    int hs,vs;   // expansion factor in each axis
; 3851 :    int w_lores; // horizontal pixels pre-expansion
; 3852 :    int ystep;   // how far through vertical expansion we are
; 3853 :    int ypos;    // which pre-expansion row we're on
; 3854 : } stbi__resample;
; 3855 : 
; 3856 : // fast 0..255 * 0..255 => 0..255 rounded multiplication
; 3857 : static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
; 3858 : {
; 3859 :    unsigned int t = x*y + 128;
; 3860 :    return (stbi_uc) ((t + (t >>8)) >> 8);
; 3861 : }
; 3862 : 
; 3863 : static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
; 3864 : {
; 3865 :    int n, decode_n, is_rgb;
; 3866 :    z->s->img_n = 0; // make stbi__cleanup_jpeg safe
; 3867 : 
; 3868 :    // validate req_comp
; 3869 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
; 3870 : 
; 3871 :    // load a jpeg image from whichever source, but leave in YCbCr format
; 3872 :    if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }
; 3873 : 
; 3874 :    // determine actual number of components to generate
; 3875 :    n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;
; 3876 : 
; 3877 :    is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));
; 3878 : 
; 3879 :    if (z->s->img_n == 3 && n < 3 && !is_rgb)
; 3880 :       decode_n = 1;
; 3881 :    else
; 3882 :       decode_n = z->s->img_n;
; 3883 : 
; 3884 :    // nothing to do if no components requested; check this now to avoid
; 3885 :    // accessing uninitialized coutput[0] later
; 3886 :    if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }
; 3887 : 
; 3888 :    // resample and color-convert
; 3889 :    {
; 3890 :       int k;
; 3891 :       unsigned int i,j;
; 3892 :       stbi_uc *output;
; 3893 :       stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };
; 3894 : 
; 3895 :       stbi__resample res_comp[4];
; 3896 : 
; 3897 :       for (k=0; k < decode_n; ++k) {
; 3898 :          stbi__resample *r = &res_comp[k];
; 3899 : 
; 3900 :          // allocate line buffer big enough for upsampling off the edges
; 3901 :          // with upsample factor of 4
; 3902 :          z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
; 3903 :          if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
; 3904 : 
; 3905 :          r->hs      = z->img_h_max / z->img_comp[k].h;
; 3906 :          r->vs      = z->img_v_max / z->img_comp[k].v;
; 3907 :          r->ystep   = r->vs >> 1;
; 3908 :          r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
; 3909 :          r->ypos    = 0;
; 3910 :          r->line0   = r->line1 = z->img_comp[k].data;
; 3911 : 
; 3912 :          if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
; 3913 :          else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
; 3914 :          else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
; 3915 :          else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
; 3916 :          else                               r->resample = stbi__resample_row_generic;
; 3917 :       }
; 3918 : 
; 3919 :       // can't error after this so, this is safe
; 3920 :       output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
; 3921 :       if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
; 3922 : 
; 3923 :       // now go ahead and resample
; 3924 :       for (j=0; j < z->s->img_y; ++j) {
; 3925 :          stbi_uc *out = output + n * z->s->img_x * j;
; 3926 :          for (k=0; k < decode_n; ++k) {
; 3927 :             stbi__resample *r = &res_comp[k];
; 3928 :             int y_bot = r->ystep >= (r->vs >> 1);
; 3929 :             coutput[k] = r->resample(z->img_comp[k].linebuf,
; 3930 :                                      y_bot ? r->line1 : r->line0,
; 3931 :                                      y_bot ? r->line0 : r->line1,
; 3932 :                                      r->w_lores, r->hs);
; 3933 :             if (++r->ystep >= r->vs) {
; 3934 :                r->ystep = 0;
; 3935 :                r->line0 = r->line1;
; 3936 :                if (++r->ypos < z->img_comp[k].y)
; 3937 :                   r->line1 += z->img_comp[k].w2;
; 3938 :             }
; 3939 :          }
; 3940 :          if (n >= 3) {
; 3941 :             stbi_uc *y = coutput[0];
; 3942 :             if (z->s->img_n == 3) {
; 3943 :                if (is_rgb) {
; 3944 :                   for (i=0; i < z->s->img_x; ++i) {
; 3945 :                      out[0] = y[i];
; 3946 :                      out[1] = coutput[1][i];
; 3947 :                      out[2] = coutput[2][i];
; 3948 :                      out[3] = 255;
; 3949 :                      out += n;
; 3950 :                   }
; 3951 :                } else {
; 3952 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3953 :                }
; 3954 :             } else if (z->s->img_n == 4) {
; 3955 :                if (z->app14_color_transform == 0) { // CMYK
; 3956 :                   for (i=0; i < z->s->img_x; ++i) {
; 3957 :                      stbi_uc m = coutput[3][i];
; 3958 :                      out[0] = stbi__blinn_8x8(coutput[0][i], m);
; 3959 :                      out[1] = stbi__blinn_8x8(coutput[1][i], m);
; 3960 :                      out[2] = stbi__blinn_8x8(coutput[2][i], m);
; 3961 :                      out[3] = 255;
; 3962 :                      out += n;
; 3963 :                   }
; 3964 :                } else if (z->app14_color_transform == 2) { // YCCK
; 3965 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3966 :                   for (i=0; i < z->s->img_x; ++i) {
; 3967 :                      stbi_uc m = coutput[3][i];
; 3968 :                      out[0] = stbi__blinn_8x8(255 - out[0], m);
; 3969 :                      out[1] = stbi__blinn_8x8(255 - out[1], m);
; 3970 :                      out[2] = stbi__blinn_8x8(255 - out[2], m);
; 3971 :                      out += n;
; 3972 :                   }
; 3973 :                } else { // YCbCr + alpha?  Ignore the fourth channel for now
; 3974 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3975 :                }
; 3976 :             } else
; 3977 :                for (i=0; i < z->s->img_x; ++i) {
; 3978 :                   out[0] = out[1] = out[2] = y[i];
; 3979 :                   out[3] = 255; // not used if n==3
; 3980 :                   out += n;
; 3981 :                }
; 3982 :          } else {
; 3983 :             if (is_rgb) {
; 3984 :                if (n == 1)
; 3985 :                   for (i=0; i < z->s->img_x; ++i)
; 3986 :                      *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
; 3987 :                else {
; 3988 :                   for (i=0; i < z->s->img_x; ++i, out += 2) {
; 3989 :                      out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
; 3990 :                      out[1] = 255;
; 3991 :                   }
; 3992 :                }
; 3993 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
; 3994 :                for (i=0; i < z->s->img_x; ++i) {
; 3995 :                   stbi_uc m = coutput[3][i];
; 3996 :                   stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
; 3997 :                   stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
; 3998 :                   stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
; 3999 :                   out[0] = stbi__compute_y(r, g, b);
; 4000 :                   out[1] = 255;
; 4001 :                   out += n;
; 4002 :                }
; 4003 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
; 4004 :                for (i=0; i < z->s->img_x; ++i) {
; 4005 :                   out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
; 4006 :                   out[1] = 255;
; 4007 :                   out += n;
; 4008 :                }
; 4009 :             } else {
; 4010 :                stbi_uc *y = coutput[0];
; 4011 :                if (n == 1)
; 4012 :                   for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
; 4013 :                else
; 4014 :                   for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
; 4015 :             }
; 4016 :          }
; 4017 :       }
; 4018 :       stbi__cleanup_jpeg(z);
; 4019 :       *out_x = z->s->img_x;
; 4020 :       *out_y = z->s->img_y;
; 4021 :       if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
; 4022 :       return output;
; 4023 :    }
; 4024 : }
; 4025 : 
; 4026 : static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 4027 : {
; 4028 :    unsigned char* result;
; 4029 :    stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
; 4030 :    if (!j) return stbi__errpuc("outofmem", "Out of memory");
; 4031 :    memset(j, 0, sizeof(stbi__jpeg));
; 4032 :    STBI_NOTUSED(ri);
; 4033 :    j->s = s;
; 4034 :    stbi__setup_jpeg(j);
; 4035 :    result = load_jpeg_image(j, x,y,comp,req_comp);
; 4036 :    STBI_FREE(j);
; 4037 :    return result;
; 4038 : }
; 4039 : 
; 4040 : static int stbi__jpeg_test(stbi__context *s)
; 4041 : {
; 4042 :    int r;
; 4043 :    stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
; 4044 :    if (!j) return stbi__err("outofmem", "Out of memory");
; 4045 :    memset(j, 0, sizeof(stbi__jpeg));
; 4046 :    j->s = s;
; 4047 :    stbi__setup_jpeg(j);
; 4048 :    r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
; 4049 :    stbi__rewind(s);
; 4050 :    STBI_FREE(j);
; 4051 :    return r;
; 4052 : }
; 4053 : 
; 4054 : static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
; 4055 : {
; 4056 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
; 4057 :       stbi__rewind( j->s );
; 4058 :       return 0;
; 4059 :    }
; 4060 :    if (x) *x = j->s->img_x;
; 4061 :    if (y) *y = j->s->img_y;
; 4062 :    if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
; 4063 :    return 1;
; 4064 : }
; 4065 : 
; 4066 : static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
; 4067 : {
; 4068 :    int result;
; 4069 :    stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
; 4070 :    if (!j) return stbi__err("outofmem", "Out of memory");
; 4071 :    memset(j, 0, sizeof(stbi__jpeg));
; 4072 :    j->s = s;
; 4073 :    result = stbi__jpeg_info_raw(j, x, y, comp);
; 4074 :    STBI_FREE(j);
; 4075 :    return result;
; 4076 : }
; 4077 : #endif
; 4078 : 
; 4079 : // public domain zlib decode    v0.2  Sean Barrett 2006-11-18
; 4080 : //    simple implementation
; 4081 : //      - all input must be provided in an upfront buffer
; 4082 : //      - all output is written to a single output buffer (can malloc/realloc)
; 4083 : //    performance
; 4084 : //      - fast huffman
; 4085 : 
; 4086 : #ifndef STBI_NO_ZLIB
; 4087 : 
; 4088 : // fast-way is faster to check than jpeg huffman, but slow way is slower
; 4089 : #define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
; 4090 : #define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
; 4091 : #define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet
; 4092 : 
; 4093 : // zlib-style huffman encoding
; 4094 : // (jpegs packs from left, zlib from right, so can't share code)
; 4095 : typedef struct
; 4096 : {
; 4097 :    stbi__uint16 fast[1 << STBI__ZFAST_BITS];
; 4098 :    stbi__uint16 firstcode[16];
; 4099 :    int maxcode[17];
; 4100 :    stbi__uint16 firstsymbol[16];
; 4101 :    stbi_uc  size[STBI__ZNSYMS];
; 4102 :    stbi__uint16 value[STBI__ZNSYMS];
; 4103 : } stbi__zhuffman;
; 4104 : 
; 4105 : stbi_inline static int stbi__bitreverse16(int n)
; 4106 : {
; 4107 :   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
; 4108 :   n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
; 4109 :   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
; 4110 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
; 4111 :   return n;
; 4112 : }
; 4113 : 
; 4114 : stbi_inline static int stbi__bit_reverse(int v, int bits)
; 4115 : {
; 4116 :    STBI_ASSERT(bits <= 16);
; 4117 :    // to bit reverse n bits, reverse 16 and shift
; 4118 :    // e.g. 11 bits, bit reverse and shift away 5
; 4119 :    return stbi__bitreverse16(v) >> (16-bits);
; 4120 : }
; 4121 : 
; 4122 : static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
; 4123 : {
; 4124 :    int i,k=0;
; 4125 :    int code, next_code[16], sizes[17];
; 4126 : 
; 4127 :    // DEFLATE spec for generating codes
; 4128 :    memset(sizes, 0, sizeof(sizes));
; 4129 :    memset(z->fast, 0, sizeof(z->fast));
; 4130 :    for (i=0; i < num; ++i)
; 4131 :       ++sizes[sizelist[i]];
; 4132 :    sizes[0] = 0;
; 4133 :    for (i=1; i < 16; ++i)
; 4134 :       if (sizes[i] > (1 << i))
; 4135 :          return stbi__err("bad sizes", "Corrupt PNG");
; 4136 :    code = 0;
; 4137 :    for (i=1; i < 16; ++i) {
; 4138 :       next_code[i] = code;
; 4139 :       z->firstcode[i] = (stbi__uint16) code;
; 4140 :       z->firstsymbol[i] = (stbi__uint16) k;
; 4141 :       code = (code + sizes[i]);
; 4142 :       if (sizes[i])
; 4143 :          if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
; 4144 :       z->maxcode[i] = code << (16-i); // preshift for inner loop
; 4145 :       code <<= 1;
; 4146 :       k += sizes[i];
; 4147 :    }
; 4148 :    z->maxcode[16] = 0x10000; // sentinel
; 4149 :    for (i=0; i < num; ++i) {
; 4150 :       int s = sizelist[i];
; 4151 :       if (s) {
; 4152 :          int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
; 4153 :          stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
; 4154 :          z->size [c] = (stbi_uc     ) s;
; 4155 :          z->value[c] = (stbi__uint16) i;
; 4156 :          if (s <= STBI__ZFAST_BITS) {
; 4157 :             int j = stbi__bit_reverse(next_code[s],s);
; 4158 :             while (j < (1 << STBI__ZFAST_BITS)) {
; 4159 :                z->fast[j] = fastv;
; 4160 :                j += (1 << s);
; 4161 :             }
; 4162 :          }
; 4163 :          ++next_code[s];
; 4164 :       }
; 4165 :    }
; 4166 :    return 1;
; 4167 : }
; 4168 : 
; 4169 : // zlib-from-memory implementation for PNG reading
; 4170 : //    because PNG allows splitting the zlib stream arbitrarily,
; 4171 : //    and it's annoying structurally to have PNG call ZLIB call PNG,
; 4172 : //    we require PNG read all the IDATs and combine them into a single
; 4173 : //    memory buffer
; 4174 : 
; 4175 : typedef struct
; 4176 : {
; 4177 :    stbi_uc *zbuffer, *zbuffer_end;
; 4178 :    int num_bits;
; 4179 :    stbi__uint32 code_buffer;
; 4180 : 
; 4181 :    char *zout;
; 4182 :    char *zout_start;
; 4183 :    char *zout_end;
; 4184 :    int   z_expandable;
; 4185 : 
; 4186 :    stbi__zhuffman z_length, z_distance;
; 4187 : } stbi__zbuf;
; 4188 : 
; 4189 : stbi_inline static int stbi__zeof(stbi__zbuf *z)
; 4190 : {
; 4191 :    return (z->zbuffer >= z->zbuffer_end);
; 4192 : }
; 4193 : 
; 4194 : stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
; 4195 : {
; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;
; 4197 : }
; 4198 : 
; 4199 : static void stbi__fill_bits(stbi__zbuf *z)
; 4200 : {
; 4201 :    do {
; 4202 :       if (z->code_buffer >= (1U << z->num_bits)) {
; 4203 :         z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
; 4204 :         return;
; 4205 :       }
; 4206 :       z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
; 4207 :       z->num_bits += 8;
; 4208 :    } while (z->num_bits <= 24);
; 4209 : }
; 4210 : 
; 4211 : stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
; 4212 : {
; 4213 :    unsigned int k;
; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);
; 4215 :    k = z->code_buffer & ((1 << n) - 1);
; 4216 :    z->code_buffer >>= n;
; 4217 :    z->num_bits -= n;
; 4218 :    return k;
; 4219 : }
; 4220 : 
; 4221 : static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
; 4222 : {
; 4223 :    int b,s,k;
; 4224 :    // not resolved by fast table, so compute it the slow way
; 4225 :    // use jpeg approach, which requires MSbits at top
; 4226 :    k = stbi__bit_reverse(a->code_buffer, 16);
; 4227 :    for (s=STBI__ZFAST_BITS+1; ; ++s)
; 4228 :       if (k < z->maxcode[s])
; 4229 :          break;
; 4230 :    if (s >= 16) return -1; // invalid code!
; 4231 :    // code size is s, so:
; 4232 :    b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
; 4233 :    if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
; 4234 :    if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
; 4235 :    a->code_buffer >>= s;
; 4236 :    a->num_bits -= s;
; 4237 :    return z->value[b];
; 4238 : }
; 4239 : 
; 4240 : stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
; 4241 : {
; 4242 :    int b,s;
; 4243 :    if (a->num_bits < 16) {
; 4244 :       if (stbi__zeof(a)) {
; 4245 :          return -1;   /* report error for unexpected end of data. */
; 4246 :       }
; 4247 :       stbi__fill_bits(a);
; 4248 :    }
; 4249 :    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
; 4250 :    if (b) {
; 4251 :       s = b >> 9;
; 4252 :       a->code_buffer >>= s;
; 4253 :       a->num_bits -= s;
; 4254 :       return b & 511;
; 4255 :    }
; 4256 :    return stbi__zhuffman_decode_slowpath(a, z);
; 4257 : }
; 4258 : 
; 4259 : static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
; 4260 : {
; 4261 :    char *q;
; 4262 :    unsigned int cur, limit, old_limit;
; 4263 :    z->zout = zout;
; 4264 :    if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
; 4265 :    cur   = (unsigned int) (z->zout - z->zout_start);
; 4266 :    limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
; 4267 :    if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");
; 4268 :    while (cur + n > limit) {
; 4269 :       if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");
; 4270 :       limit *= 2;
; 4271 :    }
; 4272 :    q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
; 4273 :    STBI_NOTUSED(old_limit);
; 4274 :    if (q == NULL) return stbi__err("outofmem", "Out of memory");
; 4275 :    z->zout_start = q;
; 4276 :    z->zout       = q + cur;
; 4277 :    z->zout_end   = q + limit;
; 4278 :    return 1;
; 4279 : }
; 4280 : 
; 4281 : static const int stbi__zlength_base[31] = {
; 4282 :    3,4,5,6,7,8,9,10,11,13,
; 4283 :    15,17,19,23,27,31,35,43,51,59,
; 4284 :    67,83,99,115,131,163,195,227,258,0,0 };
; 4285 : 
; 4286 : static const int stbi__zlength_extra[31]=
; 4287 : { 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };
; 4288 : 
; 4289 : static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
; 4290 : 257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};
; 4291 : 
; 4292 : static const int stbi__zdist_extra[32] =
; 4293 : { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
; 4294 : 
; 4295 : static int stbi__parse_huffman_block(stbi__zbuf *a)
; 4296 : {
; 4297 :    char *zout = a->zout;
; 4298 :    for(;;) {
; 4299 :       int z = stbi__zhuffman_decode(a, &a->z_length);
; 4300 :       if (z < 256) {
; 4301 :          if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
; 4302 :          if (zout >= a->zout_end) {
; 4303 :             if (!stbi__zexpand(a, zout, 1)) return 0;
; 4304 :             zout = a->zout;
; 4305 :          }
; 4306 :          *zout++ = (char) z;
; 4307 :       } else {
; 4308 :          stbi_uc *p;
; 4309 :          int len,dist;
; 4310 :          if (z == 256) {
; 4311 :             a->zout = zout;
; 4312 :             return 1;
; 4313 :          }
; 4314 :          if (z >= 286) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, length codes 286 and 287 must not appear in compressed data
; 4315 :          z -= 257;
; 4316 :          len = stbi__zlength_base[z];
; 4317 :          if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
; 4318 :          z = stbi__zhuffman_decode(a, &a->z_distance);
; 4319 :          if (z < 0 || z >= 30) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data
; 4320 :          dist = stbi__zdist_base[z];
; 4321 :          if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
; 4322 :          if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
; 4323 :          if (zout + len > a->zout_end) {
; 4324 :             if (!stbi__zexpand(a, zout, len)) return 0;
; 4325 :             zout = a->zout;
; 4326 :          }
; 4327 :          p = (stbi_uc *) (zout - dist);
; 4328 :          if (dist == 1) { // run of one byte; common in images.
; 4329 :             stbi_uc v = *p;
; 4330 :             if (len) { do *zout++ = v; while (--len); }
; 4331 :          } else {
; 4332 :             if (len) { do *zout++ = *p++; while (--len); }
; 4333 :          }
; 4334 :       }
; 4335 :    }
; 4336 : }
; 4337 : 
; 4338 : static int stbi__compute_huffman_codes(stbi__zbuf *a)
; 4339 : {
; 4340 :    static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
; 4341 :    stbi__zhuffman z_codelength;
; 4342 :    stbi_uc lencodes[286+32+137];//padding for maximum single op
; 4343 :    stbi_uc codelength_sizes[19];
; 4344 :    int i,n;
; 4345 : 
; 4346 :    int hlit  = stbi__zreceive(a,5) + 257;
; 4347 :    int hdist = stbi__zreceive(a,5) + 1;
; 4348 :    int hclen = stbi__zreceive(a,4) + 4;
; 4349 :    int ntot  = hlit + hdist;
; 4350 : 
; 4351 :    memset(codelength_sizes, 0, sizeof(codelength_sizes));
; 4352 :    for (i=0; i < hclen; ++i) {
; 4353 :       int s = stbi__zreceive(a,3);
; 4354 :       codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
; 4355 :    }
; 4356 :    if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;
; 4357 : 
; 4358 :    n = 0;
; 4359 :    while (n < ntot) {
; 4360 :       int c = stbi__zhuffman_decode(a, &z_codelength);
; 4361 :       if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
; 4362 :       if (c < 16)
; 4363 :          lencodes[n++] = (stbi_uc) c;
; 4364 :       else {
; 4365 :          stbi_uc fill = 0;
; 4366 :          if (c == 16) {
; 4367 :             c = stbi__zreceive(a,2)+3;
; 4368 :             if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
; 4369 :             fill = lencodes[n-1];
; 4370 :          } else if (c == 17) {
; 4371 :             c = stbi__zreceive(a,3)+3;
; 4372 :          } else if (c == 18) {
; 4373 :             c = stbi__zreceive(a,7)+11;
; 4374 :          } else {
; 4375 :             return stbi__err("bad codelengths", "Corrupt PNG");
; 4376 :          }
; 4377 :          if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
; 4378 :          memset(lencodes+n, fill, c);
; 4379 :          n += c;
; 4380 :       }
; 4381 :    }
; 4382 :    if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");
; 4383 :    if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
; 4384 :    if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
; 4385 :    return 1;
; 4386 : }
; 4387 : 
; 4388 : static int stbi__parse_uncompressed_block(stbi__zbuf *a)
; 4389 : {
; 4390 :    stbi_uc header[4];
; 4391 :    int len,nlen,k;
; 4392 :    if (a->num_bits & 7)
; 4393 :       stbi__zreceive(a, a->num_bits & 7); // discard
; 4394 :    // drain the bit-packed data into header
; 4395 :    k = 0;
; 4396 :    while (a->num_bits > 0) {
; 4397 :       header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
; 4398 :       a->code_buffer >>= 8;
; 4399 :       a->num_bits -= 8;
; 4400 :    }
; 4401 :    if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");
; 4402 :    // now fill header the normal way
; 4403 :    while (k < 4)
; 4404 :       header[k++] = stbi__zget8(a);
; 4405 :    len  = header[1] * 256 + header[0];
; 4406 :    nlen = header[3] * 256 + header[2];
; 4407 :    if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
; 4408 :    if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
; 4409 :    if (a->zout + len > a->zout_end)
; 4410 :       if (!stbi__zexpand(a, a->zout, len)) return 0;
; 4411 :    memcpy(a->zout, a->zbuffer, len);
; 4412 :    a->zbuffer += len;
; 4413 :    a->zout += len;
; 4414 :    return 1;
; 4415 : }
; 4416 : 
; 4417 : static int stbi__parse_zlib_header(stbi__zbuf *a)
; 4418 : {
; 4419 :    int cmf   = stbi__zget8(a);
; 4420 :    int cm    = cmf & 15;
; 4421 :    /* int cinfo = cmf >> 4; */
; 4422 :    int flg   = stbi__zget8(a);
; 4423 :    if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
; 4424 :    if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
; 4425 :    if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
; 4426 :    if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
; 4427 :    // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
; 4428 :    return 1;
; 4429 : }
; 4430 : 
; 4431 : static const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =
; 4432 : {
; 4433 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4434 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4435 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4436 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4437 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4438 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4439 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4440 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4441 :    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
; 4442 : };
; 4443 : static const stbi_uc stbi__zdefault_distance[32] =
; 4444 : {
; 4445 :    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
; 4446 : };
; 4447 : /*
; 4448 : Init algorithm:
; 4449 : {
; 4450 :    int i;   // use <= to match clearly with spec
; 4451 :    for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
; 4452 :    for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
; 4453 :    for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
; 4454 :    for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;
; 4455 : 
; 4456 :    for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
; 4457 : }
; 4458 : */
; 4459 : 
; 4460 : static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
; 4461 : {
; 4462 :    int final, type;
; 4463 :    if (parse_header)
; 4464 :       if (!stbi__parse_zlib_header(a)) return 0;
; 4465 :    a->num_bits = 0;
; 4466 :    a->code_buffer = 0;
; 4467 :    do {
; 4468 :       final = stbi__zreceive(a,1);
; 4469 :       type = stbi__zreceive(a,2);
; 4470 :       if (type == 0) {
; 4471 :          if (!stbi__parse_uncompressed_block(a)) return 0;
; 4472 :       } else if (type == 3) {
; 4473 :          return 0;
; 4474 :       } else {
; 4475 :          if (type == 1) {
; 4476 :             // use fixed code lengths
; 4477 :             if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
; 4478 :             if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
; 4479 :          } else {
; 4480 :             if (!stbi__compute_huffman_codes(a)) return 0;
; 4481 :          }
; 4482 :          if (!stbi__parse_huffman_block(a)) return 0;
; 4483 :       }
; 4484 :    } while (!final);
; 4485 :    return 1;
; 4486 : }
; 4487 : 
; 4488 : static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
; 4489 : {
; 4490 :    a->zout_start = obuf;
; 4491 :    a->zout       = obuf;
; 4492 :    a->zout_end   = obuf + olen;
; 4493 :    a->z_expandable = exp;
; 4494 : 
; 4495 :    return stbi__parse_zlib(a, parse_header);
; 4496 : }
; 4497 : 
; 4498 : STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
; 4499 : {
; 4500 :    stbi__zbuf a;
; 4501 :    char *p = (char *) stbi__malloc(initial_size);
; 4502 :    if (p == NULL) return NULL;
; 4503 :    a.zbuffer = (stbi_uc *) buffer;
; 4504 :    a.zbuffer_end = (stbi_uc *) buffer + len;
; 4505 :    if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
; 4506 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4507 :       return a.zout_start;
; 4508 :    } else {
; 4509 :       STBI_FREE(a.zout_start);
; 4510 :       return NULL;
; 4511 :    }
; 4512 : }
; 4513 : 
; 4514 : STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
; 4515 : {
; 4516 :    return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
; 4517 : }
; 4518 : 
; 4519 : STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
; 4520 : {
; 4521 :    stbi__zbuf a;
; 4522 :    char *p = (char *) stbi__malloc(initial_size);
; 4523 :    if (p == NULL) return NULL;
; 4524 :    a.zbuffer = (stbi_uc *) buffer;
; 4525 :    a.zbuffer_end = (stbi_uc *) buffer + len;
; 4526 :    if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
; 4527 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4528 :       return a.zout_start;
; 4529 :    } else {
; 4530 :       STBI_FREE(a.zout_start);
; 4531 :       return NULL;
; 4532 :    }
; 4533 : }
; 4534 : 
; 4535 : STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
; 4536 : {
; 4537 :    stbi__zbuf a;
; 4538 :    a.zbuffer = (stbi_uc *) ibuffer;
; 4539 :    a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
; 4540 :    if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
; 4541 :       return (int) (a.zout - a.zout_start);
; 4542 :    else
; 4543 :       return -1;
; 4544 : }
; 4545 : 
; 4546 : STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
; 4547 : {
; 4548 :    stbi__zbuf a;
; 4549 :    char *p = (char *) stbi__malloc(16384);
; 4550 :    if (p == NULL) return NULL;
; 4551 :    a.zbuffer = (stbi_uc *) buffer;
; 4552 :    a.zbuffer_end = (stbi_uc *) buffer+len;
; 4553 :    if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
; 4554 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4555 :       return a.zout_start;
; 4556 :    } else {
; 4557 :       STBI_FREE(a.zout_start);
; 4558 :       return NULL;
; 4559 :    }
; 4560 : }
; 4561 : 
; 4562 : STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
; 4563 : {
; 4564 :    stbi__zbuf a;
; 4565 :    a.zbuffer = (stbi_uc *) ibuffer;
; 4566 :    a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
; 4567 :    if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
; 4568 :       return (int) (a.zout - a.zout_start);
; 4569 :    else
; 4570 :       return -1;
; 4571 : }
; 4572 : #endif
; 4573 : 
; 4574 : // public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
; 4575 : //    simple implementation
; 4576 : //      - only 8-bit samples
; 4577 : //      - no CRC checking
; 4578 : //      - allocates lots of intermediate memory
; 4579 : //        - avoids problem of streaming data between subsystems
; 4580 : //        - avoids explicit window management
; 4581 : //    performance
; 4582 : //      - uses stb_zlib, a PD zlib implementation with fast huffman decoding
; 4583 : 
; 4584 : #ifndef STBI_NO_PNG
; 4585 : typedef struct
; 4586 : {
; 4587 :    stbi__uint32 length;
; 4588 :    stbi__uint32 type;
; 4589 : } stbi__pngchunk;
; 4590 : 
; 4591 : static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
; 4592 : {
; 4593 :    stbi__pngchunk c;
; 4594 :    c.length = stbi__get32be(s);
; 4595 :    c.type   = stbi__get32be(s);
; 4596 :    return c;
; 4597 : }
; 4598 : 
; 4599 : static int stbi__check_png_header(stbi__context *s)
; 4600 : {
; 4601 :    static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
; 4602 :    int i;
; 4603 :    for (i=0; i < 8; ++i)
; 4604 :       if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
; 4605 :    return 1;
; 4606 : }
; 4607 : 
; 4608 : typedef struct
; 4609 : {
; 4610 :    stbi__context *s;
; 4611 :    stbi_uc *idata, *expanded, *out;
; 4612 :    int depth;
; 4613 : } stbi__png;
; 4614 : 
; 4615 : 
; 4616 : enum {
; 4617 :    STBI__F_none=0,
; 4618 :    STBI__F_sub=1,
; 4619 :    STBI__F_up=2,
; 4620 :    STBI__F_avg=3,
; 4621 :    STBI__F_paeth=4,
; 4622 :    // synthetic filters used for first scanline to avoid needing a dummy row of 0s
; 4623 :    STBI__F_avg_first,
; 4624 :    STBI__F_paeth_first
; 4625 : };
; 4626 : 
; 4627 : static stbi_uc first_row_filter[5] =
; 4628 : {
; 4629 :    STBI__F_none,
; 4630 :    STBI__F_sub,
; 4631 :    STBI__F_none,
; 4632 :    STBI__F_avg_first,
; 4633 :    STBI__F_paeth_first
; 4634 : };
; 4635 : 
; 4636 : static int stbi__paeth(int a, int b, int c)
; 4637 : {
; 4638 :    int p = a + b - c;
; 4639 :    int pa = abs(p-a);
; 4640 :    int pb = abs(p-b);
; 4641 :    int pc = abs(p-c);
; 4642 :    if (pa <= pb && pa <= pc) return a;
; 4643 :    if (pb <= pc) return b;
; 4644 :    return c;
; 4645 : }
; 4646 : 
; 4647 : static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };
; 4648 : 
; 4649 : // create the png data from post-deflated data
; 4650 : static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
; 4651 : {
; 4652 :    int bytes = (depth == 16? 2 : 1);
; 4653 :    stbi__context *s = a->s;
; 4654 :    stbi__uint32 i,j,stride = x*out_n*bytes;
; 4655 :    stbi__uint32 img_len, img_width_bytes;
; 4656 :    int k;
; 4657 :    int img_n = s->img_n; // copy it into a local for later
; 4658 : 
; 4659 :    int output_bytes = out_n*bytes;
; 4660 :    int filter_bytes = img_n*bytes;
; 4661 :    int width = x;
; 4662 : 
; 4663 :    STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
; 4664 :    a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
; 4665 :    if (!a->out) return stbi__err("outofmem", "Out of memory");
; 4666 : 
; 4667 :    if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
; 4668 :    img_width_bytes = (((img_n * x * depth) + 7) >> 3);
; 4669 :    img_len = (img_width_bytes + 1) * y;
; 4670 : 
; 4671 :    // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
; 4672 :    // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
; 4673 :    // so just check for raw_len < img_len always.
; 4674 :    if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");
; 4675 : 
; 4676 :    for (j=0; j < y; ++j) {
; 4677 :       stbi_uc *cur = a->out + stride*j;
; 4678 :       stbi_uc *prior;
; 4679 :       int filter = *raw++;
; 4680 : 
; 4681 :       if (filter > 4)
; 4682 :          return stbi__err("invalid filter","Corrupt PNG");
; 4683 : 
; 4684 :       if (depth < 8) {
; 4685 :          if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");
; 4686 :          cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
; 4687 :          filter_bytes = 1;
; 4688 :          width = img_width_bytes;
; 4689 :       }
; 4690 :       prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above
; 4691 : 
; 4692 :       // if first row, use special filter that doesn't sample previous row
; 4693 :       if (j == 0) filter = first_row_filter[filter];
; 4694 : 
; 4695 :       // handle first byte explicitly
; 4696 :       for (k=0; k < filter_bytes; ++k) {
; 4697 :          switch (filter) {
; 4698 :             case STBI__F_none       : cur[k] = raw[k]; break;
; 4699 :             case STBI__F_sub        : cur[k] = raw[k]; break;
; 4700 :             case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
; 4701 :             case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;
; 4702 :             case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;
; 4703 :             case STBI__F_avg_first  : cur[k] = raw[k]; break;
; 4704 :             case STBI__F_paeth_first: cur[k] = raw[k]; break;
; 4705 :          }
; 4706 :       }
; 4707 : 
; 4708 :       if (depth == 8) {
; 4709 :          if (img_n != out_n)
; 4710 :             cur[img_n] = 255; // first pixel
; 4711 :          raw += img_n;
; 4712 :          cur += out_n;
; 4713 :          prior += out_n;
; 4714 :       } else if (depth == 16) {
; 4715 :          if (img_n != out_n) {
; 4716 :             cur[filter_bytes]   = 255; // first pixel top byte
; 4717 :             cur[filter_bytes+1] = 255; // first pixel bottom byte
; 4718 :          }
; 4719 :          raw += filter_bytes;
; 4720 :          cur += output_bytes;
; 4721 :          prior += output_bytes;
; 4722 :       } else {
; 4723 :          raw += 1;
; 4724 :          cur += 1;
; 4725 :          prior += 1;
; 4726 :       }
; 4727 : 
; 4728 :       // this is a little gross, so that we don't switch per-pixel or per-component
; 4729 :       if (depth < 8 || img_n == out_n) {
; 4730 :          int nk = (width - 1)*filter_bytes;
; 4731 :          #define STBI__CASE(f) \
; 4732 :              case f:     \
; 4733 :                 for (k=0; k < nk; ++k)
; 4734 :          switch (filter) {
; 4735 :             // "none" filter turns into a memcpy here; make that explicit.
; 4736 :             case STBI__F_none:         memcpy(cur, raw, nk); break;
; 4737 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;
; 4738 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
; 4739 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;
; 4740 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;
; 4741 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;
; 4742 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;
; 4743 :          }
; 4744 :          #undef STBI__CASE
; 4745 :          raw += nk;
; 4746 :       } else {
; 4747 :          STBI_ASSERT(img_n+1 == out_n);
; 4748 :          #define STBI__CASE(f) \
; 4749 :              case f:     \
; 4750 :                 for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
; 4751 :                    for (k=0; k < filter_bytes; ++k)
; 4752 :          switch (filter) {
; 4753 :             STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;
; 4754 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;
; 4755 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
; 4756 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;
; 4757 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;
; 4758 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;
; 4759 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;
; 4760 :          }
; 4761 :          #undef STBI__CASE
; 4762 : 
; 4763 :          // the loop above sets the high byte of the pixels' alpha, but for
; 4764 :          // 16 bit png files we also need the low byte set. we'll do that here.
; 4765 :          if (depth == 16) {
; 4766 :             cur = a->out + stride*j; // start at the beginning of the row again
; 4767 :             for (i=0; i < x; ++i,cur+=output_bytes) {
; 4768 :                cur[filter_bytes+1] = 255;
; 4769 :             }
; 4770 :          }
; 4771 :       }
; 4772 :    }
; 4773 : 
; 4774 :    // we make a separate pass to expand bits to pixels; for performance,
; 4775 :    // this could run two scanlines behind the above code, so it won't
; 4776 :    // intefere with filtering but will still be in the cache.
; 4777 :    if (depth < 8) {
; 4778 :       for (j=0; j < y; ++j) {
; 4779 :          stbi_uc *cur = a->out + stride*j;
; 4780 :          stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
; 4781 :          // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
; 4782 :          // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
; 4783 :          stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range
; 4784 : 
; 4785 :          // note that the final byte might overshoot and write more data than desired.
; 4786 :          // we can allocate enough data that this never writes out of memory, but it
; 4787 :          // could also overwrite the next scanline. can it overwrite non-empty data
; 4788 :          // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
; 4789 :          // so we need to explicitly clamp the final ones
; 4790 : 
; 4791 :          if (depth == 4) {
; 4792 :             for (k=x*img_n; k >= 2; k-=2, ++in) {
; 4793 :                *cur++ = scale * ((*in >> 4)       );
; 4794 :                *cur++ = scale * ((*in     ) & 0x0f);
; 4795 :             }
; 4796 :             if (k > 0) *cur++ = scale * ((*in >> 4)       );
; 4797 :          } else if (depth == 2) {
; 4798 :             for (k=x*img_n; k >= 4; k-=4, ++in) {
; 4799 :                *cur++ = scale * ((*in >> 6)       );
; 4800 :                *cur++ = scale * ((*in >> 4) & 0x03);
; 4801 :                *cur++ = scale * ((*in >> 2) & 0x03);
; 4802 :                *cur++ = scale * ((*in     ) & 0x03);
; 4803 :             }
; 4804 :             if (k > 0) *cur++ = scale * ((*in >> 6)       );
; 4805 :             if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
; 4806 :             if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
; 4807 :          } else if (depth == 1) {
; 4808 :             for (k=x*img_n; k >= 8; k-=8, ++in) {
; 4809 :                *cur++ = scale * ((*in >> 7)       );
; 4810 :                *cur++ = scale * ((*in >> 6) & 0x01);
; 4811 :                *cur++ = scale * ((*in >> 5) & 0x01);
; 4812 :                *cur++ = scale * ((*in >> 4) & 0x01);
; 4813 :                *cur++ = scale * ((*in >> 3) & 0x01);
; 4814 :                *cur++ = scale * ((*in >> 2) & 0x01);
; 4815 :                *cur++ = scale * ((*in >> 1) & 0x01);
; 4816 :                *cur++ = scale * ((*in     ) & 0x01);
; 4817 :             }
; 4818 :             if (k > 0) *cur++ = scale * ((*in >> 7)       );
; 4819 :             if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
; 4820 :             if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
; 4821 :             if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
; 4822 :             if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
; 4823 :             if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
; 4824 :             if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
; 4825 :          }
; 4826 :          if (img_n != out_n) {
; 4827 :             int q;
; 4828 :             // insert alpha = 255
; 4829 :             cur = a->out + stride*j;
; 4830 :             if (img_n == 1) {
; 4831 :                for (q=x-1; q >= 0; --q) {
; 4832 :                   cur[q*2+1] = 255;
; 4833 :                   cur[q*2+0] = cur[q];
; 4834 :                }
; 4835 :             } else {
; 4836 :                STBI_ASSERT(img_n == 3);
; 4837 :                for (q=x-1; q >= 0; --q) {
; 4838 :                   cur[q*4+3] = 255;
; 4839 :                   cur[q*4+2] = cur[q*3+2];
; 4840 :                   cur[q*4+1] = cur[q*3+1];
; 4841 :                   cur[q*4+0] = cur[q*3+0];
; 4842 :                }
; 4843 :             }
; 4844 :          }
; 4845 :       }
; 4846 :    } else if (depth == 16) {
; 4847 :       // force the image data from big-endian to platform-native.
; 4848 :       // this is done in a separate pass due to the decoding relying
; 4849 :       // on the data being untouched, but could probably be done
; 4850 :       // per-line during decode if care is taken.
; 4851 :       stbi_uc *cur = a->out;
; 4852 :       stbi__uint16 *cur16 = (stbi__uint16*)cur;
; 4853 : 
; 4854 :       for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {
; 4855 :          *cur16 = (cur[0] << 8) | cur[1];
; 4856 :       }
; 4857 :    }
; 4858 : 
; 4859 :    return 1;
; 4860 : }
; 4861 : 
; 4862 : static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
; 4863 : {
; 4864 :    int bytes = (depth == 16 ? 2 : 1);
; 4865 :    int out_bytes = out_n * bytes;
; 4866 :    stbi_uc *final;
; 4867 :    int p;
; 4868 :    if (!interlaced)
; 4869 :       return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);
; 4870 : 
; 4871 :    // de-interlacing
; 4872 :    final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
; 4873 :    if (!final) return stbi__err("outofmem", "Out of memory");
; 4874 :    for (p=0; p < 7; ++p) {
; 4875 :       int xorig[] = { 0,4,0,2,0,1,0 };
; 4876 :       int yorig[] = { 0,0,4,0,2,0,1 };
; 4877 :       int xspc[]  = { 8,8,4,4,2,2,1 };
; 4878 :       int yspc[]  = { 8,8,8,4,4,2,2 };
; 4879 :       int i,j,x,y;
; 4880 :       // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
; 4881 :       x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
; 4882 :       y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
; 4883 :       if (x && y) {
; 4884 :          stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
; 4885 :          if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
; 4886 :             STBI_FREE(final);
; 4887 :             return 0;
; 4888 :          }
; 4889 :          for (j=0; j < y; ++j) {
; 4890 :             for (i=0; i < x; ++i) {
; 4891 :                int out_y = j*yspc[p]+yorig[p];
; 4892 :                int out_x = i*xspc[p]+xorig[p];
; 4893 :                memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
; 4894 :                       a->out + (j*x+i)*out_bytes, out_bytes);
; 4895 :             }
; 4896 :          }
; 4897 :          STBI_FREE(a->out);
; 4898 :          image_data += img_len;
; 4899 :          image_data_len -= img_len;
; 4900 :       }
; 4901 :    }
; 4902 :    a->out = final;
; 4903 : 
; 4904 :    return 1;
; 4905 : }
; 4906 : 
; 4907 : static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
; 4908 : {
; 4909 :    stbi__context *s = z->s;
; 4910 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 4911 :    stbi_uc *p = z->out;
; 4912 : 
; 4913 :    // compute color-based transparency, assuming we've
; 4914 :    // already got 255 as the alpha value in the output
; 4915 :    STBI_ASSERT(out_n == 2 || out_n == 4);
; 4916 : 
; 4917 :    if (out_n == 2) {
; 4918 :       for (i=0; i < pixel_count; ++i) {
; 4919 :          p[1] = (p[0] == tc[0] ? 0 : 255);
; 4920 :          p += 2;
; 4921 :       }
; 4922 :    } else {
; 4923 :       for (i=0; i < pixel_count; ++i) {
; 4924 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
; 4925 :             p[3] = 0;
; 4926 :          p += 4;
; 4927 :       }
; 4928 :    }
; 4929 :    return 1;
; 4930 : }
; 4931 : 
; 4932 : static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
; 4933 : {
; 4934 :    stbi__context *s = z->s;
; 4935 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 4936 :    stbi__uint16 *p = (stbi__uint16*) z->out;
; 4937 : 
; 4938 :    // compute color-based transparency, assuming we've
; 4939 :    // already got 65535 as the alpha value in the output
; 4940 :    STBI_ASSERT(out_n == 2 || out_n == 4);
; 4941 : 
; 4942 :    if (out_n == 2) {
; 4943 :       for (i = 0; i < pixel_count; ++i) {
; 4944 :          p[1] = (p[0] == tc[0] ? 0 : 65535);
; 4945 :          p += 2;
; 4946 :       }
; 4947 :    } else {
; 4948 :       for (i = 0; i < pixel_count; ++i) {
; 4949 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
; 4950 :             p[3] = 0;
; 4951 :          p += 4;
; 4952 :       }
; 4953 :    }
; 4954 :    return 1;
; 4955 : }
; 4956 : 
; 4957 : static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
; 4958 : {
; 4959 :    stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
; 4960 :    stbi_uc *p, *temp_out, *orig = a->out;
; 4961 : 
; 4962 :    p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
; 4963 :    if (p == NULL) return stbi__err("outofmem", "Out of memory");
; 4964 : 
; 4965 :    // between here and free(out) below, exitting would leak
; 4966 :    temp_out = p;
; 4967 : 
; 4968 :    if (pal_img_n == 3) {
; 4969 :       for (i=0; i < pixel_count; ++i) {
; 4970 :          int n = orig[i]*4;
; 4971 :          p[0] = palette[n  ];
; 4972 :          p[1] = palette[n+1];
; 4973 :          p[2] = palette[n+2];
; 4974 :          p += 3;
; 4975 :       }
; 4976 :    } else {
; 4977 :       for (i=0; i < pixel_count; ++i) {
; 4978 :          int n = orig[i]*4;
; 4979 :          p[0] = palette[n  ];
; 4980 :          p[1] = palette[n+1];
; 4981 :          p[2] = palette[n+2];
; 4982 :          p[3] = palette[n+3];
; 4983 :          p += 4;
; 4984 :       }
; 4985 :    }
; 4986 :    STBI_FREE(a->out);
; 4987 :    a->out = temp_out;
; 4988 : 
; 4989 :    STBI_NOTUSED(len);
; 4990 : 
; 4991 :    return 1;
; 4992 : }
; 4993 : 
; 4994 : static int stbi__unpremultiply_on_load_global = 0;
; 4995 : static int stbi__de_iphone_flag_global = 0;
; 4996 : 
; 4997 : STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
; 4998 : {
; 4999 :    stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
; 5000 : }
; 5001 : 
; 5002 : STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
; 5003 : {
; 5004 :    stbi__de_iphone_flag_global = flag_true_if_should_convert;
; 5005 : }
; 5006 : 
; 5007 : #ifndef STBI_THREAD_LOCAL
; 5008 : #define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global
; 5009 : #define stbi__de_iphone_flag  stbi__de_iphone_flag_global
; 5010 : #else
; 5011 : static STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;
; 5012 : static STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;
; 5013 : 
; 5014 : STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
; 5015 : {
; 5016 :    stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
; 5017 :    stbi__unpremultiply_on_load_set = 1;
; 5018 : }
; 5019 : 
; 5020 : STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
; 5021 : {
; 5022 :    stbi__de_iphone_flag_local = flag_true_if_should_convert;
; 5023 :    stbi__de_iphone_flag_set = 1;
; 5024 : }
; 5025 : 
; 5026 : #define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \
; 5027 :                                        ? stbi__unpremultiply_on_load_local      \
; 5028 :                                        : stbi__unpremultiply_on_load_global)
; 5029 : #define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \
; 5030 :                                 ? stbi__de_iphone_flag_local                    \
; 5031 :                                 : stbi__de_iphone_flag_global)
; 5032 : #endif // STBI_THREAD_LOCAL
; 5033 : 
; 5034 : static void stbi__de_iphone(stbi__png *z)
; 5035 : {
; 5036 :    stbi__context *s = z->s;
; 5037 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 5038 :    stbi_uc *p = z->out;
; 5039 : 
; 5040 :    if (s->img_out_n == 3) {  // convert bgr to rgb
; 5041 :       for (i=0; i < pixel_count; ++i) {
; 5042 :          stbi_uc t = p[0];
; 5043 :          p[0] = p[2];
; 5044 :          p[2] = t;
; 5045 :          p += 3;
; 5046 :       }
; 5047 :    } else {
; 5048 :       STBI_ASSERT(s->img_out_n == 4);
; 5049 :       if (stbi__unpremultiply_on_load) {
; 5050 :          // convert bgr to rgb and unpremultiply
; 5051 :          for (i=0; i < pixel_count; ++i) {
; 5052 :             stbi_uc a = p[3];
; 5053 :             stbi_uc t = p[0];
; 5054 :             if (a) {
; 5055 :                stbi_uc half = a / 2;
; 5056 :                p[0] = (p[2] * 255 + half) / a;
; 5057 :                p[1] = (p[1] * 255 + half) / a;
; 5058 :                p[2] = ( t   * 255 + half) / a;
; 5059 :             } else {
; 5060 :                p[0] = p[2];
; 5061 :                p[2] = t;
; 5062 :             }
; 5063 :             p += 4;
; 5064 :          }
; 5065 :       } else {
; 5066 :          // convert bgr to rgb
; 5067 :          for (i=0; i < pixel_count; ++i) {
; 5068 :             stbi_uc t = p[0];
; 5069 :             p[0] = p[2];
; 5070 :             p[2] = t;
; 5071 :             p += 4;
; 5072 :          }
; 5073 :       }
; 5074 :    }
; 5075 : }
; 5076 : 
; 5077 : #define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))
; 5078 : 
; 5079 : static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
; 5080 : {
; 5081 :    stbi_uc palette[1024], pal_img_n=0;
; 5082 :    stbi_uc has_trans=0, tc[3]={0};
; 5083 :    stbi__uint16 tc16[3];
; 5084 :    stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
; 5085 :    int first=1,k,interlace=0, color=0, is_iphone=0;
; 5086 :    stbi__context *s = z->s;
; 5087 : 
; 5088 :    z->expanded = NULL;
; 5089 :    z->idata = NULL;
; 5090 :    z->out = NULL;
; 5091 : 
; 5092 :    if (!stbi__check_png_header(s)) return 0;
; 5093 : 
; 5094 :    if (scan == STBI__SCAN_type) return 1;
; 5095 : 
; 5096 :    for (;;) {
; 5097 :       stbi__pngchunk c = stbi__get_chunk_header(s);
; 5098 :       switch (c.type) {
; 5099 :          case STBI__PNG_TYPE('C','g','B','I'):
; 5100 :             is_iphone = 1;
; 5101 :             stbi__skip(s, c.length);
; 5102 :             break;
; 5103 :          case STBI__PNG_TYPE('I','H','D','R'): {
; 5104 :             int comp,filter;
; 5105 :             if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
; 5106 :             first = 0;
; 5107 :             if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
; 5108 :             s->img_x = stbi__get32be(s);
; 5109 :             s->img_y = stbi__get32be(s);
; 5110 :             if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 5111 :             if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 5112 :             z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
; 5113 :             color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
; 5114 :             if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
; 5115 :             if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
; 5116 :             comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
; 5117 :             filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
; 5118 :             interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
; 5119 :             if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
; 5120 :             if (!pal_img_n) {
; 5121 :                s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
; 5122 :                if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
; 5123 :             } else {
; 5124 :                // if paletted, then pal_n is our final components, and
; 5125 :                // img_n is # components to decompress/filter.
; 5126 :                s->img_n = 1;
; 5127 :                if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
; 5128 :             }
; 5129 :             // even with SCAN_header, have to scan to see if we have a tRNS
; 5130 :             break;
; 5131 :          }
; 5132 : 
; 5133 :          case STBI__PNG_TYPE('P','L','T','E'):  {
; 5134 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5135 :             if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
; 5136 :             pal_len = c.length / 3;
; 5137 :             if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
; 5138 :             for (i=0; i < pal_len; ++i) {
; 5139 :                palette[i*4+0] = stbi__get8(s);
; 5140 :                palette[i*4+1] = stbi__get8(s);
; 5141 :                palette[i*4+2] = stbi__get8(s);
; 5142 :                palette[i*4+3] = 255;
; 5143 :             }
; 5144 :             break;
; 5145 :          }
; 5146 : 
; 5147 :          case STBI__PNG_TYPE('t','R','N','S'): {
; 5148 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5149 :             if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
; 5150 :             if (pal_img_n) {
; 5151 :                if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
; 5152 :                if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
; 5153 :                if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
; 5154 :                pal_img_n = 4;
; 5155 :                for (i=0; i < c.length; ++i)
; 5156 :                   palette[i*4+3] = stbi__get8(s);
; 5157 :             } else {
; 5158 :                if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
; 5159 :                if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
; 5160 :                has_trans = 1;
; 5161 :                // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.
; 5162 :                if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }
; 5163 :                if (z->depth == 16) {
; 5164 :                   for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
; 5165 :                } else {
; 5166 :                   for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
; 5167 :                }
; 5168 :             }
; 5169 :             break;
; 5170 :          }
; 5171 : 
; 5172 :          case STBI__PNG_TYPE('I','D','A','T'): {
; 5173 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5174 :             if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
; 5175 :             if (scan == STBI__SCAN_header) {
; 5176 :                // header scan definitely stops at first IDAT
; 5177 :                if (pal_img_n)
; 5178 :                   s->img_n = pal_img_n;
; 5179 :                return 1;
; 5180 :             }
; 5181 :             if (c.length > (1u << 30)) return stbi__err("IDAT size limit", "IDAT section larger than 2^30 bytes");
; 5182 :             if ((int)(ioff + c.length) < (int)ioff) return 0;
; 5183 :             if (ioff + c.length > idata_limit) {
; 5184 :                stbi__uint32 idata_limit_old = idata_limit;
; 5185 :                stbi_uc *p;
; 5186 :                if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
; 5187 :                while (ioff + c.length > idata_limit)
; 5188 :                   idata_limit *= 2;
; 5189 :                STBI_NOTUSED(idata_limit_old);
; 5190 :                p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
; 5191 :                z->idata = p;
; 5192 :             }
; 5193 :             if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
; 5194 :             ioff += c.length;
; 5195 :             break;
; 5196 :          }
; 5197 : 
; 5198 :          case STBI__PNG_TYPE('I','E','N','D'): {
; 5199 :             stbi__uint32 raw_len, bpl;
; 5200 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5201 :             if (scan != STBI__SCAN_load) return 1;
; 5202 :             if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
; 5203 :             // initial guess for decoded data size to avoid unnecessary reallocs
; 5204 :             bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
; 5205 :             raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
; 5206 :             z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
; 5207 :             if (z->expanded == NULL) return 0; // zlib should set error
; 5208 :             STBI_FREE(z->idata); z->idata = NULL;
; 5209 :             if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
; 5210 :                s->img_out_n = s->img_n+1;
; 5211 :             else
; 5212 :                s->img_out_n = s->img_n;
; 5213 :             if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
; 5214 :             if (has_trans) {
; 5215 :                if (z->depth == 16) {
; 5216 :                   if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
; 5217 :                } else {
; 5218 :                   if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
; 5219 :                }
; 5220 :             }
; 5221 :             if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
; 5222 :                stbi__de_iphone(z);
; 5223 :             if (pal_img_n) {
; 5224 :                // pal_img_n == 3 or 4
; 5225 :                s->img_n = pal_img_n; // record the actual colors we had
; 5226 :                s->img_out_n = pal_img_n;
; 5227 :                if (req_comp >= 3) s->img_out_n = req_comp;
; 5228 :                if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
; 5229 :                   return 0;
; 5230 :             } else if (has_trans) {
; 5231 :                // non-paletted image with tRNS -> source image has (constant) alpha
; 5232 :                ++s->img_n;
; 5233 :             }
; 5234 :             STBI_FREE(z->expanded); z->expanded = NULL;
; 5235 :             // end of PNG chunk, read and skip CRC
; 5236 :             stbi__get32be(s);
; 5237 :             return 1;
; 5238 :          }
; 5239 : 
; 5240 :          default:
; 5241 :             // if critical, fail
; 5242 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5243 :             if ((c.type & (1 << 29)) == 0) {
; 5244 :                #ifndef STBI_NO_FAILURE_STRINGS
; 5245 :                // not threadsafe
; 5246 :                static char invalid_chunk[] = "XXXX PNG chunk not known";
; 5247 :                invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
; 5248 :                invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
; 5249 :                invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
; 5250 :                invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
; 5251 :                #endif
; 5252 :                return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
; 5253 :             }
; 5254 :             stbi__skip(s, c.length);
; 5255 :             break;
; 5256 :       }
; 5257 :       // end of PNG chunk, read and skip CRC
; 5258 :       stbi__get32be(s);
; 5259 :    }
; 5260 : }
; 5261 : 
; 5262 : static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
; 5263 : {
; 5264 :    void *result=NULL;
; 5265 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
; 5266 :    if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
; 5267 :       if (p->depth <= 8)
; 5268 :          ri->bits_per_channel = 8;
; 5269 :       else if (p->depth == 16)
; 5270 :          ri->bits_per_channel = 16;
; 5271 :       else
; 5272 :          return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
; 5273 :       result = p->out;
; 5274 :       p->out = NULL;
; 5275 :       if (req_comp && req_comp != p->s->img_out_n) {
; 5276 :          if (ri->bits_per_channel == 8)
; 5277 :             result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
; 5278 :          else
; 5279 :             result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
; 5280 :          p->s->img_out_n = req_comp;
; 5281 :          if (result == NULL) return result;
; 5282 :       }
; 5283 :       *x = p->s->img_x;
; 5284 :       *y = p->s->img_y;
; 5285 :       if (n) *n = p->s->img_n;
; 5286 :    }
; 5287 :    STBI_FREE(p->out);      p->out      = NULL;
; 5288 :    STBI_FREE(p->expanded); p->expanded = NULL;
; 5289 :    STBI_FREE(p->idata);    p->idata    = NULL;
; 5290 : 
; 5291 :    return result;
; 5292 : }
; 5293 : 
; 5294 : static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5295 : {
; 5296 :    stbi__png p;
; 5297 :    p.s = s;
; 5298 :    return stbi__do_png(&p, x,y,comp,req_comp, ri);
; 5299 : }
; 5300 : 
; 5301 : static int stbi__png_test(stbi__context *s)
; 5302 : {
; 5303 :    int r;
; 5304 :    r = stbi__check_png_header(s);
; 5305 :    stbi__rewind(s);
; 5306 :    return r;
; 5307 : }
; 5308 : 
; 5309 : static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
; 5310 : {
; 5311 :    if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
; 5312 :       stbi__rewind( p->s );
; 5313 :       return 0;
; 5314 :    }
; 5315 :    if (x) *x = p->s->img_x;
; 5316 :    if (y) *y = p->s->img_y;
; 5317 :    if (comp) *comp = p->s->img_n;
; 5318 :    return 1;
; 5319 : }
; 5320 : 
; 5321 : static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
; 5322 : {
; 5323 :    stbi__png p;
; 5324 :    p.s = s;
; 5325 :    return stbi__png_info_raw(&p, x, y, comp);
; 5326 : }
; 5327 : 
; 5328 : static int stbi__png_is16(stbi__context *s)
; 5329 : {
; 5330 :    stbi__png p;
; 5331 :    p.s = s;
; 5332 :    if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
; 5333 : 	   return 0;
; 5334 :    if (p.depth != 16) {
; 5335 :       stbi__rewind(p.s);
; 5336 :       return 0;
; 5337 :    }
; 5338 :    return 1;
; 5339 : }
; 5340 : #endif
; 5341 : 
; 5342 : // Microsoft/Windows BMP image
; 5343 : 
; 5344 : #ifndef STBI_NO_BMP
; 5345 : static int stbi__bmp_test_raw(stbi__context *s)
; 5346 : {
; 5347 :    int r;
; 5348 :    int sz;
; 5349 :    if (stbi__get8(s) != 'B') return 0;
; 5350 :    if (stbi__get8(s) != 'M') return 0;
; 5351 :    stbi__get32le(s); // discard filesize
; 5352 :    stbi__get16le(s); // discard reserved
; 5353 :    stbi__get16le(s); // discard reserved
; 5354 :    stbi__get32le(s); // discard data offset
; 5355 :    sz = stbi__get32le(s);
; 5356 :    r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
; 5357 :    return r;
; 5358 : }
; 5359 : 
; 5360 : static int stbi__bmp_test(stbi__context *s)
; 5361 : {
; 5362 :    int r = stbi__bmp_test_raw(s);
; 5363 :    stbi__rewind(s);
; 5364 :    return r;
; 5365 : }
; 5366 : 
; 5367 : 
; 5368 : // returns 0..31 for the highest set bit
; 5369 : static int stbi__high_bit(unsigned int z)
; 5370 : {
; 5371 :    int n=0;
; 5372 :    if (z == 0) return -1;
; 5373 :    if (z >= 0x10000) { n += 16; z >>= 16; }
; 5374 :    if (z >= 0x00100) { n +=  8; z >>=  8; }
; 5375 :    if (z >= 0x00010) { n +=  4; z >>=  4; }
; 5376 :    if (z >= 0x00004) { n +=  2; z >>=  2; }
; 5377 :    if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
; 5378 :    return n;
; 5379 : }
; 5380 : 
; 5381 : static int stbi__bitcount(unsigned int a)
; 5382 : {
; 5383 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
; 5384 :    a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
; 5385 :    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
; 5386 :    a = (a + (a >> 8)); // max 16 per 8 bits
; 5387 :    a = (a + (a >> 16)); // max 32 per 8 bits
; 5388 :    return a & 0xff;
; 5389 : }
; 5390 : 
; 5391 : // extract an arbitrarily-aligned N-bit value (N=bits)
; 5392 : // from v, and then make it 8-bits long and fractionally
; 5393 : // extend it to full full range.
; 5394 : static int stbi__shiftsigned(unsigned int v, int shift, int bits)
; 5395 : {
; 5396 :    static unsigned int mul_table[9] = {
; 5397 :       0,
; 5398 :       0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
; 5399 :       0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
; 5400 :    };
; 5401 :    static unsigned int shift_table[9] = {
; 5402 :       0, 0,0,1,0,2,4,6,0,
; 5403 :    };
; 5404 :    if (shift < 0)
; 5405 :       v <<= -shift;
; 5406 :    else
; 5407 :       v >>= shift;
; 5408 :    STBI_ASSERT(v < 256);
; 5409 :    v >>= (8-bits);
; 5410 :    STBI_ASSERT(bits >= 0 && bits <= 8);
; 5411 :    return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
; 5412 : }
; 5413 : 
; 5414 : typedef struct
; 5415 : {
; 5416 :    int bpp, offset, hsz;
; 5417 :    unsigned int mr,mg,mb,ma, all_a;
; 5418 :    int extra_read;
; 5419 : } stbi__bmp_data;
; 5420 : 
; 5421 : static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
; 5422 : {
; 5423 :    // BI_BITFIELDS specifies masks explicitly, don't override
; 5424 :    if (compress == 3)
; 5425 :       return 1;
; 5426 : 
; 5427 :    if (compress == 0) {
; 5428 :       if (info->bpp == 16) {
; 5429 :          info->mr = 31u << 10;
; 5430 :          info->mg = 31u <<  5;
; 5431 :          info->mb = 31u <<  0;
; 5432 :       } else if (info->bpp == 32) {
; 5433 :          info->mr = 0xffu << 16;
; 5434 :          info->mg = 0xffu <<  8;
; 5435 :          info->mb = 0xffu <<  0;
; 5436 :          info->ma = 0xffu << 24;
; 5437 :          info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
; 5438 :       } else {
; 5439 :          // otherwise, use defaults, which is all-0
; 5440 :          info->mr = info->mg = info->mb = info->ma = 0;
; 5441 :       }
; 5442 :       return 1;
; 5443 :    }
; 5444 :    return 0; // error
; 5445 : }
; 5446 : 
; 5447 : static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
; 5448 : {
; 5449 :    int hsz;
; 5450 :    if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
; 5451 :    stbi__get32le(s); // discard filesize
; 5452 :    stbi__get16le(s); // discard reserved
; 5453 :    stbi__get16le(s); // discard reserved
; 5454 :    info->offset = stbi__get32le(s);
; 5455 :    info->hsz = hsz = stbi__get32le(s);
; 5456 :    info->mr = info->mg = info->mb = info->ma = 0;
; 5457 :    info->extra_read = 14;
; 5458 : 
; 5459 :    if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");
; 5460 : 
; 5461 :    if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
; 5462 :    if (hsz == 12) {
; 5463 :       s->img_x = stbi__get16le(s);
; 5464 :       s->img_y = stbi__get16le(s);
; 5465 :    } else {
; 5466 :       s->img_x = stbi__get32le(s);
; 5467 :       s->img_y = stbi__get32le(s);
; 5468 :    }
; 5469 :    if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
; 5470 :    info->bpp = stbi__get16le(s);
; 5471 :    if (hsz != 12) {
; 5472 :       int compress = stbi__get32le(s);
; 5473 :       if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
; 5474 :       if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes
; 5475 :       if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel
; 5476 :       stbi__get32le(s); // discard sizeof
; 5477 :       stbi__get32le(s); // discard hres
; 5478 :       stbi__get32le(s); // discard vres
; 5479 :       stbi__get32le(s); // discard colorsused
; 5480 :       stbi__get32le(s); // discard max important
; 5481 :       if (hsz == 40 || hsz == 56) {
; 5482 :          if (hsz == 56) {
; 5483 :             stbi__get32le(s);
; 5484 :             stbi__get32le(s);
; 5485 :             stbi__get32le(s);
; 5486 :             stbi__get32le(s);
; 5487 :          }
; 5488 :          if (info->bpp == 16 || info->bpp == 32) {
; 5489 :             if (compress == 0) {
; 5490 :                stbi__bmp_set_mask_defaults(info, compress);
; 5491 :             } else if (compress == 3) {
; 5492 :                info->mr = stbi__get32le(s);
; 5493 :                info->mg = stbi__get32le(s);
; 5494 :                info->mb = stbi__get32le(s);
; 5495 :                info->extra_read += 12;
; 5496 :                // not documented, but generated by photoshop and handled by mspaint
; 5497 :                if (info->mr == info->mg && info->mg == info->mb) {
; 5498 :                   // ?!?!?
; 5499 :                   return stbi__errpuc("bad BMP", "bad BMP");
; 5500 :                }
; 5501 :             } else
; 5502 :                return stbi__errpuc("bad BMP", "bad BMP");
; 5503 :          }
; 5504 :       } else {
; 5505 :          // V4/V5 header
; 5506 :          int i;
; 5507 :          if (hsz != 108 && hsz != 124)
; 5508 :             return stbi__errpuc("bad BMP", "bad BMP");
; 5509 :          info->mr = stbi__get32le(s);
; 5510 :          info->mg = stbi__get32le(s);
; 5511 :          info->mb = stbi__get32le(s);
; 5512 :          info->ma = stbi__get32le(s);
; 5513 :          if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
; 5514 :             stbi__bmp_set_mask_defaults(info, compress);
; 5515 :          stbi__get32le(s); // discard color space
; 5516 :          for (i=0; i < 12; ++i)
; 5517 :             stbi__get32le(s); // discard color space parameters
; 5518 :          if (hsz == 124) {
; 5519 :             stbi__get32le(s); // discard rendering intent
; 5520 :             stbi__get32le(s); // discard offset of profile data
; 5521 :             stbi__get32le(s); // discard size of profile data
; 5522 :             stbi__get32le(s); // discard reserved
; 5523 :          }
; 5524 :       }
; 5525 :    }
; 5526 :    return (void *) 1;
; 5527 : }
; 5528 : 
; 5529 : 
; 5530 : static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5531 : {
; 5532 :    stbi_uc *out;
; 5533 :    unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
; 5534 :    stbi_uc pal[256][4];
; 5535 :    int psize=0,i,j,width;
; 5536 :    int flip_vertically, pad, target;
; 5537 :    stbi__bmp_data info;
; 5538 :    STBI_NOTUSED(ri);
; 5539 : 
; 5540 :    info.all_a = 255;
; 5541 :    if (stbi__bmp_parse_header(s, &info) == NULL)
; 5542 :       return NULL; // error code already set
; 5543 : 
; 5544 :    flip_vertically = ((int) s->img_y) > 0;
; 5545 :    s->img_y = abs((int) s->img_y);
; 5546 : 
; 5547 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5548 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5549 : 
; 5550 :    mr = info.mr;
; 5551 :    mg = info.mg;
; 5552 :    mb = info.mb;
; 5553 :    ma = info.ma;
; 5554 :    all_a = info.all_a;
; 5555 : 
; 5556 :    if (info.hsz == 12) {
; 5557 :       if (info.bpp < 24)
; 5558 :          psize = (info.offset - info.extra_read - 24) / 3;
; 5559 :    } else {
; 5560 :       if (info.bpp < 16)
; 5561 :          psize = (info.offset - info.extra_read - info.hsz) >> 2;
; 5562 :    }
; 5563 :    if (psize == 0) {
; 5564 :       // accept some number of extra bytes after the header, but if the offset points either to before
; 5565 :       // the header ends or implies a large amount of extra data, reject the file as malformed
; 5566 :       int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);
; 5567 :       int header_limit = 1024; // max we actually read is below 256 bytes currently.
; 5568 :       int extra_data_limit = 256*4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.
; 5569 :       if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {
; 5570 :          return stbi__errpuc("bad header", "Corrupt BMP");
; 5571 :       }
; 5572 :       // we established that bytes_read_so_far is positive and sensible.
; 5573 :       // the first half of this test rejects offsets that are either too small positives, or
; 5574 :       // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn
; 5575 :       // ensures the number computed in the second half of the test can't overflow.
; 5576 :       if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {
; 5577 :          return stbi__errpuc("bad offset", "Corrupt BMP");
; 5578 :       } else {
; 5579 :          stbi__skip(s, info.offset - bytes_read_so_far);
; 5580 :       }
; 5581 :    }
; 5582 : 
; 5583 :    if (info.bpp == 24 && ma == 0xff000000)
; 5584 :       s->img_n = 3;
; 5585 :    else
; 5586 :       s->img_n = ma ? 4 : 3;
; 5587 :    if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
; 5588 :       target = req_comp;
; 5589 :    else
; 5590 :       target = s->img_n; // if they want monochrome, we'll post-convert
; 5591 : 
; 5592 :    // sanity-check size
; 5593 :    if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
; 5594 :       return stbi__errpuc("too large", "Corrupt BMP");
; 5595 : 
; 5596 :    out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
; 5597 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");
; 5598 :    if (info.bpp < 16) {
; 5599 :       int z=0;
; 5600 :       if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
; 5601 :       for (i=0; i < psize; ++i) {
; 5602 :          pal[i][2] = stbi__get8(s);
; 5603 :          pal[i][1] = stbi__get8(s);
; 5604 :          pal[i][0] = stbi__get8(s);
; 5605 :          if (info.hsz != 12) stbi__get8(s);
; 5606 :          pal[i][3] = 255;
; 5607 :       }
; 5608 :       stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
; 5609 :       if (info.bpp == 1) width = (s->img_x + 7) >> 3;
; 5610 :       else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
; 5611 :       else if (info.bpp == 8) width = s->img_x;
; 5612 :       else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
; 5613 :       pad = (-width)&3;
; 5614 :       if (info.bpp == 1) {
; 5615 :          for (j=0; j < (int) s->img_y; ++j) {
; 5616 :             int bit_offset = 7, v = stbi__get8(s);
; 5617 :             for (i=0; i < (int) s->img_x; ++i) {
; 5618 :                int color = (v>>bit_offset)&0x1;
; 5619 :                out[z++] = pal[color][0];
; 5620 :                out[z++] = pal[color][1];
; 5621 :                out[z++] = pal[color][2];
; 5622 :                if (target == 4) out[z++] = 255;
; 5623 :                if (i+1 == (int) s->img_x) break;
; 5624 :                if((--bit_offset) < 0) {
; 5625 :                   bit_offset = 7;
; 5626 :                   v = stbi__get8(s);
; 5627 :                }
; 5628 :             }
; 5629 :             stbi__skip(s, pad);
; 5630 :          }
; 5631 :       } else {
; 5632 :          for (j=0; j < (int) s->img_y; ++j) {
; 5633 :             for (i=0; i < (int) s->img_x; i += 2) {
; 5634 :                int v=stbi__get8(s),v2=0;
; 5635 :                if (info.bpp == 4) {
; 5636 :                   v2 = v & 15;
; 5637 :                   v >>= 4;
; 5638 :                }
; 5639 :                out[z++] = pal[v][0];
; 5640 :                out[z++] = pal[v][1];
; 5641 :                out[z++] = pal[v][2];
; 5642 :                if (target == 4) out[z++] = 255;
; 5643 :                if (i+1 == (int) s->img_x) break;
; 5644 :                v = (info.bpp == 8) ? stbi__get8(s) : v2;
; 5645 :                out[z++] = pal[v][0];
; 5646 :                out[z++] = pal[v][1];
; 5647 :                out[z++] = pal[v][2];
; 5648 :                if (target == 4) out[z++] = 255;
; 5649 :             }
; 5650 :             stbi__skip(s, pad);
; 5651 :          }
; 5652 :       }
; 5653 :    } else {
; 5654 :       int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
; 5655 :       int z = 0;
; 5656 :       int easy=0;
; 5657 :       stbi__skip(s, info.offset - info.extra_read - info.hsz);
; 5658 :       if (info.bpp == 24) width = 3 * s->img_x;
; 5659 :       else if (info.bpp == 16) width = 2*s->img_x;
; 5660 :       else /* bpp = 32 and pad = 0 */ width=0;
; 5661 :       pad = (-width) & 3;
; 5662 :       if (info.bpp == 24) {
; 5663 :          easy = 1;
; 5664 :       } else if (info.bpp == 32) {
; 5665 :          if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
; 5666 :             easy = 2;
; 5667 :       }
; 5668 :       if (!easy) {
; 5669 :          if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
; 5670 :          // right shift amt to put high bit in position #7
; 5671 :          rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
; 5672 :          gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
; 5673 :          bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
; 5674 :          ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
; 5675 :          if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
; 5676 :       }
; 5677 :       for (j=0; j < (int) s->img_y; ++j) {
; 5678 :          if (easy) {
; 5679 :             for (i=0; i < (int) s->img_x; ++i) {
; 5680 :                unsigned char a;
; 5681 :                out[z+2] = stbi__get8(s);
; 5682 :                out[z+1] = stbi__get8(s);
; 5683 :                out[z+0] = stbi__get8(s);
; 5684 :                z += 3;
; 5685 :                a = (easy == 2 ? stbi__get8(s) : 255);
; 5686 :                all_a |= a;
; 5687 :                if (target == 4) out[z++] = a;
; 5688 :             }
; 5689 :          } else {
; 5690 :             int bpp = info.bpp;
; 5691 :             for (i=0; i < (int) s->img_x; ++i) {
; 5692 :                stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
; 5693 :                unsigned int a;
; 5694 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
; 5695 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
; 5696 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
; 5697 :                a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
; 5698 :                all_a |= a;
; 5699 :                if (target == 4) out[z++] = STBI__BYTECAST(a);
; 5700 :             }
; 5701 :          }
; 5702 :          stbi__skip(s, pad);
; 5703 :       }
; 5704 :    }
; 5705 : 
; 5706 :    // if alpha channel is all 0s, replace with all 255s
; 5707 :    if (target == 4 && all_a == 0)
; 5708 :       for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
; 5709 :          out[i] = 255;
; 5710 : 
; 5711 :    if (flip_vertically) {
; 5712 :       stbi_uc t;
; 5713 :       for (j=0; j < (int) s->img_y>>1; ++j) {
; 5714 :          stbi_uc *p1 = out +      j     *s->img_x*target;
; 5715 :          stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
; 5716 :          for (i=0; i < (int) s->img_x*target; ++i) {
; 5717 :             t = p1[i]; p1[i] = p2[i]; p2[i] = t;
; 5718 :          }
; 5719 :       }
; 5720 :    }
; 5721 : 
; 5722 :    if (req_comp && req_comp != target) {
; 5723 :       out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
; 5724 :       if (out == NULL) return out; // stbi__convert_format frees input on failure
; 5725 :    }
; 5726 : 
; 5727 :    *x = s->img_x;
; 5728 :    *y = s->img_y;
; 5729 :    if (comp) *comp = s->img_n;
; 5730 :    return out;
; 5731 : }
; 5732 : #endif
; 5733 : 
; 5734 : // Targa Truevision - TGA
; 5735 : // by Jonathan Dummer
; 5736 : #ifndef STBI_NO_TGA
; 5737 : // returns STBI_rgb or whatever, 0 on error
; 5738 : static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
; 5739 : {
; 5740 :    // only RGB or RGBA (incl. 16bit) or grey allowed
; 5741 :    if (is_rgb16) *is_rgb16 = 0;
; 5742 :    switch(bits_per_pixel) {
; 5743 :       case 8:  return STBI_grey;
; 5744 :       case 16: if(is_grey) return STBI_grey_alpha;
; 5745 :                // fallthrough
; 5746 :       case 15: if(is_rgb16) *is_rgb16 = 1;
; 5747 :                return STBI_rgb;
; 5748 :       case 24: // fallthrough
; 5749 :       case 32: return bits_per_pixel/8;
; 5750 :       default: return 0;
; 5751 :    }
; 5752 : }
; 5753 : 
; 5754 : static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
; 5755 : {
; 5756 :     int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
; 5757 :     int sz, tga_colormap_type;
; 5758 :     stbi__get8(s);                   // discard Offset
; 5759 :     tga_colormap_type = stbi__get8(s); // colormap type
; 5760 :     if( tga_colormap_type > 1 ) {
; 5761 :         stbi__rewind(s);
; 5762 :         return 0;      // only RGB or indexed allowed
; 5763 :     }
; 5764 :     tga_image_type = stbi__get8(s); // image type
; 5765 :     if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
; 5766 :         if (tga_image_type != 1 && tga_image_type != 9) {
; 5767 :             stbi__rewind(s);
; 5768 :             return 0;
; 5769 :         }
; 5770 :         stbi__skip(s,4);       // skip index of first colormap entry and number of entries
; 5771 :         sz = stbi__get8(s);    //   check bits per palette color entry
; 5772 :         if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
; 5773 :             stbi__rewind(s);
; 5774 :             return 0;
; 5775 :         }
; 5776 :         stbi__skip(s,4);       // skip image x and y origin
; 5777 :         tga_colormap_bpp = sz;
; 5778 :     } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
; 5779 :         if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
; 5780 :             stbi__rewind(s);
; 5781 :             return 0; // only RGB or grey allowed, +/- RLE
; 5782 :         }
; 5783 :         stbi__skip(s,9); // skip colormap specification and image x/y origin
; 5784 :         tga_colormap_bpp = 0;
; 5785 :     }
; 5786 :     tga_w = stbi__get16le(s);
; 5787 :     if( tga_w < 1 ) {
; 5788 :         stbi__rewind(s);
; 5789 :         return 0;   // test width
; 5790 :     }
; 5791 :     tga_h = stbi__get16le(s);
; 5792 :     if( tga_h < 1 ) {
; 5793 :         stbi__rewind(s);
; 5794 :         return 0;   // test height
; 5795 :     }
; 5796 :     tga_bits_per_pixel = stbi__get8(s); // bits per pixel
; 5797 :     stbi__get8(s); // ignore alpha bits
; 5798 :     if (tga_colormap_bpp != 0) {
; 5799 :         if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
; 5800 :             // when using a colormap, tga_bits_per_pixel is the size of the indexes
; 5801 :             // I don't think anything but 8 or 16bit indexes makes sense
; 5802 :             stbi__rewind(s);
; 5803 :             return 0;
; 5804 :         }
; 5805 :         tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
; 5806 :     } else {
; 5807 :         tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
; 5808 :     }
; 5809 :     if(!tga_comp) {
; 5810 :       stbi__rewind(s);
; 5811 :       return 0;
; 5812 :     }
; 5813 :     if (x) *x = tga_w;
; 5814 :     if (y) *y = tga_h;
; 5815 :     if (comp) *comp = tga_comp;
; 5816 :     return 1;                   // seems to have passed everything
; 5817 : }
; 5818 : 
; 5819 : static int stbi__tga_test(stbi__context *s)
; 5820 : {
; 5821 :    int res = 0;
; 5822 :    int sz, tga_color_type;
; 5823 :    stbi__get8(s);      //   discard Offset
; 5824 :    tga_color_type = stbi__get8(s);   //   color type
; 5825 :    if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
; 5826 :    sz = stbi__get8(s);   //   image type
; 5827 :    if ( tga_color_type == 1 ) { // colormapped (paletted) image
; 5828 :       if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
; 5829 :       stbi__skip(s,4);       // skip index of first colormap entry and number of entries
; 5830 :       sz = stbi__get8(s);    //   check bits per palette color entry
; 5831 :       if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
; 5832 :       stbi__skip(s,4);       // skip image x and y origin
; 5833 :    } else { // "normal" image w/o colormap
; 5834 :       if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
; 5835 :       stbi__skip(s,9); // skip colormap specification and image x/y origin
; 5836 :    }
; 5837 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
; 5838 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
; 5839 :    sz = stbi__get8(s);   //   bits per pixel
; 5840 :    if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
; 5841 :    if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
; 5842 : 
; 5843 :    res = 1; // if we got this far, everything's good and we can return 1 instead of 0
; 5844 : 
; 5845 : errorEnd:
; 5846 :    stbi__rewind(s);
; 5847 :    return res;
; 5848 : }
; 5849 : 
; 5850 : // read 16bit value and convert to 24bit RGB
; 5851 : static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
; 5852 : {
; 5853 :    stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
; 5854 :    stbi__uint16 fiveBitMask = 31;
; 5855 :    // we have 3 channels with 5bits each
; 5856 :    int r = (px >> 10) & fiveBitMask;
; 5857 :    int g = (px >> 5) & fiveBitMask;
; 5858 :    int b = px & fiveBitMask;
; 5859 :    // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
; 5860 :    out[0] = (stbi_uc)((r * 255)/31);
; 5861 :    out[1] = (stbi_uc)((g * 255)/31);
; 5862 :    out[2] = (stbi_uc)((b * 255)/31);
; 5863 : 
; 5864 :    // some people claim that the most significant bit might be used for alpha
; 5865 :    // (possibly if an alpha-bit is set in the "image descriptor byte")
; 5866 :    // but that only made 16bit test images completely translucent..
; 5867 :    // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
; 5868 : }
; 5869 : 
; 5870 : static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5871 : {
; 5872 :    //   read in the TGA header stuff
; 5873 :    int tga_offset = stbi__get8(s);
; 5874 :    int tga_indexed = stbi__get8(s);
; 5875 :    int tga_image_type = stbi__get8(s);
; 5876 :    int tga_is_RLE = 0;
; 5877 :    int tga_palette_start = stbi__get16le(s);
; 5878 :    int tga_palette_len = stbi__get16le(s);
; 5879 :    int tga_palette_bits = stbi__get8(s);
; 5880 :    int tga_x_origin = stbi__get16le(s);
; 5881 :    int tga_y_origin = stbi__get16le(s);
; 5882 :    int tga_width = stbi__get16le(s);
; 5883 :    int tga_height = stbi__get16le(s);
; 5884 :    int tga_bits_per_pixel = stbi__get8(s);
; 5885 :    int tga_comp, tga_rgb16=0;
; 5886 :    int tga_inverted = stbi__get8(s);
; 5887 :    // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
; 5888 :    //   image data
; 5889 :    unsigned char *tga_data;
; 5890 :    unsigned char *tga_palette = NULL;
; 5891 :    int i, j;
; 5892 :    unsigned char raw_data[4] = {0};
; 5893 :    int RLE_count = 0;
; 5894 :    int RLE_repeating = 0;
; 5895 :    int read_next_pixel = 1;
; 5896 :    STBI_NOTUSED(ri);
; 5897 :    STBI_NOTUSED(tga_x_origin); // @TODO
; 5898 :    STBI_NOTUSED(tga_y_origin); // @TODO
; 5899 : 
; 5900 :    if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5901 :    if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5902 : 
; 5903 :    //   do a tiny bit of precessing
; 5904 :    if ( tga_image_type >= 8 )
; 5905 :    {
; 5906 :       tga_image_type -= 8;
; 5907 :       tga_is_RLE = 1;
; 5908 :    }
; 5909 :    tga_inverted = 1 - ((tga_inverted >> 5) & 1);
; 5910 : 
; 5911 :    //   If I'm paletted, then I'll use the number of bits from the palette
; 5912 :    if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
; 5913 :    else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);
; 5914 : 
; 5915 :    if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
; 5916 :       return stbi__errpuc("bad format", "Can't find out TGA pixelformat");
; 5917 : 
; 5918 :    //   tga info
; 5919 :    *x = tga_width;
; 5920 :    *y = tga_height;
; 5921 :    if (comp) *comp = tga_comp;
; 5922 : 
; 5923 :    if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
; 5924 :       return stbi__errpuc("too large", "Corrupt TGA");
; 5925 : 
; 5926 :    tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
; 5927 :    if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");
; 5928 : 
; 5929 :    // skip to the data's starting position (offset usually = 0)
; 5930 :    stbi__skip(s, tga_offset );
; 5931 : 
; 5932 :    if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
; 5933 :       for (i=0; i < tga_height; ++i) {
; 5934 :          int row = tga_inverted ? tga_height -i - 1 : i;
; 5935 :          stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
; 5936 :          stbi__getn(s, tga_row, tga_width * tga_comp);
; 5937 :       }
; 5938 :    } else  {
; 5939 :       //   do I need to load a palette?
; 5940 :       if ( tga_indexed)
; 5941 :       {
; 5942 :          if (tga_palette_len == 0) {  /* you have to have at least one entry! */
; 5943 :             STBI_FREE(tga_data);
; 5944 :             return stbi__errpuc("bad palette", "Corrupt TGA");
; 5945 :          }
; 5946 : 
; 5947 :          //   any data to skip? (offset usually = 0)
; 5948 :          stbi__skip(s, tga_palette_start );
; 5949 :          //   load the palette
; 5950 :          tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
; 5951 :          if (!tga_palette) {
; 5952 :             STBI_FREE(tga_data);
; 5953 :             return stbi__errpuc("outofmem", "Out of memory");
; 5954 :          }
; 5955 :          if (tga_rgb16) {
; 5956 :             stbi_uc *pal_entry = tga_palette;
; 5957 :             STBI_ASSERT(tga_comp == STBI_rgb);
; 5958 :             for (i=0; i < tga_palette_len; ++i) {
; 5959 :                stbi__tga_read_rgb16(s, pal_entry);
; 5960 :                pal_entry += tga_comp;
; 5961 :             }
; 5962 :          } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
; 5963 :                STBI_FREE(tga_data);
; 5964 :                STBI_FREE(tga_palette);
; 5965 :                return stbi__errpuc("bad palette", "Corrupt TGA");
; 5966 :          }
; 5967 :       }
; 5968 :       //   load the data
; 5969 :       for (i=0; i < tga_width * tga_height; ++i)
; 5970 :       {
; 5971 :          //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
; 5972 :          if ( tga_is_RLE )
; 5973 :          {
; 5974 :             if ( RLE_count == 0 )
; 5975 :             {
; 5976 :                //   yep, get the next byte as a RLE command
; 5977 :                int RLE_cmd = stbi__get8(s);
; 5978 :                RLE_count = 1 + (RLE_cmd & 127);
; 5979 :                RLE_repeating = RLE_cmd >> 7;
; 5980 :                read_next_pixel = 1;
; 5981 :             } else if ( !RLE_repeating )
; 5982 :             {
; 5983 :                read_next_pixel = 1;
; 5984 :             }
; 5985 :          } else
; 5986 :          {
; 5987 :             read_next_pixel = 1;
; 5988 :          }
; 5989 :          //   OK, if I need to read a pixel, do it now
; 5990 :          if ( read_next_pixel )
; 5991 :          {
; 5992 :             //   load however much data we did have
; 5993 :             if ( tga_indexed )
; 5994 :             {
; 5995 :                // read in index, then perform the lookup
; 5996 :                int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
; 5997 :                if ( pal_idx >= tga_palette_len ) {
; 5998 :                   // invalid index
; 5999 :                   pal_idx = 0;
; 6000 :                }
; 6001 :                pal_idx *= tga_comp;
; 6002 :                for (j = 0; j < tga_comp; ++j) {
; 6003 :                   raw_data[j] = tga_palette[pal_idx+j];
; 6004 :                }
; 6005 :             } else if(tga_rgb16) {
; 6006 :                STBI_ASSERT(tga_comp == STBI_rgb);
; 6007 :                stbi__tga_read_rgb16(s, raw_data);
; 6008 :             } else {
; 6009 :                //   read in the data raw
; 6010 :                for (j = 0; j < tga_comp; ++j) {
; 6011 :                   raw_data[j] = stbi__get8(s);
; 6012 :                }
; 6013 :             }
; 6014 :             //   clear the reading flag for the next pixel
; 6015 :             read_next_pixel = 0;
; 6016 :          } // end of reading a pixel
; 6017 : 
; 6018 :          // copy data
; 6019 :          for (j = 0; j < tga_comp; ++j)
; 6020 :            tga_data[i*tga_comp+j] = raw_data[j];
; 6021 : 
; 6022 :          //   in case we're in RLE mode, keep counting down
; 6023 :          --RLE_count;
; 6024 :       }
; 6025 :       //   do I need to invert the image?
; 6026 :       if ( tga_inverted )
; 6027 :       {
; 6028 :          for (j = 0; j*2 < tga_height; ++j)
; 6029 :          {
; 6030 :             int index1 = j * tga_width * tga_comp;
; 6031 :             int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
; 6032 :             for (i = tga_width * tga_comp; i > 0; --i)
; 6033 :             {
; 6034 :                unsigned char temp = tga_data[index1];
; 6035 :                tga_data[index1] = tga_data[index2];
; 6036 :                tga_data[index2] = temp;
; 6037 :                ++index1;
; 6038 :                ++index2;
; 6039 :             }
; 6040 :          }
; 6041 :       }
; 6042 :       //   clear my palette, if I had one
; 6043 :       if ( tga_palette != NULL )
; 6044 :       {
; 6045 :          STBI_FREE( tga_palette );
; 6046 :       }
; 6047 :    }
; 6048 : 
; 6049 :    // swap RGB - if the source data was RGB16, it already is in the right order
; 6050 :    if (tga_comp >= 3 && !tga_rgb16)
; 6051 :    {
; 6052 :       unsigned char* tga_pixel = tga_data;
; 6053 :       for (i=0; i < tga_width * tga_height; ++i)
; 6054 :       {
; 6055 :          unsigned char temp = tga_pixel[0];
; 6056 :          tga_pixel[0] = tga_pixel[2];
; 6057 :          tga_pixel[2] = temp;
; 6058 :          tga_pixel += tga_comp;
; 6059 :       }
; 6060 :    }
; 6061 : 
; 6062 :    // convert to target component count
; 6063 :    if (req_comp && req_comp != tga_comp)
; 6064 :       tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);
; 6065 : 
; 6066 :    //   the things I do to get rid of an error message, and yet keep
; 6067 :    //   Microsoft's C compilers happy... [8^(
; 6068 :    tga_palette_start = tga_palette_len = tga_palette_bits =
; 6069 :          tga_x_origin = tga_y_origin = 0;
; 6070 :    STBI_NOTUSED(tga_palette_start);
; 6071 :    //   OK, done
; 6072 :    return tga_data;
; 6073 : }
; 6074 : #endif
; 6075 : 
; 6076 : // *************************************************************************************************
; 6077 : // Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB
; 6078 : 
; 6079 : #ifndef STBI_NO_PSD
; 6080 : static int stbi__psd_test(stbi__context *s)
; 6081 : {
; 6082 :    int r = (stbi__get32be(s) == 0x38425053);
; 6083 :    stbi__rewind(s);
; 6084 :    return r;
; 6085 : }
; 6086 : 
; 6087 : static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
; 6088 : {
; 6089 :    int count, nleft, len;
; 6090 : 
; 6091 :    count = 0;
; 6092 :    while ((nleft = pixelCount - count) > 0) {
; 6093 :       len = stbi__get8(s);
; 6094 :       if (len == 128) {
; 6095 :          // No-op.
; 6096 :       } else if (len < 128) {
; 6097 :          // Copy next len+1 bytes literally.
; 6098 :          len++;
; 6099 :          if (len > nleft) return 0; // corrupt data
; 6100 :          count += len;
; 6101 :          while (len) {
; 6102 :             *p = stbi__get8(s);
; 6103 :             p += 4;
; 6104 :             len--;
; 6105 :          }
; 6106 :       } else if (len > 128) {
; 6107 :          stbi_uc   val;
; 6108 :          // Next -len+1 bytes in the dest are replicated from next source byte.
; 6109 :          // (Interpret len as a negative 8-bit int.)
; 6110 :          len = 257 - len;
; 6111 :          if (len > nleft) return 0; // corrupt data
; 6112 :          val = stbi__get8(s);
; 6113 :          count += len;
; 6114 :          while (len) {
; 6115 :             *p = val;
; 6116 :             p += 4;
; 6117 :             len--;
; 6118 :          }
; 6119 :       }
; 6120 :    }
; 6121 : 
; 6122 :    return 1;
; 6123 : }
; 6124 : 
; 6125 : static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
; 6126 : {
; 6127 :    int pixelCount;
; 6128 :    int channelCount, compression;
; 6129 :    int channel, i;
; 6130 :    int bitdepth;
; 6131 :    int w,h;
; 6132 :    stbi_uc *out;
; 6133 :    STBI_NOTUSED(ri);
; 6134 : 
; 6135 :    // Check identifier
; 6136 :    if (stbi__get32be(s) != 0x38425053)   // "8BPS"
; 6137 :       return stbi__errpuc("not PSD", "Corrupt PSD image");
; 6138 : 
; 6139 :    // Check file type version.
; 6140 :    if (stbi__get16be(s) != 1)
; 6141 :       return stbi__errpuc("wrong version", "Unsupported version of PSD image");
; 6142 : 
; 6143 :    // Skip 6 reserved bytes.
; 6144 :    stbi__skip(s, 6 );
; 6145 : 
; 6146 :    // Read the number of channels (R, G, B, A, etc).
; 6147 :    channelCount = stbi__get16be(s);
; 6148 :    if (channelCount < 0 || channelCount > 16)
; 6149 :       return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");
; 6150 : 
; 6151 :    // Read the rows and columns of the image.
; 6152 :    h = stbi__get32be(s);
; 6153 :    w = stbi__get32be(s);
; 6154 : 
; 6155 :    if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 6156 :    if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 6157 : 
; 6158 :    // Make sure the depth is 8 bits.
; 6159 :    bitdepth = stbi__get16be(s);
; 6160 :    if (bitdepth != 8 && bitdepth != 16)
; 6161 :       return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");
; 6162 : 
; 6163 :    // Make sure the color mode is RGB.
; 6164 :    // Valid options are:
; 6165 :    //   0: Bitmap
; 6166 :    //   1: Grayscale
; 6167 :    //   2: Indexed color
; 6168 :    //   3: RGB color
; 6169 :    //   4: CMYK color
; 6170 :    //   7: Multichannel
; 6171 :    //   8: Duotone
; 6172 :    //   9: Lab color
; 6173 :    if (stbi__get16be(s) != 3)
; 6174 :       return stbi__errpuc("wrong color format", "PSD is not in RGB color format");
; 6175 : 
; 6176 :    // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
; 6177 :    stbi__skip(s,stbi__get32be(s) );
; 6178 : 
; 6179 :    // Skip the image resources.  (resolution, pen tool paths, etc)
; 6180 :    stbi__skip(s, stbi__get32be(s) );
; 6181 : 
; 6182 :    // Skip the reserved data.
; 6183 :    stbi__skip(s, stbi__get32be(s) );
; 6184 : 
; 6185 :    // Find out if the data is compressed.
; 6186 :    // Known values:
; 6187 :    //   0: no compression
; 6188 :    //   1: RLE compressed
; 6189 :    compression = stbi__get16be(s);
; 6190 :    if (compression > 1)
; 6191 :       return stbi__errpuc("bad compression", "PSD has an unknown compression format");
; 6192 : 
; 6193 :    // Check size
; 6194 :    if (!stbi__mad3sizes_valid(4, w, h, 0))
; 6195 :       return stbi__errpuc("too large", "Corrupt PSD");
; 6196 : 
; 6197 :    // Create the destination image.
; 6198 : 
; 6199 :    if (!compression && bitdepth == 16 && bpc == 16) {
; 6200 :       out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
; 6201 :       ri->bits_per_channel = 16;
; 6202 :    } else
; 6203 :       out = (stbi_uc *) stbi__malloc(4 * w*h);
; 6204 : 
; 6205 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");
; 6206 :    pixelCount = w*h;
; 6207 : 
; 6208 :    // Initialize the data to zero.
; 6209 :    //memset( out, 0, pixelCount * 4 );
; 6210 : 
; 6211 :    // Finally, the image data.
; 6212 :    if (compression) {
; 6213 :       // RLE as used by .PSD and .TIFF
; 6214 :       // Loop until you get the number of unpacked bytes you are expecting:
; 6215 :       //     Read the next source byte into n.
; 6216 :       //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
; 6217 :       //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
; 6218 :       //     Else if n is 128, noop.
; 6219 :       // Endloop
; 6220 : 
; 6221 :       // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
; 6222 :       // which we're going to just skip.
; 6223 :       stbi__skip(s, h * channelCount * 2 );
; 6224 : 
; 6225 :       // Read the RLE data by channel.
; 6226 :       for (channel = 0; channel < 4; channel++) {
; 6227 :          stbi_uc *p;
; 6228 : 
; 6229 :          p = out+channel;
; 6230 :          if (channel >= channelCount) {
; 6231 :             // Fill this channel with default data.
; 6232 :             for (i = 0; i < pixelCount; i++, p += 4)
; 6233 :                *p = (channel == 3 ? 255 : 0);
; 6234 :          } else {
; 6235 :             // Read the RLE data.
; 6236 :             if (!stbi__psd_decode_rle(s, p, pixelCount)) {
; 6237 :                STBI_FREE(out);
; 6238 :                return stbi__errpuc("corrupt", "bad RLE data");
; 6239 :             }
; 6240 :          }
; 6241 :       }
; 6242 : 
; 6243 :    } else {
; 6244 :       // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
; 6245 :       // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.
; 6246 : 
; 6247 :       // Read the data by channel.
; 6248 :       for (channel = 0; channel < 4; channel++) {
; 6249 :          if (channel >= channelCount) {
; 6250 :             // Fill this channel with default data.
; 6251 :             if (bitdepth == 16 && bpc == 16) {
; 6252 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
; 6253 :                stbi__uint16 val = channel == 3 ? 65535 : 0;
; 6254 :                for (i = 0; i < pixelCount; i++, q += 4)
; 6255 :                   *q = val;
; 6256 :             } else {
; 6257 :                stbi_uc *p = out+channel;
; 6258 :                stbi_uc val = channel == 3 ? 255 : 0;
; 6259 :                for (i = 0; i < pixelCount; i++, p += 4)
; 6260 :                   *p = val;
; 6261 :             }
; 6262 :          } else {
; 6263 :             if (ri->bits_per_channel == 16) {    // output bpc
; 6264 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
; 6265 :                for (i = 0; i < pixelCount; i++, q += 4)
; 6266 :                   *q = (stbi__uint16) stbi__get16be(s);
; 6267 :             } else {
; 6268 :                stbi_uc *p = out+channel;
; 6269 :                if (bitdepth == 16) {  // input bpc
; 6270 :                   for (i = 0; i < pixelCount; i++, p += 4)
; 6271 :                      *p = (stbi_uc) (stbi__get16be(s) >> 8);
; 6272 :                } else {
; 6273 :                   for (i = 0; i < pixelCount; i++, p += 4)
; 6274 :                      *p = stbi__get8(s);
; 6275 :                }
; 6276 :             }
; 6277 :          }
; 6278 :       }
; 6279 :    }
; 6280 : 
; 6281 :    // remove weird white matte from PSD
; 6282 :    if (channelCount >= 4) {
; 6283 :       if (ri->bits_per_channel == 16) {
; 6284 :          for (i=0; i < w*h; ++i) {
; 6285 :             stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
; 6286 :             if (pixel[3] != 0 && pixel[3] != 65535) {
; 6287 :                float a = pixel[3] / 65535.0f;
; 6288 :                float ra = 1.0f / a;
; 6289 :                float inv_a = 65535.0f * (1 - ra);
; 6290 :                pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
; 6291 :                pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
; 6292 :                pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
; 6293 :             }
; 6294 :          }
; 6295 :       } else {
; 6296 :          for (i=0; i < w*h; ++i) {
; 6297 :             unsigned char *pixel = out + 4*i;
; 6298 :             if (pixel[3] != 0 && pixel[3] != 255) {
; 6299 :                float a = pixel[3] / 255.0f;
; 6300 :                float ra = 1.0f / a;
; 6301 :                float inv_a = 255.0f * (1 - ra);
; 6302 :                pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
; 6303 :                pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
; 6304 :                pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
; 6305 :             }
; 6306 :          }
; 6307 :       }
; 6308 :    }
; 6309 : 
; 6310 :    // convert to desired output format
; 6311 :    if (req_comp && req_comp != 4) {
; 6312 :       if (ri->bits_per_channel == 16)
; 6313 :          out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
; 6314 :       else
; 6315 :          out = stbi__convert_format(out, 4, req_comp, w, h);
; 6316 :       if (out == NULL) return out; // stbi__convert_format frees input on failure
; 6317 :    }
; 6318 : 
; 6319 :    if (comp) *comp = 4;
; 6320 :    *y = h;
; 6321 :    *x = w;
; 6322 : 
; 6323 :    return out;
; 6324 : }
; 6325 : #endif
; 6326 : 
; 6327 : // *************************************************************************************************
; 6328 : // Softimage PIC loader
; 6329 : // by Tom Seddon
; 6330 : //
; 6331 : // See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
; 6332 : // See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/
; 6333 : 
; 6334 : #ifndef STBI_NO_PIC
; 6335 : static int stbi__pic_is4(stbi__context *s,const char *str)
; 6336 : {
; 6337 :    int i;
; 6338 :    for (i=0; i<4; ++i)
; 6339 :       if (stbi__get8(s) != (stbi_uc)str[i])
; 6340 :          return 0;
; 6341 : 
; 6342 :    return 1;
; 6343 : }
; 6344 : 
; 6345 : static int stbi__pic_test_core(stbi__context *s)
; 6346 : {
; 6347 :    int i;
; 6348 : 
; 6349 :    if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
; 6350 :       return 0;
; 6351 : 
; 6352 :    for(i=0;i<84;++i)
; 6353 :       stbi__get8(s);
; 6354 : 
; 6355 :    if (!stbi__pic_is4(s,"PICT"))
; 6356 :       return 0;
; 6357 : 
; 6358 :    return 1;
; 6359 : }
; 6360 : 
; 6361 : typedef struct
; 6362 : {
; 6363 :    stbi_uc size,type,channel;
; 6364 : } stbi__pic_packet;
; 6365 : 
; 6366 : static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
; 6367 : {
; 6368 :    int mask=0x80, i;
; 6369 : 
; 6370 :    for (i=0; i<4; ++i, mask>>=1) {
; 6371 :       if (channel & mask) {
; 6372 :          if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
; 6373 :          dest[i]=stbi__get8(s);
; 6374 :       }
; 6375 :    }
; 6376 : 
; 6377 :    return dest;
; 6378 : }
; 6379 : 
; 6380 : static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
; 6381 : {
; 6382 :    int mask=0x80,i;
; 6383 : 
; 6384 :    for (i=0;i<4; ++i, mask>>=1)
; 6385 :       if (channel&mask)

	test	dil, 16
	je	SHORT $LN155@stbi__pic_

; 6386 :          dest[i]=src[i];

	mov	BYTE PTR [rbx+3], dl
$LN155@stbi__pic_:

; 6476 :                         return 0;
; 6477 : 
; 6478 :                      for(i=0;i<count;++i, dest += 4)

	add	rbx, 4
	sub	rcx, 1
	jne	SHORT $LL25@stbi__pic_

; 6479 :                         stbi__copyval(packet->channel,dest,value);
; 6480 :                   } else { // Raw

	jmp	SHORT $LN27@stbi__pic_
$LN41@stbi__pic_:

; 6481 :                      ++count;

	inc	esi

; 6482 :                      if (count>left) return stbi__errpuc("bad file","scanline overrun");

	cmp	esi, r14d
	ja	$LN134@stbi__pic_

; 6483 : 
; 6484 :                      for(i=0;i<count;++i, dest+=4)

	xor	edi, edi
	test	esi, esi
	je	SHORT $LN27@stbi__pic_
	movzx	ebp, BYTE PTR [r15]
	npad	11
$LL28@stbi__pic_:

; 6485 :                         if (!stbi__readval(s,packet->channel,dest))

	mov	r8, rbx
	mov	edx, ebp
	mov	rcx, r13
	call	?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ; stbi__readval
	test	rax, rax
	je	$LN139@stbi__pic_

; 6483 : 
; 6484 :                      for(i=0;i<count;++i, dest+=4)

	inc	edi
	add	rbx, 4
	cmp	edi, esi
	jl	SHORT $LL28@stbi__pic_
$LN27@stbi__pic_:

; 6486 :                            return 0;
; 6487 :                   }
; 6488 :                   left-=count;

	sub	r14d, esi
	test	r14d, r14d
	jg	$LL21@stbi__pic_

; 6432 :                   if (!stbi__readval(s,packet->channel,dest))

	mov	ebp, DWORD PTR width$GSCopy$1$[rsp]
	jmp	$LN8@stbi__pic_
$LN35@stbi__pic_:

; 6433 :                      return 0;
; 6434 :                break;
; 6435 :             }
; 6436 : 
; 6437 :             case 1://Pure RLE
; 6438 :                {
; 6439 :                   int left=width, i;

	mov	r14d, ebp

; 6440 : 
; 6441 :                   while (left>0) {

	test	ebp, ebp
	jle	$LN8@stbi__pic_
$LL16@stbi__pic_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [r13+192]
	cmp	rax, QWORD PTR [r13+200]
	jae	SHORT $LN78@stbi__pic_

; 1615 :       return *s->img_buffer++;

	movzx	edi, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [r13+192], rax
	jmp	SHORT $LN77@stbi__pic_
$LN78@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r12], 0
	je	SHORT $LN79@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, r13
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [r13+192]
	movzx	edi, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [r13+192], rax
	jmp	SHORT $LN77@stbi__pic_
$LN79@stbi__pic_:

; 1619 :    }
; 1620 :    return 0;

	xor	dil, dil
$LN77@stbi__pic_:

; 1628 :    if (s->io.read) {

	cmp	QWORD PTR [r13+16], 0
	je	SHORT $LN193@stbi__pic_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	rax, QWORD PTR [r13+32]
	mov	rcx, QWORD PTR [r13+40]
	call	rax
	test	eax, eax
	je	SHORT $LN194@stbi__pic_

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

	cmp	DWORD PTR [r12], 0
	je	$LN134@stbi__pic_
$LN193@stbi__pic_:

; 6442 :                      stbi_uc count,value[4];
; 6443 : 
; 6444 :                      count=stbi__get8(s);
; 6445 :                      if (stbi__at_eof(s))   return stbi__errpuc("bad file","file too short (pure read count)");

	mov	rax, QWORD PTR [r13+200]
	cmp	QWORD PTR [r13+192], rax
	jae	$LN134@stbi__pic_
$LN194@stbi__pic_:

; 6446 : 
; 6447 :                      if (count > left)
; 6448 :                         count = (stbi_uc) left;
; 6449 : 
; 6450 :                      if (!stbi__readval(s,packet->channel,value))  return 0;

	movzx	esi, BYTE PTR [r15]
	lea	r8, QWORD PTR value$4[rsp]
	mov	edx, esi
	movzx	ebp, dil
	mov	rcx, r13
	call	?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ; stbi__readval
	test	rax, rax
	je	$LN139@stbi__pic_
	cmp	ebp, r14d
	movzx	ecx, r14b
	movzx	eax, dil
	cmovbe	ecx, eax

; 6451 : 
; 6452 :                      for(i=0; i<count; ++i,dest+=4)

	movzx	r10d, cl
	test	cl, cl
	je	SHORT $LN19@stbi__pic_

; 6446 : 
; 6447 :                      if (count > left)
; 6448 :                         count = (stbi_uc) left;
; 6449 : 
; 6450 :                      if (!stbi__readval(s,packet->channel,value))  return 0;

	mov	eax, DWORD PTR value$4[rsp]
	mov	ecx, r10d
	movzx	edx, BYTE PTR value$4[rsp+3]
	movzx	r8d, BYTE PTR value$4[rsp+2]
	movzx	r9d, BYTE PTR value$4[rsp+1]
	npad	7
$LL20@stbi__pic_:

; 6385 :       if (channel&mask)

	test	sil, sil
	jns	SHORT $LN51@stbi__pic_

; 6386 :          dest[i]=src[i];

	mov	BYTE PTR [rbx], al
$LN51@stbi__pic_:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;
; 1636 : }
; 1637 : #endif
; 1638 : 
; 1639 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
; 1640 : // nothing
; 1641 : #else
; 1642 : static void stbi__skip(stbi__context *s, int n)
; 1643 : {
; 1644 :    if (n == 0) return;  // already there!
; 1645 :    if (n < 0) {
; 1646 :       s->img_buffer = s->img_buffer_end;
; 1647 :       return;
; 1648 :    }
; 1649 :    if (s->io.read) {
; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1651 :       if (blen < n) {
; 1652 :          s->img_buffer = s->img_buffer_end;
; 1653 :          (s->io.skip)(s->io_user_data, n - blen);
; 1654 :          return;
; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;
; 1658 : }
; 1659 : #endif
; 1660 : 
; 1661 : #if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
; 1662 : // nothing
; 1663 : #else
; 1664 : static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
; 1665 : {
; 1666 :    if (s->io.read) {
; 1667 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1668 :       if (blen < n) {
; 1669 :          int res, count;
; 1670 : 
; 1671 :          memcpy(buffer, s->img_buffer, blen);
; 1672 : 
; 1673 :          count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
; 1674 :          res = (count == (n-blen));
; 1675 :          s->img_buffer = s->img_buffer_end;
; 1676 :          return res;
; 1677 :       }
; 1678 :    }
; 1679 : 
; 1680 :    if (s->img_buffer+n <= s->img_buffer_end) {
; 1681 :       memcpy(buffer, s->img_buffer, n);
; 1682 :       s->img_buffer += n;
; 1683 :       return 1;
; 1684 :    } else
; 1685 :       return 0;
; 1686 : }
; 1687 : #endif
; 1688 : 
; 1689 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1690 : // nothing
; 1691 : #else
; 1692 : static int stbi__get16be(stbi__context *s)
; 1693 : {
; 1694 :    int z = stbi__get8(s);
; 1695 :    return (z << 8) + stbi__get8(s);
; 1696 : }
; 1697 : #endif
; 1698 : 
; 1699 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1700 : // nothing
; 1701 : #else
; 1702 : static stbi__uint32 stbi__get32be(stbi__context *s)
; 1703 : {
; 1704 :    stbi__uint32 z = stbi__get16be(s);
; 1705 :    return (z << 16) + stbi__get16be(s);
; 1706 : }
; 1707 : #endif
; 1708 : 
; 1709 : #if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
; 1710 : // nothing
; 1711 : #else
; 1712 : static int stbi__get16le(stbi__context *s)
; 1713 : {
; 1714 :    int z = stbi__get8(s);
; 1715 :    return z + (stbi__get8(s) << 8);
; 1716 : }
; 1717 : #endif
; 1718 : 
; 1719 : #ifndef STBI_NO_BMP
; 1720 : static stbi__uint32 stbi__get32le(stbi__context *s)
; 1721 : {
; 1722 :    stbi__uint32 z = stbi__get16le(s);
; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;
; 1724 :    return z;
; 1725 : }
; 1726 : #endif
; 1727 : 
; 1728 : #define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
; 1729 : 
; 1730 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1731 : // nothing
; 1732 : #else
; 1733 : //////////////////////////////////////////////////////////////////////////////
; 1734 : //
; 1735 : //  generic converter from built-in img_n to req_comp
; 1736 : //    individual types do this automatically as much as possible (e.g. jpeg
; 1737 : //    does all cases internally since it needs to colorspace convert anyway,
; 1738 : //    and it never has alpha, so very few cases ). png can automatically
; 1739 : //    interleave an alpha=255 channel, but falls back to this for other cases
; 1740 : //
; 1741 : //  assume data buffer is malloced, so malloc a new one and free that one
; 1742 : //  only failure mode is malloc failing
; 1743 : 
; 1744 : static stbi_uc stbi__compute_y(int r, int g, int b)
; 1745 : {
; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1747 : }
; 1748 : #endif
; 1749 : 
; 1750 : #if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1751 : // nothing
; 1752 : #else
; 1753 : static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1754 : {
; 1755 :    int i,j;
; 1756 :    unsigned char *good;
; 1757 : 
; 1758 :    if (req_comp == img_n) return data;
; 1759 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1760 : 
; 1761 :    good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
; 1762 :    if (good == NULL) {
; 1763 :       STBI_FREE(data);
; 1764 :       return stbi__errpuc("outofmem", "Out of memory");
; 1765 :    }
; 1766 : 
; 1767 :    for (j=0; j < (int) y; ++j) {
; 1768 :       unsigned char *src  = data + j * x * img_n   ;
; 1769 :       unsigned char *dest = good + j * x * req_comp;
; 1770 : 
; 1771 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1772 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1773 :       // convert source image with img_n components to one with req_comp components;
; 1774 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1775 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1776 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
; 1777 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1778 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
; 1779 :          STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
; 1780 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1781 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
; 1782 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
; 1783 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1784 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
; 1785 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1786 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1787 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
; 1788 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
; 1789 :       }
; 1790 :       #undef STBI__CASE
; 1791 :    }
; 1792 : 
; 1793 :    STBI_FREE(data);
; 1794 :    return good;
; 1795 : }
; 1796 : #endif
; 1797 : 
; 1798 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1799 : // nothing
; 1800 : #else
; 1801 : static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
; 1802 : {
; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1804 : }
; 1805 : #endif
; 1806 : 
; 1807 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1808 : // nothing
; 1809 : #else
; 1810 : static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1811 : {
; 1812 :    int i,j;
; 1813 :    stbi__uint16 *good;
; 1814 : 
; 1815 :    if (req_comp == img_n) return data;
; 1816 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1817 : 
; 1818 :    good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
; 1819 :    if (good == NULL) {
; 1820 :       STBI_FREE(data);
; 1821 :       return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1822 :    }
; 1823 : 
; 1824 :    for (j=0; j < (int) y; ++j) {
; 1825 :       stbi__uint16 *src  = data + j * x * img_n   ;
; 1826 :       stbi__uint16 *dest = good + j * x * req_comp;
; 1827 : 
; 1828 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1829 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1830 :       // convert source image with img_n components to one with req_comp components;
; 1831 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1832 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1833 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
; 1834 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1835 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
; 1836 :          STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
; 1837 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1838 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
; 1839 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
; 1840 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1841 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
; 1842 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1843 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1844 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
; 1845 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
; 1846 :       }
; 1847 :       #undef STBI__CASE
; 1848 :    }
; 1849 : 
; 1850 :    STBI_FREE(data);
; 1851 :    return good;
; 1852 : }
; 1853 : #endif
; 1854 : 
; 1855 : #ifndef STBI_NO_LINEAR
; 1856 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
; 1857 : {
; 1858 :    int i,k,n;
; 1859 :    float *output;
; 1860 :    if (!data) return NULL;
; 1861 :    output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
; 1862 :    if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
; 1863 :    // compute number of non-alpha components
; 1864 :    if (comp & 1) n = comp; else n = comp-1;
; 1865 :    for (i=0; i < x*y; ++i) {
; 1866 :       for (k=0; k < n; ++k) {
; 1867 :          output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
; 1868 :       }
; 1869 :    }
; 1870 :    if (n < comp) {
; 1871 :       for (i=0; i < x*y; ++i) {
; 1872 :          output[i*comp + n] = data[i*comp + n]/255.0f;
; 1873 :       }
; 1874 :    }
; 1875 :    STBI_FREE(data);
; 1876 :    return output;
; 1877 : }
; 1878 : #endif
; 1879 : 
; 1880 : #ifndef STBI_NO_HDR
; 1881 : #define stbi__float2int(x)   ((int) (x))
; 1882 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
; 1883 : {
; 1884 :    int i,k,n;
; 1885 :    stbi_uc *output;
; 1886 :    if (!data) return NULL;
; 1887 :    output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
; 1888 :    if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
; 1889 :    // compute number of non-alpha components
; 1890 :    if (comp & 1) n = comp; else n = comp-1;
; 1891 :    for (i=0; i < x*y; ++i) {
; 1892 :       for (k=0; k < n; ++k) {
; 1893 :          float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
; 1894 :          if (z < 0) z = 0;
; 1895 :          if (z > 255) z = 255;
; 1896 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1897 :       }
; 1898 :       if (k < comp) {
; 1899 :          float z = data[i*comp+k] * 255 + 0.5f;
; 1900 :          if (z < 0) z = 0;
; 1901 :          if (z > 255) z = 255;
; 1902 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1903 :       }
; 1904 :    }
; 1905 :    STBI_FREE(data);
; 1906 :    return output;
; 1907 : }
; 1908 : #endif
; 1909 : 
; 1910 : //////////////////////////////////////////////////////////////////////////////
; 1911 : //
; 1912 : //  "baseline" JPEG/JFIF decoder
; 1913 : //
; 1914 : //    simple implementation
; 1915 : //      - doesn't support delayed output of y-dimension
; 1916 : //      - simple interface (only one output format: 8-bit interleaved RGB)
; 1917 : //      - doesn't try to recover corrupt jpegs
; 1918 : //      - doesn't allow partial loading, loading multiple at once
; 1919 : //      - still fast on x86 (copying globals into locals doesn't help x86)
; 1920 : //      - allocates lots of intermediate memory (full size of all components)
; 1921 : //        - non-interleaved case requires this anyway
; 1922 : //        - allows good upsampling (see next)
; 1923 : //    high-quality
; 1924 : //      - upsampled channels are bilinearly interpolated, even across blocks
; 1925 : //      - quality integer IDCT derived from IJG's 'slow'
; 1926 : //    performance
; 1927 : //      - fast huffman; reasonable integer IDCT
; 1928 : //      - some SIMD kernels for common paths on targets with SSE2/NEON
; 1929 : //      - uses a lot of intermediate memory, could cache poorly
; 1930 : 
; 1931 : #ifndef STBI_NO_JPEG
; 1932 : 
; 1933 : // huffman decoding acceleration
; 1934 : #define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
; 1935 : 
; 1936 : typedef struct
; 1937 : {
; 1938 :    stbi_uc  fast[1 << FAST_BITS];
; 1939 :    // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
; 1940 :    stbi__uint16 code[256];
; 1941 :    stbi_uc  values[256];
; 1942 :    stbi_uc  size[257];
; 1943 :    unsigned int maxcode[18];
; 1944 :    int    delta[17];   // old 'firstsymbol' - old 'firstcode'
; 1945 : } stbi__huffman;
; 1946 : 
; 1947 : typedef struct
; 1948 : {
; 1949 :    stbi__context *s;
; 1950 :    stbi__huffman huff_dc[4];
; 1951 :    stbi__huffman huff_ac[4];
; 1952 :    stbi__uint16 dequant[4][64];
; 1953 :    stbi__int16 fast_ac[4][1 << FAST_BITS];
; 1954 : 
; 1955 : // sizes for components, interleaved MCUs
; 1956 :    int img_h_max, img_v_max;
; 1957 :    int img_mcu_x, img_mcu_y;
; 1958 :    int img_mcu_w, img_mcu_h;
; 1959 : 
; 1960 : // definition of jpeg image component
; 1961 :    struct
; 1962 :    {
; 1963 :       int id;
; 1964 :       int h,v;
; 1965 :       int tq;
; 1966 :       int hd,ha;
; 1967 :       int dc_pred;
; 1968 : 
; 1969 :       int x,y,w2,h2;
; 1970 :       stbi_uc *data;
; 1971 :       void *raw_data, *raw_coeff;
; 1972 :       stbi_uc *linebuf;
; 1973 :       short   *coeff;   // progressive only
; 1974 :       int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
; 1975 :    } img_comp[4];
; 1976 : 
; 1977 :    stbi__uint32   code_buffer; // jpeg entropy-coded buffer
; 1978 :    int            code_bits;   // number of valid bits
; 1979 :    unsigned char  marker;      // marker seen while filling entropy buffer
; 1980 :    int            nomore;      // flag if we saw a marker so must stop
; 1981 : 
; 1982 :    int            progressive;
; 1983 :    int            spec_start;
; 1984 :    int            spec_end;
; 1985 :    int            succ_high;
; 1986 :    int            succ_low;
; 1987 :    int            eob_run;
; 1988 :    int            jfif;
; 1989 :    int            app14_color_transform; // Adobe APP14 tag
; 1990 :    int            rgb;
; 1991 : 
; 1992 :    int scan_n, order[4];
; 1993 :    int restart_interval, todo;
; 1994 : 
; 1995 : // kernels
; 1996 :    void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
; 1997 :    void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
; 1998 :    stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
; 1999 : } stbi__jpeg;
; 2000 : 
; 2001 : static int stbi__build_huffman(stbi__huffman *h, int *count)
; 2002 : {
; 2003 :    int i,j,k=0;
; 2004 :    unsigned int code;
; 2005 :    // build size list for each symbol (from JPEG spec)
; 2006 :    for (i=0; i < 16; ++i) {
; 2007 :       for (j=0; j < count[i]; ++j) {
; 2008 :          h->size[k++] = (stbi_uc) (i+1);
; 2009 :          if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");
; 2010 :       }
; 2011 :    }
; 2012 :    h->size[k] = 0;
; 2013 : 
; 2014 :    // compute actual symbols (from jpeg spec)
; 2015 :    code = 0;
; 2016 :    k = 0;
; 2017 :    for(j=1; j <= 16; ++j) {
; 2018 :       // compute delta to add to code to compute symbol id
; 2019 :       h->delta[j] = k - code;
; 2020 :       if (h->size[k] == j) {
; 2021 :          while (h->size[k] == j)
; 2022 :             h->code[k++] = (stbi__uint16) (code++);
; 2023 :          if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
; 2024 :       }
; 2025 :       // compute largest code + 1 for this size, preshifted as needed later
; 2026 :       h->maxcode[j] = code << (16-j);
; 2027 :       code <<= 1;
; 2028 :    }
; 2029 :    h->maxcode[j] = 0xffffffff;
; 2030 : 
; 2031 :    // build non-spec acceleration table; 255 is flag for not-accelerated
; 2032 :    memset(h->fast, 255, 1 << FAST_BITS);
; 2033 :    for (i=0; i < k; ++i) {
; 2034 :       int s = h->size[i];
; 2035 :       if (s <= FAST_BITS) {
; 2036 :          int c = h->code[i] << (FAST_BITS-s);
; 2037 :          int m = 1 << (FAST_BITS-s);
; 2038 :          for (j=0; j < m; ++j) {
; 2039 :             h->fast[c+j] = (stbi_uc) i;
; 2040 :          }
; 2041 :       }
; 2042 :    }
; 2043 :    return 1;
; 2044 : }
; 2045 : 
; 2046 : // build a table that decodes both magnitude and value of small ACs in
; 2047 : // one go.
; 2048 : static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
; 2049 : {
; 2050 :    int i;
; 2051 :    for (i=0; i < (1 << FAST_BITS); ++i) {
; 2052 :       stbi_uc fast = h->fast[i];
; 2053 :       fast_ac[i] = 0;
; 2054 :       if (fast < 255) {
; 2055 :          int rs = h->values[fast];
; 2056 :          int run = (rs >> 4) & 15;
; 2057 :          int magbits = rs & 15;
; 2058 :          int len = h->size[fast];
; 2059 : 
; 2060 :          if (magbits && len + magbits <= FAST_BITS) {
; 2061 :             // magnitude code followed by receive_extend code
; 2062 :             int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
; 2063 :             int m = 1 << (magbits - 1);
; 2064 :             if (k < m) k += (~0U << magbits) + 1;
; 2065 :             // if the result is small enough, we can fit it in fast_ac table
; 2066 :             if (k >= -128 && k <= 127)
; 2067 :                fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
; 2068 :          }
; 2069 :       }
; 2070 :    }
; 2071 : }
; 2072 : 
; 2073 : static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
; 2074 : {
; 2075 :    do {
; 2076 :       unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
; 2077 :       if (b == 0xff) {
; 2078 :          int c = stbi__get8(j->s);
; 2079 :          while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
; 2080 :          if (c != 0) {
; 2081 :             j->marker = (unsigned char) c;
; 2082 :             j->nomore = 1;
; 2083 :             return;
; 2084 :          }
; 2085 :       }
; 2086 :       j->code_buffer |= b << (24 - j->code_bits);
; 2087 :       j->code_bits += 8;
; 2088 :    } while (j->code_bits <= 24);
; 2089 : }
; 2090 : 
; 2091 : // (1 << n) - 1
; 2092 : static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
; 2093 : 
; 2094 : // decode a jpeg huffman value from the bitstream
; 2095 : stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
; 2096 : {
; 2097 :    unsigned int temp;
; 2098 :    int c,k;
; 2099 : 
; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2105 :    k = h->fast[c];
; 2106 :    if (k < 255) {
; 2107 :       int s = h->size[k];
; 2108 :       if (s > j->code_bits)
; 2109 :          return -1;
; 2110 :       j->code_buffer <<= s;
; 2111 :       j->code_bits -= s;
; 2112 :       return h->values[k];
; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;
; 2122 :    for (k=FAST_BITS+1 ; ; ++k)
; 2123 :       if (temp < h->maxcode[k])
; 2124 :          break;
; 2125 :    if (k == 17) {
; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;
; 2128 :       return -1;
; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)
; 2132 :       return -1;
; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!
; 2137 :        return -1;
; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;
; 2142 :    j->code_buffer <<= k;
; 2143 :    return h->values[c];
; 2144 : }
; 2145 : 
; 2146 : // bias[n] = (-1<<n) + 1
; 2147 : static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};
; 2148 : 
; 2149 : // combined JPEG 'receive' and JPEG 'extend', since baseline
; 2150 : // always extends everything it receives.
; 2151 : stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
; 2152 : {
; 2153 :    unsigned int k;
; 2154 :    int sgn;
; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
; 2159 :    k = stbi_lrot(j->code_buffer, n);
; 2160 :    j->code_buffer = k & ~stbi__bmask[n];
; 2161 :    k &= stbi__bmask[n];
; 2162 :    j->code_bits -= n;
; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));
; 2164 : }
; 2165 : 
; 2166 : // get some unsigned bits
; 2167 : stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
; 2168 : {
; 2169 :    unsigned int k;
; 2170 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2171 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2172 :    k = stbi_lrot(j->code_buffer, n);
; 2173 :    j->code_buffer = k & ~stbi__bmask[n];
; 2174 :    k &= stbi__bmask[n];
; 2175 :    j->code_bits -= n;
; 2176 :    return k;
; 2177 : }
; 2178 : 
; 2179 : stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
; 2180 : {
; 2181 :    unsigned int k;
; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2184 :    k = j->code_buffer;
; 2185 :    j->code_buffer <<= 1;
; 2186 :    --j->code_bits;
; 2187 :    return k & 0x80000000;
; 2188 : }
; 2189 : 
; 2190 : // given a value that's at position X in the zigzag stream,
; 2191 : // where does it appear in the 8x8 matrix coded as row-major?
; 2192 : static const stbi_uc stbi__jpeg_dezigzag[64+15] =
; 2193 : {
; 2194 :     0,  1,  8, 16,  9,  2,  3, 10,
; 2195 :    17, 24, 32, 25, 18, 11,  4,  5,
; 2196 :    12, 19, 26, 33, 40, 48, 41, 34,
; 2197 :    27, 20, 13,  6,  7, 14, 21, 28,
; 2198 :    35, 42, 49, 56, 57, 50, 43, 36,
; 2199 :    29, 22, 15, 23, 30, 37, 44, 51,
; 2200 :    58, 59, 52, 45, 38, 31, 39, 46,
; 2201 :    53, 60, 61, 54, 47, 55, 62, 63,
; 2202 :    // let corrupt input sample past end
; 2203 :    63, 63, 63, 63, 63, 63, 63, 63,
; 2204 :    63, 63, 63, 63, 63, 63, 63
; 2205 : };
; 2206 : 
; 2207 : // decode one 64-entry block--
; 2208 : static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
; 2209 : {
; 2210 :    int diff,dc,k;
; 2211 :    int t;
; 2212 : 
; 2213 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2214 :    t = stbi__jpeg_huff_decode(j, hdc);
; 2215 :    if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");
; 2216 : 
; 2217 :    // 0 all the ac values now so we can do it 32-bits at a time
; 2218 :    memset(data,0,64*sizeof(data[0]));
; 2219 : 
; 2220 :    diff = t ? stbi__extend_receive(j, t) : 0;
; 2221 :    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");
; 2222 :    dc = j->img_comp[b].dc_pred + diff;
; 2223 :    j->img_comp[b].dc_pred = dc;
; 2224 :    if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2225 :    data[0] = (short) (dc * dequant[0]);
; 2226 : 
; 2227 :    // decode AC components, see JPEG spec
; 2228 :    k = 1;
; 2229 :    do {
; 2230 :       unsigned int zig;
; 2231 :       int c,r,s;
; 2232 :       if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2233 :       c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2234 :       r = fac[c];
; 2235 :       if (r) { // fast-AC path
; 2236 :          k += (r >> 4) & 15; // run
; 2237 :          s = r & 15; // combined length
; 2238 :          if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2239 :          j->code_buffer <<= s;
; 2240 :          j->code_bits -= s;
; 2241 :          // decode into unzigzag'd location
; 2242 :          zig = stbi__jpeg_dezigzag[k++];
; 2243 :          data[zig] = (short) ((r >> 8) * dequant[zig]);
; 2244 :       } else {
; 2245 :          int rs = stbi__jpeg_huff_decode(j, hac);
; 2246 :          if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2247 :          s = rs & 15;
; 2248 :          r = rs >> 4;
; 2249 :          if (s == 0) {
; 2250 :             if (rs != 0xf0) break; // end block
; 2251 :             k += 16;
; 2252 :          } else {
; 2253 :             k += r;
; 2254 :             // decode into unzigzag'd location
; 2255 :             zig = stbi__jpeg_dezigzag[k++];
; 2256 :             data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
; 2257 :          }
; 2258 :       }
; 2259 :    } while (k < 64);
; 2260 :    return 1;
; 2261 : }
; 2262 : 
; 2263 : static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
; 2264 : {
; 2265 :    int diff,dc;
; 2266 :    int t;
; 2267 :    if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2268 : 
; 2269 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2270 : 
; 2271 :    if (j->succ_high == 0) {
; 2272 :       // first scan for DC coefficient, must be first
; 2273 :       memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
; 2274 :       t = stbi__jpeg_huff_decode(j, hdc);
; 2275 :       if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2276 :       diff = t ? stbi__extend_receive(j, t) : 0;
; 2277 : 
; 2278 :       if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");
; 2279 :       dc = j->img_comp[b].dc_pred + diff;
; 2280 :       j->img_comp[b].dc_pred = dc;
; 2281 :       if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2282 :       data[0] = (short) (dc * (1 << j->succ_low));
; 2283 :    } else {
; 2284 :       // refinement scan for DC coefficient
; 2285 :       if (stbi__jpeg_get_bit(j))
; 2286 :          data[0] += (short) (1 << j->succ_low);
; 2287 :    }
; 2288 :    return 1;
; 2289 : }
; 2290 : 
; 2291 : // @OPTIMIZE: store non-zigzagged during the decode passes,
; 2292 : // and only de-zigzag when dequantizing
; 2293 : static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
; 2294 : {
; 2295 :    int k;
; 2296 :    if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2297 : 
; 2298 :    if (j->succ_high == 0) {
; 2299 :       int shift = j->succ_low;
; 2300 : 
; 2301 :       if (j->eob_run) {
; 2302 :          --j->eob_run;
; 2303 :          return 1;
; 2304 :       }
; 2305 : 
; 2306 :       k = j->spec_start;
; 2307 :       do {
; 2308 :          unsigned int zig;
; 2309 :          int c,r,s;
; 2310 :          if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2311 :          c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2312 :          r = fac[c];
; 2313 :          if (r) { // fast-AC path
; 2314 :             k += (r >> 4) & 15; // run
; 2315 :             s = r & 15; // combined length
; 2316 :             if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2317 :             j->code_buffer <<= s;
; 2318 :             j->code_bits -= s;
; 2319 :             zig = stbi__jpeg_dezigzag[k++];
; 2320 :             data[zig] = (short) ((r >> 8) * (1 << shift));
; 2321 :          } else {
; 2322 :             int rs = stbi__jpeg_huff_decode(j, hac);
; 2323 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2324 :             s = rs & 15;
; 2325 :             r = rs >> 4;
; 2326 :             if (s == 0) {
; 2327 :                if (r < 15) {
; 2328 :                   j->eob_run = (1 << r);
; 2329 :                   if (r)
; 2330 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2331 :                   --j->eob_run;
; 2332 :                   break;
; 2333 :                }
; 2334 :                k += 16;
; 2335 :             } else {
; 2336 :                k += r;
; 2337 :                zig = stbi__jpeg_dezigzag[k++];
; 2338 :                data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
; 2339 :             }
; 2340 :          }
; 2341 :       } while (k <= j->spec_end);
; 2342 :    } else {
; 2343 :       // refinement scan for these AC coefficients
; 2344 : 
; 2345 :       short bit = (short) (1 << j->succ_low);
; 2346 : 
; 2347 :       if (j->eob_run) {
; 2348 :          --j->eob_run;
; 2349 :          for (k = j->spec_start; k <= j->spec_end; ++k) {
; 2350 :             short *p = &data[stbi__jpeg_dezigzag[k]];
; 2351 :             if (*p != 0)
; 2352 :                if (stbi__jpeg_get_bit(j))
; 2353 :                   if ((*p & bit)==0) {
; 2354 :                      if (*p > 0)
; 2355 :                         *p += bit;
; 2356 :                      else
; 2357 :                         *p -= bit;
; 2358 :                   }
; 2359 :          }
; 2360 :       } else {
; 2361 :          k = j->spec_start;
; 2362 :          do {
; 2363 :             int r,s;
; 2364 :             int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
; 2365 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2366 :             s = rs & 15;
; 2367 :             r = rs >> 4;
; 2368 :             if (s == 0) {
; 2369 :                if (r < 15) {
; 2370 :                   j->eob_run = (1 << r) - 1;
; 2371 :                   if (r)
; 2372 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2373 :                   r = 64; // force end of block
; 2374 :                } else {
; 2375 :                   // r=15 s=0 should write 16 0s, so we just do
; 2376 :                   // a run of 15 0s and then write s (which is 0),
; 2377 :                   // so we don't have to do anything special here
; 2378 :                }
; 2379 :             } else {
; 2380 :                if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
; 2381 :                // sign bit
; 2382 :                if (stbi__jpeg_get_bit(j))
; 2383 :                   s = bit;
; 2384 :                else
; 2385 :                   s = -bit;
; 2386 :             }
; 2387 : 
; 2388 :             // advance by r
; 2389 :             while (k <= j->spec_end) {
; 2390 :                short *p = &data[stbi__jpeg_dezigzag[k++]];
; 2391 :                if (*p != 0) {
; 2392 :                   if (stbi__jpeg_get_bit(j))
; 2393 :                      if ((*p & bit)==0) {
; 2394 :                         if (*p > 0)
; 2395 :                            *p += bit;
; 2396 :                         else
; 2397 :                            *p -= bit;
; 2398 :                      }
; 2399 :                } else {
; 2400 :                   if (r == 0) {
; 2401 :                      *p = (short) s;
; 2402 :                      break;
; 2403 :                   }
; 2404 :                   --r;
; 2405 :                }
; 2406 :             }
; 2407 :          } while (k <= j->spec_end);
; 2408 :       }
; 2409 :    }
; 2410 :    return 1;
; 2411 : }
; 2412 : 
; 2413 : // take a -128..127 value and stbi__clamp it and convert to 0..255
; 2414 : stbi_inline static stbi_uc stbi__clamp(int x)
; 2415 : {
; 2416 :    // trick to use a single test to catch both cases
; 2417 :    if ((unsigned int) x > 255) {
; 2418 :       if (x < 0) return 0;
; 2419 :       if (x > 255) return 255;
; 2420 :    }
; 2421 :    return (stbi_uc) x;
; 2422 : }
; 2423 : 
; 2424 : #define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
; 2425 : #define stbi__fsh(x)  ((x) * 4096)
; 2426 : 
; 2427 : // derived from jidctint -- DCT_ISLOW
; 2428 : #define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
; 2429 :    int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
; 2430 :    p2 = s2;                                    \
; 2431 :    p3 = s6;                                    \
; 2432 :    p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
; 2433 :    t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
; 2434 :    t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
; 2435 :    p2 = s0;                                    \
; 2436 :    p3 = s4;                                    \
; 2437 :    t0 = stbi__fsh(p2+p3);                      \
; 2438 :    t1 = stbi__fsh(p2-p3);                      \
; 2439 :    x0 = t0+t3;                                 \
; 2440 :    x3 = t0-t3;                                 \
; 2441 :    x1 = t1+t2;                                 \
; 2442 :    x2 = t1-t2;                                 \
; 2443 :    t0 = s7;                                    \
; 2444 :    t1 = s5;                                    \
; 2445 :    t2 = s3;                                    \
; 2446 :    t3 = s1;                                    \
; 2447 :    p3 = t0+t2;                                 \
; 2448 :    p4 = t1+t3;                                 \
; 2449 :    p1 = t0+t3;                                 \
; 2450 :    p2 = t1+t2;                                 \
; 2451 :    p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
; 2452 :    t0 = t0*stbi__f2f( 0.298631336f);           \
; 2453 :    t1 = t1*stbi__f2f( 2.053119869f);           \
; 2454 :    t2 = t2*stbi__f2f( 3.072711026f);           \
; 2455 :    t3 = t3*stbi__f2f( 1.501321110f);           \
; 2456 :    p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
; 2457 :    p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
; 2458 :    p3 = p3*stbi__f2f(-1.961570560f);           \
; 2459 :    p4 = p4*stbi__f2f(-0.390180644f);           \
; 2460 :    t3 += p1+p4;                                \
; 2461 :    t2 += p2+p3;                                \
; 2462 :    t1 += p2+p4;                                \
; 2463 :    t0 += p1+p3;
; 2464 : 
; 2465 : static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
; 2466 : {
; 2467 :    int i,val[64],*v=val;
; 2468 :    stbi_uc *o;
; 2469 :    short *d = data;
; 2470 : 
; 2471 :    // columns
; 2472 :    for (i=0; i < 8; ++i,++d, ++v) {
; 2473 :       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2474 :       if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2475 :            && d[40]==0 && d[48]==0 && d[56]==0) {
; 2476 :          //    no shortcut                 0     seconds
; 2477 :          //    (1|2|3|4|5|6|7)==0          0     seconds
; 2478 :          //    all separate               -0.047 seconds
; 2479 :          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2480 :          int dcterm = d[0]*4;
; 2481 :          v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
; 2482 :       } else {
; 2483 :          STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
; 2484 :          // constants scaled things up by 1<<12; let's bring them back
; 2485 :          // down, but keep 2 extra bits of precision
; 2486 :          x0 += 512; x1 += 512; x2 += 512; x3 += 512;
; 2487 :          v[ 0] = (x0+t3) >> 10;
; 2488 :          v[56] = (x0-t3) >> 10;
; 2489 :          v[ 8] = (x1+t2) >> 10;
; 2490 :          v[48] = (x1-t2) >> 10;
; 2491 :          v[16] = (x2+t1) >> 10;
; 2492 :          v[40] = (x2-t1) >> 10;
; 2493 :          v[24] = (x3+t0) >> 10;
; 2494 :          v[32] = (x3-t0) >> 10;
; 2495 :       }
; 2496 :    }
; 2497 : 
; 2498 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
; 2499 :       // no fast case since the first 1D IDCT spread components out
; 2500 :       STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
; 2501 :       // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2502 :       // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2503 :       // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2504 :       // so we want to round that, which means adding 0.5 * 1<<17,
; 2505 :       // aka 65536. Also, we'll end up with -128 to 127 that we want
; 2506 :       // to encode as 0..255 by adding 128, so we'll add that before the shift
; 2507 :       x0 += 65536 + (128<<17);
; 2508 :       x1 += 65536 + (128<<17);
; 2509 :       x2 += 65536 + (128<<17);
; 2510 :       x3 += 65536 + (128<<17);
; 2511 :       // tried computing the shifts into temps, or'ing the temps to see
; 2512 :       // if any were out of range, but that was slower
; 2513 :       o[0] = stbi__clamp((x0+t3) >> 17);
; 2514 :       o[7] = stbi__clamp((x0-t3) >> 17);
; 2515 :       o[1] = stbi__clamp((x1+t2) >> 17);
; 2516 :       o[6] = stbi__clamp((x1-t2) >> 17);
; 2517 :       o[2] = stbi__clamp((x2+t1) >> 17);
; 2518 :       o[5] = stbi__clamp((x2-t1) >> 17);
; 2519 :       o[3] = stbi__clamp((x3+t0) >> 17);
; 2520 :       o[4] = stbi__clamp((x3-t0) >> 17);
; 2521 :    }
; 2522 : }
; 2523 : 
; 2524 : #ifdef STBI_SSE2
; 2525 : // sse2 integer IDCT. not the fastest possible implementation but it
; 2526 : // produces bit-identical results to the generic C version so it's
; 2527 : // fully "transparent".
; 2528 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2529 : {
; 2530 :    // This is constructed to match our regular (generic) integer IDCT exactly.
; 2531 :    __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2532 :    __m128i tmp;
; 2533 : 
; 2534 :    // dot product constant: even elems=x, odd elems=y
; 2535 :    #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2536 : 
; 2537 :    // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2538 :    // out(1) = c1[even]*x + c1[odd]*y
; 2539 :    #define dct_rot(out0,out1, x,y,c0,c1) \
; 2540 :       __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2541 :       __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2542 :       __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2543 :       __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2544 :       __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2545 :       __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2546 : 
; 2547 :    // out = in << 12  (in 16-bit, out 32-bit)
; 2548 :    #define dct_widen(out, in) \
; 2549 :       __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2550 :       __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2551 : 
; 2552 :    // wide add
; 2553 :    #define dct_wadd(out, a, b) \
; 2554 :       __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2555 :       __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2556 : 
; 2557 :    // wide sub
; 2558 :    #define dct_wsub(out, a, b) \
; 2559 :       __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2560 :       __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2561 : 
; 2562 :    // butterfly a/b, add bias, then shift by "s" and pack
; 2563 :    #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2564 :       { \
; 2565 :          __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2566 :          __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2567 :          dct_wadd(sum, abiased, b); \
; 2568 :          dct_wsub(dif, abiased, b); \
; 2569 :          out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2570 :          out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2571 :       }
; 2572 : 
; 2573 :    // 8-bit interleave step (for transposes)
; 2574 :    #define dct_interleave8(a, b) \
; 2575 :       tmp = a; \
; 2576 :       a = _mm_unpacklo_epi8(a, b); \
; 2577 :       b = _mm_unpackhi_epi8(tmp, b)
; 2578 : 
; 2579 :    // 16-bit interleave step (for transposes)
; 2580 :    #define dct_interleave16(a, b) \
; 2581 :       tmp = a; \
; 2582 :       a = _mm_unpacklo_epi16(a, b); \
; 2583 :       b = _mm_unpackhi_epi16(tmp, b)
; 2584 : 
; 2585 :    #define dct_pass(bias,shift) \
; 2586 :       { \
; 2587 :          /* even part */ \
; 2588 :          dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2589 :          __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2590 :          __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2591 :          dct_widen(t0e, sum04); \
; 2592 :          dct_widen(t1e, dif04); \
; 2593 :          dct_wadd(x0, t0e, t3e); \
; 2594 :          dct_wsub(x3, t0e, t3e); \
; 2595 :          dct_wadd(x1, t1e, t2e); \
; 2596 :          dct_wsub(x2, t1e, t2e); \
; 2597 :          /* odd part */ \
; 2598 :          dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2599 :          dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2600 :          __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2601 :          __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2602 :          dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2603 :          dct_wadd(x4, y0o, y4o); \
; 2604 :          dct_wadd(x5, y1o, y5o); \
; 2605 :          dct_wadd(x6, y2o, y5o); \
; 2606 :          dct_wadd(x7, y3o, y4o); \
; 2607 :          dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2608 :          dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2609 :          dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2610 :          dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2611 :       }
; 2612 : 
; 2613 :    __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
; 2614 :    __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
; 2615 :    __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
; 2616 :    __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
; 2617 :    __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
; 2618 :    __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
; 2619 :    __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
; 2620 :    __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
; 2621 : 
; 2622 :    // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2623 :    __m128i bias_0 = _mm_set1_epi32(512);
; 2624 :    __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
; 2625 : 
; 2626 :    // load
; 2627 :    row0 = _mm_load_si128((const __m128i *) (data + 0*8));
; 2628 :    row1 = _mm_load_si128((const __m128i *) (data + 1*8));
; 2629 :    row2 = _mm_load_si128((const __m128i *) (data + 2*8));
; 2630 :    row3 = _mm_load_si128((const __m128i *) (data + 3*8));
; 2631 :    row4 = _mm_load_si128((const __m128i *) (data + 4*8));
; 2632 :    row5 = _mm_load_si128((const __m128i *) (data + 5*8));
; 2633 :    row6 = _mm_load_si128((const __m128i *) (data + 6*8));
; 2634 :    row7 = _mm_load_si128((const __m128i *) (data + 7*8));
; 2635 : 
; 2636 :    // column pass
; 2637 :    dct_pass(bias_0, 10);
; 2638 : 
; 2639 :    {
; 2640 :       // 16bit 8x8 transpose pass 1
; 2641 :       dct_interleave16(row0, row4);
; 2642 :       dct_interleave16(row1, row5);
; 2643 :       dct_interleave16(row2, row6);
; 2644 :       dct_interleave16(row3, row7);
; 2645 : 
; 2646 :       // transpose pass 2
; 2647 :       dct_interleave16(row0, row2);
; 2648 :       dct_interleave16(row1, row3);
; 2649 :       dct_interleave16(row4, row6);
; 2650 :       dct_interleave16(row5, row7);
; 2651 : 
; 2652 :       // transpose pass 3
; 2653 :       dct_interleave16(row0, row1);
; 2654 :       dct_interleave16(row2, row3);
; 2655 :       dct_interleave16(row4, row5);
; 2656 :       dct_interleave16(row6, row7);
; 2657 :    }
; 2658 : 
; 2659 :    // row pass
; 2660 :    dct_pass(bias_1, 17);
; 2661 : 
; 2662 :    {
; 2663 :       // pack
; 2664 :       __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
; 2665 :       __m128i p1 = _mm_packus_epi16(row2, row3);
; 2666 :       __m128i p2 = _mm_packus_epi16(row4, row5);
; 2667 :       __m128i p3 = _mm_packus_epi16(row6, row7);
; 2668 : 
; 2669 :       // 8bit 8x8 transpose pass 1
; 2670 :       dct_interleave8(p0, p2); // a0e0a1e1...
; 2671 :       dct_interleave8(p1, p3); // c0g0c1g1...
; 2672 : 
; 2673 :       // transpose pass 2
; 2674 :       dct_interleave8(p0, p1); // a0c0e0g0...
; 2675 :       dct_interleave8(p2, p3); // b0d0f0h0...
; 2676 : 
; 2677 :       // transpose pass 3
; 2678 :       dct_interleave8(p0, p2); // a0b0c0d0...
; 2679 :       dct_interleave8(p1, p3); // a4b4c4d4...
; 2680 : 
; 2681 :       // store
; 2682 :       _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
; 2683 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
; 2684 :       _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
; 2685 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
; 2686 :       _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
; 2687 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
; 2688 :       _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
; 2689 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
; 2690 :    }
; 2691 : 
; 2692 : #undef dct_const
; 2693 : #undef dct_rot
; 2694 : #undef dct_widen
; 2695 : #undef dct_wadd
; 2696 : #undef dct_wsub
; 2697 : #undef dct_bfly32o
; 2698 : #undef dct_interleave8
; 2699 : #undef dct_interleave16
; 2700 : #undef dct_pass
; 2701 : }
; 2702 : 
; 2703 : #endif // STBI_SSE2
; 2704 : 
; 2705 : #ifdef STBI_NEON
; 2706 : 
; 2707 : // NEON integer IDCT. should produce bit-identical
; 2708 : // results to the generic C version.
; 2709 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2710 : {
; 2711 :    int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;
; 2712 : 
; 2713 :    int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
; 2714 :    int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
; 2715 :    int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
; 2716 :    int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
; 2717 :    int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
; 2718 :    int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
; 2719 :    int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
; 2720 :    int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
; 2721 :    int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
; 2722 :    int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
; 2723 :    int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
; 2724 :    int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));
; 2725 : 
; 2726 : #define dct_long_mul(out, inq, coeff) \
; 2727 :    int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
; 2728 :    int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)
; 2729 : 
; 2730 : #define dct_long_mac(out, acc, inq, coeff) \
; 2731 :    int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
; 2732 :    int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)
; 2733 : 
; 2734 : #define dct_widen(out, inq) \
; 2735 :    int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
; 2736 :    int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)
; 2737 : 
; 2738 : // wide add
; 2739 : #define dct_wadd(out, a, b) \
; 2740 :    int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
; 2741 :    int32x4_t out##_h = vaddq_s32(a##_h, b##_h)
; 2742 : 
; 2743 : // wide sub
; 2744 : #define dct_wsub(out, a, b) \
; 2745 :    int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
; 2746 :    int32x4_t out##_h = vsubq_s32(a##_h, b##_h)
; 2747 : 
; 2748 : // butterfly a/b, then shift using "shiftop" by "s" and pack
; 2749 : #define dct_bfly32o(out0,out1, a,b,shiftop,s) \
; 2750 :    { \
; 2751 :       dct_wadd(sum, a, b); \
; 2752 :       dct_wsub(dif, a, b); \
; 2753 :       out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
; 2754 :       out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
; 2755 :    }
; 2756 : 
; 2757 : #define dct_pass(shiftop, shift) \
; 2758 :    { \
; 2759 :       /* even part */ \
; 2760 :       int16x8_t sum26 = vaddq_s16(row2, row6); \
; 2761 :       dct_long_mul(p1e, sum26, rot0_0); \
; 2762 :       dct_long_mac(t2e, p1e, row6, rot0_1); \
; 2763 :       dct_long_mac(t3e, p1e, row2, rot0_2); \
; 2764 :       int16x8_t sum04 = vaddq_s16(row0, row4); \
; 2765 :       int16x8_t dif04 = vsubq_s16(row0, row4); \
; 2766 :       dct_widen(t0e, sum04); \
; 2767 :       dct_widen(t1e, dif04); \
; 2768 :       dct_wadd(x0, t0e, t3e); \
; 2769 :       dct_wsub(x3, t0e, t3e); \
; 2770 :       dct_wadd(x1, t1e, t2e); \
; 2771 :       dct_wsub(x2, t1e, t2e); \
; 2772 :       /* odd part */ \
; 2773 :       int16x8_t sum15 = vaddq_s16(row1, row5); \
; 2774 :       int16x8_t sum17 = vaddq_s16(row1, row7); \
; 2775 :       int16x8_t sum35 = vaddq_s16(row3, row5); \
; 2776 :       int16x8_t sum37 = vaddq_s16(row3, row7); \
; 2777 :       int16x8_t sumodd = vaddq_s16(sum17, sum35); \
; 2778 :       dct_long_mul(p5o, sumodd, rot1_0); \
; 2779 :       dct_long_mac(p1o, p5o, sum17, rot1_1); \
; 2780 :       dct_long_mac(p2o, p5o, sum35, rot1_2); \
; 2781 :       dct_long_mul(p3o, sum37, rot2_0); \
; 2782 :       dct_long_mul(p4o, sum15, rot2_1); \
; 2783 :       dct_wadd(sump13o, p1o, p3o); \
; 2784 :       dct_wadd(sump24o, p2o, p4o); \
; 2785 :       dct_wadd(sump23o, p2o, p3o); \
; 2786 :       dct_wadd(sump14o, p1o, p4o); \
; 2787 :       dct_long_mac(x4, sump13o, row7, rot3_0); \
; 2788 :       dct_long_mac(x5, sump24o, row5, rot3_1); \
; 2789 :       dct_long_mac(x6, sump23o, row3, rot3_2); \
; 2790 :       dct_long_mac(x7, sump14o, row1, rot3_3); \
; 2791 :       dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
; 2792 :       dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
; 2793 :       dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
; 2794 :       dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
; 2795 :    }
; 2796 : 
; 2797 :    // load
; 2798 :    row0 = vld1q_s16(data + 0*8);
; 2799 :    row1 = vld1q_s16(data + 1*8);
; 2800 :    row2 = vld1q_s16(data + 2*8);
; 2801 :    row3 = vld1q_s16(data + 3*8);
; 2802 :    row4 = vld1q_s16(data + 4*8);
; 2803 :    row5 = vld1q_s16(data + 5*8);
; 2804 :    row6 = vld1q_s16(data + 6*8);
; 2805 :    row7 = vld1q_s16(data + 7*8);
; 2806 : 
; 2807 :    // add DC bias
; 2808 :    row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));
; 2809 : 
; 2810 :    // column pass
; 2811 :    dct_pass(vrshrn_n_s32, 10);
; 2812 : 
; 2813 :    // 16bit 8x8 transpose
; 2814 :    {
; 2815 : // these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
; 2816 : // whether compilers actually get this is another story, sadly.
; 2817 : #define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
; 2818 : #define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
; 2819 : #define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }
; 2820 : 
; 2821 :       // pass 1
; 2822 :       dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
; 2823 :       dct_trn16(row2, row3);
; 2824 :       dct_trn16(row4, row5);
; 2825 :       dct_trn16(row6, row7);
; 2826 : 
; 2827 :       // pass 2
; 2828 :       dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
; 2829 :       dct_trn32(row1, row3);
; 2830 :       dct_trn32(row4, row6);
; 2831 :       dct_trn32(row5, row7);
; 2832 : 
; 2833 :       // pass 3
; 2834 :       dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
; 2835 :       dct_trn64(row1, row5);
; 2836 :       dct_trn64(row2, row6);
; 2837 :       dct_trn64(row3, row7);
; 2838 : 
; 2839 : #undef dct_trn16
; 2840 : #undef dct_trn32
; 2841 : #undef dct_trn64
; 2842 :    }
; 2843 : 
; 2844 :    // row pass
; 2845 :    // vrshrn_n_s32 only supports shifts up to 16, we need
; 2846 :    // 17. so do a non-rounding shift of 16 first then follow
; 2847 :    // up with a rounding shift by 1.
; 2848 :    dct_pass(vshrn_n_s32, 16);
; 2849 : 
; 2850 :    {
; 2851 :       // pack and round
; 2852 :       uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
; 2853 :       uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
; 2854 :       uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
; 2855 :       uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
; 2856 :       uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
; 2857 :       uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
; 2858 :       uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
; 2859 :       uint8x8_t p7 = vqrshrun_n_s16(row7, 1);
; 2860 : 
; 2861 :       // again, these can translate into one instruction, but often don't.
; 2862 : #define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
; 2863 : #define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
; 2864 : #define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }
; 2865 : 
; 2866 :       // sadly can't use interleaved stores here since we only write
; 2867 :       // 8 bytes to each scan line!
; 2868 : 
; 2869 :       // 8x8 8-bit transpose pass 1
; 2870 :       dct_trn8_8(p0, p1);
; 2871 :       dct_trn8_8(p2, p3);
; 2872 :       dct_trn8_8(p4, p5);
; 2873 :       dct_trn8_8(p6, p7);
; 2874 : 
; 2875 :       // pass 2
; 2876 :       dct_trn8_16(p0, p2);
; 2877 :       dct_trn8_16(p1, p3);
; 2878 :       dct_trn8_16(p4, p6);
; 2879 :       dct_trn8_16(p5, p7);
; 2880 : 
; 2881 :       // pass 3
; 2882 :       dct_trn8_32(p0, p4);
; 2883 :       dct_trn8_32(p1, p5);
; 2884 :       dct_trn8_32(p2, p6);
; 2885 :       dct_trn8_32(p3, p7);
; 2886 : 
; 2887 :       // store
; 2888 :       vst1_u8(out, p0); out += out_stride;
; 2889 :       vst1_u8(out, p1); out += out_stride;
; 2890 :       vst1_u8(out, p2); out += out_stride;
; 2891 :       vst1_u8(out, p3); out += out_stride;
; 2892 :       vst1_u8(out, p4); out += out_stride;
; 2893 :       vst1_u8(out, p5); out += out_stride;
; 2894 :       vst1_u8(out, p6); out += out_stride;
; 2895 :       vst1_u8(out, p7);
; 2896 : 
; 2897 : #undef dct_trn8_8
; 2898 : #undef dct_trn8_16
; 2899 : #undef dct_trn8_32
; 2900 :    }
; 2901 : 
; 2902 : #undef dct_long_mul
; 2903 : #undef dct_long_mac
; 2904 : #undef dct_widen
; 2905 : #undef dct_wadd
; 2906 : #undef dct_wsub
; 2907 : #undef dct_bfly32o
; 2908 : #undef dct_pass
; 2909 : }
; 2910 : 
; 2911 : #endif // STBI_NEON
; 2912 : 
; 2913 : #define STBI__MARKER_none  0xff
; 2914 : // if there's a pending marker from the entropy stream, return that
; 2915 : // otherwise, fetch from the stream and get a marker. if there's no
; 2916 : // marker, return 0xff, which is never a valid marker value
; 2917 : static stbi_uc stbi__get_marker(stbi__jpeg *j)
; 2918 : {
; 2919 :    stbi_uc x;
; 2920 :    if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
; 2921 :    x = stbi__get8(j->s);
; 2922 :    if (x != 0xff) return STBI__MARKER_none;
; 2923 :    while (x == 0xff)
; 2924 :       x = stbi__get8(j->s); // consume repeated 0xff fill bytes
; 2925 :    return x;
; 2926 : }
; 2927 : 
; 2928 : // in each scan, we'll have scan_n components, and the order
; 2929 : // of the components is specified by order[]
; 2930 : #define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
; 2931 : 
; 2932 : // after a restart interval, stbi__jpeg_reset the entropy decoder and
; 2933 : // the dc prediction
; 2934 : static void stbi__jpeg_reset(stbi__jpeg *j)
; 2935 : {
; 2936 :    j->code_bits = 0;
; 2937 :    j->code_buffer = 0;
; 2938 :    j->nomore = 0;
; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
; 2940 :    j->marker = STBI__MARKER_none;
; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
; 2942 :    j->eob_run = 0;
; 2943 :    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2944 :    // since we don't even allow 1<<30 pixels
; 2945 : }
; 2946 : 
; 2947 : static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
; 2948 : {
; 2949 :    stbi__jpeg_reset(z);
; 2950 :    if (!z->progressive) {
; 2951 :       if (z->scan_n == 1) {
; 2952 :          int i,j;
; 2953 :          STBI_SIMD_ALIGN(short, data[64]);
; 2954 :          int n = z->order[0];
; 2955 :          // non-interleaved data, we just need to process one block at a time,
; 2956 :          // in trivial scanline order
; 2957 :          // number of blocks to do just depends on how many actual "pixels" this
; 2958 :          // component has, independent of interleaved MCU blocking and such
; 2959 :          int w = (z->img_comp[n].x+7) >> 3;
; 2960 :          int h = (z->img_comp[n].y+7) >> 3;
; 2961 :          for (j=0; j < h; ++j) {
; 2962 :             for (i=0; i < w; ++i) {
; 2963 :                int ha = z->img_comp[n].ha;
; 2964 :                if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2965 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 2966 :                // every data block is an MCU, so countdown the restart interval
; 2967 :                if (--z->todo <= 0) {
; 2968 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 2969 :                   // if it's NOT a restart, then just bail, so we get corrupt data
; 2970 :                   // rather than no data
; 2971 :                   if (!STBI__RESTART(z->marker)) return 1;
; 2972 :                   stbi__jpeg_reset(z);
; 2973 :                }
; 2974 :             }
; 2975 :          }
; 2976 :          return 1;
; 2977 :       } else { // interleaved
; 2978 :          int i,j,k,x,y;
; 2979 :          STBI_SIMD_ALIGN(short, data[64]);
; 2980 :          for (j=0; j < z->img_mcu_y; ++j) {
; 2981 :             for (i=0; i < z->img_mcu_x; ++i) {
; 2982 :                // scan an interleaved mcu... process scan_n components in order
; 2983 :                for (k=0; k < z->scan_n; ++k) {
; 2984 :                   int n = z->order[k];
; 2985 :                   // scan out an mcu's worth of this component; that's just determined
; 2986 :                   // by the basic H and V specified for the component
; 2987 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 2988 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 2989 :                         int x2 = (i*z->img_comp[n].h + x)*8;
; 2990 :                         int y2 = (j*z->img_comp[n].v + y)*8;
; 2991 :                         int ha = z->img_comp[n].ha;
; 2992 :                         if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2993 :                         z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
; 2994 :                      }
; 2995 :                   }
; 2996 :                }
; 2997 :                // after all interleaved components, that's an interleaved MCU,
; 2998 :                // so now count down the restart interval
; 2999 :                if (--z->todo <= 0) {
; 3000 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3001 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3002 :                   stbi__jpeg_reset(z);
; 3003 :                }
; 3004 :             }
; 3005 :          }
; 3006 :          return 1;
; 3007 :       }
; 3008 :    } else {
; 3009 :       if (z->scan_n == 1) {
; 3010 :          int i,j;
; 3011 :          int n = z->order[0];
; 3012 :          // non-interleaved data, we just need to process one block at a time,
; 3013 :          // in trivial scanline order
; 3014 :          // number of blocks to do just depends on how many actual "pixels" this
; 3015 :          // component has, independent of interleaved MCU blocking and such
; 3016 :          int w = (z->img_comp[n].x+7) >> 3;
; 3017 :          int h = (z->img_comp[n].y+7) >> 3;
; 3018 :          for (j=0; j < h; ++j) {
; 3019 :             for (i=0; i < w; ++i) {
; 3020 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3021 :                if (z->spec_start == 0) {
; 3022 :                   if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3023 :                      return 0;
; 3024 :                } else {
; 3025 :                   int ha = z->img_comp[n].ha;
; 3026 :                   if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
; 3027 :                      return 0;
; 3028 :                }
; 3029 :                // every data block is an MCU, so countdown the restart interval
; 3030 :                if (--z->todo <= 0) {
; 3031 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3032 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3033 :                   stbi__jpeg_reset(z);
; 3034 :                }
; 3035 :             }
; 3036 :          }
; 3037 :          return 1;
; 3038 :       } else { // interleaved
; 3039 :          int i,j,k,x,y;
; 3040 :          for (j=0; j < z->img_mcu_y; ++j) {
; 3041 :             for (i=0; i < z->img_mcu_x; ++i) {
; 3042 :                // scan an interleaved mcu... process scan_n components in order
; 3043 :                for (k=0; k < z->scan_n; ++k) {
; 3044 :                   int n = z->order[k];
; 3045 :                   // scan out an mcu's worth of this component; that's just determined
; 3046 :                   // by the basic H and V specified for the component
; 3047 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 3048 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 3049 :                         int x2 = (i*z->img_comp[n].h + x);
; 3050 :                         int y2 = (j*z->img_comp[n].v + y);
; 3051 :                         short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
; 3052 :                         if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3053 :                            return 0;
; 3054 :                      }
; 3055 :                   }
; 3056 :                }
; 3057 :                // after all interleaved components, that's an interleaved MCU,
; 3058 :                // so now count down the restart interval
; 3059 :                if (--z->todo <= 0) {
; 3060 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3061 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3062 :                   stbi__jpeg_reset(z);
; 3063 :                }
; 3064 :             }
; 3065 :          }
; 3066 :          return 1;
; 3067 :       }
; 3068 :    }
; 3069 : }
; 3070 : 
; 3071 : static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
; 3072 : {
; 3073 :    int i;
; 3074 :    for (i=0; i < 64; ++i)
; 3075 :       data[i] *= dequant[i];
; 3076 : }
; 3077 : 
; 3078 : static void stbi__jpeg_finish(stbi__jpeg *z)
; 3079 : {
; 3080 :    if (z->progressive) {
; 3081 :       // dequantize and idct the data
; 3082 :       int i,j,n;
; 3083 :       for (n=0; n < z->s->img_n; ++n) {
; 3084 :          int w = (z->img_comp[n].x+7) >> 3;
; 3085 :          int h = (z->img_comp[n].y+7) >> 3;
; 3086 :          for (j=0; j < h; ++j) {
; 3087 :             for (i=0; i < w; ++i) {
; 3088 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3089 :                stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
; 3090 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 3091 :             }
; 3092 :          }
; 3093 :       }
; 3094 :    }
; 3095 : }
; 3096 : 
; 3097 : static int stbi__process_marker(stbi__jpeg *z, int m)
; 3098 : {
; 3099 :    int L;
; 3100 :    switch (m) {
; 3101 :       case STBI__MARKER_none: // no marker found
; 3102 :          return stbi__err("expected marker","Corrupt JPEG");
; 3103 : 
; 3104 :       case 0xDD: // DRI - specify restart interval
; 3105 :          if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
; 3106 :          z->restart_interval = stbi__get16be(z->s);
; 3107 :          return 1;
; 3108 : 
; 3109 :       case 0xDB: // DQT - define quantization table
; 3110 :          L = stbi__get16be(z->s)-2;
; 3111 :          while (L > 0) {
; 3112 :             int q = stbi__get8(z->s);
; 3113 :             int p = q >> 4, sixteen = (p != 0);
; 3114 :             int t = q & 15,i;
; 3115 :             if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
; 3116 :             if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");
; 3117 : 
; 3118 :             for (i=0; i < 64; ++i)
; 3119 :                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
; 3120 :             L -= (sixteen ? 129 : 65);
; 3121 :          }
; 3122 :          return L==0;
; 3123 : 
; 3124 :       case 0xC4: // DHT - define huffman table
; 3125 :          L = stbi__get16be(z->s)-2;
; 3126 :          while (L > 0) {
; 3127 :             stbi_uc *v;
; 3128 :             int sizes[16],i,n=0;
; 3129 :             int q = stbi__get8(z->s);
; 3130 :             int tc = q >> 4;
; 3131 :             int th = q & 15;
; 3132 :             if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
; 3133 :             for (i=0; i < 16; ++i) {
; 3134 :                sizes[i] = stbi__get8(z->s);
; 3135 :                n += sizes[i];
; 3136 :             }
; 3137 :             if(n > 256) return stbi__err("bad DHT header","Corrupt JPEG"); // Loop over i < n would write past end of values!
; 3138 :             L -= 17;
; 3139 :             if (tc == 0) {
; 3140 :                if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
; 3141 :                v = z->huff_dc[th].values;
; 3142 :             } else {
; 3143 :                if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
; 3144 :                v = z->huff_ac[th].values;
; 3145 :             }
; 3146 :             for (i=0; i < n; ++i)
; 3147 :                v[i] = stbi__get8(z->s);
; 3148 :             if (tc != 0)
; 3149 :                stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
; 3150 :             L -= n;
; 3151 :          }
; 3152 :          return L==0;
; 3153 :    }
; 3154 : 
; 3155 :    // check for comment block or APP blocks
; 3156 :    if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
; 3157 :       L = stbi__get16be(z->s);
; 3158 :       if (L < 2) {
; 3159 :          if (m == 0xFE)
; 3160 :             return stbi__err("bad COM len","Corrupt JPEG");
; 3161 :          else
; 3162 :             return stbi__err("bad APP len","Corrupt JPEG");
; 3163 :       }
; 3164 :       L -= 2;
; 3165 : 
; 3166 :       if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
; 3167 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3168 :          int ok = 1;
; 3169 :          int i;
; 3170 :          for (i=0; i < 5; ++i)
; 3171 :             if (stbi__get8(z->s) != tag[i])
; 3172 :                ok = 0;
; 3173 :          L -= 5;
; 3174 :          if (ok)
; 3175 :             z->jfif = 1;
; 3176 :       } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;
; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)
; 3181 :             if (stbi__get8(z->s) != tag[i])
; 3182 :                ok = 0;
; 3183 :          L -= 6;
; 3184 :          if (ok) {
; 3185 :             stbi__get8(z->s); // version
; 3186 :             stbi__get16be(z->s); // flags0
; 3187 :             stbi__get16be(z->s); // flags1
; 3188 :             z->app14_color_transform = stbi__get8(z->s); // color transform
; 3189 :             L -= 6;
; 3190 :          }
; 3191 :       }
; 3192 : 
; 3193 :       stbi__skip(z->s, L);
; 3194 :       return 1;
; 3195 :    }
; 3196 : 
; 3197 :    return stbi__err("unknown marker","Corrupt JPEG");
; 3198 : }
; 3199 : 
; 3200 : // after we see SOS
; 3201 : static int stbi__process_scan_header(stbi__jpeg *z)
; 3202 : {
; 3203 :    int i;
; 3204 :    int Ls = stbi__get16be(z->s);
; 3205 :    z->scan_n = stbi__get8(z->s);
; 3206 :    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
; 3207 :    if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
; 3208 :    for (i=0; i < z->scan_n; ++i) {
; 3209 :       int id = stbi__get8(z->s), which;
; 3210 :       int q = stbi__get8(z->s);
; 3211 :       for (which = 0; which < z->s->img_n; ++which)
; 3212 :          if (z->img_comp[which].id == id)
; 3213 :             break;
; 3214 :       if (which == z->s->img_n) return 0; // no match
; 3215 :       z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
; 3216 :       z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
; 3217 :       z->order[i] = which;
; 3218 :    }
; 3219 : 
; 3220 :    {
; 3221 :       int aa;
; 3222 :       z->spec_start = stbi__get8(z->s);
; 3223 :       z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
; 3224 :       aa = stbi__get8(z->s);
; 3225 :       z->succ_high = (aa >> 4);
; 3226 :       z->succ_low  = (aa & 15);
; 3227 :       if (z->progressive) {
; 3228 :          if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
; 3229 :             return stbi__err("bad SOS", "Corrupt JPEG");
; 3230 :       } else {
; 3231 :          if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3232 :          if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3233 :          z->spec_end = 63;
; 3234 :       }
; 3235 :    }
; 3236 : 
; 3237 :    return 1;
; 3238 : }
; 3239 : 
; 3240 : static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
; 3241 : {
; 3242 :    int i;
; 3243 :    for (i=0; i < ncomp; ++i) {
; 3244 :       if (z->img_comp[i].raw_data) {
; 3245 :          STBI_FREE(z->img_comp[i].raw_data);
; 3246 :          z->img_comp[i].raw_data = NULL;
; 3247 :          z->img_comp[i].data = NULL;
; 3248 :       }
; 3249 :       if (z->img_comp[i].raw_coeff) {
; 3250 :          STBI_FREE(z->img_comp[i].raw_coeff);
; 3251 :          z->img_comp[i].raw_coeff = 0;
; 3252 :          z->img_comp[i].coeff = 0;
; 3253 :       }
; 3254 :       if (z->img_comp[i].linebuf) {
; 3255 :          STBI_FREE(z->img_comp[i].linebuf);
; 3256 :          z->img_comp[i].linebuf = NULL;
; 3257 :       }
; 3258 :    }
; 3259 :    return why;
; 3260 : }
; 3261 : 
; 3262 : static int stbi__process_frame_header(stbi__jpeg *z, int scan)
; 3263 : {
; 3264 :    stbi__context *s = z->s;
; 3265 :    int Lf,p,i,q, h_max=1,v_max=1,c;
; 3266 :    Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
; 3267 :    p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
; 3268 :    s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
; 3269 :    s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
; 3270 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 3271 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 3272 :    c = stbi__get8(s);
; 3273 :    if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");
; 3274 :    s->img_n = c;
; 3275 :    for (i=0; i < c; ++i) {
; 3276 :       z->img_comp[i].data = NULL;
; 3277 :       z->img_comp[i].linebuf = NULL;
; 3278 :    }
; 3279 : 
; 3280 :    if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");
; 3281 : 
; 3282 :    z->rgb = 0;
; 3283 :    for (i=0; i < s->img_n; ++i) {
; 3284 :       static const unsigned char rgb[3] = { 'R', 'G', 'B' };
; 3285 :       z->img_comp[i].id = stbi__get8(s);
; 3286 :       if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
; 3287 :          ++z->rgb;
; 3288 :       q = stbi__get8(s);
; 3289 :       z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
; 3290 :       z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
; 3291 :       z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
; 3292 :    }
; 3293 : 
; 3294 :    if (scan != STBI__SCAN_load) return 1;
; 3295 : 
; 3296 :    if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");
; 3297 : 
; 3298 :    for (i=0; i < s->img_n; ++i) {
; 3299 :       if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
; 3300 :       if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
; 3301 :    }
; 3302 : 
; 3303 :    // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
; 3304 :    // and I've never seen a non-corrupted JPEG file actually use them
; 3305 :    for (i=0; i < s->img_n; ++i) {
; 3306 :       if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");
; 3307 :       if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");
; 3308 :    }
; 3309 : 
; 3310 :    // compute interleaved mcu info
; 3311 :    z->img_h_max = h_max;
; 3312 :    z->img_v_max = v_max;
; 3313 :    z->img_mcu_w = h_max * 8;
; 3314 :    z->img_mcu_h = v_max * 8;
; 3315 :    // these sizes can't be more than 17 bits
; 3316 :    z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
; 3317 :    z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;
; 3318 : 
; 3319 :    for (i=0; i < s->img_n; ++i) {
; 3320 :       // number of effective pixels (e.g. for non-interleaved MCU)
; 3321 :       z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
; 3322 :       z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
; 3323 :       // to simplify generation, we'll allocate enough memory to decode
; 3324 :       // the bogus oversized data from using interleaved MCUs and their
; 3325 :       // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
; 3326 :       // discard the extra data until colorspace conversion
; 3327 :       //
; 3328 :       // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
; 3329 :       // so these muls can't overflow with 32-bit ints (which we require)
; 3330 :       z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
; 3331 :       z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
; 3332 :       z->img_comp[i].coeff = 0;
; 3333 :       z->img_comp[i].raw_coeff = 0;
; 3334 :       z->img_comp[i].linebuf = NULL;
; 3335 :       z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
; 3336 :       if (z->img_comp[i].raw_data == NULL)
; 3337 :          return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
; 3338 :       // align blocks for idct using mmx/sse
; 3339 :       z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
; 3340 :       if (z->progressive) {
; 3341 :          // w2, h2 are multiples of 8 (see above)
; 3342 :          z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
; 3343 :          z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
; 3344 :          z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
; 3345 :          if (z->img_comp[i].raw_coeff == NULL)
; 3346 :             return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
; 3347 :          z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
; 3348 :       }
; 3349 :    }
; 3350 : 
; 3351 :    return 1;
; 3352 : }
; 3353 : 
; 3354 : // use comparisons since in some cases we handle more than one case (e.g. SOF)
; 3355 : #define stbi__DNL(x)         ((x) == 0xdc)
; 3356 : #define stbi__SOI(x)         ((x) == 0xd8)
; 3357 : #define stbi__EOI(x)         ((x) == 0xd9)
; 3358 : #define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
; 3359 : #define stbi__SOS(x)         ((x) == 0xda)
; 3360 : 
; 3361 : #define stbi__SOF_progressive(x)   ((x) == 0xc2)
; 3362 : 
; 3363 : static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
; 3364 : {
; 3365 :    int m;
; 3366 :    z->jfif = 0;
; 3367 :    z->app14_color_transform = -1; // valid values are 0,1,2
; 3368 :    z->marker = STBI__MARKER_none; // initialize cached marker to empty
; 3369 :    m = stbi__get_marker(z);
; 3370 :    if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
; 3371 :    if (scan == STBI__SCAN_type) return 1;
; 3372 :    m = stbi__get_marker(z);
; 3373 :    while (!stbi__SOF(m)) {
; 3374 :       if (!stbi__process_marker(z,m)) return 0;
; 3375 :       m = stbi__get_marker(z);
; 3376 :       while (m == STBI__MARKER_none) {
; 3377 :          // some files have extra padding after their blocks, so ok, we'll scan
; 3378 :          if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
; 3379 :          m = stbi__get_marker(z);
; 3380 :       }
; 3381 :    }
; 3382 :    z->progressive = stbi__SOF_progressive(m);
; 3383 :    if (!stbi__process_frame_header(z, scan)) return 0;
; 3384 :    return 1;
; 3385 : }
; 3386 : 
; 3387 : static int stbi__skip_jpeg_junk_at_end(stbi__jpeg *j)
; 3388 : {
; 3389 :    // some JPEGs have junk at end, skip over it but if we find what looks
; 3390 :    // like a valid marker, resume there
; 3391 :    while (!stbi__at_eof(j->s)) {
; 3392 :       int x = stbi__get8(j->s);
; 3393 :       while (x == 255) { // might be a marker
; 3394 :          if (stbi__at_eof(j->s)) return STBI__MARKER_none;
; 3395 :          x = stbi__get8(j->s);
; 3396 :          if (x != 0x00 && x != 0xff) {
; 3397 :             // not a stuffed zero or lead-in to another marker, looks
; 3398 :             // like an actual marker, return it
; 3399 :             return x;
; 3400 :          }
; 3401 :          // stuffed zero has x=0 now which ends the loop, meaning we go
; 3402 :          // back to regular scan loop.
; 3403 :          // repeated 0xff keeps trying to read the next byte of the marker.
; 3404 :       }
; 3405 :    }
; 3406 :    return STBI__MARKER_none;
; 3407 : }
; 3408 : 
; 3409 : // decode image to YCbCr format
; 3410 : static int stbi__decode_jpeg_image(stbi__jpeg *j)
; 3411 : {
; 3412 :    int m;
; 3413 :    for (m = 0; m < 4; m++) {
; 3414 :       j->img_comp[m].raw_data = NULL;
; 3415 :       j->img_comp[m].raw_coeff = NULL;
; 3416 :    }
; 3417 :    j->restart_interval = 0;
; 3418 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
; 3419 :    m = stbi__get_marker(j);
; 3420 :    while (!stbi__EOI(m)) {
; 3421 :       if (stbi__SOS(m)) {
; 3422 :          if (!stbi__process_scan_header(j)) return 0;
; 3423 :          if (!stbi__parse_entropy_coded_data(j)) return 0;
; 3424 :          if (j->marker == STBI__MARKER_none ) {
; 3425 :          j->marker = stbi__skip_jpeg_junk_at_end(j);
; 3426 :             // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
; 3427 :          }
; 3428 :          m = stbi__get_marker(j);
; 3429 :          if (STBI__RESTART(m))
; 3430 :             m = stbi__get_marker(j);
; 3431 :       } else if (stbi__DNL(m)) {
; 3432 :          int Ld = stbi__get16be(j->s);
; 3433 :          stbi__uint32 NL = stbi__get16be(j->s);
; 3434 :          if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
; 3435 :          if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
; 3436 :          m = stbi__get_marker(j);
; 3437 :       } else {
; 3438 :          if (!stbi__process_marker(j, m)) return 1;
; 3439 :          m = stbi__get_marker(j);
; 3440 :       }
; 3441 :    }
; 3442 :    if (j->progressive)
; 3443 :       stbi__jpeg_finish(j);
; 3444 :    return 1;
; 3445 : }
; 3446 : 
; 3447 : // static jfif-centered resampling (across block boundaries)
; 3448 : 
; 3449 : typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
; 3450 :                                     int w, int hs);
; 3451 : 
; 3452 : #define stbi__div4(x) ((stbi_uc) ((x) >> 2))
; 3453 : 
; 3454 : static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3455 : {
; 3456 :    STBI_NOTUSED(out);
; 3457 :    STBI_NOTUSED(in_far);
; 3458 :    STBI_NOTUSED(w);
; 3459 :    STBI_NOTUSED(hs);
; 3460 :    return in_near;
; 3461 : }
; 3462 : 
; 3463 : static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3464 : {
; 3465 :    // need to generate two samples vertically for every one in input
; 3466 :    int i;
; 3467 :    STBI_NOTUSED(hs);
; 3468 :    for (i=0; i < w; ++i)
; 3469 :       out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
; 3470 :    return out;
; 3471 : }
; 3472 : 
; 3473 : static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3474 : {
; 3475 :    // need to generate two samples horizontally for every one in input
; 3476 :    int i;
; 3477 :    stbi_uc *input = in_near;
; 3478 : 
; 3479 :    if (w == 1) {
; 3480 :       // if only one sample, can't do any interpolation
; 3481 :       out[0] = out[1] = input[0];
; 3482 :       return out;
; 3483 :    }
; 3484 : 
; 3485 :    out[0] = input[0];
; 3486 :    out[1] = stbi__div4(input[0]*3 + input[1] + 2);
; 3487 :    for (i=1; i < w-1; ++i) {
; 3488 :       int n = 3*input[i]+2;
; 3489 :       out[i*2+0] = stbi__div4(n+input[i-1]);
; 3490 :       out[i*2+1] = stbi__div4(n+input[i+1]);
; 3491 :    }
; 3492 :    out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
; 3493 :    out[i*2+1] = input[w-1];
; 3494 : 
; 3495 :    STBI_NOTUSED(in_far);
; 3496 :    STBI_NOTUSED(hs);
; 3497 : 
; 3498 :    return out;
; 3499 : }
; 3500 : 
; 3501 : #define stbi__div16(x) ((stbi_uc) ((x) >> 4))
; 3502 : 
; 3503 : static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3504 : {
; 3505 :    // need to generate 2x2 samples for every one in input
; 3506 :    int i,t0,t1;
; 3507 :    if (w == 1) {
; 3508 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
; 3509 :       return out;
; 3510 :    }
; 3511 : 
; 3512 :    t1 = 3*in_near[0] + in_far[0];
; 3513 :    out[0] = stbi__div4(t1+2);
; 3514 :    for (i=1; i < w; ++i) {
; 3515 :       t0 = t1;
; 3516 :       t1 = 3*in_near[i]+in_far[i];
; 3517 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
; 3518 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
; 3519 :    }
; 3520 :    out[w*2-1] = stbi__div4(t1+2);
; 3521 : 
; 3522 :    STBI_NOTUSED(hs);
; 3523 : 
; 3524 :    return out;
; 3525 : }
; 3526 : 
; 3527 : #if defined(STBI_SSE2) || defined(STBI_NEON)
; 3528 : static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3529 : {
; 3530 :    // need to generate 2x2 samples for every one in input
; 3531 :    int i=0,t0,t1;
; 3532 : 
; 3533 :    if (w == 1) {
; 3534 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
; 3535 :       return out;
; 3536 :    }
; 3537 : 
; 3538 :    t1 = 3*in_near[0] + in_far[0];
; 3539 :    // process groups of 8 pixels for as long as we can.
; 3540 :    // note we can't handle the last pixel in a row in this loop
; 3541 :    // because we need to handle the filter boundary conditions.
; 3542 :    for (; i < ((w-1) & ~7); i += 8) {
; 3543 : #if defined(STBI_SSE2)
; 3544 :       // load and perform the vertical filtering pass
; 3545 :       // this uses 3*x + y = 4*x + (y - x)
; 3546 :       __m128i zero  = _mm_setzero_si128();
; 3547 :       __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
; 3548 :       __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
; 3549 :       __m128i farw  = _mm_unpacklo_epi8(farb, zero);
; 3550 :       __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
; 3551 :       __m128i diff  = _mm_sub_epi16(farw, nearw);
; 3552 :       __m128i nears = _mm_slli_epi16(nearw, 2);
; 3553 :       __m128i curr  = _mm_add_epi16(nears, diff); // current row
; 3554 : 
; 3555 :       // horizontal filter works the same based on shifted vers of current
; 3556 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3557 :       // insert the previous pixel value (from t1).
; 3558 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3559 :       // of next block of 8 pixels added in.
; 3560 :       __m128i prv0 = _mm_slli_si128(curr, 2);
; 3561 :       __m128i nxt0 = _mm_srli_si128(curr, 2);
; 3562 :       __m128i prev = _mm_insert_epi16(prv0, t1, 0);
; 3563 :       __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);
; 3564 : 
; 3565 :       // horizontal filter, polyphase implementation since it's convenient:
; 3566 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3567 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3568 :       // note the shared term.
; 3569 :       __m128i bias  = _mm_set1_epi16(8);
; 3570 :       __m128i curs = _mm_slli_epi16(curr, 2);
; 3571 :       __m128i prvd = _mm_sub_epi16(prev, curr);
; 3572 :       __m128i nxtd = _mm_sub_epi16(next, curr);
; 3573 :       __m128i curb = _mm_add_epi16(curs, bias);
; 3574 :       __m128i even = _mm_add_epi16(prvd, curb);
; 3575 :       __m128i odd  = _mm_add_epi16(nxtd, curb);
; 3576 : 
; 3577 :       // interleave even and odd pixels, then undo scaling.
; 3578 :       __m128i int0 = _mm_unpacklo_epi16(even, odd);
; 3579 :       __m128i int1 = _mm_unpackhi_epi16(even, odd);
; 3580 :       __m128i de0  = _mm_srli_epi16(int0, 4);
; 3581 :       __m128i de1  = _mm_srli_epi16(int1, 4);
; 3582 : 
; 3583 :       // pack and write output
; 3584 :       __m128i outv = _mm_packus_epi16(de0, de1);
; 3585 :       _mm_storeu_si128((__m128i *) (out + i*2), outv);
; 3586 : #elif defined(STBI_NEON)
; 3587 :       // load and perform the vertical filtering pass
; 3588 :       // this uses 3*x + y = 4*x + (y - x)
; 3589 :       uint8x8_t farb  = vld1_u8(in_far + i);
; 3590 :       uint8x8_t nearb = vld1_u8(in_near + i);
; 3591 :       int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
; 3592 :       int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
; 3593 :       int16x8_t curr  = vaddq_s16(nears, diff); // current row
; 3594 : 
; 3595 :       // horizontal filter works the same based on shifted vers of current
; 3596 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3597 :       // insert the previous pixel value (from t1).
; 3598 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3599 :       // of next block of 8 pixels added in.
; 3600 :       int16x8_t prv0 = vextq_s16(curr, curr, 7);
; 3601 :       int16x8_t nxt0 = vextq_s16(curr, curr, 1);
; 3602 :       int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
; 3603 :       int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);
; 3604 : 
; 3605 :       // horizontal filter, polyphase implementation since it's convenient:
; 3606 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3607 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3608 :       // note the shared term.
; 3609 :       int16x8_t curs = vshlq_n_s16(curr, 2);
; 3610 :       int16x8_t prvd = vsubq_s16(prev, curr);
; 3611 :       int16x8_t nxtd = vsubq_s16(next, curr);
; 3612 :       int16x8_t even = vaddq_s16(curs, prvd);
; 3613 :       int16x8_t odd  = vaddq_s16(curs, nxtd);
; 3614 : 
; 3615 :       // undo scaling and round, then store with even/odd phases interleaved
; 3616 :       uint8x8x2_t o;
; 3617 :       o.val[0] = vqrshrun_n_s16(even, 4);
; 3618 :       o.val[1] = vqrshrun_n_s16(odd,  4);
; 3619 :       vst2_u8(out + i*2, o);
; 3620 : #endif
; 3621 : 
; 3622 :       // "previous" value for next iter
; 3623 :       t1 = 3*in_near[i+7] + in_far[i+7];
; 3624 :    }
; 3625 : 
; 3626 :    t0 = t1;
; 3627 :    t1 = 3*in_near[i] + in_far[i];
; 3628 :    out[i*2] = stbi__div16(3*t1 + t0 + 8);
; 3629 : 
; 3630 :    for (++i; i < w; ++i) {
; 3631 :       t0 = t1;
; 3632 :       t1 = 3*in_near[i]+in_far[i];
; 3633 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
; 3634 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
; 3635 :    }
; 3636 :    out[w*2-1] = stbi__div4(t1+2);
; 3637 : 
; 3638 :    STBI_NOTUSED(hs);
; 3639 : 
; 3640 :    return out;
; 3641 : }
; 3642 : #endif
; 3643 : 
; 3644 : static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3645 : {
; 3646 :    // resample with nearest-neighbor
; 3647 :    int i,j;
; 3648 :    STBI_NOTUSED(in_far);
; 3649 :    for (i=0; i < w; ++i)
; 3650 :       for (j=0; j < hs; ++j)
; 3651 :          out[i*hs+j] = in_near[i];
; 3652 :    return out;
; 3653 : }
; 3654 : 
; 3655 : // this is a reduced-precision calculation of YCbCr-to-RGB introduced
; 3656 : // to make sure the code produces the same results in both SIMD and scalar
; 3657 : #define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
; 3658 : static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
; 3659 : {
; 3660 :    int i;
; 3661 :    for (i=0; i < count; ++i) {
; 3662 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding
; 3663 :       int r,g,b;
; 3664 :       int cr = pcr[i] - 128;
; 3665 :       int cb = pcb[i] - 128;
; 3666 :       r = y_fixed +  cr* stbi__float2fixed(1.40200f);
; 3667 :       g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
; 3668 :       b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
; 3669 :       r >>= 20;
; 3670 :       g >>= 20;
; 3671 :       b >>= 20;
; 3672 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
; 3673 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
; 3674 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
; 3675 :       out[0] = (stbi_uc)r;
; 3676 :       out[1] = (stbi_uc)g;
; 3677 :       out[2] = (stbi_uc)b;
; 3678 :       out[3] = 255;
; 3679 :       out += step;
; 3680 :    }
; 3681 : }
; 3682 : 
; 3683 : #if defined(STBI_SSE2) || defined(STBI_NEON)
; 3684 : static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
; 3685 : {
; 3686 :    int i = 0;
; 3687 : 
; 3688 : #ifdef STBI_SSE2
; 3689 :    // step == 3 is pretty ugly on the final interleave, and i'm not convinced
; 3690 :    // it's useful in practice (you wouldn't use it for textures, for example).
; 3691 :    // so just accelerate step == 4 case.
; 3692 :    if (step == 4) {
; 3693 :       // this is a fairly straightforward implementation and not super-optimized.
; 3694 :       __m128i signflip  = _mm_set1_epi8(-0x80);
; 3695 :       __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3696 :       __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3697 :       __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3698 :       __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3699 :       __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
; 3700 :       __m128i xw = _mm_set1_epi16(255); // alpha channel
; 3701 : 
; 3702 :       for (; i+7 < count; i += 8) {
; 3703 :          // load
; 3704 :          __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
; 3705 :          __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
; 3706 :          __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
; 3707 :          __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
; 3708 :          __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128
; 3709 : 
; 3710 :          // unpack to short (and left-shift cr, cb by 8)
; 3711 :          __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
; 3712 :          __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
; 3713 :          __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);
; 3714 : 
; 3715 :          // color transform
; 3716 :          __m128i yws = _mm_srli_epi16(yw, 4);
; 3717 :          __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
; 3718 :          __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
; 3719 :          __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
; 3720 :          __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
; 3721 :          __m128i rws = _mm_add_epi16(cr0, yws);
; 3722 :          __m128i gwt = _mm_add_epi16(cb0, yws);
; 3723 :          __m128i bws = _mm_add_epi16(yws, cb1);
; 3724 :          __m128i gws = _mm_add_epi16(gwt, cr1);
; 3725 : 
; 3726 :          // descale
; 3727 :          __m128i rw = _mm_srai_epi16(rws, 4);
; 3728 :          __m128i bw = _mm_srai_epi16(bws, 4);
; 3729 :          __m128i gw = _mm_srai_epi16(gws, 4);
; 3730 : 
; 3731 :          // back to byte, set up for transpose
; 3732 :          __m128i brb = _mm_packus_epi16(rw, bw);
; 3733 :          __m128i gxb = _mm_packus_epi16(gw, xw);
; 3734 : 
; 3735 :          // transpose to interleave channels
; 3736 :          __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
; 3737 :          __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
; 3738 :          __m128i o0 = _mm_unpacklo_epi16(t0, t1);
; 3739 :          __m128i o1 = _mm_unpackhi_epi16(t0, t1);
; 3740 : 
; 3741 :          // store
; 3742 :          _mm_storeu_si128((__m128i *) (out + 0), o0);
; 3743 :          _mm_storeu_si128((__m128i *) (out + 16), o1);
; 3744 :          out += 32;
; 3745 :       }
; 3746 :    }
; 3747 : #endif
; 3748 : 
; 3749 : #ifdef STBI_NEON
; 3750 :    // in this version, step=3 support would be easy to add. but is there demand?
; 3751 :    if (step == 4) {
; 3752 :       // this is a fairly straightforward implementation and not super-optimized.
; 3753 :       uint8x8_t signflip = vdup_n_u8(0x80);
; 3754 :       int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3755 :       int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3756 :       int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3757 :       int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3758 : 
; 3759 :       for (; i+7 < count; i += 8) {
; 3760 :          // load
; 3761 :          uint8x8_t y_bytes  = vld1_u8(y + i);
; 3762 :          uint8x8_t cr_bytes = vld1_u8(pcr + i);
; 3763 :          uint8x8_t cb_bytes = vld1_u8(pcb + i);
; 3764 :          int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
; 3765 :          int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
; 3766 : 
; 3767 :          // expand to s16
; 3768 :          int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
; 3769 :          int16x8_t crw = vshll_n_s8(cr_biased, 7);
; 3770 :          int16x8_t cbw = vshll_n_s8(cb_biased, 7);
; 3771 : 
; 3772 :          // color transform
; 3773 :          int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
; 3774 :          int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
; 3775 :          int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
; 3776 :          int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
; 3777 :          int16x8_t rws = vaddq_s16(yws, cr0);
; 3778 :          int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
; 3779 :          int16x8_t bws = vaddq_s16(yws, cb1);
; 3780 : 
; 3781 :          // undo scaling, round, convert to byte
; 3782 :          uint8x8x4_t o;
; 3783 :          o.val[0] = vqrshrun_n_s16(rws, 4);
; 3784 :          o.val[1] = vqrshrun_n_s16(gws, 4);
; 3785 :          o.val[2] = vqrshrun_n_s16(bws, 4);
; 3786 :          o.val[3] = vdup_n_u8(255);
; 3787 : 
; 3788 :          // store, interleaving r/g/b/a
; 3789 :          vst4_u8(out, o);
; 3790 :          out += 8*4;
; 3791 :       }
; 3792 :    }
; 3793 : #endif
; 3794 : 
; 3795 :    for (; i < count; ++i) {
; 3796 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding
; 3797 :       int r,g,b;
; 3798 :       int cr = pcr[i] - 128;
; 3799 :       int cb = pcb[i] - 128;
; 3800 :       r = y_fixed + cr* stbi__float2fixed(1.40200f);
; 3801 :       g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
; 3802 :       b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
; 3803 :       r >>= 20;
; 3804 :       g >>= 20;
; 3805 :       b >>= 20;
; 3806 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
; 3807 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
; 3808 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
; 3809 :       out[0] = (stbi_uc)r;
; 3810 :       out[1] = (stbi_uc)g;
; 3811 :       out[2] = (stbi_uc)b;
; 3812 :       out[3] = 255;
; 3813 :       out += step;
; 3814 :    }
; 3815 : }
; 3816 : #endif
; 3817 : 
; 3818 : // set up the kernels
; 3819 : static void stbi__setup_jpeg(stbi__jpeg *j)
; 3820 : {
; 3821 :    j->idct_block_kernel = stbi__idct_block;
; 3822 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
; 3823 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;
; 3824 : 
; 3825 : #ifdef STBI_SSE2
; 3826 :    if (stbi__sse2_available()) {
; 3827 :       j->idct_block_kernel = stbi__idct_simd;
; 3828 :       j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3829 :       j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3830 :    }
; 3831 : #endif
; 3832 : 
; 3833 : #ifdef STBI_NEON
; 3834 :    j->idct_block_kernel = stbi__idct_simd;
; 3835 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3836 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3837 : #endif
; 3838 : }
; 3839 : 
; 3840 : // clean up the temporary component buffers
; 3841 : static void stbi__cleanup_jpeg(stbi__jpeg *j)
; 3842 : {
; 3843 :    stbi__free_jpeg_components(j, j->s->img_n, 0);
; 3844 : }
; 3845 : 
; 3846 : typedef struct
; 3847 : {
; 3848 :    resample_row_func resample;
; 3849 :    stbi_uc *line0,*line1;
; 3850 :    int hs,vs;   // expansion factor in each axis
; 3851 :    int w_lores; // horizontal pixels pre-expansion
; 3852 :    int ystep;   // how far through vertical expansion we are
; 3853 :    int ypos;    // which pre-expansion row we're on
; 3854 : } stbi__resample;
; 3855 : 
; 3856 : // fast 0..255 * 0..255 => 0..255 rounded multiplication
; 3857 : static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
; 3858 : {
; 3859 :    unsigned int t = x*y + 128;
; 3860 :    return (stbi_uc) ((t + (t >>8)) >> 8);
; 3861 : }
; 3862 : 
; 3863 : static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
; 3864 : {
; 3865 :    int n, decode_n, is_rgb;
; 3866 :    z->s->img_n = 0; // make stbi__cleanup_jpeg safe
; 3867 : 
; 3868 :    // validate req_comp
; 3869 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
; 3870 : 
; 3871 :    // load a jpeg image from whichever source, but leave in YCbCr format
; 3872 :    if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }
; 3873 : 
; 3874 :    // determine actual number of components to generate
; 3875 :    n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;
; 3876 : 
; 3877 :    is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));
; 3878 : 
; 3879 :    if (z->s->img_n == 3 && n < 3 && !is_rgb)
; 3880 :       decode_n = 1;
; 3881 :    else
; 3882 :       decode_n = z->s->img_n;
; 3883 : 
; 3884 :    // nothing to do if no components requested; check this now to avoid
; 3885 :    // accessing uninitialized coutput[0] later
; 3886 :    if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }
; 3887 : 
; 3888 :    // resample and color-convert
; 3889 :    {
; 3890 :       int k;
; 3891 :       unsigned int i,j;
; 3892 :       stbi_uc *output;
; 3893 :       stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };
; 3894 : 
; 3895 :       stbi__resample res_comp[4];
; 3896 : 
; 3897 :       for (k=0; k < decode_n; ++k) {
; 3898 :          stbi__resample *r = &res_comp[k];
; 3899 : 
; 3900 :          // allocate line buffer big enough for upsampling off the edges
; 3901 :          // with upsample factor of 4
; 3902 :          z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
; 3903 :          if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
; 3904 : 
; 3905 :          r->hs      = z->img_h_max / z->img_comp[k].h;
; 3906 :          r->vs      = z->img_v_max / z->img_comp[k].v;
; 3907 :          r->ystep   = r->vs >> 1;
; 3908 :          r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
; 3909 :          r->ypos    = 0;
; 3910 :          r->line0   = r->line1 = z->img_comp[k].data;
; 3911 : 
; 3912 :          if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
; 3913 :          else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
; 3914 :          else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
; 3915 :          else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
; 3916 :          else                               r->resample = stbi__resample_row_generic;
; 3917 :       }
; 3918 : 
; 3919 :       // can't error after this so, this is safe
; 3920 :       output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
; 3921 :       if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
; 3922 : 
; 3923 :       // now go ahead and resample
; 3924 :       for (j=0; j < z->s->img_y; ++j) {
; 3925 :          stbi_uc *out = output + n * z->s->img_x * j;
; 3926 :          for (k=0; k < decode_n; ++k) {
; 3927 :             stbi__resample *r = &res_comp[k];
; 3928 :             int y_bot = r->ystep >= (r->vs >> 1);
; 3929 :             coutput[k] = r->resample(z->img_comp[k].linebuf,
; 3930 :                                      y_bot ? r->line1 : r->line0,
; 3931 :                                      y_bot ? r->line0 : r->line1,
; 3932 :                                      r->w_lores, r->hs);
; 3933 :             if (++r->ystep >= r->vs) {
; 3934 :                r->ystep = 0;
; 3935 :                r->line0 = r->line1;
; 3936 :                if (++r->ypos < z->img_comp[k].y)
; 3937 :                   r->line1 += z->img_comp[k].w2;
; 3938 :             }
; 3939 :          }
; 3940 :          if (n >= 3) {
; 3941 :             stbi_uc *y = coutput[0];
; 3942 :             if (z->s->img_n == 3) {
; 3943 :                if (is_rgb) {
; 3944 :                   for (i=0; i < z->s->img_x; ++i) {
; 3945 :                      out[0] = y[i];
; 3946 :                      out[1] = coutput[1][i];
; 3947 :                      out[2] = coutput[2][i];
; 3948 :                      out[3] = 255;
; 3949 :                      out += n;
; 3950 :                   }
; 3951 :                } else {
; 3952 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3953 :                }
; 3954 :             } else if (z->s->img_n == 4) {
; 3955 :                if (z->app14_color_transform == 0) { // CMYK
; 3956 :                   for (i=0; i < z->s->img_x; ++i) {
; 3957 :                      stbi_uc m = coutput[3][i];
; 3958 :                      out[0] = stbi__blinn_8x8(coutput[0][i], m);
; 3959 :                      out[1] = stbi__blinn_8x8(coutput[1][i], m);
; 3960 :                      out[2] = stbi__blinn_8x8(coutput[2][i], m);
; 3961 :                      out[3] = 255;
; 3962 :                      out += n;
; 3963 :                   }
; 3964 :                } else if (z->app14_color_transform == 2) { // YCCK
; 3965 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3966 :                   for (i=0; i < z->s->img_x; ++i) {
; 3967 :                      stbi_uc m = coutput[3][i];
; 3968 :                      out[0] = stbi__blinn_8x8(255 - out[0], m);
; 3969 :                      out[1] = stbi__blinn_8x8(255 - out[1], m);
; 3970 :                      out[2] = stbi__blinn_8x8(255 - out[2], m);
; 3971 :                      out += n;
; 3972 :                   }
; 3973 :                } else { // YCbCr + alpha?  Ignore the fourth channel for now
; 3974 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3975 :                }
; 3976 :             } else
; 3977 :                for (i=0; i < z->s->img_x; ++i) {
; 3978 :                   out[0] = out[1] = out[2] = y[i];
; 3979 :                   out[3] = 255; // not used if n==3
; 3980 :                   out += n;
; 3981 :                }
; 3982 :          } else {
; 3983 :             if (is_rgb) {
; 3984 :                if (n == 1)
; 3985 :                   for (i=0; i < z->s->img_x; ++i)
; 3986 :                      *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
; 3987 :                else {
; 3988 :                   for (i=0; i < z->s->img_x; ++i, out += 2) {
; 3989 :                      out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
; 3990 :                      out[1] = 255;
; 3991 :                   }
; 3992 :                }
; 3993 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
; 3994 :                for (i=0; i < z->s->img_x; ++i) {
; 3995 :                   stbi_uc m = coutput[3][i];
; 3996 :                   stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
; 3997 :                   stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
; 3998 :                   stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
; 3999 :                   out[0] = stbi__compute_y(r, g, b);
; 4000 :                   out[1] = 255;
; 4001 :                   out += n;
; 4002 :                }
; 4003 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
; 4004 :                for (i=0; i < z->s->img_x; ++i) {
; 4005 :                   out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
; 4006 :                   out[1] = 255;
; 4007 :                   out += n;
; 4008 :                }
; 4009 :             } else {
; 4010 :                stbi_uc *y = coutput[0];
; 4011 :                if (n == 1)
; 4012 :                   for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
; 4013 :                else
; 4014 :                   for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
; 4015 :             }
; 4016 :          }
; 4017 :       }
; 4018 :       stbi__cleanup_jpeg(z);
; 4019 :       *out_x = z->s->img_x;
; 4020 :       *out_y = z->s->img_y;
; 4021 :       if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
; 4022 :       return output;
; 4023 :    }
; 4024 : }
; 4025 : 
; 4026 : static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 4027 : {
; 4028 :    unsigned char* result;
; 4029 :    stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
; 4030 :    if (!j) return stbi__errpuc("outofmem", "Out of memory");
; 4031 :    memset(j, 0, sizeof(stbi__jpeg));
; 4032 :    STBI_NOTUSED(ri);
; 4033 :    j->s = s;
; 4034 :    stbi__setup_jpeg(j);
; 4035 :    result = load_jpeg_image(j, x,y,comp,req_comp);
; 4036 :    STBI_FREE(j);
; 4037 :    return result;
; 4038 : }
; 4039 : 
; 4040 : static int stbi__jpeg_test(stbi__context *s)
; 4041 : {
; 4042 :    int r;
; 4043 :    stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
; 4044 :    if (!j) return stbi__err("outofmem", "Out of memory");
; 4045 :    memset(j, 0, sizeof(stbi__jpeg));
; 4046 :    j->s = s;
; 4047 :    stbi__setup_jpeg(j);
; 4048 :    r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
; 4049 :    stbi__rewind(s);
; 4050 :    STBI_FREE(j);
; 4051 :    return r;
; 4052 : }
; 4053 : 
; 4054 : static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
; 4055 : {
; 4056 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
; 4057 :       stbi__rewind( j->s );
; 4058 :       return 0;
; 4059 :    }
; 4060 :    if (x) *x = j->s->img_x;
; 4061 :    if (y) *y = j->s->img_y;
; 4062 :    if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
; 4063 :    return 1;
; 4064 : }
; 4065 : 
; 4066 : static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
; 4067 : {
; 4068 :    int result;
; 4069 :    stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
; 4070 :    if (!j) return stbi__err("outofmem", "Out of memory");
; 4071 :    memset(j, 0, sizeof(stbi__jpeg));
; 4072 :    j->s = s;
; 4073 :    result = stbi__jpeg_info_raw(j, x, y, comp);
; 4074 :    STBI_FREE(j);
; 4075 :    return result;
; 4076 : }
; 4077 : #endif
; 4078 : 
; 4079 : // public domain zlib decode    v0.2  Sean Barrett 2006-11-18
; 4080 : //    simple implementation
; 4081 : //      - all input must be provided in an upfront buffer
; 4082 : //      - all output is written to a single output buffer (can malloc/realloc)
; 4083 : //    performance
; 4084 : //      - fast huffman
; 4085 : 
; 4086 : #ifndef STBI_NO_ZLIB
; 4087 : 
; 4088 : // fast-way is faster to check than jpeg huffman, but slow way is slower
; 4089 : #define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
; 4090 : #define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
; 4091 : #define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet
; 4092 : 
; 4093 : // zlib-style huffman encoding
; 4094 : // (jpegs packs from left, zlib from right, so can't share code)
; 4095 : typedef struct
; 4096 : {
; 4097 :    stbi__uint16 fast[1 << STBI__ZFAST_BITS];
; 4098 :    stbi__uint16 firstcode[16];
; 4099 :    int maxcode[17];
; 4100 :    stbi__uint16 firstsymbol[16];
; 4101 :    stbi_uc  size[STBI__ZNSYMS];
; 4102 :    stbi__uint16 value[STBI__ZNSYMS];
; 4103 : } stbi__zhuffman;
; 4104 : 
; 4105 : stbi_inline static int stbi__bitreverse16(int n)
; 4106 : {
; 4107 :   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
; 4108 :   n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
; 4109 :   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
; 4110 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
; 4111 :   return n;
; 4112 : }
; 4113 : 
; 4114 : stbi_inline static int stbi__bit_reverse(int v, int bits)
; 4115 : {
; 4116 :    STBI_ASSERT(bits <= 16);
; 4117 :    // to bit reverse n bits, reverse 16 and shift
; 4118 :    // e.g. 11 bits, bit reverse and shift away 5
; 4119 :    return stbi__bitreverse16(v) >> (16-bits);
; 4120 : }
; 4121 : 
; 4122 : static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
; 4123 : {
; 4124 :    int i,k=0;
; 4125 :    int code, next_code[16], sizes[17];
; 4126 : 
; 4127 :    // DEFLATE spec for generating codes
; 4128 :    memset(sizes, 0, sizeof(sizes));
; 4129 :    memset(z->fast, 0, sizeof(z->fast));
; 4130 :    for (i=0; i < num; ++i)
; 4131 :       ++sizes[sizelist[i]];
; 4132 :    sizes[0] = 0;
; 4133 :    for (i=1; i < 16; ++i)
; 4134 :       if (sizes[i] > (1 << i))
; 4135 :          return stbi__err("bad sizes", "Corrupt PNG");
; 4136 :    code = 0;
; 4137 :    for (i=1; i < 16; ++i) {
; 4138 :       next_code[i] = code;
; 4139 :       z->firstcode[i] = (stbi__uint16) code;
; 4140 :       z->firstsymbol[i] = (stbi__uint16) k;
; 4141 :       code = (code + sizes[i]);
; 4142 :       if (sizes[i])
; 4143 :          if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
; 4144 :       z->maxcode[i] = code << (16-i); // preshift for inner loop
; 4145 :       code <<= 1;
; 4146 :       k += sizes[i];
; 4147 :    }
; 4148 :    z->maxcode[16] = 0x10000; // sentinel
; 4149 :    for (i=0; i < num; ++i) {
; 4150 :       int s = sizelist[i];
; 4151 :       if (s) {
; 4152 :          int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
; 4153 :          stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
; 4154 :          z->size [c] = (stbi_uc     ) s;
; 4155 :          z->value[c] = (stbi__uint16) i;
; 4156 :          if (s <= STBI__ZFAST_BITS) {
; 4157 :             int j = stbi__bit_reverse(next_code[s],s);
; 4158 :             while (j < (1 << STBI__ZFAST_BITS)) {
; 4159 :                z->fast[j] = fastv;
; 4160 :                j += (1 << s);
; 4161 :             }
; 4162 :          }
; 4163 :          ++next_code[s];
; 4164 :       }
; 4165 :    }
; 4166 :    return 1;
; 4167 : }
; 4168 : 
; 4169 : // zlib-from-memory implementation for PNG reading
; 4170 : //    because PNG allows splitting the zlib stream arbitrarily,
; 4171 : //    and it's annoying structurally to have PNG call ZLIB call PNG,
; 4172 : //    we require PNG read all the IDATs and combine them into a single
; 4173 : //    memory buffer
; 4174 : 
; 4175 : typedef struct
; 4176 : {
; 4177 :    stbi_uc *zbuffer, *zbuffer_end;
; 4178 :    int num_bits;
; 4179 :    stbi__uint32 code_buffer;
; 4180 : 
; 4181 :    char *zout;
; 4182 :    char *zout_start;
; 4183 :    char *zout_end;
; 4184 :    int   z_expandable;
; 4185 : 
; 4186 :    stbi__zhuffman z_length, z_distance;
; 4187 : } stbi__zbuf;
; 4188 : 
; 4189 : stbi_inline static int stbi__zeof(stbi__zbuf *z)
; 4190 : {
; 4191 :    return (z->zbuffer >= z->zbuffer_end);
; 4192 : }
; 4193 : 
; 4194 : stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
; 4195 : {
; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;
; 4197 : }
; 4198 : 
; 4199 : static void stbi__fill_bits(stbi__zbuf *z)
; 4200 : {
; 4201 :    do {
; 4202 :       if (z->code_buffer >= (1U << z->num_bits)) {
; 4203 :         z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
; 4204 :         return;
; 4205 :       }
; 4206 :       z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
; 4207 :       z->num_bits += 8;
; 4208 :    } while (z->num_bits <= 24);
; 4209 : }
; 4210 : 
; 4211 : stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
; 4212 : {
; 4213 :    unsigned int k;
; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);
; 4215 :    k = z->code_buffer & ((1 << n) - 1);
; 4216 :    z->code_buffer >>= n;
; 4217 :    z->num_bits -= n;
; 4218 :    return k;
; 4219 : }
; 4220 : 
; 4221 : static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
; 4222 : {
; 4223 :    int b,s,k;
; 4224 :    // not resolved by fast table, so compute it the slow way
; 4225 :    // use jpeg approach, which requires MSbits at top
; 4226 :    k = stbi__bit_reverse(a->code_buffer, 16);
; 4227 :    for (s=STBI__ZFAST_BITS+1; ; ++s)
; 4228 :       if (k < z->maxcode[s])
; 4229 :          break;
; 4230 :    if (s >= 16) return -1; // invalid code!
; 4231 :    // code size is s, so:
; 4232 :    b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
; 4233 :    if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
; 4234 :    if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
; 4235 :    a->code_buffer >>= s;
; 4236 :    a->num_bits -= s;
; 4237 :    return z->value[b];
; 4238 : }
; 4239 : 
; 4240 : stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
; 4241 : {
; 4242 :    int b,s;
; 4243 :    if (a->num_bits < 16) {
; 4244 :       if (stbi__zeof(a)) {
; 4245 :          return -1;   /* report error for unexpected end of data. */
; 4246 :       }
; 4247 :       stbi__fill_bits(a);
; 4248 :    }
; 4249 :    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
; 4250 :    if (b) {
; 4251 :       s = b >> 9;
; 4252 :       a->code_buffer >>= s;
; 4253 :       a->num_bits -= s;
; 4254 :       return b & 511;
; 4255 :    }
; 4256 :    return stbi__zhuffman_decode_slowpath(a, z);
; 4257 : }
; 4258 : 
; 4259 : static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
; 4260 : {
; 4261 :    char *q;
; 4262 :    unsigned int cur, limit, old_limit;
; 4263 :    z->zout = zout;
; 4264 :    if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
; 4265 :    cur   = (unsigned int) (z->zout - z->zout_start);
; 4266 :    limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
; 4267 :    if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");
; 4268 :    while (cur + n > limit) {
; 4269 :       if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");
; 4270 :       limit *= 2;
; 4271 :    }
; 4272 :    q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
; 4273 :    STBI_NOTUSED(old_limit);
; 4274 :    if (q == NULL) return stbi__err("outofmem", "Out of memory");
; 4275 :    z->zout_start = q;
; 4276 :    z->zout       = q + cur;
; 4277 :    z->zout_end   = q + limit;
; 4278 :    return 1;
; 4279 : }
; 4280 : 
; 4281 : static const int stbi__zlength_base[31] = {
; 4282 :    3,4,5,6,7,8,9,10,11,13,
; 4283 :    15,17,19,23,27,31,35,43,51,59,
; 4284 :    67,83,99,115,131,163,195,227,258,0,0 };
; 4285 : 
; 4286 : static const int stbi__zlength_extra[31]=
; 4287 : { 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };
; 4288 : 
; 4289 : static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
; 4290 : 257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};
; 4291 : 
; 4292 : static const int stbi__zdist_extra[32] =
; 4293 : { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
; 4294 : 
; 4295 : static int stbi__parse_huffman_block(stbi__zbuf *a)
; 4296 : {
; 4297 :    char *zout = a->zout;
; 4298 :    for(;;) {
; 4299 :       int z = stbi__zhuffman_decode(a, &a->z_length);
; 4300 :       if (z < 256) {
; 4301 :          if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
; 4302 :          if (zout >= a->zout_end) {
; 4303 :             if (!stbi__zexpand(a, zout, 1)) return 0;
; 4304 :             zout = a->zout;
; 4305 :          }
; 4306 :          *zout++ = (char) z;
; 4307 :       } else {
; 4308 :          stbi_uc *p;
; 4309 :          int len,dist;
; 4310 :          if (z == 256) {
; 4311 :             a->zout = zout;
; 4312 :             return 1;
; 4313 :          }
; 4314 :          if (z >= 286) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, length codes 286 and 287 must not appear in compressed data
; 4315 :          z -= 257;
; 4316 :          len = stbi__zlength_base[z];
; 4317 :          if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
; 4318 :          z = stbi__zhuffman_decode(a, &a->z_distance);
; 4319 :          if (z < 0 || z >= 30) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data
; 4320 :          dist = stbi__zdist_base[z];
; 4321 :          if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
; 4322 :          if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
; 4323 :          if (zout + len > a->zout_end) {
; 4324 :             if (!stbi__zexpand(a, zout, len)) return 0;
; 4325 :             zout = a->zout;
; 4326 :          }
; 4327 :          p = (stbi_uc *) (zout - dist);
; 4328 :          if (dist == 1) { // run of one byte; common in images.
; 4329 :             stbi_uc v = *p;
; 4330 :             if (len) { do *zout++ = v; while (--len); }
; 4331 :          } else {
; 4332 :             if (len) { do *zout++ = *p++; while (--len); }
; 4333 :          }
; 4334 :       }
; 4335 :    }
; 4336 : }
; 4337 : 
; 4338 : static int stbi__compute_huffman_codes(stbi__zbuf *a)
; 4339 : {
; 4340 :    static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
; 4341 :    stbi__zhuffman z_codelength;
; 4342 :    stbi_uc lencodes[286+32+137];//padding for maximum single op
; 4343 :    stbi_uc codelength_sizes[19];
; 4344 :    int i,n;
; 4345 : 
; 4346 :    int hlit  = stbi__zreceive(a,5) + 257;
; 4347 :    int hdist = stbi__zreceive(a,5) + 1;
; 4348 :    int hclen = stbi__zreceive(a,4) + 4;
; 4349 :    int ntot  = hlit + hdist;
; 4350 : 
; 4351 :    memset(codelength_sizes, 0, sizeof(codelength_sizes));
; 4352 :    for (i=0; i < hclen; ++i) {
; 4353 :       int s = stbi__zreceive(a,3);
; 4354 :       codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
; 4355 :    }
; 4356 :    if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;
; 4357 : 
; 4358 :    n = 0;
; 4359 :    while (n < ntot) {
; 4360 :       int c = stbi__zhuffman_decode(a, &z_codelength);
; 4361 :       if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
; 4362 :       if (c < 16)
; 4363 :          lencodes[n++] = (stbi_uc) c;
; 4364 :       else {
; 4365 :          stbi_uc fill = 0;
; 4366 :          if (c == 16) {
; 4367 :             c = stbi__zreceive(a,2)+3;
; 4368 :             if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
; 4369 :             fill = lencodes[n-1];
; 4370 :          } else if (c == 17) {
; 4371 :             c = stbi__zreceive(a,3)+3;
; 4372 :          } else if (c == 18) {
; 4373 :             c = stbi__zreceive(a,7)+11;
; 4374 :          } else {
; 4375 :             return stbi__err("bad codelengths", "Corrupt PNG");
; 4376 :          }
; 4377 :          if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
; 4378 :          memset(lencodes+n, fill, c);
; 4379 :          n += c;
; 4380 :       }
; 4381 :    }
; 4382 :    if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");
; 4383 :    if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
; 4384 :    if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
; 4385 :    return 1;
; 4386 : }
; 4387 : 
; 4388 : static int stbi__parse_uncompressed_block(stbi__zbuf *a)
; 4389 : {
; 4390 :    stbi_uc header[4];
; 4391 :    int len,nlen,k;
; 4392 :    if (a->num_bits & 7)
; 4393 :       stbi__zreceive(a, a->num_bits & 7); // discard
; 4394 :    // drain the bit-packed data into header
; 4395 :    k = 0;
; 4396 :    while (a->num_bits > 0) {
; 4397 :       header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
; 4398 :       a->code_buffer >>= 8;
; 4399 :       a->num_bits -= 8;
; 4400 :    }
; 4401 :    if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");
; 4402 :    // now fill header the normal way
; 4403 :    while (k < 4)
; 4404 :       header[k++] = stbi__zget8(a);
; 4405 :    len  = header[1] * 256 + header[0];
; 4406 :    nlen = header[3] * 256 + header[2];
; 4407 :    if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
; 4408 :    if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
; 4409 :    if (a->zout + len > a->zout_end)
; 4410 :       if (!stbi__zexpand(a, a->zout, len)) return 0;
; 4411 :    memcpy(a->zout, a->zbuffer, len);
; 4412 :    a->zbuffer += len;
; 4413 :    a->zout += len;
; 4414 :    return 1;
; 4415 : }
; 4416 : 
; 4417 : static int stbi__parse_zlib_header(stbi__zbuf *a)
; 4418 : {
; 4419 :    int cmf   = stbi__zget8(a);
; 4420 :    int cm    = cmf & 15;
; 4421 :    /* int cinfo = cmf >> 4; */
; 4422 :    int flg   = stbi__zget8(a);
; 4423 :    if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
; 4424 :    if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
; 4425 :    if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
; 4426 :    if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
; 4427 :    // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
; 4428 :    return 1;
; 4429 : }
; 4430 : 
; 4431 : static const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =
; 4432 : {
; 4433 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4434 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4435 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4436 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4437 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4438 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4439 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4440 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4441 :    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
; 4442 : };
; 4443 : static const stbi_uc stbi__zdefault_distance[32] =
; 4444 : {
; 4445 :    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
; 4446 : };
; 4447 : /*
; 4448 : Init algorithm:
; 4449 : {
; 4450 :    int i;   // use <= to match clearly with spec
; 4451 :    for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
; 4452 :    for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
; 4453 :    for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
; 4454 :    for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;
; 4455 : 
; 4456 :    for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
; 4457 : }
; 4458 : */
; 4459 : 
; 4460 : static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
; 4461 : {
; 4462 :    int final, type;
; 4463 :    if (parse_header)
; 4464 :       if (!stbi__parse_zlib_header(a)) return 0;
; 4465 :    a->num_bits = 0;
; 4466 :    a->code_buffer = 0;
; 4467 :    do {
; 4468 :       final = stbi__zreceive(a,1);
; 4469 :       type = stbi__zreceive(a,2);
; 4470 :       if (type == 0) {
; 4471 :          if (!stbi__parse_uncompressed_block(a)) return 0;
; 4472 :       } else if (type == 3) {
; 4473 :          return 0;
; 4474 :       } else {
; 4475 :          if (type == 1) {
; 4476 :             // use fixed code lengths
; 4477 :             if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
; 4478 :             if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
; 4479 :          } else {
; 4480 :             if (!stbi__compute_huffman_codes(a)) return 0;
; 4481 :          }
; 4482 :          if (!stbi__parse_huffman_block(a)) return 0;
; 4483 :       }
; 4484 :    } while (!final);
; 4485 :    return 1;
; 4486 : }
; 4487 : 
; 4488 : static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
; 4489 : {
; 4490 :    a->zout_start = obuf;
; 4491 :    a->zout       = obuf;
; 4492 :    a->zout_end   = obuf + olen;
; 4493 :    a->z_expandable = exp;
; 4494 : 
; 4495 :    return stbi__parse_zlib(a, parse_header);
; 4496 : }
; 4497 : 
; 4498 : STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
; 4499 : {
; 4500 :    stbi__zbuf a;
; 4501 :    char *p = (char *) stbi__malloc(initial_size);
; 4502 :    if (p == NULL) return NULL;
; 4503 :    a.zbuffer = (stbi_uc *) buffer;
; 4504 :    a.zbuffer_end = (stbi_uc *) buffer + len;
; 4505 :    if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
; 4506 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4507 :       return a.zout_start;
; 4508 :    } else {
; 4509 :       STBI_FREE(a.zout_start);
; 4510 :       return NULL;
; 4511 :    }
; 4512 : }
; 4513 : 
; 4514 : STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
; 4515 : {
; 4516 :    return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
; 4517 : }
; 4518 : 
; 4519 : STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
; 4520 : {
; 4521 :    stbi__zbuf a;
; 4522 :    char *p = (char *) stbi__malloc(initial_size);
; 4523 :    if (p == NULL) return NULL;
; 4524 :    a.zbuffer = (stbi_uc *) buffer;
; 4525 :    a.zbuffer_end = (stbi_uc *) buffer + len;
; 4526 :    if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
; 4527 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4528 :       return a.zout_start;
; 4529 :    } else {
; 4530 :       STBI_FREE(a.zout_start);
; 4531 :       return NULL;
; 4532 :    }
; 4533 : }
; 4534 : 
; 4535 : STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
; 4536 : {
; 4537 :    stbi__zbuf a;
; 4538 :    a.zbuffer = (stbi_uc *) ibuffer;
; 4539 :    a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
; 4540 :    if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
; 4541 :       return (int) (a.zout - a.zout_start);
; 4542 :    else
; 4543 :       return -1;
; 4544 : }
; 4545 : 
; 4546 : STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
; 4547 : {
; 4548 :    stbi__zbuf a;
; 4549 :    char *p = (char *) stbi__malloc(16384);
; 4550 :    if (p == NULL) return NULL;
; 4551 :    a.zbuffer = (stbi_uc *) buffer;
; 4552 :    a.zbuffer_end = (stbi_uc *) buffer+len;
; 4553 :    if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
; 4554 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4555 :       return a.zout_start;
; 4556 :    } else {
; 4557 :       STBI_FREE(a.zout_start);
; 4558 :       return NULL;
; 4559 :    }
; 4560 : }
; 4561 : 
; 4562 : STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
; 4563 : {
; 4564 :    stbi__zbuf a;
; 4565 :    a.zbuffer = (stbi_uc *) ibuffer;
; 4566 :    a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
; 4567 :    if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
; 4568 :       return (int) (a.zout - a.zout_start);
; 4569 :    else
; 4570 :       return -1;
; 4571 : }
; 4572 : #endif
; 4573 : 
; 4574 : // public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
; 4575 : //    simple implementation
; 4576 : //      - only 8-bit samples
; 4577 : //      - no CRC checking
; 4578 : //      - allocates lots of intermediate memory
; 4579 : //        - avoids problem of streaming data between subsystems
; 4580 : //        - avoids explicit window management
; 4581 : //    performance
; 4582 : //      - uses stb_zlib, a PD zlib implementation with fast huffman decoding
; 4583 : 
; 4584 : #ifndef STBI_NO_PNG
; 4585 : typedef struct
; 4586 : {
; 4587 :    stbi__uint32 length;
; 4588 :    stbi__uint32 type;
; 4589 : } stbi__pngchunk;
; 4590 : 
; 4591 : static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
; 4592 : {
; 4593 :    stbi__pngchunk c;
; 4594 :    c.length = stbi__get32be(s);
; 4595 :    c.type   = stbi__get32be(s);
; 4596 :    return c;
; 4597 : }
; 4598 : 
; 4599 : static int stbi__check_png_header(stbi__context *s)
; 4600 : {
; 4601 :    static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
; 4602 :    int i;
; 4603 :    for (i=0; i < 8; ++i)
; 4604 :       if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
; 4605 :    return 1;
; 4606 : }
; 4607 : 
; 4608 : typedef struct
; 4609 : {
; 4610 :    stbi__context *s;
; 4611 :    stbi_uc *idata, *expanded, *out;
; 4612 :    int depth;
; 4613 : } stbi__png;
; 4614 : 
; 4615 : 
; 4616 : enum {
; 4617 :    STBI__F_none=0,
; 4618 :    STBI__F_sub=1,
; 4619 :    STBI__F_up=2,
; 4620 :    STBI__F_avg=3,
; 4621 :    STBI__F_paeth=4,
; 4622 :    // synthetic filters used for first scanline to avoid needing a dummy row of 0s
; 4623 :    STBI__F_avg_first,
; 4624 :    STBI__F_paeth_first
; 4625 : };
; 4626 : 
; 4627 : static stbi_uc first_row_filter[5] =
; 4628 : {
; 4629 :    STBI__F_none,
; 4630 :    STBI__F_sub,
; 4631 :    STBI__F_none,
; 4632 :    STBI__F_avg_first,
; 4633 :    STBI__F_paeth_first
; 4634 : };
; 4635 : 
; 4636 : static int stbi__paeth(int a, int b, int c)
; 4637 : {
; 4638 :    int p = a + b - c;
; 4639 :    int pa = abs(p-a);
; 4640 :    int pb = abs(p-b);
; 4641 :    int pc = abs(p-c);
; 4642 :    if (pa <= pb && pa <= pc) return a;
; 4643 :    if (pb <= pc) return b;
; 4644 :    return c;
; 4645 : }
; 4646 : 
; 4647 : static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };
; 4648 : 
; 4649 : // create the png data from post-deflated data
; 4650 : static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
; 4651 : {
; 4652 :    int bytes = (depth == 16? 2 : 1);
; 4653 :    stbi__context *s = a->s;
; 4654 :    stbi__uint32 i,j,stride = x*out_n*bytes;
; 4655 :    stbi__uint32 img_len, img_width_bytes;
; 4656 :    int k;
; 4657 :    int img_n = s->img_n; // copy it into a local for later
; 4658 : 
; 4659 :    int output_bytes = out_n*bytes;
; 4660 :    int filter_bytes = img_n*bytes;
; 4661 :    int width = x;
; 4662 : 
; 4663 :    STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
; 4664 :    a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
; 4665 :    if (!a->out) return stbi__err("outofmem", "Out of memory");
; 4666 : 
; 4667 :    if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
; 4668 :    img_width_bytes = (((img_n * x * depth) + 7) >> 3);
; 4669 :    img_len = (img_width_bytes + 1) * y;
; 4670 : 
; 4671 :    // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
; 4672 :    // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
; 4673 :    // so just check for raw_len < img_len always.
; 4674 :    if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");
; 4675 : 
; 4676 :    for (j=0; j < y; ++j) {
; 4677 :       stbi_uc *cur = a->out + stride*j;
; 4678 :       stbi_uc *prior;
; 4679 :       int filter = *raw++;
; 4680 : 
; 4681 :       if (filter > 4)
; 4682 :          return stbi__err("invalid filter","Corrupt PNG");
; 4683 : 
; 4684 :       if (depth < 8) {
; 4685 :          if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");
; 4686 :          cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
; 4687 :          filter_bytes = 1;
; 4688 :          width = img_width_bytes;
; 4689 :       }
; 4690 :       prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above
; 4691 : 
; 4692 :       // if first row, use special filter that doesn't sample previous row
; 4693 :       if (j == 0) filter = first_row_filter[filter];
; 4694 : 
; 4695 :       // handle first byte explicitly
; 4696 :       for (k=0; k < filter_bytes; ++k) {
; 4697 :          switch (filter) {
; 4698 :             case STBI__F_none       : cur[k] = raw[k]; break;
; 4699 :             case STBI__F_sub        : cur[k] = raw[k]; break;
; 4700 :             case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
; 4701 :             case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;
; 4702 :             case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;
; 4703 :             case STBI__F_avg_first  : cur[k] = raw[k]; break;
; 4704 :             case STBI__F_paeth_first: cur[k] = raw[k]; break;
; 4705 :          }
; 4706 :       }
; 4707 : 
; 4708 :       if (depth == 8) {
; 4709 :          if (img_n != out_n)
; 4710 :             cur[img_n] = 255; // first pixel
; 4711 :          raw += img_n;
; 4712 :          cur += out_n;
; 4713 :          prior += out_n;
; 4714 :       } else if (depth == 16) {
; 4715 :          if (img_n != out_n) {
; 4716 :             cur[filter_bytes]   = 255; // first pixel top byte
; 4717 :             cur[filter_bytes+1] = 255; // first pixel bottom byte
; 4718 :          }
; 4719 :          raw += filter_bytes;
; 4720 :          cur += output_bytes;
; 4721 :          prior += output_bytes;
; 4722 :       } else {
; 4723 :          raw += 1;
; 4724 :          cur += 1;
; 4725 :          prior += 1;
; 4726 :       }
; 4727 : 
; 4728 :       // this is a little gross, so that we don't switch per-pixel or per-component
; 4729 :       if (depth < 8 || img_n == out_n) {
; 4730 :          int nk = (width - 1)*filter_bytes;
; 4731 :          #define STBI__CASE(f) \
; 4732 :              case f:     \
; 4733 :                 for (k=0; k < nk; ++k)
; 4734 :          switch (filter) {
; 4735 :             // "none" filter turns into a memcpy here; make that explicit.
; 4736 :             case STBI__F_none:         memcpy(cur, raw, nk); break;
; 4737 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;
; 4738 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
; 4739 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;
; 4740 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;
; 4741 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;
; 4742 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;
; 4743 :          }
; 4744 :          #undef STBI__CASE
; 4745 :          raw += nk;
; 4746 :       } else {
; 4747 :          STBI_ASSERT(img_n+1 == out_n);
; 4748 :          #define STBI__CASE(f) \
; 4749 :              case f:     \
; 4750 :                 for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
; 4751 :                    for (k=0; k < filter_bytes; ++k)
; 4752 :          switch (filter) {
; 4753 :             STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;
; 4754 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;
; 4755 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
; 4756 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;
; 4757 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;
; 4758 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;
; 4759 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;
; 4760 :          }
; 4761 :          #undef STBI__CASE
; 4762 : 
; 4763 :          // the loop above sets the high byte of the pixels' alpha, but for
; 4764 :          // 16 bit png files we also need the low byte set. we'll do that here.
; 4765 :          if (depth == 16) {
; 4766 :             cur = a->out + stride*j; // start at the beginning of the row again
; 4767 :             for (i=0; i < x; ++i,cur+=output_bytes) {
; 4768 :                cur[filter_bytes+1] = 255;
; 4769 :             }
; 4770 :          }
; 4771 :       }
; 4772 :    }
; 4773 : 
; 4774 :    // we make a separate pass to expand bits to pixels; for performance,
; 4775 :    // this could run two scanlines behind the above code, so it won't
; 4776 :    // intefere with filtering but will still be in the cache.
; 4777 :    if (depth < 8) {
; 4778 :       for (j=0; j < y; ++j) {
; 4779 :          stbi_uc *cur = a->out + stride*j;
; 4780 :          stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
; 4781 :          // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
; 4782 :          // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
; 4783 :          stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range
; 4784 : 
; 4785 :          // note that the final byte might overshoot and write more data than desired.
; 4786 :          // we can allocate enough data that this never writes out of memory, but it
; 4787 :          // could also overwrite the next scanline. can it overwrite non-empty data
; 4788 :          // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
; 4789 :          // so we need to explicitly clamp the final ones
; 4790 : 
; 4791 :          if (depth == 4) {
; 4792 :             for (k=x*img_n; k >= 2; k-=2, ++in) {
; 4793 :                *cur++ = scale * ((*in >> 4)       );
; 4794 :                *cur++ = scale * ((*in     ) & 0x0f);
; 4795 :             }
; 4796 :             if (k > 0) *cur++ = scale * ((*in >> 4)       );
; 4797 :          } else if (depth == 2) {
; 4798 :             for (k=x*img_n; k >= 4; k-=4, ++in) {
; 4799 :                *cur++ = scale * ((*in >> 6)       );
; 4800 :                *cur++ = scale * ((*in >> 4) & 0x03);
; 4801 :                *cur++ = scale * ((*in >> 2) & 0x03);
; 4802 :                *cur++ = scale * ((*in     ) & 0x03);
; 4803 :             }
; 4804 :             if (k > 0) *cur++ = scale * ((*in >> 6)       );
; 4805 :             if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
; 4806 :             if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
; 4807 :          } else if (depth == 1) {
; 4808 :             for (k=x*img_n; k >= 8; k-=8, ++in) {
; 4809 :                *cur++ = scale * ((*in >> 7)       );
; 4810 :                *cur++ = scale * ((*in >> 6) & 0x01);
; 4811 :                *cur++ = scale * ((*in >> 5) & 0x01);
; 4812 :                *cur++ = scale * ((*in >> 4) & 0x01);
; 4813 :                *cur++ = scale * ((*in >> 3) & 0x01);
; 4814 :                *cur++ = scale * ((*in >> 2) & 0x01);
; 4815 :                *cur++ = scale * ((*in >> 1) & 0x01);
; 4816 :                *cur++ = scale * ((*in     ) & 0x01);
; 4817 :             }
; 4818 :             if (k > 0) *cur++ = scale * ((*in >> 7)       );
; 4819 :             if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
; 4820 :             if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
; 4821 :             if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
; 4822 :             if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
; 4823 :             if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
; 4824 :             if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
; 4825 :          }
; 4826 :          if (img_n != out_n) {
; 4827 :             int q;
; 4828 :             // insert alpha = 255
; 4829 :             cur = a->out + stride*j;
; 4830 :             if (img_n == 1) {
; 4831 :                for (q=x-1; q >= 0; --q) {
; 4832 :                   cur[q*2+1] = 255;
; 4833 :                   cur[q*2+0] = cur[q];
; 4834 :                }
; 4835 :             } else {
; 4836 :                STBI_ASSERT(img_n == 3);
; 4837 :                for (q=x-1; q >= 0; --q) {
; 4838 :                   cur[q*4+3] = 255;
; 4839 :                   cur[q*4+2] = cur[q*3+2];
; 4840 :                   cur[q*4+1] = cur[q*3+1];
; 4841 :                   cur[q*4+0] = cur[q*3+0];
; 4842 :                }
; 4843 :             }
; 4844 :          }
; 4845 :       }
; 4846 :    } else if (depth == 16) {
; 4847 :       // force the image data from big-endian to platform-native.
; 4848 :       // this is done in a separate pass due to the decoding relying
; 4849 :       // on the data being untouched, but could probably be done
; 4850 :       // per-line during decode if care is taken.
; 4851 :       stbi_uc *cur = a->out;
; 4852 :       stbi__uint16 *cur16 = (stbi__uint16*)cur;
; 4853 : 
; 4854 :       for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {
; 4855 :          *cur16 = (cur[0] << 8) | cur[1];
; 4856 :       }
; 4857 :    }
; 4858 : 
; 4859 :    return 1;
; 4860 : }
; 4861 : 
; 4862 : static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
; 4863 : {
; 4864 :    int bytes = (depth == 16 ? 2 : 1);
; 4865 :    int out_bytes = out_n * bytes;
; 4866 :    stbi_uc *final;
; 4867 :    int p;
; 4868 :    if (!interlaced)
; 4869 :       return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);
; 4870 : 
; 4871 :    // de-interlacing
; 4872 :    final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
; 4873 :    if (!final) return stbi__err("outofmem", "Out of memory");
; 4874 :    for (p=0; p < 7; ++p) {
; 4875 :       int xorig[] = { 0,4,0,2,0,1,0 };
; 4876 :       int yorig[] = { 0,0,4,0,2,0,1 };
; 4877 :       int xspc[]  = { 8,8,4,4,2,2,1 };
; 4878 :       int yspc[]  = { 8,8,8,4,4,2,2 };
; 4879 :       int i,j,x,y;
; 4880 :       // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
; 4881 :       x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
; 4882 :       y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
; 4883 :       if (x && y) {
; 4884 :          stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
; 4885 :          if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
; 4886 :             STBI_FREE(final);
; 4887 :             return 0;
; 4888 :          }
; 4889 :          for (j=0; j < y; ++j) {
; 4890 :             for (i=0; i < x; ++i) {
; 4891 :                int out_y = j*yspc[p]+yorig[p];
; 4892 :                int out_x = i*xspc[p]+xorig[p];
; 4893 :                memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
; 4894 :                       a->out + (j*x+i)*out_bytes, out_bytes);
; 4895 :             }
; 4896 :          }
; 4897 :          STBI_FREE(a->out);
; 4898 :          image_data += img_len;
; 4899 :          image_data_len -= img_len;
; 4900 :       }
; 4901 :    }
; 4902 :    a->out = final;
; 4903 : 
; 4904 :    return 1;
; 4905 : }
; 4906 : 
; 4907 : static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
; 4908 : {
; 4909 :    stbi__context *s = z->s;
; 4910 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 4911 :    stbi_uc *p = z->out;
; 4912 : 
; 4913 :    // compute color-based transparency, assuming we've
; 4914 :    // already got 255 as the alpha value in the output
; 4915 :    STBI_ASSERT(out_n == 2 || out_n == 4);
; 4916 : 
; 4917 :    if (out_n == 2) {
; 4918 :       for (i=0; i < pixel_count; ++i) {
; 4919 :          p[1] = (p[0] == tc[0] ? 0 : 255);
; 4920 :          p += 2;
; 4921 :       }
; 4922 :    } else {
; 4923 :       for (i=0; i < pixel_count; ++i) {
; 4924 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
; 4925 :             p[3] = 0;
; 4926 :          p += 4;
; 4927 :       }
; 4928 :    }
; 4929 :    return 1;
; 4930 : }
; 4931 : 
; 4932 : static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
; 4933 : {
; 4934 :    stbi__context *s = z->s;
; 4935 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 4936 :    stbi__uint16 *p = (stbi__uint16*) z->out;
; 4937 : 
; 4938 :    // compute color-based transparency, assuming we've
; 4939 :    // already got 65535 as the alpha value in the output
; 4940 :    STBI_ASSERT(out_n == 2 || out_n == 4);
; 4941 : 
; 4942 :    if (out_n == 2) {
; 4943 :       for (i = 0; i < pixel_count; ++i) {
; 4944 :          p[1] = (p[0] == tc[0] ? 0 : 65535);
; 4945 :          p += 2;
; 4946 :       }
; 4947 :    } else {
; 4948 :       for (i = 0; i < pixel_count; ++i) {
; 4949 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
; 4950 :             p[3] = 0;
; 4951 :          p += 4;
; 4952 :       }
; 4953 :    }
; 4954 :    return 1;
; 4955 : }
; 4956 : 
; 4957 : static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
; 4958 : {
; 4959 :    stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
; 4960 :    stbi_uc *p, *temp_out, *orig = a->out;
; 4961 : 
; 4962 :    p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
; 4963 :    if (p == NULL) return stbi__err("outofmem", "Out of memory");
; 4964 : 
; 4965 :    // between here and free(out) below, exitting would leak
; 4966 :    temp_out = p;
; 4967 : 
; 4968 :    if (pal_img_n == 3) {
; 4969 :       for (i=0; i < pixel_count; ++i) {
; 4970 :          int n = orig[i]*4;
; 4971 :          p[0] = palette[n  ];
; 4972 :          p[1] = palette[n+1];
; 4973 :          p[2] = palette[n+2];
; 4974 :          p += 3;
; 4975 :       }
; 4976 :    } else {
; 4977 :       for (i=0; i < pixel_count; ++i) {
; 4978 :          int n = orig[i]*4;
; 4979 :          p[0] = palette[n  ];
; 4980 :          p[1] = palette[n+1];
; 4981 :          p[2] = palette[n+2];
; 4982 :          p[3] = palette[n+3];
; 4983 :          p += 4;
; 4984 :       }
; 4985 :    }
; 4986 :    STBI_FREE(a->out);
; 4987 :    a->out = temp_out;
; 4988 : 
; 4989 :    STBI_NOTUSED(len);
; 4990 : 
; 4991 :    return 1;
; 4992 : }
; 4993 : 
; 4994 : static int stbi__unpremultiply_on_load_global = 0;
; 4995 : static int stbi__de_iphone_flag_global = 0;
; 4996 : 
; 4997 : STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
; 4998 : {
; 4999 :    stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
; 5000 : }
; 5001 : 
; 5002 : STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
; 5003 : {
; 5004 :    stbi__de_iphone_flag_global = flag_true_if_should_convert;
; 5005 : }
; 5006 : 
; 5007 : #ifndef STBI_THREAD_LOCAL
; 5008 : #define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global
; 5009 : #define stbi__de_iphone_flag  stbi__de_iphone_flag_global
; 5010 : #else
; 5011 : static STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;
; 5012 : static STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;
; 5013 : 
; 5014 : STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
; 5015 : {
; 5016 :    stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
; 5017 :    stbi__unpremultiply_on_load_set = 1;
; 5018 : }
; 5019 : 
; 5020 : STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
; 5021 : {
; 5022 :    stbi__de_iphone_flag_local = flag_true_if_should_convert;
; 5023 :    stbi__de_iphone_flag_set = 1;
; 5024 : }
; 5025 : 
; 5026 : #define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \
; 5027 :                                        ? stbi__unpremultiply_on_load_local      \
; 5028 :                                        : stbi__unpremultiply_on_load_global)
; 5029 : #define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \
; 5030 :                                 ? stbi__de_iphone_flag_local                    \
; 5031 :                                 : stbi__de_iphone_flag_global)
; 5032 : #endif // STBI_THREAD_LOCAL
; 5033 : 
; 5034 : static void stbi__de_iphone(stbi__png *z)
; 5035 : {
; 5036 :    stbi__context *s = z->s;
; 5037 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 5038 :    stbi_uc *p = z->out;
; 5039 : 
; 5040 :    if (s->img_out_n == 3) {  // convert bgr to rgb
; 5041 :       for (i=0; i < pixel_count; ++i) {
; 5042 :          stbi_uc t = p[0];
; 5043 :          p[0] = p[2];
; 5044 :          p[2] = t;
; 5045 :          p += 3;
; 5046 :       }
; 5047 :    } else {
; 5048 :       STBI_ASSERT(s->img_out_n == 4);
; 5049 :       if (stbi__unpremultiply_on_load) {
; 5050 :          // convert bgr to rgb and unpremultiply
; 5051 :          for (i=0; i < pixel_count; ++i) {
; 5052 :             stbi_uc a = p[3];
; 5053 :             stbi_uc t = p[0];
; 5054 :             if (a) {
; 5055 :                stbi_uc half = a / 2;
; 5056 :                p[0] = (p[2] * 255 + half) / a;
; 5057 :                p[1] = (p[1] * 255 + half) / a;
; 5058 :                p[2] = ( t   * 255 + half) / a;
; 5059 :             } else {
; 5060 :                p[0] = p[2];
; 5061 :                p[2] = t;
; 5062 :             }
; 5063 :             p += 4;
; 5064 :          }
; 5065 :       } else {
; 5066 :          // convert bgr to rgb
; 5067 :          for (i=0; i < pixel_count; ++i) {
; 5068 :             stbi_uc t = p[0];
; 5069 :             p[0] = p[2];
; 5070 :             p[2] = t;
; 5071 :             p += 4;
; 5072 :          }
; 5073 :       }
; 5074 :    }
; 5075 : }
; 5076 : 
; 5077 : #define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))
; 5078 : 
; 5079 : static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
; 5080 : {
; 5081 :    stbi_uc palette[1024], pal_img_n=0;
; 5082 :    stbi_uc has_trans=0, tc[3]={0};
; 5083 :    stbi__uint16 tc16[3];
; 5084 :    stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
; 5085 :    int first=1,k,interlace=0, color=0, is_iphone=0;
; 5086 :    stbi__context *s = z->s;
; 5087 : 
; 5088 :    z->expanded = NULL;
; 5089 :    z->idata = NULL;
; 5090 :    z->out = NULL;
; 5091 : 
; 5092 :    if (!stbi__check_png_header(s)) return 0;
; 5093 : 
; 5094 :    if (scan == STBI__SCAN_type) return 1;
; 5095 : 
; 5096 :    for (;;) {
; 5097 :       stbi__pngchunk c = stbi__get_chunk_header(s);
; 5098 :       switch (c.type) {
; 5099 :          case STBI__PNG_TYPE('C','g','B','I'):
; 5100 :             is_iphone = 1;
; 5101 :             stbi__skip(s, c.length);
; 5102 :             break;
; 5103 :          case STBI__PNG_TYPE('I','H','D','R'): {
; 5104 :             int comp,filter;
; 5105 :             if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
; 5106 :             first = 0;
; 5107 :             if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
; 5108 :             s->img_x = stbi__get32be(s);
; 5109 :             s->img_y = stbi__get32be(s);
; 5110 :             if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 5111 :             if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 5112 :             z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
; 5113 :             color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
; 5114 :             if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
; 5115 :             if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
; 5116 :             comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
; 5117 :             filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
; 5118 :             interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
; 5119 :             if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
; 5120 :             if (!pal_img_n) {
; 5121 :                s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
; 5122 :                if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
; 5123 :             } else {
; 5124 :                // if paletted, then pal_n is our final components, and
; 5125 :                // img_n is # components to decompress/filter.
; 5126 :                s->img_n = 1;
; 5127 :                if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
; 5128 :             }
; 5129 :             // even with SCAN_header, have to scan to see if we have a tRNS
; 5130 :             break;
; 5131 :          }
; 5132 : 
; 5133 :          case STBI__PNG_TYPE('P','L','T','E'):  {
; 5134 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5135 :             if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
; 5136 :             pal_len = c.length / 3;
; 5137 :             if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
; 5138 :             for (i=0; i < pal_len; ++i) {
; 5139 :                palette[i*4+0] = stbi__get8(s);
; 5140 :                palette[i*4+1] = stbi__get8(s);
; 5141 :                palette[i*4+2] = stbi__get8(s);
; 5142 :                palette[i*4+3] = 255;
; 5143 :             }
; 5144 :             break;
; 5145 :          }
; 5146 : 
; 5147 :          case STBI__PNG_TYPE('t','R','N','S'): {
; 5148 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5149 :             if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
; 5150 :             if (pal_img_n) {
; 5151 :                if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
; 5152 :                if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
; 5153 :                if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
; 5154 :                pal_img_n = 4;
; 5155 :                for (i=0; i < c.length; ++i)
; 5156 :                   palette[i*4+3] = stbi__get8(s);
; 5157 :             } else {
; 5158 :                if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
; 5159 :                if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
; 5160 :                has_trans = 1;
; 5161 :                // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.
; 5162 :                if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }
; 5163 :                if (z->depth == 16) {
; 5164 :                   for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
; 5165 :                } else {
; 5166 :                   for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
; 5167 :                }
; 5168 :             }
; 5169 :             break;
; 5170 :          }
; 5171 : 
; 5172 :          case STBI__PNG_TYPE('I','D','A','T'): {
; 5173 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5174 :             if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
; 5175 :             if (scan == STBI__SCAN_header) {
; 5176 :                // header scan definitely stops at first IDAT
; 5177 :                if (pal_img_n)
; 5178 :                   s->img_n = pal_img_n;
; 5179 :                return 1;
; 5180 :             }
; 5181 :             if (c.length > (1u << 30)) return stbi__err("IDAT size limit", "IDAT section larger than 2^30 bytes");
; 5182 :             if ((int)(ioff + c.length) < (int)ioff) return 0;
; 5183 :             if (ioff + c.length > idata_limit) {
; 5184 :                stbi__uint32 idata_limit_old = idata_limit;
; 5185 :                stbi_uc *p;
; 5186 :                if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
; 5187 :                while (ioff + c.length > idata_limit)
; 5188 :                   idata_limit *= 2;
; 5189 :                STBI_NOTUSED(idata_limit_old);
; 5190 :                p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
; 5191 :                z->idata = p;
; 5192 :             }
; 5193 :             if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
; 5194 :             ioff += c.length;
; 5195 :             break;
; 5196 :          }
; 5197 : 
; 5198 :          case STBI__PNG_TYPE('I','E','N','D'): {
; 5199 :             stbi__uint32 raw_len, bpl;
; 5200 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5201 :             if (scan != STBI__SCAN_load) return 1;
; 5202 :             if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
; 5203 :             // initial guess for decoded data size to avoid unnecessary reallocs
; 5204 :             bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
; 5205 :             raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
; 5206 :             z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
; 5207 :             if (z->expanded == NULL) return 0; // zlib should set error
; 5208 :             STBI_FREE(z->idata); z->idata = NULL;
; 5209 :             if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
; 5210 :                s->img_out_n = s->img_n+1;
; 5211 :             else
; 5212 :                s->img_out_n = s->img_n;
; 5213 :             if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
; 5214 :             if (has_trans) {
; 5215 :                if (z->depth == 16) {
; 5216 :                   if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
; 5217 :                } else {
; 5218 :                   if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
; 5219 :                }
; 5220 :             }
; 5221 :             if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
; 5222 :                stbi__de_iphone(z);
; 5223 :             if (pal_img_n) {
; 5224 :                // pal_img_n == 3 or 4
; 5225 :                s->img_n = pal_img_n; // record the actual colors we had
; 5226 :                s->img_out_n = pal_img_n;
; 5227 :                if (req_comp >= 3) s->img_out_n = req_comp;
; 5228 :                if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
; 5229 :                   return 0;
; 5230 :             } else if (has_trans) {
; 5231 :                // non-paletted image with tRNS -> source image has (constant) alpha
; 5232 :                ++s->img_n;
; 5233 :             }
; 5234 :             STBI_FREE(z->expanded); z->expanded = NULL;
; 5235 :             // end of PNG chunk, read and skip CRC
; 5236 :             stbi__get32be(s);
; 5237 :             return 1;
; 5238 :          }
; 5239 : 
; 5240 :          default:
; 5241 :             // if critical, fail
; 5242 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5243 :             if ((c.type & (1 << 29)) == 0) {
; 5244 :                #ifndef STBI_NO_FAILURE_STRINGS
; 5245 :                // not threadsafe
; 5246 :                static char invalid_chunk[] = "XXXX PNG chunk not known";
; 5247 :                invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
; 5248 :                invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
; 5249 :                invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
; 5250 :                invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
; 5251 :                #endif
; 5252 :                return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
; 5253 :             }
; 5254 :             stbi__skip(s, c.length);
; 5255 :             break;
; 5256 :       }
; 5257 :       // end of PNG chunk, read and skip CRC
; 5258 :       stbi__get32be(s);
; 5259 :    }
; 5260 : }
; 5261 : 
; 5262 : static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
; 5263 : {
; 5264 :    void *result=NULL;
; 5265 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
; 5266 :    if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
; 5267 :       if (p->depth <= 8)
; 5268 :          ri->bits_per_channel = 8;
; 5269 :       else if (p->depth == 16)
; 5270 :          ri->bits_per_channel = 16;
; 5271 :       else
; 5272 :          return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
; 5273 :       result = p->out;
; 5274 :       p->out = NULL;
; 5275 :       if (req_comp && req_comp != p->s->img_out_n) {
; 5276 :          if (ri->bits_per_channel == 8)
; 5277 :             result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
; 5278 :          else
; 5279 :             result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
; 5280 :          p->s->img_out_n = req_comp;
; 5281 :          if (result == NULL) return result;
; 5282 :       }
; 5283 :       *x = p->s->img_x;
; 5284 :       *y = p->s->img_y;
; 5285 :       if (n) *n = p->s->img_n;
; 5286 :    }
; 5287 :    STBI_FREE(p->out);      p->out      = NULL;
; 5288 :    STBI_FREE(p->expanded); p->expanded = NULL;
; 5289 :    STBI_FREE(p->idata);    p->idata    = NULL;
; 5290 : 
; 5291 :    return result;
; 5292 : }
; 5293 : 
; 5294 : static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5295 : {
; 5296 :    stbi__png p;
; 5297 :    p.s = s;
; 5298 :    return stbi__do_png(&p, x,y,comp,req_comp, ri);
; 5299 : }
; 5300 : 
; 5301 : static int stbi__png_test(stbi__context *s)
; 5302 : {
; 5303 :    int r;
; 5304 :    r = stbi__check_png_header(s);
; 5305 :    stbi__rewind(s);
; 5306 :    return r;
; 5307 : }
; 5308 : 
; 5309 : static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
; 5310 : {
; 5311 :    if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
; 5312 :       stbi__rewind( p->s );
; 5313 :       return 0;
; 5314 :    }
; 5315 :    if (x) *x = p->s->img_x;
; 5316 :    if (y) *y = p->s->img_y;
; 5317 :    if (comp) *comp = p->s->img_n;
; 5318 :    return 1;
; 5319 : }
; 5320 : 
; 5321 : static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
; 5322 : {
; 5323 :    stbi__png p;
; 5324 :    p.s = s;
; 5325 :    return stbi__png_info_raw(&p, x, y, comp);
; 5326 : }
; 5327 : 
; 5328 : static int stbi__png_is16(stbi__context *s)
; 5329 : {
; 5330 :    stbi__png p;
; 5331 :    p.s = s;
; 5332 :    if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
; 5333 : 	   return 0;
; 5334 :    if (p.depth != 16) {
; 5335 :       stbi__rewind(p.s);
; 5336 :       return 0;
; 5337 :    }
; 5338 :    return 1;
; 5339 : }
; 5340 : #endif
; 5341 : 
; 5342 : // Microsoft/Windows BMP image
; 5343 : 
; 5344 : #ifndef STBI_NO_BMP
; 5345 : static int stbi__bmp_test_raw(stbi__context *s)
; 5346 : {
; 5347 :    int r;
; 5348 :    int sz;
; 5349 :    if (stbi__get8(s) != 'B') return 0;
; 5350 :    if (stbi__get8(s) != 'M') return 0;
; 5351 :    stbi__get32le(s); // discard filesize
; 5352 :    stbi__get16le(s); // discard reserved
; 5353 :    stbi__get16le(s); // discard reserved
; 5354 :    stbi__get32le(s); // discard data offset
; 5355 :    sz = stbi__get32le(s);
; 5356 :    r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
; 5357 :    return r;
; 5358 : }
; 5359 : 
; 5360 : static int stbi__bmp_test(stbi__context *s)
; 5361 : {
; 5362 :    int r = stbi__bmp_test_raw(s);
; 5363 :    stbi__rewind(s);
; 5364 :    return r;
; 5365 : }
; 5366 : 
; 5367 : 
; 5368 : // returns 0..31 for the highest set bit
; 5369 : static int stbi__high_bit(unsigned int z)
; 5370 : {
; 5371 :    int n=0;
; 5372 :    if (z == 0) return -1;
; 5373 :    if (z >= 0x10000) { n += 16; z >>= 16; }
; 5374 :    if (z >= 0x00100) { n +=  8; z >>=  8; }
; 5375 :    if (z >= 0x00010) { n +=  4; z >>=  4; }
; 5376 :    if (z >= 0x00004) { n +=  2; z >>=  2; }
; 5377 :    if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
; 5378 :    return n;
; 5379 : }
; 5380 : 
; 5381 : static int stbi__bitcount(unsigned int a)
; 5382 : {
; 5383 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
; 5384 :    a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
; 5385 :    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
; 5386 :    a = (a + (a >> 8)); // max 16 per 8 bits
; 5387 :    a = (a + (a >> 16)); // max 32 per 8 bits
; 5388 :    return a & 0xff;
; 5389 : }
; 5390 : 
; 5391 : // extract an arbitrarily-aligned N-bit value (N=bits)
; 5392 : // from v, and then make it 8-bits long and fractionally
; 5393 : // extend it to full full range.
; 5394 : static int stbi__shiftsigned(unsigned int v, int shift, int bits)
; 5395 : {
; 5396 :    static unsigned int mul_table[9] = {
; 5397 :       0,
; 5398 :       0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
; 5399 :       0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
; 5400 :    };
; 5401 :    static unsigned int shift_table[9] = {
; 5402 :       0, 0,0,1,0,2,4,6,0,
; 5403 :    };
; 5404 :    if (shift < 0)
; 5405 :       v <<= -shift;
; 5406 :    else
; 5407 :       v >>= shift;
; 5408 :    STBI_ASSERT(v < 256);
; 5409 :    v >>= (8-bits);
; 5410 :    STBI_ASSERT(bits >= 0 && bits <= 8);
; 5411 :    return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
; 5412 : }
; 5413 : 
; 5414 : typedef struct
; 5415 : {
; 5416 :    int bpp, offset, hsz;
; 5417 :    unsigned int mr,mg,mb,ma, all_a;
; 5418 :    int extra_read;
; 5419 : } stbi__bmp_data;
; 5420 : 
; 5421 : static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
; 5422 : {
; 5423 :    // BI_BITFIELDS specifies masks explicitly, don't override
; 5424 :    if (compress == 3)
; 5425 :       return 1;
; 5426 : 
; 5427 :    if (compress == 0) {
; 5428 :       if (info->bpp == 16) {
; 5429 :          info->mr = 31u << 10;
; 5430 :          info->mg = 31u <<  5;
; 5431 :          info->mb = 31u <<  0;
; 5432 :       } else if (info->bpp == 32) {
; 5433 :          info->mr = 0xffu << 16;
; 5434 :          info->mg = 0xffu <<  8;
; 5435 :          info->mb = 0xffu <<  0;
; 5436 :          info->ma = 0xffu << 24;
; 5437 :          info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
; 5438 :       } else {
; 5439 :          // otherwise, use defaults, which is all-0
; 5440 :          info->mr = info->mg = info->mb = info->ma = 0;
; 5441 :       }
; 5442 :       return 1;
; 5443 :    }
; 5444 :    return 0; // error
; 5445 : }
; 5446 : 
; 5447 : static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
; 5448 : {
; 5449 :    int hsz;
; 5450 :    if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
; 5451 :    stbi__get32le(s); // discard filesize
; 5452 :    stbi__get16le(s); // discard reserved
; 5453 :    stbi__get16le(s); // discard reserved
; 5454 :    info->offset = stbi__get32le(s);
; 5455 :    info->hsz = hsz = stbi__get32le(s);
; 5456 :    info->mr = info->mg = info->mb = info->ma = 0;
; 5457 :    info->extra_read = 14;
; 5458 : 
; 5459 :    if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");
; 5460 : 
; 5461 :    if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
; 5462 :    if (hsz == 12) {
; 5463 :       s->img_x = stbi__get16le(s);
; 5464 :       s->img_y = stbi__get16le(s);
; 5465 :    } else {
; 5466 :       s->img_x = stbi__get32le(s);
; 5467 :       s->img_y = stbi__get32le(s);
; 5468 :    }
; 5469 :    if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
; 5470 :    info->bpp = stbi__get16le(s);
; 5471 :    if (hsz != 12) {
; 5472 :       int compress = stbi__get32le(s);
; 5473 :       if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
; 5474 :       if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes
; 5475 :       if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel
; 5476 :       stbi__get32le(s); // discard sizeof
; 5477 :       stbi__get32le(s); // discard hres
; 5478 :       stbi__get32le(s); // discard vres
; 5479 :       stbi__get32le(s); // discard colorsused
; 5480 :       stbi__get32le(s); // discard max important
; 5481 :       if (hsz == 40 || hsz == 56) {
; 5482 :          if (hsz == 56) {
; 5483 :             stbi__get32le(s);
; 5484 :             stbi__get32le(s);
; 5485 :             stbi__get32le(s);
; 5486 :             stbi__get32le(s);
; 5487 :          }
; 5488 :          if (info->bpp == 16 || info->bpp == 32) {
; 5489 :             if (compress == 0) {
; 5490 :                stbi__bmp_set_mask_defaults(info, compress);
; 5491 :             } else if (compress == 3) {
; 5492 :                info->mr = stbi__get32le(s);
; 5493 :                info->mg = stbi__get32le(s);
; 5494 :                info->mb = stbi__get32le(s);
; 5495 :                info->extra_read += 12;
; 5496 :                // not documented, but generated by photoshop and handled by mspaint
; 5497 :                if (info->mr == info->mg && info->mg == info->mb) {
; 5498 :                   // ?!?!?
; 5499 :                   return stbi__errpuc("bad BMP", "bad BMP");
; 5500 :                }
; 5501 :             } else
; 5502 :                return stbi__errpuc("bad BMP", "bad BMP");
; 5503 :          }
; 5504 :       } else {
; 5505 :          // V4/V5 header
; 5506 :          int i;
; 5507 :          if (hsz != 108 && hsz != 124)
; 5508 :             return stbi__errpuc("bad BMP", "bad BMP");
; 5509 :          info->mr = stbi__get32le(s);
; 5510 :          info->mg = stbi__get32le(s);
; 5511 :          info->mb = stbi__get32le(s);
; 5512 :          info->ma = stbi__get32le(s);
; 5513 :          if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
; 5514 :             stbi__bmp_set_mask_defaults(info, compress);
; 5515 :          stbi__get32le(s); // discard color space
; 5516 :          for (i=0; i < 12; ++i)
; 5517 :             stbi__get32le(s); // discard color space parameters
; 5518 :          if (hsz == 124) {
; 5519 :             stbi__get32le(s); // discard rendering intent
; 5520 :             stbi__get32le(s); // discard offset of profile data
; 5521 :             stbi__get32le(s); // discard size of profile data
; 5522 :             stbi__get32le(s); // discard reserved
; 5523 :          }
; 5524 :       }
; 5525 :    }
; 5526 :    return (void *) 1;
; 5527 : }
; 5528 : 
; 5529 : 
; 5530 : static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5531 : {
; 5532 :    stbi_uc *out;
; 5533 :    unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
; 5534 :    stbi_uc pal[256][4];
; 5535 :    int psize=0,i,j,width;
; 5536 :    int flip_vertically, pad, target;
; 5537 :    stbi__bmp_data info;
; 5538 :    STBI_NOTUSED(ri);
; 5539 : 
; 5540 :    info.all_a = 255;
; 5541 :    if (stbi__bmp_parse_header(s, &info) == NULL)
; 5542 :       return NULL; // error code already set
; 5543 : 
; 5544 :    flip_vertically = ((int) s->img_y) > 0;
; 5545 :    s->img_y = abs((int) s->img_y);
; 5546 : 
; 5547 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5548 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5549 : 
; 5550 :    mr = info.mr;
; 5551 :    mg = info.mg;
; 5552 :    mb = info.mb;
; 5553 :    ma = info.ma;
; 5554 :    all_a = info.all_a;
; 5555 : 
; 5556 :    if (info.hsz == 12) {
; 5557 :       if (info.bpp < 24)
; 5558 :          psize = (info.offset - info.extra_read - 24) / 3;
; 5559 :    } else {
; 5560 :       if (info.bpp < 16)
; 5561 :          psize = (info.offset - info.extra_read - info.hsz) >> 2;
; 5562 :    }
; 5563 :    if (psize == 0) {
; 5564 :       // accept some number of extra bytes after the header, but if the offset points either to before
; 5565 :       // the header ends or implies a large amount of extra data, reject the file as malformed
; 5566 :       int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);
; 5567 :       int header_limit = 1024; // max we actually read is below 256 bytes currently.
; 5568 :       int extra_data_limit = 256*4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.
; 5569 :       if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {
; 5570 :          return stbi__errpuc("bad header", "Corrupt BMP");
; 5571 :       }
; 5572 :       // we established that bytes_read_so_far is positive and sensible.
; 5573 :       // the first half of this test rejects offsets that are either too small positives, or
; 5574 :       // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn
; 5575 :       // ensures the number computed in the second half of the test can't overflow.
; 5576 :       if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {
; 5577 :          return stbi__errpuc("bad offset", "Corrupt BMP");
; 5578 :       } else {
; 5579 :          stbi__skip(s, info.offset - bytes_read_so_far);
; 5580 :       }
; 5581 :    }
; 5582 : 
; 5583 :    if (info.bpp == 24 && ma == 0xff000000)
; 5584 :       s->img_n = 3;
; 5585 :    else
; 5586 :       s->img_n = ma ? 4 : 3;
; 5587 :    if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
; 5588 :       target = req_comp;
; 5589 :    else
; 5590 :       target = s->img_n; // if they want monochrome, we'll post-convert
; 5591 : 
; 5592 :    // sanity-check size
; 5593 :    if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
; 5594 :       return stbi__errpuc("too large", "Corrupt BMP");
; 5595 : 
; 5596 :    out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
; 5597 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");
; 5598 :    if (info.bpp < 16) {
; 5599 :       int z=0;
; 5600 :       if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
; 5601 :       for (i=0; i < psize; ++i) {
; 5602 :          pal[i][2] = stbi__get8(s);
; 5603 :          pal[i][1] = stbi__get8(s);
; 5604 :          pal[i][0] = stbi__get8(s);
; 5605 :          if (info.hsz != 12) stbi__get8(s);
; 5606 :          pal[i][3] = 255;
; 5607 :       }
; 5608 :       stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
; 5609 :       if (info.bpp == 1) width = (s->img_x + 7) >> 3;
; 5610 :       else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
; 5611 :       else if (info.bpp == 8) width = s->img_x;
; 5612 :       else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
; 5613 :       pad = (-width)&3;
; 5614 :       if (info.bpp == 1) {
; 5615 :          for (j=0; j < (int) s->img_y; ++j) {
; 5616 :             int bit_offset = 7, v = stbi__get8(s);
; 5617 :             for (i=0; i < (int) s->img_x; ++i) {
; 5618 :                int color = (v>>bit_offset)&0x1;
; 5619 :                out[z++] = pal[color][0];
; 5620 :                out[z++] = pal[color][1];
; 5621 :                out[z++] = pal[color][2];
; 5622 :                if (target == 4) out[z++] = 255;
; 5623 :                if (i+1 == (int) s->img_x) break;
; 5624 :                if((--bit_offset) < 0) {
; 5625 :                   bit_offset = 7;
; 5626 :                   v = stbi__get8(s);
; 5627 :                }
; 5628 :             }
; 5629 :             stbi__skip(s, pad);
; 5630 :          }
; 5631 :       } else {
; 5632 :          for (j=0; j < (int) s->img_y; ++j) {
; 5633 :             for (i=0; i < (int) s->img_x; i += 2) {
; 5634 :                int v=stbi__get8(s),v2=0;
; 5635 :                if (info.bpp == 4) {
; 5636 :                   v2 = v & 15;
; 5637 :                   v >>= 4;
; 5638 :                }
; 5639 :                out[z++] = pal[v][0];
; 5640 :                out[z++] = pal[v][1];
; 5641 :                out[z++] = pal[v][2];
; 5642 :                if (target == 4) out[z++] = 255;
; 5643 :                if (i+1 == (int) s->img_x) break;
; 5644 :                v = (info.bpp == 8) ? stbi__get8(s) : v2;
; 5645 :                out[z++] = pal[v][0];
; 5646 :                out[z++] = pal[v][1];
; 5647 :                out[z++] = pal[v][2];
; 5648 :                if (target == 4) out[z++] = 255;
; 5649 :             }
; 5650 :             stbi__skip(s, pad);
; 5651 :          }
; 5652 :       }
; 5653 :    } else {
; 5654 :       int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
; 5655 :       int z = 0;
; 5656 :       int easy=0;
; 5657 :       stbi__skip(s, info.offset - info.extra_read - info.hsz);
; 5658 :       if (info.bpp == 24) width = 3 * s->img_x;
; 5659 :       else if (info.bpp == 16) width = 2*s->img_x;
; 5660 :       else /* bpp = 32 and pad = 0 */ width=0;
; 5661 :       pad = (-width) & 3;
; 5662 :       if (info.bpp == 24) {
; 5663 :          easy = 1;
; 5664 :       } else if (info.bpp == 32) {
; 5665 :          if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
; 5666 :             easy = 2;
; 5667 :       }
; 5668 :       if (!easy) {
; 5669 :          if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
; 5670 :          // right shift amt to put high bit in position #7
; 5671 :          rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
; 5672 :          gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
; 5673 :          bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
; 5674 :          ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
; 5675 :          if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
; 5676 :       }
; 5677 :       for (j=0; j < (int) s->img_y; ++j) {
; 5678 :          if (easy) {
; 5679 :             for (i=0; i < (int) s->img_x; ++i) {
; 5680 :                unsigned char a;
; 5681 :                out[z+2] = stbi__get8(s);
; 5682 :                out[z+1] = stbi__get8(s);
; 5683 :                out[z+0] = stbi__get8(s);
; 5684 :                z += 3;
; 5685 :                a = (easy == 2 ? stbi__get8(s) : 255);
; 5686 :                all_a |= a;
; 5687 :                if (target == 4) out[z++] = a;
; 5688 :             }
; 5689 :          } else {
; 5690 :             int bpp = info.bpp;
; 5691 :             for (i=0; i < (int) s->img_x; ++i) {
; 5692 :                stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
; 5693 :                unsigned int a;
; 5694 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
; 5695 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
; 5696 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
; 5697 :                a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
; 5698 :                all_a |= a;
; 5699 :                if (target == 4) out[z++] = STBI__BYTECAST(a);
; 5700 :             }
; 5701 :          }
; 5702 :          stbi__skip(s, pad);
; 5703 :       }
; 5704 :    }
; 5705 : 
; 5706 :    // if alpha channel is all 0s, replace with all 255s
; 5707 :    if (target == 4 && all_a == 0)
; 5708 :       for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
; 5709 :          out[i] = 255;
; 5710 : 
; 5711 :    if (flip_vertically) {
; 5712 :       stbi_uc t;
; 5713 :       for (j=0; j < (int) s->img_y>>1; ++j) {
; 5714 :          stbi_uc *p1 = out +      j     *s->img_x*target;
; 5715 :          stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
; 5716 :          for (i=0; i < (int) s->img_x*target; ++i) {
; 5717 :             t = p1[i]; p1[i] = p2[i]; p2[i] = t;
; 5718 :          }
; 5719 :       }
; 5720 :    }
; 5721 : 
; 5722 :    if (req_comp && req_comp != target) {
; 5723 :       out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
; 5724 :       if (out == NULL) return out; // stbi__convert_format frees input on failure
; 5725 :    }
; 5726 : 
; 5727 :    *x = s->img_x;
; 5728 :    *y = s->img_y;
; 5729 :    if (comp) *comp = s->img_n;
; 5730 :    return out;
; 5731 : }
; 5732 : #endif
; 5733 : 
; 5734 : // Targa Truevision - TGA
; 5735 : // by Jonathan Dummer
; 5736 : #ifndef STBI_NO_TGA
; 5737 : // returns STBI_rgb or whatever, 0 on error
; 5738 : static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
; 5739 : {
; 5740 :    // only RGB or RGBA (incl. 16bit) or grey allowed
; 5741 :    if (is_rgb16) *is_rgb16 = 0;
; 5742 :    switch(bits_per_pixel) {
; 5743 :       case 8:  return STBI_grey;
; 5744 :       case 16: if(is_grey) return STBI_grey_alpha;
; 5745 :                // fallthrough
; 5746 :       case 15: if(is_rgb16) *is_rgb16 = 1;
; 5747 :                return STBI_rgb;
; 5748 :       case 24: // fallthrough
; 5749 :       case 32: return bits_per_pixel/8;
; 5750 :       default: return 0;
; 5751 :    }
; 5752 : }
; 5753 : 
; 5754 : static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
; 5755 : {
; 5756 :     int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
; 5757 :     int sz, tga_colormap_type;
; 5758 :     stbi__get8(s);                   // discard Offset
; 5759 :     tga_colormap_type = stbi__get8(s); // colormap type
; 5760 :     if( tga_colormap_type > 1 ) {
; 5761 :         stbi__rewind(s);
; 5762 :         return 0;      // only RGB or indexed allowed
; 5763 :     }
; 5764 :     tga_image_type = stbi__get8(s); // image type
; 5765 :     if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
; 5766 :         if (tga_image_type != 1 && tga_image_type != 9) {
; 5767 :             stbi__rewind(s);
; 5768 :             return 0;
; 5769 :         }
; 5770 :         stbi__skip(s,4);       // skip index of first colormap entry and number of entries
; 5771 :         sz = stbi__get8(s);    //   check bits per palette color entry
; 5772 :         if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
; 5773 :             stbi__rewind(s);
; 5774 :             return 0;
; 5775 :         }
; 5776 :         stbi__skip(s,4);       // skip image x and y origin
; 5777 :         tga_colormap_bpp = sz;
; 5778 :     } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
; 5779 :         if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
; 5780 :             stbi__rewind(s);
; 5781 :             return 0; // only RGB or grey allowed, +/- RLE
; 5782 :         }
; 5783 :         stbi__skip(s,9); // skip colormap specification and image x/y origin
; 5784 :         tga_colormap_bpp = 0;
; 5785 :     }
; 5786 :     tga_w = stbi__get16le(s);
; 5787 :     if( tga_w < 1 ) {
; 5788 :         stbi__rewind(s);
; 5789 :         return 0;   // test width
; 5790 :     }
; 5791 :     tga_h = stbi__get16le(s);
; 5792 :     if( tga_h < 1 ) {
; 5793 :         stbi__rewind(s);
; 5794 :         return 0;   // test height
; 5795 :     }
; 5796 :     tga_bits_per_pixel = stbi__get8(s); // bits per pixel
; 5797 :     stbi__get8(s); // ignore alpha bits
; 5798 :     if (tga_colormap_bpp != 0) {
; 5799 :         if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
; 5800 :             // when using a colormap, tga_bits_per_pixel is the size of the indexes
; 5801 :             // I don't think anything but 8 or 16bit indexes makes sense
; 5802 :             stbi__rewind(s);
; 5803 :             return 0;
; 5804 :         }
; 5805 :         tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
; 5806 :     } else {
; 5807 :         tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
; 5808 :     }
; 5809 :     if(!tga_comp) {
; 5810 :       stbi__rewind(s);
; 5811 :       return 0;
; 5812 :     }
; 5813 :     if (x) *x = tga_w;
; 5814 :     if (y) *y = tga_h;
; 5815 :     if (comp) *comp = tga_comp;
; 5816 :     return 1;                   // seems to have passed everything
; 5817 : }
; 5818 : 
; 5819 : static int stbi__tga_test(stbi__context *s)
; 5820 : {
; 5821 :    int res = 0;
; 5822 :    int sz, tga_color_type;
; 5823 :    stbi__get8(s);      //   discard Offset
; 5824 :    tga_color_type = stbi__get8(s);   //   color type
; 5825 :    if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
; 5826 :    sz = stbi__get8(s);   //   image type
; 5827 :    if ( tga_color_type == 1 ) { // colormapped (paletted) image
; 5828 :       if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
; 5829 :       stbi__skip(s,4);       // skip index of first colormap entry and number of entries
; 5830 :       sz = stbi__get8(s);    //   check bits per palette color entry
; 5831 :       if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
; 5832 :       stbi__skip(s,4);       // skip image x and y origin
; 5833 :    } else { // "normal" image w/o colormap
; 5834 :       if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
; 5835 :       stbi__skip(s,9); // skip colormap specification and image x/y origin
; 5836 :    }
; 5837 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
; 5838 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
; 5839 :    sz = stbi__get8(s);   //   bits per pixel
; 5840 :    if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
; 5841 :    if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
; 5842 : 
; 5843 :    res = 1; // if we got this far, everything's good and we can return 1 instead of 0
; 5844 : 
; 5845 : errorEnd:
; 5846 :    stbi__rewind(s);
; 5847 :    return res;
; 5848 : }
; 5849 : 
; 5850 : // read 16bit value and convert to 24bit RGB
; 5851 : static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
; 5852 : {
; 5853 :    stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
; 5854 :    stbi__uint16 fiveBitMask = 31;
; 5855 :    // we have 3 channels with 5bits each
; 5856 :    int r = (px >> 10) & fiveBitMask;
; 5857 :    int g = (px >> 5) & fiveBitMask;
; 5858 :    int b = px & fiveBitMask;
; 5859 :    // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
; 5860 :    out[0] = (stbi_uc)((r * 255)/31);
; 5861 :    out[1] = (stbi_uc)((g * 255)/31);
; 5862 :    out[2] = (stbi_uc)((b * 255)/31);
; 5863 : 
; 5864 :    // some people claim that the most significant bit might be used for alpha
; 5865 :    // (possibly if an alpha-bit is set in the "image descriptor byte")
; 5866 :    // but that only made 16bit test images completely translucent..
; 5867 :    // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
; 5868 : }
; 5869 : 
; 5870 : static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5871 : {
; 5872 :    //   read in the TGA header stuff
; 5873 :    int tga_offset = stbi__get8(s);
; 5874 :    int tga_indexed = stbi__get8(s);
; 5875 :    int tga_image_type = stbi__get8(s);
; 5876 :    int tga_is_RLE = 0;
; 5877 :    int tga_palette_start = stbi__get16le(s);
; 5878 :    int tga_palette_len = stbi__get16le(s);
; 5879 :    int tga_palette_bits = stbi__get8(s);
; 5880 :    int tga_x_origin = stbi__get16le(s);
; 5881 :    int tga_y_origin = stbi__get16le(s);
; 5882 :    int tga_width = stbi__get16le(s);
; 5883 :    int tga_height = stbi__get16le(s);
; 5884 :    int tga_bits_per_pixel = stbi__get8(s);
; 5885 :    int tga_comp, tga_rgb16=0;
; 5886 :    int tga_inverted = stbi__get8(s);
; 5887 :    // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
; 5888 :    //   image data
; 5889 :    unsigned char *tga_data;
; 5890 :    unsigned char *tga_palette = NULL;
; 5891 :    int i, j;
; 5892 :    unsigned char raw_data[4] = {0};
; 5893 :    int RLE_count = 0;
; 5894 :    int RLE_repeating = 0;
; 5895 :    int read_next_pixel = 1;
; 5896 :    STBI_NOTUSED(ri);
; 5897 :    STBI_NOTUSED(tga_x_origin); // @TODO
; 5898 :    STBI_NOTUSED(tga_y_origin); // @TODO
; 5899 : 
; 5900 :    if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5901 :    if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5902 : 
; 5903 :    //   do a tiny bit of precessing
; 5904 :    if ( tga_image_type >= 8 )
; 5905 :    {
; 5906 :       tga_image_type -= 8;
; 5907 :       tga_is_RLE = 1;
; 5908 :    }
; 5909 :    tga_inverted = 1 - ((tga_inverted >> 5) & 1);
; 5910 : 
; 5911 :    //   If I'm paletted, then I'll use the number of bits from the palette
; 5912 :    if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
; 5913 :    else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);
; 5914 : 
; 5915 :    if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
; 5916 :       return stbi__errpuc("bad format", "Can't find out TGA pixelformat");
; 5917 : 
; 5918 :    //   tga info
; 5919 :    *x = tga_width;
; 5920 :    *y = tga_height;
; 5921 :    if (comp) *comp = tga_comp;
; 5922 : 
; 5923 :    if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
; 5924 :       return stbi__errpuc("too large", "Corrupt TGA");
; 5925 : 
; 5926 :    tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
; 5927 :    if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");
; 5928 : 
; 5929 :    // skip to the data's starting position (offset usually = 0)
; 5930 :    stbi__skip(s, tga_offset );
; 5931 : 
; 5932 :    if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
; 5933 :       for (i=0; i < tga_height; ++i) {
; 5934 :          int row = tga_inverted ? tga_height -i - 1 : i;
; 5935 :          stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
; 5936 :          stbi__getn(s, tga_row, tga_width * tga_comp);
; 5937 :       }
; 5938 :    } else  {
; 5939 :       //   do I need to load a palette?
; 5940 :       if ( tga_indexed)
; 5941 :       {
; 5942 :          if (tga_palette_len == 0) {  /* you have to have at least one entry! */
; 5943 :             STBI_FREE(tga_data);
; 5944 :             return stbi__errpuc("bad palette", "Corrupt TGA");
; 5945 :          }
; 5946 : 
; 5947 :          //   any data to skip? (offset usually = 0)
; 5948 :          stbi__skip(s, tga_palette_start );
; 5949 :          //   load the palette
; 5950 :          tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
; 5951 :          if (!tga_palette) {
; 5952 :             STBI_FREE(tga_data);
; 5953 :             return stbi__errpuc("outofmem", "Out of memory");
; 5954 :          }
; 5955 :          if (tga_rgb16) {
; 5956 :             stbi_uc *pal_entry = tga_palette;
; 5957 :             STBI_ASSERT(tga_comp == STBI_rgb);
; 5958 :             for (i=0; i < tga_palette_len; ++i) {
; 5959 :                stbi__tga_read_rgb16(s, pal_entry);
; 5960 :                pal_entry += tga_comp;
; 5961 :             }
; 5962 :          } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
; 5963 :                STBI_FREE(tga_data);
; 5964 :                STBI_FREE(tga_palette);
; 5965 :                return stbi__errpuc("bad palette", "Corrupt TGA");
; 5966 :          }
; 5967 :       }
; 5968 :       //   load the data
; 5969 :       for (i=0; i < tga_width * tga_height; ++i)
; 5970 :       {
; 5971 :          //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
; 5972 :          if ( tga_is_RLE )
; 5973 :          {
; 5974 :             if ( RLE_count == 0 )
; 5975 :             {
; 5976 :                //   yep, get the next byte as a RLE command
; 5977 :                int RLE_cmd = stbi__get8(s);
; 5978 :                RLE_count = 1 + (RLE_cmd & 127);
; 5979 :                RLE_repeating = RLE_cmd >> 7;
; 5980 :                read_next_pixel = 1;
; 5981 :             } else if ( !RLE_repeating )
; 5982 :             {
; 5983 :                read_next_pixel = 1;
; 5984 :             }
; 5985 :          } else
; 5986 :          {
; 5987 :             read_next_pixel = 1;
; 5988 :          }
; 5989 :          //   OK, if I need to read a pixel, do it now
; 5990 :          if ( read_next_pixel )
; 5991 :          {
; 5992 :             //   load however much data we did have
; 5993 :             if ( tga_indexed )
; 5994 :             {
; 5995 :                // read in index, then perform the lookup
; 5996 :                int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
; 5997 :                if ( pal_idx >= tga_palette_len ) {
; 5998 :                   // invalid index
; 5999 :                   pal_idx = 0;
; 6000 :                }
; 6001 :                pal_idx *= tga_comp;
; 6002 :                for (j = 0; j < tga_comp; ++j) {
; 6003 :                   raw_data[j] = tga_palette[pal_idx+j];
; 6004 :                }
; 6005 :             } else if(tga_rgb16) {
; 6006 :                STBI_ASSERT(tga_comp == STBI_rgb);
; 6007 :                stbi__tga_read_rgb16(s, raw_data);
; 6008 :             } else {
; 6009 :                //   read in the data raw
; 6010 :                for (j = 0; j < tga_comp; ++j) {
; 6011 :                   raw_data[j] = stbi__get8(s);
; 6012 :                }
; 6013 :             }
; 6014 :             //   clear the reading flag for the next pixel
; 6015 :             read_next_pixel = 0;
; 6016 :          } // end of reading a pixel
; 6017 : 
; 6018 :          // copy data
; 6019 :          for (j = 0; j < tga_comp; ++j)
; 6020 :            tga_data[i*tga_comp+j] = raw_data[j];
; 6021 : 
; 6022 :          //   in case we're in RLE mode, keep counting down
; 6023 :          --RLE_count;
; 6024 :       }
; 6025 :       //   do I need to invert the image?
; 6026 :       if ( tga_inverted )
; 6027 :       {
; 6028 :          for (j = 0; j*2 < tga_height; ++j)
; 6029 :          {
; 6030 :             int index1 = j * tga_width * tga_comp;
; 6031 :             int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
; 6032 :             for (i = tga_width * tga_comp; i > 0; --i)
; 6033 :             {
; 6034 :                unsigned char temp = tga_data[index1];
; 6035 :                tga_data[index1] = tga_data[index2];
; 6036 :                tga_data[index2] = temp;
; 6037 :                ++index1;
; 6038 :                ++index2;
; 6039 :             }
; 6040 :          }
; 6041 :       }
; 6042 :       //   clear my palette, if I had one
; 6043 :       if ( tga_palette != NULL )
; 6044 :       {
; 6045 :          STBI_FREE( tga_palette );
; 6046 :       }
; 6047 :    }
; 6048 : 
; 6049 :    // swap RGB - if the source data was RGB16, it already is in the right order
; 6050 :    if (tga_comp >= 3 && !tga_rgb16)
; 6051 :    {
; 6052 :       unsigned char* tga_pixel = tga_data;
; 6053 :       for (i=0; i < tga_width * tga_height; ++i)
; 6054 :       {
; 6055 :          unsigned char temp = tga_pixel[0];
; 6056 :          tga_pixel[0] = tga_pixel[2];
; 6057 :          tga_pixel[2] = temp;
; 6058 :          tga_pixel += tga_comp;
; 6059 :       }
; 6060 :    }
; 6061 : 
; 6062 :    // convert to target component count
; 6063 :    if (req_comp && req_comp != tga_comp)
; 6064 :       tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);
; 6065 : 
; 6066 :    //   the things I do to get rid of an error message, and yet keep
; 6067 :    //   Microsoft's C compilers happy... [8^(
; 6068 :    tga_palette_start = tga_palette_len = tga_palette_bits =
; 6069 :          tga_x_origin = tga_y_origin = 0;
; 6070 :    STBI_NOTUSED(tga_palette_start);
; 6071 :    //   OK, done
; 6072 :    return tga_data;
; 6073 : }
; 6074 : #endif
; 6075 : 
; 6076 : // *************************************************************************************************
; 6077 : // Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB
; 6078 : 
; 6079 : #ifndef STBI_NO_PSD
; 6080 : static int stbi__psd_test(stbi__context *s)
; 6081 : {
; 6082 :    int r = (stbi__get32be(s) == 0x38425053);
; 6083 :    stbi__rewind(s);
; 6084 :    return r;
; 6085 : }
; 6086 : 
; 6087 : static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
; 6088 : {
; 6089 :    int count, nleft, len;
; 6090 : 
; 6091 :    count = 0;
; 6092 :    while ((nleft = pixelCount - count) > 0) {
; 6093 :       len = stbi__get8(s);
; 6094 :       if (len == 128) {
; 6095 :          // No-op.
; 6096 :       } else if (len < 128) {
; 6097 :          // Copy next len+1 bytes literally.
; 6098 :          len++;
; 6099 :          if (len > nleft) return 0; // corrupt data
; 6100 :          count += len;
; 6101 :          while (len) {
; 6102 :             *p = stbi__get8(s);
; 6103 :             p += 4;
; 6104 :             len--;
; 6105 :          }
; 6106 :       } else if (len > 128) {
; 6107 :          stbi_uc   val;
; 6108 :          // Next -len+1 bytes in the dest are replicated from next source byte.
; 6109 :          // (Interpret len as a negative 8-bit int.)
; 6110 :          len = 257 - len;
; 6111 :          if (len > nleft) return 0; // corrupt data
; 6112 :          val = stbi__get8(s);
; 6113 :          count += len;
; 6114 :          while (len) {
; 6115 :             *p = val;
; 6116 :             p += 4;
; 6117 :             len--;
; 6118 :          }
; 6119 :       }
; 6120 :    }
; 6121 : 
; 6122 :    return 1;
; 6123 : }
; 6124 : 
; 6125 : static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
; 6126 : {
; 6127 :    int pixelCount;
; 6128 :    int channelCount, compression;
; 6129 :    int channel, i;
; 6130 :    int bitdepth;
; 6131 :    int w,h;
; 6132 :    stbi_uc *out;
; 6133 :    STBI_NOTUSED(ri);
; 6134 : 
; 6135 :    // Check identifier
; 6136 :    if (stbi__get32be(s) != 0x38425053)   // "8BPS"
; 6137 :       return stbi__errpuc("not PSD", "Corrupt PSD image");
; 6138 : 
; 6139 :    // Check file type version.
; 6140 :    if (stbi__get16be(s) != 1)
; 6141 :       return stbi__errpuc("wrong version", "Unsupported version of PSD image");
; 6142 : 
; 6143 :    // Skip 6 reserved bytes.
; 6144 :    stbi__skip(s, 6 );
; 6145 : 
; 6146 :    // Read the number of channels (R, G, B, A, etc).
; 6147 :    channelCount = stbi__get16be(s);
; 6148 :    if (channelCount < 0 || channelCount > 16)
; 6149 :       return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");
; 6150 : 
; 6151 :    // Read the rows and columns of the image.
; 6152 :    h = stbi__get32be(s);
; 6153 :    w = stbi__get32be(s);
; 6154 : 
; 6155 :    if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 6156 :    if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 6157 : 
; 6158 :    // Make sure the depth is 8 bits.
; 6159 :    bitdepth = stbi__get16be(s);
; 6160 :    if (bitdepth != 8 && bitdepth != 16)
; 6161 :       return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");
; 6162 : 
; 6163 :    // Make sure the color mode is RGB.
; 6164 :    // Valid options are:
; 6165 :    //   0: Bitmap
; 6166 :    //   1: Grayscale
; 6167 :    //   2: Indexed color
; 6168 :    //   3: RGB color
; 6169 :    //   4: CMYK color
; 6170 :    //   7: Multichannel
; 6171 :    //   8: Duotone
; 6172 :    //   9: Lab color
; 6173 :    if (stbi__get16be(s) != 3)
; 6174 :       return stbi__errpuc("wrong color format", "PSD is not in RGB color format");
; 6175 : 
; 6176 :    // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
; 6177 :    stbi__skip(s,stbi__get32be(s) );
; 6178 : 
; 6179 :    // Skip the image resources.  (resolution, pen tool paths, etc)
; 6180 :    stbi__skip(s, stbi__get32be(s) );
; 6181 : 
; 6182 :    // Skip the reserved data.
; 6183 :    stbi__skip(s, stbi__get32be(s) );
; 6184 : 
; 6185 :    // Find out if the data is compressed.
; 6186 :    // Known values:
; 6187 :    //   0: no compression
; 6188 :    //   1: RLE compressed
; 6189 :    compression = stbi__get16be(s);
; 6190 :    if (compression > 1)
; 6191 :       return stbi__errpuc("bad compression", "PSD has an unknown compression format");
; 6192 : 
; 6193 :    // Check size
; 6194 :    if (!stbi__mad3sizes_valid(4, w, h, 0))
; 6195 :       return stbi__errpuc("too large", "Corrupt PSD");
; 6196 : 
; 6197 :    // Create the destination image.
; 6198 : 
; 6199 :    if (!compression && bitdepth == 16 && bpc == 16) {
; 6200 :       out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
; 6201 :       ri->bits_per_channel = 16;
; 6202 :    } else
; 6203 :       out = (stbi_uc *) stbi__malloc(4 * w*h);
; 6204 : 
; 6205 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");
; 6206 :    pixelCount = w*h;
; 6207 : 
; 6208 :    // Initialize the data to zero.
; 6209 :    //memset( out, 0, pixelCount * 4 );
; 6210 : 
; 6211 :    // Finally, the image data.
; 6212 :    if (compression) {
; 6213 :       // RLE as used by .PSD and .TIFF
; 6214 :       // Loop until you get the number of unpacked bytes you are expecting:
; 6215 :       //     Read the next source byte into n.
; 6216 :       //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
; 6217 :       //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
; 6218 :       //     Else if n is 128, noop.
; 6219 :       // Endloop
; 6220 : 
; 6221 :       // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
; 6222 :       // which we're going to just skip.
; 6223 :       stbi__skip(s, h * channelCount * 2 );
; 6224 : 
; 6225 :       // Read the RLE data by channel.
; 6226 :       for (channel = 0; channel < 4; channel++) {
; 6227 :          stbi_uc *p;
; 6228 : 
; 6229 :          p = out+channel;
; 6230 :          if (channel >= channelCount) {
; 6231 :             // Fill this channel with default data.
; 6232 :             for (i = 0; i < pixelCount; i++, p += 4)
; 6233 :                *p = (channel == 3 ? 255 : 0);
; 6234 :          } else {
; 6235 :             // Read the RLE data.
; 6236 :             if (!stbi__psd_decode_rle(s, p, pixelCount)) {
; 6237 :                STBI_FREE(out);
; 6238 :                return stbi__errpuc("corrupt", "bad RLE data");
; 6239 :             }
; 6240 :          }
; 6241 :       }
; 6242 : 
; 6243 :    } else {
; 6244 :       // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
; 6245 :       // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.
; 6246 : 
; 6247 :       // Read the data by channel.
; 6248 :       for (channel = 0; channel < 4; channel++) {
; 6249 :          if (channel >= channelCount) {
; 6250 :             // Fill this channel with default data.
; 6251 :             if (bitdepth == 16 && bpc == 16) {
; 6252 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
; 6253 :                stbi__uint16 val = channel == 3 ? 65535 : 0;
; 6254 :                for (i = 0; i < pixelCount; i++, q += 4)
; 6255 :                   *q = val;
; 6256 :             } else {
; 6257 :                stbi_uc *p = out+channel;
; 6258 :                stbi_uc val = channel == 3 ? 255 : 0;
; 6259 :                for (i = 0; i < pixelCount; i++, p += 4)
; 6260 :                   *p = val;
; 6261 :             }
; 6262 :          } else {
; 6263 :             if (ri->bits_per_channel == 16) {    // output bpc
; 6264 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
; 6265 :                for (i = 0; i < pixelCount; i++, q += 4)
; 6266 :                   *q = (stbi__uint16) stbi__get16be(s);
; 6267 :             } else {
; 6268 :                stbi_uc *p = out+channel;
; 6269 :                if (bitdepth == 16) {  // input bpc
; 6270 :                   for (i = 0; i < pixelCount; i++, p += 4)
; 6271 :                      *p = (stbi_uc) (stbi__get16be(s) >> 8);
; 6272 :                } else {
; 6273 :                   for (i = 0; i < pixelCount; i++, p += 4)
; 6274 :                      *p = stbi__get8(s);
; 6275 :                }
; 6276 :             }
; 6277 :          }
; 6278 :       }
; 6279 :    }
; 6280 : 
; 6281 :    // remove weird white matte from PSD
; 6282 :    if (channelCount >= 4) {
; 6283 :       if (ri->bits_per_channel == 16) {
; 6284 :          for (i=0; i < w*h; ++i) {
; 6285 :             stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
; 6286 :             if (pixel[3] != 0 && pixel[3] != 65535) {
; 6287 :                float a = pixel[3] / 65535.0f;
; 6288 :                float ra = 1.0f / a;
; 6289 :                float inv_a = 65535.0f * (1 - ra);
; 6290 :                pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
; 6291 :                pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
; 6292 :                pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
; 6293 :             }
; 6294 :          }
; 6295 :       } else {
; 6296 :          for (i=0; i < w*h; ++i) {
; 6297 :             unsigned char *pixel = out + 4*i;
; 6298 :             if (pixel[3] != 0 && pixel[3] != 255) {
; 6299 :                float a = pixel[3] / 255.0f;
; 6300 :                float ra = 1.0f / a;
; 6301 :                float inv_a = 255.0f * (1 - ra);
; 6302 :                pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
; 6303 :                pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
; 6304 :                pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
; 6305 :             }
; 6306 :          }
; 6307 :       }
; 6308 :    }
; 6309 : 
; 6310 :    // convert to desired output format
; 6311 :    if (req_comp && req_comp != 4) {
; 6312 :       if (ri->bits_per_channel == 16)
; 6313 :          out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
; 6314 :       else
; 6315 :          out = stbi__convert_format(out, 4, req_comp, w, h);
; 6316 :       if (out == NULL) return out; // stbi__convert_format frees input on failure
; 6317 :    }
; 6318 : 
; 6319 :    if (comp) *comp = 4;
; 6320 :    *y = h;
; 6321 :    *x = w;
; 6322 : 
; 6323 :    return out;
; 6324 : }
; 6325 : #endif
; 6326 : 
; 6327 : // *************************************************************************************************
; 6328 : // Softimage PIC loader
; 6329 : // by Tom Seddon
; 6330 : //
; 6331 : // See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
; 6332 : // See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/
; 6333 : 
; 6334 : #ifndef STBI_NO_PIC
; 6335 : static int stbi__pic_is4(stbi__context *s,const char *str)
; 6336 : {
; 6337 :    int i;
; 6338 :    for (i=0; i<4; ++i)
; 6339 :       if (stbi__get8(s) != (stbi_uc)str[i])
; 6340 :          return 0;
; 6341 : 
; 6342 :    return 1;
; 6343 : }
; 6344 : 
; 6345 : static int stbi__pic_test_core(stbi__context *s)
; 6346 : {
; 6347 :    int i;
; 6348 : 
; 6349 :    if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
; 6350 :       return 0;
; 6351 : 
; 6352 :    for(i=0;i<84;++i)
; 6353 :       stbi__get8(s);
; 6354 : 
; 6355 :    if (!stbi__pic_is4(s,"PICT"))
; 6356 :       return 0;
; 6357 : 
; 6358 :    return 1;
; 6359 : }
; 6360 : 
; 6361 : typedef struct
; 6362 : {
; 6363 :    stbi_uc size,type,channel;
; 6364 : } stbi__pic_packet;
; 6365 : 
; 6366 : static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
; 6367 : {
; 6368 :    int mask=0x80, i;
; 6369 : 
; 6370 :    for (i=0; i<4; ++i, mask>>=1) {
; 6371 :       if (channel & mask) {
; 6372 :          if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
; 6373 :          dest[i]=stbi__get8(s);
; 6374 :       }
; 6375 :    }
; 6376 : 
; 6377 :    return dest;
; 6378 : }
; 6379 : 
; 6380 : static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
; 6381 : {
; 6382 :    int mask=0x80,i;
; 6383 : 
; 6384 :    for (i=0;i<4; ++i, mask>>=1)
; 6385 :       if (channel&mask)

	test	sil, 64					; 00000040H
	je	SHORT $LN157@stbi__pic_

; 6386 :          dest[i]=src[i];

	mov	BYTE PTR [rbx+1], r9b
$LN157@stbi__pic_:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;
; 1636 : }
; 1637 : #endif
; 1638 : 
; 1639 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
; 1640 : // nothing
; 1641 : #else
; 1642 : static void stbi__skip(stbi__context *s, int n)
; 1643 : {
; 1644 :    if (n == 0) return;  // already there!
; 1645 :    if (n < 0) {
; 1646 :       s->img_buffer = s->img_buffer_end;
; 1647 :       return;
; 1648 :    }
; 1649 :    if (s->io.read) {
; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1651 :       if (blen < n) {
; 1652 :          s->img_buffer = s->img_buffer_end;
; 1653 :          (s->io.skip)(s->io_user_data, n - blen);
; 1654 :          return;
; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;
; 1658 : }
; 1659 : #endif
; 1660 : 
; 1661 : #if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
; 1662 : // nothing
; 1663 : #else
; 1664 : static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
; 1665 : {
; 1666 :    if (s->io.read) {
; 1667 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1668 :       if (blen < n) {
; 1669 :          int res, count;
; 1670 : 
; 1671 :          memcpy(buffer, s->img_buffer, blen);
; 1672 : 
; 1673 :          count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
; 1674 :          res = (count == (n-blen));
; 1675 :          s->img_buffer = s->img_buffer_end;
; 1676 :          return res;
; 1677 :       }
; 1678 :    }
; 1679 : 
; 1680 :    if (s->img_buffer+n <= s->img_buffer_end) {
; 1681 :       memcpy(buffer, s->img_buffer, n);
; 1682 :       s->img_buffer += n;
; 1683 :       return 1;
; 1684 :    } else
; 1685 :       return 0;
; 1686 : }
; 1687 : #endif
; 1688 : 
; 1689 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1690 : // nothing
; 1691 : #else
; 1692 : static int stbi__get16be(stbi__context *s)
; 1693 : {
; 1694 :    int z = stbi__get8(s);
; 1695 :    return (z << 8) + stbi__get8(s);
; 1696 : }
; 1697 : #endif
; 1698 : 
; 1699 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1700 : // nothing
; 1701 : #else
; 1702 : static stbi__uint32 stbi__get32be(stbi__context *s)
; 1703 : {
; 1704 :    stbi__uint32 z = stbi__get16be(s);
; 1705 :    return (z << 16) + stbi__get16be(s);
; 1706 : }
; 1707 : #endif
; 1708 : 
; 1709 : #if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
; 1710 : // nothing
; 1711 : #else
; 1712 : static int stbi__get16le(stbi__context *s)
; 1713 : {
; 1714 :    int z = stbi__get8(s);
; 1715 :    return z + (stbi__get8(s) << 8);
; 1716 : }
; 1717 : #endif
; 1718 : 
; 1719 : #ifndef STBI_NO_BMP
; 1720 : static stbi__uint32 stbi__get32le(stbi__context *s)
; 1721 : {
; 1722 :    stbi__uint32 z = stbi__get16le(s);
; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;
; 1724 :    return z;
; 1725 : }
; 1726 : #endif
; 1727 : 
; 1728 : #define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
; 1729 : 
; 1730 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1731 : // nothing
; 1732 : #else
; 1733 : //////////////////////////////////////////////////////////////////////////////
; 1734 : //
; 1735 : //  generic converter from built-in img_n to req_comp
; 1736 : //    individual types do this automatically as much as possible (e.g. jpeg
; 1737 : //    does all cases internally since it needs to colorspace convert anyway,
; 1738 : //    and it never has alpha, so very few cases ). png can automatically
; 1739 : //    interleave an alpha=255 channel, but falls back to this for other cases
; 1740 : //
; 1741 : //  assume data buffer is malloced, so malloc a new one and free that one
; 1742 : //  only failure mode is malloc failing
; 1743 : 
; 1744 : static stbi_uc stbi__compute_y(int r, int g, int b)
; 1745 : {
; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1747 : }
; 1748 : #endif
; 1749 : 
; 1750 : #if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1751 : // nothing
; 1752 : #else
; 1753 : static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1754 : {
; 1755 :    int i,j;
; 1756 :    unsigned char *good;
; 1757 : 
; 1758 :    if (req_comp == img_n) return data;
; 1759 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1760 : 
; 1761 :    good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
; 1762 :    if (good == NULL) {
; 1763 :       STBI_FREE(data);
; 1764 :       return stbi__errpuc("outofmem", "Out of memory");
; 1765 :    }
; 1766 : 
; 1767 :    for (j=0; j < (int) y; ++j) {
; 1768 :       unsigned char *src  = data + j * x * img_n   ;
; 1769 :       unsigned char *dest = good + j * x * req_comp;
; 1770 : 
; 1771 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1772 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1773 :       // convert source image with img_n components to one with req_comp components;
; 1774 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1775 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1776 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
; 1777 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1778 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
; 1779 :          STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
; 1780 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1781 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
; 1782 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
; 1783 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1784 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
; 1785 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1786 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1787 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
; 1788 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
; 1789 :       }
; 1790 :       #undef STBI__CASE
; 1791 :    }
; 1792 : 
; 1793 :    STBI_FREE(data);
; 1794 :    return good;
; 1795 : }
; 1796 : #endif
; 1797 : 
; 1798 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1799 : // nothing
; 1800 : #else
; 1801 : static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
; 1802 : {
; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1804 : }
; 1805 : #endif
; 1806 : 
; 1807 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1808 : // nothing
; 1809 : #else
; 1810 : static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1811 : {
; 1812 :    int i,j;
; 1813 :    stbi__uint16 *good;
; 1814 : 
; 1815 :    if (req_comp == img_n) return data;
; 1816 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1817 : 
; 1818 :    good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
; 1819 :    if (good == NULL) {
; 1820 :       STBI_FREE(data);
; 1821 :       return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1822 :    }
; 1823 : 
; 1824 :    for (j=0; j < (int) y; ++j) {
; 1825 :       stbi__uint16 *src  = data + j * x * img_n   ;
; 1826 :       stbi__uint16 *dest = good + j * x * req_comp;
; 1827 : 
; 1828 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1829 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1830 :       // convert source image with img_n components to one with req_comp components;
; 1831 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1832 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1833 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
; 1834 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1835 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
; 1836 :          STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
; 1837 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1838 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
; 1839 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
; 1840 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1841 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
; 1842 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1843 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1844 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
; 1845 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
; 1846 :       }
; 1847 :       #undef STBI__CASE
; 1848 :    }
; 1849 : 
; 1850 :    STBI_FREE(data);
; 1851 :    return good;
; 1852 : }
; 1853 : #endif
; 1854 : 
; 1855 : #ifndef STBI_NO_LINEAR
; 1856 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
; 1857 : {
; 1858 :    int i,k,n;
; 1859 :    float *output;
; 1860 :    if (!data) return NULL;
; 1861 :    output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
; 1862 :    if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
; 1863 :    // compute number of non-alpha components
; 1864 :    if (comp & 1) n = comp; else n = comp-1;
; 1865 :    for (i=0; i < x*y; ++i) {
; 1866 :       for (k=0; k < n; ++k) {
; 1867 :          output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
; 1868 :       }
; 1869 :    }
; 1870 :    if (n < comp) {
; 1871 :       for (i=0; i < x*y; ++i) {
; 1872 :          output[i*comp + n] = data[i*comp + n]/255.0f;
; 1873 :       }
; 1874 :    }
; 1875 :    STBI_FREE(data);
; 1876 :    return output;
; 1877 : }
; 1878 : #endif
; 1879 : 
; 1880 : #ifndef STBI_NO_HDR
; 1881 : #define stbi__float2int(x)   ((int) (x))
; 1882 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
; 1883 : {
; 1884 :    int i,k,n;
; 1885 :    stbi_uc *output;
; 1886 :    if (!data) return NULL;
; 1887 :    output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
; 1888 :    if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
; 1889 :    // compute number of non-alpha components
; 1890 :    if (comp & 1) n = comp; else n = comp-1;
; 1891 :    for (i=0; i < x*y; ++i) {
; 1892 :       for (k=0; k < n; ++k) {
; 1893 :          float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
; 1894 :          if (z < 0) z = 0;
; 1895 :          if (z > 255) z = 255;
; 1896 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1897 :       }
; 1898 :       if (k < comp) {
; 1899 :          float z = data[i*comp+k] * 255 + 0.5f;
; 1900 :          if (z < 0) z = 0;
; 1901 :          if (z > 255) z = 255;
; 1902 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1903 :       }
; 1904 :    }
; 1905 :    STBI_FREE(data);
; 1906 :    return output;
; 1907 : }
; 1908 : #endif
; 1909 : 
; 1910 : //////////////////////////////////////////////////////////////////////////////
; 1911 : //
; 1912 : //  "baseline" JPEG/JFIF decoder
; 1913 : //
; 1914 : //    simple implementation
; 1915 : //      - doesn't support delayed output of y-dimension
; 1916 : //      - simple interface (only one output format: 8-bit interleaved RGB)
; 1917 : //      - doesn't try to recover corrupt jpegs
; 1918 : //      - doesn't allow partial loading, loading multiple at once
; 1919 : //      - still fast on x86 (copying globals into locals doesn't help x86)
; 1920 : //      - allocates lots of intermediate memory (full size of all components)
; 1921 : //        - non-interleaved case requires this anyway
; 1922 : //        - allows good upsampling (see next)
; 1923 : //    high-quality
; 1924 : //      - upsampled channels are bilinearly interpolated, even across blocks
; 1925 : //      - quality integer IDCT derived from IJG's 'slow'
; 1926 : //    performance
; 1927 : //      - fast huffman; reasonable integer IDCT
; 1928 : //      - some SIMD kernels for common paths on targets with SSE2/NEON
; 1929 : //      - uses a lot of intermediate memory, could cache poorly
; 1930 : 
; 1931 : #ifndef STBI_NO_JPEG
; 1932 : 
; 1933 : // huffman decoding acceleration
; 1934 : #define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
; 1935 : 
; 1936 : typedef struct
; 1937 : {
; 1938 :    stbi_uc  fast[1 << FAST_BITS];
; 1939 :    // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
; 1940 :    stbi__uint16 code[256];
; 1941 :    stbi_uc  values[256];
; 1942 :    stbi_uc  size[257];
; 1943 :    unsigned int maxcode[18];
; 1944 :    int    delta[17];   // old 'firstsymbol' - old 'firstcode'
; 1945 : } stbi__huffman;
; 1946 : 
; 1947 : typedef struct
; 1948 : {
; 1949 :    stbi__context *s;
; 1950 :    stbi__huffman huff_dc[4];
; 1951 :    stbi__huffman huff_ac[4];
; 1952 :    stbi__uint16 dequant[4][64];
; 1953 :    stbi__int16 fast_ac[4][1 << FAST_BITS];
; 1954 : 
; 1955 : // sizes for components, interleaved MCUs
; 1956 :    int img_h_max, img_v_max;
; 1957 :    int img_mcu_x, img_mcu_y;
; 1958 :    int img_mcu_w, img_mcu_h;
; 1959 : 
; 1960 : // definition of jpeg image component
; 1961 :    struct
; 1962 :    {
; 1963 :       int id;
; 1964 :       int h,v;
; 1965 :       int tq;
; 1966 :       int hd,ha;
; 1967 :       int dc_pred;
; 1968 : 
; 1969 :       int x,y,w2,h2;
; 1970 :       stbi_uc *data;
; 1971 :       void *raw_data, *raw_coeff;
; 1972 :       stbi_uc *linebuf;
; 1973 :       short   *coeff;   // progressive only
; 1974 :       int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
; 1975 :    } img_comp[4];
; 1976 : 
; 1977 :    stbi__uint32   code_buffer; // jpeg entropy-coded buffer
; 1978 :    int            code_bits;   // number of valid bits
; 1979 :    unsigned char  marker;      // marker seen while filling entropy buffer
; 1980 :    int            nomore;      // flag if we saw a marker so must stop
; 1981 : 
; 1982 :    int            progressive;
; 1983 :    int            spec_start;
; 1984 :    int            spec_end;
; 1985 :    int            succ_high;
; 1986 :    int            succ_low;
; 1987 :    int            eob_run;
; 1988 :    int            jfif;
; 1989 :    int            app14_color_transform; // Adobe APP14 tag
; 1990 :    int            rgb;
; 1991 : 
; 1992 :    int scan_n, order[4];
; 1993 :    int restart_interval, todo;
; 1994 : 
; 1995 : // kernels
; 1996 :    void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
; 1997 :    void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
; 1998 :    stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
; 1999 : } stbi__jpeg;
; 2000 : 
; 2001 : static int stbi__build_huffman(stbi__huffman *h, int *count)
; 2002 : {
; 2003 :    int i,j,k=0;
; 2004 :    unsigned int code;
; 2005 :    // build size list for each symbol (from JPEG spec)
; 2006 :    for (i=0; i < 16; ++i) {
; 2007 :       for (j=0; j < count[i]; ++j) {
; 2008 :          h->size[k++] = (stbi_uc) (i+1);
; 2009 :          if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");
; 2010 :       }
; 2011 :    }
; 2012 :    h->size[k] = 0;
; 2013 : 
; 2014 :    // compute actual symbols (from jpeg spec)
; 2015 :    code = 0;
; 2016 :    k = 0;
; 2017 :    for(j=1; j <= 16; ++j) {
; 2018 :       // compute delta to add to code to compute symbol id
; 2019 :       h->delta[j] = k - code;
; 2020 :       if (h->size[k] == j) {
; 2021 :          while (h->size[k] == j)
; 2022 :             h->code[k++] = (stbi__uint16) (code++);
; 2023 :          if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
; 2024 :       }
; 2025 :       // compute largest code + 1 for this size, preshifted as needed later
; 2026 :       h->maxcode[j] = code << (16-j);
; 2027 :       code <<= 1;
; 2028 :    }
; 2029 :    h->maxcode[j] = 0xffffffff;
; 2030 : 
; 2031 :    // build non-spec acceleration table; 255 is flag for not-accelerated
; 2032 :    memset(h->fast, 255, 1 << FAST_BITS);
; 2033 :    for (i=0; i < k; ++i) {
; 2034 :       int s = h->size[i];
; 2035 :       if (s <= FAST_BITS) {
; 2036 :          int c = h->code[i] << (FAST_BITS-s);
; 2037 :          int m = 1 << (FAST_BITS-s);
; 2038 :          for (j=0; j < m; ++j) {
; 2039 :             h->fast[c+j] = (stbi_uc) i;
; 2040 :          }
; 2041 :       }
; 2042 :    }
; 2043 :    return 1;
; 2044 : }
; 2045 : 
; 2046 : // build a table that decodes both magnitude and value of small ACs in
; 2047 : // one go.
; 2048 : static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
; 2049 : {
; 2050 :    int i;
; 2051 :    for (i=0; i < (1 << FAST_BITS); ++i) {
; 2052 :       stbi_uc fast = h->fast[i];
; 2053 :       fast_ac[i] = 0;
; 2054 :       if (fast < 255) {
; 2055 :          int rs = h->values[fast];
; 2056 :          int run = (rs >> 4) & 15;
; 2057 :          int magbits = rs & 15;
; 2058 :          int len = h->size[fast];
; 2059 : 
; 2060 :          if (magbits && len + magbits <= FAST_BITS) {
; 2061 :             // magnitude code followed by receive_extend code
; 2062 :             int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
; 2063 :             int m = 1 << (magbits - 1);
; 2064 :             if (k < m) k += (~0U << magbits) + 1;
; 2065 :             // if the result is small enough, we can fit it in fast_ac table
; 2066 :             if (k >= -128 && k <= 127)
; 2067 :                fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
; 2068 :          }
; 2069 :       }
; 2070 :    }
; 2071 : }
; 2072 : 
; 2073 : static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
; 2074 : {
; 2075 :    do {
; 2076 :       unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
; 2077 :       if (b == 0xff) {
; 2078 :          int c = stbi__get8(j->s);
; 2079 :          while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
; 2080 :          if (c != 0) {
; 2081 :             j->marker = (unsigned char) c;
; 2082 :             j->nomore = 1;
; 2083 :             return;
; 2084 :          }
; 2085 :       }
; 2086 :       j->code_buffer |= b << (24 - j->code_bits);
; 2087 :       j->code_bits += 8;
; 2088 :    } while (j->code_bits <= 24);
; 2089 : }
; 2090 : 
; 2091 : // (1 << n) - 1
; 2092 : static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
; 2093 : 
; 2094 : // decode a jpeg huffman value from the bitstream
; 2095 : stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
; 2096 : {
; 2097 :    unsigned int temp;
; 2098 :    int c,k;
; 2099 : 
; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2105 :    k = h->fast[c];
; 2106 :    if (k < 255) {
; 2107 :       int s = h->size[k];
; 2108 :       if (s > j->code_bits)
; 2109 :          return -1;
; 2110 :       j->code_buffer <<= s;
; 2111 :       j->code_bits -= s;
; 2112 :       return h->values[k];
; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;
; 2122 :    for (k=FAST_BITS+1 ; ; ++k)
; 2123 :       if (temp < h->maxcode[k])
; 2124 :          break;
; 2125 :    if (k == 17) {
; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;
; 2128 :       return -1;
; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)
; 2132 :       return -1;
; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!
; 2137 :        return -1;
; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;
; 2142 :    j->code_buffer <<= k;
; 2143 :    return h->values[c];
; 2144 : }
; 2145 : 
; 2146 : // bias[n] = (-1<<n) + 1
; 2147 : static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};
; 2148 : 
; 2149 : // combined JPEG 'receive' and JPEG 'extend', since baseline
; 2150 : // always extends everything it receives.
; 2151 : stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
; 2152 : {
; 2153 :    unsigned int k;
; 2154 :    int sgn;
; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
; 2159 :    k = stbi_lrot(j->code_buffer, n);
; 2160 :    j->code_buffer = k & ~stbi__bmask[n];
; 2161 :    k &= stbi__bmask[n];
; 2162 :    j->code_bits -= n;
; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));
; 2164 : }
; 2165 : 
; 2166 : // get some unsigned bits
; 2167 : stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
; 2168 : {
; 2169 :    unsigned int k;
; 2170 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2171 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2172 :    k = stbi_lrot(j->code_buffer, n);
; 2173 :    j->code_buffer = k & ~stbi__bmask[n];
; 2174 :    k &= stbi__bmask[n];
; 2175 :    j->code_bits -= n;
; 2176 :    return k;
; 2177 : }
; 2178 : 
; 2179 : stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
; 2180 : {
; 2181 :    unsigned int k;
; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2184 :    k = j->code_buffer;
; 2185 :    j->code_buffer <<= 1;
; 2186 :    --j->code_bits;
; 2187 :    return k & 0x80000000;
; 2188 : }
; 2189 : 
; 2190 : // given a value that's at position X in the zigzag stream,
; 2191 : // where does it appear in the 8x8 matrix coded as row-major?
; 2192 : static const stbi_uc stbi__jpeg_dezigzag[64+15] =
; 2193 : {
; 2194 :     0,  1,  8, 16,  9,  2,  3, 10,
; 2195 :    17, 24, 32, 25, 18, 11,  4,  5,
; 2196 :    12, 19, 26, 33, 40, 48, 41, 34,
; 2197 :    27, 20, 13,  6,  7, 14, 21, 28,
; 2198 :    35, 42, 49, 56, 57, 50, 43, 36,
; 2199 :    29, 22, 15, 23, 30, 37, 44, 51,
; 2200 :    58, 59, 52, 45, 38, 31, 39, 46,
; 2201 :    53, 60, 61, 54, 47, 55, 62, 63,
; 2202 :    // let corrupt input sample past end
; 2203 :    63, 63, 63, 63, 63, 63, 63, 63,
; 2204 :    63, 63, 63, 63, 63, 63, 63
; 2205 : };
; 2206 : 
; 2207 : // decode one 64-entry block--
; 2208 : static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
; 2209 : {
; 2210 :    int diff,dc,k;
; 2211 :    int t;
; 2212 : 
; 2213 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2214 :    t = stbi__jpeg_huff_decode(j, hdc);
; 2215 :    if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");
; 2216 : 
; 2217 :    // 0 all the ac values now so we can do it 32-bits at a time
; 2218 :    memset(data,0,64*sizeof(data[0]));
; 2219 : 
; 2220 :    diff = t ? stbi__extend_receive(j, t) : 0;
; 2221 :    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");
; 2222 :    dc = j->img_comp[b].dc_pred + diff;
; 2223 :    j->img_comp[b].dc_pred = dc;
; 2224 :    if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2225 :    data[0] = (short) (dc * dequant[0]);
; 2226 : 
; 2227 :    // decode AC components, see JPEG spec
; 2228 :    k = 1;
; 2229 :    do {
; 2230 :       unsigned int zig;
; 2231 :       int c,r,s;
; 2232 :       if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2233 :       c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2234 :       r = fac[c];
; 2235 :       if (r) { // fast-AC path
; 2236 :          k += (r >> 4) & 15; // run
; 2237 :          s = r & 15; // combined length
; 2238 :          if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2239 :          j->code_buffer <<= s;
; 2240 :          j->code_bits -= s;
; 2241 :          // decode into unzigzag'd location
; 2242 :          zig = stbi__jpeg_dezigzag[k++];
; 2243 :          data[zig] = (short) ((r >> 8) * dequant[zig]);
; 2244 :       } else {
; 2245 :          int rs = stbi__jpeg_huff_decode(j, hac);
; 2246 :          if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2247 :          s = rs & 15;
; 2248 :          r = rs >> 4;
; 2249 :          if (s == 0) {
; 2250 :             if (rs != 0xf0) break; // end block
; 2251 :             k += 16;
; 2252 :          } else {
; 2253 :             k += r;
; 2254 :             // decode into unzigzag'd location
; 2255 :             zig = stbi__jpeg_dezigzag[k++];
; 2256 :             data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
; 2257 :          }
; 2258 :       }
; 2259 :    } while (k < 64);
; 2260 :    return 1;
; 2261 : }
; 2262 : 
; 2263 : static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
; 2264 : {
; 2265 :    int diff,dc;
; 2266 :    int t;
; 2267 :    if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2268 : 
; 2269 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2270 : 
; 2271 :    if (j->succ_high == 0) {
; 2272 :       // first scan for DC coefficient, must be first
; 2273 :       memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
; 2274 :       t = stbi__jpeg_huff_decode(j, hdc);
; 2275 :       if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2276 :       diff = t ? stbi__extend_receive(j, t) : 0;
; 2277 : 
; 2278 :       if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");
; 2279 :       dc = j->img_comp[b].dc_pred + diff;
; 2280 :       j->img_comp[b].dc_pred = dc;
; 2281 :       if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2282 :       data[0] = (short) (dc * (1 << j->succ_low));
; 2283 :    } else {
; 2284 :       // refinement scan for DC coefficient
; 2285 :       if (stbi__jpeg_get_bit(j))
; 2286 :          data[0] += (short) (1 << j->succ_low);
; 2287 :    }
; 2288 :    return 1;
; 2289 : }
; 2290 : 
; 2291 : // @OPTIMIZE: store non-zigzagged during the decode passes,
; 2292 : // and only de-zigzag when dequantizing
; 2293 : static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
; 2294 : {
; 2295 :    int k;
; 2296 :    if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2297 : 
; 2298 :    if (j->succ_high == 0) {
; 2299 :       int shift = j->succ_low;
; 2300 : 
; 2301 :       if (j->eob_run) {
; 2302 :          --j->eob_run;
; 2303 :          return 1;
; 2304 :       }
; 2305 : 
; 2306 :       k = j->spec_start;
; 2307 :       do {
; 2308 :          unsigned int zig;
; 2309 :          int c,r,s;
; 2310 :          if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2311 :          c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2312 :          r = fac[c];
; 2313 :          if (r) { // fast-AC path
; 2314 :             k += (r >> 4) & 15; // run
; 2315 :             s = r & 15; // combined length
; 2316 :             if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2317 :             j->code_buffer <<= s;
; 2318 :             j->code_bits -= s;
; 2319 :             zig = stbi__jpeg_dezigzag[k++];
; 2320 :             data[zig] = (short) ((r >> 8) * (1 << shift));
; 2321 :          } else {
; 2322 :             int rs = stbi__jpeg_huff_decode(j, hac);
; 2323 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2324 :             s = rs & 15;
; 2325 :             r = rs >> 4;
; 2326 :             if (s == 0) {
; 2327 :                if (r < 15) {
; 2328 :                   j->eob_run = (1 << r);
; 2329 :                   if (r)
; 2330 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2331 :                   --j->eob_run;
; 2332 :                   break;
; 2333 :                }
; 2334 :                k += 16;
; 2335 :             } else {
; 2336 :                k += r;
; 2337 :                zig = stbi__jpeg_dezigzag[k++];
; 2338 :                data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
; 2339 :             }
; 2340 :          }
; 2341 :       } while (k <= j->spec_end);
; 2342 :    } else {
; 2343 :       // refinement scan for these AC coefficients
; 2344 : 
; 2345 :       short bit = (short) (1 << j->succ_low);
; 2346 : 
; 2347 :       if (j->eob_run) {
; 2348 :          --j->eob_run;
; 2349 :          for (k = j->spec_start; k <= j->spec_end; ++k) {
; 2350 :             short *p = &data[stbi__jpeg_dezigzag[k]];
; 2351 :             if (*p != 0)
; 2352 :                if (stbi__jpeg_get_bit(j))
; 2353 :                   if ((*p & bit)==0) {
; 2354 :                      if (*p > 0)
; 2355 :                         *p += bit;
; 2356 :                      else
; 2357 :                         *p -= bit;
; 2358 :                   }
; 2359 :          }
; 2360 :       } else {
; 2361 :          k = j->spec_start;
; 2362 :          do {
; 2363 :             int r,s;
; 2364 :             int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
; 2365 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2366 :             s = rs & 15;
; 2367 :             r = rs >> 4;
; 2368 :             if (s == 0) {
; 2369 :                if (r < 15) {
; 2370 :                   j->eob_run = (1 << r) - 1;
; 2371 :                   if (r)
; 2372 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2373 :                   r = 64; // force end of block
; 2374 :                } else {
; 2375 :                   // r=15 s=0 should write 16 0s, so we just do
; 2376 :                   // a run of 15 0s and then write s (which is 0),
; 2377 :                   // so we don't have to do anything special here
; 2378 :                }
; 2379 :             } else {
; 2380 :                if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
; 2381 :                // sign bit
; 2382 :                if (stbi__jpeg_get_bit(j))
; 2383 :                   s = bit;
; 2384 :                else
; 2385 :                   s = -bit;
; 2386 :             }
; 2387 : 
; 2388 :             // advance by r
; 2389 :             while (k <= j->spec_end) {
; 2390 :                short *p = &data[stbi__jpeg_dezigzag[k++]];
; 2391 :                if (*p != 0) {
; 2392 :                   if (stbi__jpeg_get_bit(j))
; 2393 :                      if ((*p & bit)==0) {
; 2394 :                         if (*p > 0)
; 2395 :                            *p += bit;
; 2396 :                         else
; 2397 :                            *p -= bit;
; 2398 :                      }
; 2399 :                } else {
; 2400 :                   if (r == 0) {
; 2401 :                      *p = (short) s;
; 2402 :                      break;
; 2403 :                   }
; 2404 :                   --r;
; 2405 :                }
; 2406 :             }
; 2407 :          } while (k <= j->spec_end);
; 2408 :       }
; 2409 :    }
; 2410 :    return 1;
; 2411 : }
; 2412 : 
; 2413 : // take a -128..127 value and stbi__clamp it and convert to 0..255
; 2414 : stbi_inline static stbi_uc stbi__clamp(int x)
; 2415 : {
; 2416 :    // trick to use a single test to catch both cases
; 2417 :    if ((unsigned int) x > 255) {
; 2418 :       if (x < 0) return 0;
; 2419 :       if (x > 255) return 255;
; 2420 :    }
; 2421 :    return (stbi_uc) x;
; 2422 : }
; 2423 : 
; 2424 : #define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
; 2425 : #define stbi__fsh(x)  ((x) * 4096)
; 2426 : 
; 2427 : // derived from jidctint -- DCT_ISLOW
; 2428 : #define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
; 2429 :    int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
; 2430 :    p2 = s2;                                    \
; 2431 :    p3 = s6;                                    \
; 2432 :    p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
; 2433 :    t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
; 2434 :    t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
; 2435 :    p2 = s0;                                    \
; 2436 :    p3 = s4;                                    \
; 2437 :    t0 = stbi__fsh(p2+p3);                      \
; 2438 :    t1 = stbi__fsh(p2-p3);                      \
; 2439 :    x0 = t0+t3;                                 \
; 2440 :    x3 = t0-t3;                                 \
; 2441 :    x1 = t1+t2;                                 \
; 2442 :    x2 = t1-t2;                                 \
; 2443 :    t0 = s7;                                    \
; 2444 :    t1 = s5;                                    \
; 2445 :    t2 = s3;                                    \
; 2446 :    t3 = s1;                                    \
; 2447 :    p3 = t0+t2;                                 \
; 2448 :    p4 = t1+t3;                                 \
; 2449 :    p1 = t0+t3;                                 \
; 2450 :    p2 = t1+t2;                                 \
; 2451 :    p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
; 2452 :    t0 = t0*stbi__f2f( 0.298631336f);           \
; 2453 :    t1 = t1*stbi__f2f( 2.053119869f);           \
; 2454 :    t2 = t2*stbi__f2f( 3.072711026f);           \
; 2455 :    t3 = t3*stbi__f2f( 1.501321110f);           \
; 2456 :    p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
; 2457 :    p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
; 2458 :    p3 = p3*stbi__f2f(-1.961570560f);           \
; 2459 :    p4 = p4*stbi__f2f(-0.390180644f);           \
; 2460 :    t3 += p1+p4;                                \
; 2461 :    t2 += p2+p3;                                \
; 2462 :    t1 += p2+p4;                                \
; 2463 :    t0 += p1+p3;
; 2464 : 
; 2465 : static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
; 2466 : {
; 2467 :    int i,val[64],*v=val;
; 2468 :    stbi_uc *o;
; 2469 :    short *d = data;
; 2470 : 
; 2471 :    // columns
; 2472 :    for (i=0; i < 8; ++i,++d, ++v) {
; 2473 :       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2474 :       if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2475 :            && d[40]==0 && d[48]==0 && d[56]==0) {
; 2476 :          //    no shortcut                 0     seconds
; 2477 :          //    (1|2|3|4|5|6|7)==0          0     seconds
; 2478 :          //    all separate               -0.047 seconds
; 2479 :          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2480 :          int dcterm = d[0]*4;
; 2481 :          v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
; 2482 :       } else {
; 2483 :          STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
; 2484 :          // constants scaled things up by 1<<12; let's bring them back
; 2485 :          // down, but keep 2 extra bits of precision
; 2486 :          x0 += 512; x1 += 512; x2 += 512; x3 += 512;
; 2487 :          v[ 0] = (x0+t3) >> 10;
; 2488 :          v[56] = (x0-t3) >> 10;
; 2489 :          v[ 8] = (x1+t2) >> 10;
; 2490 :          v[48] = (x1-t2) >> 10;
; 2491 :          v[16] = (x2+t1) >> 10;
; 2492 :          v[40] = (x2-t1) >> 10;
; 2493 :          v[24] = (x3+t0) >> 10;
; 2494 :          v[32] = (x3-t0) >> 10;
; 2495 :       }
; 2496 :    }
; 2497 : 
; 2498 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
; 2499 :       // no fast case since the first 1D IDCT spread components out
; 2500 :       STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
; 2501 :       // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2502 :       // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2503 :       // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2504 :       // so we want to round that, which means adding 0.5 * 1<<17,
; 2505 :       // aka 65536. Also, we'll end up with -128 to 127 that we want
; 2506 :       // to encode as 0..255 by adding 128, so we'll add that before the shift
; 2507 :       x0 += 65536 + (128<<17);
; 2508 :       x1 += 65536 + (128<<17);
; 2509 :       x2 += 65536 + (128<<17);
; 2510 :       x3 += 65536 + (128<<17);
; 2511 :       // tried computing the shifts into temps, or'ing the temps to see
; 2512 :       // if any were out of range, but that was slower
; 2513 :       o[0] = stbi__clamp((x0+t3) >> 17);
; 2514 :       o[7] = stbi__clamp((x0-t3) >> 17);
; 2515 :       o[1] = stbi__clamp((x1+t2) >> 17);
; 2516 :       o[6] = stbi__clamp((x1-t2) >> 17);
; 2517 :       o[2] = stbi__clamp((x2+t1) >> 17);
; 2518 :       o[5] = stbi__clamp((x2-t1) >> 17);
; 2519 :       o[3] = stbi__clamp((x3+t0) >> 17);
; 2520 :       o[4] = stbi__clamp((x3-t0) >> 17);
; 2521 :    }
; 2522 : }
; 2523 : 
; 2524 : #ifdef STBI_SSE2
; 2525 : // sse2 integer IDCT. not the fastest possible implementation but it
; 2526 : // produces bit-identical results to the generic C version so it's
; 2527 : // fully "transparent".
; 2528 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2529 : {
; 2530 :    // This is constructed to match our regular (generic) integer IDCT exactly.
; 2531 :    __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2532 :    __m128i tmp;
; 2533 : 
; 2534 :    // dot product constant: even elems=x, odd elems=y
; 2535 :    #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2536 : 
; 2537 :    // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2538 :    // out(1) = c1[even]*x + c1[odd]*y
; 2539 :    #define dct_rot(out0,out1, x,y,c0,c1) \
; 2540 :       __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2541 :       __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2542 :       __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2543 :       __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2544 :       __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2545 :       __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2546 : 
; 2547 :    // out = in << 12  (in 16-bit, out 32-bit)
; 2548 :    #define dct_widen(out, in) \
; 2549 :       __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2550 :       __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2551 : 
; 2552 :    // wide add
; 2553 :    #define dct_wadd(out, a, b) \
; 2554 :       __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2555 :       __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2556 : 
; 2557 :    // wide sub
; 2558 :    #define dct_wsub(out, a, b) \
; 2559 :       __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2560 :       __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2561 : 
; 2562 :    // butterfly a/b, add bias, then shift by "s" and pack
; 2563 :    #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2564 :       { \
; 2565 :          __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2566 :          __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2567 :          dct_wadd(sum, abiased, b); \
; 2568 :          dct_wsub(dif, abiased, b); \
; 2569 :          out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2570 :          out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2571 :       }
; 2572 : 
; 2573 :    // 8-bit interleave step (for transposes)
; 2574 :    #define dct_interleave8(a, b) \
; 2575 :       tmp = a; \
; 2576 :       a = _mm_unpacklo_epi8(a, b); \
; 2577 :       b = _mm_unpackhi_epi8(tmp, b)
; 2578 : 
; 2579 :    // 16-bit interleave step (for transposes)
; 2580 :    #define dct_interleave16(a, b) \
; 2581 :       tmp = a; \
; 2582 :       a = _mm_unpacklo_epi16(a, b); \
; 2583 :       b = _mm_unpackhi_epi16(tmp, b)
; 2584 : 
; 2585 :    #define dct_pass(bias,shift) \
; 2586 :       { \
; 2587 :          /* even part */ \
; 2588 :          dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2589 :          __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2590 :          __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2591 :          dct_widen(t0e, sum04); \
; 2592 :          dct_widen(t1e, dif04); \
; 2593 :          dct_wadd(x0, t0e, t3e); \
; 2594 :          dct_wsub(x3, t0e, t3e); \
; 2595 :          dct_wadd(x1, t1e, t2e); \
; 2596 :          dct_wsub(x2, t1e, t2e); \
; 2597 :          /* odd part */ \
; 2598 :          dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2599 :          dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2600 :          __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2601 :          __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2602 :          dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2603 :          dct_wadd(x4, y0o, y4o); \
; 2604 :          dct_wadd(x5, y1o, y5o); \
; 2605 :          dct_wadd(x6, y2o, y5o); \
; 2606 :          dct_wadd(x7, y3o, y4o); \
; 2607 :          dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2608 :          dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2609 :          dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2610 :          dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2611 :       }
; 2612 : 
; 2613 :    __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
; 2614 :    __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
; 2615 :    __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
; 2616 :    __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
; 2617 :    __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
; 2618 :    __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
; 2619 :    __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
; 2620 :    __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
; 2621 : 
; 2622 :    // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2623 :    __m128i bias_0 = _mm_set1_epi32(512);
; 2624 :    __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
; 2625 : 
; 2626 :    // load
; 2627 :    row0 = _mm_load_si128((const __m128i *) (data + 0*8));
; 2628 :    row1 = _mm_load_si128((const __m128i *) (data + 1*8));
; 2629 :    row2 = _mm_load_si128((const __m128i *) (data + 2*8));
; 2630 :    row3 = _mm_load_si128((const __m128i *) (data + 3*8));
; 2631 :    row4 = _mm_load_si128((const __m128i *) (data + 4*8));
; 2632 :    row5 = _mm_load_si128((const __m128i *) (data + 5*8));
; 2633 :    row6 = _mm_load_si128((const __m128i *) (data + 6*8));
; 2634 :    row7 = _mm_load_si128((const __m128i *) (data + 7*8));
; 2635 : 
; 2636 :    // column pass
; 2637 :    dct_pass(bias_0, 10);
; 2638 : 
; 2639 :    {
; 2640 :       // 16bit 8x8 transpose pass 1
; 2641 :       dct_interleave16(row0, row4);
; 2642 :       dct_interleave16(row1, row5);
; 2643 :       dct_interleave16(row2, row6);
; 2644 :       dct_interleave16(row3, row7);
; 2645 : 
; 2646 :       // transpose pass 2
; 2647 :       dct_interleave16(row0, row2);
; 2648 :       dct_interleave16(row1, row3);
; 2649 :       dct_interleave16(row4, row6);
; 2650 :       dct_interleave16(row5, row7);
; 2651 : 
; 2652 :       // transpose pass 3
; 2653 :       dct_interleave16(row0, row1);
; 2654 :       dct_interleave16(row2, row3);
; 2655 :       dct_interleave16(row4, row5);
; 2656 :       dct_interleave16(row6, row7);
; 2657 :    }
; 2658 : 
; 2659 :    // row pass
; 2660 :    dct_pass(bias_1, 17);
; 2661 : 
; 2662 :    {
; 2663 :       // pack
; 2664 :       __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
; 2665 :       __m128i p1 = _mm_packus_epi16(row2, row3);
; 2666 :       __m128i p2 = _mm_packus_epi16(row4, row5);
; 2667 :       __m128i p3 = _mm_packus_epi16(row6, row7);
; 2668 : 
; 2669 :       // 8bit 8x8 transpose pass 1
; 2670 :       dct_interleave8(p0, p2); // a0e0a1e1...
; 2671 :       dct_interleave8(p1, p3); // c0g0c1g1...
; 2672 : 
; 2673 :       // transpose pass 2
; 2674 :       dct_interleave8(p0, p1); // a0c0e0g0...
; 2675 :       dct_interleave8(p2, p3); // b0d0f0h0...
; 2676 : 
; 2677 :       // transpose pass 3
; 2678 :       dct_interleave8(p0, p2); // a0b0c0d0...
; 2679 :       dct_interleave8(p1, p3); // a4b4c4d4...
; 2680 : 
; 2681 :       // store
; 2682 :       _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
; 2683 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
; 2684 :       _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
; 2685 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
; 2686 :       _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
; 2687 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
; 2688 :       _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
; 2689 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
; 2690 :    }
; 2691 : 
; 2692 : #undef dct_const
; 2693 : #undef dct_rot
; 2694 : #undef dct_widen
; 2695 : #undef dct_wadd
; 2696 : #undef dct_wsub
; 2697 : #undef dct_bfly32o
; 2698 : #undef dct_interleave8
; 2699 : #undef dct_interleave16
; 2700 : #undef dct_pass
; 2701 : }
; 2702 : 
; 2703 : #endif // STBI_SSE2
; 2704 : 
; 2705 : #ifdef STBI_NEON
; 2706 : 
; 2707 : // NEON integer IDCT. should produce bit-identical
; 2708 : // results to the generic C version.
; 2709 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2710 : {
; 2711 :    int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;
; 2712 : 
; 2713 :    int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
; 2714 :    int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
; 2715 :    int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
; 2716 :    int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
; 2717 :    int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
; 2718 :    int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
; 2719 :    int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
; 2720 :    int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
; 2721 :    int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
; 2722 :    int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
; 2723 :    int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
; 2724 :    int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));
; 2725 : 
; 2726 : #define dct_long_mul(out, inq, coeff) \
; 2727 :    int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
; 2728 :    int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)
; 2729 : 
; 2730 : #define dct_long_mac(out, acc, inq, coeff) \
; 2731 :    int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
; 2732 :    int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)
; 2733 : 
; 2734 : #define dct_widen(out, inq) \
; 2735 :    int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
; 2736 :    int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)
; 2737 : 
; 2738 : // wide add
; 2739 : #define dct_wadd(out, a, b) \
; 2740 :    int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
; 2741 :    int32x4_t out##_h = vaddq_s32(a##_h, b##_h)
; 2742 : 
; 2743 : // wide sub
; 2744 : #define dct_wsub(out, a, b) \
; 2745 :    int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
; 2746 :    int32x4_t out##_h = vsubq_s32(a##_h, b##_h)
; 2747 : 
; 2748 : // butterfly a/b, then shift using "shiftop" by "s" and pack
; 2749 : #define dct_bfly32o(out0,out1, a,b,shiftop,s) \
; 2750 :    { \
; 2751 :       dct_wadd(sum, a, b); \
; 2752 :       dct_wsub(dif, a, b); \
; 2753 :       out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
; 2754 :       out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
; 2755 :    }
; 2756 : 
; 2757 : #define dct_pass(shiftop, shift) \
; 2758 :    { \
; 2759 :       /* even part */ \
; 2760 :       int16x8_t sum26 = vaddq_s16(row2, row6); \
; 2761 :       dct_long_mul(p1e, sum26, rot0_0); \
; 2762 :       dct_long_mac(t2e, p1e, row6, rot0_1); \
; 2763 :       dct_long_mac(t3e, p1e, row2, rot0_2); \
; 2764 :       int16x8_t sum04 = vaddq_s16(row0, row4); \
; 2765 :       int16x8_t dif04 = vsubq_s16(row0, row4); \
; 2766 :       dct_widen(t0e, sum04); \
; 2767 :       dct_widen(t1e, dif04); \
; 2768 :       dct_wadd(x0, t0e, t3e); \
; 2769 :       dct_wsub(x3, t0e, t3e); \
; 2770 :       dct_wadd(x1, t1e, t2e); \
; 2771 :       dct_wsub(x2, t1e, t2e); \
; 2772 :       /* odd part */ \
; 2773 :       int16x8_t sum15 = vaddq_s16(row1, row5); \
; 2774 :       int16x8_t sum17 = vaddq_s16(row1, row7); \
; 2775 :       int16x8_t sum35 = vaddq_s16(row3, row5); \
; 2776 :       int16x8_t sum37 = vaddq_s16(row3, row7); \
; 2777 :       int16x8_t sumodd = vaddq_s16(sum17, sum35); \
; 2778 :       dct_long_mul(p5o, sumodd, rot1_0); \
; 2779 :       dct_long_mac(p1o, p5o, sum17, rot1_1); \
; 2780 :       dct_long_mac(p2o, p5o, sum35, rot1_2); \
; 2781 :       dct_long_mul(p3o, sum37, rot2_0); \
; 2782 :       dct_long_mul(p4o, sum15, rot2_1); \
; 2783 :       dct_wadd(sump13o, p1o, p3o); \
; 2784 :       dct_wadd(sump24o, p2o, p4o); \
; 2785 :       dct_wadd(sump23o, p2o, p3o); \
; 2786 :       dct_wadd(sump14o, p1o, p4o); \
; 2787 :       dct_long_mac(x4, sump13o, row7, rot3_0); \
; 2788 :       dct_long_mac(x5, sump24o, row5, rot3_1); \
; 2789 :       dct_long_mac(x6, sump23o, row3, rot3_2); \
; 2790 :       dct_long_mac(x7, sump14o, row1, rot3_3); \
; 2791 :       dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
; 2792 :       dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
; 2793 :       dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
; 2794 :       dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
; 2795 :    }
; 2796 : 
; 2797 :    // load
; 2798 :    row0 = vld1q_s16(data + 0*8);
; 2799 :    row1 = vld1q_s16(data + 1*8);
; 2800 :    row2 = vld1q_s16(data + 2*8);
; 2801 :    row3 = vld1q_s16(data + 3*8);
; 2802 :    row4 = vld1q_s16(data + 4*8);
; 2803 :    row5 = vld1q_s16(data + 5*8);
; 2804 :    row6 = vld1q_s16(data + 6*8);
; 2805 :    row7 = vld1q_s16(data + 7*8);
; 2806 : 
; 2807 :    // add DC bias
; 2808 :    row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));
; 2809 : 
; 2810 :    // column pass
; 2811 :    dct_pass(vrshrn_n_s32, 10);
; 2812 : 
; 2813 :    // 16bit 8x8 transpose
; 2814 :    {
; 2815 : // these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
; 2816 : // whether compilers actually get this is another story, sadly.
; 2817 : #define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
; 2818 : #define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
; 2819 : #define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }
; 2820 : 
; 2821 :       // pass 1
; 2822 :       dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
; 2823 :       dct_trn16(row2, row3);
; 2824 :       dct_trn16(row4, row5);
; 2825 :       dct_trn16(row6, row7);
; 2826 : 
; 2827 :       // pass 2
; 2828 :       dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
; 2829 :       dct_trn32(row1, row3);
; 2830 :       dct_trn32(row4, row6);
; 2831 :       dct_trn32(row5, row7);
; 2832 : 
; 2833 :       // pass 3
; 2834 :       dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
; 2835 :       dct_trn64(row1, row5);
; 2836 :       dct_trn64(row2, row6);
; 2837 :       dct_trn64(row3, row7);
; 2838 : 
; 2839 : #undef dct_trn16
; 2840 : #undef dct_trn32
; 2841 : #undef dct_trn64
; 2842 :    }
; 2843 : 
; 2844 :    // row pass
; 2845 :    // vrshrn_n_s32 only supports shifts up to 16, we need
; 2846 :    // 17. so do a non-rounding shift of 16 first then follow
; 2847 :    // up with a rounding shift by 1.
; 2848 :    dct_pass(vshrn_n_s32, 16);
; 2849 : 
; 2850 :    {
; 2851 :       // pack and round
; 2852 :       uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
; 2853 :       uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
; 2854 :       uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
; 2855 :       uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
; 2856 :       uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
; 2857 :       uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
; 2858 :       uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
; 2859 :       uint8x8_t p7 = vqrshrun_n_s16(row7, 1);
; 2860 : 
; 2861 :       // again, these can translate into one instruction, but often don't.
; 2862 : #define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
; 2863 : #define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
; 2864 : #define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }
; 2865 : 
; 2866 :       // sadly can't use interleaved stores here since we only write
; 2867 :       // 8 bytes to each scan line!
; 2868 : 
; 2869 :       // 8x8 8-bit transpose pass 1
; 2870 :       dct_trn8_8(p0, p1);
; 2871 :       dct_trn8_8(p2, p3);
; 2872 :       dct_trn8_8(p4, p5);
; 2873 :       dct_trn8_8(p6, p7);
; 2874 : 
; 2875 :       // pass 2
; 2876 :       dct_trn8_16(p0, p2);
; 2877 :       dct_trn8_16(p1, p3);
; 2878 :       dct_trn8_16(p4, p6);
; 2879 :       dct_trn8_16(p5, p7);
; 2880 : 
; 2881 :       // pass 3
; 2882 :       dct_trn8_32(p0, p4);
; 2883 :       dct_trn8_32(p1, p5);
; 2884 :       dct_trn8_32(p2, p6);
; 2885 :       dct_trn8_32(p3, p7);
; 2886 : 
; 2887 :       // store
; 2888 :       vst1_u8(out, p0); out += out_stride;
; 2889 :       vst1_u8(out, p1); out += out_stride;
; 2890 :       vst1_u8(out, p2); out += out_stride;
; 2891 :       vst1_u8(out, p3); out += out_stride;
; 2892 :       vst1_u8(out, p4); out += out_stride;
; 2893 :       vst1_u8(out, p5); out += out_stride;
; 2894 :       vst1_u8(out, p6); out += out_stride;
; 2895 :       vst1_u8(out, p7);
; 2896 : 
; 2897 : #undef dct_trn8_8
; 2898 : #undef dct_trn8_16
; 2899 : #undef dct_trn8_32
; 2900 :    }
; 2901 : 
; 2902 : #undef dct_long_mul
; 2903 : #undef dct_long_mac
; 2904 : #undef dct_widen
; 2905 : #undef dct_wadd
; 2906 : #undef dct_wsub
; 2907 : #undef dct_bfly32o
; 2908 : #undef dct_pass
; 2909 : }
; 2910 : 
; 2911 : #endif // STBI_NEON
; 2912 : 
; 2913 : #define STBI__MARKER_none  0xff
; 2914 : // if there's a pending marker from the entropy stream, return that
; 2915 : // otherwise, fetch from the stream and get a marker. if there's no
; 2916 : // marker, return 0xff, which is never a valid marker value
; 2917 : static stbi_uc stbi__get_marker(stbi__jpeg *j)
; 2918 : {
; 2919 :    stbi_uc x;
; 2920 :    if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
; 2921 :    x = stbi__get8(j->s);
; 2922 :    if (x != 0xff) return STBI__MARKER_none;
; 2923 :    while (x == 0xff)
; 2924 :       x = stbi__get8(j->s); // consume repeated 0xff fill bytes
; 2925 :    return x;
; 2926 : }
; 2927 : 
; 2928 : // in each scan, we'll have scan_n components, and the order
; 2929 : // of the components is specified by order[]
; 2930 : #define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
; 2931 : 
; 2932 : // after a restart interval, stbi__jpeg_reset the entropy decoder and
; 2933 : // the dc prediction
; 2934 : static void stbi__jpeg_reset(stbi__jpeg *j)
; 2935 : {
; 2936 :    j->code_bits = 0;
; 2937 :    j->code_buffer = 0;
; 2938 :    j->nomore = 0;
; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
; 2940 :    j->marker = STBI__MARKER_none;
; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
; 2942 :    j->eob_run = 0;
; 2943 :    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2944 :    // since we don't even allow 1<<30 pixels
; 2945 : }
; 2946 : 
; 2947 : static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
; 2948 : {
; 2949 :    stbi__jpeg_reset(z);
; 2950 :    if (!z->progressive) {
; 2951 :       if (z->scan_n == 1) {
; 2952 :          int i,j;
; 2953 :          STBI_SIMD_ALIGN(short, data[64]);
; 2954 :          int n = z->order[0];
; 2955 :          // non-interleaved data, we just need to process one block at a time,
; 2956 :          // in trivial scanline order
; 2957 :          // number of blocks to do just depends on how many actual "pixels" this
; 2958 :          // component has, independent of interleaved MCU blocking and such
; 2959 :          int w = (z->img_comp[n].x+7) >> 3;
; 2960 :          int h = (z->img_comp[n].y+7) >> 3;
; 2961 :          for (j=0; j < h; ++j) {
; 2962 :             for (i=0; i < w; ++i) {
; 2963 :                int ha = z->img_comp[n].ha;
; 2964 :                if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2965 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 2966 :                // every data block is an MCU, so countdown the restart interval
; 2967 :                if (--z->todo <= 0) {
; 2968 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 2969 :                   // if it's NOT a restart, then just bail, so we get corrupt data
; 2970 :                   // rather than no data
; 2971 :                   if (!STBI__RESTART(z->marker)) return 1;
; 2972 :                   stbi__jpeg_reset(z);
; 2973 :                }
; 2974 :             }
; 2975 :          }
; 2976 :          return 1;
; 2977 :       } else { // interleaved
; 2978 :          int i,j,k,x,y;
; 2979 :          STBI_SIMD_ALIGN(short, data[64]);
; 2980 :          for (j=0; j < z->img_mcu_y; ++j) {
; 2981 :             for (i=0; i < z->img_mcu_x; ++i) {
; 2982 :                // scan an interleaved mcu... process scan_n components in order
; 2983 :                for (k=0; k < z->scan_n; ++k) {
; 2984 :                   int n = z->order[k];
; 2985 :                   // scan out an mcu's worth of this component; that's just determined
; 2986 :                   // by the basic H and V specified for the component
; 2987 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 2988 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 2989 :                         int x2 = (i*z->img_comp[n].h + x)*8;
; 2990 :                         int y2 = (j*z->img_comp[n].v + y)*8;
; 2991 :                         int ha = z->img_comp[n].ha;
; 2992 :                         if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2993 :                         z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
; 2994 :                      }
; 2995 :                   }
; 2996 :                }
; 2997 :                // after all interleaved components, that's an interleaved MCU,
; 2998 :                // so now count down the restart interval
; 2999 :                if (--z->todo <= 0) {
; 3000 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3001 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3002 :                   stbi__jpeg_reset(z);
; 3003 :                }
; 3004 :             }
; 3005 :          }
; 3006 :          return 1;
; 3007 :       }
; 3008 :    } else {
; 3009 :       if (z->scan_n == 1) {
; 3010 :          int i,j;
; 3011 :          int n = z->order[0];
; 3012 :          // non-interleaved data, we just need to process one block at a time,
; 3013 :          // in trivial scanline order
; 3014 :          // number of blocks to do just depends on how many actual "pixels" this
; 3015 :          // component has, independent of interleaved MCU blocking and such
; 3016 :          int w = (z->img_comp[n].x+7) >> 3;
; 3017 :          int h = (z->img_comp[n].y+7) >> 3;
; 3018 :          for (j=0; j < h; ++j) {
; 3019 :             for (i=0; i < w; ++i) {
; 3020 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3021 :                if (z->spec_start == 0) {
; 3022 :                   if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3023 :                      return 0;
; 3024 :                } else {
; 3025 :                   int ha = z->img_comp[n].ha;
; 3026 :                   if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
; 3027 :                      return 0;
; 3028 :                }
; 3029 :                // every data block is an MCU, so countdown the restart interval
; 3030 :                if (--z->todo <= 0) {
; 3031 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3032 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3033 :                   stbi__jpeg_reset(z);
; 3034 :                }
; 3035 :             }
; 3036 :          }
; 3037 :          return 1;
; 3038 :       } else { // interleaved
; 3039 :          int i,j,k,x,y;
; 3040 :          for (j=0; j < z->img_mcu_y; ++j) {
; 3041 :             for (i=0; i < z->img_mcu_x; ++i) {
; 3042 :                // scan an interleaved mcu... process scan_n components in order
; 3043 :                for (k=0; k < z->scan_n; ++k) {
; 3044 :                   int n = z->order[k];
; 3045 :                   // scan out an mcu's worth of this component; that's just determined
; 3046 :                   // by the basic H and V specified for the component
; 3047 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 3048 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 3049 :                         int x2 = (i*z->img_comp[n].h + x);
; 3050 :                         int y2 = (j*z->img_comp[n].v + y);
; 3051 :                         short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
; 3052 :                         if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3053 :                            return 0;
; 3054 :                      }
; 3055 :                   }
; 3056 :                }
; 3057 :                // after all interleaved components, that's an interleaved MCU,
; 3058 :                // so now count down the restart interval
; 3059 :                if (--z->todo <= 0) {
; 3060 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3061 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3062 :                   stbi__jpeg_reset(z);
; 3063 :                }
; 3064 :             }
; 3065 :          }
; 3066 :          return 1;
; 3067 :       }
; 3068 :    }
; 3069 : }
; 3070 : 
; 3071 : static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
; 3072 : {
; 3073 :    int i;
; 3074 :    for (i=0; i < 64; ++i)
; 3075 :       data[i] *= dequant[i];
; 3076 : }
; 3077 : 
; 3078 : static void stbi__jpeg_finish(stbi__jpeg *z)
; 3079 : {
; 3080 :    if (z->progressive) {
; 3081 :       // dequantize and idct the data
; 3082 :       int i,j,n;
; 3083 :       for (n=0; n < z->s->img_n; ++n) {
; 3084 :          int w = (z->img_comp[n].x+7) >> 3;
; 3085 :          int h = (z->img_comp[n].y+7) >> 3;
; 3086 :          for (j=0; j < h; ++j) {
; 3087 :             for (i=0; i < w; ++i) {
; 3088 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3089 :                stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
; 3090 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 3091 :             }
; 3092 :          }
; 3093 :       }
; 3094 :    }
; 3095 : }
; 3096 : 
; 3097 : static int stbi__process_marker(stbi__jpeg *z, int m)
; 3098 : {
; 3099 :    int L;
; 3100 :    switch (m) {
; 3101 :       case STBI__MARKER_none: // no marker found
; 3102 :          return stbi__err("expected marker","Corrupt JPEG");
; 3103 : 
; 3104 :       case 0xDD: // DRI - specify restart interval
; 3105 :          if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
; 3106 :          z->restart_interval = stbi__get16be(z->s);
; 3107 :          return 1;
; 3108 : 
; 3109 :       case 0xDB: // DQT - define quantization table
; 3110 :          L = stbi__get16be(z->s)-2;
; 3111 :          while (L > 0) {
; 3112 :             int q = stbi__get8(z->s);
; 3113 :             int p = q >> 4, sixteen = (p != 0);
; 3114 :             int t = q & 15,i;
; 3115 :             if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
; 3116 :             if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");
; 3117 : 
; 3118 :             for (i=0; i < 64; ++i)
; 3119 :                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
; 3120 :             L -= (sixteen ? 129 : 65);
; 3121 :          }
; 3122 :          return L==0;
; 3123 : 
; 3124 :       case 0xC4: // DHT - define huffman table
; 3125 :          L = stbi__get16be(z->s)-2;
; 3126 :          while (L > 0) {
; 3127 :             stbi_uc *v;
; 3128 :             int sizes[16],i,n=0;
; 3129 :             int q = stbi__get8(z->s);
; 3130 :             int tc = q >> 4;
; 3131 :             int th = q & 15;
; 3132 :             if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
; 3133 :             for (i=0; i < 16; ++i) {
; 3134 :                sizes[i] = stbi__get8(z->s);
; 3135 :                n += sizes[i];
; 3136 :             }
; 3137 :             if(n > 256) return stbi__err("bad DHT header","Corrupt JPEG"); // Loop over i < n would write past end of values!
; 3138 :             L -= 17;
; 3139 :             if (tc == 0) {
; 3140 :                if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
; 3141 :                v = z->huff_dc[th].values;
; 3142 :             } else {
; 3143 :                if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
; 3144 :                v = z->huff_ac[th].values;
; 3145 :             }
; 3146 :             for (i=0; i < n; ++i)
; 3147 :                v[i] = stbi__get8(z->s);
; 3148 :             if (tc != 0)
; 3149 :                stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
; 3150 :             L -= n;
; 3151 :          }
; 3152 :          return L==0;
; 3153 :    }
; 3154 : 
; 3155 :    // check for comment block or APP blocks
; 3156 :    if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
; 3157 :       L = stbi__get16be(z->s);
; 3158 :       if (L < 2) {
; 3159 :          if (m == 0xFE)
; 3160 :             return stbi__err("bad COM len","Corrupt JPEG");
; 3161 :          else
; 3162 :             return stbi__err("bad APP len","Corrupt JPEG");
; 3163 :       }
; 3164 :       L -= 2;
; 3165 : 
; 3166 :       if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
; 3167 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3168 :          int ok = 1;
; 3169 :          int i;
; 3170 :          for (i=0; i < 5; ++i)
; 3171 :             if (stbi__get8(z->s) != tag[i])
; 3172 :                ok = 0;
; 3173 :          L -= 5;
; 3174 :          if (ok)
; 3175 :             z->jfif = 1;
; 3176 :       } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;
; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)
; 3181 :             if (stbi__get8(z->s) != tag[i])
; 3182 :                ok = 0;
; 3183 :          L -= 6;
; 3184 :          if (ok) {
; 3185 :             stbi__get8(z->s); // version
; 3186 :             stbi__get16be(z->s); // flags0
; 3187 :             stbi__get16be(z->s); // flags1
; 3188 :             z->app14_color_transform = stbi__get8(z->s); // color transform
; 3189 :             L -= 6;
; 3190 :          }
; 3191 :       }
; 3192 : 
; 3193 :       stbi__skip(z->s, L);
; 3194 :       return 1;
; 3195 :    }
; 3196 : 
; 3197 :    return stbi__err("unknown marker","Corrupt JPEG");
; 3198 : }
; 3199 : 
; 3200 : // after we see SOS
; 3201 : static int stbi__process_scan_header(stbi__jpeg *z)
; 3202 : {
; 3203 :    int i;
; 3204 :    int Ls = stbi__get16be(z->s);
; 3205 :    z->scan_n = stbi__get8(z->s);
; 3206 :    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
; 3207 :    if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
; 3208 :    for (i=0; i < z->scan_n; ++i) {
; 3209 :       int id = stbi__get8(z->s), which;
; 3210 :       int q = stbi__get8(z->s);
; 3211 :       for (which = 0; which < z->s->img_n; ++which)
; 3212 :          if (z->img_comp[which].id == id)
; 3213 :             break;
; 3214 :       if (which == z->s->img_n) return 0; // no match
; 3215 :       z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
; 3216 :       z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
; 3217 :       z->order[i] = which;
; 3218 :    }
; 3219 : 
; 3220 :    {
; 3221 :       int aa;
; 3222 :       z->spec_start = stbi__get8(z->s);
; 3223 :       z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
; 3224 :       aa = stbi__get8(z->s);
; 3225 :       z->succ_high = (aa >> 4);
; 3226 :       z->succ_low  = (aa & 15);
; 3227 :       if (z->progressive) {
; 3228 :          if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
; 3229 :             return stbi__err("bad SOS", "Corrupt JPEG");
; 3230 :       } else {
; 3231 :          if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3232 :          if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3233 :          z->spec_end = 63;
; 3234 :       }
; 3235 :    }
; 3236 : 
; 3237 :    return 1;
; 3238 : }
; 3239 : 
; 3240 : static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
; 3241 : {
; 3242 :    int i;
; 3243 :    for (i=0; i < ncomp; ++i) {
; 3244 :       if (z->img_comp[i].raw_data) {
; 3245 :          STBI_FREE(z->img_comp[i].raw_data);
; 3246 :          z->img_comp[i].raw_data = NULL;
; 3247 :          z->img_comp[i].data = NULL;
; 3248 :       }
; 3249 :       if (z->img_comp[i].raw_coeff) {
; 3250 :          STBI_FREE(z->img_comp[i].raw_coeff);
; 3251 :          z->img_comp[i].raw_coeff = 0;
; 3252 :          z->img_comp[i].coeff = 0;
; 3253 :       }
; 3254 :       if (z->img_comp[i].linebuf) {
; 3255 :          STBI_FREE(z->img_comp[i].linebuf);
; 3256 :          z->img_comp[i].linebuf = NULL;
; 3257 :       }
; 3258 :    }
; 3259 :    return why;
; 3260 : }
; 3261 : 
; 3262 : static int stbi__process_frame_header(stbi__jpeg *z, int scan)
; 3263 : {
; 3264 :    stbi__context *s = z->s;
; 3265 :    int Lf,p,i,q, h_max=1,v_max=1,c;
; 3266 :    Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
; 3267 :    p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
; 3268 :    s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
; 3269 :    s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
; 3270 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 3271 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 3272 :    c = stbi__get8(s);
; 3273 :    if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");
; 3274 :    s->img_n = c;
; 3275 :    for (i=0; i < c; ++i) {
; 3276 :       z->img_comp[i].data = NULL;
; 3277 :       z->img_comp[i].linebuf = NULL;
; 3278 :    }
; 3279 : 
; 3280 :    if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");
; 3281 : 
; 3282 :    z->rgb = 0;
; 3283 :    for (i=0; i < s->img_n; ++i) {
; 3284 :       static const unsigned char rgb[3] = { 'R', 'G', 'B' };
; 3285 :       z->img_comp[i].id = stbi__get8(s);
; 3286 :       if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
; 3287 :          ++z->rgb;
; 3288 :       q = stbi__get8(s);
; 3289 :       z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
; 3290 :       z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
; 3291 :       z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
; 3292 :    }
; 3293 : 
; 3294 :    if (scan != STBI__SCAN_load) return 1;
; 3295 : 
; 3296 :    if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");
; 3297 : 
; 3298 :    for (i=0; i < s->img_n; ++i) {
; 3299 :       if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
; 3300 :       if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
; 3301 :    }
; 3302 : 
; 3303 :    // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
; 3304 :    // and I've never seen a non-corrupted JPEG file actually use them
; 3305 :    for (i=0; i < s->img_n; ++i) {
; 3306 :       if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");
; 3307 :       if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");
; 3308 :    }
; 3309 : 
; 3310 :    // compute interleaved mcu info
; 3311 :    z->img_h_max = h_max;
; 3312 :    z->img_v_max = v_max;
; 3313 :    z->img_mcu_w = h_max * 8;
; 3314 :    z->img_mcu_h = v_max * 8;
; 3315 :    // these sizes can't be more than 17 bits
; 3316 :    z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
; 3317 :    z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;
; 3318 : 
; 3319 :    for (i=0; i < s->img_n; ++i) {
; 3320 :       // number of effective pixels (e.g. for non-interleaved MCU)
; 3321 :       z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
; 3322 :       z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
; 3323 :       // to simplify generation, we'll allocate enough memory to decode
; 3324 :       // the bogus oversized data from using interleaved MCUs and their
; 3325 :       // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
; 3326 :       // discard the extra data until colorspace conversion
; 3327 :       //
; 3328 :       // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
; 3329 :       // so these muls can't overflow with 32-bit ints (which we require)
; 3330 :       z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
; 3331 :       z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
; 3332 :       z->img_comp[i].coeff = 0;
; 3333 :       z->img_comp[i].raw_coeff = 0;
; 3334 :       z->img_comp[i].linebuf = NULL;
; 3335 :       z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
; 3336 :       if (z->img_comp[i].raw_data == NULL)
; 3337 :          return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
; 3338 :       // align blocks for idct using mmx/sse
; 3339 :       z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
; 3340 :       if (z->progressive) {
; 3341 :          // w2, h2 are multiples of 8 (see above)
; 3342 :          z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
; 3343 :          z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
; 3344 :          z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
; 3345 :          if (z->img_comp[i].raw_coeff == NULL)
; 3346 :             return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
; 3347 :          z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
; 3348 :       }
; 3349 :    }
; 3350 : 
; 3351 :    return 1;
; 3352 : }
; 3353 : 
; 3354 : // use comparisons since in some cases we handle more than one case (e.g. SOF)
; 3355 : #define stbi__DNL(x)         ((x) == 0xdc)
; 3356 : #define stbi__SOI(x)         ((x) == 0xd8)
; 3357 : #define stbi__EOI(x)         ((x) == 0xd9)
; 3358 : #define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
; 3359 : #define stbi__SOS(x)         ((x) == 0xda)
; 3360 : 
; 3361 : #define stbi__SOF_progressive(x)   ((x) == 0xc2)
; 3362 : 
; 3363 : static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
; 3364 : {
; 3365 :    int m;
; 3366 :    z->jfif = 0;
; 3367 :    z->app14_color_transform = -1; // valid values are 0,1,2
; 3368 :    z->marker = STBI__MARKER_none; // initialize cached marker to empty
; 3369 :    m = stbi__get_marker(z);
; 3370 :    if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
; 3371 :    if (scan == STBI__SCAN_type) return 1;
; 3372 :    m = stbi__get_marker(z);
; 3373 :    while (!stbi__SOF(m)) {
; 3374 :       if (!stbi__process_marker(z,m)) return 0;
; 3375 :       m = stbi__get_marker(z);
; 3376 :       while (m == STBI__MARKER_none) {
; 3377 :          // some files have extra padding after their blocks, so ok, we'll scan
; 3378 :          if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
; 3379 :          m = stbi__get_marker(z);
; 3380 :       }
; 3381 :    }
; 3382 :    z->progressive = stbi__SOF_progressive(m);
; 3383 :    if (!stbi__process_frame_header(z, scan)) return 0;
; 3384 :    return 1;
; 3385 : }
; 3386 : 
; 3387 : static int stbi__skip_jpeg_junk_at_end(stbi__jpeg *j)
; 3388 : {
; 3389 :    // some JPEGs have junk at end, skip over it but if we find what looks
; 3390 :    // like a valid marker, resume there
; 3391 :    while (!stbi__at_eof(j->s)) {
; 3392 :       int x = stbi__get8(j->s);
; 3393 :       while (x == 255) { // might be a marker
; 3394 :          if (stbi__at_eof(j->s)) return STBI__MARKER_none;
; 3395 :          x = stbi__get8(j->s);
; 3396 :          if (x != 0x00 && x != 0xff) {
; 3397 :             // not a stuffed zero or lead-in to another marker, looks
; 3398 :             // like an actual marker, return it
; 3399 :             return x;
; 3400 :          }
; 3401 :          // stuffed zero has x=0 now which ends the loop, meaning we go
; 3402 :          // back to regular scan loop.
; 3403 :          // repeated 0xff keeps trying to read the next byte of the marker.
; 3404 :       }
; 3405 :    }
; 3406 :    return STBI__MARKER_none;
; 3407 : }
; 3408 : 
; 3409 : // decode image to YCbCr format
; 3410 : static int stbi__decode_jpeg_image(stbi__jpeg *j)
; 3411 : {
; 3412 :    int m;
; 3413 :    for (m = 0; m < 4; m++) {
; 3414 :       j->img_comp[m].raw_data = NULL;
; 3415 :       j->img_comp[m].raw_coeff = NULL;
; 3416 :    }
; 3417 :    j->restart_interval = 0;
; 3418 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
; 3419 :    m = stbi__get_marker(j);
; 3420 :    while (!stbi__EOI(m)) {
; 3421 :       if (stbi__SOS(m)) {
; 3422 :          if (!stbi__process_scan_header(j)) return 0;
; 3423 :          if (!stbi__parse_entropy_coded_data(j)) return 0;
; 3424 :          if (j->marker == STBI__MARKER_none ) {
; 3425 :          j->marker = stbi__skip_jpeg_junk_at_end(j);
; 3426 :             // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
; 3427 :          }
; 3428 :          m = stbi__get_marker(j);
; 3429 :          if (STBI__RESTART(m))
; 3430 :             m = stbi__get_marker(j);
; 3431 :       } else if (stbi__DNL(m)) {
; 3432 :          int Ld = stbi__get16be(j->s);
; 3433 :          stbi__uint32 NL = stbi__get16be(j->s);
; 3434 :          if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
; 3435 :          if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
; 3436 :          m = stbi__get_marker(j);
; 3437 :       } else {
; 3438 :          if (!stbi__process_marker(j, m)) return 1;
; 3439 :          m = stbi__get_marker(j);
; 3440 :       }
; 3441 :    }
; 3442 :    if (j->progressive)
; 3443 :       stbi__jpeg_finish(j);
; 3444 :    return 1;
; 3445 : }
; 3446 : 
; 3447 : // static jfif-centered resampling (across block boundaries)
; 3448 : 
; 3449 : typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
; 3450 :                                     int w, int hs);
; 3451 : 
; 3452 : #define stbi__div4(x) ((stbi_uc) ((x) >> 2))
; 3453 : 
; 3454 : static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3455 : {
; 3456 :    STBI_NOTUSED(out);
; 3457 :    STBI_NOTUSED(in_far);
; 3458 :    STBI_NOTUSED(w);
; 3459 :    STBI_NOTUSED(hs);
; 3460 :    return in_near;
; 3461 : }
; 3462 : 
; 3463 : static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3464 : {
; 3465 :    // need to generate two samples vertically for every one in input
; 3466 :    int i;
; 3467 :    STBI_NOTUSED(hs);
; 3468 :    for (i=0; i < w; ++i)
; 3469 :       out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
; 3470 :    return out;
; 3471 : }
; 3472 : 
; 3473 : static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3474 : {
; 3475 :    // need to generate two samples horizontally for every one in input
; 3476 :    int i;
; 3477 :    stbi_uc *input = in_near;
; 3478 : 
; 3479 :    if (w == 1) {
; 3480 :       // if only one sample, can't do any interpolation
; 3481 :       out[0] = out[1] = input[0];
; 3482 :       return out;
; 3483 :    }
; 3484 : 
; 3485 :    out[0] = input[0];
; 3486 :    out[1] = stbi__div4(input[0]*3 + input[1] + 2);
; 3487 :    for (i=1; i < w-1; ++i) {
; 3488 :       int n = 3*input[i]+2;
; 3489 :       out[i*2+0] = stbi__div4(n+input[i-1]);
; 3490 :       out[i*2+1] = stbi__div4(n+input[i+1]);
; 3491 :    }
; 3492 :    out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
; 3493 :    out[i*2+1] = input[w-1];
; 3494 : 
; 3495 :    STBI_NOTUSED(in_far);
; 3496 :    STBI_NOTUSED(hs);
; 3497 : 
; 3498 :    return out;
; 3499 : }
; 3500 : 
; 3501 : #define stbi__div16(x) ((stbi_uc) ((x) >> 4))
; 3502 : 
; 3503 : static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3504 : {
; 3505 :    // need to generate 2x2 samples for every one in input
; 3506 :    int i,t0,t1;
; 3507 :    if (w == 1) {
; 3508 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
; 3509 :       return out;
; 3510 :    }
; 3511 : 
; 3512 :    t1 = 3*in_near[0] + in_far[0];
; 3513 :    out[0] = stbi__div4(t1+2);
; 3514 :    for (i=1; i < w; ++i) {
; 3515 :       t0 = t1;
; 3516 :       t1 = 3*in_near[i]+in_far[i];
; 3517 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
; 3518 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
; 3519 :    }
; 3520 :    out[w*2-1] = stbi__div4(t1+2);
; 3521 : 
; 3522 :    STBI_NOTUSED(hs);
; 3523 : 
; 3524 :    return out;
; 3525 : }
; 3526 : 
; 3527 : #if defined(STBI_SSE2) || defined(STBI_NEON)
; 3528 : static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3529 : {
; 3530 :    // need to generate 2x2 samples for every one in input
; 3531 :    int i=0,t0,t1;
; 3532 : 
; 3533 :    if (w == 1) {
; 3534 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
; 3535 :       return out;
; 3536 :    }
; 3537 : 
; 3538 :    t1 = 3*in_near[0] + in_far[0];
; 3539 :    // process groups of 8 pixels for as long as we can.
; 3540 :    // note we can't handle the last pixel in a row in this loop
; 3541 :    // because we need to handle the filter boundary conditions.
; 3542 :    for (; i < ((w-1) & ~7); i += 8) {
; 3543 : #if defined(STBI_SSE2)
; 3544 :       // load and perform the vertical filtering pass
; 3545 :       // this uses 3*x + y = 4*x + (y - x)
; 3546 :       __m128i zero  = _mm_setzero_si128();
; 3547 :       __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
; 3548 :       __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
; 3549 :       __m128i farw  = _mm_unpacklo_epi8(farb, zero);
; 3550 :       __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
; 3551 :       __m128i diff  = _mm_sub_epi16(farw, nearw);
; 3552 :       __m128i nears = _mm_slli_epi16(nearw, 2);
; 3553 :       __m128i curr  = _mm_add_epi16(nears, diff); // current row
; 3554 : 
; 3555 :       // horizontal filter works the same based on shifted vers of current
; 3556 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3557 :       // insert the previous pixel value (from t1).
; 3558 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3559 :       // of next block of 8 pixels added in.
; 3560 :       __m128i prv0 = _mm_slli_si128(curr, 2);
; 3561 :       __m128i nxt0 = _mm_srli_si128(curr, 2);
; 3562 :       __m128i prev = _mm_insert_epi16(prv0, t1, 0);
; 3563 :       __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);
; 3564 : 
; 3565 :       // horizontal filter, polyphase implementation since it's convenient:
; 3566 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3567 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3568 :       // note the shared term.
; 3569 :       __m128i bias  = _mm_set1_epi16(8);
; 3570 :       __m128i curs = _mm_slli_epi16(curr, 2);
; 3571 :       __m128i prvd = _mm_sub_epi16(prev, curr);
; 3572 :       __m128i nxtd = _mm_sub_epi16(next, curr);
; 3573 :       __m128i curb = _mm_add_epi16(curs, bias);
; 3574 :       __m128i even = _mm_add_epi16(prvd, curb);
; 3575 :       __m128i odd  = _mm_add_epi16(nxtd, curb);
; 3576 : 
; 3577 :       // interleave even and odd pixels, then undo scaling.
; 3578 :       __m128i int0 = _mm_unpacklo_epi16(even, odd);
; 3579 :       __m128i int1 = _mm_unpackhi_epi16(even, odd);
; 3580 :       __m128i de0  = _mm_srli_epi16(int0, 4);
; 3581 :       __m128i de1  = _mm_srli_epi16(int1, 4);
; 3582 : 
; 3583 :       // pack and write output
; 3584 :       __m128i outv = _mm_packus_epi16(de0, de1);
; 3585 :       _mm_storeu_si128((__m128i *) (out + i*2), outv);
; 3586 : #elif defined(STBI_NEON)
; 3587 :       // load and perform the vertical filtering pass
; 3588 :       // this uses 3*x + y = 4*x + (y - x)
; 3589 :       uint8x8_t farb  = vld1_u8(in_far + i);
; 3590 :       uint8x8_t nearb = vld1_u8(in_near + i);
; 3591 :       int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
; 3592 :       int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
; 3593 :       int16x8_t curr  = vaddq_s16(nears, diff); // current row
; 3594 : 
; 3595 :       // horizontal filter works the same based on shifted vers of current
; 3596 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3597 :       // insert the previous pixel value (from t1).
; 3598 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3599 :       // of next block of 8 pixels added in.
; 3600 :       int16x8_t prv0 = vextq_s16(curr, curr, 7);
; 3601 :       int16x8_t nxt0 = vextq_s16(curr, curr, 1);
; 3602 :       int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
; 3603 :       int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);
; 3604 : 
; 3605 :       // horizontal filter, polyphase implementation since it's convenient:
; 3606 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3607 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3608 :       // note the shared term.
; 3609 :       int16x8_t curs = vshlq_n_s16(curr, 2);
; 3610 :       int16x8_t prvd = vsubq_s16(prev, curr);
; 3611 :       int16x8_t nxtd = vsubq_s16(next, curr);
; 3612 :       int16x8_t even = vaddq_s16(curs, prvd);
; 3613 :       int16x8_t odd  = vaddq_s16(curs, nxtd);
; 3614 : 
; 3615 :       // undo scaling and round, then store with even/odd phases interleaved
; 3616 :       uint8x8x2_t o;
; 3617 :       o.val[0] = vqrshrun_n_s16(even, 4);
; 3618 :       o.val[1] = vqrshrun_n_s16(odd,  4);
; 3619 :       vst2_u8(out + i*2, o);
; 3620 : #endif
; 3621 : 
; 3622 :       // "previous" value for next iter
; 3623 :       t1 = 3*in_near[i+7] + in_far[i+7];
; 3624 :    }
; 3625 : 
; 3626 :    t0 = t1;
; 3627 :    t1 = 3*in_near[i] + in_far[i];
; 3628 :    out[i*2] = stbi__div16(3*t1 + t0 + 8);
; 3629 : 
; 3630 :    for (++i; i < w; ++i) {
; 3631 :       t0 = t1;
; 3632 :       t1 = 3*in_near[i]+in_far[i];
; 3633 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
; 3634 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
; 3635 :    }
; 3636 :    out[w*2-1] = stbi__div4(t1+2);
; 3637 : 
; 3638 :    STBI_NOTUSED(hs);
; 3639 : 
; 3640 :    return out;
; 3641 : }
; 3642 : #endif
; 3643 : 
; 3644 : static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3645 : {
; 3646 :    // resample with nearest-neighbor
; 3647 :    int i,j;
; 3648 :    STBI_NOTUSED(in_far);
; 3649 :    for (i=0; i < w; ++i)
; 3650 :       for (j=0; j < hs; ++j)
; 3651 :          out[i*hs+j] = in_near[i];
; 3652 :    return out;
; 3653 : }
; 3654 : 
; 3655 : // this is a reduced-precision calculation of YCbCr-to-RGB introduced
; 3656 : // to make sure the code produces the same results in both SIMD and scalar
; 3657 : #define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
; 3658 : static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
; 3659 : {
; 3660 :    int i;
; 3661 :    for (i=0; i < count; ++i) {
; 3662 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding
; 3663 :       int r,g,b;
; 3664 :       int cr = pcr[i] - 128;
; 3665 :       int cb = pcb[i] - 128;
; 3666 :       r = y_fixed +  cr* stbi__float2fixed(1.40200f);
; 3667 :       g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
; 3668 :       b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
; 3669 :       r >>= 20;
; 3670 :       g >>= 20;
; 3671 :       b >>= 20;
; 3672 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
; 3673 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
; 3674 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
; 3675 :       out[0] = (stbi_uc)r;
; 3676 :       out[1] = (stbi_uc)g;
; 3677 :       out[2] = (stbi_uc)b;
; 3678 :       out[3] = 255;
; 3679 :       out += step;
; 3680 :    }
; 3681 : }
; 3682 : 
; 3683 : #if defined(STBI_SSE2) || defined(STBI_NEON)
; 3684 : static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
; 3685 : {
; 3686 :    int i = 0;
; 3687 : 
; 3688 : #ifdef STBI_SSE2
; 3689 :    // step == 3 is pretty ugly on the final interleave, and i'm not convinced
; 3690 :    // it's useful in practice (you wouldn't use it for textures, for example).
; 3691 :    // so just accelerate step == 4 case.
; 3692 :    if (step == 4) {
; 3693 :       // this is a fairly straightforward implementation and not super-optimized.
; 3694 :       __m128i signflip  = _mm_set1_epi8(-0x80);
; 3695 :       __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3696 :       __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3697 :       __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3698 :       __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3699 :       __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
; 3700 :       __m128i xw = _mm_set1_epi16(255); // alpha channel
; 3701 : 
; 3702 :       for (; i+7 < count; i += 8) {
; 3703 :          // load
; 3704 :          __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
; 3705 :          __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
; 3706 :          __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
; 3707 :          __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
; 3708 :          __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128
; 3709 : 
; 3710 :          // unpack to short (and left-shift cr, cb by 8)
; 3711 :          __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
; 3712 :          __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
; 3713 :          __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);
; 3714 : 
; 3715 :          // color transform
; 3716 :          __m128i yws = _mm_srli_epi16(yw, 4);
; 3717 :          __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
; 3718 :          __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
; 3719 :          __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
; 3720 :          __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
; 3721 :          __m128i rws = _mm_add_epi16(cr0, yws);
; 3722 :          __m128i gwt = _mm_add_epi16(cb0, yws);
; 3723 :          __m128i bws = _mm_add_epi16(yws, cb1);
; 3724 :          __m128i gws = _mm_add_epi16(gwt, cr1);
; 3725 : 
; 3726 :          // descale
; 3727 :          __m128i rw = _mm_srai_epi16(rws, 4);
; 3728 :          __m128i bw = _mm_srai_epi16(bws, 4);
; 3729 :          __m128i gw = _mm_srai_epi16(gws, 4);
; 3730 : 
; 3731 :          // back to byte, set up for transpose
; 3732 :          __m128i brb = _mm_packus_epi16(rw, bw);
; 3733 :          __m128i gxb = _mm_packus_epi16(gw, xw);
; 3734 : 
; 3735 :          // transpose to interleave channels
; 3736 :          __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
; 3737 :          __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
; 3738 :          __m128i o0 = _mm_unpacklo_epi16(t0, t1);
; 3739 :          __m128i o1 = _mm_unpackhi_epi16(t0, t1);
; 3740 : 
; 3741 :          // store
; 3742 :          _mm_storeu_si128((__m128i *) (out + 0), o0);
; 3743 :          _mm_storeu_si128((__m128i *) (out + 16), o1);
; 3744 :          out += 32;
; 3745 :       }
; 3746 :    }
; 3747 : #endif
; 3748 : 
; 3749 : #ifdef STBI_NEON
; 3750 :    // in this version, step=3 support would be easy to add. but is there demand?
; 3751 :    if (step == 4) {
; 3752 :       // this is a fairly straightforward implementation and not super-optimized.
; 3753 :       uint8x8_t signflip = vdup_n_u8(0x80);
; 3754 :       int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3755 :       int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3756 :       int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3757 :       int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3758 : 
; 3759 :       for (; i+7 < count; i += 8) {
; 3760 :          // load
; 3761 :          uint8x8_t y_bytes  = vld1_u8(y + i);
; 3762 :          uint8x8_t cr_bytes = vld1_u8(pcr + i);
; 3763 :          uint8x8_t cb_bytes = vld1_u8(pcb + i);
; 3764 :          int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
; 3765 :          int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
; 3766 : 
; 3767 :          // expand to s16
; 3768 :          int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
; 3769 :          int16x8_t crw = vshll_n_s8(cr_biased, 7);
; 3770 :          int16x8_t cbw = vshll_n_s8(cb_biased, 7);
; 3771 : 
; 3772 :          // color transform
; 3773 :          int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
; 3774 :          int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
; 3775 :          int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
; 3776 :          int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
; 3777 :          int16x8_t rws = vaddq_s16(yws, cr0);
; 3778 :          int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
; 3779 :          int16x8_t bws = vaddq_s16(yws, cb1);
; 3780 : 
; 3781 :          // undo scaling, round, convert to byte
; 3782 :          uint8x8x4_t o;
; 3783 :          o.val[0] = vqrshrun_n_s16(rws, 4);
; 3784 :          o.val[1] = vqrshrun_n_s16(gws, 4);
; 3785 :          o.val[2] = vqrshrun_n_s16(bws, 4);
; 3786 :          o.val[3] = vdup_n_u8(255);
; 3787 : 
; 3788 :          // store, interleaving r/g/b/a
; 3789 :          vst4_u8(out, o);
; 3790 :          out += 8*4;
; 3791 :       }
; 3792 :    }
; 3793 : #endif
; 3794 : 
; 3795 :    for (; i < count; ++i) {
; 3796 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding
; 3797 :       int r,g,b;
; 3798 :       int cr = pcr[i] - 128;
; 3799 :       int cb = pcb[i] - 128;
; 3800 :       r = y_fixed + cr* stbi__float2fixed(1.40200f);
; 3801 :       g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
; 3802 :       b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
; 3803 :       r >>= 20;
; 3804 :       g >>= 20;
; 3805 :       b >>= 20;
; 3806 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
; 3807 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
; 3808 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
; 3809 :       out[0] = (stbi_uc)r;
; 3810 :       out[1] = (stbi_uc)g;
; 3811 :       out[2] = (stbi_uc)b;
; 3812 :       out[3] = 255;
; 3813 :       out += step;
; 3814 :    }
; 3815 : }
; 3816 : #endif
; 3817 : 
; 3818 : // set up the kernels
; 3819 : static void stbi__setup_jpeg(stbi__jpeg *j)
; 3820 : {
; 3821 :    j->idct_block_kernel = stbi__idct_block;
; 3822 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
; 3823 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;
; 3824 : 
; 3825 : #ifdef STBI_SSE2
; 3826 :    if (stbi__sse2_available()) {
; 3827 :       j->idct_block_kernel = stbi__idct_simd;
; 3828 :       j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3829 :       j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3830 :    }
; 3831 : #endif
; 3832 : 
; 3833 : #ifdef STBI_NEON
; 3834 :    j->idct_block_kernel = stbi__idct_simd;
; 3835 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3836 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3837 : #endif
; 3838 : }
; 3839 : 
; 3840 : // clean up the temporary component buffers
; 3841 : static void stbi__cleanup_jpeg(stbi__jpeg *j)
; 3842 : {
; 3843 :    stbi__free_jpeg_components(j, j->s->img_n, 0);
; 3844 : }
; 3845 : 
; 3846 : typedef struct
; 3847 : {
; 3848 :    resample_row_func resample;
; 3849 :    stbi_uc *line0,*line1;
; 3850 :    int hs,vs;   // expansion factor in each axis
; 3851 :    int w_lores; // horizontal pixels pre-expansion
; 3852 :    int ystep;   // how far through vertical expansion we are
; 3853 :    int ypos;    // which pre-expansion row we're on
; 3854 : } stbi__resample;
; 3855 : 
; 3856 : // fast 0..255 * 0..255 => 0..255 rounded multiplication
; 3857 : static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
; 3858 : {
; 3859 :    unsigned int t = x*y + 128;
; 3860 :    return (stbi_uc) ((t + (t >>8)) >> 8);
; 3861 : }
; 3862 : 
; 3863 : static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
; 3864 : {
; 3865 :    int n, decode_n, is_rgb;
; 3866 :    z->s->img_n = 0; // make stbi__cleanup_jpeg safe
; 3867 : 
; 3868 :    // validate req_comp
; 3869 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
; 3870 : 
; 3871 :    // load a jpeg image from whichever source, but leave in YCbCr format
; 3872 :    if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }
; 3873 : 
; 3874 :    // determine actual number of components to generate
; 3875 :    n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;
; 3876 : 
; 3877 :    is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));
; 3878 : 
; 3879 :    if (z->s->img_n == 3 && n < 3 && !is_rgb)
; 3880 :       decode_n = 1;
; 3881 :    else
; 3882 :       decode_n = z->s->img_n;
; 3883 : 
; 3884 :    // nothing to do if no components requested; check this now to avoid
; 3885 :    // accessing uninitialized coutput[0] later
; 3886 :    if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }
; 3887 : 
; 3888 :    // resample and color-convert
; 3889 :    {
; 3890 :       int k;
; 3891 :       unsigned int i,j;
; 3892 :       stbi_uc *output;
; 3893 :       stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };
; 3894 : 
; 3895 :       stbi__resample res_comp[4];
; 3896 : 
; 3897 :       for (k=0; k < decode_n; ++k) {
; 3898 :          stbi__resample *r = &res_comp[k];
; 3899 : 
; 3900 :          // allocate line buffer big enough for upsampling off the edges
; 3901 :          // with upsample factor of 4
; 3902 :          z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
; 3903 :          if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
; 3904 : 
; 3905 :          r->hs      = z->img_h_max / z->img_comp[k].h;
; 3906 :          r->vs      = z->img_v_max / z->img_comp[k].v;
; 3907 :          r->ystep   = r->vs >> 1;
; 3908 :          r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
; 3909 :          r->ypos    = 0;
; 3910 :          r->line0   = r->line1 = z->img_comp[k].data;
; 3911 : 
; 3912 :          if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
; 3913 :          else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
; 3914 :          else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
; 3915 :          else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
; 3916 :          else                               r->resample = stbi__resample_row_generic;
; 3917 :       }
; 3918 : 
; 3919 :       // can't error after this so, this is safe
; 3920 :       output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
; 3921 :       if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
; 3922 : 
; 3923 :       // now go ahead and resample
; 3924 :       for (j=0; j < z->s->img_y; ++j) {
; 3925 :          stbi_uc *out = output + n * z->s->img_x * j;
; 3926 :          for (k=0; k < decode_n; ++k) {
; 3927 :             stbi__resample *r = &res_comp[k];
; 3928 :             int y_bot = r->ystep >= (r->vs >> 1);
; 3929 :             coutput[k] = r->resample(z->img_comp[k].linebuf,
; 3930 :                                      y_bot ? r->line1 : r->line0,
; 3931 :                                      y_bot ? r->line0 : r->line1,
; 3932 :                                      r->w_lores, r->hs);
; 3933 :             if (++r->ystep >= r->vs) {
; 3934 :                r->ystep = 0;
; 3935 :                r->line0 = r->line1;
; 3936 :                if (++r->ypos < z->img_comp[k].y)
; 3937 :                   r->line1 += z->img_comp[k].w2;
; 3938 :             }
; 3939 :          }
; 3940 :          if (n >= 3) {
; 3941 :             stbi_uc *y = coutput[0];
; 3942 :             if (z->s->img_n == 3) {
; 3943 :                if (is_rgb) {
; 3944 :                   for (i=0; i < z->s->img_x; ++i) {
; 3945 :                      out[0] = y[i];
; 3946 :                      out[1] = coutput[1][i];
; 3947 :                      out[2] = coutput[2][i];
; 3948 :                      out[3] = 255;
; 3949 :                      out += n;
; 3950 :                   }
; 3951 :                } else {
; 3952 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3953 :                }
; 3954 :             } else if (z->s->img_n == 4) {
; 3955 :                if (z->app14_color_transform == 0) { // CMYK
; 3956 :                   for (i=0; i < z->s->img_x; ++i) {
; 3957 :                      stbi_uc m = coutput[3][i];
; 3958 :                      out[0] = stbi__blinn_8x8(coutput[0][i], m);
; 3959 :                      out[1] = stbi__blinn_8x8(coutput[1][i], m);
; 3960 :                      out[2] = stbi__blinn_8x8(coutput[2][i], m);
; 3961 :                      out[3] = 255;
; 3962 :                      out += n;
; 3963 :                   }
; 3964 :                } else if (z->app14_color_transform == 2) { // YCCK
; 3965 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3966 :                   for (i=0; i < z->s->img_x; ++i) {
; 3967 :                      stbi_uc m = coutput[3][i];
; 3968 :                      out[0] = stbi__blinn_8x8(255 - out[0], m);
; 3969 :                      out[1] = stbi__blinn_8x8(255 - out[1], m);
; 3970 :                      out[2] = stbi__blinn_8x8(255 - out[2], m);
; 3971 :                      out += n;
; 3972 :                   }
; 3973 :                } else { // YCbCr + alpha?  Ignore the fourth channel for now
; 3974 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3975 :                }
; 3976 :             } else
; 3977 :                for (i=0; i < z->s->img_x; ++i) {
; 3978 :                   out[0] = out[1] = out[2] = y[i];
; 3979 :                   out[3] = 255; // not used if n==3
; 3980 :                   out += n;
; 3981 :                }
; 3982 :          } else {
; 3983 :             if (is_rgb) {
; 3984 :                if (n == 1)
; 3985 :                   for (i=0; i < z->s->img_x; ++i)
; 3986 :                      *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
; 3987 :                else {
; 3988 :                   for (i=0; i < z->s->img_x; ++i, out += 2) {
; 3989 :                      out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
; 3990 :                      out[1] = 255;
; 3991 :                   }
; 3992 :                }
; 3993 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
; 3994 :                for (i=0; i < z->s->img_x; ++i) {
; 3995 :                   stbi_uc m = coutput[3][i];
; 3996 :                   stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
; 3997 :                   stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
; 3998 :                   stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
; 3999 :                   out[0] = stbi__compute_y(r, g, b);
; 4000 :                   out[1] = 255;
; 4001 :                   out += n;
; 4002 :                }
; 4003 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
; 4004 :                for (i=0; i < z->s->img_x; ++i) {
; 4005 :                   out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
; 4006 :                   out[1] = 255;
; 4007 :                   out += n;
; 4008 :                }
; 4009 :             } else {
; 4010 :                stbi_uc *y = coutput[0];
; 4011 :                if (n == 1)
; 4012 :                   for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
; 4013 :                else
; 4014 :                   for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
; 4015 :             }
; 4016 :          }
; 4017 :       }
; 4018 :       stbi__cleanup_jpeg(z);
; 4019 :       *out_x = z->s->img_x;
; 4020 :       *out_y = z->s->img_y;
; 4021 :       if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
; 4022 :       return output;
; 4023 :    }
; 4024 : }
; 4025 : 
; 4026 : static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 4027 : {
; 4028 :    unsigned char* result;
; 4029 :    stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
; 4030 :    if (!j) return stbi__errpuc("outofmem", "Out of memory");
; 4031 :    memset(j, 0, sizeof(stbi__jpeg));
; 4032 :    STBI_NOTUSED(ri);
; 4033 :    j->s = s;
; 4034 :    stbi__setup_jpeg(j);
; 4035 :    result = load_jpeg_image(j, x,y,comp,req_comp);
; 4036 :    STBI_FREE(j);
; 4037 :    return result;
; 4038 : }
; 4039 : 
; 4040 : static int stbi__jpeg_test(stbi__context *s)
; 4041 : {
; 4042 :    int r;
; 4043 :    stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
; 4044 :    if (!j) return stbi__err("outofmem", "Out of memory");
; 4045 :    memset(j, 0, sizeof(stbi__jpeg));
; 4046 :    j->s = s;
; 4047 :    stbi__setup_jpeg(j);
; 4048 :    r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
; 4049 :    stbi__rewind(s);
; 4050 :    STBI_FREE(j);
; 4051 :    return r;
; 4052 : }
; 4053 : 
; 4054 : static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
; 4055 : {
; 4056 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
; 4057 :       stbi__rewind( j->s );
; 4058 :       return 0;
; 4059 :    }
; 4060 :    if (x) *x = j->s->img_x;
; 4061 :    if (y) *y = j->s->img_y;
; 4062 :    if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
; 4063 :    return 1;
; 4064 : }
; 4065 : 
; 4066 : static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
; 4067 : {
; 4068 :    int result;
; 4069 :    stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
; 4070 :    if (!j) return stbi__err("outofmem", "Out of memory");
; 4071 :    memset(j, 0, sizeof(stbi__jpeg));
; 4072 :    j->s = s;
; 4073 :    result = stbi__jpeg_info_raw(j, x, y, comp);
; 4074 :    STBI_FREE(j);
; 4075 :    return result;
; 4076 : }
; 4077 : #endif
; 4078 : 
; 4079 : // public domain zlib decode    v0.2  Sean Barrett 2006-11-18
; 4080 : //    simple implementation
; 4081 : //      - all input must be provided in an upfront buffer
; 4082 : //      - all output is written to a single output buffer (can malloc/realloc)
; 4083 : //    performance
; 4084 : //      - fast huffman
; 4085 : 
; 4086 : #ifndef STBI_NO_ZLIB
; 4087 : 
; 4088 : // fast-way is faster to check than jpeg huffman, but slow way is slower
; 4089 : #define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
; 4090 : #define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
; 4091 : #define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet
; 4092 : 
; 4093 : // zlib-style huffman encoding
; 4094 : // (jpegs packs from left, zlib from right, so can't share code)
; 4095 : typedef struct
; 4096 : {
; 4097 :    stbi__uint16 fast[1 << STBI__ZFAST_BITS];
; 4098 :    stbi__uint16 firstcode[16];
; 4099 :    int maxcode[17];
; 4100 :    stbi__uint16 firstsymbol[16];
; 4101 :    stbi_uc  size[STBI__ZNSYMS];
; 4102 :    stbi__uint16 value[STBI__ZNSYMS];
; 4103 : } stbi__zhuffman;
; 4104 : 
; 4105 : stbi_inline static int stbi__bitreverse16(int n)
; 4106 : {
; 4107 :   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
; 4108 :   n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
; 4109 :   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
; 4110 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
; 4111 :   return n;
; 4112 : }
; 4113 : 
; 4114 : stbi_inline static int stbi__bit_reverse(int v, int bits)
; 4115 : {
; 4116 :    STBI_ASSERT(bits <= 16);
; 4117 :    // to bit reverse n bits, reverse 16 and shift
; 4118 :    // e.g. 11 bits, bit reverse and shift away 5
; 4119 :    return stbi__bitreverse16(v) >> (16-bits);
; 4120 : }
; 4121 : 
; 4122 : static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
; 4123 : {
; 4124 :    int i,k=0;
; 4125 :    int code, next_code[16], sizes[17];
; 4126 : 
; 4127 :    // DEFLATE spec for generating codes
; 4128 :    memset(sizes, 0, sizeof(sizes));
; 4129 :    memset(z->fast, 0, sizeof(z->fast));
; 4130 :    for (i=0; i < num; ++i)
; 4131 :       ++sizes[sizelist[i]];
; 4132 :    sizes[0] = 0;
; 4133 :    for (i=1; i < 16; ++i)
; 4134 :       if (sizes[i] > (1 << i))
; 4135 :          return stbi__err("bad sizes", "Corrupt PNG");
; 4136 :    code = 0;
; 4137 :    for (i=1; i < 16; ++i) {
; 4138 :       next_code[i] = code;
; 4139 :       z->firstcode[i] = (stbi__uint16) code;
; 4140 :       z->firstsymbol[i] = (stbi__uint16) k;
; 4141 :       code = (code + sizes[i]);
; 4142 :       if (sizes[i])
; 4143 :          if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
; 4144 :       z->maxcode[i] = code << (16-i); // preshift for inner loop
; 4145 :       code <<= 1;
; 4146 :       k += sizes[i];
; 4147 :    }
; 4148 :    z->maxcode[16] = 0x10000; // sentinel
; 4149 :    for (i=0; i < num; ++i) {
; 4150 :       int s = sizelist[i];
; 4151 :       if (s) {
; 4152 :          int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
; 4153 :          stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
; 4154 :          z->size [c] = (stbi_uc     ) s;
; 4155 :          z->value[c] = (stbi__uint16) i;
; 4156 :          if (s <= STBI__ZFAST_BITS) {
; 4157 :             int j = stbi__bit_reverse(next_code[s],s);
; 4158 :             while (j < (1 << STBI__ZFAST_BITS)) {
; 4159 :                z->fast[j] = fastv;
; 4160 :                j += (1 << s);
; 4161 :             }
; 4162 :          }
; 4163 :          ++next_code[s];
; 4164 :       }
; 4165 :    }
; 4166 :    return 1;
; 4167 : }
; 4168 : 
; 4169 : // zlib-from-memory implementation for PNG reading
; 4170 : //    because PNG allows splitting the zlib stream arbitrarily,
; 4171 : //    and it's annoying structurally to have PNG call ZLIB call PNG,
; 4172 : //    we require PNG read all the IDATs and combine them into a single
; 4173 : //    memory buffer
; 4174 : 
; 4175 : typedef struct
; 4176 : {
; 4177 :    stbi_uc *zbuffer, *zbuffer_end;
; 4178 :    int num_bits;
; 4179 :    stbi__uint32 code_buffer;
; 4180 : 
; 4181 :    char *zout;
; 4182 :    char *zout_start;
; 4183 :    char *zout_end;
; 4184 :    int   z_expandable;
; 4185 : 
; 4186 :    stbi__zhuffman z_length, z_distance;
; 4187 : } stbi__zbuf;
; 4188 : 
; 4189 : stbi_inline static int stbi__zeof(stbi__zbuf *z)
; 4190 : {
; 4191 :    return (z->zbuffer >= z->zbuffer_end);
; 4192 : }
; 4193 : 
; 4194 : stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
; 4195 : {
; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;
; 4197 : }
; 4198 : 
; 4199 : static void stbi__fill_bits(stbi__zbuf *z)
; 4200 : {
; 4201 :    do {
; 4202 :       if (z->code_buffer >= (1U << z->num_bits)) {
; 4203 :         z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
; 4204 :         return;
; 4205 :       }
; 4206 :       z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
; 4207 :       z->num_bits += 8;
; 4208 :    } while (z->num_bits <= 24);
; 4209 : }
; 4210 : 
; 4211 : stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
; 4212 : {
; 4213 :    unsigned int k;
; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);
; 4215 :    k = z->code_buffer & ((1 << n) - 1);
; 4216 :    z->code_buffer >>= n;
; 4217 :    z->num_bits -= n;
; 4218 :    return k;
; 4219 : }
; 4220 : 
; 4221 : static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
; 4222 : {
; 4223 :    int b,s,k;
; 4224 :    // not resolved by fast table, so compute it the slow way
; 4225 :    // use jpeg approach, which requires MSbits at top
; 4226 :    k = stbi__bit_reverse(a->code_buffer, 16);
; 4227 :    for (s=STBI__ZFAST_BITS+1; ; ++s)
; 4228 :       if (k < z->maxcode[s])
; 4229 :          break;
; 4230 :    if (s >= 16) return -1; // invalid code!
; 4231 :    // code size is s, so:
; 4232 :    b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
; 4233 :    if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
; 4234 :    if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
; 4235 :    a->code_buffer >>= s;
; 4236 :    a->num_bits -= s;
; 4237 :    return z->value[b];
; 4238 : }
; 4239 : 
; 4240 : stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
; 4241 : {
; 4242 :    int b,s;
; 4243 :    if (a->num_bits < 16) {
; 4244 :       if (stbi__zeof(a)) {
; 4245 :          return -1;   /* report error for unexpected end of data. */
; 4246 :       }
; 4247 :       stbi__fill_bits(a);
; 4248 :    }
; 4249 :    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
; 4250 :    if (b) {
; 4251 :       s = b >> 9;
; 4252 :       a->code_buffer >>= s;
; 4253 :       a->num_bits -= s;
; 4254 :       return b & 511;
; 4255 :    }
; 4256 :    return stbi__zhuffman_decode_slowpath(a, z);
; 4257 : }
; 4258 : 
; 4259 : static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
; 4260 : {
; 4261 :    char *q;
; 4262 :    unsigned int cur, limit, old_limit;
; 4263 :    z->zout = zout;
; 4264 :    if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
; 4265 :    cur   = (unsigned int) (z->zout - z->zout_start);
; 4266 :    limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
; 4267 :    if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");
; 4268 :    while (cur + n > limit) {
; 4269 :       if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");
; 4270 :       limit *= 2;
; 4271 :    }
; 4272 :    q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
; 4273 :    STBI_NOTUSED(old_limit);
; 4274 :    if (q == NULL) return stbi__err("outofmem", "Out of memory");
; 4275 :    z->zout_start = q;
; 4276 :    z->zout       = q + cur;
; 4277 :    z->zout_end   = q + limit;
; 4278 :    return 1;
; 4279 : }
; 4280 : 
; 4281 : static const int stbi__zlength_base[31] = {
; 4282 :    3,4,5,6,7,8,9,10,11,13,
; 4283 :    15,17,19,23,27,31,35,43,51,59,
; 4284 :    67,83,99,115,131,163,195,227,258,0,0 };
; 4285 : 
; 4286 : static const int stbi__zlength_extra[31]=
; 4287 : { 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };
; 4288 : 
; 4289 : static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
; 4290 : 257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};
; 4291 : 
; 4292 : static const int stbi__zdist_extra[32] =
; 4293 : { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
; 4294 : 
; 4295 : static int stbi__parse_huffman_block(stbi__zbuf *a)
; 4296 : {
; 4297 :    char *zout = a->zout;
; 4298 :    for(;;) {
; 4299 :       int z = stbi__zhuffman_decode(a, &a->z_length);
; 4300 :       if (z < 256) {
; 4301 :          if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
; 4302 :          if (zout >= a->zout_end) {
; 4303 :             if (!stbi__zexpand(a, zout, 1)) return 0;
; 4304 :             zout = a->zout;
; 4305 :          }
; 4306 :          *zout++ = (char) z;
; 4307 :       } else {
; 4308 :          stbi_uc *p;
; 4309 :          int len,dist;
; 4310 :          if (z == 256) {
; 4311 :             a->zout = zout;
; 4312 :             return 1;
; 4313 :          }
; 4314 :          if (z >= 286) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, length codes 286 and 287 must not appear in compressed data
; 4315 :          z -= 257;
; 4316 :          len = stbi__zlength_base[z];
; 4317 :          if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
; 4318 :          z = stbi__zhuffman_decode(a, &a->z_distance);
; 4319 :          if (z < 0 || z >= 30) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data
; 4320 :          dist = stbi__zdist_base[z];
; 4321 :          if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
; 4322 :          if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
; 4323 :          if (zout + len > a->zout_end) {
; 4324 :             if (!stbi__zexpand(a, zout, len)) return 0;
; 4325 :             zout = a->zout;
; 4326 :          }
; 4327 :          p = (stbi_uc *) (zout - dist);
; 4328 :          if (dist == 1) { // run of one byte; common in images.
; 4329 :             stbi_uc v = *p;
; 4330 :             if (len) { do *zout++ = v; while (--len); }
; 4331 :          } else {
; 4332 :             if (len) { do *zout++ = *p++; while (--len); }
; 4333 :          }
; 4334 :       }
; 4335 :    }
; 4336 : }
; 4337 : 
; 4338 : static int stbi__compute_huffman_codes(stbi__zbuf *a)
; 4339 : {
; 4340 :    static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
; 4341 :    stbi__zhuffman z_codelength;
; 4342 :    stbi_uc lencodes[286+32+137];//padding for maximum single op
; 4343 :    stbi_uc codelength_sizes[19];
; 4344 :    int i,n;
; 4345 : 
; 4346 :    int hlit  = stbi__zreceive(a,5) + 257;
; 4347 :    int hdist = stbi__zreceive(a,5) + 1;
; 4348 :    int hclen = stbi__zreceive(a,4) + 4;
; 4349 :    int ntot  = hlit + hdist;
; 4350 : 
; 4351 :    memset(codelength_sizes, 0, sizeof(codelength_sizes));
; 4352 :    for (i=0; i < hclen; ++i) {
; 4353 :       int s = stbi__zreceive(a,3);
; 4354 :       codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
; 4355 :    }
; 4356 :    if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;
; 4357 : 
; 4358 :    n = 0;
; 4359 :    while (n < ntot) {
; 4360 :       int c = stbi__zhuffman_decode(a, &z_codelength);
; 4361 :       if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
; 4362 :       if (c < 16)
; 4363 :          lencodes[n++] = (stbi_uc) c;
; 4364 :       else {
; 4365 :          stbi_uc fill = 0;
; 4366 :          if (c == 16) {
; 4367 :             c = stbi__zreceive(a,2)+3;
; 4368 :             if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
; 4369 :             fill = lencodes[n-1];
; 4370 :          } else if (c == 17) {
; 4371 :             c = stbi__zreceive(a,3)+3;
; 4372 :          } else if (c == 18) {
; 4373 :             c = stbi__zreceive(a,7)+11;
; 4374 :          } else {
; 4375 :             return stbi__err("bad codelengths", "Corrupt PNG");
; 4376 :          }
; 4377 :          if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
; 4378 :          memset(lencodes+n, fill, c);
; 4379 :          n += c;
; 4380 :       }
; 4381 :    }
; 4382 :    if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");
; 4383 :    if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
; 4384 :    if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
; 4385 :    return 1;
; 4386 : }
; 4387 : 
; 4388 : static int stbi__parse_uncompressed_block(stbi__zbuf *a)
; 4389 : {
; 4390 :    stbi_uc header[4];
; 4391 :    int len,nlen,k;
; 4392 :    if (a->num_bits & 7)
; 4393 :       stbi__zreceive(a, a->num_bits & 7); // discard
; 4394 :    // drain the bit-packed data into header
; 4395 :    k = 0;
; 4396 :    while (a->num_bits > 0) {
; 4397 :       header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
; 4398 :       a->code_buffer >>= 8;
; 4399 :       a->num_bits -= 8;
; 4400 :    }
; 4401 :    if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");
; 4402 :    // now fill header the normal way
; 4403 :    while (k < 4)
; 4404 :       header[k++] = stbi__zget8(a);
; 4405 :    len  = header[1] * 256 + header[0];
; 4406 :    nlen = header[3] * 256 + header[2];
; 4407 :    if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
; 4408 :    if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
; 4409 :    if (a->zout + len > a->zout_end)
; 4410 :       if (!stbi__zexpand(a, a->zout, len)) return 0;
; 4411 :    memcpy(a->zout, a->zbuffer, len);
; 4412 :    a->zbuffer += len;
; 4413 :    a->zout += len;
; 4414 :    return 1;
; 4415 : }
; 4416 : 
; 4417 : static int stbi__parse_zlib_header(stbi__zbuf *a)
; 4418 : {
; 4419 :    int cmf   = stbi__zget8(a);
; 4420 :    int cm    = cmf & 15;
; 4421 :    /* int cinfo = cmf >> 4; */
; 4422 :    int flg   = stbi__zget8(a);
; 4423 :    if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
; 4424 :    if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
; 4425 :    if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
; 4426 :    if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
; 4427 :    // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
; 4428 :    return 1;
; 4429 : }
; 4430 : 
; 4431 : static const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =
; 4432 : {
; 4433 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4434 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4435 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4436 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4437 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4438 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4439 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4440 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4441 :    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
; 4442 : };
; 4443 : static const stbi_uc stbi__zdefault_distance[32] =
; 4444 : {
; 4445 :    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
; 4446 : };
; 4447 : /*
; 4448 : Init algorithm:
; 4449 : {
; 4450 :    int i;   // use <= to match clearly with spec
; 4451 :    for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
; 4452 :    for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
; 4453 :    for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
; 4454 :    for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;
; 4455 : 
; 4456 :    for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
; 4457 : }
; 4458 : */
; 4459 : 
; 4460 : static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
; 4461 : {
; 4462 :    int final, type;
; 4463 :    if (parse_header)
; 4464 :       if (!stbi__parse_zlib_header(a)) return 0;
; 4465 :    a->num_bits = 0;
; 4466 :    a->code_buffer = 0;
; 4467 :    do {
; 4468 :       final = stbi__zreceive(a,1);
; 4469 :       type = stbi__zreceive(a,2);
; 4470 :       if (type == 0) {
; 4471 :          if (!stbi__parse_uncompressed_block(a)) return 0;
; 4472 :       } else if (type == 3) {
; 4473 :          return 0;
; 4474 :       } else {
; 4475 :          if (type == 1) {
; 4476 :             // use fixed code lengths
; 4477 :             if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
; 4478 :             if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
; 4479 :          } else {
; 4480 :             if (!stbi__compute_huffman_codes(a)) return 0;
; 4481 :          }
; 4482 :          if (!stbi__parse_huffman_block(a)) return 0;
; 4483 :       }
; 4484 :    } while (!final);
; 4485 :    return 1;
; 4486 : }
; 4487 : 
; 4488 : static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
; 4489 : {
; 4490 :    a->zout_start = obuf;
; 4491 :    a->zout       = obuf;
; 4492 :    a->zout_end   = obuf + olen;
; 4493 :    a->z_expandable = exp;
; 4494 : 
; 4495 :    return stbi__parse_zlib(a, parse_header);
; 4496 : }
; 4497 : 
; 4498 : STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
; 4499 : {
; 4500 :    stbi__zbuf a;
; 4501 :    char *p = (char *) stbi__malloc(initial_size);
; 4502 :    if (p == NULL) return NULL;
; 4503 :    a.zbuffer = (stbi_uc *) buffer;
; 4504 :    a.zbuffer_end = (stbi_uc *) buffer + len;
; 4505 :    if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
; 4506 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4507 :       return a.zout_start;
; 4508 :    } else {
; 4509 :       STBI_FREE(a.zout_start);
; 4510 :       return NULL;
; 4511 :    }
; 4512 : }
; 4513 : 
; 4514 : STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
; 4515 : {
; 4516 :    return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
; 4517 : }
; 4518 : 
; 4519 : STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
; 4520 : {
; 4521 :    stbi__zbuf a;
; 4522 :    char *p = (char *) stbi__malloc(initial_size);
; 4523 :    if (p == NULL) return NULL;
; 4524 :    a.zbuffer = (stbi_uc *) buffer;
; 4525 :    a.zbuffer_end = (stbi_uc *) buffer + len;
; 4526 :    if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
; 4527 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4528 :       return a.zout_start;
; 4529 :    } else {
; 4530 :       STBI_FREE(a.zout_start);
; 4531 :       return NULL;
; 4532 :    }
; 4533 : }
; 4534 : 
; 4535 : STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
; 4536 : {
; 4537 :    stbi__zbuf a;
; 4538 :    a.zbuffer = (stbi_uc *) ibuffer;
; 4539 :    a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
; 4540 :    if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
; 4541 :       return (int) (a.zout - a.zout_start);
; 4542 :    else
; 4543 :       return -1;
; 4544 : }
; 4545 : 
; 4546 : STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
; 4547 : {
; 4548 :    stbi__zbuf a;
; 4549 :    char *p = (char *) stbi__malloc(16384);
; 4550 :    if (p == NULL) return NULL;
; 4551 :    a.zbuffer = (stbi_uc *) buffer;
; 4552 :    a.zbuffer_end = (stbi_uc *) buffer+len;
; 4553 :    if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
; 4554 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4555 :       return a.zout_start;
; 4556 :    } else {
; 4557 :       STBI_FREE(a.zout_start);
; 4558 :       return NULL;
; 4559 :    }
; 4560 : }
; 4561 : 
; 4562 : STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
; 4563 : {
; 4564 :    stbi__zbuf a;
; 4565 :    a.zbuffer = (stbi_uc *) ibuffer;
; 4566 :    a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
; 4567 :    if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
; 4568 :       return (int) (a.zout - a.zout_start);
; 4569 :    else
; 4570 :       return -1;
; 4571 : }
; 4572 : #endif
; 4573 : 
; 4574 : // public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
; 4575 : //    simple implementation
; 4576 : //      - only 8-bit samples
; 4577 : //      - no CRC checking
; 4578 : //      - allocates lots of intermediate memory
; 4579 : //        - avoids problem of streaming data between subsystems
; 4580 : //        - avoids explicit window management
; 4581 : //    performance
; 4582 : //      - uses stb_zlib, a PD zlib implementation with fast huffman decoding
; 4583 : 
; 4584 : #ifndef STBI_NO_PNG
; 4585 : typedef struct
; 4586 : {
; 4587 :    stbi__uint32 length;
; 4588 :    stbi__uint32 type;
; 4589 : } stbi__pngchunk;
; 4590 : 
; 4591 : static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
; 4592 : {
; 4593 :    stbi__pngchunk c;
; 4594 :    c.length = stbi__get32be(s);
; 4595 :    c.type   = stbi__get32be(s);
; 4596 :    return c;
; 4597 : }
; 4598 : 
; 4599 : static int stbi__check_png_header(stbi__context *s)
; 4600 : {
; 4601 :    static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
; 4602 :    int i;
; 4603 :    for (i=0; i < 8; ++i)
; 4604 :       if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
; 4605 :    return 1;
; 4606 : }
; 4607 : 
; 4608 : typedef struct
; 4609 : {
; 4610 :    stbi__context *s;
; 4611 :    stbi_uc *idata, *expanded, *out;
; 4612 :    int depth;
; 4613 : } stbi__png;
; 4614 : 
; 4615 : 
; 4616 : enum {
; 4617 :    STBI__F_none=0,
; 4618 :    STBI__F_sub=1,
; 4619 :    STBI__F_up=2,
; 4620 :    STBI__F_avg=3,
; 4621 :    STBI__F_paeth=4,
; 4622 :    // synthetic filters used for first scanline to avoid needing a dummy row of 0s
; 4623 :    STBI__F_avg_first,
; 4624 :    STBI__F_paeth_first
; 4625 : };
; 4626 : 
; 4627 : static stbi_uc first_row_filter[5] =
; 4628 : {
; 4629 :    STBI__F_none,
; 4630 :    STBI__F_sub,
; 4631 :    STBI__F_none,
; 4632 :    STBI__F_avg_first,
; 4633 :    STBI__F_paeth_first
; 4634 : };
; 4635 : 
; 4636 : static int stbi__paeth(int a, int b, int c)
; 4637 : {
; 4638 :    int p = a + b - c;
; 4639 :    int pa = abs(p-a);
; 4640 :    int pb = abs(p-b);
; 4641 :    int pc = abs(p-c);
; 4642 :    if (pa <= pb && pa <= pc) return a;
; 4643 :    if (pb <= pc) return b;
; 4644 :    return c;
; 4645 : }
; 4646 : 
; 4647 : static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };
; 4648 : 
; 4649 : // create the png data from post-deflated data
; 4650 : static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
; 4651 : {
; 4652 :    int bytes = (depth == 16? 2 : 1);
; 4653 :    stbi__context *s = a->s;
; 4654 :    stbi__uint32 i,j,stride = x*out_n*bytes;
; 4655 :    stbi__uint32 img_len, img_width_bytes;
; 4656 :    int k;
; 4657 :    int img_n = s->img_n; // copy it into a local for later
; 4658 : 
; 4659 :    int output_bytes = out_n*bytes;
; 4660 :    int filter_bytes = img_n*bytes;
; 4661 :    int width = x;
; 4662 : 
; 4663 :    STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
; 4664 :    a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
; 4665 :    if (!a->out) return stbi__err("outofmem", "Out of memory");
; 4666 : 
; 4667 :    if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
; 4668 :    img_width_bytes = (((img_n * x * depth) + 7) >> 3);
; 4669 :    img_len = (img_width_bytes + 1) * y;
; 4670 : 
; 4671 :    // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
; 4672 :    // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
; 4673 :    // so just check for raw_len < img_len always.
; 4674 :    if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");
; 4675 : 
; 4676 :    for (j=0; j < y; ++j) {
; 4677 :       stbi_uc *cur = a->out + stride*j;
; 4678 :       stbi_uc *prior;
; 4679 :       int filter = *raw++;
; 4680 : 
; 4681 :       if (filter > 4)
; 4682 :          return stbi__err("invalid filter","Corrupt PNG");
; 4683 : 
; 4684 :       if (depth < 8) {
; 4685 :          if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");
; 4686 :          cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
; 4687 :          filter_bytes = 1;
; 4688 :          width = img_width_bytes;
; 4689 :       }
; 4690 :       prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above
; 4691 : 
; 4692 :       // if first row, use special filter that doesn't sample previous row
; 4693 :       if (j == 0) filter = first_row_filter[filter];
; 4694 : 
; 4695 :       // handle first byte explicitly
; 4696 :       for (k=0; k < filter_bytes; ++k) {
; 4697 :          switch (filter) {
; 4698 :             case STBI__F_none       : cur[k] = raw[k]; break;
; 4699 :             case STBI__F_sub        : cur[k] = raw[k]; break;
; 4700 :             case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
; 4701 :             case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;
; 4702 :             case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;
; 4703 :             case STBI__F_avg_first  : cur[k] = raw[k]; break;
; 4704 :             case STBI__F_paeth_first: cur[k] = raw[k]; break;
; 4705 :          }
; 4706 :       }
; 4707 : 
; 4708 :       if (depth == 8) {
; 4709 :          if (img_n != out_n)
; 4710 :             cur[img_n] = 255; // first pixel
; 4711 :          raw += img_n;
; 4712 :          cur += out_n;
; 4713 :          prior += out_n;
; 4714 :       } else if (depth == 16) {
; 4715 :          if (img_n != out_n) {
; 4716 :             cur[filter_bytes]   = 255; // first pixel top byte
; 4717 :             cur[filter_bytes+1] = 255; // first pixel bottom byte
; 4718 :          }
; 4719 :          raw += filter_bytes;
; 4720 :          cur += output_bytes;
; 4721 :          prior += output_bytes;
; 4722 :       } else {
; 4723 :          raw += 1;
; 4724 :          cur += 1;
; 4725 :          prior += 1;
; 4726 :       }
; 4727 : 
; 4728 :       // this is a little gross, so that we don't switch per-pixel or per-component
; 4729 :       if (depth < 8 || img_n == out_n) {
; 4730 :          int nk = (width - 1)*filter_bytes;
; 4731 :          #define STBI__CASE(f) \
; 4732 :              case f:     \
; 4733 :                 for (k=0; k < nk; ++k)
; 4734 :          switch (filter) {
; 4735 :             // "none" filter turns into a memcpy here; make that explicit.
; 4736 :             case STBI__F_none:         memcpy(cur, raw, nk); break;
; 4737 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;
; 4738 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
; 4739 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;
; 4740 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;
; 4741 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;
; 4742 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;
; 4743 :          }
; 4744 :          #undef STBI__CASE
; 4745 :          raw += nk;
; 4746 :       } else {
; 4747 :          STBI_ASSERT(img_n+1 == out_n);
; 4748 :          #define STBI__CASE(f) \
; 4749 :              case f:     \
; 4750 :                 for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
; 4751 :                    for (k=0; k < filter_bytes; ++k)
; 4752 :          switch (filter) {
; 4753 :             STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;
; 4754 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;
; 4755 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
; 4756 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;
; 4757 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;
; 4758 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;
; 4759 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;
; 4760 :          }
; 4761 :          #undef STBI__CASE
; 4762 : 
; 4763 :          // the loop above sets the high byte of the pixels' alpha, but for
; 4764 :          // 16 bit png files we also need the low byte set. we'll do that here.
; 4765 :          if (depth == 16) {
; 4766 :             cur = a->out + stride*j; // start at the beginning of the row again
; 4767 :             for (i=0; i < x; ++i,cur+=output_bytes) {
; 4768 :                cur[filter_bytes+1] = 255;
; 4769 :             }
; 4770 :          }
; 4771 :       }
; 4772 :    }
; 4773 : 
; 4774 :    // we make a separate pass to expand bits to pixels; for performance,
; 4775 :    // this could run two scanlines behind the above code, so it won't
; 4776 :    // intefere with filtering but will still be in the cache.
; 4777 :    if (depth < 8) {
; 4778 :       for (j=0; j < y; ++j) {
; 4779 :          stbi_uc *cur = a->out + stride*j;
; 4780 :          stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
; 4781 :          // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
; 4782 :          // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
; 4783 :          stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range
; 4784 : 
; 4785 :          // note that the final byte might overshoot and write more data than desired.
; 4786 :          // we can allocate enough data that this never writes out of memory, but it
; 4787 :          // could also overwrite the next scanline. can it overwrite non-empty data
; 4788 :          // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
; 4789 :          // so we need to explicitly clamp the final ones
; 4790 : 
; 4791 :          if (depth == 4) {
; 4792 :             for (k=x*img_n; k >= 2; k-=2, ++in) {
; 4793 :                *cur++ = scale * ((*in >> 4)       );
; 4794 :                *cur++ = scale * ((*in     ) & 0x0f);
; 4795 :             }
; 4796 :             if (k > 0) *cur++ = scale * ((*in >> 4)       );
; 4797 :          } else if (depth == 2) {
; 4798 :             for (k=x*img_n; k >= 4; k-=4, ++in) {
; 4799 :                *cur++ = scale * ((*in >> 6)       );
; 4800 :                *cur++ = scale * ((*in >> 4) & 0x03);
; 4801 :                *cur++ = scale * ((*in >> 2) & 0x03);
; 4802 :                *cur++ = scale * ((*in     ) & 0x03);
; 4803 :             }
; 4804 :             if (k > 0) *cur++ = scale * ((*in >> 6)       );
; 4805 :             if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
; 4806 :             if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
; 4807 :          } else if (depth == 1) {
; 4808 :             for (k=x*img_n; k >= 8; k-=8, ++in) {
; 4809 :                *cur++ = scale * ((*in >> 7)       );
; 4810 :                *cur++ = scale * ((*in >> 6) & 0x01);
; 4811 :                *cur++ = scale * ((*in >> 5) & 0x01);
; 4812 :                *cur++ = scale * ((*in >> 4) & 0x01);
; 4813 :                *cur++ = scale * ((*in >> 3) & 0x01);
; 4814 :                *cur++ = scale * ((*in >> 2) & 0x01);
; 4815 :                *cur++ = scale * ((*in >> 1) & 0x01);
; 4816 :                *cur++ = scale * ((*in     ) & 0x01);
; 4817 :             }
; 4818 :             if (k > 0) *cur++ = scale * ((*in >> 7)       );
; 4819 :             if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
; 4820 :             if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
; 4821 :             if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
; 4822 :             if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
; 4823 :             if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
; 4824 :             if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
; 4825 :          }
; 4826 :          if (img_n != out_n) {
; 4827 :             int q;
; 4828 :             // insert alpha = 255
; 4829 :             cur = a->out + stride*j;
; 4830 :             if (img_n == 1) {
; 4831 :                for (q=x-1; q >= 0; --q) {
; 4832 :                   cur[q*2+1] = 255;
; 4833 :                   cur[q*2+0] = cur[q];
; 4834 :                }
; 4835 :             } else {
; 4836 :                STBI_ASSERT(img_n == 3);
; 4837 :                for (q=x-1; q >= 0; --q) {
; 4838 :                   cur[q*4+3] = 255;
; 4839 :                   cur[q*4+2] = cur[q*3+2];
; 4840 :                   cur[q*4+1] = cur[q*3+1];
; 4841 :                   cur[q*4+0] = cur[q*3+0];
; 4842 :                }
; 4843 :             }
; 4844 :          }
; 4845 :       }
; 4846 :    } else if (depth == 16) {
; 4847 :       // force the image data from big-endian to platform-native.
; 4848 :       // this is done in a separate pass due to the decoding relying
; 4849 :       // on the data being untouched, but could probably be done
; 4850 :       // per-line during decode if care is taken.
; 4851 :       stbi_uc *cur = a->out;
; 4852 :       stbi__uint16 *cur16 = (stbi__uint16*)cur;
; 4853 : 
; 4854 :       for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {
; 4855 :          *cur16 = (cur[0] << 8) | cur[1];
; 4856 :       }
; 4857 :    }
; 4858 : 
; 4859 :    return 1;
; 4860 : }
; 4861 : 
; 4862 : static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
; 4863 : {
; 4864 :    int bytes = (depth == 16 ? 2 : 1);
; 4865 :    int out_bytes = out_n * bytes;
; 4866 :    stbi_uc *final;
; 4867 :    int p;
; 4868 :    if (!interlaced)
; 4869 :       return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);
; 4870 : 
; 4871 :    // de-interlacing
; 4872 :    final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
; 4873 :    if (!final) return stbi__err("outofmem", "Out of memory");
; 4874 :    for (p=0; p < 7; ++p) {
; 4875 :       int xorig[] = { 0,4,0,2,0,1,0 };
; 4876 :       int yorig[] = { 0,0,4,0,2,0,1 };
; 4877 :       int xspc[]  = { 8,8,4,4,2,2,1 };
; 4878 :       int yspc[]  = { 8,8,8,4,4,2,2 };
; 4879 :       int i,j,x,y;
; 4880 :       // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
; 4881 :       x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
; 4882 :       y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
; 4883 :       if (x && y) {
; 4884 :          stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
; 4885 :          if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
; 4886 :             STBI_FREE(final);
; 4887 :             return 0;
; 4888 :          }
; 4889 :          for (j=0; j < y; ++j) {
; 4890 :             for (i=0; i < x; ++i) {
; 4891 :                int out_y = j*yspc[p]+yorig[p];
; 4892 :                int out_x = i*xspc[p]+xorig[p];
; 4893 :                memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
; 4894 :                       a->out + (j*x+i)*out_bytes, out_bytes);
; 4895 :             }
; 4896 :          }
; 4897 :          STBI_FREE(a->out);
; 4898 :          image_data += img_len;
; 4899 :          image_data_len -= img_len;
; 4900 :       }
; 4901 :    }
; 4902 :    a->out = final;
; 4903 : 
; 4904 :    return 1;
; 4905 : }
; 4906 : 
; 4907 : static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
; 4908 : {
; 4909 :    stbi__context *s = z->s;
; 4910 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 4911 :    stbi_uc *p = z->out;
; 4912 : 
; 4913 :    // compute color-based transparency, assuming we've
; 4914 :    // already got 255 as the alpha value in the output
; 4915 :    STBI_ASSERT(out_n == 2 || out_n == 4);
; 4916 : 
; 4917 :    if (out_n == 2) {
; 4918 :       for (i=0; i < pixel_count; ++i) {
; 4919 :          p[1] = (p[0] == tc[0] ? 0 : 255);
; 4920 :          p += 2;
; 4921 :       }
; 4922 :    } else {
; 4923 :       for (i=0; i < pixel_count; ++i) {
; 4924 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
; 4925 :             p[3] = 0;
; 4926 :          p += 4;
; 4927 :       }
; 4928 :    }
; 4929 :    return 1;
; 4930 : }
; 4931 : 
; 4932 : static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
; 4933 : {
; 4934 :    stbi__context *s = z->s;
; 4935 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 4936 :    stbi__uint16 *p = (stbi__uint16*) z->out;
; 4937 : 
; 4938 :    // compute color-based transparency, assuming we've
; 4939 :    // already got 65535 as the alpha value in the output
; 4940 :    STBI_ASSERT(out_n == 2 || out_n == 4);
; 4941 : 
; 4942 :    if (out_n == 2) {
; 4943 :       for (i = 0; i < pixel_count; ++i) {
; 4944 :          p[1] = (p[0] == tc[0] ? 0 : 65535);
; 4945 :          p += 2;
; 4946 :       }
; 4947 :    } else {
; 4948 :       for (i = 0; i < pixel_count; ++i) {
; 4949 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
; 4950 :             p[3] = 0;
; 4951 :          p += 4;
; 4952 :       }
; 4953 :    }
; 4954 :    return 1;
; 4955 : }
; 4956 : 
; 4957 : static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
; 4958 : {
; 4959 :    stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
; 4960 :    stbi_uc *p, *temp_out, *orig = a->out;
; 4961 : 
; 4962 :    p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
; 4963 :    if (p == NULL) return stbi__err("outofmem", "Out of memory");
; 4964 : 
; 4965 :    // between here and free(out) below, exitting would leak
; 4966 :    temp_out = p;
; 4967 : 
; 4968 :    if (pal_img_n == 3) {
; 4969 :       for (i=0; i < pixel_count; ++i) {
; 4970 :          int n = orig[i]*4;
; 4971 :          p[0] = palette[n  ];
; 4972 :          p[1] = palette[n+1];
; 4973 :          p[2] = palette[n+2];
; 4974 :          p += 3;
; 4975 :       }
; 4976 :    } else {
; 4977 :       for (i=0; i < pixel_count; ++i) {
; 4978 :          int n = orig[i]*4;
; 4979 :          p[0] = palette[n  ];
; 4980 :          p[1] = palette[n+1];
; 4981 :          p[2] = palette[n+2];
; 4982 :          p[3] = palette[n+3];
; 4983 :          p += 4;
; 4984 :       }
; 4985 :    }
; 4986 :    STBI_FREE(a->out);
; 4987 :    a->out = temp_out;
; 4988 : 
; 4989 :    STBI_NOTUSED(len);
; 4990 : 
; 4991 :    return 1;
; 4992 : }
; 4993 : 
; 4994 : static int stbi__unpremultiply_on_load_global = 0;
; 4995 : static int stbi__de_iphone_flag_global = 0;
; 4996 : 
; 4997 : STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
; 4998 : {
; 4999 :    stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
; 5000 : }
; 5001 : 
; 5002 : STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
; 5003 : {
; 5004 :    stbi__de_iphone_flag_global = flag_true_if_should_convert;
; 5005 : }
; 5006 : 
; 5007 : #ifndef STBI_THREAD_LOCAL
; 5008 : #define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global
; 5009 : #define stbi__de_iphone_flag  stbi__de_iphone_flag_global
; 5010 : #else
; 5011 : static STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;
; 5012 : static STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;
; 5013 : 
; 5014 : STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
; 5015 : {
; 5016 :    stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
; 5017 :    stbi__unpremultiply_on_load_set = 1;
; 5018 : }
; 5019 : 
; 5020 : STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
; 5021 : {
; 5022 :    stbi__de_iphone_flag_local = flag_true_if_should_convert;
; 5023 :    stbi__de_iphone_flag_set = 1;
; 5024 : }
; 5025 : 
; 5026 : #define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \
; 5027 :                                        ? stbi__unpremultiply_on_load_local      \
; 5028 :                                        : stbi__unpremultiply_on_load_global)
; 5029 : #define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \
; 5030 :                                 ? stbi__de_iphone_flag_local                    \
; 5031 :                                 : stbi__de_iphone_flag_global)
; 5032 : #endif // STBI_THREAD_LOCAL
; 5033 : 
; 5034 : static void stbi__de_iphone(stbi__png *z)
; 5035 : {
; 5036 :    stbi__context *s = z->s;
; 5037 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 5038 :    stbi_uc *p = z->out;
; 5039 : 
; 5040 :    if (s->img_out_n == 3) {  // convert bgr to rgb
; 5041 :       for (i=0; i < pixel_count; ++i) {
; 5042 :          stbi_uc t = p[0];
; 5043 :          p[0] = p[2];
; 5044 :          p[2] = t;
; 5045 :          p += 3;
; 5046 :       }
; 5047 :    } else {
; 5048 :       STBI_ASSERT(s->img_out_n == 4);
; 5049 :       if (stbi__unpremultiply_on_load) {
; 5050 :          // convert bgr to rgb and unpremultiply
; 5051 :          for (i=0; i < pixel_count; ++i) {
; 5052 :             stbi_uc a = p[3];
; 5053 :             stbi_uc t = p[0];
; 5054 :             if (a) {
; 5055 :                stbi_uc half = a / 2;
; 5056 :                p[0] = (p[2] * 255 + half) / a;
; 5057 :                p[1] = (p[1] * 255 + half) / a;
; 5058 :                p[2] = ( t   * 255 + half) / a;
; 5059 :             } else {
; 5060 :                p[0] = p[2];
; 5061 :                p[2] = t;
; 5062 :             }
; 5063 :             p += 4;
; 5064 :          }
; 5065 :       } else {
; 5066 :          // convert bgr to rgb
; 5067 :          for (i=0; i < pixel_count; ++i) {
; 5068 :             stbi_uc t = p[0];
; 5069 :             p[0] = p[2];
; 5070 :             p[2] = t;
; 5071 :             p += 4;
; 5072 :          }
; 5073 :       }
; 5074 :    }
; 5075 : }
; 5076 : 
; 5077 : #define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))
; 5078 : 
; 5079 : static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
; 5080 : {
; 5081 :    stbi_uc palette[1024], pal_img_n=0;
; 5082 :    stbi_uc has_trans=0, tc[3]={0};
; 5083 :    stbi__uint16 tc16[3];
; 5084 :    stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
; 5085 :    int first=1,k,interlace=0, color=0, is_iphone=0;
; 5086 :    stbi__context *s = z->s;
; 5087 : 
; 5088 :    z->expanded = NULL;
; 5089 :    z->idata = NULL;
; 5090 :    z->out = NULL;
; 5091 : 
; 5092 :    if (!stbi__check_png_header(s)) return 0;
; 5093 : 
; 5094 :    if (scan == STBI__SCAN_type) return 1;
; 5095 : 
; 5096 :    for (;;) {
; 5097 :       stbi__pngchunk c = stbi__get_chunk_header(s);
; 5098 :       switch (c.type) {
; 5099 :          case STBI__PNG_TYPE('C','g','B','I'):
; 5100 :             is_iphone = 1;
; 5101 :             stbi__skip(s, c.length);
; 5102 :             break;
; 5103 :          case STBI__PNG_TYPE('I','H','D','R'): {
; 5104 :             int comp,filter;
; 5105 :             if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
; 5106 :             first = 0;
; 5107 :             if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
; 5108 :             s->img_x = stbi__get32be(s);
; 5109 :             s->img_y = stbi__get32be(s);
; 5110 :             if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 5111 :             if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 5112 :             z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
; 5113 :             color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
; 5114 :             if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
; 5115 :             if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
; 5116 :             comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
; 5117 :             filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
; 5118 :             interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
; 5119 :             if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
; 5120 :             if (!pal_img_n) {
; 5121 :                s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
; 5122 :                if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
; 5123 :             } else {
; 5124 :                // if paletted, then pal_n is our final components, and
; 5125 :                // img_n is # components to decompress/filter.
; 5126 :                s->img_n = 1;
; 5127 :                if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
; 5128 :             }
; 5129 :             // even with SCAN_header, have to scan to see if we have a tRNS
; 5130 :             break;
; 5131 :          }
; 5132 : 
; 5133 :          case STBI__PNG_TYPE('P','L','T','E'):  {
; 5134 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5135 :             if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
; 5136 :             pal_len = c.length / 3;
; 5137 :             if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
; 5138 :             for (i=0; i < pal_len; ++i) {
; 5139 :                palette[i*4+0] = stbi__get8(s);
; 5140 :                palette[i*4+1] = stbi__get8(s);
; 5141 :                palette[i*4+2] = stbi__get8(s);
; 5142 :                palette[i*4+3] = 255;
; 5143 :             }
; 5144 :             break;
; 5145 :          }
; 5146 : 
; 5147 :          case STBI__PNG_TYPE('t','R','N','S'): {
; 5148 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5149 :             if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
; 5150 :             if (pal_img_n) {
; 5151 :                if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
; 5152 :                if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
; 5153 :                if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
; 5154 :                pal_img_n = 4;
; 5155 :                for (i=0; i < c.length; ++i)
; 5156 :                   palette[i*4+3] = stbi__get8(s);
; 5157 :             } else {
; 5158 :                if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
; 5159 :                if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
; 5160 :                has_trans = 1;
; 5161 :                // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.
; 5162 :                if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }
; 5163 :                if (z->depth == 16) {
; 5164 :                   for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
; 5165 :                } else {
; 5166 :                   for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
; 5167 :                }
; 5168 :             }
; 5169 :             break;
; 5170 :          }
; 5171 : 
; 5172 :          case STBI__PNG_TYPE('I','D','A','T'): {
; 5173 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5174 :             if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
; 5175 :             if (scan == STBI__SCAN_header) {
; 5176 :                // header scan definitely stops at first IDAT
; 5177 :                if (pal_img_n)
; 5178 :                   s->img_n = pal_img_n;
; 5179 :                return 1;
; 5180 :             }
; 5181 :             if (c.length > (1u << 30)) return stbi__err("IDAT size limit", "IDAT section larger than 2^30 bytes");
; 5182 :             if ((int)(ioff + c.length) < (int)ioff) return 0;
; 5183 :             if (ioff + c.length > idata_limit) {
; 5184 :                stbi__uint32 idata_limit_old = idata_limit;
; 5185 :                stbi_uc *p;
; 5186 :                if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
; 5187 :                while (ioff + c.length > idata_limit)
; 5188 :                   idata_limit *= 2;
; 5189 :                STBI_NOTUSED(idata_limit_old);
; 5190 :                p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
; 5191 :                z->idata = p;
; 5192 :             }
; 5193 :             if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
; 5194 :             ioff += c.length;
; 5195 :             break;
; 5196 :          }
; 5197 : 
; 5198 :          case STBI__PNG_TYPE('I','E','N','D'): {
; 5199 :             stbi__uint32 raw_len, bpl;
; 5200 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5201 :             if (scan != STBI__SCAN_load) return 1;
; 5202 :             if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
; 5203 :             // initial guess for decoded data size to avoid unnecessary reallocs
; 5204 :             bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
; 5205 :             raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
; 5206 :             z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
; 5207 :             if (z->expanded == NULL) return 0; // zlib should set error
; 5208 :             STBI_FREE(z->idata); z->idata = NULL;
; 5209 :             if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
; 5210 :                s->img_out_n = s->img_n+1;
; 5211 :             else
; 5212 :                s->img_out_n = s->img_n;
; 5213 :             if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
; 5214 :             if (has_trans) {
; 5215 :                if (z->depth == 16) {
; 5216 :                   if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
; 5217 :                } else {
; 5218 :                   if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
; 5219 :                }
; 5220 :             }
; 5221 :             if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
; 5222 :                stbi__de_iphone(z);
; 5223 :             if (pal_img_n) {
; 5224 :                // pal_img_n == 3 or 4
; 5225 :                s->img_n = pal_img_n; // record the actual colors we had
; 5226 :                s->img_out_n = pal_img_n;
; 5227 :                if (req_comp >= 3) s->img_out_n = req_comp;
; 5228 :                if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
; 5229 :                   return 0;
; 5230 :             } else if (has_trans) {
; 5231 :                // non-paletted image with tRNS -> source image has (constant) alpha
; 5232 :                ++s->img_n;
; 5233 :             }
; 5234 :             STBI_FREE(z->expanded); z->expanded = NULL;
; 5235 :             // end of PNG chunk, read and skip CRC
; 5236 :             stbi__get32be(s);
; 5237 :             return 1;
; 5238 :          }
; 5239 : 
; 5240 :          default:
; 5241 :             // if critical, fail
; 5242 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5243 :             if ((c.type & (1 << 29)) == 0) {
; 5244 :                #ifndef STBI_NO_FAILURE_STRINGS
; 5245 :                // not threadsafe
; 5246 :                static char invalid_chunk[] = "XXXX PNG chunk not known";
; 5247 :                invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
; 5248 :                invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
; 5249 :                invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
; 5250 :                invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
; 5251 :                #endif
; 5252 :                return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
; 5253 :             }
; 5254 :             stbi__skip(s, c.length);
; 5255 :             break;
; 5256 :       }
; 5257 :       // end of PNG chunk, read and skip CRC
; 5258 :       stbi__get32be(s);
; 5259 :    }
; 5260 : }
; 5261 : 
; 5262 : static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
; 5263 : {
; 5264 :    void *result=NULL;
; 5265 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
; 5266 :    if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
; 5267 :       if (p->depth <= 8)
; 5268 :          ri->bits_per_channel = 8;
; 5269 :       else if (p->depth == 16)
; 5270 :          ri->bits_per_channel = 16;
; 5271 :       else
; 5272 :          return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
; 5273 :       result = p->out;
; 5274 :       p->out = NULL;
; 5275 :       if (req_comp && req_comp != p->s->img_out_n) {
; 5276 :          if (ri->bits_per_channel == 8)
; 5277 :             result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
; 5278 :          else
; 5279 :             result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
; 5280 :          p->s->img_out_n = req_comp;
; 5281 :          if (result == NULL) return result;
; 5282 :       }
; 5283 :       *x = p->s->img_x;
; 5284 :       *y = p->s->img_y;
; 5285 :       if (n) *n = p->s->img_n;
; 5286 :    }
; 5287 :    STBI_FREE(p->out);      p->out      = NULL;
; 5288 :    STBI_FREE(p->expanded); p->expanded = NULL;
; 5289 :    STBI_FREE(p->idata);    p->idata    = NULL;
; 5290 : 
; 5291 :    return result;
; 5292 : }
; 5293 : 
; 5294 : static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5295 : {
; 5296 :    stbi__png p;
; 5297 :    p.s = s;
; 5298 :    return stbi__do_png(&p, x,y,comp,req_comp, ri);
; 5299 : }
; 5300 : 
; 5301 : static int stbi__png_test(stbi__context *s)
; 5302 : {
; 5303 :    int r;
; 5304 :    r = stbi__check_png_header(s);
; 5305 :    stbi__rewind(s);
; 5306 :    return r;
; 5307 : }
; 5308 : 
; 5309 : static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
; 5310 : {
; 5311 :    if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
; 5312 :       stbi__rewind( p->s );
; 5313 :       return 0;
; 5314 :    }
; 5315 :    if (x) *x = p->s->img_x;
; 5316 :    if (y) *y = p->s->img_y;
; 5317 :    if (comp) *comp = p->s->img_n;
; 5318 :    return 1;
; 5319 : }
; 5320 : 
; 5321 : static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
; 5322 : {
; 5323 :    stbi__png p;
; 5324 :    p.s = s;
; 5325 :    return stbi__png_info_raw(&p, x, y, comp);
; 5326 : }
; 5327 : 
; 5328 : static int stbi__png_is16(stbi__context *s)
; 5329 : {
; 5330 :    stbi__png p;
; 5331 :    p.s = s;
; 5332 :    if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
; 5333 : 	   return 0;
; 5334 :    if (p.depth != 16) {
; 5335 :       stbi__rewind(p.s);
; 5336 :       return 0;
; 5337 :    }
; 5338 :    return 1;
; 5339 : }
; 5340 : #endif
; 5341 : 
; 5342 : // Microsoft/Windows BMP image
; 5343 : 
; 5344 : #ifndef STBI_NO_BMP
; 5345 : static int stbi__bmp_test_raw(stbi__context *s)
; 5346 : {
; 5347 :    int r;
; 5348 :    int sz;
; 5349 :    if (stbi__get8(s) != 'B') return 0;
; 5350 :    if (stbi__get8(s) != 'M') return 0;
; 5351 :    stbi__get32le(s); // discard filesize
; 5352 :    stbi__get16le(s); // discard reserved
; 5353 :    stbi__get16le(s); // discard reserved
; 5354 :    stbi__get32le(s); // discard data offset
; 5355 :    sz = stbi__get32le(s);
; 5356 :    r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
; 5357 :    return r;
; 5358 : }
; 5359 : 
; 5360 : static int stbi__bmp_test(stbi__context *s)
; 5361 : {
; 5362 :    int r = stbi__bmp_test_raw(s);
; 5363 :    stbi__rewind(s);
; 5364 :    return r;
; 5365 : }
; 5366 : 
; 5367 : 
; 5368 : // returns 0..31 for the highest set bit
; 5369 : static int stbi__high_bit(unsigned int z)
; 5370 : {
; 5371 :    int n=0;
; 5372 :    if (z == 0) return -1;
; 5373 :    if (z >= 0x10000) { n += 16; z >>= 16; }
; 5374 :    if (z >= 0x00100) { n +=  8; z >>=  8; }
; 5375 :    if (z >= 0x00010) { n +=  4; z >>=  4; }
; 5376 :    if (z >= 0x00004) { n +=  2; z >>=  2; }
; 5377 :    if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
; 5378 :    return n;
; 5379 : }
; 5380 : 
; 5381 : static int stbi__bitcount(unsigned int a)
; 5382 : {
; 5383 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
; 5384 :    a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
; 5385 :    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
; 5386 :    a = (a + (a >> 8)); // max 16 per 8 bits
; 5387 :    a = (a + (a >> 16)); // max 32 per 8 bits
; 5388 :    return a & 0xff;
; 5389 : }
; 5390 : 
; 5391 : // extract an arbitrarily-aligned N-bit value (N=bits)
; 5392 : // from v, and then make it 8-bits long and fractionally
; 5393 : // extend it to full full range.
; 5394 : static int stbi__shiftsigned(unsigned int v, int shift, int bits)
; 5395 : {
; 5396 :    static unsigned int mul_table[9] = {
; 5397 :       0,
; 5398 :       0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
; 5399 :       0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
; 5400 :    };
; 5401 :    static unsigned int shift_table[9] = {
; 5402 :       0, 0,0,1,0,2,4,6,0,
; 5403 :    };
; 5404 :    if (shift < 0)
; 5405 :       v <<= -shift;
; 5406 :    else
; 5407 :       v >>= shift;
; 5408 :    STBI_ASSERT(v < 256);
; 5409 :    v >>= (8-bits);
; 5410 :    STBI_ASSERT(bits >= 0 && bits <= 8);
; 5411 :    return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
; 5412 : }
; 5413 : 
; 5414 : typedef struct
; 5415 : {
; 5416 :    int bpp, offset, hsz;
; 5417 :    unsigned int mr,mg,mb,ma, all_a;
; 5418 :    int extra_read;
; 5419 : } stbi__bmp_data;
; 5420 : 
; 5421 : static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
; 5422 : {
; 5423 :    // BI_BITFIELDS specifies masks explicitly, don't override
; 5424 :    if (compress == 3)
; 5425 :       return 1;
; 5426 : 
; 5427 :    if (compress == 0) {
; 5428 :       if (info->bpp == 16) {
; 5429 :          info->mr = 31u << 10;
; 5430 :          info->mg = 31u <<  5;
; 5431 :          info->mb = 31u <<  0;
; 5432 :       } else if (info->bpp == 32) {
; 5433 :          info->mr = 0xffu << 16;
; 5434 :          info->mg = 0xffu <<  8;
; 5435 :          info->mb = 0xffu <<  0;
; 5436 :          info->ma = 0xffu << 24;
; 5437 :          info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
; 5438 :       } else {
; 5439 :          // otherwise, use defaults, which is all-0
; 5440 :          info->mr = info->mg = info->mb = info->ma = 0;
; 5441 :       }
; 5442 :       return 1;
; 5443 :    }
; 5444 :    return 0; // error
; 5445 : }
; 5446 : 
; 5447 : static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
; 5448 : {
; 5449 :    int hsz;
; 5450 :    if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
; 5451 :    stbi__get32le(s); // discard filesize
; 5452 :    stbi__get16le(s); // discard reserved
; 5453 :    stbi__get16le(s); // discard reserved
; 5454 :    info->offset = stbi__get32le(s);
; 5455 :    info->hsz = hsz = stbi__get32le(s);
; 5456 :    info->mr = info->mg = info->mb = info->ma = 0;
; 5457 :    info->extra_read = 14;
; 5458 : 
; 5459 :    if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");
; 5460 : 
; 5461 :    if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
; 5462 :    if (hsz == 12) {
; 5463 :       s->img_x = stbi__get16le(s);
; 5464 :       s->img_y = stbi__get16le(s);
; 5465 :    } else {
; 5466 :       s->img_x = stbi__get32le(s);
; 5467 :       s->img_y = stbi__get32le(s);
; 5468 :    }
; 5469 :    if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
; 5470 :    info->bpp = stbi__get16le(s);
; 5471 :    if (hsz != 12) {
; 5472 :       int compress = stbi__get32le(s);
; 5473 :       if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
; 5474 :       if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes
; 5475 :       if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel
; 5476 :       stbi__get32le(s); // discard sizeof
; 5477 :       stbi__get32le(s); // discard hres
; 5478 :       stbi__get32le(s); // discard vres
; 5479 :       stbi__get32le(s); // discard colorsused
; 5480 :       stbi__get32le(s); // discard max important
; 5481 :       if (hsz == 40 || hsz == 56) {
; 5482 :          if (hsz == 56) {
; 5483 :             stbi__get32le(s);
; 5484 :             stbi__get32le(s);
; 5485 :             stbi__get32le(s);
; 5486 :             stbi__get32le(s);
; 5487 :          }
; 5488 :          if (info->bpp == 16 || info->bpp == 32) {
; 5489 :             if (compress == 0) {
; 5490 :                stbi__bmp_set_mask_defaults(info, compress);
; 5491 :             } else if (compress == 3) {
; 5492 :                info->mr = stbi__get32le(s);
; 5493 :                info->mg = stbi__get32le(s);
; 5494 :                info->mb = stbi__get32le(s);
; 5495 :                info->extra_read += 12;
; 5496 :                // not documented, but generated by photoshop and handled by mspaint
; 5497 :                if (info->mr == info->mg && info->mg == info->mb) {
; 5498 :                   // ?!?!?
; 5499 :                   return stbi__errpuc("bad BMP", "bad BMP");
; 5500 :                }
; 5501 :             } else
; 5502 :                return stbi__errpuc("bad BMP", "bad BMP");
; 5503 :          }
; 5504 :       } else {
; 5505 :          // V4/V5 header
; 5506 :          int i;
; 5507 :          if (hsz != 108 && hsz != 124)
; 5508 :             return stbi__errpuc("bad BMP", "bad BMP");
; 5509 :          info->mr = stbi__get32le(s);
; 5510 :          info->mg = stbi__get32le(s);
; 5511 :          info->mb = stbi__get32le(s);
; 5512 :          info->ma = stbi__get32le(s);
; 5513 :          if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
; 5514 :             stbi__bmp_set_mask_defaults(info, compress);
; 5515 :          stbi__get32le(s); // discard color space
; 5516 :          for (i=0; i < 12; ++i)
; 5517 :             stbi__get32le(s); // discard color space parameters
; 5518 :          if (hsz == 124) {
; 5519 :             stbi__get32le(s); // discard rendering intent
; 5520 :             stbi__get32le(s); // discard offset of profile data
; 5521 :             stbi__get32le(s); // discard size of profile data
; 5522 :             stbi__get32le(s); // discard reserved
; 5523 :          }
; 5524 :       }
; 5525 :    }
; 5526 :    return (void *) 1;
; 5527 : }
; 5528 : 
; 5529 : 
; 5530 : static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5531 : {
; 5532 :    stbi_uc *out;
; 5533 :    unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
; 5534 :    stbi_uc pal[256][4];
; 5535 :    int psize=0,i,j,width;
; 5536 :    int flip_vertically, pad, target;
; 5537 :    stbi__bmp_data info;
; 5538 :    STBI_NOTUSED(ri);
; 5539 : 
; 5540 :    info.all_a = 255;
; 5541 :    if (stbi__bmp_parse_header(s, &info) == NULL)
; 5542 :       return NULL; // error code already set
; 5543 : 
; 5544 :    flip_vertically = ((int) s->img_y) > 0;
; 5545 :    s->img_y = abs((int) s->img_y);
; 5546 : 
; 5547 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5548 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5549 : 
; 5550 :    mr = info.mr;
; 5551 :    mg = info.mg;
; 5552 :    mb = info.mb;
; 5553 :    ma = info.ma;
; 5554 :    all_a = info.all_a;
; 5555 : 
; 5556 :    if (info.hsz == 12) {
; 5557 :       if (info.bpp < 24)
; 5558 :          psize = (info.offset - info.extra_read - 24) / 3;
; 5559 :    } else {
; 5560 :       if (info.bpp < 16)
; 5561 :          psize = (info.offset - info.extra_read - info.hsz) >> 2;
; 5562 :    }
; 5563 :    if (psize == 0) {
; 5564 :       // accept some number of extra bytes after the header, but if the offset points either to before
; 5565 :       // the header ends or implies a large amount of extra data, reject the file as malformed
; 5566 :       int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);
; 5567 :       int header_limit = 1024; // max we actually read is below 256 bytes currently.
; 5568 :       int extra_data_limit = 256*4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.
; 5569 :       if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {
; 5570 :          return stbi__errpuc("bad header", "Corrupt BMP");
; 5571 :       }
; 5572 :       // we established that bytes_read_so_far is positive and sensible.
; 5573 :       // the first half of this test rejects offsets that are either too small positives, or
; 5574 :       // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn
; 5575 :       // ensures the number computed in the second half of the test can't overflow.
; 5576 :       if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {
; 5577 :          return stbi__errpuc("bad offset", "Corrupt BMP");
; 5578 :       } else {
; 5579 :          stbi__skip(s, info.offset - bytes_read_so_far);
; 5580 :       }
; 5581 :    }
; 5582 : 
; 5583 :    if (info.bpp == 24 && ma == 0xff000000)
; 5584 :       s->img_n = 3;
; 5585 :    else
; 5586 :       s->img_n = ma ? 4 : 3;
; 5587 :    if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
; 5588 :       target = req_comp;
; 5589 :    else
; 5590 :       target = s->img_n; // if they want monochrome, we'll post-convert
; 5591 : 
; 5592 :    // sanity-check size
; 5593 :    if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
; 5594 :       return stbi__errpuc("too large", "Corrupt BMP");
; 5595 : 
; 5596 :    out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
; 5597 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");
; 5598 :    if (info.bpp < 16) {
; 5599 :       int z=0;
; 5600 :       if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
; 5601 :       for (i=0; i < psize; ++i) {
; 5602 :          pal[i][2] = stbi__get8(s);
; 5603 :          pal[i][1] = stbi__get8(s);
; 5604 :          pal[i][0] = stbi__get8(s);
; 5605 :          if (info.hsz != 12) stbi__get8(s);
; 5606 :          pal[i][3] = 255;
; 5607 :       }
; 5608 :       stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
; 5609 :       if (info.bpp == 1) width = (s->img_x + 7) >> 3;
; 5610 :       else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
; 5611 :       else if (info.bpp == 8) width = s->img_x;
; 5612 :       else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
; 5613 :       pad = (-width)&3;
; 5614 :       if (info.bpp == 1) {
; 5615 :          for (j=0; j < (int) s->img_y; ++j) {
; 5616 :             int bit_offset = 7, v = stbi__get8(s);
; 5617 :             for (i=0; i < (int) s->img_x; ++i) {
; 5618 :                int color = (v>>bit_offset)&0x1;
; 5619 :                out[z++] = pal[color][0];
; 5620 :                out[z++] = pal[color][1];
; 5621 :                out[z++] = pal[color][2];
; 5622 :                if (target == 4) out[z++] = 255;
; 5623 :                if (i+1 == (int) s->img_x) break;
; 5624 :                if((--bit_offset) < 0) {
; 5625 :                   bit_offset = 7;
; 5626 :                   v = stbi__get8(s);
; 5627 :                }
; 5628 :             }
; 5629 :             stbi__skip(s, pad);
; 5630 :          }
; 5631 :       } else {
; 5632 :          for (j=0; j < (int) s->img_y; ++j) {
; 5633 :             for (i=0; i < (int) s->img_x; i += 2) {
; 5634 :                int v=stbi__get8(s),v2=0;
; 5635 :                if (info.bpp == 4) {
; 5636 :                   v2 = v & 15;
; 5637 :                   v >>= 4;
; 5638 :                }
; 5639 :                out[z++] = pal[v][0];
; 5640 :                out[z++] = pal[v][1];
; 5641 :                out[z++] = pal[v][2];
; 5642 :                if (target == 4) out[z++] = 255;
; 5643 :                if (i+1 == (int) s->img_x) break;
; 5644 :                v = (info.bpp == 8) ? stbi__get8(s) : v2;
; 5645 :                out[z++] = pal[v][0];
; 5646 :                out[z++] = pal[v][1];
; 5647 :                out[z++] = pal[v][2];
; 5648 :                if (target == 4) out[z++] = 255;
; 5649 :             }
; 5650 :             stbi__skip(s, pad);
; 5651 :          }
; 5652 :       }
; 5653 :    } else {
; 5654 :       int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
; 5655 :       int z = 0;
; 5656 :       int easy=0;
; 5657 :       stbi__skip(s, info.offset - info.extra_read - info.hsz);
; 5658 :       if (info.bpp == 24) width = 3 * s->img_x;
; 5659 :       else if (info.bpp == 16) width = 2*s->img_x;
; 5660 :       else /* bpp = 32 and pad = 0 */ width=0;
; 5661 :       pad = (-width) & 3;
; 5662 :       if (info.bpp == 24) {
; 5663 :          easy = 1;
; 5664 :       } else if (info.bpp == 32) {
; 5665 :          if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
; 5666 :             easy = 2;
; 5667 :       }
; 5668 :       if (!easy) {
; 5669 :          if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
; 5670 :          // right shift amt to put high bit in position #7
; 5671 :          rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
; 5672 :          gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
; 5673 :          bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
; 5674 :          ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
; 5675 :          if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
; 5676 :       }
; 5677 :       for (j=0; j < (int) s->img_y; ++j) {
; 5678 :          if (easy) {
; 5679 :             for (i=0; i < (int) s->img_x; ++i) {
; 5680 :                unsigned char a;
; 5681 :                out[z+2] = stbi__get8(s);
; 5682 :                out[z+1] = stbi__get8(s);
; 5683 :                out[z+0] = stbi__get8(s);
; 5684 :                z += 3;
; 5685 :                a = (easy == 2 ? stbi__get8(s) : 255);
; 5686 :                all_a |= a;
; 5687 :                if (target == 4) out[z++] = a;
; 5688 :             }
; 5689 :          } else {
; 5690 :             int bpp = info.bpp;
; 5691 :             for (i=0; i < (int) s->img_x; ++i) {
; 5692 :                stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
; 5693 :                unsigned int a;
; 5694 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
; 5695 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
; 5696 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
; 5697 :                a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
; 5698 :                all_a |= a;
; 5699 :                if (target == 4) out[z++] = STBI__BYTECAST(a);
; 5700 :             }
; 5701 :          }
; 5702 :          stbi__skip(s, pad);
; 5703 :       }
; 5704 :    }
; 5705 : 
; 5706 :    // if alpha channel is all 0s, replace with all 255s
; 5707 :    if (target == 4 && all_a == 0)
; 5708 :       for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
; 5709 :          out[i] = 255;
; 5710 : 
; 5711 :    if (flip_vertically) {
; 5712 :       stbi_uc t;
; 5713 :       for (j=0; j < (int) s->img_y>>1; ++j) {
; 5714 :          stbi_uc *p1 = out +      j     *s->img_x*target;
; 5715 :          stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
; 5716 :          for (i=0; i < (int) s->img_x*target; ++i) {
; 5717 :             t = p1[i]; p1[i] = p2[i]; p2[i] = t;
; 5718 :          }
; 5719 :       }
; 5720 :    }
; 5721 : 
; 5722 :    if (req_comp && req_comp != target) {
; 5723 :       out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
; 5724 :       if (out == NULL) return out; // stbi__convert_format frees input on failure
; 5725 :    }
; 5726 : 
; 5727 :    *x = s->img_x;
; 5728 :    *y = s->img_y;
; 5729 :    if (comp) *comp = s->img_n;
; 5730 :    return out;
; 5731 : }
; 5732 : #endif
; 5733 : 
; 5734 : // Targa Truevision - TGA
; 5735 : // by Jonathan Dummer
; 5736 : #ifndef STBI_NO_TGA
; 5737 : // returns STBI_rgb or whatever, 0 on error
; 5738 : static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
; 5739 : {
; 5740 :    // only RGB or RGBA (incl. 16bit) or grey allowed
; 5741 :    if (is_rgb16) *is_rgb16 = 0;
; 5742 :    switch(bits_per_pixel) {
; 5743 :       case 8:  return STBI_grey;
; 5744 :       case 16: if(is_grey) return STBI_grey_alpha;
; 5745 :                // fallthrough
; 5746 :       case 15: if(is_rgb16) *is_rgb16 = 1;
; 5747 :                return STBI_rgb;
; 5748 :       case 24: // fallthrough
; 5749 :       case 32: return bits_per_pixel/8;
; 5750 :       default: return 0;
; 5751 :    }
; 5752 : }
; 5753 : 
; 5754 : static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
; 5755 : {
; 5756 :     int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
; 5757 :     int sz, tga_colormap_type;
; 5758 :     stbi__get8(s);                   // discard Offset
; 5759 :     tga_colormap_type = stbi__get8(s); // colormap type
; 5760 :     if( tga_colormap_type > 1 ) {
; 5761 :         stbi__rewind(s);
; 5762 :         return 0;      // only RGB or indexed allowed
; 5763 :     }
; 5764 :     tga_image_type = stbi__get8(s); // image type
; 5765 :     if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
; 5766 :         if (tga_image_type != 1 && tga_image_type != 9) {
; 5767 :             stbi__rewind(s);
; 5768 :             return 0;
; 5769 :         }
; 5770 :         stbi__skip(s,4);       // skip index of first colormap entry and number of entries
; 5771 :         sz = stbi__get8(s);    //   check bits per palette color entry
; 5772 :         if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
; 5773 :             stbi__rewind(s);
; 5774 :             return 0;
; 5775 :         }
; 5776 :         stbi__skip(s,4);       // skip image x and y origin
; 5777 :         tga_colormap_bpp = sz;
; 5778 :     } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
; 5779 :         if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
; 5780 :             stbi__rewind(s);
; 5781 :             return 0; // only RGB or grey allowed, +/- RLE
; 5782 :         }
; 5783 :         stbi__skip(s,9); // skip colormap specification and image x/y origin
; 5784 :         tga_colormap_bpp = 0;
; 5785 :     }
; 5786 :     tga_w = stbi__get16le(s);
; 5787 :     if( tga_w < 1 ) {
; 5788 :         stbi__rewind(s);
; 5789 :         return 0;   // test width
; 5790 :     }
; 5791 :     tga_h = stbi__get16le(s);
; 5792 :     if( tga_h < 1 ) {
; 5793 :         stbi__rewind(s);
; 5794 :         return 0;   // test height
; 5795 :     }
; 5796 :     tga_bits_per_pixel = stbi__get8(s); // bits per pixel
; 5797 :     stbi__get8(s); // ignore alpha bits
; 5798 :     if (tga_colormap_bpp != 0) {
; 5799 :         if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
; 5800 :             // when using a colormap, tga_bits_per_pixel is the size of the indexes
; 5801 :             // I don't think anything but 8 or 16bit indexes makes sense
; 5802 :             stbi__rewind(s);
; 5803 :             return 0;
; 5804 :         }
; 5805 :         tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
; 5806 :     } else {
; 5807 :         tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
; 5808 :     }
; 5809 :     if(!tga_comp) {
; 5810 :       stbi__rewind(s);
; 5811 :       return 0;
; 5812 :     }
; 5813 :     if (x) *x = tga_w;
; 5814 :     if (y) *y = tga_h;
; 5815 :     if (comp) *comp = tga_comp;
; 5816 :     return 1;                   // seems to have passed everything
; 5817 : }
; 5818 : 
; 5819 : static int stbi__tga_test(stbi__context *s)
; 5820 : {
; 5821 :    int res = 0;
; 5822 :    int sz, tga_color_type;
; 5823 :    stbi__get8(s);      //   discard Offset
; 5824 :    tga_color_type = stbi__get8(s);   //   color type
; 5825 :    if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
; 5826 :    sz = stbi__get8(s);   //   image type
; 5827 :    if ( tga_color_type == 1 ) { // colormapped (paletted) image
; 5828 :       if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
; 5829 :       stbi__skip(s,4);       // skip index of first colormap entry and number of entries
; 5830 :       sz = stbi__get8(s);    //   check bits per palette color entry
; 5831 :       if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
; 5832 :       stbi__skip(s,4);       // skip image x and y origin
; 5833 :    } else { // "normal" image w/o colormap
; 5834 :       if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
; 5835 :       stbi__skip(s,9); // skip colormap specification and image x/y origin
; 5836 :    }
; 5837 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
; 5838 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
; 5839 :    sz = stbi__get8(s);   //   bits per pixel
; 5840 :    if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
; 5841 :    if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
; 5842 : 
; 5843 :    res = 1; // if we got this far, everything's good and we can return 1 instead of 0
; 5844 : 
; 5845 : errorEnd:
; 5846 :    stbi__rewind(s);
; 5847 :    return res;
; 5848 : }
; 5849 : 
; 5850 : // read 16bit value and convert to 24bit RGB
; 5851 : static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
; 5852 : {
; 5853 :    stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
; 5854 :    stbi__uint16 fiveBitMask = 31;
; 5855 :    // we have 3 channels with 5bits each
; 5856 :    int r = (px >> 10) & fiveBitMask;
; 5857 :    int g = (px >> 5) & fiveBitMask;
; 5858 :    int b = px & fiveBitMask;
; 5859 :    // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
; 5860 :    out[0] = (stbi_uc)((r * 255)/31);
; 5861 :    out[1] = (stbi_uc)((g * 255)/31);
; 5862 :    out[2] = (stbi_uc)((b * 255)/31);
; 5863 : 
; 5864 :    // some people claim that the most significant bit might be used for alpha
; 5865 :    // (possibly if an alpha-bit is set in the "image descriptor byte")
; 5866 :    // but that only made 16bit test images completely translucent..
; 5867 :    // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
; 5868 : }
; 5869 : 
; 5870 : static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5871 : {
; 5872 :    //   read in the TGA header stuff
; 5873 :    int tga_offset = stbi__get8(s);
; 5874 :    int tga_indexed = stbi__get8(s);
; 5875 :    int tga_image_type = stbi__get8(s);
; 5876 :    int tga_is_RLE = 0;
; 5877 :    int tga_palette_start = stbi__get16le(s);
; 5878 :    int tga_palette_len = stbi__get16le(s);
; 5879 :    int tga_palette_bits = stbi__get8(s);
; 5880 :    int tga_x_origin = stbi__get16le(s);
; 5881 :    int tga_y_origin = stbi__get16le(s);
; 5882 :    int tga_width = stbi__get16le(s);
; 5883 :    int tga_height = stbi__get16le(s);
; 5884 :    int tga_bits_per_pixel = stbi__get8(s);
; 5885 :    int tga_comp, tga_rgb16=0;
; 5886 :    int tga_inverted = stbi__get8(s);
; 5887 :    // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
; 5888 :    //   image data
; 5889 :    unsigned char *tga_data;
; 5890 :    unsigned char *tga_palette = NULL;
; 5891 :    int i, j;
; 5892 :    unsigned char raw_data[4] = {0};
; 5893 :    int RLE_count = 0;
; 5894 :    int RLE_repeating = 0;
; 5895 :    int read_next_pixel = 1;
; 5896 :    STBI_NOTUSED(ri);
; 5897 :    STBI_NOTUSED(tga_x_origin); // @TODO
; 5898 :    STBI_NOTUSED(tga_y_origin); // @TODO
; 5899 : 
; 5900 :    if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5901 :    if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5902 : 
; 5903 :    //   do a tiny bit of precessing
; 5904 :    if ( tga_image_type >= 8 )
; 5905 :    {
; 5906 :       tga_image_type -= 8;
; 5907 :       tga_is_RLE = 1;
; 5908 :    }
; 5909 :    tga_inverted = 1 - ((tga_inverted >> 5) & 1);
; 5910 : 
; 5911 :    //   If I'm paletted, then I'll use the number of bits from the palette
; 5912 :    if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
; 5913 :    else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);
; 5914 : 
; 5915 :    if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
; 5916 :       return stbi__errpuc("bad format", "Can't find out TGA pixelformat");
; 5917 : 
; 5918 :    //   tga info
; 5919 :    *x = tga_width;
; 5920 :    *y = tga_height;
; 5921 :    if (comp) *comp = tga_comp;
; 5922 : 
; 5923 :    if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
; 5924 :       return stbi__errpuc("too large", "Corrupt TGA");
; 5925 : 
; 5926 :    tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
; 5927 :    if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");
; 5928 : 
; 5929 :    // skip to the data's starting position (offset usually = 0)
; 5930 :    stbi__skip(s, tga_offset );
; 5931 : 
; 5932 :    if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
; 5933 :       for (i=0; i < tga_height; ++i) {
; 5934 :          int row = tga_inverted ? tga_height -i - 1 : i;
; 5935 :          stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
; 5936 :          stbi__getn(s, tga_row, tga_width * tga_comp);
; 5937 :       }
; 5938 :    } else  {
; 5939 :       //   do I need to load a palette?
; 5940 :       if ( tga_indexed)
; 5941 :       {
; 5942 :          if (tga_palette_len == 0) {  /* you have to have at least one entry! */
; 5943 :             STBI_FREE(tga_data);
; 5944 :             return stbi__errpuc("bad palette", "Corrupt TGA");
; 5945 :          }
; 5946 : 
; 5947 :          //   any data to skip? (offset usually = 0)
; 5948 :          stbi__skip(s, tga_palette_start );
; 5949 :          //   load the palette
; 5950 :          tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
; 5951 :          if (!tga_palette) {
; 5952 :             STBI_FREE(tga_data);
; 5953 :             return stbi__errpuc("outofmem", "Out of memory");
; 5954 :          }
; 5955 :          if (tga_rgb16) {
; 5956 :             stbi_uc *pal_entry = tga_palette;
; 5957 :             STBI_ASSERT(tga_comp == STBI_rgb);
; 5958 :             for (i=0; i < tga_palette_len; ++i) {
; 5959 :                stbi__tga_read_rgb16(s, pal_entry);
; 5960 :                pal_entry += tga_comp;
; 5961 :             }
; 5962 :          } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
; 5963 :                STBI_FREE(tga_data);
; 5964 :                STBI_FREE(tga_palette);
; 5965 :                return stbi__errpuc("bad palette", "Corrupt TGA");
; 5966 :          }
; 5967 :       }
; 5968 :       //   load the data
; 5969 :       for (i=0; i < tga_width * tga_height; ++i)
; 5970 :       {
; 5971 :          //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
; 5972 :          if ( tga_is_RLE )
; 5973 :          {
; 5974 :             if ( RLE_count == 0 )
; 5975 :             {
; 5976 :                //   yep, get the next byte as a RLE command
; 5977 :                int RLE_cmd = stbi__get8(s);
; 5978 :                RLE_count = 1 + (RLE_cmd & 127);
; 5979 :                RLE_repeating = RLE_cmd >> 7;
; 5980 :                read_next_pixel = 1;
; 5981 :             } else if ( !RLE_repeating )
; 5982 :             {
; 5983 :                read_next_pixel = 1;
; 5984 :             }
; 5985 :          } else
; 5986 :          {
; 5987 :             read_next_pixel = 1;
; 5988 :          }
; 5989 :          //   OK, if I need to read a pixel, do it now
; 5990 :          if ( read_next_pixel )
; 5991 :          {
; 5992 :             //   load however much data we did have
; 5993 :             if ( tga_indexed )
; 5994 :             {
; 5995 :                // read in index, then perform the lookup
; 5996 :                int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
; 5997 :                if ( pal_idx >= tga_palette_len ) {
; 5998 :                   // invalid index
; 5999 :                   pal_idx = 0;
; 6000 :                }
; 6001 :                pal_idx *= tga_comp;
; 6002 :                for (j = 0; j < tga_comp; ++j) {
; 6003 :                   raw_data[j] = tga_palette[pal_idx+j];
; 6004 :                }
; 6005 :             } else if(tga_rgb16) {
; 6006 :                STBI_ASSERT(tga_comp == STBI_rgb);
; 6007 :                stbi__tga_read_rgb16(s, raw_data);
; 6008 :             } else {
; 6009 :                //   read in the data raw
; 6010 :                for (j = 0; j < tga_comp; ++j) {
; 6011 :                   raw_data[j] = stbi__get8(s);
; 6012 :                }
; 6013 :             }
; 6014 :             //   clear the reading flag for the next pixel
; 6015 :             read_next_pixel = 0;
; 6016 :          } // end of reading a pixel
; 6017 : 
; 6018 :          // copy data
; 6019 :          for (j = 0; j < tga_comp; ++j)
; 6020 :            tga_data[i*tga_comp+j] = raw_data[j];
; 6021 : 
; 6022 :          //   in case we're in RLE mode, keep counting down
; 6023 :          --RLE_count;
; 6024 :       }
; 6025 :       //   do I need to invert the image?
; 6026 :       if ( tga_inverted )
; 6027 :       {
; 6028 :          for (j = 0; j*2 < tga_height; ++j)
; 6029 :          {
; 6030 :             int index1 = j * tga_width * tga_comp;
; 6031 :             int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
; 6032 :             for (i = tga_width * tga_comp; i > 0; --i)
; 6033 :             {
; 6034 :                unsigned char temp = tga_data[index1];
; 6035 :                tga_data[index1] = tga_data[index2];
; 6036 :                tga_data[index2] = temp;
; 6037 :                ++index1;
; 6038 :                ++index2;
; 6039 :             }
; 6040 :          }
; 6041 :       }
; 6042 :       //   clear my palette, if I had one
; 6043 :       if ( tga_palette != NULL )
; 6044 :       {
; 6045 :          STBI_FREE( tga_palette );
; 6046 :       }
; 6047 :    }
; 6048 : 
; 6049 :    // swap RGB - if the source data was RGB16, it already is in the right order
; 6050 :    if (tga_comp >= 3 && !tga_rgb16)
; 6051 :    {
; 6052 :       unsigned char* tga_pixel = tga_data;
; 6053 :       for (i=0; i < tga_width * tga_height; ++i)
; 6054 :       {
; 6055 :          unsigned char temp = tga_pixel[0];
; 6056 :          tga_pixel[0] = tga_pixel[2];
; 6057 :          tga_pixel[2] = temp;
; 6058 :          tga_pixel += tga_comp;
; 6059 :       }
; 6060 :    }
; 6061 : 
; 6062 :    // convert to target component count
; 6063 :    if (req_comp && req_comp != tga_comp)
; 6064 :       tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);
; 6065 : 
; 6066 :    //   the things I do to get rid of an error message, and yet keep
; 6067 :    //   Microsoft's C compilers happy... [8^(
; 6068 :    tga_palette_start = tga_palette_len = tga_palette_bits =
; 6069 :          tga_x_origin = tga_y_origin = 0;
; 6070 :    STBI_NOTUSED(tga_palette_start);
; 6071 :    //   OK, done
; 6072 :    return tga_data;
; 6073 : }
; 6074 : #endif
; 6075 : 
; 6076 : // *************************************************************************************************
; 6077 : // Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB
; 6078 : 
; 6079 : #ifndef STBI_NO_PSD
; 6080 : static int stbi__psd_test(stbi__context *s)
; 6081 : {
; 6082 :    int r = (stbi__get32be(s) == 0x38425053);
; 6083 :    stbi__rewind(s);
; 6084 :    return r;
; 6085 : }
; 6086 : 
; 6087 : static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
; 6088 : {
; 6089 :    int count, nleft, len;
; 6090 : 
; 6091 :    count = 0;
; 6092 :    while ((nleft = pixelCount - count) > 0) {
; 6093 :       len = stbi__get8(s);
; 6094 :       if (len == 128) {
; 6095 :          // No-op.
; 6096 :       } else if (len < 128) {
; 6097 :          // Copy next len+1 bytes literally.
; 6098 :          len++;
; 6099 :          if (len > nleft) return 0; // corrupt data
; 6100 :          count += len;
; 6101 :          while (len) {
; 6102 :             *p = stbi__get8(s);
; 6103 :             p += 4;
; 6104 :             len--;
; 6105 :          }
; 6106 :       } else if (len > 128) {
; 6107 :          stbi_uc   val;
; 6108 :          // Next -len+1 bytes in the dest are replicated from next source byte.
; 6109 :          // (Interpret len as a negative 8-bit int.)
; 6110 :          len = 257 - len;
; 6111 :          if (len > nleft) return 0; // corrupt data
; 6112 :          val = stbi__get8(s);
; 6113 :          count += len;
; 6114 :          while (len) {
; 6115 :             *p = val;
; 6116 :             p += 4;
; 6117 :             len--;
; 6118 :          }
; 6119 :       }
; 6120 :    }
; 6121 : 
; 6122 :    return 1;
; 6123 : }
; 6124 : 
; 6125 : static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
; 6126 : {
; 6127 :    int pixelCount;
; 6128 :    int channelCount, compression;
; 6129 :    int channel, i;
; 6130 :    int bitdepth;
; 6131 :    int w,h;
; 6132 :    stbi_uc *out;
; 6133 :    STBI_NOTUSED(ri);
; 6134 : 
; 6135 :    // Check identifier
; 6136 :    if (stbi__get32be(s) != 0x38425053)   // "8BPS"
; 6137 :       return stbi__errpuc("not PSD", "Corrupt PSD image");
; 6138 : 
; 6139 :    // Check file type version.
; 6140 :    if (stbi__get16be(s) != 1)
; 6141 :       return stbi__errpuc("wrong version", "Unsupported version of PSD image");
; 6142 : 
; 6143 :    // Skip 6 reserved bytes.
; 6144 :    stbi__skip(s, 6 );
; 6145 : 
; 6146 :    // Read the number of channels (R, G, B, A, etc).
; 6147 :    channelCount = stbi__get16be(s);
; 6148 :    if (channelCount < 0 || channelCount > 16)
; 6149 :       return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");
; 6150 : 
; 6151 :    // Read the rows and columns of the image.
; 6152 :    h = stbi__get32be(s);
; 6153 :    w = stbi__get32be(s);
; 6154 : 
; 6155 :    if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 6156 :    if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 6157 : 
; 6158 :    // Make sure the depth is 8 bits.
; 6159 :    bitdepth = stbi__get16be(s);
; 6160 :    if (bitdepth != 8 && bitdepth != 16)
; 6161 :       return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");
; 6162 : 
; 6163 :    // Make sure the color mode is RGB.
; 6164 :    // Valid options are:
; 6165 :    //   0: Bitmap
; 6166 :    //   1: Grayscale
; 6167 :    //   2: Indexed color
; 6168 :    //   3: RGB color
; 6169 :    //   4: CMYK color
; 6170 :    //   7: Multichannel
; 6171 :    //   8: Duotone
; 6172 :    //   9: Lab color
; 6173 :    if (stbi__get16be(s) != 3)
; 6174 :       return stbi__errpuc("wrong color format", "PSD is not in RGB color format");
; 6175 : 
; 6176 :    // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
; 6177 :    stbi__skip(s,stbi__get32be(s) );
; 6178 : 
; 6179 :    // Skip the image resources.  (resolution, pen tool paths, etc)
; 6180 :    stbi__skip(s, stbi__get32be(s) );
; 6181 : 
; 6182 :    // Skip the reserved data.
; 6183 :    stbi__skip(s, stbi__get32be(s) );
; 6184 : 
; 6185 :    // Find out if the data is compressed.
; 6186 :    // Known values:
; 6187 :    //   0: no compression
; 6188 :    //   1: RLE compressed
; 6189 :    compression = stbi__get16be(s);
; 6190 :    if (compression > 1)
; 6191 :       return stbi__errpuc("bad compression", "PSD has an unknown compression format");
; 6192 : 
; 6193 :    // Check size
; 6194 :    if (!stbi__mad3sizes_valid(4, w, h, 0))
; 6195 :       return stbi__errpuc("too large", "Corrupt PSD");
; 6196 : 
; 6197 :    // Create the destination image.
; 6198 : 
; 6199 :    if (!compression && bitdepth == 16 && bpc == 16) {
; 6200 :       out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
; 6201 :       ri->bits_per_channel = 16;
; 6202 :    } else
; 6203 :       out = (stbi_uc *) stbi__malloc(4 * w*h);
; 6204 : 
; 6205 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");
; 6206 :    pixelCount = w*h;
; 6207 : 
; 6208 :    // Initialize the data to zero.
; 6209 :    //memset( out, 0, pixelCount * 4 );
; 6210 : 
; 6211 :    // Finally, the image data.
; 6212 :    if (compression) {
; 6213 :       // RLE as used by .PSD and .TIFF
; 6214 :       // Loop until you get the number of unpacked bytes you are expecting:
; 6215 :       //     Read the next source byte into n.
; 6216 :       //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
; 6217 :       //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
; 6218 :       //     Else if n is 128, noop.
; 6219 :       // Endloop
; 6220 : 
; 6221 :       // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
; 6222 :       // which we're going to just skip.
; 6223 :       stbi__skip(s, h * channelCount * 2 );
; 6224 : 
; 6225 :       // Read the RLE data by channel.
; 6226 :       for (channel = 0; channel < 4; channel++) {
; 6227 :          stbi_uc *p;
; 6228 : 
; 6229 :          p = out+channel;
; 6230 :          if (channel >= channelCount) {
; 6231 :             // Fill this channel with default data.
; 6232 :             for (i = 0; i < pixelCount; i++, p += 4)
; 6233 :                *p = (channel == 3 ? 255 : 0);
; 6234 :          } else {
; 6235 :             // Read the RLE data.
; 6236 :             if (!stbi__psd_decode_rle(s, p, pixelCount)) {
; 6237 :                STBI_FREE(out);
; 6238 :                return stbi__errpuc("corrupt", "bad RLE data");
; 6239 :             }
; 6240 :          }
; 6241 :       }
; 6242 : 
; 6243 :    } else {
; 6244 :       // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
; 6245 :       // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.
; 6246 : 
; 6247 :       // Read the data by channel.
; 6248 :       for (channel = 0; channel < 4; channel++) {
; 6249 :          if (channel >= channelCount) {
; 6250 :             // Fill this channel with default data.
; 6251 :             if (bitdepth == 16 && bpc == 16) {
; 6252 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
; 6253 :                stbi__uint16 val = channel == 3 ? 65535 : 0;
; 6254 :                for (i = 0; i < pixelCount; i++, q += 4)
; 6255 :                   *q = val;
; 6256 :             } else {
; 6257 :                stbi_uc *p = out+channel;
; 6258 :                stbi_uc val = channel == 3 ? 255 : 0;
; 6259 :                for (i = 0; i < pixelCount; i++, p += 4)
; 6260 :                   *p = val;
; 6261 :             }
; 6262 :          } else {
; 6263 :             if (ri->bits_per_channel == 16) {    // output bpc
; 6264 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
; 6265 :                for (i = 0; i < pixelCount; i++, q += 4)
; 6266 :                   *q = (stbi__uint16) stbi__get16be(s);
; 6267 :             } else {
; 6268 :                stbi_uc *p = out+channel;
; 6269 :                if (bitdepth == 16) {  // input bpc
; 6270 :                   for (i = 0; i < pixelCount; i++, p += 4)
; 6271 :                      *p = (stbi_uc) (stbi__get16be(s) >> 8);
; 6272 :                } else {
; 6273 :                   for (i = 0; i < pixelCount; i++, p += 4)
; 6274 :                      *p = stbi__get8(s);
; 6275 :                }
; 6276 :             }
; 6277 :          }
; 6278 :       }
; 6279 :    }
; 6280 : 
; 6281 :    // remove weird white matte from PSD
; 6282 :    if (channelCount >= 4) {
; 6283 :       if (ri->bits_per_channel == 16) {
; 6284 :          for (i=0; i < w*h; ++i) {
; 6285 :             stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
; 6286 :             if (pixel[3] != 0 && pixel[3] != 65535) {
; 6287 :                float a = pixel[3] / 65535.0f;
; 6288 :                float ra = 1.0f / a;
; 6289 :                float inv_a = 65535.0f * (1 - ra);
; 6290 :                pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
; 6291 :                pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
; 6292 :                pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
; 6293 :             }
; 6294 :          }
; 6295 :       } else {
; 6296 :          for (i=0; i < w*h; ++i) {
; 6297 :             unsigned char *pixel = out + 4*i;
; 6298 :             if (pixel[3] != 0 && pixel[3] != 255) {
; 6299 :                float a = pixel[3] / 255.0f;
; 6300 :                float ra = 1.0f / a;
; 6301 :                float inv_a = 255.0f * (1 - ra);
; 6302 :                pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
; 6303 :                pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
; 6304 :                pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
; 6305 :             }
; 6306 :          }
; 6307 :       }
; 6308 :    }
; 6309 : 
; 6310 :    // convert to desired output format
; 6311 :    if (req_comp && req_comp != 4) {
; 6312 :       if (ri->bits_per_channel == 16)
; 6313 :          out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
; 6314 :       else
; 6315 :          out = stbi__convert_format(out, 4, req_comp, w, h);
; 6316 :       if (out == NULL) return out; // stbi__convert_format frees input on failure
; 6317 :    }
; 6318 : 
; 6319 :    if (comp) *comp = 4;
; 6320 :    *y = h;
; 6321 :    *x = w;
; 6322 : 
; 6323 :    return out;
; 6324 : }
; 6325 : #endif
; 6326 : 
; 6327 : // *************************************************************************************************
; 6328 : // Softimage PIC loader
; 6329 : // by Tom Seddon
; 6330 : //
; 6331 : // See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
; 6332 : // See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/
; 6333 : 
; 6334 : #ifndef STBI_NO_PIC
; 6335 : static int stbi__pic_is4(stbi__context *s,const char *str)
; 6336 : {
; 6337 :    int i;
; 6338 :    for (i=0; i<4; ++i)
; 6339 :       if (stbi__get8(s) != (stbi_uc)str[i])
; 6340 :          return 0;
; 6341 : 
; 6342 :    return 1;
; 6343 : }
; 6344 : 
; 6345 : static int stbi__pic_test_core(stbi__context *s)
; 6346 : {
; 6347 :    int i;
; 6348 : 
; 6349 :    if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
; 6350 :       return 0;
; 6351 : 
; 6352 :    for(i=0;i<84;++i)
; 6353 :       stbi__get8(s);
; 6354 : 
; 6355 :    if (!stbi__pic_is4(s,"PICT"))
; 6356 :       return 0;
; 6357 : 
; 6358 :    return 1;
; 6359 : }
; 6360 : 
; 6361 : typedef struct
; 6362 : {
; 6363 :    stbi_uc size,type,channel;
; 6364 : } stbi__pic_packet;
; 6365 : 
; 6366 : static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
; 6367 : {
; 6368 :    int mask=0x80, i;
; 6369 : 
; 6370 :    for (i=0; i<4; ++i, mask>>=1) {
; 6371 :       if (channel & mask) {
; 6372 :          if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
; 6373 :          dest[i]=stbi__get8(s);
; 6374 :       }
; 6375 :    }
; 6376 : 
; 6377 :    return dest;
; 6378 : }
; 6379 : 
; 6380 : static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
; 6381 : {
; 6382 :    int mask=0x80,i;
; 6383 : 
; 6384 :    for (i=0;i<4; ++i, mask>>=1)
; 6385 :       if (channel&mask)

	test	sil, 32					; 00000020H
	je	SHORT $LN159@stbi__pic_

; 6386 :          dest[i]=src[i];

	mov	BYTE PTR [rbx+2], r8b
$LN159@stbi__pic_:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;
; 1636 : }
; 1637 : #endif
; 1638 : 
; 1639 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
; 1640 : // nothing
; 1641 : #else
; 1642 : static void stbi__skip(stbi__context *s, int n)
; 1643 : {
; 1644 :    if (n == 0) return;  // already there!
; 1645 :    if (n < 0) {
; 1646 :       s->img_buffer = s->img_buffer_end;
; 1647 :       return;
; 1648 :    }
; 1649 :    if (s->io.read) {
; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1651 :       if (blen < n) {
; 1652 :          s->img_buffer = s->img_buffer_end;
; 1653 :          (s->io.skip)(s->io_user_data, n - blen);
; 1654 :          return;
; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;
; 1658 : }
; 1659 : #endif
; 1660 : 
; 1661 : #if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
; 1662 : // nothing
; 1663 : #else
; 1664 : static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
; 1665 : {
; 1666 :    if (s->io.read) {
; 1667 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1668 :       if (blen < n) {
; 1669 :          int res, count;
; 1670 : 
; 1671 :          memcpy(buffer, s->img_buffer, blen);
; 1672 : 
; 1673 :          count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
; 1674 :          res = (count == (n-blen));
; 1675 :          s->img_buffer = s->img_buffer_end;
; 1676 :          return res;
; 1677 :       }
; 1678 :    }
; 1679 : 
; 1680 :    if (s->img_buffer+n <= s->img_buffer_end) {
; 1681 :       memcpy(buffer, s->img_buffer, n);
; 1682 :       s->img_buffer += n;
; 1683 :       return 1;
; 1684 :    } else
; 1685 :       return 0;
; 1686 : }
; 1687 : #endif
; 1688 : 
; 1689 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1690 : // nothing
; 1691 : #else
; 1692 : static int stbi__get16be(stbi__context *s)
; 1693 : {
; 1694 :    int z = stbi__get8(s);
; 1695 :    return (z << 8) + stbi__get8(s);
; 1696 : }
; 1697 : #endif
; 1698 : 
; 1699 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1700 : // nothing
; 1701 : #else
; 1702 : static stbi__uint32 stbi__get32be(stbi__context *s)
; 1703 : {
; 1704 :    stbi__uint32 z = stbi__get16be(s);
; 1705 :    return (z << 16) + stbi__get16be(s);
; 1706 : }
; 1707 : #endif
; 1708 : 
; 1709 : #if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
; 1710 : // nothing
; 1711 : #else
; 1712 : static int stbi__get16le(stbi__context *s)
; 1713 : {
; 1714 :    int z = stbi__get8(s);
; 1715 :    return z + (stbi__get8(s) << 8);
; 1716 : }
; 1717 : #endif
; 1718 : 
; 1719 : #ifndef STBI_NO_BMP
; 1720 : static stbi__uint32 stbi__get32le(stbi__context *s)
; 1721 : {
; 1722 :    stbi__uint32 z = stbi__get16le(s);
; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;
; 1724 :    return z;
; 1725 : }
; 1726 : #endif
; 1727 : 
; 1728 : #define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
; 1729 : 
; 1730 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1731 : // nothing
; 1732 : #else
; 1733 : //////////////////////////////////////////////////////////////////////////////
; 1734 : //
; 1735 : //  generic converter from built-in img_n to req_comp
; 1736 : //    individual types do this automatically as much as possible (e.g. jpeg
; 1737 : //    does all cases internally since it needs to colorspace convert anyway,
; 1738 : //    and it never has alpha, so very few cases ). png can automatically
; 1739 : //    interleave an alpha=255 channel, but falls back to this for other cases
; 1740 : //
; 1741 : //  assume data buffer is malloced, so malloc a new one and free that one
; 1742 : //  only failure mode is malloc failing
; 1743 : 
; 1744 : static stbi_uc stbi__compute_y(int r, int g, int b)
; 1745 : {
; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1747 : }
; 1748 : #endif
; 1749 : 
; 1750 : #if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1751 : // nothing
; 1752 : #else
; 1753 : static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1754 : {
; 1755 :    int i,j;
; 1756 :    unsigned char *good;
; 1757 : 
; 1758 :    if (req_comp == img_n) return data;
; 1759 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1760 : 
; 1761 :    good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
; 1762 :    if (good == NULL) {
; 1763 :       STBI_FREE(data);
; 1764 :       return stbi__errpuc("outofmem", "Out of memory");
; 1765 :    }
; 1766 : 
; 1767 :    for (j=0; j < (int) y; ++j) {
; 1768 :       unsigned char *src  = data + j * x * img_n   ;
; 1769 :       unsigned char *dest = good + j * x * req_comp;
; 1770 : 
; 1771 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1772 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1773 :       // convert source image with img_n components to one with req_comp components;
; 1774 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1775 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1776 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
; 1777 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1778 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
; 1779 :          STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
; 1780 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1781 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
; 1782 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
; 1783 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1784 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
; 1785 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1786 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1787 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
; 1788 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
; 1789 :       }
; 1790 :       #undef STBI__CASE
; 1791 :    }
; 1792 : 
; 1793 :    STBI_FREE(data);
; 1794 :    return good;
; 1795 : }
; 1796 : #endif
; 1797 : 
; 1798 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1799 : // nothing
; 1800 : #else
; 1801 : static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
; 1802 : {
; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1804 : }
; 1805 : #endif
; 1806 : 
; 1807 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1808 : // nothing
; 1809 : #else
; 1810 : static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1811 : {
; 1812 :    int i,j;
; 1813 :    stbi__uint16 *good;
; 1814 : 
; 1815 :    if (req_comp == img_n) return data;
; 1816 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1817 : 
; 1818 :    good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
; 1819 :    if (good == NULL) {
; 1820 :       STBI_FREE(data);
; 1821 :       return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1822 :    }
; 1823 : 
; 1824 :    for (j=0; j < (int) y; ++j) {
; 1825 :       stbi__uint16 *src  = data + j * x * img_n   ;
; 1826 :       stbi__uint16 *dest = good + j * x * req_comp;
; 1827 : 
; 1828 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1829 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1830 :       // convert source image with img_n components to one with req_comp components;
; 1831 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1832 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1833 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
; 1834 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1835 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
; 1836 :          STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
; 1837 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1838 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
; 1839 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
; 1840 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1841 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
; 1842 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1843 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1844 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
; 1845 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
; 1846 :       }
; 1847 :       #undef STBI__CASE
; 1848 :    }
; 1849 : 
; 1850 :    STBI_FREE(data);
; 1851 :    return good;
; 1852 : }
; 1853 : #endif
; 1854 : 
; 1855 : #ifndef STBI_NO_LINEAR
; 1856 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
; 1857 : {
; 1858 :    int i,k,n;
; 1859 :    float *output;
; 1860 :    if (!data) return NULL;
; 1861 :    output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
; 1862 :    if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
; 1863 :    // compute number of non-alpha components
; 1864 :    if (comp & 1) n = comp; else n = comp-1;
; 1865 :    for (i=0; i < x*y; ++i) {
; 1866 :       for (k=0; k < n; ++k) {
; 1867 :          output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
; 1868 :       }
; 1869 :    }
; 1870 :    if (n < comp) {
; 1871 :       for (i=0; i < x*y; ++i) {
; 1872 :          output[i*comp + n] = data[i*comp + n]/255.0f;
; 1873 :       }
; 1874 :    }
; 1875 :    STBI_FREE(data);
; 1876 :    return output;
; 1877 : }
; 1878 : #endif
; 1879 : 
; 1880 : #ifndef STBI_NO_HDR
; 1881 : #define stbi__float2int(x)   ((int) (x))
; 1882 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
; 1883 : {
; 1884 :    int i,k,n;
; 1885 :    stbi_uc *output;
; 1886 :    if (!data) return NULL;
; 1887 :    output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
; 1888 :    if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
; 1889 :    // compute number of non-alpha components
; 1890 :    if (comp & 1) n = comp; else n = comp-1;
; 1891 :    for (i=0; i < x*y; ++i) {
; 1892 :       for (k=0; k < n; ++k) {
; 1893 :          float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
; 1894 :          if (z < 0) z = 0;
; 1895 :          if (z > 255) z = 255;
; 1896 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1897 :       }
; 1898 :       if (k < comp) {
; 1899 :          float z = data[i*comp+k] * 255 + 0.5f;
; 1900 :          if (z < 0) z = 0;
; 1901 :          if (z > 255) z = 255;
; 1902 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1903 :       }
; 1904 :    }
; 1905 :    STBI_FREE(data);
; 1906 :    return output;
; 1907 : }
; 1908 : #endif
; 1909 : 
; 1910 : //////////////////////////////////////////////////////////////////////////////
; 1911 : //
; 1912 : //  "baseline" JPEG/JFIF decoder
; 1913 : //
; 1914 : //    simple implementation
; 1915 : //      - doesn't support delayed output of y-dimension
; 1916 : //      - simple interface (only one output format: 8-bit interleaved RGB)
; 1917 : //      - doesn't try to recover corrupt jpegs
; 1918 : //      - doesn't allow partial loading, loading multiple at once
; 1919 : //      - still fast on x86 (copying globals into locals doesn't help x86)
; 1920 : //      - allocates lots of intermediate memory (full size of all components)
; 1921 : //        - non-interleaved case requires this anyway
; 1922 : //        - allows good upsampling (see next)
; 1923 : //    high-quality
; 1924 : //      - upsampled channels are bilinearly interpolated, even across blocks
; 1925 : //      - quality integer IDCT derived from IJG's 'slow'
; 1926 : //    performance
; 1927 : //      - fast huffman; reasonable integer IDCT
; 1928 : //      - some SIMD kernels for common paths on targets with SSE2/NEON
; 1929 : //      - uses a lot of intermediate memory, could cache poorly
; 1930 : 
; 1931 : #ifndef STBI_NO_JPEG
; 1932 : 
; 1933 : // huffman decoding acceleration
; 1934 : #define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
; 1935 : 
; 1936 : typedef struct
; 1937 : {
; 1938 :    stbi_uc  fast[1 << FAST_BITS];
; 1939 :    // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
; 1940 :    stbi__uint16 code[256];
; 1941 :    stbi_uc  values[256];
; 1942 :    stbi_uc  size[257];
; 1943 :    unsigned int maxcode[18];
; 1944 :    int    delta[17];   // old 'firstsymbol' - old 'firstcode'
; 1945 : } stbi__huffman;
; 1946 : 
; 1947 : typedef struct
; 1948 : {
; 1949 :    stbi__context *s;
; 1950 :    stbi__huffman huff_dc[4];
; 1951 :    stbi__huffman huff_ac[4];
; 1952 :    stbi__uint16 dequant[4][64];
; 1953 :    stbi__int16 fast_ac[4][1 << FAST_BITS];
; 1954 : 
; 1955 : // sizes for components, interleaved MCUs
; 1956 :    int img_h_max, img_v_max;
; 1957 :    int img_mcu_x, img_mcu_y;
; 1958 :    int img_mcu_w, img_mcu_h;
; 1959 : 
; 1960 : // definition of jpeg image component
; 1961 :    struct
; 1962 :    {
; 1963 :       int id;
; 1964 :       int h,v;
; 1965 :       int tq;
; 1966 :       int hd,ha;
; 1967 :       int dc_pred;
; 1968 : 
; 1969 :       int x,y,w2,h2;
; 1970 :       stbi_uc *data;
; 1971 :       void *raw_data, *raw_coeff;
; 1972 :       stbi_uc *linebuf;
; 1973 :       short   *coeff;   // progressive only
; 1974 :       int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
; 1975 :    } img_comp[4];
; 1976 : 
; 1977 :    stbi__uint32   code_buffer; // jpeg entropy-coded buffer
; 1978 :    int            code_bits;   // number of valid bits
; 1979 :    unsigned char  marker;      // marker seen while filling entropy buffer
; 1980 :    int            nomore;      // flag if we saw a marker so must stop
; 1981 : 
; 1982 :    int            progressive;
; 1983 :    int            spec_start;
; 1984 :    int            spec_end;
; 1985 :    int            succ_high;
; 1986 :    int            succ_low;
; 1987 :    int            eob_run;
; 1988 :    int            jfif;
; 1989 :    int            app14_color_transform; // Adobe APP14 tag
; 1990 :    int            rgb;
; 1991 : 
; 1992 :    int scan_n, order[4];
; 1993 :    int restart_interval, todo;
; 1994 : 
; 1995 : // kernels
; 1996 :    void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
; 1997 :    void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
; 1998 :    stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
; 1999 : } stbi__jpeg;
; 2000 : 
; 2001 : static int stbi__build_huffman(stbi__huffman *h, int *count)
; 2002 : {
; 2003 :    int i,j,k=0;
; 2004 :    unsigned int code;
; 2005 :    // build size list for each symbol (from JPEG spec)
; 2006 :    for (i=0; i < 16; ++i) {
; 2007 :       for (j=0; j < count[i]; ++j) {
; 2008 :          h->size[k++] = (stbi_uc) (i+1);
; 2009 :          if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");
; 2010 :       }
; 2011 :    }
; 2012 :    h->size[k] = 0;
; 2013 : 
; 2014 :    // compute actual symbols (from jpeg spec)
; 2015 :    code = 0;
; 2016 :    k = 0;
; 2017 :    for(j=1; j <= 16; ++j) {
; 2018 :       // compute delta to add to code to compute symbol id
; 2019 :       h->delta[j] = k - code;
; 2020 :       if (h->size[k] == j) {
; 2021 :          while (h->size[k] == j)
; 2022 :             h->code[k++] = (stbi__uint16) (code++);
; 2023 :          if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
; 2024 :       }
; 2025 :       // compute largest code + 1 for this size, preshifted as needed later
; 2026 :       h->maxcode[j] = code << (16-j);
; 2027 :       code <<= 1;
; 2028 :    }
; 2029 :    h->maxcode[j] = 0xffffffff;
; 2030 : 
; 2031 :    // build non-spec acceleration table; 255 is flag for not-accelerated
; 2032 :    memset(h->fast, 255, 1 << FAST_BITS);
; 2033 :    for (i=0; i < k; ++i) {
; 2034 :       int s = h->size[i];
; 2035 :       if (s <= FAST_BITS) {
; 2036 :          int c = h->code[i] << (FAST_BITS-s);
; 2037 :          int m = 1 << (FAST_BITS-s);
; 2038 :          for (j=0; j < m; ++j) {
; 2039 :             h->fast[c+j] = (stbi_uc) i;
; 2040 :          }
; 2041 :       }
; 2042 :    }
; 2043 :    return 1;
; 2044 : }
; 2045 : 
; 2046 : // build a table that decodes both magnitude and value of small ACs in
; 2047 : // one go.
; 2048 : static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
; 2049 : {
; 2050 :    int i;
; 2051 :    for (i=0; i < (1 << FAST_BITS); ++i) {
; 2052 :       stbi_uc fast = h->fast[i];
; 2053 :       fast_ac[i] = 0;
; 2054 :       if (fast < 255) {
; 2055 :          int rs = h->values[fast];
; 2056 :          int run = (rs >> 4) & 15;
; 2057 :          int magbits = rs & 15;
; 2058 :          int len = h->size[fast];
; 2059 : 
; 2060 :          if (magbits && len + magbits <= FAST_BITS) {
; 2061 :             // magnitude code followed by receive_extend code
; 2062 :             int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
; 2063 :             int m = 1 << (magbits - 1);
; 2064 :             if (k < m) k += (~0U << magbits) + 1;
; 2065 :             // if the result is small enough, we can fit it in fast_ac table
; 2066 :             if (k >= -128 && k <= 127)
; 2067 :                fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
; 2068 :          }
; 2069 :       }
; 2070 :    }
; 2071 : }
; 2072 : 
; 2073 : static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
; 2074 : {
; 2075 :    do {
; 2076 :       unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
; 2077 :       if (b == 0xff) {
; 2078 :          int c = stbi__get8(j->s);
; 2079 :          while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
; 2080 :          if (c != 0) {
; 2081 :             j->marker = (unsigned char) c;
; 2082 :             j->nomore = 1;
; 2083 :             return;
; 2084 :          }
; 2085 :       }
; 2086 :       j->code_buffer |= b << (24 - j->code_bits);
; 2087 :       j->code_bits += 8;
; 2088 :    } while (j->code_bits <= 24);
; 2089 : }
; 2090 : 
; 2091 : // (1 << n) - 1
; 2092 : static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
; 2093 : 
; 2094 : // decode a jpeg huffman value from the bitstream
; 2095 : stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
; 2096 : {
; 2097 :    unsigned int temp;
; 2098 :    int c,k;
; 2099 : 
; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2105 :    k = h->fast[c];
; 2106 :    if (k < 255) {
; 2107 :       int s = h->size[k];
; 2108 :       if (s > j->code_bits)
; 2109 :          return -1;
; 2110 :       j->code_buffer <<= s;
; 2111 :       j->code_bits -= s;
; 2112 :       return h->values[k];
; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;
; 2122 :    for (k=FAST_BITS+1 ; ; ++k)
; 2123 :       if (temp < h->maxcode[k])
; 2124 :          break;
; 2125 :    if (k == 17) {
; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;
; 2128 :       return -1;
; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)
; 2132 :       return -1;
; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!
; 2137 :        return -1;
; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;
; 2142 :    j->code_buffer <<= k;
; 2143 :    return h->values[c];
; 2144 : }
; 2145 : 
; 2146 : // bias[n] = (-1<<n) + 1
; 2147 : static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};
; 2148 : 
; 2149 : // combined JPEG 'receive' and JPEG 'extend', since baseline
; 2150 : // always extends everything it receives.
; 2151 : stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
; 2152 : {
; 2153 :    unsigned int k;
; 2154 :    int sgn;
; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
; 2159 :    k = stbi_lrot(j->code_buffer, n);
; 2160 :    j->code_buffer = k & ~stbi__bmask[n];
; 2161 :    k &= stbi__bmask[n];
; 2162 :    j->code_bits -= n;
; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));
; 2164 : }
; 2165 : 
; 2166 : // get some unsigned bits
; 2167 : stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
; 2168 : {
; 2169 :    unsigned int k;
; 2170 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2171 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2172 :    k = stbi_lrot(j->code_buffer, n);
; 2173 :    j->code_buffer = k & ~stbi__bmask[n];
; 2174 :    k &= stbi__bmask[n];
; 2175 :    j->code_bits -= n;
; 2176 :    return k;
; 2177 : }
; 2178 : 
; 2179 : stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
; 2180 : {
; 2181 :    unsigned int k;
; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2184 :    k = j->code_buffer;
; 2185 :    j->code_buffer <<= 1;
; 2186 :    --j->code_bits;
; 2187 :    return k & 0x80000000;
; 2188 : }
; 2189 : 
; 2190 : // given a value that's at position X in the zigzag stream,
; 2191 : // where does it appear in the 8x8 matrix coded as row-major?
; 2192 : static const stbi_uc stbi__jpeg_dezigzag[64+15] =
; 2193 : {
; 2194 :     0,  1,  8, 16,  9,  2,  3, 10,
; 2195 :    17, 24, 32, 25, 18, 11,  4,  5,
; 2196 :    12, 19, 26, 33, 40, 48, 41, 34,
; 2197 :    27, 20, 13,  6,  7, 14, 21, 28,
; 2198 :    35, 42, 49, 56, 57, 50, 43, 36,
; 2199 :    29, 22, 15, 23, 30, 37, 44, 51,
; 2200 :    58, 59, 52, 45, 38, 31, 39, 46,
; 2201 :    53, 60, 61, 54, 47, 55, 62, 63,
; 2202 :    // let corrupt input sample past end
; 2203 :    63, 63, 63, 63, 63, 63, 63, 63,
; 2204 :    63, 63, 63, 63, 63, 63, 63
; 2205 : };
; 2206 : 
; 2207 : // decode one 64-entry block--
; 2208 : static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
; 2209 : {
; 2210 :    int diff,dc,k;
; 2211 :    int t;
; 2212 : 
; 2213 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2214 :    t = stbi__jpeg_huff_decode(j, hdc);
; 2215 :    if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");
; 2216 : 
; 2217 :    // 0 all the ac values now so we can do it 32-bits at a time
; 2218 :    memset(data,0,64*sizeof(data[0]));
; 2219 : 
; 2220 :    diff = t ? stbi__extend_receive(j, t) : 0;
; 2221 :    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");
; 2222 :    dc = j->img_comp[b].dc_pred + diff;
; 2223 :    j->img_comp[b].dc_pred = dc;
; 2224 :    if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2225 :    data[0] = (short) (dc * dequant[0]);
; 2226 : 
; 2227 :    // decode AC components, see JPEG spec
; 2228 :    k = 1;
; 2229 :    do {
; 2230 :       unsigned int zig;
; 2231 :       int c,r,s;
; 2232 :       if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2233 :       c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2234 :       r = fac[c];
; 2235 :       if (r) { // fast-AC path
; 2236 :          k += (r >> 4) & 15; // run
; 2237 :          s = r & 15; // combined length
; 2238 :          if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2239 :          j->code_buffer <<= s;
; 2240 :          j->code_bits -= s;
; 2241 :          // decode into unzigzag'd location
; 2242 :          zig = stbi__jpeg_dezigzag[k++];
; 2243 :          data[zig] = (short) ((r >> 8) * dequant[zig]);
; 2244 :       } else {
; 2245 :          int rs = stbi__jpeg_huff_decode(j, hac);
; 2246 :          if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2247 :          s = rs & 15;
; 2248 :          r = rs >> 4;
; 2249 :          if (s == 0) {
; 2250 :             if (rs != 0xf0) break; // end block
; 2251 :             k += 16;
; 2252 :          } else {
; 2253 :             k += r;
; 2254 :             // decode into unzigzag'd location
; 2255 :             zig = stbi__jpeg_dezigzag[k++];
; 2256 :             data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
; 2257 :          }
; 2258 :       }
; 2259 :    } while (k < 64);
; 2260 :    return 1;
; 2261 : }
; 2262 : 
; 2263 : static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
; 2264 : {
; 2265 :    int diff,dc;
; 2266 :    int t;
; 2267 :    if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2268 : 
; 2269 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2270 : 
; 2271 :    if (j->succ_high == 0) {
; 2272 :       // first scan for DC coefficient, must be first
; 2273 :       memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
; 2274 :       t = stbi__jpeg_huff_decode(j, hdc);
; 2275 :       if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2276 :       diff = t ? stbi__extend_receive(j, t) : 0;
; 2277 : 
; 2278 :       if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");
; 2279 :       dc = j->img_comp[b].dc_pred + diff;
; 2280 :       j->img_comp[b].dc_pred = dc;
; 2281 :       if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2282 :       data[0] = (short) (dc * (1 << j->succ_low));
; 2283 :    } else {
; 2284 :       // refinement scan for DC coefficient
; 2285 :       if (stbi__jpeg_get_bit(j))
; 2286 :          data[0] += (short) (1 << j->succ_low);
; 2287 :    }
; 2288 :    return 1;
; 2289 : }
; 2290 : 
; 2291 : // @OPTIMIZE: store non-zigzagged during the decode passes,
; 2292 : // and only de-zigzag when dequantizing
; 2293 : static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
; 2294 : {
; 2295 :    int k;
; 2296 :    if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2297 : 
; 2298 :    if (j->succ_high == 0) {
; 2299 :       int shift = j->succ_low;
; 2300 : 
; 2301 :       if (j->eob_run) {
; 2302 :          --j->eob_run;
; 2303 :          return 1;
; 2304 :       }
; 2305 : 
; 2306 :       k = j->spec_start;
; 2307 :       do {
; 2308 :          unsigned int zig;
; 2309 :          int c,r,s;
; 2310 :          if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2311 :          c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2312 :          r = fac[c];
; 2313 :          if (r) { // fast-AC path
; 2314 :             k += (r >> 4) & 15; // run
; 2315 :             s = r & 15; // combined length
; 2316 :             if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2317 :             j->code_buffer <<= s;
; 2318 :             j->code_bits -= s;
; 2319 :             zig = stbi__jpeg_dezigzag[k++];
; 2320 :             data[zig] = (short) ((r >> 8) * (1 << shift));
; 2321 :          } else {
; 2322 :             int rs = stbi__jpeg_huff_decode(j, hac);
; 2323 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2324 :             s = rs & 15;
; 2325 :             r = rs >> 4;
; 2326 :             if (s == 0) {
; 2327 :                if (r < 15) {
; 2328 :                   j->eob_run = (1 << r);
; 2329 :                   if (r)
; 2330 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2331 :                   --j->eob_run;
; 2332 :                   break;
; 2333 :                }
; 2334 :                k += 16;
; 2335 :             } else {
; 2336 :                k += r;
; 2337 :                zig = stbi__jpeg_dezigzag[k++];
; 2338 :                data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
; 2339 :             }
; 2340 :          }
; 2341 :       } while (k <= j->spec_end);
; 2342 :    } else {
; 2343 :       // refinement scan for these AC coefficients
; 2344 : 
; 2345 :       short bit = (short) (1 << j->succ_low);
; 2346 : 
; 2347 :       if (j->eob_run) {
; 2348 :          --j->eob_run;
; 2349 :          for (k = j->spec_start; k <= j->spec_end; ++k) {
; 2350 :             short *p = &data[stbi__jpeg_dezigzag[k]];
; 2351 :             if (*p != 0)
; 2352 :                if (stbi__jpeg_get_bit(j))
; 2353 :                   if ((*p & bit)==0) {
; 2354 :                      if (*p > 0)
; 2355 :                         *p += bit;
; 2356 :                      else
; 2357 :                         *p -= bit;
; 2358 :                   }
; 2359 :          }
; 2360 :       } else {
; 2361 :          k = j->spec_start;
; 2362 :          do {
; 2363 :             int r,s;
; 2364 :             int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
; 2365 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2366 :             s = rs & 15;
; 2367 :             r = rs >> 4;
; 2368 :             if (s == 0) {
; 2369 :                if (r < 15) {
; 2370 :                   j->eob_run = (1 << r) - 1;
; 2371 :                   if (r)
; 2372 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2373 :                   r = 64; // force end of block
; 2374 :                } else {
; 2375 :                   // r=15 s=0 should write 16 0s, so we just do
; 2376 :                   // a run of 15 0s and then write s (which is 0),
; 2377 :                   // so we don't have to do anything special here
; 2378 :                }
; 2379 :             } else {
; 2380 :                if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
; 2381 :                // sign bit
; 2382 :                if (stbi__jpeg_get_bit(j))
; 2383 :                   s = bit;
; 2384 :                else
; 2385 :                   s = -bit;
; 2386 :             }
; 2387 : 
; 2388 :             // advance by r
; 2389 :             while (k <= j->spec_end) {
; 2390 :                short *p = &data[stbi__jpeg_dezigzag[k++]];
; 2391 :                if (*p != 0) {
; 2392 :                   if (stbi__jpeg_get_bit(j))
; 2393 :                      if ((*p & bit)==0) {
; 2394 :                         if (*p > 0)
; 2395 :                            *p += bit;
; 2396 :                         else
; 2397 :                            *p -= bit;
; 2398 :                      }
; 2399 :                } else {
; 2400 :                   if (r == 0) {
; 2401 :                      *p = (short) s;
; 2402 :                      break;
; 2403 :                   }
; 2404 :                   --r;
; 2405 :                }
; 2406 :             }
; 2407 :          } while (k <= j->spec_end);
; 2408 :       }
; 2409 :    }
; 2410 :    return 1;
; 2411 : }
; 2412 : 
; 2413 : // take a -128..127 value and stbi__clamp it and convert to 0..255
; 2414 : stbi_inline static stbi_uc stbi__clamp(int x)
; 2415 : {
; 2416 :    // trick to use a single test to catch both cases
; 2417 :    if ((unsigned int) x > 255) {
; 2418 :       if (x < 0) return 0;
; 2419 :       if (x > 255) return 255;
; 2420 :    }
; 2421 :    return (stbi_uc) x;
; 2422 : }
; 2423 : 
; 2424 : #define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
; 2425 : #define stbi__fsh(x)  ((x) * 4096)
; 2426 : 
; 2427 : // derived from jidctint -- DCT_ISLOW
; 2428 : #define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
; 2429 :    int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
; 2430 :    p2 = s2;                                    \
; 2431 :    p3 = s6;                                    \
; 2432 :    p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
; 2433 :    t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
; 2434 :    t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
; 2435 :    p2 = s0;                                    \
; 2436 :    p3 = s4;                                    \
; 2437 :    t0 = stbi__fsh(p2+p3);                      \
; 2438 :    t1 = stbi__fsh(p2-p3);                      \
; 2439 :    x0 = t0+t3;                                 \
; 2440 :    x3 = t0-t3;                                 \
; 2441 :    x1 = t1+t2;                                 \
; 2442 :    x2 = t1-t2;                                 \
; 2443 :    t0 = s7;                                    \
; 2444 :    t1 = s5;                                    \
; 2445 :    t2 = s3;                                    \
; 2446 :    t3 = s1;                                    \
; 2447 :    p3 = t0+t2;                                 \
; 2448 :    p4 = t1+t3;                                 \
; 2449 :    p1 = t0+t3;                                 \
; 2450 :    p2 = t1+t2;                                 \
; 2451 :    p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
; 2452 :    t0 = t0*stbi__f2f( 0.298631336f);           \
; 2453 :    t1 = t1*stbi__f2f( 2.053119869f);           \
; 2454 :    t2 = t2*stbi__f2f( 3.072711026f);           \
; 2455 :    t3 = t3*stbi__f2f( 1.501321110f);           \
; 2456 :    p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
; 2457 :    p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
; 2458 :    p3 = p3*stbi__f2f(-1.961570560f);           \
; 2459 :    p4 = p4*stbi__f2f(-0.390180644f);           \
; 2460 :    t3 += p1+p4;                                \
; 2461 :    t2 += p2+p3;                                \
; 2462 :    t1 += p2+p4;                                \
; 2463 :    t0 += p1+p3;
; 2464 : 
; 2465 : static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
; 2466 : {
; 2467 :    int i,val[64],*v=val;
; 2468 :    stbi_uc *o;
; 2469 :    short *d = data;
; 2470 : 
; 2471 :    // columns
; 2472 :    for (i=0; i < 8; ++i,++d, ++v) {
; 2473 :       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2474 :       if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2475 :            && d[40]==0 && d[48]==0 && d[56]==0) {
; 2476 :          //    no shortcut                 0     seconds
; 2477 :          //    (1|2|3|4|5|6|7)==0          0     seconds
; 2478 :          //    all separate               -0.047 seconds
; 2479 :          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2480 :          int dcterm = d[0]*4;
; 2481 :          v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
; 2482 :       } else {
; 2483 :          STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
; 2484 :          // constants scaled things up by 1<<12; let's bring them back
; 2485 :          // down, but keep 2 extra bits of precision
; 2486 :          x0 += 512; x1 += 512; x2 += 512; x3 += 512;
; 2487 :          v[ 0] = (x0+t3) >> 10;
; 2488 :          v[56] = (x0-t3) >> 10;
; 2489 :          v[ 8] = (x1+t2) >> 10;
; 2490 :          v[48] = (x1-t2) >> 10;
; 2491 :          v[16] = (x2+t1) >> 10;
; 2492 :          v[40] = (x2-t1) >> 10;
; 2493 :          v[24] = (x3+t0) >> 10;
; 2494 :          v[32] = (x3-t0) >> 10;
; 2495 :       }
; 2496 :    }
; 2497 : 
; 2498 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
; 2499 :       // no fast case since the first 1D IDCT spread components out
; 2500 :       STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
; 2501 :       // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2502 :       // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2503 :       // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2504 :       // so we want to round that, which means adding 0.5 * 1<<17,
; 2505 :       // aka 65536. Also, we'll end up with -128 to 127 that we want
; 2506 :       // to encode as 0..255 by adding 128, so we'll add that before the shift
; 2507 :       x0 += 65536 + (128<<17);
; 2508 :       x1 += 65536 + (128<<17);
; 2509 :       x2 += 65536 + (128<<17);
; 2510 :       x3 += 65536 + (128<<17);
; 2511 :       // tried computing the shifts into temps, or'ing the temps to see
; 2512 :       // if any were out of range, but that was slower
; 2513 :       o[0] = stbi__clamp((x0+t3) >> 17);
; 2514 :       o[7] = stbi__clamp((x0-t3) >> 17);
; 2515 :       o[1] = stbi__clamp((x1+t2) >> 17);
; 2516 :       o[6] = stbi__clamp((x1-t2) >> 17);
; 2517 :       o[2] = stbi__clamp((x2+t1) >> 17);
; 2518 :       o[5] = stbi__clamp((x2-t1) >> 17);
; 2519 :       o[3] = stbi__clamp((x3+t0) >> 17);
; 2520 :       o[4] = stbi__clamp((x3-t0) >> 17);
; 2521 :    }
; 2522 : }
; 2523 : 
; 2524 : #ifdef STBI_SSE2
; 2525 : // sse2 integer IDCT. not the fastest possible implementation but it
; 2526 : // produces bit-identical results to the generic C version so it's
; 2527 : // fully "transparent".
; 2528 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2529 : {
; 2530 :    // This is constructed to match our regular (generic) integer IDCT exactly.
; 2531 :    __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2532 :    __m128i tmp;
; 2533 : 
; 2534 :    // dot product constant: even elems=x, odd elems=y
; 2535 :    #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2536 : 
; 2537 :    // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2538 :    // out(1) = c1[even]*x + c1[odd]*y
; 2539 :    #define dct_rot(out0,out1, x,y,c0,c1) \
; 2540 :       __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2541 :       __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2542 :       __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2543 :       __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2544 :       __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2545 :       __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2546 : 
; 2547 :    // out = in << 12  (in 16-bit, out 32-bit)
; 2548 :    #define dct_widen(out, in) \
; 2549 :       __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2550 :       __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2551 : 
; 2552 :    // wide add
; 2553 :    #define dct_wadd(out, a, b) \
; 2554 :       __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2555 :       __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2556 : 
; 2557 :    // wide sub
; 2558 :    #define dct_wsub(out, a, b) \
; 2559 :       __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2560 :       __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2561 : 
; 2562 :    // butterfly a/b, add bias, then shift by "s" and pack
; 2563 :    #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2564 :       { \
; 2565 :          __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2566 :          __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2567 :          dct_wadd(sum, abiased, b); \
; 2568 :          dct_wsub(dif, abiased, b); \
; 2569 :          out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2570 :          out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2571 :       }
; 2572 : 
; 2573 :    // 8-bit interleave step (for transposes)
; 2574 :    #define dct_interleave8(a, b) \
; 2575 :       tmp = a; \
; 2576 :       a = _mm_unpacklo_epi8(a, b); \
; 2577 :       b = _mm_unpackhi_epi8(tmp, b)
; 2578 : 
; 2579 :    // 16-bit interleave step (for transposes)
; 2580 :    #define dct_interleave16(a, b) \
; 2581 :       tmp = a; \
; 2582 :       a = _mm_unpacklo_epi16(a, b); \
; 2583 :       b = _mm_unpackhi_epi16(tmp, b)
; 2584 : 
; 2585 :    #define dct_pass(bias,shift) \
; 2586 :       { \
; 2587 :          /* even part */ \
; 2588 :          dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2589 :          __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2590 :          __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2591 :          dct_widen(t0e, sum04); \
; 2592 :          dct_widen(t1e, dif04); \
; 2593 :          dct_wadd(x0, t0e, t3e); \
; 2594 :          dct_wsub(x3, t0e, t3e); \
; 2595 :          dct_wadd(x1, t1e, t2e); \
; 2596 :          dct_wsub(x2, t1e, t2e); \
; 2597 :          /* odd part */ \
; 2598 :          dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2599 :          dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2600 :          __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2601 :          __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2602 :          dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2603 :          dct_wadd(x4, y0o, y4o); \
; 2604 :          dct_wadd(x5, y1o, y5o); \
; 2605 :          dct_wadd(x6, y2o, y5o); \
; 2606 :          dct_wadd(x7, y3o, y4o); \
; 2607 :          dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2608 :          dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2609 :          dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2610 :          dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2611 :       }
; 2612 : 
; 2613 :    __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
; 2614 :    __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
; 2615 :    __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
; 2616 :    __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
; 2617 :    __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
; 2618 :    __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
; 2619 :    __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
; 2620 :    __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
; 2621 : 
; 2622 :    // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2623 :    __m128i bias_0 = _mm_set1_epi32(512);
; 2624 :    __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
; 2625 : 
; 2626 :    // load
; 2627 :    row0 = _mm_load_si128((const __m128i *) (data + 0*8));
; 2628 :    row1 = _mm_load_si128((const __m128i *) (data + 1*8));
; 2629 :    row2 = _mm_load_si128((const __m128i *) (data + 2*8));
; 2630 :    row3 = _mm_load_si128((const __m128i *) (data + 3*8));
; 2631 :    row4 = _mm_load_si128((const __m128i *) (data + 4*8));
; 2632 :    row5 = _mm_load_si128((const __m128i *) (data + 5*8));
; 2633 :    row6 = _mm_load_si128((const __m128i *) (data + 6*8));
; 2634 :    row7 = _mm_load_si128((const __m128i *) (data + 7*8));
; 2635 : 
; 2636 :    // column pass
; 2637 :    dct_pass(bias_0, 10);
; 2638 : 
; 2639 :    {
; 2640 :       // 16bit 8x8 transpose pass 1
; 2641 :       dct_interleave16(row0, row4);
; 2642 :       dct_interleave16(row1, row5);
; 2643 :       dct_interleave16(row2, row6);
; 2644 :       dct_interleave16(row3, row7);
; 2645 : 
; 2646 :       // transpose pass 2
; 2647 :       dct_interleave16(row0, row2);
; 2648 :       dct_interleave16(row1, row3);
; 2649 :       dct_interleave16(row4, row6);
; 2650 :       dct_interleave16(row5, row7);
; 2651 : 
; 2652 :       // transpose pass 3
; 2653 :       dct_interleave16(row0, row1);
; 2654 :       dct_interleave16(row2, row3);
; 2655 :       dct_interleave16(row4, row5);
; 2656 :       dct_interleave16(row6, row7);
; 2657 :    }
; 2658 : 
; 2659 :    // row pass
; 2660 :    dct_pass(bias_1, 17);
; 2661 : 
; 2662 :    {
; 2663 :       // pack
; 2664 :       __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
; 2665 :       __m128i p1 = _mm_packus_epi16(row2, row3);
; 2666 :       __m128i p2 = _mm_packus_epi16(row4, row5);
; 2667 :       __m128i p3 = _mm_packus_epi16(row6, row7);
; 2668 : 
; 2669 :       // 8bit 8x8 transpose pass 1
; 2670 :       dct_interleave8(p0, p2); // a0e0a1e1...
; 2671 :       dct_interleave8(p1, p3); // c0g0c1g1...
; 2672 : 
; 2673 :       // transpose pass 2
; 2674 :       dct_interleave8(p0, p1); // a0c0e0g0...
; 2675 :       dct_interleave8(p2, p3); // b0d0f0h0...
; 2676 : 
; 2677 :       // transpose pass 3
; 2678 :       dct_interleave8(p0, p2); // a0b0c0d0...
; 2679 :       dct_interleave8(p1, p3); // a4b4c4d4...
; 2680 : 
; 2681 :       // store
; 2682 :       _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
; 2683 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
; 2684 :       _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
; 2685 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
; 2686 :       _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
; 2687 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
; 2688 :       _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
; 2689 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
; 2690 :    }
; 2691 : 
; 2692 : #undef dct_const
; 2693 : #undef dct_rot
; 2694 : #undef dct_widen
; 2695 : #undef dct_wadd
; 2696 : #undef dct_wsub
; 2697 : #undef dct_bfly32o
; 2698 : #undef dct_interleave8
; 2699 : #undef dct_interleave16
; 2700 : #undef dct_pass
; 2701 : }
; 2702 : 
; 2703 : #endif // STBI_SSE2
; 2704 : 
; 2705 : #ifdef STBI_NEON
; 2706 : 
; 2707 : // NEON integer IDCT. should produce bit-identical
; 2708 : // results to the generic C version.
; 2709 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2710 : {
; 2711 :    int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;
; 2712 : 
; 2713 :    int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
; 2714 :    int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
; 2715 :    int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
; 2716 :    int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
; 2717 :    int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
; 2718 :    int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
; 2719 :    int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
; 2720 :    int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
; 2721 :    int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
; 2722 :    int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
; 2723 :    int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
; 2724 :    int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));
; 2725 : 
; 2726 : #define dct_long_mul(out, inq, coeff) \
; 2727 :    int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
; 2728 :    int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)
; 2729 : 
; 2730 : #define dct_long_mac(out, acc, inq, coeff) \
; 2731 :    int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
; 2732 :    int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)
; 2733 : 
; 2734 : #define dct_widen(out, inq) \
; 2735 :    int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
; 2736 :    int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)
; 2737 : 
; 2738 : // wide add
; 2739 : #define dct_wadd(out, a, b) \
; 2740 :    int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
; 2741 :    int32x4_t out##_h = vaddq_s32(a##_h, b##_h)
; 2742 : 
; 2743 : // wide sub
; 2744 : #define dct_wsub(out, a, b) \
; 2745 :    int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
; 2746 :    int32x4_t out##_h = vsubq_s32(a##_h, b##_h)
; 2747 : 
; 2748 : // butterfly a/b, then shift using "shiftop" by "s" and pack
; 2749 : #define dct_bfly32o(out0,out1, a,b,shiftop,s) \
; 2750 :    { \
; 2751 :       dct_wadd(sum, a, b); \
; 2752 :       dct_wsub(dif, a, b); \
; 2753 :       out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
; 2754 :       out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
; 2755 :    }
; 2756 : 
; 2757 : #define dct_pass(shiftop, shift) \
; 2758 :    { \
; 2759 :       /* even part */ \
; 2760 :       int16x8_t sum26 = vaddq_s16(row2, row6); \
; 2761 :       dct_long_mul(p1e, sum26, rot0_0); \
; 2762 :       dct_long_mac(t2e, p1e, row6, rot0_1); \
; 2763 :       dct_long_mac(t3e, p1e, row2, rot0_2); \
; 2764 :       int16x8_t sum04 = vaddq_s16(row0, row4); \
; 2765 :       int16x8_t dif04 = vsubq_s16(row0, row4); \
; 2766 :       dct_widen(t0e, sum04); \
; 2767 :       dct_widen(t1e, dif04); \
; 2768 :       dct_wadd(x0, t0e, t3e); \
; 2769 :       dct_wsub(x3, t0e, t3e); \
; 2770 :       dct_wadd(x1, t1e, t2e); \
; 2771 :       dct_wsub(x2, t1e, t2e); \
; 2772 :       /* odd part */ \
; 2773 :       int16x8_t sum15 = vaddq_s16(row1, row5); \
; 2774 :       int16x8_t sum17 = vaddq_s16(row1, row7); \
; 2775 :       int16x8_t sum35 = vaddq_s16(row3, row5); \
; 2776 :       int16x8_t sum37 = vaddq_s16(row3, row7); \
; 2777 :       int16x8_t sumodd = vaddq_s16(sum17, sum35); \
; 2778 :       dct_long_mul(p5o, sumodd, rot1_0); \
; 2779 :       dct_long_mac(p1o, p5o, sum17, rot1_1); \
; 2780 :       dct_long_mac(p2o, p5o, sum35, rot1_2); \
; 2781 :       dct_long_mul(p3o, sum37, rot2_0); \
; 2782 :       dct_long_mul(p4o, sum15, rot2_1); \
; 2783 :       dct_wadd(sump13o, p1o, p3o); \
; 2784 :       dct_wadd(sump24o, p2o, p4o); \
; 2785 :       dct_wadd(sump23o, p2o, p3o); \
; 2786 :       dct_wadd(sump14o, p1o, p4o); \
; 2787 :       dct_long_mac(x4, sump13o, row7, rot3_0); \
; 2788 :       dct_long_mac(x5, sump24o, row5, rot3_1); \
; 2789 :       dct_long_mac(x6, sump23o, row3, rot3_2); \
; 2790 :       dct_long_mac(x7, sump14o, row1, rot3_3); \
; 2791 :       dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
; 2792 :       dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
; 2793 :       dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
; 2794 :       dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
; 2795 :    }
; 2796 : 
; 2797 :    // load
; 2798 :    row0 = vld1q_s16(data + 0*8);
; 2799 :    row1 = vld1q_s16(data + 1*8);
; 2800 :    row2 = vld1q_s16(data + 2*8);
; 2801 :    row3 = vld1q_s16(data + 3*8);
; 2802 :    row4 = vld1q_s16(data + 4*8);
; 2803 :    row5 = vld1q_s16(data + 5*8);
; 2804 :    row6 = vld1q_s16(data + 6*8);
; 2805 :    row7 = vld1q_s16(data + 7*8);
; 2806 : 
; 2807 :    // add DC bias
; 2808 :    row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));
; 2809 : 
; 2810 :    // column pass
; 2811 :    dct_pass(vrshrn_n_s32, 10);
; 2812 : 
; 2813 :    // 16bit 8x8 transpose
; 2814 :    {
; 2815 : // these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
; 2816 : // whether compilers actually get this is another story, sadly.
; 2817 : #define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
; 2818 : #define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
; 2819 : #define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }
; 2820 : 
; 2821 :       // pass 1
; 2822 :       dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
; 2823 :       dct_trn16(row2, row3);
; 2824 :       dct_trn16(row4, row5);
; 2825 :       dct_trn16(row6, row7);
; 2826 : 
; 2827 :       // pass 2
; 2828 :       dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
; 2829 :       dct_trn32(row1, row3);
; 2830 :       dct_trn32(row4, row6);
; 2831 :       dct_trn32(row5, row7);
; 2832 : 
; 2833 :       // pass 3
; 2834 :       dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
; 2835 :       dct_trn64(row1, row5);
; 2836 :       dct_trn64(row2, row6);
; 2837 :       dct_trn64(row3, row7);
; 2838 : 
; 2839 : #undef dct_trn16
; 2840 : #undef dct_trn32
; 2841 : #undef dct_trn64
; 2842 :    }
; 2843 : 
; 2844 :    // row pass
; 2845 :    // vrshrn_n_s32 only supports shifts up to 16, we need
; 2846 :    // 17. so do a non-rounding shift of 16 first then follow
; 2847 :    // up with a rounding shift by 1.
; 2848 :    dct_pass(vshrn_n_s32, 16);
; 2849 : 
; 2850 :    {
; 2851 :       // pack and round
; 2852 :       uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
; 2853 :       uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
; 2854 :       uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
; 2855 :       uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
; 2856 :       uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
; 2857 :       uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
; 2858 :       uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
; 2859 :       uint8x8_t p7 = vqrshrun_n_s16(row7, 1);
; 2860 : 
; 2861 :       // again, these can translate into one instruction, but often don't.
; 2862 : #define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
; 2863 : #define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
; 2864 : #define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }
; 2865 : 
; 2866 :       // sadly can't use interleaved stores here since we only write
; 2867 :       // 8 bytes to each scan line!
; 2868 : 
; 2869 :       // 8x8 8-bit transpose pass 1
; 2870 :       dct_trn8_8(p0, p1);
; 2871 :       dct_trn8_8(p2, p3);
; 2872 :       dct_trn8_8(p4, p5);
; 2873 :       dct_trn8_8(p6, p7);
; 2874 : 
; 2875 :       // pass 2
; 2876 :       dct_trn8_16(p0, p2);
; 2877 :       dct_trn8_16(p1, p3);
; 2878 :       dct_trn8_16(p4, p6);
; 2879 :       dct_trn8_16(p5, p7);
; 2880 : 
; 2881 :       // pass 3
; 2882 :       dct_trn8_32(p0, p4);
; 2883 :       dct_trn8_32(p1, p5);
; 2884 :       dct_trn8_32(p2, p6);
; 2885 :       dct_trn8_32(p3, p7);
; 2886 : 
; 2887 :       // store
; 2888 :       vst1_u8(out, p0); out += out_stride;
; 2889 :       vst1_u8(out, p1); out += out_stride;
; 2890 :       vst1_u8(out, p2); out += out_stride;
; 2891 :       vst1_u8(out, p3); out += out_stride;
; 2892 :       vst1_u8(out, p4); out += out_stride;
; 2893 :       vst1_u8(out, p5); out += out_stride;
; 2894 :       vst1_u8(out, p6); out += out_stride;
; 2895 :       vst1_u8(out, p7);
; 2896 : 
; 2897 : #undef dct_trn8_8
; 2898 : #undef dct_trn8_16
; 2899 : #undef dct_trn8_32
; 2900 :    }
; 2901 : 
; 2902 : #undef dct_long_mul
; 2903 : #undef dct_long_mac
; 2904 : #undef dct_widen
; 2905 : #undef dct_wadd
; 2906 : #undef dct_wsub
; 2907 : #undef dct_bfly32o
; 2908 : #undef dct_pass
; 2909 : }
; 2910 : 
; 2911 : #endif // STBI_NEON
; 2912 : 
; 2913 : #define STBI__MARKER_none  0xff
; 2914 : // if there's a pending marker from the entropy stream, return that
; 2915 : // otherwise, fetch from the stream and get a marker. if there's no
; 2916 : // marker, return 0xff, which is never a valid marker value
; 2917 : static stbi_uc stbi__get_marker(stbi__jpeg *j)
; 2918 : {
; 2919 :    stbi_uc x;
; 2920 :    if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
; 2921 :    x = stbi__get8(j->s);
; 2922 :    if (x != 0xff) return STBI__MARKER_none;
; 2923 :    while (x == 0xff)
; 2924 :       x = stbi__get8(j->s); // consume repeated 0xff fill bytes
; 2925 :    return x;
; 2926 : }
; 2927 : 
; 2928 : // in each scan, we'll have scan_n components, and the order
; 2929 : // of the components is specified by order[]
; 2930 : #define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
; 2931 : 
; 2932 : // after a restart interval, stbi__jpeg_reset the entropy decoder and
; 2933 : // the dc prediction
; 2934 : static void stbi__jpeg_reset(stbi__jpeg *j)
; 2935 : {
; 2936 :    j->code_bits = 0;
; 2937 :    j->code_buffer = 0;
; 2938 :    j->nomore = 0;
; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
; 2940 :    j->marker = STBI__MARKER_none;
; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
; 2942 :    j->eob_run = 0;
; 2943 :    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2944 :    // since we don't even allow 1<<30 pixels
; 2945 : }
; 2946 : 
; 2947 : static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
; 2948 : {
; 2949 :    stbi__jpeg_reset(z);
; 2950 :    if (!z->progressive) {
; 2951 :       if (z->scan_n == 1) {
; 2952 :          int i,j;
; 2953 :          STBI_SIMD_ALIGN(short, data[64]);
; 2954 :          int n = z->order[0];
; 2955 :          // non-interleaved data, we just need to process one block at a time,
; 2956 :          // in trivial scanline order
; 2957 :          // number of blocks to do just depends on how many actual "pixels" this
; 2958 :          // component has, independent of interleaved MCU blocking and such
; 2959 :          int w = (z->img_comp[n].x+7) >> 3;
; 2960 :          int h = (z->img_comp[n].y+7) >> 3;
; 2961 :          for (j=0; j < h; ++j) {
; 2962 :             for (i=0; i < w; ++i) {
; 2963 :                int ha = z->img_comp[n].ha;
; 2964 :                if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2965 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 2966 :                // every data block is an MCU, so countdown the restart interval
; 2967 :                if (--z->todo <= 0) {
; 2968 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 2969 :                   // if it's NOT a restart, then just bail, so we get corrupt data
; 2970 :                   // rather than no data
; 2971 :                   if (!STBI__RESTART(z->marker)) return 1;
; 2972 :                   stbi__jpeg_reset(z);
; 2973 :                }
; 2974 :             }
; 2975 :          }
; 2976 :          return 1;
; 2977 :       } else { // interleaved
; 2978 :          int i,j,k,x,y;
; 2979 :          STBI_SIMD_ALIGN(short, data[64]);
; 2980 :          for (j=0; j < z->img_mcu_y; ++j) {
; 2981 :             for (i=0; i < z->img_mcu_x; ++i) {
; 2982 :                // scan an interleaved mcu... process scan_n components in order
; 2983 :                for (k=0; k < z->scan_n; ++k) {
; 2984 :                   int n = z->order[k];
; 2985 :                   // scan out an mcu's worth of this component; that's just determined
; 2986 :                   // by the basic H and V specified for the component
; 2987 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 2988 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 2989 :                         int x2 = (i*z->img_comp[n].h + x)*8;
; 2990 :                         int y2 = (j*z->img_comp[n].v + y)*8;
; 2991 :                         int ha = z->img_comp[n].ha;
; 2992 :                         if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2993 :                         z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
; 2994 :                      }
; 2995 :                   }
; 2996 :                }
; 2997 :                // after all interleaved components, that's an interleaved MCU,
; 2998 :                // so now count down the restart interval
; 2999 :                if (--z->todo <= 0) {
; 3000 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3001 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3002 :                   stbi__jpeg_reset(z);
; 3003 :                }
; 3004 :             }
; 3005 :          }
; 3006 :          return 1;
; 3007 :       }
; 3008 :    } else {
; 3009 :       if (z->scan_n == 1) {
; 3010 :          int i,j;
; 3011 :          int n = z->order[0];
; 3012 :          // non-interleaved data, we just need to process one block at a time,
; 3013 :          // in trivial scanline order
; 3014 :          // number of blocks to do just depends on how many actual "pixels" this
; 3015 :          // component has, independent of interleaved MCU blocking and such
; 3016 :          int w = (z->img_comp[n].x+7) >> 3;
; 3017 :          int h = (z->img_comp[n].y+7) >> 3;
; 3018 :          for (j=0; j < h; ++j) {
; 3019 :             for (i=0; i < w; ++i) {
; 3020 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3021 :                if (z->spec_start == 0) {
; 3022 :                   if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3023 :                      return 0;
; 3024 :                } else {
; 3025 :                   int ha = z->img_comp[n].ha;
; 3026 :                   if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
; 3027 :                      return 0;
; 3028 :                }
; 3029 :                // every data block is an MCU, so countdown the restart interval
; 3030 :                if (--z->todo <= 0) {
; 3031 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3032 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3033 :                   stbi__jpeg_reset(z);
; 3034 :                }
; 3035 :             }
; 3036 :          }
; 3037 :          return 1;
; 3038 :       } else { // interleaved
; 3039 :          int i,j,k,x,y;
; 3040 :          for (j=0; j < z->img_mcu_y; ++j) {
; 3041 :             for (i=0; i < z->img_mcu_x; ++i) {
; 3042 :                // scan an interleaved mcu... process scan_n components in order
; 3043 :                for (k=0; k < z->scan_n; ++k) {
; 3044 :                   int n = z->order[k];
; 3045 :                   // scan out an mcu's worth of this component; that's just determined
; 3046 :                   // by the basic H and V specified for the component
; 3047 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 3048 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 3049 :                         int x2 = (i*z->img_comp[n].h + x);
; 3050 :                         int y2 = (j*z->img_comp[n].v + y);
; 3051 :                         short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
; 3052 :                         if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3053 :                            return 0;
; 3054 :                      }
; 3055 :                   }
; 3056 :                }
; 3057 :                // after all interleaved components, that's an interleaved MCU,
; 3058 :                // so now count down the restart interval
; 3059 :                if (--z->todo <= 0) {
; 3060 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3061 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3062 :                   stbi__jpeg_reset(z);
; 3063 :                }
; 3064 :             }
; 3065 :          }
; 3066 :          return 1;
; 3067 :       }
; 3068 :    }
; 3069 : }
; 3070 : 
; 3071 : static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
; 3072 : {
; 3073 :    int i;
; 3074 :    for (i=0; i < 64; ++i)
; 3075 :       data[i] *= dequant[i];
; 3076 : }
; 3077 : 
; 3078 : static void stbi__jpeg_finish(stbi__jpeg *z)
; 3079 : {
; 3080 :    if (z->progressive) {
; 3081 :       // dequantize and idct the data
; 3082 :       int i,j,n;
; 3083 :       for (n=0; n < z->s->img_n; ++n) {
; 3084 :          int w = (z->img_comp[n].x+7) >> 3;
; 3085 :          int h = (z->img_comp[n].y+7) >> 3;
; 3086 :          for (j=0; j < h; ++j) {
; 3087 :             for (i=0; i < w; ++i) {
; 3088 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3089 :                stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
; 3090 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 3091 :             }
; 3092 :          }
; 3093 :       }
; 3094 :    }
; 3095 : }
; 3096 : 
; 3097 : static int stbi__process_marker(stbi__jpeg *z, int m)
; 3098 : {
; 3099 :    int L;
; 3100 :    switch (m) {
; 3101 :       case STBI__MARKER_none: // no marker found
; 3102 :          return stbi__err("expected marker","Corrupt JPEG");
; 3103 : 
; 3104 :       case 0xDD: // DRI - specify restart interval
; 3105 :          if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
; 3106 :          z->restart_interval = stbi__get16be(z->s);
; 3107 :          return 1;
; 3108 : 
; 3109 :       case 0xDB: // DQT - define quantization table
; 3110 :          L = stbi__get16be(z->s)-2;
; 3111 :          while (L > 0) {
; 3112 :             int q = stbi__get8(z->s);
; 3113 :             int p = q >> 4, sixteen = (p != 0);
; 3114 :             int t = q & 15,i;
; 3115 :             if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
; 3116 :             if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");
; 3117 : 
; 3118 :             for (i=0; i < 64; ++i)
; 3119 :                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
; 3120 :             L -= (sixteen ? 129 : 65);
; 3121 :          }
; 3122 :          return L==0;
; 3123 : 
; 3124 :       case 0xC4: // DHT - define huffman table
; 3125 :          L = stbi__get16be(z->s)-2;
; 3126 :          while (L > 0) {
; 3127 :             stbi_uc *v;
; 3128 :             int sizes[16],i,n=0;
; 3129 :             int q = stbi__get8(z->s);
; 3130 :             int tc = q >> 4;
; 3131 :             int th = q & 15;
; 3132 :             if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
; 3133 :             for (i=0; i < 16; ++i) {
; 3134 :                sizes[i] = stbi__get8(z->s);
; 3135 :                n += sizes[i];
; 3136 :             }
; 3137 :             if(n > 256) return stbi__err("bad DHT header","Corrupt JPEG"); // Loop over i < n would write past end of values!
; 3138 :             L -= 17;
; 3139 :             if (tc == 0) {
; 3140 :                if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
; 3141 :                v = z->huff_dc[th].values;
; 3142 :             } else {
; 3143 :                if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
; 3144 :                v = z->huff_ac[th].values;
; 3145 :             }
; 3146 :             for (i=0; i < n; ++i)
; 3147 :                v[i] = stbi__get8(z->s);
; 3148 :             if (tc != 0)
; 3149 :                stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
; 3150 :             L -= n;
; 3151 :          }
; 3152 :          return L==0;
; 3153 :    }
; 3154 : 
; 3155 :    // check for comment block or APP blocks
; 3156 :    if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
; 3157 :       L = stbi__get16be(z->s);
; 3158 :       if (L < 2) {
; 3159 :          if (m == 0xFE)
; 3160 :             return stbi__err("bad COM len","Corrupt JPEG");
; 3161 :          else
; 3162 :             return stbi__err("bad APP len","Corrupt JPEG");
; 3163 :       }
; 3164 :       L -= 2;
; 3165 : 
; 3166 :       if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
; 3167 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3168 :          int ok = 1;
; 3169 :          int i;
; 3170 :          for (i=0; i < 5; ++i)
; 3171 :             if (stbi__get8(z->s) != tag[i])
; 3172 :                ok = 0;
; 3173 :          L -= 5;
; 3174 :          if (ok)
; 3175 :             z->jfif = 1;
; 3176 :       } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;
; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)
; 3181 :             if (stbi__get8(z->s) != tag[i])
; 3182 :                ok = 0;
; 3183 :          L -= 6;
; 3184 :          if (ok) {
; 3185 :             stbi__get8(z->s); // version
; 3186 :             stbi__get16be(z->s); // flags0
; 3187 :             stbi__get16be(z->s); // flags1
; 3188 :             z->app14_color_transform = stbi__get8(z->s); // color transform
; 3189 :             L -= 6;
; 3190 :          }
; 3191 :       }
; 3192 : 
; 3193 :       stbi__skip(z->s, L);
; 3194 :       return 1;
; 3195 :    }
; 3196 : 
; 3197 :    return stbi__err("unknown marker","Corrupt JPEG");
; 3198 : }
; 3199 : 
; 3200 : // after we see SOS
; 3201 : static int stbi__process_scan_header(stbi__jpeg *z)
; 3202 : {
; 3203 :    int i;
; 3204 :    int Ls = stbi__get16be(z->s);
; 3205 :    z->scan_n = stbi__get8(z->s);
; 3206 :    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
; 3207 :    if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
; 3208 :    for (i=0; i < z->scan_n; ++i) {
; 3209 :       int id = stbi__get8(z->s), which;
; 3210 :       int q = stbi__get8(z->s);
; 3211 :       for (which = 0; which < z->s->img_n; ++which)
; 3212 :          if (z->img_comp[which].id == id)
; 3213 :             break;
; 3214 :       if (which == z->s->img_n) return 0; // no match
; 3215 :       z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
; 3216 :       z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
; 3217 :       z->order[i] = which;
; 3218 :    }
; 3219 : 
; 3220 :    {
; 3221 :       int aa;
; 3222 :       z->spec_start = stbi__get8(z->s);
; 3223 :       z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
; 3224 :       aa = stbi__get8(z->s);
; 3225 :       z->succ_high = (aa >> 4);
; 3226 :       z->succ_low  = (aa & 15);
; 3227 :       if (z->progressive) {
; 3228 :          if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
; 3229 :             return stbi__err("bad SOS", "Corrupt JPEG");
; 3230 :       } else {
; 3231 :          if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3232 :          if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3233 :          z->spec_end = 63;
; 3234 :       }
; 3235 :    }
; 3236 : 
; 3237 :    return 1;
; 3238 : }
; 3239 : 
; 3240 : static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
; 3241 : {
; 3242 :    int i;
; 3243 :    for (i=0; i < ncomp; ++i) {
; 3244 :       if (z->img_comp[i].raw_data) {
; 3245 :          STBI_FREE(z->img_comp[i].raw_data);
; 3246 :          z->img_comp[i].raw_data = NULL;
; 3247 :          z->img_comp[i].data = NULL;
; 3248 :       }
; 3249 :       if (z->img_comp[i].raw_coeff) {
; 3250 :          STBI_FREE(z->img_comp[i].raw_coeff);
; 3251 :          z->img_comp[i].raw_coeff = 0;
; 3252 :          z->img_comp[i].coeff = 0;
; 3253 :       }
; 3254 :       if (z->img_comp[i].linebuf) {
; 3255 :          STBI_FREE(z->img_comp[i].linebuf);
; 3256 :          z->img_comp[i].linebuf = NULL;
; 3257 :       }
; 3258 :    }
; 3259 :    return why;
; 3260 : }
; 3261 : 
; 3262 : static int stbi__process_frame_header(stbi__jpeg *z, int scan)
; 3263 : {
; 3264 :    stbi__context *s = z->s;
; 3265 :    int Lf,p,i,q, h_max=1,v_max=1,c;
; 3266 :    Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
; 3267 :    p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
; 3268 :    s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
; 3269 :    s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
; 3270 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 3271 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 3272 :    c = stbi__get8(s);
; 3273 :    if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");
; 3274 :    s->img_n = c;
; 3275 :    for (i=0; i < c; ++i) {
; 3276 :       z->img_comp[i].data = NULL;
; 3277 :       z->img_comp[i].linebuf = NULL;
; 3278 :    }
; 3279 : 
; 3280 :    if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");
; 3281 : 
; 3282 :    z->rgb = 0;
; 3283 :    for (i=0; i < s->img_n; ++i) {
; 3284 :       static const unsigned char rgb[3] = { 'R', 'G', 'B' };
; 3285 :       z->img_comp[i].id = stbi__get8(s);
; 3286 :       if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
; 3287 :          ++z->rgb;
; 3288 :       q = stbi__get8(s);
; 3289 :       z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
; 3290 :       z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
; 3291 :       z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
; 3292 :    }
; 3293 : 
; 3294 :    if (scan != STBI__SCAN_load) return 1;
; 3295 : 
; 3296 :    if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");
; 3297 : 
; 3298 :    for (i=0; i < s->img_n; ++i) {
; 3299 :       if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
; 3300 :       if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
; 3301 :    }
; 3302 : 
; 3303 :    // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
; 3304 :    // and I've never seen a non-corrupted JPEG file actually use them
; 3305 :    for (i=0; i < s->img_n; ++i) {
; 3306 :       if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");
; 3307 :       if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");
; 3308 :    }
; 3309 : 
; 3310 :    // compute interleaved mcu info
; 3311 :    z->img_h_max = h_max;
; 3312 :    z->img_v_max = v_max;
; 3313 :    z->img_mcu_w = h_max * 8;
; 3314 :    z->img_mcu_h = v_max * 8;
; 3315 :    // these sizes can't be more than 17 bits
; 3316 :    z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
; 3317 :    z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;
; 3318 : 
; 3319 :    for (i=0; i < s->img_n; ++i) {
; 3320 :       // number of effective pixels (e.g. for non-interleaved MCU)
; 3321 :       z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
; 3322 :       z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
; 3323 :       // to simplify generation, we'll allocate enough memory to decode
; 3324 :       // the bogus oversized data from using interleaved MCUs and their
; 3325 :       // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
; 3326 :       // discard the extra data until colorspace conversion
; 3327 :       //
; 3328 :       // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
; 3329 :       // so these muls can't overflow with 32-bit ints (which we require)
; 3330 :       z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
; 3331 :       z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
; 3332 :       z->img_comp[i].coeff = 0;
; 3333 :       z->img_comp[i].raw_coeff = 0;
; 3334 :       z->img_comp[i].linebuf = NULL;
; 3335 :       z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
; 3336 :       if (z->img_comp[i].raw_data == NULL)
; 3337 :          return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
; 3338 :       // align blocks for idct using mmx/sse
; 3339 :       z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
; 3340 :       if (z->progressive) {
; 3341 :          // w2, h2 are multiples of 8 (see above)
; 3342 :          z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
; 3343 :          z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
; 3344 :          z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
; 3345 :          if (z->img_comp[i].raw_coeff == NULL)
; 3346 :             return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
; 3347 :          z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
; 3348 :       }
; 3349 :    }
; 3350 : 
; 3351 :    return 1;
; 3352 : }
; 3353 : 
; 3354 : // use comparisons since in some cases we handle more than one case (e.g. SOF)
; 3355 : #define stbi__DNL(x)         ((x) == 0xdc)
; 3356 : #define stbi__SOI(x)         ((x) == 0xd8)
; 3357 : #define stbi__EOI(x)         ((x) == 0xd9)
; 3358 : #define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
; 3359 : #define stbi__SOS(x)         ((x) == 0xda)
; 3360 : 
; 3361 : #define stbi__SOF_progressive(x)   ((x) == 0xc2)
; 3362 : 
; 3363 : static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
; 3364 : {
; 3365 :    int m;
; 3366 :    z->jfif = 0;
; 3367 :    z->app14_color_transform = -1; // valid values are 0,1,2
; 3368 :    z->marker = STBI__MARKER_none; // initialize cached marker to empty
; 3369 :    m = stbi__get_marker(z);
; 3370 :    if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
; 3371 :    if (scan == STBI__SCAN_type) return 1;
; 3372 :    m = stbi__get_marker(z);
; 3373 :    while (!stbi__SOF(m)) {
; 3374 :       if (!stbi__process_marker(z,m)) return 0;
; 3375 :       m = stbi__get_marker(z);
; 3376 :       while (m == STBI__MARKER_none) {
; 3377 :          // some files have extra padding after their blocks, so ok, we'll scan
; 3378 :          if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
; 3379 :          m = stbi__get_marker(z);
; 3380 :       }
; 3381 :    }
; 3382 :    z->progressive = stbi__SOF_progressive(m);
; 3383 :    if (!stbi__process_frame_header(z, scan)) return 0;
; 3384 :    return 1;
; 3385 : }
; 3386 : 
; 3387 : static int stbi__skip_jpeg_junk_at_end(stbi__jpeg *j)
; 3388 : {
; 3389 :    // some JPEGs have junk at end, skip over it but if we find what looks
; 3390 :    // like a valid marker, resume there
; 3391 :    while (!stbi__at_eof(j->s)) {
; 3392 :       int x = stbi__get8(j->s);
; 3393 :       while (x == 255) { // might be a marker
; 3394 :          if (stbi__at_eof(j->s)) return STBI__MARKER_none;
; 3395 :          x = stbi__get8(j->s);
; 3396 :          if (x != 0x00 && x != 0xff) {
; 3397 :             // not a stuffed zero or lead-in to another marker, looks
; 3398 :             // like an actual marker, return it
; 3399 :             return x;
; 3400 :          }
; 3401 :          // stuffed zero has x=0 now which ends the loop, meaning we go
; 3402 :          // back to regular scan loop.
; 3403 :          // repeated 0xff keeps trying to read the next byte of the marker.
; 3404 :       }
; 3405 :    }
; 3406 :    return STBI__MARKER_none;
; 3407 : }
; 3408 : 
; 3409 : // decode image to YCbCr format
; 3410 : static int stbi__decode_jpeg_image(stbi__jpeg *j)
; 3411 : {
; 3412 :    int m;
; 3413 :    for (m = 0; m < 4; m++) {
; 3414 :       j->img_comp[m].raw_data = NULL;
; 3415 :       j->img_comp[m].raw_coeff = NULL;
; 3416 :    }
; 3417 :    j->restart_interval = 0;
; 3418 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
; 3419 :    m = stbi__get_marker(j);
; 3420 :    while (!stbi__EOI(m)) {
; 3421 :       if (stbi__SOS(m)) {
; 3422 :          if (!stbi__process_scan_header(j)) return 0;
; 3423 :          if (!stbi__parse_entropy_coded_data(j)) return 0;
; 3424 :          if (j->marker == STBI__MARKER_none ) {
; 3425 :          j->marker = stbi__skip_jpeg_junk_at_end(j);
; 3426 :             // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
; 3427 :          }
; 3428 :          m = stbi__get_marker(j);
; 3429 :          if (STBI__RESTART(m))
; 3430 :             m = stbi__get_marker(j);
; 3431 :       } else if (stbi__DNL(m)) {
; 3432 :          int Ld = stbi__get16be(j->s);
; 3433 :          stbi__uint32 NL = stbi__get16be(j->s);
; 3434 :          if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
; 3435 :          if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
; 3436 :          m = stbi__get_marker(j);
; 3437 :       } else {
; 3438 :          if (!stbi__process_marker(j, m)) return 1;
; 3439 :          m = stbi__get_marker(j);
; 3440 :       }
; 3441 :    }
; 3442 :    if (j->progressive)
; 3443 :       stbi__jpeg_finish(j);
; 3444 :    return 1;
; 3445 : }
; 3446 : 
; 3447 : // static jfif-centered resampling (across block boundaries)
; 3448 : 
; 3449 : typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
; 3450 :                                     int w, int hs);
; 3451 : 
; 3452 : #define stbi__div4(x) ((stbi_uc) ((x) >> 2))
; 3453 : 
; 3454 : static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3455 : {
; 3456 :    STBI_NOTUSED(out);
; 3457 :    STBI_NOTUSED(in_far);
; 3458 :    STBI_NOTUSED(w);
; 3459 :    STBI_NOTUSED(hs);
; 3460 :    return in_near;
; 3461 : }
; 3462 : 
; 3463 : static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3464 : {
; 3465 :    // need to generate two samples vertically for every one in input
; 3466 :    int i;
; 3467 :    STBI_NOTUSED(hs);
; 3468 :    for (i=0; i < w; ++i)
; 3469 :       out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
; 3470 :    return out;
; 3471 : }
; 3472 : 
; 3473 : static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3474 : {
; 3475 :    // need to generate two samples horizontally for every one in input
; 3476 :    int i;
; 3477 :    stbi_uc *input = in_near;
; 3478 : 
; 3479 :    if (w == 1) {
; 3480 :       // if only one sample, can't do any interpolation
; 3481 :       out[0] = out[1] = input[0];
; 3482 :       return out;
; 3483 :    }
; 3484 : 
; 3485 :    out[0] = input[0];
; 3486 :    out[1] = stbi__div4(input[0]*3 + input[1] + 2);
; 3487 :    for (i=1; i < w-1; ++i) {
; 3488 :       int n = 3*input[i]+2;
; 3489 :       out[i*2+0] = stbi__div4(n+input[i-1]);
; 3490 :       out[i*2+1] = stbi__div4(n+input[i+1]);
; 3491 :    }
; 3492 :    out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
; 3493 :    out[i*2+1] = input[w-1];
; 3494 : 
; 3495 :    STBI_NOTUSED(in_far);
; 3496 :    STBI_NOTUSED(hs);
; 3497 : 
; 3498 :    return out;
; 3499 : }
; 3500 : 
; 3501 : #define stbi__div16(x) ((stbi_uc) ((x) >> 4))
; 3502 : 
; 3503 : static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3504 : {
; 3505 :    // need to generate 2x2 samples for every one in input
; 3506 :    int i,t0,t1;
; 3507 :    if (w == 1) {
; 3508 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
; 3509 :       return out;
; 3510 :    }
; 3511 : 
; 3512 :    t1 = 3*in_near[0] + in_far[0];
; 3513 :    out[0] = stbi__div4(t1+2);
; 3514 :    for (i=1; i < w; ++i) {
; 3515 :       t0 = t1;
; 3516 :       t1 = 3*in_near[i]+in_far[i];
; 3517 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
; 3518 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
; 3519 :    }
; 3520 :    out[w*2-1] = stbi__div4(t1+2);
; 3521 : 
; 3522 :    STBI_NOTUSED(hs);
; 3523 : 
; 3524 :    return out;
; 3525 : }
; 3526 : 
; 3527 : #if defined(STBI_SSE2) || defined(STBI_NEON)
; 3528 : static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3529 : {
; 3530 :    // need to generate 2x2 samples for every one in input
; 3531 :    int i=0,t0,t1;
; 3532 : 
; 3533 :    if (w == 1) {
; 3534 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
; 3535 :       return out;
; 3536 :    }
; 3537 : 
; 3538 :    t1 = 3*in_near[0] + in_far[0];
; 3539 :    // process groups of 8 pixels for as long as we can.
; 3540 :    // note we can't handle the last pixel in a row in this loop
; 3541 :    // because we need to handle the filter boundary conditions.
; 3542 :    for (; i < ((w-1) & ~7); i += 8) {
; 3543 : #if defined(STBI_SSE2)
; 3544 :       // load and perform the vertical filtering pass
; 3545 :       // this uses 3*x + y = 4*x + (y - x)
; 3546 :       __m128i zero  = _mm_setzero_si128();
; 3547 :       __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
; 3548 :       __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
; 3549 :       __m128i farw  = _mm_unpacklo_epi8(farb, zero);
; 3550 :       __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
; 3551 :       __m128i diff  = _mm_sub_epi16(farw, nearw);
; 3552 :       __m128i nears = _mm_slli_epi16(nearw, 2);
; 3553 :       __m128i curr  = _mm_add_epi16(nears, diff); // current row
; 3554 : 
; 3555 :       // horizontal filter works the same based on shifted vers of current
; 3556 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3557 :       // insert the previous pixel value (from t1).
; 3558 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3559 :       // of next block of 8 pixels added in.
; 3560 :       __m128i prv0 = _mm_slli_si128(curr, 2);
; 3561 :       __m128i nxt0 = _mm_srli_si128(curr, 2);
; 3562 :       __m128i prev = _mm_insert_epi16(prv0, t1, 0);
; 3563 :       __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);
; 3564 : 
; 3565 :       // horizontal filter, polyphase implementation since it's convenient:
; 3566 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3567 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3568 :       // note the shared term.
; 3569 :       __m128i bias  = _mm_set1_epi16(8);
; 3570 :       __m128i curs = _mm_slli_epi16(curr, 2);
; 3571 :       __m128i prvd = _mm_sub_epi16(prev, curr);
; 3572 :       __m128i nxtd = _mm_sub_epi16(next, curr);
; 3573 :       __m128i curb = _mm_add_epi16(curs, bias);
; 3574 :       __m128i even = _mm_add_epi16(prvd, curb);
; 3575 :       __m128i odd  = _mm_add_epi16(nxtd, curb);
; 3576 : 
; 3577 :       // interleave even and odd pixels, then undo scaling.
; 3578 :       __m128i int0 = _mm_unpacklo_epi16(even, odd);
; 3579 :       __m128i int1 = _mm_unpackhi_epi16(even, odd);
; 3580 :       __m128i de0  = _mm_srli_epi16(int0, 4);
; 3581 :       __m128i de1  = _mm_srli_epi16(int1, 4);
; 3582 : 
; 3583 :       // pack and write output
; 3584 :       __m128i outv = _mm_packus_epi16(de0, de1);
; 3585 :       _mm_storeu_si128((__m128i *) (out + i*2), outv);
; 3586 : #elif defined(STBI_NEON)
; 3587 :       // load and perform the vertical filtering pass
; 3588 :       // this uses 3*x + y = 4*x + (y - x)
; 3589 :       uint8x8_t farb  = vld1_u8(in_far + i);
; 3590 :       uint8x8_t nearb = vld1_u8(in_near + i);
; 3591 :       int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
; 3592 :       int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
; 3593 :       int16x8_t curr  = vaddq_s16(nears, diff); // current row
; 3594 : 
; 3595 :       // horizontal filter works the same based on shifted vers of current
; 3596 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3597 :       // insert the previous pixel value (from t1).
; 3598 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3599 :       // of next block of 8 pixels added in.
; 3600 :       int16x8_t prv0 = vextq_s16(curr, curr, 7);
; 3601 :       int16x8_t nxt0 = vextq_s16(curr, curr, 1);
; 3602 :       int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
; 3603 :       int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);
; 3604 : 
; 3605 :       // horizontal filter, polyphase implementation since it's convenient:
; 3606 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3607 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3608 :       // note the shared term.
; 3609 :       int16x8_t curs = vshlq_n_s16(curr, 2);
; 3610 :       int16x8_t prvd = vsubq_s16(prev, curr);
; 3611 :       int16x8_t nxtd = vsubq_s16(next, curr);
; 3612 :       int16x8_t even = vaddq_s16(curs, prvd);
; 3613 :       int16x8_t odd  = vaddq_s16(curs, nxtd);
; 3614 : 
; 3615 :       // undo scaling and round, then store with even/odd phases interleaved
; 3616 :       uint8x8x2_t o;
; 3617 :       o.val[0] = vqrshrun_n_s16(even, 4);
; 3618 :       o.val[1] = vqrshrun_n_s16(odd,  4);
; 3619 :       vst2_u8(out + i*2, o);
; 3620 : #endif
; 3621 : 
; 3622 :       // "previous" value for next iter
; 3623 :       t1 = 3*in_near[i+7] + in_far[i+7];
; 3624 :    }
; 3625 : 
; 3626 :    t0 = t1;
; 3627 :    t1 = 3*in_near[i] + in_far[i];
; 3628 :    out[i*2] = stbi__div16(3*t1 + t0 + 8);
; 3629 : 
; 3630 :    for (++i; i < w; ++i) {
; 3631 :       t0 = t1;
; 3632 :       t1 = 3*in_near[i]+in_far[i];
; 3633 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
; 3634 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
; 3635 :    }
; 3636 :    out[w*2-1] = stbi__div4(t1+2);
; 3637 : 
; 3638 :    STBI_NOTUSED(hs);
; 3639 : 
; 3640 :    return out;
; 3641 : }
; 3642 : #endif
; 3643 : 
; 3644 : static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3645 : {
; 3646 :    // resample with nearest-neighbor
; 3647 :    int i,j;
; 3648 :    STBI_NOTUSED(in_far);
; 3649 :    for (i=0; i < w; ++i)
; 3650 :       for (j=0; j < hs; ++j)
; 3651 :          out[i*hs+j] = in_near[i];
; 3652 :    return out;
; 3653 : }
; 3654 : 
; 3655 : // this is a reduced-precision calculation of YCbCr-to-RGB introduced
; 3656 : // to make sure the code produces the same results in both SIMD and scalar
; 3657 : #define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
; 3658 : static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
; 3659 : {
; 3660 :    int i;
; 3661 :    for (i=0; i < count; ++i) {
; 3662 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding
; 3663 :       int r,g,b;
; 3664 :       int cr = pcr[i] - 128;
; 3665 :       int cb = pcb[i] - 128;
; 3666 :       r = y_fixed +  cr* stbi__float2fixed(1.40200f);
; 3667 :       g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
; 3668 :       b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
; 3669 :       r >>= 20;
; 3670 :       g >>= 20;
; 3671 :       b >>= 20;
; 3672 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
; 3673 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
; 3674 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
; 3675 :       out[0] = (stbi_uc)r;
; 3676 :       out[1] = (stbi_uc)g;
; 3677 :       out[2] = (stbi_uc)b;
; 3678 :       out[3] = 255;
; 3679 :       out += step;
; 3680 :    }
; 3681 : }
; 3682 : 
; 3683 : #if defined(STBI_SSE2) || defined(STBI_NEON)
; 3684 : static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
; 3685 : {
; 3686 :    int i = 0;
; 3687 : 
; 3688 : #ifdef STBI_SSE2
; 3689 :    // step == 3 is pretty ugly on the final interleave, and i'm not convinced
; 3690 :    // it's useful in practice (you wouldn't use it for textures, for example).
; 3691 :    // so just accelerate step == 4 case.
; 3692 :    if (step == 4) {
; 3693 :       // this is a fairly straightforward implementation and not super-optimized.
; 3694 :       __m128i signflip  = _mm_set1_epi8(-0x80);
; 3695 :       __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3696 :       __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3697 :       __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3698 :       __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3699 :       __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
; 3700 :       __m128i xw = _mm_set1_epi16(255); // alpha channel
; 3701 : 
; 3702 :       for (; i+7 < count; i += 8) {
; 3703 :          // load
; 3704 :          __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
; 3705 :          __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
; 3706 :          __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
; 3707 :          __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
; 3708 :          __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128
; 3709 : 
; 3710 :          // unpack to short (and left-shift cr, cb by 8)
; 3711 :          __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
; 3712 :          __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
; 3713 :          __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);
; 3714 : 
; 3715 :          // color transform
; 3716 :          __m128i yws = _mm_srli_epi16(yw, 4);
; 3717 :          __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
; 3718 :          __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
; 3719 :          __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
; 3720 :          __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
; 3721 :          __m128i rws = _mm_add_epi16(cr0, yws);
; 3722 :          __m128i gwt = _mm_add_epi16(cb0, yws);
; 3723 :          __m128i bws = _mm_add_epi16(yws, cb1);
; 3724 :          __m128i gws = _mm_add_epi16(gwt, cr1);
; 3725 : 
; 3726 :          // descale
; 3727 :          __m128i rw = _mm_srai_epi16(rws, 4);
; 3728 :          __m128i bw = _mm_srai_epi16(bws, 4);
; 3729 :          __m128i gw = _mm_srai_epi16(gws, 4);
; 3730 : 
; 3731 :          // back to byte, set up for transpose
; 3732 :          __m128i brb = _mm_packus_epi16(rw, bw);
; 3733 :          __m128i gxb = _mm_packus_epi16(gw, xw);
; 3734 : 
; 3735 :          // transpose to interleave channels
; 3736 :          __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
; 3737 :          __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
; 3738 :          __m128i o0 = _mm_unpacklo_epi16(t0, t1);
; 3739 :          __m128i o1 = _mm_unpackhi_epi16(t0, t1);
; 3740 : 
; 3741 :          // store
; 3742 :          _mm_storeu_si128((__m128i *) (out + 0), o0);
; 3743 :          _mm_storeu_si128((__m128i *) (out + 16), o1);
; 3744 :          out += 32;
; 3745 :       }
; 3746 :    }
; 3747 : #endif
; 3748 : 
; 3749 : #ifdef STBI_NEON
; 3750 :    // in this version, step=3 support would be easy to add. but is there demand?
; 3751 :    if (step == 4) {
; 3752 :       // this is a fairly straightforward implementation and not super-optimized.
; 3753 :       uint8x8_t signflip = vdup_n_u8(0x80);
; 3754 :       int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3755 :       int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3756 :       int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3757 :       int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3758 : 
; 3759 :       for (; i+7 < count; i += 8) {
; 3760 :          // load
; 3761 :          uint8x8_t y_bytes  = vld1_u8(y + i);
; 3762 :          uint8x8_t cr_bytes = vld1_u8(pcr + i);
; 3763 :          uint8x8_t cb_bytes = vld1_u8(pcb + i);
; 3764 :          int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
; 3765 :          int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
; 3766 : 
; 3767 :          // expand to s16
; 3768 :          int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
; 3769 :          int16x8_t crw = vshll_n_s8(cr_biased, 7);
; 3770 :          int16x8_t cbw = vshll_n_s8(cb_biased, 7);
; 3771 : 
; 3772 :          // color transform
; 3773 :          int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
; 3774 :          int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
; 3775 :          int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
; 3776 :          int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
; 3777 :          int16x8_t rws = vaddq_s16(yws, cr0);
; 3778 :          int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
; 3779 :          int16x8_t bws = vaddq_s16(yws, cb1);
; 3780 : 
; 3781 :          // undo scaling, round, convert to byte
; 3782 :          uint8x8x4_t o;
; 3783 :          o.val[0] = vqrshrun_n_s16(rws, 4);
; 3784 :          o.val[1] = vqrshrun_n_s16(gws, 4);
; 3785 :          o.val[2] = vqrshrun_n_s16(bws, 4);
; 3786 :          o.val[3] = vdup_n_u8(255);
; 3787 : 
; 3788 :          // store, interleaving r/g/b/a
; 3789 :          vst4_u8(out, o);
; 3790 :          out += 8*4;
; 3791 :       }
; 3792 :    }
; 3793 : #endif
; 3794 : 
; 3795 :    for (; i < count; ++i) {
; 3796 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding
; 3797 :       int r,g,b;
; 3798 :       int cr = pcr[i] - 128;
; 3799 :       int cb = pcb[i] - 128;
; 3800 :       r = y_fixed + cr* stbi__float2fixed(1.40200f);
; 3801 :       g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
; 3802 :       b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
; 3803 :       r >>= 20;
; 3804 :       g >>= 20;
; 3805 :       b >>= 20;
; 3806 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
; 3807 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
; 3808 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
; 3809 :       out[0] = (stbi_uc)r;
; 3810 :       out[1] = (stbi_uc)g;
; 3811 :       out[2] = (stbi_uc)b;
; 3812 :       out[3] = 255;
; 3813 :       out += step;
; 3814 :    }
; 3815 : }
; 3816 : #endif
; 3817 : 
; 3818 : // set up the kernels
; 3819 : static void stbi__setup_jpeg(stbi__jpeg *j)
; 3820 : {
; 3821 :    j->idct_block_kernel = stbi__idct_block;
; 3822 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
; 3823 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;
; 3824 : 
; 3825 : #ifdef STBI_SSE2
; 3826 :    if (stbi__sse2_available()) {
; 3827 :       j->idct_block_kernel = stbi__idct_simd;
; 3828 :       j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3829 :       j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3830 :    }
; 3831 : #endif
; 3832 : 
; 3833 : #ifdef STBI_NEON
; 3834 :    j->idct_block_kernel = stbi__idct_simd;
; 3835 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3836 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3837 : #endif
; 3838 : }
; 3839 : 
; 3840 : // clean up the temporary component buffers
; 3841 : static void stbi__cleanup_jpeg(stbi__jpeg *j)
; 3842 : {
; 3843 :    stbi__free_jpeg_components(j, j->s->img_n, 0);
; 3844 : }
; 3845 : 
; 3846 : typedef struct
; 3847 : {
; 3848 :    resample_row_func resample;
; 3849 :    stbi_uc *line0,*line1;
; 3850 :    int hs,vs;   // expansion factor in each axis
; 3851 :    int w_lores; // horizontal pixels pre-expansion
; 3852 :    int ystep;   // how far through vertical expansion we are
; 3853 :    int ypos;    // which pre-expansion row we're on
; 3854 : } stbi__resample;
; 3855 : 
; 3856 : // fast 0..255 * 0..255 => 0..255 rounded multiplication
; 3857 : static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
; 3858 : {
; 3859 :    unsigned int t = x*y + 128;
; 3860 :    return (stbi_uc) ((t + (t >>8)) >> 8);
; 3861 : }
; 3862 : 
; 3863 : static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
; 3864 : {
; 3865 :    int n, decode_n, is_rgb;
; 3866 :    z->s->img_n = 0; // make stbi__cleanup_jpeg safe
; 3867 : 
; 3868 :    // validate req_comp
; 3869 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
; 3870 : 
; 3871 :    // load a jpeg image from whichever source, but leave in YCbCr format
; 3872 :    if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }
; 3873 : 
; 3874 :    // determine actual number of components to generate
; 3875 :    n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;
; 3876 : 
; 3877 :    is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));
; 3878 : 
; 3879 :    if (z->s->img_n == 3 && n < 3 && !is_rgb)
; 3880 :       decode_n = 1;
; 3881 :    else
; 3882 :       decode_n = z->s->img_n;
; 3883 : 
; 3884 :    // nothing to do if no components requested; check this now to avoid
; 3885 :    // accessing uninitialized coutput[0] later
; 3886 :    if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }
; 3887 : 
; 3888 :    // resample and color-convert
; 3889 :    {
; 3890 :       int k;
; 3891 :       unsigned int i,j;
; 3892 :       stbi_uc *output;
; 3893 :       stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };
; 3894 : 
; 3895 :       stbi__resample res_comp[4];
; 3896 : 
; 3897 :       for (k=0; k < decode_n; ++k) {
; 3898 :          stbi__resample *r = &res_comp[k];
; 3899 : 
; 3900 :          // allocate line buffer big enough for upsampling off the edges
; 3901 :          // with upsample factor of 4
; 3902 :          z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
; 3903 :          if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
; 3904 : 
; 3905 :          r->hs      = z->img_h_max / z->img_comp[k].h;
; 3906 :          r->vs      = z->img_v_max / z->img_comp[k].v;
; 3907 :          r->ystep   = r->vs >> 1;
; 3908 :          r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
; 3909 :          r->ypos    = 0;
; 3910 :          r->line0   = r->line1 = z->img_comp[k].data;
; 3911 : 
; 3912 :          if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
; 3913 :          else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
; 3914 :          else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
; 3915 :          else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
; 3916 :          else                               r->resample = stbi__resample_row_generic;
; 3917 :       }
; 3918 : 
; 3919 :       // can't error after this so, this is safe
; 3920 :       output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
; 3921 :       if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
; 3922 : 
; 3923 :       // now go ahead and resample
; 3924 :       for (j=0; j < z->s->img_y; ++j) {
; 3925 :          stbi_uc *out = output + n * z->s->img_x * j;
; 3926 :          for (k=0; k < decode_n; ++k) {
; 3927 :             stbi__resample *r = &res_comp[k];
; 3928 :             int y_bot = r->ystep >= (r->vs >> 1);
; 3929 :             coutput[k] = r->resample(z->img_comp[k].linebuf,
; 3930 :                                      y_bot ? r->line1 : r->line0,
; 3931 :                                      y_bot ? r->line0 : r->line1,
; 3932 :                                      r->w_lores, r->hs);
; 3933 :             if (++r->ystep >= r->vs) {
; 3934 :                r->ystep = 0;
; 3935 :                r->line0 = r->line1;
; 3936 :                if (++r->ypos < z->img_comp[k].y)
; 3937 :                   r->line1 += z->img_comp[k].w2;
; 3938 :             }
; 3939 :          }
; 3940 :          if (n >= 3) {
; 3941 :             stbi_uc *y = coutput[0];
; 3942 :             if (z->s->img_n == 3) {
; 3943 :                if (is_rgb) {
; 3944 :                   for (i=0; i < z->s->img_x; ++i) {
; 3945 :                      out[0] = y[i];
; 3946 :                      out[1] = coutput[1][i];
; 3947 :                      out[2] = coutput[2][i];
; 3948 :                      out[3] = 255;
; 3949 :                      out += n;
; 3950 :                   }
; 3951 :                } else {
; 3952 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3953 :                }
; 3954 :             } else if (z->s->img_n == 4) {
; 3955 :                if (z->app14_color_transform == 0) { // CMYK
; 3956 :                   for (i=0; i < z->s->img_x; ++i) {
; 3957 :                      stbi_uc m = coutput[3][i];
; 3958 :                      out[0] = stbi__blinn_8x8(coutput[0][i], m);
; 3959 :                      out[1] = stbi__blinn_8x8(coutput[1][i], m);
; 3960 :                      out[2] = stbi__blinn_8x8(coutput[2][i], m);
; 3961 :                      out[3] = 255;
; 3962 :                      out += n;
; 3963 :                   }
; 3964 :                } else if (z->app14_color_transform == 2) { // YCCK
; 3965 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3966 :                   for (i=0; i < z->s->img_x; ++i) {
; 3967 :                      stbi_uc m = coutput[3][i];
; 3968 :                      out[0] = stbi__blinn_8x8(255 - out[0], m);
; 3969 :                      out[1] = stbi__blinn_8x8(255 - out[1], m);
; 3970 :                      out[2] = stbi__blinn_8x8(255 - out[2], m);
; 3971 :                      out += n;
; 3972 :                   }
; 3973 :                } else { // YCbCr + alpha?  Ignore the fourth channel for now
; 3974 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3975 :                }
; 3976 :             } else
; 3977 :                for (i=0; i < z->s->img_x; ++i) {
; 3978 :                   out[0] = out[1] = out[2] = y[i];
; 3979 :                   out[3] = 255; // not used if n==3
; 3980 :                   out += n;
; 3981 :                }
; 3982 :          } else {
; 3983 :             if (is_rgb) {
; 3984 :                if (n == 1)
; 3985 :                   for (i=0; i < z->s->img_x; ++i)
; 3986 :                      *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
; 3987 :                else {
; 3988 :                   for (i=0; i < z->s->img_x; ++i, out += 2) {
; 3989 :                      out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
; 3990 :                      out[1] = 255;
; 3991 :                   }
; 3992 :                }
; 3993 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
; 3994 :                for (i=0; i < z->s->img_x; ++i) {
; 3995 :                   stbi_uc m = coutput[3][i];
; 3996 :                   stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
; 3997 :                   stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
; 3998 :                   stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
; 3999 :                   out[0] = stbi__compute_y(r, g, b);
; 4000 :                   out[1] = 255;
; 4001 :                   out += n;
; 4002 :                }
; 4003 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
; 4004 :                for (i=0; i < z->s->img_x; ++i) {
; 4005 :                   out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
; 4006 :                   out[1] = 255;
; 4007 :                   out += n;
; 4008 :                }
; 4009 :             } else {
; 4010 :                stbi_uc *y = coutput[0];
; 4011 :                if (n == 1)
; 4012 :                   for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
; 4013 :                else
; 4014 :                   for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
; 4015 :             }
; 4016 :          }
; 4017 :       }
; 4018 :       stbi__cleanup_jpeg(z);
; 4019 :       *out_x = z->s->img_x;
; 4020 :       *out_y = z->s->img_y;
; 4021 :       if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
; 4022 :       return output;
; 4023 :    }
; 4024 : }
; 4025 : 
; 4026 : static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 4027 : {
; 4028 :    unsigned char* result;
; 4029 :    stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
; 4030 :    if (!j) return stbi__errpuc("outofmem", "Out of memory");
; 4031 :    memset(j, 0, sizeof(stbi__jpeg));
; 4032 :    STBI_NOTUSED(ri);
; 4033 :    j->s = s;
; 4034 :    stbi__setup_jpeg(j);
; 4035 :    result = load_jpeg_image(j, x,y,comp,req_comp);
; 4036 :    STBI_FREE(j);
; 4037 :    return result;
; 4038 : }
; 4039 : 
; 4040 : static int stbi__jpeg_test(stbi__context *s)
; 4041 : {
; 4042 :    int r;
; 4043 :    stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
; 4044 :    if (!j) return stbi__err("outofmem", "Out of memory");
; 4045 :    memset(j, 0, sizeof(stbi__jpeg));
; 4046 :    j->s = s;
; 4047 :    stbi__setup_jpeg(j);
; 4048 :    r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
; 4049 :    stbi__rewind(s);
; 4050 :    STBI_FREE(j);
; 4051 :    return r;
; 4052 : }
; 4053 : 
; 4054 : static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
; 4055 : {
; 4056 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
; 4057 :       stbi__rewind( j->s );
; 4058 :       return 0;
; 4059 :    }
; 4060 :    if (x) *x = j->s->img_x;
; 4061 :    if (y) *y = j->s->img_y;
; 4062 :    if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
; 4063 :    return 1;
; 4064 : }
; 4065 : 
; 4066 : static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
; 4067 : {
; 4068 :    int result;
; 4069 :    stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
; 4070 :    if (!j) return stbi__err("outofmem", "Out of memory");
; 4071 :    memset(j, 0, sizeof(stbi__jpeg));
; 4072 :    j->s = s;
; 4073 :    result = stbi__jpeg_info_raw(j, x, y, comp);
; 4074 :    STBI_FREE(j);
; 4075 :    return result;
; 4076 : }
; 4077 : #endif
; 4078 : 
; 4079 : // public domain zlib decode    v0.2  Sean Barrett 2006-11-18
; 4080 : //    simple implementation
; 4081 : //      - all input must be provided in an upfront buffer
; 4082 : //      - all output is written to a single output buffer (can malloc/realloc)
; 4083 : //    performance
; 4084 : //      - fast huffman
; 4085 : 
; 4086 : #ifndef STBI_NO_ZLIB
; 4087 : 
; 4088 : // fast-way is faster to check than jpeg huffman, but slow way is slower
; 4089 : #define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
; 4090 : #define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
; 4091 : #define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet
; 4092 : 
; 4093 : // zlib-style huffman encoding
; 4094 : // (jpegs packs from left, zlib from right, so can't share code)
; 4095 : typedef struct
; 4096 : {
; 4097 :    stbi__uint16 fast[1 << STBI__ZFAST_BITS];
; 4098 :    stbi__uint16 firstcode[16];
; 4099 :    int maxcode[17];
; 4100 :    stbi__uint16 firstsymbol[16];
; 4101 :    stbi_uc  size[STBI__ZNSYMS];
; 4102 :    stbi__uint16 value[STBI__ZNSYMS];
; 4103 : } stbi__zhuffman;
; 4104 : 
; 4105 : stbi_inline static int stbi__bitreverse16(int n)
; 4106 : {
; 4107 :   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
; 4108 :   n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
; 4109 :   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
; 4110 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
; 4111 :   return n;
; 4112 : }
; 4113 : 
; 4114 : stbi_inline static int stbi__bit_reverse(int v, int bits)
; 4115 : {
; 4116 :    STBI_ASSERT(bits <= 16);
; 4117 :    // to bit reverse n bits, reverse 16 and shift
; 4118 :    // e.g. 11 bits, bit reverse and shift away 5
; 4119 :    return stbi__bitreverse16(v) >> (16-bits);
; 4120 : }
; 4121 : 
; 4122 : static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
; 4123 : {
; 4124 :    int i,k=0;
; 4125 :    int code, next_code[16], sizes[17];
; 4126 : 
; 4127 :    // DEFLATE spec for generating codes
; 4128 :    memset(sizes, 0, sizeof(sizes));
; 4129 :    memset(z->fast, 0, sizeof(z->fast));
; 4130 :    for (i=0; i < num; ++i)
; 4131 :       ++sizes[sizelist[i]];
; 4132 :    sizes[0] = 0;
; 4133 :    for (i=1; i < 16; ++i)
; 4134 :       if (sizes[i] > (1 << i))
; 4135 :          return stbi__err("bad sizes", "Corrupt PNG");
; 4136 :    code = 0;
; 4137 :    for (i=1; i < 16; ++i) {
; 4138 :       next_code[i] = code;
; 4139 :       z->firstcode[i] = (stbi__uint16) code;
; 4140 :       z->firstsymbol[i] = (stbi__uint16) k;
; 4141 :       code = (code + sizes[i]);
; 4142 :       if (sizes[i])
; 4143 :          if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
; 4144 :       z->maxcode[i] = code << (16-i); // preshift for inner loop
; 4145 :       code <<= 1;
; 4146 :       k += sizes[i];
; 4147 :    }
; 4148 :    z->maxcode[16] = 0x10000; // sentinel
; 4149 :    for (i=0; i < num; ++i) {
; 4150 :       int s = sizelist[i];
; 4151 :       if (s) {
; 4152 :          int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
; 4153 :          stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
; 4154 :          z->size [c] = (stbi_uc     ) s;
; 4155 :          z->value[c] = (stbi__uint16) i;
; 4156 :          if (s <= STBI__ZFAST_BITS) {
; 4157 :             int j = stbi__bit_reverse(next_code[s],s);
; 4158 :             while (j < (1 << STBI__ZFAST_BITS)) {
; 4159 :                z->fast[j] = fastv;
; 4160 :                j += (1 << s);
; 4161 :             }
; 4162 :          }
; 4163 :          ++next_code[s];
; 4164 :       }
; 4165 :    }
; 4166 :    return 1;
; 4167 : }
; 4168 : 
; 4169 : // zlib-from-memory implementation for PNG reading
; 4170 : //    because PNG allows splitting the zlib stream arbitrarily,
; 4171 : //    and it's annoying structurally to have PNG call ZLIB call PNG,
; 4172 : //    we require PNG read all the IDATs and combine them into a single
; 4173 : //    memory buffer
; 4174 : 
; 4175 : typedef struct
; 4176 : {
; 4177 :    stbi_uc *zbuffer, *zbuffer_end;
; 4178 :    int num_bits;
; 4179 :    stbi__uint32 code_buffer;
; 4180 : 
; 4181 :    char *zout;
; 4182 :    char *zout_start;
; 4183 :    char *zout_end;
; 4184 :    int   z_expandable;
; 4185 : 
; 4186 :    stbi__zhuffman z_length, z_distance;
; 4187 : } stbi__zbuf;
; 4188 : 
; 4189 : stbi_inline static int stbi__zeof(stbi__zbuf *z)
; 4190 : {
; 4191 :    return (z->zbuffer >= z->zbuffer_end);
; 4192 : }
; 4193 : 
; 4194 : stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
; 4195 : {
; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;
; 4197 : }
; 4198 : 
; 4199 : static void stbi__fill_bits(stbi__zbuf *z)
; 4200 : {
; 4201 :    do {
; 4202 :       if (z->code_buffer >= (1U << z->num_bits)) {
; 4203 :         z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
; 4204 :         return;
; 4205 :       }
; 4206 :       z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
; 4207 :       z->num_bits += 8;
; 4208 :    } while (z->num_bits <= 24);
; 4209 : }
; 4210 : 
; 4211 : stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
; 4212 : {
; 4213 :    unsigned int k;
; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);
; 4215 :    k = z->code_buffer & ((1 << n) - 1);
; 4216 :    z->code_buffer >>= n;
; 4217 :    z->num_bits -= n;
; 4218 :    return k;
; 4219 : }
; 4220 : 
; 4221 : static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
; 4222 : {
; 4223 :    int b,s,k;
; 4224 :    // not resolved by fast table, so compute it the slow way
; 4225 :    // use jpeg approach, which requires MSbits at top
; 4226 :    k = stbi__bit_reverse(a->code_buffer, 16);
; 4227 :    for (s=STBI__ZFAST_BITS+1; ; ++s)
; 4228 :       if (k < z->maxcode[s])
; 4229 :          break;
; 4230 :    if (s >= 16) return -1; // invalid code!
; 4231 :    // code size is s, so:
; 4232 :    b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
; 4233 :    if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
; 4234 :    if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
; 4235 :    a->code_buffer >>= s;
; 4236 :    a->num_bits -= s;
; 4237 :    return z->value[b];
; 4238 : }
; 4239 : 
; 4240 : stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
; 4241 : {
; 4242 :    int b,s;
; 4243 :    if (a->num_bits < 16) {
; 4244 :       if (stbi__zeof(a)) {
; 4245 :          return -1;   /* report error for unexpected end of data. */
; 4246 :       }
; 4247 :       stbi__fill_bits(a);
; 4248 :    }
; 4249 :    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
; 4250 :    if (b) {
; 4251 :       s = b >> 9;
; 4252 :       a->code_buffer >>= s;
; 4253 :       a->num_bits -= s;
; 4254 :       return b & 511;
; 4255 :    }
; 4256 :    return stbi__zhuffman_decode_slowpath(a, z);
; 4257 : }
; 4258 : 
; 4259 : static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
; 4260 : {
; 4261 :    char *q;
; 4262 :    unsigned int cur, limit, old_limit;
; 4263 :    z->zout = zout;
; 4264 :    if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
; 4265 :    cur   = (unsigned int) (z->zout - z->zout_start);
; 4266 :    limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
; 4267 :    if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");
; 4268 :    while (cur + n > limit) {
; 4269 :       if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");
; 4270 :       limit *= 2;
; 4271 :    }
; 4272 :    q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
; 4273 :    STBI_NOTUSED(old_limit);
; 4274 :    if (q == NULL) return stbi__err("outofmem", "Out of memory");
; 4275 :    z->zout_start = q;
; 4276 :    z->zout       = q + cur;
; 4277 :    z->zout_end   = q + limit;
; 4278 :    return 1;
; 4279 : }
; 4280 : 
; 4281 : static const int stbi__zlength_base[31] = {
; 4282 :    3,4,5,6,7,8,9,10,11,13,
; 4283 :    15,17,19,23,27,31,35,43,51,59,
; 4284 :    67,83,99,115,131,163,195,227,258,0,0 };
; 4285 : 
; 4286 : static const int stbi__zlength_extra[31]=
; 4287 : { 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };
; 4288 : 
; 4289 : static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
; 4290 : 257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};
; 4291 : 
; 4292 : static const int stbi__zdist_extra[32] =
; 4293 : { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
; 4294 : 
; 4295 : static int stbi__parse_huffman_block(stbi__zbuf *a)
; 4296 : {
; 4297 :    char *zout = a->zout;
; 4298 :    for(;;) {
; 4299 :       int z = stbi__zhuffman_decode(a, &a->z_length);
; 4300 :       if (z < 256) {
; 4301 :          if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
; 4302 :          if (zout >= a->zout_end) {
; 4303 :             if (!stbi__zexpand(a, zout, 1)) return 0;
; 4304 :             zout = a->zout;
; 4305 :          }
; 4306 :          *zout++ = (char) z;
; 4307 :       } else {
; 4308 :          stbi_uc *p;
; 4309 :          int len,dist;
; 4310 :          if (z == 256) {
; 4311 :             a->zout = zout;
; 4312 :             return 1;
; 4313 :          }
; 4314 :          if (z >= 286) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, length codes 286 and 287 must not appear in compressed data
; 4315 :          z -= 257;
; 4316 :          len = stbi__zlength_base[z];
; 4317 :          if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
; 4318 :          z = stbi__zhuffman_decode(a, &a->z_distance);
; 4319 :          if (z < 0 || z >= 30) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data
; 4320 :          dist = stbi__zdist_base[z];
; 4321 :          if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
; 4322 :          if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
; 4323 :          if (zout + len > a->zout_end) {
; 4324 :             if (!stbi__zexpand(a, zout, len)) return 0;
; 4325 :             zout = a->zout;
; 4326 :          }
; 4327 :          p = (stbi_uc *) (zout - dist);
; 4328 :          if (dist == 1) { // run of one byte; common in images.
; 4329 :             stbi_uc v = *p;
; 4330 :             if (len) { do *zout++ = v; while (--len); }
; 4331 :          } else {
; 4332 :             if (len) { do *zout++ = *p++; while (--len); }
; 4333 :          }
; 4334 :       }
; 4335 :    }
; 4336 : }
; 4337 : 
; 4338 : static int stbi__compute_huffman_codes(stbi__zbuf *a)
; 4339 : {
; 4340 :    static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
; 4341 :    stbi__zhuffman z_codelength;
; 4342 :    stbi_uc lencodes[286+32+137];//padding for maximum single op
; 4343 :    stbi_uc codelength_sizes[19];
; 4344 :    int i,n;
; 4345 : 
; 4346 :    int hlit  = stbi__zreceive(a,5) + 257;
; 4347 :    int hdist = stbi__zreceive(a,5) + 1;
; 4348 :    int hclen = stbi__zreceive(a,4) + 4;
; 4349 :    int ntot  = hlit + hdist;
; 4350 : 
; 4351 :    memset(codelength_sizes, 0, sizeof(codelength_sizes));
; 4352 :    for (i=0; i < hclen; ++i) {
; 4353 :       int s = stbi__zreceive(a,3);
; 4354 :       codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
; 4355 :    }
; 4356 :    if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;
; 4357 : 
; 4358 :    n = 0;
; 4359 :    while (n < ntot) {
; 4360 :       int c = stbi__zhuffman_decode(a, &z_codelength);
; 4361 :       if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
; 4362 :       if (c < 16)
; 4363 :          lencodes[n++] = (stbi_uc) c;
; 4364 :       else {
; 4365 :          stbi_uc fill = 0;
; 4366 :          if (c == 16) {
; 4367 :             c = stbi__zreceive(a,2)+3;
; 4368 :             if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
; 4369 :             fill = lencodes[n-1];
; 4370 :          } else if (c == 17) {
; 4371 :             c = stbi__zreceive(a,3)+3;
; 4372 :          } else if (c == 18) {
; 4373 :             c = stbi__zreceive(a,7)+11;
; 4374 :          } else {
; 4375 :             return stbi__err("bad codelengths", "Corrupt PNG");
; 4376 :          }
; 4377 :          if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
; 4378 :          memset(lencodes+n, fill, c);
; 4379 :          n += c;
; 4380 :       }
; 4381 :    }
; 4382 :    if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");
; 4383 :    if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
; 4384 :    if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
; 4385 :    return 1;
; 4386 : }
; 4387 : 
; 4388 : static int stbi__parse_uncompressed_block(stbi__zbuf *a)
; 4389 : {
; 4390 :    stbi_uc header[4];
; 4391 :    int len,nlen,k;
; 4392 :    if (a->num_bits & 7)
; 4393 :       stbi__zreceive(a, a->num_bits & 7); // discard
; 4394 :    // drain the bit-packed data into header
; 4395 :    k = 0;
; 4396 :    while (a->num_bits > 0) {
; 4397 :       header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
; 4398 :       a->code_buffer >>= 8;
; 4399 :       a->num_bits -= 8;
; 4400 :    }
; 4401 :    if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");
; 4402 :    // now fill header the normal way
; 4403 :    while (k < 4)
; 4404 :       header[k++] = stbi__zget8(a);
; 4405 :    len  = header[1] * 256 + header[0];
; 4406 :    nlen = header[3] * 256 + header[2];
; 4407 :    if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
; 4408 :    if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
; 4409 :    if (a->zout + len > a->zout_end)
; 4410 :       if (!stbi__zexpand(a, a->zout, len)) return 0;
; 4411 :    memcpy(a->zout, a->zbuffer, len);
; 4412 :    a->zbuffer += len;
; 4413 :    a->zout += len;
; 4414 :    return 1;
; 4415 : }
; 4416 : 
; 4417 : static int stbi__parse_zlib_header(stbi__zbuf *a)
; 4418 : {
; 4419 :    int cmf   = stbi__zget8(a);
; 4420 :    int cm    = cmf & 15;
; 4421 :    /* int cinfo = cmf >> 4; */
; 4422 :    int flg   = stbi__zget8(a);
; 4423 :    if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
; 4424 :    if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
; 4425 :    if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
; 4426 :    if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
; 4427 :    // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
; 4428 :    return 1;
; 4429 : }
; 4430 : 
; 4431 : static const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =
; 4432 : {
; 4433 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4434 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4435 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4436 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4437 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4438 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4439 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4440 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4441 :    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
; 4442 : };
; 4443 : static const stbi_uc stbi__zdefault_distance[32] =
; 4444 : {
; 4445 :    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
; 4446 : };
; 4447 : /*
; 4448 : Init algorithm:
; 4449 : {
; 4450 :    int i;   // use <= to match clearly with spec
; 4451 :    for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
; 4452 :    for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
; 4453 :    for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
; 4454 :    for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;
; 4455 : 
; 4456 :    for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
; 4457 : }
; 4458 : */
; 4459 : 
; 4460 : static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
; 4461 : {
; 4462 :    int final, type;
; 4463 :    if (parse_header)
; 4464 :       if (!stbi__parse_zlib_header(a)) return 0;
; 4465 :    a->num_bits = 0;
; 4466 :    a->code_buffer = 0;
; 4467 :    do {
; 4468 :       final = stbi__zreceive(a,1);
; 4469 :       type = stbi__zreceive(a,2);
; 4470 :       if (type == 0) {
; 4471 :          if (!stbi__parse_uncompressed_block(a)) return 0;
; 4472 :       } else if (type == 3) {
; 4473 :          return 0;
; 4474 :       } else {
; 4475 :          if (type == 1) {
; 4476 :             // use fixed code lengths
; 4477 :             if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
; 4478 :             if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
; 4479 :          } else {
; 4480 :             if (!stbi__compute_huffman_codes(a)) return 0;
; 4481 :          }
; 4482 :          if (!stbi__parse_huffman_block(a)) return 0;
; 4483 :       }
; 4484 :    } while (!final);
; 4485 :    return 1;
; 4486 : }
; 4487 : 
; 4488 : static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
; 4489 : {
; 4490 :    a->zout_start = obuf;
; 4491 :    a->zout       = obuf;
; 4492 :    a->zout_end   = obuf + olen;
; 4493 :    a->z_expandable = exp;
; 4494 : 
; 4495 :    return stbi__parse_zlib(a, parse_header);
; 4496 : }
; 4497 : 
; 4498 : STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
; 4499 : {
; 4500 :    stbi__zbuf a;
; 4501 :    char *p = (char *) stbi__malloc(initial_size);
; 4502 :    if (p == NULL) return NULL;
; 4503 :    a.zbuffer = (stbi_uc *) buffer;
; 4504 :    a.zbuffer_end = (stbi_uc *) buffer + len;
; 4505 :    if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
; 4506 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4507 :       return a.zout_start;
; 4508 :    } else {
; 4509 :       STBI_FREE(a.zout_start);
; 4510 :       return NULL;
; 4511 :    }
; 4512 : }
; 4513 : 
; 4514 : STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
; 4515 : {
; 4516 :    return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
; 4517 : }
; 4518 : 
; 4519 : STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
; 4520 : {
; 4521 :    stbi__zbuf a;
; 4522 :    char *p = (char *) stbi__malloc(initial_size);
; 4523 :    if (p == NULL) return NULL;
; 4524 :    a.zbuffer = (stbi_uc *) buffer;
; 4525 :    a.zbuffer_end = (stbi_uc *) buffer + len;
; 4526 :    if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
; 4527 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4528 :       return a.zout_start;
; 4529 :    } else {
; 4530 :       STBI_FREE(a.zout_start);
; 4531 :       return NULL;
; 4532 :    }
; 4533 : }
; 4534 : 
; 4535 : STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
; 4536 : {
; 4537 :    stbi__zbuf a;
; 4538 :    a.zbuffer = (stbi_uc *) ibuffer;
; 4539 :    a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
; 4540 :    if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
; 4541 :       return (int) (a.zout - a.zout_start);
; 4542 :    else
; 4543 :       return -1;
; 4544 : }
; 4545 : 
; 4546 : STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
; 4547 : {
; 4548 :    stbi__zbuf a;
; 4549 :    char *p = (char *) stbi__malloc(16384);
; 4550 :    if (p == NULL) return NULL;
; 4551 :    a.zbuffer = (stbi_uc *) buffer;
; 4552 :    a.zbuffer_end = (stbi_uc *) buffer+len;
; 4553 :    if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
; 4554 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4555 :       return a.zout_start;
; 4556 :    } else {
; 4557 :       STBI_FREE(a.zout_start);
; 4558 :       return NULL;
; 4559 :    }
; 4560 : }
; 4561 : 
; 4562 : STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
; 4563 : {
; 4564 :    stbi__zbuf a;
; 4565 :    a.zbuffer = (stbi_uc *) ibuffer;
; 4566 :    a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
; 4567 :    if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
; 4568 :       return (int) (a.zout - a.zout_start);
; 4569 :    else
; 4570 :       return -1;
; 4571 : }
; 4572 : #endif
; 4573 : 
; 4574 : // public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
; 4575 : //    simple implementation
; 4576 : //      - only 8-bit samples
; 4577 : //      - no CRC checking
; 4578 : //      - allocates lots of intermediate memory
; 4579 : //        - avoids problem of streaming data between subsystems
; 4580 : //        - avoids explicit window management
; 4581 : //    performance
; 4582 : //      - uses stb_zlib, a PD zlib implementation with fast huffman decoding
; 4583 : 
; 4584 : #ifndef STBI_NO_PNG
; 4585 : typedef struct
; 4586 : {
; 4587 :    stbi__uint32 length;
; 4588 :    stbi__uint32 type;
; 4589 : } stbi__pngchunk;
; 4590 : 
; 4591 : static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
; 4592 : {
; 4593 :    stbi__pngchunk c;
; 4594 :    c.length = stbi__get32be(s);
; 4595 :    c.type   = stbi__get32be(s);
; 4596 :    return c;
; 4597 : }
; 4598 : 
; 4599 : static int stbi__check_png_header(stbi__context *s)
; 4600 : {
; 4601 :    static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
; 4602 :    int i;
; 4603 :    for (i=0; i < 8; ++i)
; 4604 :       if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
; 4605 :    return 1;
; 4606 : }
; 4607 : 
; 4608 : typedef struct
; 4609 : {
; 4610 :    stbi__context *s;
; 4611 :    stbi_uc *idata, *expanded, *out;
; 4612 :    int depth;
; 4613 : } stbi__png;
; 4614 : 
; 4615 : 
; 4616 : enum {
; 4617 :    STBI__F_none=0,
; 4618 :    STBI__F_sub=1,
; 4619 :    STBI__F_up=2,
; 4620 :    STBI__F_avg=3,
; 4621 :    STBI__F_paeth=4,
; 4622 :    // synthetic filters used for first scanline to avoid needing a dummy row of 0s
; 4623 :    STBI__F_avg_first,
; 4624 :    STBI__F_paeth_first
; 4625 : };
; 4626 : 
; 4627 : static stbi_uc first_row_filter[5] =
; 4628 : {
; 4629 :    STBI__F_none,
; 4630 :    STBI__F_sub,
; 4631 :    STBI__F_none,
; 4632 :    STBI__F_avg_first,
; 4633 :    STBI__F_paeth_first
; 4634 : };
; 4635 : 
; 4636 : static int stbi__paeth(int a, int b, int c)
; 4637 : {
; 4638 :    int p = a + b - c;
; 4639 :    int pa = abs(p-a);
; 4640 :    int pb = abs(p-b);
; 4641 :    int pc = abs(p-c);
; 4642 :    if (pa <= pb && pa <= pc) return a;
; 4643 :    if (pb <= pc) return b;
; 4644 :    return c;
; 4645 : }
; 4646 : 
; 4647 : static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };
; 4648 : 
; 4649 : // create the png data from post-deflated data
; 4650 : static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
; 4651 : {
; 4652 :    int bytes = (depth == 16? 2 : 1);
; 4653 :    stbi__context *s = a->s;
; 4654 :    stbi__uint32 i,j,stride = x*out_n*bytes;
; 4655 :    stbi__uint32 img_len, img_width_bytes;
; 4656 :    int k;
; 4657 :    int img_n = s->img_n; // copy it into a local for later
; 4658 : 
; 4659 :    int output_bytes = out_n*bytes;
; 4660 :    int filter_bytes = img_n*bytes;
; 4661 :    int width = x;
; 4662 : 
; 4663 :    STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
; 4664 :    a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
; 4665 :    if (!a->out) return stbi__err("outofmem", "Out of memory");
; 4666 : 
; 4667 :    if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
; 4668 :    img_width_bytes = (((img_n * x * depth) + 7) >> 3);
; 4669 :    img_len = (img_width_bytes + 1) * y;
; 4670 : 
; 4671 :    // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
; 4672 :    // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
; 4673 :    // so just check for raw_len < img_len always.
; 4674 :    if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");
; 4675 : 
; 4676 :    for (j=0; j < y; ++j) {
; 4677 :       stbi_uc *cur = a->out + stride*j;
; 4678 :       stbi_uc *prior;
; 4679 :       int filter = *raw++;
; 4680 : 
; 4681 :       if (filter > 4)
; 4682 :          return stbi__err("invalid filter","Corrupt PNG");
; 4683 : 
; 4684 :       if (depth < 8) {
; 4685 :          if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");
; 4686 :          cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
; 4687 :          filter_bytes = 1;
; 4688 :          width = img_width_bytes;
; 4689 :       }
; 4690 :       prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above
; 4691 : 
; 4692 :       // if first row, use special filter that doesn't sample previous row
; 4693 :       if (j == 0) filter = first_row_filter[filter];
; 4694 : 
; 4695 :       // handle first byte explicitly
; 4696 :       for (k=0; k < filter_bytes; ++k) {
; 4697 :          switch (filter) {
; 4698 :             case STBI__F_none       : cur[k] = raw[k]; break;
; 4699 :             case STBI__F_sub        : cur[k] = raw[k]; break;
; 4700 :             case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
; 4701 :             case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;
; 4702 :             case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;
; 4703 :             case STBI__F_avg_first  : cur[k] = raw[k]; break;
; 4704 :             case STBI__F_paeth_first: cur[k] = raw[k]; break;
; 4705 :          }
; 4706 :       }
; 4707 : 
; 4708 :       if (depth == 8) {
; 4709 :          if (img_n != out_n)
; 4710 :             cur[img_n] = 255; // first pixel
; 4711 :          raw += img_n;
; 4712 :          cur += out_n;
; 4713 :          prior += out_n;
; 4714 :       } else if (depth == 16) {
; 4715 :          if (img_n != out_n) {
; 4716 :             cur[filter_bytes]   = 255; // first pixel top byte
; 4717 :             cur[filter_bytes+1] = 255; // first pixel bottom byte
; 4718 :          }
; 4719 :          raw += filter_bytes;
; 4720 :          cur += output_bytes;
; 4721 :          prior += output_bytes;
; 4722 :       } else {
; 4723 :          raw += 1;
; 4724 :          cur += 1;
; 4725 :          prior += 1;
; 4726 :       }
; 4727 : 
; 4728 :       // this is a little gross, so that we don't switch per-pixel or per-component
; 4729 :       if (depth < 8 || img_n == out_n) {
; 4730 :          int nk = (width - 1)*filter_bytes;
; 4731 :          #define STBI__CASE(f) \
; 4732 :              case f:     \
; 4733 :                 for (k=0; k < nk; ++k)
; 4734 :          switch (filter) {
; 4735 :             // "none" filter turns into a memcpy here; make that explicit.
; 4736 :             case STBI__F_none:         memcpy(cur, raw, nk); break;
; 4737 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;
; 4738 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
; 4739 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;
; 4740 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;
; 4741 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;
; 4742 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;
; 4743 :          }
; 4744 :          #undef STBI__CASE
; 4745 :          raw += nk;
; 4746 :       } else {
; 4747 :          STBI_ASSERT(img_n+1 == out_n);
; 4748 :          #define STBI__CASE(f) \
; 4749 :              case f:     \
; 4750 :                 for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
; 4751 :                    for (k=0; k < filter_bytes; ++k)
; 4752 :          switch (filter) {
; 4753 :             STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;
; 4754 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;
; 4755 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
; 4756 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;
; 4757 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;
; 4758 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;
; 4759 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;
; 4760 :          }
; 4761 :          #undef STBI__CASE
; 4762 : 
; 4763 :          // the loop above sets the high byte of the pixels' alpha, but for
; 4764 :          // 16 bit png files we also need the low byte set. we'll do that here.
; 4765 :          if (depth == 16) {
; 4766 :             cur = a->out + stride*j; // start at the beginning of the row again
; 4767 :             for (i=0; i < x; ++i,cur+=output_bytes) {
; 4768 :                cur[filter_bytes+1] = 255;
; 4769 :             }
; 4770 :          }
; 4771 :       }
; 4772 :    }
; 4773 : 
; 4774 :    // we make a separate pass to expand bits to pixels; for performance,
; 4775 :    // this could run two scanlines behind the above code, so it won't
; 4776 :    // intefere with filtering but will still be in the cache.
; 4777 :    if (depth < 8) {
; 4778 :       for (j=0; j < y; ++j) {
; 4779 :          stbi_uc *cur = a->out + stride*j;
; 4780 :          stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
; 4781 :          // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
; 4782 :          // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
; 4783 :          stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range
; 4784 : 
; 4785 :          // note that the final byte might overshoot and write more data than desired.
; 4786 :          // we can allocate enough data that this never writes out of memory, but it
; 4787 :          // could also overwrite the next scanline. can it overwrite non-empty data
; 4788 :          // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
; 4789 :          // so we need to explicitly clamp the final ones
; 4790 : 
; 4791 :          if (depth == 4) {
; 4792 :             for (k=x*img_n; k >= 2; k-=2, ++in) {
; 4793 :                *cur++ = scale * ((*in >> 4)       );
; 4794 :                *cur++ = scale * ((*in     ) & 0x0f);
; 4795 :             }
; 4796 :             if (k > 0) *cur++ = scale * ((*in >> 4)       );
; 4797 :          } else if (depth == 2) {
; 4798 :             for (k=x*img_n; k >= 4; k-=4, ++in) {
; 4799 :                *cur++ = scale * ((*in >> 6)       );
; 4800 :                *cur++ = scale * ((*in >> 4) & 0x03);
; 4801 :                *cur++ = scale * ((*in >> 2) & 0x03);
; 4802 :                *cur++ = scale * ((*in     ) & 0x03);
; 4803 :             }
; 4804 :             if (k > 0) *cur++ = scale * ((*in >> 6)       );
; 4805 :             if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
; 4806 :             if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
; 4807 :          } else if (depth == 1) {
; 4808 :             for (k=x*img_n; k >= 8; k-=8, ++in) {
; 4809 :                *cur++ = scale * ((*in >> 7)       );
; 4810 :                *cur++ = scale * ((*in >> 6) & 0x01);
; 4811 :                *cur++ = scale * ((*in >> 5) & 0x01);
; 4812 :                *cur++ = scale * ((*in >> 4) & 0x01);
; 4813 :                *cur++ = scale * ((*in >> 3) & 0x01);
; 4814 :                *cur++ = scale * ((*in >> 2) & 0x01);
; 4815 :                *cur++ = scale * ((*in >> 1) & 0x01);
; 4816 :                *cur++ = scale * ((*in     ) & 0x01);
; 4817 :             }
; 4818 :             if (k > 0) *cur++ = scale * ((*in >> 7)       );
; 4819 :             if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
; 4820 :             if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
; 4821 :             if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
; 4822 :             if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
; 4823 :             if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
; 4824 :             if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
; 4825 :          }
; 4826 :          if (img_n != out_n) {
; 4827 :             int q;
; 4828 :             // insert alpha = 255
; 4829 :             cur = a->out + stride*j;
; 4830 :             if (img_n == 1) {
; 4831 :                for (q=x-1; q >= 0; --q) {
; 4832 :                   cur[q*2+1] = 255;
; 4833 :                   cur[q*2+0] = cur[q];
; 4834 :                }
; 4835 :             } else {
; 4836 :                STBI_ASSERT(img_n == 3);
; 4837 :                for (q=x-1; q >= 0; --q) {
; 4838 :                   cur[q*4+3] = 255;
; 4839 :                   cur[q*4+2] = cur[q*3+2];
; 4840 :                   cur[q*4+1] = cur[q*3+1];
; 4841 :                   cur[q*4+0] = cur[q*3+0];
; 4842 :                }
; 4843 :             }
; 4844 :          }
; 4845 :       }
; 4846 :    } else if (depth == 16) {
; 4847 :       // force the image data from big-endian to platform-native.
; 4848 :       // this is done in a separate pass due to the decoding relying
; 4849 :       // on the data being untouched, but could probably be done
; 4850 :       // per-line during decode if care is taken.
; 4851 :       stbi_uc *cur = a->out;
; 4852 :       stbi__uint16 *cur16 = (stbi__uint16*)cur;
; 4853 : 
; 4854 :       for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {
; 4855 :          *cur16 = (cur[0] << 8) | cur[1];
; 4856 :       }
; 4857 :    }
; 4858 : 
; 4859 :    return 1;
; 4860 : }
; 4861 : 
; 4862 : static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
; 4863 : {
; 4864 :    int bytes = (depth == 16 ? 2 : 1);
; 4865 :    int out_bytes = out_n * bytes;
; 4866 :    stbi_uc *final;
; 4867 :    int p;
; 4868 :    if (!interlaced)
; 4869 :       return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);
; 4870 : 
; 4871 :    // de-interlacing
; 4872 :    final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
; 4873 :    if (!final) return stbi__err("outofmem", "Out of memory");
; 4874 :    for (p=0; p < 7; ++p) {
; 4875 :       int xorig[] = { 0,4,0,2,0,1,0 };
; 4876 :       int yorig[] = { 0,0,4,0,2,0,1 };
; 4877 :       int xspc[]  = { 8,8,4,4,2,2,1 };
; 4878 :       int yspc[]  = { 8,8,8,4,4,2,2 };
; 4879 :       int i,j,x,y;
; 4880 :       // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
; 4881 :       x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
; 4882 :       y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
; 4883 :       if (x && y) {
; 4884 :          stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
; 4885 :          if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
; 4886 :             STBI_FREE(final);
; 4887 :             return 0;
; 4888 :          }
; 4889 :          for (j=0; j < y; ++j) {
; 4890 :             for (i=0; i < x; ++i) {
; 4891 :                int out_y = j*yspc[p]+yorig[p];
; 4892 :                int out_x = i*xspc[p]+xorig[p];
; 4893 :                memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
; 4894 :                       a->out + (j*x+i)*out_bytes, out_bytes);
; 4895 :             }
; 4896 :          }
; 4897 :          STBI_FREE(a->out);
; 4898 :          image_data += img_len;
; 4899 :          image_data_len -= img_len;
; 4900 :       }
; 4901 :    }
; 4902 :    a->out = final;
; 4903 : 
; 4904 :    return 1;
; 4905 : }
; 4906 : 
; 4907 : static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
; 4908 : {
; 4909 :    stbi__context *s = z->s;
; 4910 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 4911 :    stbi_uc *p = z->out;
; 4912 : 
; 4913 :    // compute color-based transparency, assuming we've
; 4914 :    // already got 255 as the alpha value in the output
; 4915 :    STBI_ASSERT(out_n == 2 || out_n == 4);
; 4916 : 
; 4917 :    if (out_n == 2) {
; 4918 :       for (i=0; i < pixel_count; ++i) {
; 4919 :          p[1] = (p[0] == tc[0] ? 0 : 255);
; 4920 :          p += 2;
; 4921 :       }
; 4922 :    } else {
; 4923 :       for (i=0; i < pixel_count; ++i) {
; 4924 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
; 4925 :             p[3] = 0;
; 4926 :          p += 4;
; 4927 :       }
; 4928 :    }
; 4929 :    return 1;
; 4930 : }
; 4931 : 
; 4932 : static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
; 4933 : {
; 4934 :    stbi__context *s = z->s;
; 4935 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 4936 :    stbi__uint16 *p = (stbi__uint16*) z->out;
; 4937 : 
; 4938 :    // compute color-based transparency, assuming we've
; 4939 :    // already got 65535 as the alpha value in the output
; 4940 :    STBI_ASSERT(out_n == 2 || out_n == 4);
; 4941 : 
; 4942 :    if (out_n == 2) {
; 4943 :       for (i = 0; i < pixel_count; ++i) {
; 4944 :          p[1] = (p[0] == tc[0] ? 0 : 65535);
; 4945 :          p += 2;
; 4946 :       }
; 4947 :    } else {
; 4948 :       for (i = 0; i < pixel_count; ++i) {
; 4949 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
; 4950 :             p[3] = 0;
; 4951 :          p += 4;
; 4952 :       }
; 4953 :    }
; 4954 :    return 1;
; 4955 : }
; 4956 : 
; 4957 : static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
; 4958 : {
; 4959 :    stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
; 4960 :    stbi_uc *p, *temp_out, *orig = a->out;
; 4961 : 
; 4962 :    p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
; 4963 :    if (p == NULL) return stbi__err("outofmem", "Out of memory");
; 4964 : 
; 4965 :    // between here and free(out) below, exitting would leak
; 4966 :    temp_out = p;
; 4967 : 
; 4968 :    if (pal_img_n == 3) {
; 4969 :       for (i=0; i < pixel_count; ++i) {
; 4970 :          int n = orig[i]*4;
; 4971 :          p[0] = palette[n  ];
; 4972 :          p[1] = palette[n+1];
; 4973 :          p[2] = palette[n+2];
; 4974 :          p += 3;
; 4975 :       }
; 4976 :    } else {
; 4977 :       for (i=0; i < pixel_count; ++i) {
; 4978 :          int n = orig[i]*4;
; 4979 :          p[0] = palette[n  ];
; 4980 :          p[1] = palette[n+1];
; 4981 :          p[2] = palette[n+2];
; 4982 :          p[3] = palette[n+3];
; 4983 :          p += 4;
; 4984 :       }
; 4985 :    }
; 4986 :    STBI_FREE(a->out);
; 4987 :    a->out = temp_out;
; 4988 : 
; 4989 :    STBI_NOTUSED(len);
; 4990 : 
; 4991 :    return 1;
; 4992 : }
; 4993 : 
; 4994 : static int stbi__unpremultiply_on_load_global = 0;
; 4995 : static int stbi__de_iphone_flag_global = 0;
; 4996 : 
; 4997 : STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
; 4998 : {
; 4999 :    stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
; 5000 : }
; 5001 : 
; 5002 : STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
; 5003 : {
; 5004 :    stbi__de_iphone_flag_global = flag_true_if_should_convert;
; 5005 : }
; 5006 : 
; 5007 : #ifndef STBI_THREAD_LOCAL
; 5008 : #define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global
; 5009 : #define stbi__de_iphone_flag  stbi__de_iphone_flag_global
; 5010 : #else
; 5011 : static STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;
; 5012 : static STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;
; 5013 : 
; 5014 : STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
; 5015 : {
; 5016 :    stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
; 5017 :    stbi__unpremultiply_on_load_set = 1;
; 5018 : }
; 5019 : 
; 5020 : STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
; 5021 : {
; 5022 :    stbi__de_iphone_flag_local = flag_true_if_should_convert;
; 5023 :    stbi__de_iphone_flag_set = 1;
; 5024 : }
; 5025 : 
; 5026 : #define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \
; 5027 :                                        ? stbi__unpremultiply_on_load_local      \
; 5028 :                                        : stbi__unpremultiply_on_load_global)
; 5029 : #define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \
; 5030 :                                 ? stbi__de_iphone_flag_local                    \
; 5031 :                                 : stbi__de_iphone_flag_global)
; 5032 : #endif // STBI_THREAD_LOCAL
; 5033 : 
; 5034 : static void stbi__de_iphone(stbi__png *z)
; 5035 : {
; 5036 :    stbi__context *s = z->s;
; 5037 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 5038 :    stbi_uc *p = z->out;
; 5039 : 
; 5040 :    if (s->img_out_n == 3) {  // convert bgr to rgb
; 5041 :       for (i=0; i < pixel_count; ++i) {
; 5042 :          stbi_uc t = p[0];
; 5043 :          p[0] = p[2];
; 5044 :          p[2] = t;
; 5045 :          p += 3;
; 5046 :       }
; 5047 :    } else {
; 5048 :       STBI_ASSERT(s->img_out_n == 4);
; 5049 :       if (stbi__unpremultiply_on_load) {
; 5050 :          // convert bgr to rgb and unpremultiply
; 5051 :          for (i=0; i < pixel_count; ++i) {
; 5052 :             stbi_uc a = p[3];
; 5053 :             stbi_uc t = p[0];
; 5054 :             if (a) {
; 5055 :                stbi_uc half = a / 2;
; 5056 :                p[0] = (p[2] * 255 + half) / a;
; 5057 :                p[1] = (p[1] * 255 + half) / a;
; 5058 :                p[2] = ( t   * 255 + half) / a;
; 5059 :             } else {
; 5060 :                p[0] = p[2];
; 5061 :                p[2] = t;
; 5062 :             }
; 5063 :             p += 4;
; 5064 :          }
; 5065 :       } else {
; 5066 :          // convert bgr to rgb
; 5067 :          for (i=0; i < pixel_count; ++i) {
; 5068 :             stbi_uc t = p[0];
; 5069 :             p[0] = p[2];
; 5070 :             p[2] = t;
; 5071 :             p += 4;
; 5072 :          }
; 5073 :       }
; 5074 :    }
; 5075 : }
; 5076 : 
; 5077 : #define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))
; 5078 : 
; 5079 : static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
; 5080 : {
; 5081 :    stbi_uc palette[1024], pal_img_n=0;
; 5082 :    stbi_uc has_trans=0, tc[3]={0};
; 5083 :    stbi__uint16 tc16[3];
; 5084 :    stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
; 5085 :    int first=1,k,interlace=0, color=0, is_iphone=0;
; 5086 :    stbi__context *s = z->s;
; 5087 : 
; 5088 :    z->expanded = NULL;
; 5089 :    z->idata = NULL;
; 5090 :    z->out = NULL;
; 5091 : 
; 5092 :    if (!stbi__check_png_header(s)) return 0;
; 5093 : 
; 5094 :    if (scan == STBI__SCAN_type) return 1;
; 5095 : 
; 5096 :    for (;;) {
; 5097 :       stbi__pngchunk c = stbi__get_chunk_header(s);
; 5098 :       switch (c.type) {
; 5099 :          case STBI__PNG_TYPE('C','g','B','I'):
; 5100 :             is_iphone = 1;
; 5101 :             stbi__skip(s, c.length);
; 5102 :             break;
; 5103 :          case STBI__PNG_TYPE('I','H','D','R'): {
; 5104 :             int comp,filter;
; 5105 :             if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
; 5106 :             first = 0;
; 5107 :             if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
; 5108 :             s->img_x = stbi__get32be(s);
; 5109 :             s->img_y = stbi__get32be(s);
; 5110 :             if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 5111 :             if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 5112 :             z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
; 5113 :             color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
; 5114 :             if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
; 5115 :             if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
; 5116 :             comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
; 5117 :             filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
; 5118 :             interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
; 5119 :             if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
; 5120 :             if (!pal_img_n) {
; 5121 :                s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
; 5122 :                if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
; 5123 :             } else {
; 5124 :                // if paletted, then pal_n is our final components, and
; 5125 :                // img_n is # components to decompress/filter.
; 5126 :                s->img_n = 1;
; 5127 :                if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
; 5128 :             }
; 5129 :             // even with SCAN_header, have to scan to see if we have a tRNS
; 5130 :             break;
; 5131 :          }
; 5132 : 
; 5133 :          case STBI__PNG_TYPE('P','L','T','E'):  {
; 5134 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5135 :             if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
; 5136 :             pal_len = c.length / 3;
; 5137 :             if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
; 5138 :             for (i=0; i < pal_len; ++i) {
; 5139 :                palette[i*4+0] = stbi__get8(s);
; 5140 :                palette[i*4+1] = stbi__get8(s);
; 5141 :                palette[i*4+2] = stbi__get8(s);
; 5142 :                palette[i*4+3] = 255;
; 5143 :             }
; 5144 :             break;
; 5145 :          }
; 5146 : 
; 5147 :          case STBI__PNG_TYPE('t','R','N','S'): {
; 5148 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5149 :             if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
; 5150 :             if (pal_img_n) {
; 5151 :                if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
; 5152 :                if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
; 5153 :                if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
; 5154 :                pal_img_n = 4;
; 5155 :                for (i=0; i < c.length; ++i)
; 5156 :                   palette[i*4+3] = stbi__get8(s);
; 5157 :             } else {
; 5158 :                if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
; 5159 :                if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
; 5160 :                has_trans = 1;
; 5161 :                // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.
; 5162 :                if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }
; 5163 :                if (z->depth == 16) {
; 5164 :                   for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
; 5165 :                } else {
; 5166 :                   for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
; 5167 :                }
; 5168 :             }
; 5169 :             break;
; 5170 :          }
; 5171 : 
; 5172 :          case STBI__PNG_TYPE('I','D','A','T'): {
; 5173 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5174 :             if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
; 5175 :             if (scan == STBI__SCAN_header) {
; 5176 :                // header scan definitely stops at first IDAT
; 5177 :                if (pal_img_n)
; 5178 :                   s->img_n = pal_img_n;
; 5179 :                return 1;
; 5180 :             }
; 5181 :             if (c.length > (1u << 30)) return stbi__err("IDAT size limit", "IDAT section larger than 2^30 bytes");
; 5182 :             if ((int)(ioff + c.length) < (int)ioff) return 0;
; 5183 :             if (ioff + c.length > idata_limit) {
; 5184 :                stbi__uint32 idata_limit_old = idata_limit;
; 5185 :                stbi_uc *p;
; 5186 :                if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
; 5187 :                while (ioff + c.length > idata_limit)
; 5188 :                   idata_limit *= 2;
; 5189 :                STBI_NOTUSED(idata_limit_old);
; 5190 :                p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
; 5191 :                z->idata = p;
; 5192 :             }
; 5193 :             if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
; 5194 :             ioff += c.length;
; 5195 :             break;
; 5196 :          }
; 5197 : 
; 5198 :          case STBI__PNG_TYPE('I','E','N','D'): {
; 5199 :             stbi__uint32 raw_len, bpl;
; 5200 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5201 :             if (scan != STBI__SCAN_load) return 1;
; 5202 :             if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
; 5203 :             // initial guess for decoded data size to avoid unnecessary reallocs
; 5204 :             bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
; 5205 :             raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
; 5206 :             z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
; 5207 :             if (z->expanded == NULL) return 0; // zlib should set error
; 5208 :             STBI_FREE(z->idata); z->idata = NULL;
; 5209 :             if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
; 5210 :                s->img_out_n = s->img_n+1;
; 5211 :             else
; 5212 :                s->img_out_n = s->img_n;
; 5213 :             if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
; 5214 :             if (has_trans) {
; 5215 :                if (z->depth == 16) {
; 5216 :                   if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
; 5217 :                } else {
; 5218 :                   if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
; 5219 :                }
; 5220 :             }
; 5221 :             if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
; 5222 :                stbi__de_iphone(z);
; 5223 :             if (pal_img_n) {
; 5224 :                // pal_img_n == 3 or 4
; 5225 :                s->img_n = pal_img_n; // record the actual colors we had
; 5226 :                s->img_out_n = pal_img_n;
; 5227 :                if (req_comp >= 3) s->img_out_n = req_comp;
; 5228 :                if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
; 5229 :                   return 0;
; 5230 :             } else if (has_trans) {
; 5231 :                // non-paletted image with tRNS -> source image has (constant) alpha
; 5232 :                ++s->img_n;
; 5233 :             }
; 5234 :             STBI_FREE(z->expanded); z->expanded = NULL;
; 5235 :             // end of PNG chunk, read and skip CRC
; 5236 :             stbi__get32be(s);
; 5237 :             return 1;
; 5238 :          }
; 5239 : 
; 5240 :          default:
; 5241 :             // if critical, fail
; 5242 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5243 :             if ((c.type & (1 << 29)) == 0) {
; 5244 :                #ifndef STBI_NO_FAILURE_STRINGS
; 5245 :                // not threadsafe
; 5246 :                static char invalid_chunk[] = "XXXX PNG chunk not known";
; 5247 :                invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
; 5248 :                invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
; 5249 :                invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
; 5250 :                invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
; 5251 :                #endif
; 5252 :                return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
; 5253 :             }
; 5254 :             stbi__skip(s, c.length);
; 5255 :             break;
; 5256 :       }
; 5257 :       // end of PNG chunk, read and skip CRC
; 5258 :       stbi__get32be(s);
; 5259 :    }
; 5260 : }
; 5261 : 
; 5262 : static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
; 5263 : {
; 5264 :    void *result=NULL;
; 5265 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
; 5266 :    if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
; 5267 :       if (p->depth <= 8)
; 5268 :          ri->bits_per_channel = 8;
; 5269 :       else if (p->depth == 16)
; 5270 :          ri->bits_per_channel = 16;
; 5271 :       else
; 5272 :          return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
; 5273 :       result = p->out;
; 5274 :       p->out = NULL;
; 5275 :       if (req_comp && req_comp != p->s->img_out_n) {
; 5276 :          if (ri->bits_per_channel == 8)
; 5277 :             result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
; 5278 :          else
; 5279 :             result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
; 5280 :          p->s->img_out_n = req_comp;
; 5281 :          if (result == NULL) return result;
; 5282 :       }
; 5283 :       *x = p->s->img_x;
; 5284 :       *y = p->s->img_y;
; 5285 :       if (n) *n = p->s->img_n;
; 5286 :    }
; 5287 :    STBI_FREE(p->out);      p->out      = NULL;
; 5288 :    STBI_FREE(p->expanded); p->expanded = NULL;
; 5289 :    STBI_FREE(p->idata);    p->idata    = NULL;
; 5290 : 
; 5291 :    return result;
; 5292 : }
; 5293 : 
; 5294 : static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5295 : {
; 5296 :    stbi__png p;
; 5297 :    p.s = s;
; 5298 :    return stbi__do_png(&p, x,y,comp,req_comp, ri);
; 5299 : }
; 5300 : 
; 5301 : static int stbi__png_test(stbi__context *s)
; 5302 : {
; 5303 :    int r;
; 5304 :    r = stbi__check_png_header(s);
; 5305 :    stbi__rewind(s);
; 5306 :    return r;
; 5307 : }
; 5308 : 
; 5309 : static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
; 5310 : {
; 5311 :    if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
; 5312 :       stbi__rewind( p->s );
; 5313 :       return 0;
; 5314 :    }
; 5315 :    if (x) *x = p->s->img_x;
; 5316 :    if (y) *y = p->s->img_y;
; 5317 :    if (comp) *comp = p->s->img_n;
; 5318 :    return 1;
; 5319 : }
; 5320 : 
; 5321 : static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
; 5322 : {
; 5323 :    stbi__png p;
; 5324 :    p.s = s;
; 5325 :    return stbi__png_info_raw(&p, x, y, comp);
; 5326 : }
; 5327 : 
; 5328 : static int stbi__png_is16(stbi__context *s)
; 5329 : {
; 5330 :    stbi__png p;
; 5331 :    p.s = s;
; 5332 :    if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
; 5333 : 	   return 0;
; 5334 :    if (p.depth != 16) {
; 5335 :       stbi__rewind(p.s);
; 5336 :       return 0;
; 5337 :    }
; 5338 :    return 1;
; 5339 : }
; 5340 : #endif
; 5341 : 
; 5342 : // Microsoft/Windows BMP image
; 5343 : 
; 5344 : #ifndef STBI_NO_BMP
; 5345 : static int stbi__bmp_test_raw(stbi__context *s)
; 5346 : {
; 5347 :    int r;
; 5348 :    int sz;
; 5349 :    if (stbi__get8(s) != 'B') return 0;
; 5350 :    if (stbi__get8(s) != 'M') return 0;
; 5351 :    stbi__get32le(s); // discard filesize
; 5352 :    stbi__get16le(s); // discard reserved
; 5353 :    stbi__get16le(s); // discard reserved
; 5354 :    stbi__get32le(s); // discard data offset
; 5355 :    sz = stbi__get32le(s);
; 5356 :    r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
; 5357 :    return r;
; 5358 : }
; 5359 : 
; 5360 : static int stbi__bmp_test(stbi__context *s)
; 5361 : {
; 5362 :    int r = stbi__bmp_test_raw(s);
; 5363 :    stbi__rewind(s);
; 5364 :    return r;
; 5365 : }
; 5366 : 
; 5367 : 
; 5368 : // returns 0..31 for the highest set bit
; 5369 : static int stbi__high_bit(unsigned int z)
; 5370 : {
; 5371 :    int n=0;
; 5372 :    if (z == 0) return -1;
; 5373 :    if (z >= 0x10000) { n += 16; z >>= 16; }
; 5374 :    if (z >= 0x00100) { n +=  8; z >>=  8; }
; 5375 :    if (z >= 0x00010) { n +=  4; z >>=  4; }
; 5376 :    if (z >= 0x00004) { n +=  2; z >>=  2; }
; 5377 :    if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
; 5378 :    return n;
; 5379 : }
; 5380 : 
; 5381 : static int stbi__bitcount(unsigned int a)
; 5382 : {
; 5383 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
; 5384 :    a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
; 5385 :    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
; 5386 :    a = (a + (a >> 8)); // max 16 per 8 bits
; 5387 :    a = (a + (a >> 16)); // max 32 per 8 bits
; 5388 :    return a & 0xff;
; 5389 : }
; 5390 : 
; 5391 : // extract an arbitrarily-aligned N-bit value (N=bits)
; 5392 : // from v, and then make it 8-bits long and fractionally
; 5393 : // extend it to full full range.
; 5394 : static int stbi__shiftsigned(unsigned int v, int shift, int bits)
; 5395 : {
; 5396 :    static unsigned int mul_table[9] = {
; 5397 :       0,
; 5398 :       0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
; 5399 :       0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
; 5400 :    };
; 5401 :    static unsigned int shift_table[9] = {
; 5402 :       0, 0,0,1,0,2,4,6,0,
; 5403 :    };
; 5404 :    if (shift < 0)
; 5405 :       v <<= -shift;
; 5406 :    else
; 5407 :       v >>= shift;
; 5408 :    STBI_ASSERT(v < 256);
; 5409 :    v >>= (8-bits);
; 5410 :    STBI_ASSERT(bits >= 0 && bits <= 8);
; 5411 :    return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
; 5412 : }
; 5413 : 
; 5414 : typedef struct
; 5415 : {
; 5416 :    int bpp, offset, hsz;
; 5417 :    unsigned int mr,mg,mb,ma, all_a;
; 5418 :    int extra_read;
; 5419 : } stbi__bmp_data;
; 5420 : 
; 5421 : static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
; 5422 : {
; 5423 :    // BI_BITFIELDS specifies masks explicitly, don't override
; 5424 :    if (compress == 3)
; 5425 :       return 1;
; 5426 : 
; 5427 :    if (compress == 0) {
; 5428 :       if (info->bpp == 16) {
; 5429 :          info->mr = 31u << 10;
; 5430 :          info->mg = 31u <<  5;
; 5431 :          info->mb = 31u <<  0;
; 5432 :       } else if (info->bpp == 32) {
; 5433 :          info->mr = 0xffu << 16;
; 5434 :          info->mg = 0xffu <<  8;
; 5435 :          info->mb = 0xffu <<  0;
; 5436 :          info->ma = 0xffu << 24;
; 5437 :          info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
; 5438 :       } else {
; 5439 :          // otherwise, use defaults, which is all-0
; 5440 :          info->mr = info->mg = info->mb = info->ma = 0;
; 5441 :       }
; 5442 :       return 1;
; 5443 :    }
; 5444 :    return 0; // error
; 5445 : }
; 5446 : 
; 5447 : static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
; 5448 : {
; 5449 :    int hsz;
; 5450 :    if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
; 5451 :    stbi__get32le(s); // discard filesize
; 5452 :    stbi__get16le(s); // discard reserved
; 5453 :    stbi__get16le(s); // discard reserved
; 5454 :    info->offset = stbi__get32le(s);
; 5455 :    info->hsz = hsz = stbi__get32le(s);
; 5456 :    info->mr = info->mg = info->mb = info->ma = 0;
; 5457 :    info->extra_read = 14;
; 5458 : 
; 5459 :    if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");
; 5460 : 
; 5461 :    if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
; 5462 :    if (hsz == 12) {
; 5463 :       s->img_x = stbi__get16le(s);
; 5464 :       s->img_y = stbi__get16le(s);
; 5465 :    } else {
; 5466 :       s->img_x = stbi__get32le(s);
; 5467 :       s->img_y = stbi__get32le(s);
; 5468 :    }
; 5469 :    if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
; 5470 :    info->bpp = stbi__get16le(s);
; 5471 :    if (hsz != 12) {
; 5472 :       int compress = stbi__get32le(s);
; 5473 :       if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
; 5474 :       if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes
; 5475 :       if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel
; 5476 :       stbi__get32le(s); // discard sizeof
; 5477 :       stbi__get32le(s); // discard hres
; 5478 :       stbi__get32le(s); // discard vres
; 5479 :       stbi__get32le(s); // discard colorsused
; 5480 :       stbi__get32le(s); // discard max important
; 5481 :       if (hsz == 40 || hsz == 56) {
; 5482 :          if (hsz == 56) {
; 5483 :             stbi__get32le(s);
; 5484 :             stbi__get32le(s);
; 5485 :             stbi__get32le(s);
; 5486 :             stbi__get32le(s);
; 5487 :          }
; 5488 :          if (info->bpp == 16 || info->bpp == 32) {
; 5489 :             if (compress == 0) {
; 5490 :                stbi__bmp_set_mask_defaults(info, compress);
; 5491 :             } else if (compress == 3) {
; 5492 :                info->mr = stbi__get32le(s);
; 5493 :                info->mg = stbi__get32le(s);
; 5494 :                info->mb = stbi__get32le(s);
; 5495 :                info->extra_read += 12;
; 5496 :                // not documented, but generated by photoshop and handled by mspaint
; 5497 :                if (info->mr == info->mg && info->mg == info->mb) {
; 5498 :                   // ?!?!?
; 5499 :                   return stbi__errpuc("bad BMP", "bad BMP");
; 5500 :                }
; 5501 :             } else
; 5502 :                return stbi__errpuc("bad BMP", "bad BMP");
; 5503 :          }
; 5504 :       } else {
; 5505 :          // V4/V5 header
; 5506 :          int i;
; 5507 :          if (hsz != 108 && hsz != 124)
; 5508 :             return stbi__errpuc("bad BMP", "bad BMP");
; 5509 :          info->mr = stbi__get32le(s);
; 5510 :          info->mg = stbi__get32le(s);
; 5511 :          info->mb = stbi__get32le(s);
; 5512 :          info->ma = stbi__get32le(s);
; 5513 :          if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
; 5514 :             stbi__bmp_set_mask_defaults(info, compress);
; 5515 :          stbi__get32le(s); // discard color space
; 5516 :          for (i=0; i < 12; ++i)
; 5517 :             stbi__get32le(s); // discard color space parameters
; 5518 :          if (hsz == 124) {
; 5519 :             stbi__get32le(s); // discard rendering intent
; 5520 :             stbi__get32le(s); // discard offset of profile data
; 5521 :             stbi__get32le(s); // discard size of profile data
; 5522 :             stbi__get32le(s); // discard reserved
; 5523 :          }
; 5524 :       }
; 5525 :    }
; 5526 :    return (void *) 1;
; 5527 : }
; 5528 : 
; 5529 : 
; 5530 : static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5531 : {
; 5532 :    stbi_uc *out;
; 5533 :    unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
; 5534 :    stbi_uc pal[256][4];
; 5535 :    int psize=0,i,j,width;
; 5536 :    int flip_vertically, pad, target;
; 5537 :    stbi__bmp_data info;
; 5538 :    STBI_NOTUSED(ri);
; 5539 : 
; 5540 :    info.all_a = 255;
; 5541 :    if (stbi__bmp_parse_header(s, &info) == NULL)
; 5542 :       return NULL; // error code already set
; 5543 : 
; 5544 :    flip_vertically = ((int) s->img_y) > 0;
; 5545 :    s->img_y = abs((int) s->img_y);
; 5546 : 
; 5547 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5548 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5549 : 
; 5550 :    mr = info.mr;
; 5551 :    mg = info.mg;
; 5552 :    mb = info.mb;
; 5553 :    ma = info.ma;
; 5554 :    all_a = info.all_a;
; 5555 : 
; 5556 :    if (info.hsz == 12) {
; 5557 :       if (info.bpp < 24)
; 5558 :          psize = (info.offset - info.extra_read - 24) / 3;
; 5559 :    } else {
; 5560 :       if (info.bpp < 16)
; 5561 :          psize = (info.offset - info.extra_read - info.hsz) >> 2;
; 5562 :    }
; 5563 :    if (psize == 0) {
; 5564 :       // accept some number of extra bytes after the header, but if the offset points either to before
; 5565 :       // the header ends or implies a large amount of extra data, reject the file as malformed
; 5566 :       int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);
; 5567 :       int header_limit = 1024; // max we actually read is below 256 bytes currently.
; 5568 :       int extra_data_limit = 256*4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.
; 5569 :       if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {
; 5570 :          return stbi__errpuc("bad header", "Corrupt BMP");
; 5571 :       }
; 5572 :       // we established that bytes_read_so_far is positive and sensible.
; 5573 :       // the first half of this test rejects offsets that are either too small positives, or
; 5574 :       // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn
; 5575 :       // ensures the number computed in the second half of the test can't overflow.
; 5576 :       if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {
; 5577 :          return stbi__errpuc("bad offset", "Corrupt BMP");
; 5578 :       } else {
; 5579 :          stbi__skip(s, info.offset - bytes_read_so_far);
; 5580 :       }
; 5581 :    }
; 5582 : 
; 5583 :    if (info.bpp == 24 && ma == 0xff000000)
; 5584 :       s->img_n = 3;
; 5585 :    else
; 5586 :       s->img_n = ma ? 4 : 3;
; 5587 :    if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
; 5588 :       target = req_comp;
; 5589 :    else
; 5590 :       target = s->img_n; // if they want monochrome, we'll post-convert
; 5591 : 
; 5592 :    // sanity-check size
; 5593 :    if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
; 5594 :       return stbi__errpuc("too large", "Corrupt BMP");
; 5595 : 
; 5596 :    out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
; 5597 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");
; 5598 :    if (info.bpp < 16) {
; 5599 :       int z=0;
; 5600 :       if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
; 5601 :       for (i=0; i < psize; ++i) {
; 5602 :          pal[i][2] = stbi__get8(s);
; 5603 :          pal[i][1] = stbi__get8(s);
; 5604 :          pal[i][0] = stbi__get8(s);
; 5605 :          if (info.hsz != 12) stbi__get8(s);
; 5606 :          pal[i][3] = 255;
; 5607 :       }
; 5608 :       stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
; 5609 :       if (info.bpp == 1) width = (s->img_x + 7) >> 3;
; 5610 :       else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
; 5611 :       else if (info.bpp == 8) width = s->img_x;
; 5612 :       else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
; 5613 :       pad = (-width)&3;
; 5614 :       if (info.bpp == 1) {
; 5615 :          for (j=0; j < (int) s->img_y; ++j) {
; 5616 :             int bit_offset = 7, v = stbi__get8(s);
; 5617 :             for (i=0; i < (int) s->img_x; ++i) {
; 5618 :                int color = (v>>bit_offset)&0x1;
; 5619 :                out[z++] = pal[color][0];
; 5620 :                out[z++] = pal[color][1];
; 5621 :                out[z++] = pal[color][2];
; 5622 :                if (target == 4) out[z++] = 255;
; 5623 :                if (i+1 == (int) s->img_x) break;
; 5624 :                if((--bit_offset) < 0) {
; 5625 :                   bit_offset = 7;
; 5626 :                   v = stbi__get8(s);
; 5627 :                }
; 5628 :             }
; 5629 :             stbi__skip(s, pad);
; 5630 :          }
; 5631 :       } else {
; 5632 :          for (j=0; j < (int) s->img_y; ++j) {
; 5633 :             for (i=0; i < (int) s->img_x; i += 2) {
; 5634 :                int v=stbi__get8(s),v2=0;
; 5635 :                if (info.bpp == 4) {
; 5636 :                   v2 = v & 15;
; 5637 :                   v >>= 4;
; 5638 :                }
; 5639 :                out[z++] = pal[v][0];
; 5640 :                out[z++] = pal[v][1];
; 5641 :                out[z++] = pal[v][2];
; 5642 :                if (target == 4) out[z++] = 255;
; 5643 :                if (i+1 == (int) s->img_x) break;
; 5644 :                v = (info.bpp == 8) ? stbi__get8(s) : v2;
; 5645 :                out[z++] = pal[v][0];
; 5646 :                out[z++] = pal[v][1];
; 5647 :                out[z++] = pal[v][2];
; 5648 :                if (target == 4) out[z++] = 255;
; 5649 :             }
; 5650 :             stbi__skip(s, pad);
; 5651 :          }
; 5652 :       }
; 5653 :    } else {
; 5654 :       int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
; 5655 :       int z = 0;
; 5656 :       int easy=0;
; 5657 :       stbi__skip(s, info.offset - info.extra_read - info.hsz);
; 5658 :       if (info.bpp == 24) width = 3 * s->img_x;
; 5659 :       else if (info.bpp == 16) width = 2*s->img_x;
; 5660 :       else /* bpp = 32 and pad = 0 */ width=0;
; 5661 :       pad = (-width) & 3;
; 5662 :       if (info.bpp == 24) {
; 5663 :          easy = 1;
; 5664 :       } else if (info.bpp == 32) {
; 5665 :          if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
; 5666 :             easy = 2;
; 5667 :       }
; 5668 :       if (!easy) {
; 5669 :          if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
; 5670 :          // right shift amt to put high bit in position #7
; 5671 :          rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
; 5672 :          gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
; 5673 :          bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
; 5674 :          ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
; 5675 :          if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
; 5676 :       }
; 5677 :       for (j=0; j < (int) s->img_y; ++j) {
; 5678 :          if (easy) {
; 5679 :             for (i=0; i < (int) s->img_x; ++i) {
; 5680 :                unsigned char a;
; 5681 :                out[z+2] = stbi__get8(s);
; 5682 :                out[z+1] = stbi__get8(s);
; 5683 :                out[z+0] = stbi__get8(s);
; 5684 :                z += 3;
; 5685 :                a = (easy == 2 ? stbi__get8(s) : 255);
; 5686 :                all_a |= a;
; 5687 :                if (target == 4) out[z++] = a;
; 5688 :             }
; 5689 :          } else {
; 5690 :             int bpp = info.bpp;
; 5691 :             for (i=0; i < (int) s->img_x; ++i) {
; 5692 :                stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
; 5693 :                unsigned int a;
; 5694 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
; 5695 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
; 5696 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
; 5697 :                a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
; 5698 :                all_a |= a;
; 5699 :                if (target == 4) out[z++] = STBI__BYTECAST(a);
; 5700 :             }
; 5701 :          }
; 5702 :          stbi__skip(s, pad);
; 5703 :       }
; 5704 :    }
; 5705 : 
; 5706 :    // if alpha channel is all 0s, replace with all 255s
; 5707 :    if (target == 4 && all_a == 0)
; 5708 :       for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
; 5709 :          out[i] = 255;
; 5710 : 
; 5711 :    if (flip_vertically) {
; 5712 :       stbi_uc t;
; 5713 :       for (j=0; j < (int) s->img_y>>1; ++j) {
; 5714 :          stbi_uc *p1 = out +      j     *s->img_x*target;
; 5715 :          stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
; 5716 :          for (i=0; i < (int) s->img_x*target; ++i) {
; 5717 :             t = p1[i]; p1[i] = p2[i]; p2[i] = t;
; 5718 :          }
; 5719 :       }
; 5720 :    }
; 5721 : 
; 5722 :    if (req_comp && req_comp != target) {
; 5723 :       out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
; 5724 :       if (out == NULL) return out; // stbi__convert_format frees input on failure
; 5725 :    }
; 5726 : 
; 5727 :    *x = s->img_x;
; 5728 :    *y = s->img_y;
; 5729 :    if (comp) *comp = s->img_n;
; 5730 :    return out;
; 5731 : }
; 5732 : #endif
; 5733 : 
; 5734 : // Targa Truevision - TGA
; 5735 : // by Jonathan Dummer
; 5736 : #ifndef STBI_NO_TGA
; 5737 : // returns STBI_rgb or whatever, 0 on error
; 5738 : static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
; 5739 : {
; 5740 :    // only RGB or RGBA (incl. 16bit) or grey allowed
; 5741 :    if (is_rgb16) *is_rgb16 = 0;
; 5742 :    switch(bits_per_pixel) {
; 5743 :       case 8:  return STBI_grey;
; 5744 :       case 16: if(is_grey) return STBI_grey_alpha;
; 5745 :                // fallthrough
; 5746 :       case 15: if(is_rgb16) *is_rgb16 = 1;
; 5747 :                return STBI_rgb;
; 5748 :       case 24: // fallthrough
; 5749 :       case 32: return bits_per_pixel/8;
; 5750 :       default: return 0;
; 5751 :    }
; 5752 : }
; 5753 : 
; 5754 : static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
; 5755 : {
; 5756 :     int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
; 5757 :     int sz, tga_colormap_type;
; 5758 :     stbi__get8(s);                   // discard Offset
; 5759 :     tga_colormap_type = stbi__get8(s); // colormap type
; 5760 :     if( tga_colormap_type > 1 ) {
; 5761 :         stbi__rewind(s);
; 5762 :         return 0;      // only RGB or indexed allowed
; 5763 :     }
; 5764 :     tga_image_type = stbi__get8(s); // image type
; 5765 :     if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
; 5766 :         if (tga_image_type != 1 && tga_image_type != 9) {
; 5767 :             stbi__rewind(s);
; 5768 :             return 0;
; 5769 :         }
; 5770 :         stbi__skip(s,4);       // skip index of first colormap entry and number of entries
; 5771 :         sz = stbi__get8(s);    //   check bits per palette color entry
; 5772 :         if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
; 5773 :             stbi__rewind(s);
; 5774 :             return 0;
; 5775 :         }
; 5776 :         stbi__skip(s,4);       // skip image x and y origin
; 5777 :         tga_colormap_bpp = sz;
; 5778 :     } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
; 5779 :         if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
; 5780 :             stbi__rewind(s);
; 5781 :             return 0; // only RGB or grey allowed, +/- RLE
; 5782 :         }
; 5783 :         stbi__skip(s,9); // skip colormap specification and image x/y origin
; 5784 :         tga_colormap_bpp = 0;
; 5785 :     }
; 5786 :     tga_w = stbi__get16le(s);
; 5787 :     if( tga_w < 1 ) {
; 5788 :         stbi__rewind(s);
; 5789 :         return 0;   // test width
; 5790 :     }
; 5791 :     tga_h = stbi__get16le(s);
; 5792 :     if( tga_h < 1 ) {
; 5793 :         stbi__rewind(s);
; 5794 :         return 0;   // test height
; 5795 :     }
; 5796 :     tga_bits_per_pixel = stbi__get8(s); // bits per pixel
; 5797 :     stbi__get8(s); // ignore alpha bits
; 5798 :     if (tga_colormap_bpp != 0) {
; 5799 :         if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
; 5800 :             // when using a colormap, tga_bits_per_pixel is the size of the indexes
; 5801 :             // I don't think anything but 8 or 16bit indexes makes sense
; 5802 :             stbi__rewind(s);
; 5803 :             return 0;
; 5804 :         }
; 5805 :         tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
; 5806 :     } else {
; 5807 :         tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
; 5808 :     }
; 5809 :     if(!tga_comp) {
; 5810 :       stbi__rewind(s);
; 5811 :       return 0;
; 5812 :     }
; 5813 :     if (x) *x = tga_w;
; 5814 :     if (y) *y = tga_h;
; 5815 :     if (comp) *comp = tga_comp;
; 5816 :     return 1;                   // seems to have passed everything
; 5817 : }
; 5818 : 
; 5819 : static int stbi__tga_test(stbi__context *s)
; 5820 : {
; 5821 :    int res = 0;
; 5822 :    int sz, tga_color_type;
; 5823 :    stbi__get8(s);      //   discard Offset
; 5824 :    tga_color_type = stbi__get8(s);   //   color type
; 5825 :    if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
; 5826 :    sz = stbi__get8(s);   //   image type
; 5827 :    if ( tga_color_type == 1 ) { // colormapped (paletted) image
; 5828 :       if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
; 5829 :       stbi__skip(s,4);       // skip index of first colormap entry and number of entries
; 5830 :       sz = stbi__get8(s);    //   check bits per palette color entry
; 5831 :       if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
; 5832 :       stbi__skip(s,4);       // skip image x and y origin
; 5833 :    } else { // "normal" image w/o colormap
; 5834 :       if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
; 5835 :       stbi__skip(s,9); // skip colormap specification and image x/y origin
; 5836 :    }
; 5837 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
; 5838 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
; 5839 :    sz = stbi__get8(s);   //   bits per pixel
; 5840 :    if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
; 5841 :    if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
; 5842 : 
; 5843 :    res = 1; // if we got this far, everything's good and we can return 1 instead of 0
; 5844 : 
; 5845 : errorEnd:
; 5846 :    stbi__rewind(s);
; 5847 :    return res;
; 5848 : }
; 5849 : 
; 5850 : // read 16bit value and convert to 24bit RGB
; 5851 : static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
; 5852 : {
; 5853 :    stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
; 5854 :    stbi__uint16 fiveBitMask = 31;
; 5855 :    // we have 3 channels with 5bits each
; 5856 :    int r = (px >> 10) & fiveBitMask;
; 5857 :    int g = (px >> 5) & fiveBitMask;
; 5858 :    int b = px & fiveBitMask;
; 5859 :    // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
; 5860 :    out[0] = (stbi_uc)((r * 255)/31);
; 5861 :    out[1] = (stbi_uc)((g * 255)/31);
; 5862 :    out[2] = (stbi_uc)((b * 255)/31);
; 5863 : 
; 5864 :    // some people claim that the most significant bit might be used for alpha
; 5865 :    // (possibly if an alpha-bit is set in the "image descriptor byte")
; 5866 :    // but that only made 16bit test images completely translucent..
; 5867 :    // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
; 5868 : }
; 5869 : 
; 5870 : static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5871 : {
; 5872 :    //   read in the TGA header stuff
; 5873 :    int tga_offset = stbi__get8(s);
; 5874 :    int tga_indexed = stbi__get8(s);
; 5875 :    int tga_image_type = stbi__get8(s);
; 5876 :    int tga_is_RLE = 0;
; 5877 :    int tga_palette_start = stbi__get16le(s);
; 5878 :    int tga_palette_len = stbi__get16le(s);
; 5879 :    int tga_palette_bits = stbi__get8(s);
; 5880 :    int tga_x_origin = stbi__get16le(s);
; 5881 :    int tga_y_origin = stbi__get16le(s);
; 5882 :    int tga_width = stbi__get16le(s);
; 5883 :    int tga_height = stbi__get16le(s);
; 5884 :    int tga_bits_per_pixel = stbi__get8(s);
; 5885 :    int tga_comp, tga_rgb16=0;
; 5886 :    int tga_inverted = stbi__get8(s);
; 5887 :    // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
; 5888 :    //   image data
; 5889 :    unsigned char *tga_data;
; 5890 :    unsigned char *tga_palette = NULL;
; 5891 :    int i, j;
; 5892 :    unsigned char raw_data[4] = {0};
; 5893 :    int RLE_count = 0;
; 5894 :    int RLE_repeating = 0;
; 5895 :    int read_next_pixel = 1;
; 5896 :    STBI_NOTUSED(ri);
; 5897 :    STBI_NOTUSED(tga_x_origin); // @TODO
; 5898 :    STBI_NOTUSED(tga_y_origin); // @TODO
; 5899 : 
; 5900 :    if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5901 :    if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5902 : 
; 5903 :    //   do a tiny bit of precessing
; 5904 :    if ( tga_image_type >= 8 )
; 5905 :    {
; 5906 :       tga_image_type -= 8;
; 5907 :       tga_is_RLE = 1;
; 5908 :    }
; 5909 :    tga_inverted = 1 - ((tga_inverted >> 5) & 1);
; 5910 : 
; 5911 :    //   If I'm paletted, then I'll use the number of bits from the palette
; 5912 :    if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
; 5913 :    else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);
; 5914 : 
; 5915 :    if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
; 5916 :       return stbi__errpuc("bad format", "Can't find out TGA pixelformat");
; 5917 : 
; 5918 :    //   tga info
; 5919 :    *x = tga_width;
; 5920 :    *y = tga_height;
; 5921 :    if (comp) *comp = tga_comp;
; 5922 : 
; 5923 :    if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
; 5924 :       return stbi__errpuc("too large", "Corrupt TGA");
; 5925 : 
; 5926 :    tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
; 5927 :    if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");
; 5928 : 
; 5929 :    // skip to the data's starting position (offset usually = 0)
; 5930 :    stbi__skip(s, tga_offset );
; 5931 : 
; 5932 :    if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
; 5933 :       for (i=0; i < tga_height; ++i) {
; 5934 :          int row = tga_inverted ? tga_height -i - 1 : i;
; 5935 :          stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
; 5936 :          stbi__getn(s, tga_row, tga_width * tga_comp);
; 5937 :       }
; 5938 :    } else  {
; 5939 :       //   do I need to load a palette?
; 5940 :       if ( tga_indexed)
; 5941 :       {
; 5942 :          if (tga_palette_len == 0) {  /* you have to have at least one entry! */
; 5943 :             STBI_FREE(tga_data);
; 5944 :             return stbi__errpuc("bad palette", "Corrupt TGA");
; 5945 :          }
; 5946 : 
; 5947 :          //   any data to skip? (offset usually = 0)
; 5948 :          stbi__skip(s, tga_palette_start );
; 5949 :          //   load the palette
; 5950 :          tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
; 5951 :          if (!tga_palette) {
; 5952 :             STBI_FREE(tga_data);
; 5953 :             return stbi__errpuc("outofmem", "Out of memory");
; 5954 :          }
; 5955 :          if (tga_rgb16) {
; 5956 :             stbi_uc *pal_entry = tga_palette;
; 5957 :             STBI_ASSERT(tga_comp == STBI_rgb);
; 5958 :             for (i=0; i < tga_palette_len; ++i) {
; 5959 :                stbi__tga_read_rgb16(s, pal_entry);
; 5960 :                pal_entry += tga_comp;
; 5961 :             }
; 5962 :          } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
; 5963 :                STBI_FREE(tga_data);
; 5964 :                STBI_FREE(tga_palette);
; 5965 :                return stbi__errpuc("bad palette", "Corrupt TGA");
; 5966 :          }
; 5967 :       }
; 5968 :       //   load the data
; 5969 :       for (i=0; i < tga_width * tga_height; ++i)
; 5970 :       {
; 5971 :          //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
; 5972 :          if ( tga_is_RLE )
; 5973 :          {
; 5974 :             if ( RLE_count == 0 )
; 5975 :             {
; 5976 :                //   yep, get the next byte as a RLE command
; 5977 :                int RLE_cmd = stbi__get8(s);
; 5978 :                RLE_count = 1 + (RLE_cmd & 127);
; 5979 :                RLE_repeating = RLE_cmd >> 7;
; 5980 :                read_next_pixel = 1;
; 5981 :             } else if ( !RLE_repeating )
; 5982 :             {
; 5983 :                read_next_pixel = 1;
; 5984 :             }
; 5985 :          } else
; 5986 :          {
; 5987 :             read_next_pixel = 1;
; 5988 :          }
; 5989 :          //   OK, if I need to read a pixel, do it now
; 5990 :          if ( read_next_pixel )
; 5991 :          {
; 5992 :             //   load however much data we did have
; 5993 :             if ( tga_indexed )
; 5994 :             {
; 5995 :                // read in index, then perform the lookup
; 5996 :                int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
; 5997 :                if ( pal_idx >= tga_palette_len ) {
; 5998 :                   // invalid index
; 5999 :                   pal_idx = 0;
; 6000 :                }
; 6001 :                pal_idx *= tga_comp;
; 6002 :                for (j = 0; j < tga_comp; ++j) {
; 6003 :                   raw_data[j] = tga_palette[pal_idx+j];
; 6004 :                }
; 6005 :             } else if(tga_rgb16) {
; 6006 :                STBI_ASSERT(tga_comp == STBI_rgb);
; 6007 :                stbi__tga_read_rgb16(s, raw_data);
; 6008 :             } else {
; 6009 :                //   read in the data raw
; 6010 :                for (j = 0; j < tga_comp; ++j) {
; 6011 :                   raw_data[j] = stbi__get8(s);
; 6012 :                }
; 6013 :             }
; 6014 :             //   clear the reading flag for the next pixel
; 6015 :             read_next_pixel = 0;
; 6016 :          } // end of reading a pixel
; 6017 : 
; 6018 :          // copy data
; 6019 :          for (j = 0; j < tga_comp; ++j)
; 6020 :            tga_data[i*tga_comp+j] = raw_data[j];
; 6021 : 
; 6022 :          //   in case we're in RLE mode, keep counting down
; 6023 :          --RLE_count;
; 6024 :       }
; 6025 :       //   do I need to invert the image?
; 6026 :       if ( tga_inverted )
; 6027 :       {
; 6028 :          for (j = 0; j*2 < tga_height; ++j)
; 6029 :          {
; 6030 :             int index1 = j * tga_width * tga_comp;
; 6031 :             int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
; 6032 :             for (i = tga_width * tga_comp; i > 0; --i)
; 6033 :             {
; 6034 :                unsigned char temp = tga_data[index1];
; 6035 :                tga_data[index1] = tga_data[index2];
; 6036 :                tga_data[index2] = temp;
; 6037 :                ++index1;
; 6038 :                ++index2;
; 6039 :             }
; 6040 :          }
; 6041 :       }
; 6042 :       //   clear my palette, if I had one
; 6043 :       if ( tga_palette != NULL )
; 6044 :       {
; 6045 :          STBI_FREE( tga_palette );
; 6046 :       }
; 6047 :    }
; 6048 : 
; 6049 :    // swap RGB - if the source data was RGB16, it already is in the right order
; 6050 :    if (tga_comp >= 3 && !tga_rgb16)
; 6051 :    {
; 6052 :       unsigned char* tga_pixel = tga_data;
; 6053 :       for (i=0; i < tga_width * tga_height; ++i)
; 6054 :       {
; 6055 :          unsigned char temp = tga_pixel[0];
; 6056 :          tga_pixel[0] = tga_pixel[2];
; 6057 :          tga_pixel[2] = temp;
; 6058 :          tga_pixel += tga_comp;
; 6059 :       }
; 6060 :    }
; 6061 : 
; 6062 :    // convert to target component count
; 6063 :    if (req_comp && req_comp != tga_comp)
; 6064 :       tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);
; 6065 : 
; 6066 :    //   the things I do to get rid of an error message, and yet keep
; 6067 :    //   Microsoft's C compilers happy... [8^(
; 6068 :    tga_palette_start = tga_palette_len = tga_palette_bits =
; 6069 :          tga_x_origin = tga_y_origin = 0;
; 6070 :    STBI_NOTUSED(tga_palette_start);
; 6071 :    //   OK, done
; 6072 :    return tga_data;
; 6073 : }
; 6074 : #endif
; 6075 : 
; 6076 : // *************************************************************************************************
; 6077 : // Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB
; 6078 : 
; 6079 : #ifndef STBI_NO_PSD
; 6080 : static int stbi__psd_test(stbi__context *s)
; 6081 : {
; 6082 :    int r = (stbi__get32be(s) == 0x38425053);
; 6083 :    stbi__rewind(s);
; 6084 :    return r;
; 6085 : }
; 6086 : 
; 6087 : static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
; 6088 : {
; 6089 :    int count, nleft, len;
; 6090 : 
; 6091 :    count = 0;
; 6092 :    while ((nleft = pixelCount - count) > 0) {
; 6093 :       len = stbi__get8(s);
; 6094 :       if (len == 128) {
; 6095 :          // No-op.
; 6096 :       } else if (len < 128) {
; 6097 :          // Copy next len+1 bytes literally.
; 6098 :          len++;
; 6099 :          if (len > nleft) return 0; // corrupt data
; 6100 :          count += len;
; 6101 :          while (len) {
; 6102 :             *p = stbi__get8(s);
; 6103 :             p += 4;
; 6104 :             len--;
; 6105 :          }
; 6106 :       } else if (len > 128) {
; 6107 :          stbi_uc   val;
; 6108 :          // Next -len+1 bytes in the dest are replicated from next source byte.
; 6109 :          // (Interpret len as a negative 8-bit int.)
; 6110 :          len = 257 - len;
; 6111 :          if (len > nleft) return 0; // corrupt data
; 6112 :          val = stbi__get8(s);
; 6113 :          count += len;
; 6114 :          while (len) {
; 6115 :             *p = val;
; 6116 :             p += 4;
; 6117 :             len--;
; 6118 :          }
; 6119 :       }
; 6120 :    }
; 6121 : 
; 6122 :    return 1;
; 6123 : }
; 6124 : 
; 6125 : static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
; 6126 : {
; 6127 :    int pixelCount;
; 6128 :    int channelCount, compression;
; 6129 :    int channel, i;
; 6130 :    int bitdepth;
; 6131 :    int w,h;
; 6132 :    stbi_uc *out;
; 6133 :    STBI_NOTUSED(ri);
; 6134 : 
; 6135 :    // Check identifier
; 6136 :    if (stbi__get32be(s) != 0x38425053)   // "8BPS"
; 6137 :       return stbi__errpuc("not PSD", "Corrupt PSD image");
; 6138 : 
; 6139 :    // Check file type version.
; 6140 :    if (stbi__get16be(s) != 1)
; 6141 :       return stbi__errpuc("wrong version", "Unsupported version of PSD image");
; 6142 : 
; 6143 :    // Skip 6 reserved bytes.
; 6144 :    stbi__skip(s, 6 );
; 6145 : 
; 6146 :    // Read the number of channels (R, G, B, A, etc).
; 6147 :    channelCount = stbi__get16be(s);
; 6148 :    if (channelCount < 0 || channelCount > 16)
; 6149 :       return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");
; 6150 : 
; 6151 :    // Read the rows and columns of the image.
; 6152 :    h = stbi__get32be(s);
; 6153 :    w = stbi__get32be(s);
; 6154 : 
; 6155 :    if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 6156 :    if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 6157 : 
; 6158 :    // Make sure the depth is 8 bits.
; 6159 :    bitdepth = stbi__get16be(s);
; 6160 :    if (bitdepth != 8 && bitdepth != 16)
; 6161 :       return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");
; 6162 : 
; 6163 :    // Make sure the color mode is RGB.
; 6164 :    // Valid options are:
; 6165 :    //   0: Bitmap
; 6166 :    //   1: Grayscale
; 6167 :    //   2: Indexed color
; 6168 :    //   3: RGB color
; 6169 :    //   4: CMYK color
; 6170 :    //   7: Multichannel
; 6171 :    //   8: Duotone
; 6172 :    //   9: Lab color
; 6173 :    if (stbi__get16be(s) != 3)
; 6174 :       return stbi__errpuc("wrong color format", "PSD is not in RGB color format");
; 6175 : 
; 6176 :    // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
; 6177 :    stbi__skip(s,stbi__get32be(s) );
; 6178 : 
; 6179 :    // Skip the image resources.  (resolution, pen tool paths, etc)
; 6180 :    stbi__skip(s, stbi__get32be(s) );
; 6181 : 
; 6182 :    // Skip the reserved data.
; 6183 :    stbi__skip(s, stbi__get32be(s) );
; 6184 : 
; 6185 :    // Find out if the data is compressed.
; 6186 :    // Known values:
; 6187 :    //   0: no compression
; 6188 :    //   1: RLE compressed
; 6189 :    compression = stbi__get16be(s);
; 6190 :    if (compression > 1)
; 6191 :       return stbi__errpuc("bad compression", "PSD has an unknown compression format");
; 6192 : 
; 6193 :    // Check size
; 6194 :    if (!stbi__mad3sizes_valid(4, w, h, 0))
; 6195 :       return stbi__errpuc("too large", "Corrupt PSD");
; 6196 : 
; 6197 :    // Create the destination image.
; 6198 : 
; 6199 :    if (!compression && bitdepth == 16 && bpc == 16) {
; 6200 :       out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
; 6201 :       ri->bits_per_channel = 16;
; 6202 :    } else
; 6203 :       out = (stbi_uc *) stbi__malloc(4 * w*h);
; 6204 : 
; 6205 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");
; 6206 :    pixelCount = w*h;
; 6207 : 
; 6208 :    // Initialize the data to zero.
; 6209 :    //memset( out, 0, pixelCount * 4 );
; 6210 : 
; 6211 :    // Finally, the image data.
; 6212 :    if (compression) {
; 6213 :       // RLE as used by .PSD and .TIFF
; 6214 :       // Loop until you get the number of unpacked bytes you are expecting:
; 6215 :       //     Read the next source byte into n.
; 6216 :       //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
; 6217 :       //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
; 6218 :       //     Else if n is 128, noop.
; 6219 :       // Endloop
; 6220 : 
; 6221 :       // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
; 6222 :       // which we're going to just skip.
; 6223 :       stbi__skip(s, h * channelCount * 2 );
; 6224 : 
; 6225 :       // Read the RLE data by channel.
; 6226 :       for (channel = 0; channel < 4; channel++) {
; 6227 :          stbi_uc *p;
; 6228 : 
; 6229 :          p = out+channel;
; 6230 :          if (channel >= channelCount) {
; 6231 :             // Fill this channel with default data.
; 6232 :             for (i = 0; i < pixelCount; i++, p += 4)
; 6233 :                *p = (channel == 3 ? 255 : 0);
; 6234 :          } else {
; 6235 :             // Read the RLE data.
; 6236 :             if (!stbi__psd_decode_rle(s, p, pixelCount)) {
; 6237 :                STBI_FREE(out);
; 6238 :                return stbi__errpuc("corrupt", "bad RLE data");
; 6239 :             }
; 6240 :          }
; 6241 :       }
; 6242 : 
; 6243 :    } else {
; 6244 :       // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
; 6245 :       // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.
; 6246 : 
; 6247 :       // Read the data by channel.
; 6248 :       for (channel = 0; channel < 4; channel++) {
; 6249 :          if (channel >= channelCount) {
; 6250 :             // Fill this channel with default data.
; 6251 :             if (bitdepth == 16 && bpc == 16) {
; 6252 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
; 6253 :                stbi__uint16 val = channel == 3 ? 65535 : 0;
; 6254 :                for (i = 0; i < pixelCount; i++, q += 4)
; 6255 :                   *q = val;
; 6256 :             } else {
; 6257 :                stbi_uc *p = out+channel;
; 6258 :                stbi_uc val = channel == 3 ? 255 : 0;
; 6259 :                for (i = 0; i < pixelCount; i++, p += 4)
; 6260 :                   *p = val;
; 6261 :             }
; 6262 :          } else {
; 6263 :             if (ri->bits_per_channel == 16) {    // output bpc
; 6264 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
; 6265 :                for (i = 0; i < pixelCount; i++, q += 4)
; 6266 :                   *q = (stbi__uint16) stbi__get16be(s);
; 6267 :             } else {
; 6268 :                stbi_uc *p = out+channel;
; 6269 :                if (bitdepth == 16) {  // input bpc
; 6270 :                   for (i = 0; i < pixelCount; i++, p += 4)
; 6271 :                      *p = (stbi_uc) (stbi__get16be(s) >> 8);
; 6272 :                } else {
; 6273 :                   for (i = 0; i < pixelCount; i++, p += 4)
; 6274 :                      *p = stbi__get8(s);
; 6275 :                }
; 6276 :             }
; 6277 :          }
; 6278 :       }
; 6279 :    }
; 6280 : 
; 6281 :    // remove weird white matte from PSD
; 6282 :    if (channelCount >= 4) {
; 6283 :       if (ri->bits_per_channel == 16) {
; 6284 :          for (i=0; i < w*h; ++i) {
; 6285 :             stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
; 6286 :             if (pixel[3] != 0 && pixel[3] != 65535) {
; 6287 :                float a = pixel[3] / 65535.0f;
; 6288 :                float ra = 1.0f / a;
; 6289 :                float inv_a = 65535.0f * (1 - ra);
; 6290 :                pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
; 6291 :                pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
; 6292 :                pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
; 6293 :             }
; 6294 :          }
; 6295 :       } else {
; 6296 :          for (i=0; i < w*h; ++i) {
; 6297 :             unsigned char *pixel = out + 4*i;
; 6298 :             if (pixel[3] != 0 && pixel[3] != 255) {
; 6299 :                float a = pixel[3] / 255.0f;
; 6300 :                float ra = 1.0f / a;
; 6301 :                float inv_a = 255.0f * (1 - ra);
; 6302 :                pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
; 6303 :                pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
; 6304 :                pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
; 6305 :             }
; 6306 :          }
; 6307 :       }
; 6308 :    }
; 6309 : 
; 6310 :    // convert to desired output format
; 6311 :    if (req_comp && req_comp != 4) {
; 6312 :       if (ri->bits_per_channel == 16)
; 6313 :          out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
; 6314 :       else
; 6315 :          out = stbi__convert_format(out, 4, req_comp, w, h);
; 6316 :       if (out == NULL) return out; // stbi__convert_format frees input on failure
; 6317 :    }
; 6318 : 
; 6319 :    if (comp) *comp = 4;
; 6320 :    *y = h;
; 6321 :    *x = w;
; 6322 : 
; 6323 :    return out;
; 6324 : }
; 6325 : #endif
; 6326 : 
; 6327 : // *************************************************************************************************
; 6328 : // Softimage PIC loader
; 6329 : // by Tom Seddon
; 6330 : //
; 6331 : // See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
; 6332 : // See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/
; 6333 : 
; 6334 : #ifndef STBI_NO_PIC
; 6335 : static int stbi__pic_is4(stbi__context *s,const char *str)
; 6336 : {
; 6337 :    int i;
; 6338 :    for (i=0; i<4; ++i)
; 6339 :       if (stbi__get8(s) != (stbi_uc)str[i])
; 6340 :          return 0;
; 6341 : 
; 6342 :    return 1;
; 6343 : }
; 6344 : 
; 6345 : static int stbi__pic_test_core(stbi__context *s)
; 6346 : {
; 6347 :    int i;
; 6348 : 
; 6349 :    if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
; 6350 :       return 0;
; 6351 : 
; 6352 :    for(i=0;i<84;++i)
; 6353 :       stbi__get8(s);
; 6354 : 
; 6355 :    if (!stbi__pic_is4(s,"PICT"))
; 6356 :       return 0;
; 6357 : 
; 6358 :    return 1;
; 6359 : }
; 6360 : 
; 6361 : typedef struct
; 6362 : {
; 6363 :    stbi_uc size,type,channel;
; 6364 : } stbi__pic_packet;
; 6365 : 
; 6366 : static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
; 6367 : {
; 6368 :    int mask=0x80, i;
; 6369 : 
; 6370 :    for (i=0; i<4; ++i, mask>>=1) {
; 6371 :       if (channel & mask) {
; 6372 :          if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
; 6373 :          dest[i]=stbi__get8(s);
; 6374 :       }
; 6375 :    }
; 6376 : 
; 6377 :    return dest;
; 6378 : }
; 6379 : 
; 6380 : static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
; 6381 : {
; 6382 :    int mask=0x80,i;
; 6383 : 
; 6384 :    for (i=0;i<4; ++i, mask>>=1)
; 6385 :       if (channel&mask)

	test	sil, 16
	je	SHORT $LN161@stbi__pic_

; 6386 :          dest[i]=src[i];

	mov	BYTE PTR [rbx+3], dl
$LN161@stbi__pic_:

; 6451 : 
; 6452 :                      for(i=0; i<count; ++i,dest+=4)

	add	rbx, 4
	sub	rcx, 1
	jne	SHORT $LL20@stbi__pic_
$LN19@stbi__pic_:

; 6453 :                         stbi__copyval(packet->channel,dest,value);
; 6454 :                      left -= count;

	sub	r14d, r10d
	test	r14d, r14d
	jg	$LL16@stbi__pic_

; 6440 : 
; 6441 :                   while (left>0) {

	mov	ebp, DWORD PTR width$GSCopy$1$[rsp]
	jmp	SHORT $LN8@stbi__pic_
$LN33@stbi__pic_:

; 6425 :             default:
; 6426 :                return stbi__errpuc("bad format","packet has bad compression type");
; 6427 : 
; 6428 :             case 0: {//uncompressed
; 6429 :                int x;
; 6430 : 
; 6431 :                for(x=0;x<width;++x, dest+=4)

	xor	edi, edi
	test	ebp, ebp
	jle	SHORT $LN8@stbi__pic_
	movzx	esi, BYTE PTR [r15]
	npad	6
$LL15@stbi__pic_:

; 6432 :                   if (!stbi__readval(s,packet->channel,dest))

	mov	r8, rbx
	mov	edx, esi
	mov	rcx, r13
	call	?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ; stbi__readval
	test	rax, rax
	je	$LN139@stbi__pic_

; 6425 :             default:
; 6426 :                return stbi__errpuc("bad format","packet has bad compression type");
; 6427 : 
; 6428 :             case 0: {//uncompressed
; 6429 :                int x;
; 6430 : 
; 6431 :                for(x=0;x<width;++x, dest+=4)

	inc	edi
	add	rbx, 4
	cmp	edi, ebp
	jl	SHORT $LL15@stbi__pic_
$LN8@stbi__pic_:

; 6418 :       int packet_idx;
; 6419 : 
; 6420 :       for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {

	mov	rax, QWORD PTR $T2[rsp]
	add	r15, 3
	inc	rax
	cmp	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR $T2[rsp], rax
	mov	rax, QWORD PTR tv1744[rsp]
	jl	$LL10@stbi__pic_
	mov	rax, QWORD PTR $T1[rsp]
	lea	r8d, DWORD PTR [rbp*4]
	mov	ecx, DWORD PTR y$1$[rsp]
	mov	edx, DWORD PTR tv1729[rsp]
	mov	r9d, DWORD PTR height$1$[rsp]
$LN5@stbi__pic_:

; 6416 : 
; 6417 :    for(y=0; y<height; ++y) {

	inc	ecx
	add	edx, r8d
	mov	DWORD PTR y$1$[rsp], ecx
	mov	DWORD PTR tv1729[rsp], edx
	cmp	ecx, r9d
	jl	$LL7@stbi__pic_
$LN202@stbi__pic_:

; 6489 :                }
; 6490 :                break;
; 6491 :             }
; 6492 :          }
; 6493 :       }
; 6494 :    }
; 6495 : 
; 6496 :    return result;

	mov	rax, QWORD PTR result$GSCopy$1$[rsp]
	jmp	SHORT $LN1@stbi__pic_
$LN134@stbi__pic_:

; 6497 : }

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08GGMBIFE@bad?5file@
	jmp	SHORT $LN263@stbi__pic_
$LN128@stbi__pic_:
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0L@DMAPJJO@bad?5format@
$LN263@stbi__pic_:
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	QWORD PTR [rdx+rcx], rax
$LN139@stbi__pic_:
	xor	eax, eax
$LN1@stbi__pic_:
	mov	r12, QWORD PTR [rsp+128]
	mov	rdi, QWORD PTR [rsp+136]
	mov	rsi, QWORD PTR [rsp+144]
	mov	rbx, QWORD PTR [rsp+208]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 152				; 00000098H
	pop	r15
	pop	r14
	pop	r13
	pop	rbp
	ret	0
?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z ENDP ; stbi__pic_load_core
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
_TEXT	SEGMENT
internal_comp$ = 48
__$ArrayPad$ = 56
s$ = 144
px$ = 152
py$ = 160
comp$ = 168
req_comp$dead$ = 176
ri$dead$ = 184
?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__pic_load, COMDAT

; 6500 : {

	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r15
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 6501 :    stbi_uc *result;
; 6502 :    int i, x,y, internal_comp;
; 6503 :    STBI_NOTUSED(ri);
; 6504 : 
; 6505 :    if (!comp) comp = &internal_comp;
; 6506 : 
; 6507 :    for (i=0; i<92; ++i)

	test	r9, r9
	lea	r15, QWORD PTR internal_comp$[rsp]
	mov	r13, r8
	mov	r12, rdx
	cmovne	r15, r9
	mov	rbx, rcx
	mov	edi, 92					; 0000005cH
	npad	9
$LL4@stbi__pic_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN15@stbi__pic_

; 1615 :       return *s->img_buffer++;

	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN2@stbi__pic_
$LN15@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN2@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	inc	QWORD PTR [rbx+192]
$LN2@stbi__pic_:

; 6501 :    stbi_uc *result;
; 6502 :    int i, x,y, internal_comp;
; 6503 :    STBI_NOTUSED(ri);
; 6504 : 
; 6505 :    if (!comp) comp = &internal_comp;
; 6506 : 
; 6507 :    for (i=0; i<92; ++i)

	sub	rdi, 1
	jne	SHORT $LL4@stbi__pic_

; 6508 :       stbi__get8(s);
; 6509 : 
; 6510 :    x = stbi__get16be(s);

	mov	rcx, rbx
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 6511 :    y = stbi__get16be(s);

	mov	rcx, rbx
	mov	esi, eax
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	edi, eax

; 6512 : 
; 6513 :    if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

	cmp	eax, 16777216				; 01000000H
	jle	SHORT $LN6@stbi__pic_
$LN108@stbi__pic_:

; 6538 : }

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
	mov	QWORD PTR [rdx+rcx], rax
	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN6@stbi__pic_:

; 6514 :    if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

	cmp	esi, 16777216				; 01000000H
	jg	SHORT $LN108@stbi__pic_

; 1628 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], 0
	je	SHORT $LN25@stbi__pic_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	rax, QWORD PTR [rbx+32]
	mov	rcx, QWORD PTR [rbx+40]
	call	rax
	test	eax, eax
	je	SHORT $LN8@stbi__pic_

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN85@stbi__pic_
$LN25@stbi__pic_:

; 6515 : 
; 6516 :    if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");

	mov	rax, QWORD PTR [rbx+200]
	cmp	QWORD PTR [rbx+192], rax
	jb	SHORT $LN8@stbi__pic_
$LN85@stbi__pic_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08GGMBIFE@bad?5file@
	mov	QWORD PTR [rdx+rcx], rax

; 6515 : 
; 6516 :    if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");

	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN8@stbi__pic_:

; 1014 :    if (a < 0 || b < 0) return 0;

	test	esi, esi
	js	SHORT $LN108@stbi__pic_
	test	edi, edi
	js	$LN108@stbi__pic_

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN84@stbi__pic_

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	edi

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	esi, eax
	jg	$LN108@stbi__pic_
$LN84@stbi__pic_:
	mov	eax, edi
	imul	eax, esi

; 1014 :    if (a < 0 || b < 0) return 0;

	test	eax, eax
	js	$LN108@stbi__pic_

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	eax, 536870911				; 1fffffffH
	jg	$LN108@stbi__pic_
	mov	QWORD PTR [rsp+80], rbp
	mov	rcx, rbx
	mov	QWORD PTR [rsp+72], r14
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	rcx, rbx
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	rcx, rbx
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	rcx, rbx
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	test	edi, edi
	jne	SHORT $LN60@stbi__pic_
	mov	eax, esi
	imul	eax, edi
	jmp	SHORT $LN87@stbi__pic_
$LN60@stbi__pic_:

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	edi

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	esi, eax
	jg	SHORT $LN79@stbi__pic_
	mov	eax, edi
	imul	eax, esi
$LN87@stbi__pic_:

; 1056 :    return stbi__malloc(a*b*c + add);

	lea	eax, DWORD PTR [rax*4]
	movsxd	r14, eax

; 985  :     return STBI_MALLOC(size);

	mov	rcx, r14
	call	QWORD PTR __imp_malloc
	mov	rbp, rax

; 6517 :    if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");
; 6518 : 
; 6519 :    stbi__get32be(s); //skip `ratio'
; 6520 :    stbi__get16be(s); //skip `fields'
; 6521 :    stbi__get16be(s); //skip `pad'
; 6522 : 
; 6523 :    // intermediate buffer is RGBA
; 6524 :    result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
; 6525 :    if (!result) return stbi__errpuc("outofmem", "Out of memory");

	test	rax, rax
	je	SHORT $LN79@stbi__pic_

; 6526 :    memset(result, 0xff, x*y*4);

	mov	r8, r14
	mov	edx, 255				; 000000ffH
	mov	rcx, rax
	call	memset

; 6527 : 
; 6528 :    if (!stbi__pic_load_core(s,x,y,comp, result)) {

	mov	r9, r15
	mov	QWORD PTR [rsp+32], rbp
	mov	r8d, edi
	mov	edx, esi
	mov	rcx, rbx
	call	?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z ; stbi__pic_load_core
	test	rax, rax
	jne	SHORT $LN11@stbi__pic_

; 6529 :       STBI_FREE(result);

	mov	rcx, rbp
	call	QWORD PTR __imp_free

; 6530 :       result=0;

	xor	ebp, ebp
$LN11@stbi__pic_:

; 6531 :    }
; 6532 :    *px = x;
; 6533 :    *py = y;
; 6534 :    if (req_comp == 0) req_comp = *comp;
; 6535 :    result=stbi__convert_format(result,4,req_comp,x,y);

	mov	edx, 4
	mov	DWORD PTR [r12], esi
	mov	r8d, edx
	mov	DWORD PTR [r13], edi
	mov	r9d, esi
	mov	DWORD PTR [rsp+32], edi
	mov	rcx, rbp
	call	?stbi__convert_format@@YAPEAEPEAEHHII@Z	; stbi__convert_format

; 6536 : 
; 6537 :    return result;

	jmp	SHORT $LN107@stbi__pic_
$LN79@stbi__pic_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
	mov	QWORD PTR [rdx+rcx], rax

; 6517 :    if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");
; 6518 : 
; 6519 :    stbi__get32be(s); //skip `ratio'
; 6520 :    stbi__get16be(s); //skip `fields'
; 6521 :    stbi__get16be(s); //skip `pad'
; 6522 : 
; 6523 :    // intermediate buffer is RGBA
; 6524 :    result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
; 6525 :    if (!result) return stbi__errpuc("outofmem", "Out of memory");

	xor	eax, eax
$LN107@stbi__pic_:
	mov	rbp, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+72]
$LN1@stbi__pic_:

; 6538 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 88					; 00000058H
	pop	r15
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__pic_load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__pic_test@@YAHPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__pic_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__pic_test, COMDAT

; 6541 : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 6349 :    if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))

	lea	rdx, OFFSET FLAT:??_C@_04KBFEPHFH@S?$IA?v4@

; 6541 : {

	mov	rbx, rcx

; 6349 :    if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))

	call	?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ; stbi__pic_is4
	test	eax, eax
	jne	SHORT $LN7@stbi__pic_
$LN26@stbi__pic_:

; 889  :    s->img_buffer = s->img_buffer_original;

	xor	r8d, r8d
	jmp	SHORT $LN25@stbi__pic_
$LN7@stbi__pic_:
	mov	QWORD PTR [rsp+48], rdi

; 6352 :    for(i=0;i<84;++i)

	mov	edi, 84					; 00000054H
	npad	8
$LL6@stbi__pic_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN11@stbi__pic_

; 1615 :       return *s->img_buffer++;

	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN4@stbi__pic_
$LN11@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN4@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	inc	QWORD PTR [rbx+192]
$LN4@stbi__pic_:

; 6352 :    for(i=0;i<84;++i)

	sub	rdi, 1
	jne	SHORT $LL6@stbi__pic_
	mov	rdi, QWORD PTR [rsp+48]

; 6353 :       stbi__get8(s);
; 6354 : 
; 6355 :    if (!stbi__pic_is4(s,"PICT"))

	lea	rdx, OFFSET FLAT:??_C@_04ELNJHLFH@PICT@
	mov	rcx, rbx
	call	?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ; stbi__pic_is4
	test	eax, eax
	je	SHORT $LN26@stbi__pic_

; 6356 :       return 0;
; 6357 : 
; 6358 :    return 1;

	mov	r8d, 1
$LN25@stbi__pic_:

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	rcx, QWORD PTR [rbx+208]
	mov	eax, 200				; 000000c8H
	mov	edx, 192				; 000000c0H
	mov	QWORD PTR [rdx+rbx], rcx

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	rcx, QWORD PTR [rbx+216]
	mov	QWORD PTR [rax+rbx], rcx

; 6542 :    int r = stbi__pic_test_core(s);
; 6543 :    stbi__rewind(s);
; 6544 :    return r;

	mov	eax, r8d

; 6545 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stbi__pic_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__pic_test
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z PROC	; stbi__gif_test_raw, COMDAT

; 6580 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rcx+192]

; 6580 : {

	mov	rbx, rcx

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rcx+200]
	jb	SHORT $LN52@stbi__gif_

; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rcx+48], 0
	je	$LN3@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN52@stbi__gif_:

; 6581 :    int sz;
; 6582 :    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 71					; 00000047H
	jne	$LN3@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN53@stbi__gif_

; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	$LN3@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN53@stbi__gif_:

; 6581 :    int sz;
; 6582 :    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 73					; 00000049H
	jne	$LN3@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN54@stbi__gif_

; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	$LN3@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN54@stbi__gif_:

; 6581 :    int sz;
; 6582 :    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 70					; 00000046H
	jne	$LN3@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN55@stbi__gif_

; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	$LN3@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN55@stbi__gif_:

; 6581 :    int sz;
; 6582 :    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 56					; 00000038H
	jne	SHORT $LN3@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN56@stbi__gif_

; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN3@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN56@stbi__gif_:

; 6583 :    sz = stbi__get8(s);
; 6584 :    if (sz != '9' && sz != '7') return 0;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 57					; 00000039H
	je	SHORT $LN4@stbi__gif_
	cmp	cl, 55					; 00000037H
	jne	SHORT $LN3@stbi__gif_
$LN4@stbi__gif_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN57@stbi__gif_

; 1615 :       return *s->img_buffer++;
; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN3@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN57@stbi__gif_:

; 6585 :    if (stbi__get8(s) != 'a') return 0;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 97					; 00000061H
	jne	SHORT $LN3@stbi__gif_

; 6586 :    return 1;

	mov	eax, 1

; 6587 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@stbi__gif_:
	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z ENDP	; stbi__gif_test_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__gif_test@@YAHPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__gif_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__gif_test, COMDAT

; 6590 : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 6591 :    int r = stbi__gif_test_raw(s);

	call	?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z ; stbi__gif_test_raw

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	rdx, QWORD PTR [rbx+208]
	mov	QWORD PTR [rbx+192], rdx

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	rdx, QWORD PTR [rbx+216]
	mov	QWORD PTR [rbx+200], rdx

; 6592 :    stbi__rewind(s);
; 6593 :    return r;
; 6594 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stbi__gif_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__gif_test
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z
_TEXT	SEGMENT
s$ = 64
pal$ = 72
num_entries$ = 80
transp$ = 88
?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z PROC ; stbi__gif_parse_colortable, COMDAT

; 6598 :    int i;
; 6599 :    for (i=0; i < num_entries; ++i) {

	test	r8d, r8d
	jle	$LN29@stbi__gif_
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	xor	r15d, r15d
	mov	QWORD PTR [rsp+64], rdi
	mov	esi, r15d
	movsxd	rbp, r8d
	mov	r14d, r9d
	lea	rdi, QWORD PTR [rdx+1]
	mov	rbx, rcx
	npad	12
$LL4@stbi__gif_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN7@stbi__gif_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN6@stbi__gif_
$LN7@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], r15d
	je	SHORT $LN8@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN6@stbi__gif_
$LN8@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN6@stbi__gif_:

; 6600 :       pal[i][2] = stbi__get8(s);

	mov	BYTE PTR [rdi+1], cl

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN11@stbi__gif_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN10@stbi__gif_
$LN11@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], r15d
	je	SHORT $LN12@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN10@stbi__gif_
$LN12@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN10@stbi__gif_:

; 6601 :       pal[i][1] = stbi__get8(s);

	mov	BYTE PTR [rdi], cl

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN15@stbi__gif_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN14@stbi__gif_
$LN15@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], r15d
	je	SHORT $LN16@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN14@stbi__gif_
$LN16@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN14@stbi__gif_:

; 6602 :       pal[i][0] = stbi__get8(s);
; 6603 :       pal[i][3] = transp == i ? 0 : 255;

	cmp	r14d, esi
	mov	BYTE PTR [rdi-1], cl
	mov	eax, 255				; 000000ffH
	cmove	eax, r15d
	inc	esi
	mov	BYTE PTR [rdi+2], al
	add	rdi, 4
	sub	rbp, 1
	jne	$LL4@stbi__gif_

; 6604 :    }
; 6605 : }

	mov	rdi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
$LN29@stbi__gif_:
	ret	0
?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z ENDP ; stbi__gif_parse_colortable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
_TEXT	SEGMENT
s$ = 48
g$ = 56
comp$ = 64
is_info$dead$ = 72
?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z PROC ; stbi__gif_header, COMDAT

; 6608 : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r15
	sub	rsp, 32					; 00000020H

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rcx+192]

; 6608 : {

	mov	r15, r8
	mov	rsi, rdx
	mov	rbx, rcx

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rcx+200]
	jb	SHORT $LN92@stbi__gif_

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rcx+48], 0
	je	$LN60@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN92@stbi__gif_:

; 6609 :    stbi_uc version;
; 6610 :    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 71					; 00000047H
	jne	$LN60@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN93@stbi__gif_

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	$LN60@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN93@stbi__gif_:

; 6609 :    stbi_uc version;
; 6610 :    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 73					; 00000049H
	jne	$LN60@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN94@stbi__gif_

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	$LN60@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN94@stbi__gif_:

; 6609 :    stbi_uc version;
; 6610 :    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 70					; 00000046H
	jne	$LN60@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN95@stbi__gif_

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	$LN60@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN95@stbi__gif_:

; 6609 :    stbi_uc version;
; 6610 :    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 56					; 00000038H
	jne	$LN60@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN96@stbi__gif_

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	$LN60@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN96@stbi__gif_:

; 6611 :       return stbi__err("not GIF", "Corrupt GIF");
; 6612 : 
; 6613 :    version = stbi__get8(s);
; 6614 :    if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 55					; 00000037H
	je	SHORT $LN4@stbi__gif_
	cmp	cl, 57					; 00000039H
	jne	$LN60@stbi__gif_
$LN4@stbi__gif_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN97@stbi__gif_

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	$LN60@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN97@stbi__gif_:

; 6615 :    if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	cmp	cl, 97					; 00000061H
	jne	$LN58@stbi__gif_

; 6616 : 
; 6617 :    stbi__g_failure_reason = "";

	mov	rax, QWORD PTR gs:88

; 6618 :    g->w = stbi__get16le(s);

	mov	rcx, rbx
	mov	QWORD PTR [rsp+48], r14
	mov	r14, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	add	r14, rdx
	mov	QWORD PTR [r14], rax
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 6619 :    g->h = stbi__get16le(s);

	mov	rcx, rbx
	mov	DWORD PTR [rsi], eax
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	DWORD PTR [rsi+4], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN41@stbi__gif_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN40@stbi__gif_
$LN41@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN42@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN40@stbi__gif_
$LN42@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN40@stbi__gif_:

; 6620 :    g->flags = stbi__get8(s);

	movzx	eax, cl
	mov	DWORD PTR [rsi+32], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN45@stbi__gif_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN44@stbi__gif_
$LN45@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN46@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN44@stbi__gif_
$LN46@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN44@stbi__gif_:

; 6621 :    g->bgindex = stbi__get8(s);

	movzx	eax, cl
	mov	DWORD PTR [rsi+36], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN49@stbi__gif_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN48@stbi__gif_
$LN49@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN50@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN48@stbi__gif_
$LN50@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN48@stbi__gif_:

; 6622 :    g->ratio = stbi__get8(s);
; 6623 :    g->transparent = -1;
; 6624 : 
; 6625 :    if (g->w > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

	cmp	DWORD PTR [rsi], 16777216		; 01000000H
	movzx	eax, cl
	mov	DWORD PTR [rsi+40], eax
	mov	DWORD PTR [rsi+44], -1
	jg	SHORT $LN61@stbi__gif_

; 6626 :    if (g->h > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

	cmp	DWORD PTR [rsi+4], 16777216		; 01000000H
	jg	SHORT $LN61@stbi__gif_

; 6627 : 
; 6628 :    if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

	test	r15, r15
	je	SHORT $LN8@stbi__gif_
	mov	DWORD PTR [r15], 4
$LN8@stbi__gif_:

; 6629 : 
; 6630 :    if (is_info) return 1;
; 6631 : 
; 6632 :    if (g->flags & 0x80)

	mov	ecx, DWORD PTR [rsi+32]
	test	cl, cl
	jns	SHORT $LN10@stbi__gif_

; 6633 :       stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

	and	ecx, 7
	lea	rdx, QWORD PTR [rsi+52]
	mov	r8d, 2
	mov	r9d, -1
	shl	r8d, cl
	mov	rcx, rbx
	call	?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z ; stbi__gif_parse_colortable
$LN10@stbi__gif_:

; 6634 : 
; 6635 :    return 1;

	mov	eax, 1
$LN91@stbi__gif_:
	mov	r14, QWORD PTR [rsp+48]
$LN1@stbi__gif_:

; 6636 : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r15
	ret	0
$LN61@stbi__gif_:

; 978  :    stbi__g_failure_reason = str;

	lea	rax, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
	mov	QWORD PTR [r14], rax

; 6626 :    if (g->h > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

	xor	eax, eax
	jmp	SHORT $LN91@stbi__gif_
$LN60@stbi__gif_:

; 6636 : }

	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
$LN58@stbi__gif_:
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_07KMJLPAII@not?5GIF@
	mov	QWORD PTR [rdx+rcx], rax
	xor	eax, eax
	jmp	SHORT $LN1@stbi__gif_
?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z ENDP ; stbi__gif_header
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z
_TEXT	SEGMENT
g$ = 48
code$ = 56
?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z PROC		; stbi__out_gif_code, COMDAT

; 6654 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 6655 :    stbi_uc *p, *c;
; 6656 :    int idx;
; 6657 : 
; 6658 :    // recurse to decode the prefixes, since the linked-list is backwards,
; 6659 :    // and working backwards through an interleaved image would be nasty
; 6660 :    if (g->codes[code].prefix >= 0)

	movzx	edi, dx
	mov	rbx, rcx
	movzx	edx, WORD PTR [rcx+rdi*4+2100]
	test	dx, dx
	js	SHORT $LN4@stbi__out_

; 6661 :       stbi__out_gif_code(g, g->codes[code].prefix);

	call	?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z ; stbi__out_gif_code
$LN4@stbi__out_:

; 6662 : 
; 6663 :    if (g->cur_y >= g->max_y) return;

	mov	ecx, DWORD PTR [rbx+34912]
	cmp	ecx, DWORD PTR [rbx+34904]
	jge	$LN13@stbi__out_

; 6664 : 
; 6665 :    idx = g->cur_x + g->cur_y;

	mov	eax, DWORD PTR [rbx+34908]
	add	eax, ecx

; 6666 :    p = &g->out[idx];

	movsxd	r8, eax

; 6667 :    g->history[idx / 4] = 1;

	cdq
	add	r8, QWORD PTR [rbx+8]
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbx+24]
	mov	BYTE PTR [rcx+rax], 1

; 6668 : 
; 6669 :    c = &g->color_table[g->codes[code].suffix * 4];

	movzx	ecx, BYTE PTR [rbx+rdi*4+2103]
	mov	rax, QWORD PTR [rbx+34872]

; 6670 :    if (c[3] > 128) { // don't render transparent pixels;

	cmp	BYTE PTR [rax+rcx*4+3], 128		; 00000080H
	lea	rdx, QWORD PTR [rax+rcx*4]
	jbe	SHORT $LN6@stbi__out_

; 6671 :       p[0] = c[2];

	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [r8], al

; 6672 :       p[1] = c[1];

	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [r8+1], al

; 6673 :       p[2] = c[0];

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [r8+2], al

; 6674 :       p[3] = c[3];

	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [r8+3], al
$LN6@stbi__out_:

; 6675 :    }
; 6676 :    g->cur_x += 4;

	add	DWORD PTR [rbx+34908], 4
	mov	eax, DWORD PTR [rbx+34908]

; 6677 : 
; 6678 :    if (g->cur_x >= g->max_x) {

	cmp	eax, DWORD PTR [rbx+34900]
	jl	SHORT $LN13@stbi__out_

; 6679 :       g->cur_x = g->start_x;

	mov	eax, DWORD PTR [rbx+34892]

; 6680 :       g->cur_y += g->step;
; 6681 : 
; 6682 :       while (g->cur_y >= g->max_y && g->parse > 0) {

	mov	r9d, DWORD PTR [rbx+34904]
	mov	DWORD PTR [rbx+34908], eax
	mov	eax, DWORD PTR [rbx+34884]
	add	DWORD PTR [rbx+34912], eax
	cmp	DWORD PTR [rbx+34912], r9d
	jl	SHORT $LN13@stbi__out_
	npad	4
$LL2@stbi__out_:
	mov	r8d, DWORD PTR [rbx+34880]
	test	r8d, r8d
	jle	SHORT $LN13@stbi__out_

; 6683 :          g->step = (1 << g->parse) * g->line_size;

	mov	edx, DWORD PTR [rbx+34916]

; 6684 :          g->cur_y = g->start_y + (g->step >> 1);
; 6685 :          --g->parse;

	lea	eax, DWORD PTR [r8-1]
	mov	ecx, r8d
	mov	DWORD PTR [rbx+34880], eax
	shl	edx, cl
	mov	ecx, DWORD PTR [rbx+34896]
	mov	DWORD PTR [rbx+34884], edx
	sar	edx, 1
	add	ecx, edx
	mov	DWORD PTR [rbx+34912], ecx
	cmp	ecx, r9d
	jge	SHORT $LL2@stbi__out_
$LN13@stbi__out_:

; 6686 :       }
; 6687 :    }
; 6688 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z ENDP		; stbi__out_gif_code
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z
_TEXT	SEGMENT
tv914 = 32
tv941 = 36
$T1 = 40
valid_bits$1$ = 112
s$ = 112
g$ = 120
bits$1$ = 128
first$1$ = 136
?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z PROC ; stbi__process_gif_raster, COMDAT

; 6691 : {

	push	rbx
	push	r12
	sub	rsp, 88					; 00000058H

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rcx+192]

; 6691 : {

	mov	r12, rdx
	mov	rbx, rcx

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rcx+200]
	jb	SHORT $LN128@stbi__proc

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rcx+48], 0
	je	SHORT $LN32@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN128@stbi__proc:

; 6692 :    stbi_uc lzw_cs;
; 6693 :    stbi__int32 len, init_code;
; 6694 :    stbi__uint32 first;
; 6695 :    stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
; 6696 :    stbi__gif_lzw *p;
; 6697 : 
; 6698 :    lzw_cs = stbi__get8(s);
; 6699 :    if (lzw_cs > 12) return NULL;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 12
	jbe	SHORT $LN85@stbi__proc
	xor	eax, eax

; 6773 : }

	add	rsp, 88					; 00000058H
	pop	r12
	pop	rbx
	ret	0
$LN32@stbi__proc:

; 1620 :    return 0;

	xor	cl, cl
$LN85@stbi__proc:
	mov	QWORD PTR [rsp+120], rbp

; 6701 :    first = 1;

	mov	r11d, 1
	movzx	ecx, cl

; 6702 :    codesize = lzw_cs + 1;
; 6703 :    codemask = (1 << codesize) - 1;
; 6704 :    bits = 0;

	xor	r9d, r9d
	mov	QWORD PTR [rsp+80], rsi

; 6705 :    valid_bits = 0;

	xor	edx, edx
	mov	QWORD PTR [rsp+72], rdi
	mov	QWORD PTR [rsp+64], r13

; 6706 :    for (init_code = 0; init_code < clear; init_code++) {

	lea	r8d, QWORD PTR [r11-2]
	lea	eax, DWORD PTR [rcx+1]
	mov	QWORD PTR [rsp+56], r14
	mov	DWORD PTR tv914[rsp], eax
	mov	r13d, 1
	shl	r13d, cl
	mov	ecx, eax
	mov	QWORD PTR [rsp+48], r15
	mov	r15d, eax
	mov	eax, r11d
	mov	DWORD PTR first$1$[rsp], r11d
	shl	eax, cl
	xor	ecx, ecx
	dec	eax
	mov	DWORD PTR bits$1$[rsp], r9d
	mov	DWORD PTR tv941[rsp], eax
	mov	r14d, eax
	mov	DWORD PTR valid_bits$1$[rsp], edx
	test	r13d, r13d
	jle	SHORT $LN3@stbi__proc

; 6700 :    clear = 1 << lzw_cs;

	lea	rax, QWORD PTR [r12+2102]
	npad	12
$LL4@stbi__proc:

; 6707 :       g->codes[init_code].prefix = -1;
; 6708 :       g->codes[init_code].first = (stbi_uc) init_code;

	mov	BYTE PTR [rax], cl

; 6709 :       g->codes[init_code].suffix = (stbi_uc) init_code;

	mov	BYTE PTR [rax+1], cl
	inc	ecx
	mov	WORD PTR [rax-2], r8w
	lea	rax, QWORD PTR [rax+4]
	cmp	ecx, r13d
	jl	SHORT $LL4@stbi__proc
$LN3@stbi__proc:

; 6710 :    }
; 6711 : 
; 6712 :    // support no starting clear code
; 6713 :    avail = clear+2;

	lea	eax, DWORD PTR [r13+2]

; 6714 :    oldcode = -1;

	mov	ebp, r8d
	movsxd	rsi, eax

; 6715 : 
; 6716 :    len = 0;

	xor	edi, edi
	mov	r8, rsi
	mov	QWORD PTR $T1[rsp], rsi
	npad	7
$LL5@stbi__proc:

; 6717 :    for(;;) {
; 6718 :       if (valid_bits < codesize) {

	cmp	edx, r15d
	jge	$LN11@stbi__proc

; 6719 :          if (len == 0) {

	test	edi, edi
	jne	SHORT $LN86@stbi__proc

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN35@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN129@stbi__proc
$LN35@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN36@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	mov	r9d, DWORD PTR bits$1$[rsp]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN129@stbi__proc
$LN36@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN129@stbi__proc:

; 6720 :             len = stbi__get8(s); // start new block

	movzx	edi, cl
	mov	edx, 48					; 00000030H
	mov	rax, rbx
	lea	r8, QWORD PTR [rbx+rdx]

; 6721 :             if (len == 0)

	test	cl, cl
	je	$LN9@stbi__proc
	mov	edx, DWORD PTR valid_bits$1$[rsp]
	jmp	SHORT $LN80@stbi__proc
$LN86@stbi__proc:
	lea	r8, QWORD PTR [rbx+48]
$LN80@stbi__proc:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]

; 6722 :                return g->out;
; 6723 :          }
; 6724 :          --len;

	dec	edi

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN39@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN38@stbi__proc
$LN39@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r8], 0
	je	SHORT $LN40@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	mov	edx, DWORD PTR valid_bits$1$[rsp]
	mov	r9d, DWORD PTR bits$1$[rsp]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN38@stbi__proc
$LN40@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN38@stbi__proc:

; 6725 :          bits |= (stbi__int32) stbi__get8(s) << valid_bits;
; 6726 :          valid_bits += 8;
; 6727 :       } else {

	mov	r8, QWORD PTR $T1[rsp]
	mov	r11d, DWORD PTR first$1$[rsp]
	movzx	eax, cl
	mov	ecx, edx
	shl	eax, cl
	or	r9d, eax
	lea	eax, DWORD PTR [r13+2]
	add	edx, 8
	mov	DWORD PTR bits$1$[rsp], r9d
	mov	DWORD PTR valid_bits$1$[rsp], edx
	jmp	$LL5@stbi__proc
$LN11@stbi__proc:

; 6728 :          stbi__int32 code = bits & codemask;

	mov	r10d, r9d

; 6729 :          bits >>= codesize;
; 6730 :          valid_bits -= codesize;

	sub	edx, r15d
	mov	ecx, r15d
	mov	DWORD PTR valid_bits$1$[rsp], edx
	sar	r9d, cl
	and	r10d, r14d
	mov	DWORD PTR bits$1$[rsp], r9d

; 6731 :          // @OPTIMIZE: is there some way we can accelerate the non-clear path?
; 6732 :          if (code == clear) {  // clear code

	cmp	r10d, r13d
	jne	SHORT $LN15@stbi__proc

; 6733 :             codesize = lzw_cs + 1;

	mov	r15d, DWORD PTR tv914[rsp]

; 6734 :             codemask = (1 << codesize) - 1;
; 6735 :             avail = clear + 2;

	mov	esi, eax
	mov	r14d, DWORD PTR tv941[rsp]

; 6736 :             oldcode = -1;

	mov	ebp, -1
	movsxd	r8, r13d
	add	r8, 2

; 6737 :             first = 0;

	xor	r11d, r11d
	mov	QWORD PTR $T1[rsp], r8
	mov	DWORD PTR first$1$[rsp], r11d
	jmp	$LL5@stbi__proc
$LN15@stbi__proc:

; 6738 :          } else if (code == clear + 1) { // end of stream code

	lea	eax, DWORD PTR [r13+1]
	cmp	r10d, eax
	je	$LN70@stbi__proc

; 6743 :          } else if (code <= avail) {

	cmp	r10d, esi
	jg	$LN19@stbi__proc

; 6744 :             if (first) {

	test	r11d, r11d
	jne	$LN71@stbi__proc

; 6746 :             }
; 6747 : 
; 6748 :             if (oldcode >= 0) {

	test	ebp, ebp
	js	SHORT $LN22@stbi__proc

; 6749 :                p = &g->codes[avail++];

	lea	rdx, QWORD PTR [r12+r8*4]
	inc	esi
	inc	r8
	mov	QWORD PTR $T1[rsp], r8

; 6750 :                if (avail > 8192) {

	cmp	esi, 8192				; 00002000H
	jg	$LN72@stbi__proc

; 6752 :                }
; 6753 : 
; 6754 :                p->prefix = (stbi__int16) oldcode;
; 6755 :                p->first = g->codes[oldcode].first;

	movsxd	rax, ebp
	mov	WORD PTR [rdx+2100], bp
	movzx	ecx, BYTE PTR [r12+rax*4+2102]
	mov	BYTE PTR [rdx+2102], cl

; 6756 :                p->suffix = (code == avail) ? p->first : g->codes[code].first;

	cmp	r10d, esi
	je	SHORT $LN29@stbi__proc
	movsxd	rax, r10d
	movzx	ecx, BYTE PTR [r12+rax*4+2102]
$LN29@stbi__proc:
	mov	BYTE PTR [rdx+2103], cl
	jmp	SHORT $LN25@stbi__proc
$LN22@stbi__proc:

; 6757 :             } else if (code == avail)

	cmp	r10d, esi
	je	$LN19@stbi__proc
$LN25@stbi__proc:

; 6758 :                return stbi__errpuc("illegal code in raster", "Corrupt GIF");
; 6759 : 
; 6760 :             stbi__out_gif_code(g, (stbi__uint16) code);

	movzx	edx, r10w
	mov	rcx, r12
	call	?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z ; stbi__out_gif_code

; 6761 : 
; 6762 :             if ((avail & codemask) == 0 && avail <= 0x0FFF) {

	test	esi, r14d
	jne	SHORT $LN26@stbi__proc
	cmp	esi, 4095				; 00000fffH
	jg	SHORT $LN26@stbi__proc

; 6763 :                codesize++;

	inc	r15d

; 6764 :                codemask = (1 << codesize) - 1;

	mov	r14d, 1
	mov	ecx, r15d
	shl	r14d, cl
	dec	r14d
$LN26@stbi__proc:

; 6770 :          }
; 6771 :       }
; 6772 :    }

	mov	edx, DWORD PTR valid_bits$1$[rsp]
	lea	eax, DWORD PTR [r13+2]
	mov	r8, QWORD PTR $T1[rsp]
	mov	ebp, r10d
	mov	r9d, DWORD PTR bits$1$[rsp]
	jmp	$LL5@stbi__proc
$LN72@stbi__proc:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0P@GJNJCPDJ@too?5many?5codes@
	mov	QWORD PTR [rdx+rcx], rax

; 6751 :                   return stbi__errpuc("too many codes", "Corrupt GIF");

	xor	eax, eax
	jmp	$LN127@stbi__proc
$LN71@stbi__proc:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0O@MGDACKOJ@no?5clear?5code@
	mov	QWORD PTR [rdx+rcx], rax

; 6745 :                return stbi__errpuc("no clear code", "Corrupt GIF");

	xor	eax, eax
	jmp	$LN127@stbi__proc
$LN19@stbi__proc:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@
	mov	QWORD PTR [rdx+rcx], rax

; 6765 :             }
; 6766 : 
; 6767 :             oldcode = code;
; 6768 :          } else {
; 6769 :             return stbi__errpuc("illegal code in raster", "Corrupt GIF");

	xor	eax, eax
	jmp	$LN127@stbi__proc
$LN70@stbi__proc:

; 1644 :    if (n == 0) return;  // already there!

	test	edi, edi
	je	SHORT $LL8@stbi__proc

; 1645 :    if (n < 0) {

	jns	SHORT $LN44@stbi__proc

; 1646 :       s->img_buffer = s->img_buffer_end;

	mov	rax, QWORD PTR [rbx+200]
	mov	QWORD PTR [rbx+192], rax

; 1647 :       return;

	jmp	SHORT $LL8@stbi__proc
$LN44@stbi__proc:

; 1648 :    }
; 1649 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], 0
	je	SHORT $LN46@stbi__proc

; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);

	mov	ecx, DWORD PTR [rbx+200]
	sub	ecx, DWORD PTR [rbx+192]

; 1651 :       if (blen < n) {

	cmp	ecx, edi
	jge	SHORT $LN46@stbi__proc

; 1652 :          s->img_buffer = s->img_buffer_end;

	mov	rax, QWORD PTR [rbx+200]

; 1653 :          (s->io.skip)(s->io_user_data, n - blen);

	sub	edi, ecx
	mov	rcx, QWORD PTR [rbx+40]
	mov	edx, edi
	mov	QWORD PTR [rbx+192], rax
	call	QWORD PTR [rbx+24]

; 1654 :          return;

	jmp	SHORT $LL8@stbi__proc
$LN46@stbi__proc:

; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;

	movsxd	rax, edi
	add	QWORD PTR [rbx+192], rax
	npad	11
$LL8@stbi__proc:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rcx, QWORD PTR [rbx+192]
	cmp	rcx, QWORD PTR [rbx+200]
	jae	SHORT $LN49@stbi__proc

; 1615 :       return *s->img_buffer++;

	movzx	edx, BYTE PTR [rcx]
	inc	rcx
	mov	QWORD PTR [rbx+192], rcx
	jmp	SHORT $LN48@stbi__proc
$LN49@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN50@stbi__proc

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edx, BYTE PTR [rax]
	lea	rcx, QWORD PTR [rax+1]
	mov	QWORD PTR [rbx+192], rcx
	jmp	SHORT $LN48@stbi__proc
$LN50@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

	xor	dl, dl
$LN48@stbi__proc:

; 6739 :             stbi__skip(s, len);
; 6740 :             while ((len = stbi__get8(s)) > 0)

	movzx	edx, dl
	test	edx, edx
	je	SHORT $LN9@stbi__proc

; 1649 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], 0
	je	SHORT $LN56@stbi__proc

; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);

	mov	r8d, DWORD PTR [rbx+200]
	sub	r8d, ecx

; 1651 :       if (blen < n) {

	cmp	r8d, edx
	jge	SHORT $LN56@stbi__proc

; 1652 :          s->img_buffer = s->img_buffer_end;

	mov	rax, QWORD PTR [rbx+200]

; 1653 :          (s->io.skip)(s->io_user_data, n - blen);

	sub	edx, r8d
	mov	rcx, QWORD PTR [rbx+40]
	mov	QWORD PTR [rbx+192], rax
	call	QWORD PTR [rbx+24]

; 1654 :          return;

	jmp	SHORT $LL8@stbi__proc
$LN56@stbi__proc:

; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;

	lea	rax, QWORD PTR [rcx+rdx]
	mov	QWORD PTR [rbx+192], rax

; 6741 :                stbi__skip(s,len);

	jmp	$LL8@stbi__proc
$LN9@stbi__proc:

; 6742 :             return g->out;

	mov	rax, QWORD PTR [r12+8]
$LN127@stbi__proc:
	mov	r14, QWORD PTR [rsp+56]
	mov	r13, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+120]
	mov	r15, QWORD PTR [rsp+48]

; 6773 : }

	add	rsp, 88					; 00000058H
	pop	r12
	pop	rbx
	ret	0
?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z ENDP ; stbi__process_gif_raster
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z
_TEXT	SEGMENT
s$ = 80
g$ = 88
comp$ = 96
first_frame$1$ = 104
req_comp$dead$ = 104
two_back$dead$ = 112
?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z PROC ; stbi__gif_load_next, COMDAT

; 6778 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	DWORD PTR [rsp+32], r9d
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 6779 :    int dispose;
; 6780 :    int first_frame;
; 6781 :    int pi;
; 6782 :    int pcount;
; 6783 :    STBI_NOTUSED(req_comp);
; 6784 : 
; 6785 :    // on first frame, any non-written pixels get the background colour (non-transparent)
; 6786 :    first_frame = 0;

	xor	r12d, r12d
	mov	rsi, rdx
	mov	rbx, rcx
	mov	DWORD PTR first_frame$1$[rsp], r12d

; 6787 :    if (g->out == 0) {

	cmp	QWORD PTR [rdx+8], r12
	jne	$LN18@stbi__gif_

; 6788 :       if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header

	call	?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z ; stbi__gif_header
	test	eax, eax
	je	$LN178@stbi__gif_

; 6789 :       if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))

	mov	ecx, DWORD PTR [rsi]
	mov	edi, DWORD PTR [rsi+4]

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	$LN171@stbi__gif_

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	jne	SHORT $LN116@stbi__gif_
	lea	r8d, DWORD PTR [rcx*4]
	jmp	SHORT $LN175@stbi__gif_
$LN116@stbi__gif_:

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	ecx

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	eax, 4
	jl	$LN171@stbi__gif_
	lea	r8d, DWORD PTR [rcx*4]

; 1014 :    if (a < 0 || b < 0) return 0;

	test	r8d, r8d
	js	$LN171@stbi__gif_
$LN175@stbi__gif_:
	test	edi, edi
	js	$LN171@stbi__gif_

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN172@stbi__gif_

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	edi

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	r8d, eax
	jg	$LN171@stbi__gif_
$LN172@stbi__gif_:

; 6789 :       if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))

	imul	edi, ecx

; 6791 :       pcount = g->w * g->h;
; 6792 :       g->out = (stbi_uc *) stbi__malloc(4 * pcount);

	lea	eax, DWORD PTR [rdi*4]
	movsxd	rbp, eax

; 985  :     return STBI_MALLOC(size);

	mov	rcx, rbp
	call	QWORD PTR __imp_malloc
	mov	rcx, rbp

; 6791 :       pcount = g->w * g->h;
; 6792 :       g->out = (stbi_uc *) stbi__malloc(4 * pcount);

	mov	QWORD PTR [rsi+8], rax

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc

; 6794 :       g->history = (stbi_uc *) stbi__malloc(pcount);

	movsxd	rdi, edi

; 985  :     return STBI_MALLOC(size);

	mov	rcx, rdi

; 6793 :       g->background = (stbi_uc *) stbi__malloc(4 * pcount);

	mov	QWORD PTR [rsi+16], rax

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc

; 6795 :       if (!g->out || !g->background || !g->history)

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rsi+24], rax
	test	rcx, rcx
	je	SHORT $LN23@stbi__gif_
	cmp	QWORD PTR [rsi+16], r12
	je	SHORT $LN23@stbi__gif_
	test	rax, rax
	je	SHORT $LN23@stbi__gif_

; 6797 : 
; 6798 :       // image is treated as "transparent" at the start - ie, nothing overwrites the current background;
; 6799 :       // background colour is only used for pixels that are not rendered first frame, after that "background"
; 6800 :       // color refers to the color that was there the previous frame.
; 6801 :       memset(g->out, 0x00, 4 * pcount);

	mov	r8, rbp
	xor	edx, edx
	call	memset

; 6802 :       memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)

	mov	rcx, QWORD PTR [rsi+16]
	mov	r8, rbp
	xor	edx, edx
	call	memset

; 6803 :       memset(g->history, 0x00, pcount);        // pixels that were affected previous frame

	mov	rcx, QWORD PTR [rsi+24]
	mov	r8, rdi
	xor	edx, edx
	call	memset

; 6804 :       first_frame = 1;

	mov	DWORD PTR first_frame$1$[rsp], 1

; 6805 :    } else {

	jmp	$LN19@stbi__gif_
$LN23@stbi__gif_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@

; 6796 :          return stbi__errpuc("outofmem", "Out of memory");

	jmp	$LN244@stbi__gif_
$LN171@stbi__gif_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@

; 6790 :          return stbi__errpuc("too large", "GIF image is too large");

	jmp	$LN244@stbi__gif_
$LN18@stbi__gif_:

; 6806 :       // second frame - how do we dispose of the previous one?
; 6807 :       dispose = (g->eflags & 0x1C) >> 2;
; 6808 :       pcount = g->w * g->h;

	mov	eax, DWORD PTR [rdx]
	imul	eax, DWORD PTR [rdx+4]
	mov	ecx, DWORD PTR [rdx+48]
	movsxd	r8, eax

; 6809 : 
; 6810 :       if ((dispose == 3) && (two_back == 0)) {

	mov	eax, ecx
	and	eax, 28
	cmp	al, 12
	je	SHORT $LN174@stbi__gif_

; 6811 :          dispose = 2; // if I don't have an image to revert back to, default to the old background
; 6812 :       }
; 6813 : 
; 6814 :       if (dispose == 3) { // use previous graphic
; 6815 :          for (pi = 0; pi < pcount; ++pi) {
; 6816 :             if (g->history[pi]) {
; 6817 :                memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );
; 6818 :             }
; 6819 :          }
; 6820 :       } else if (dispose == 2) {

	and	cl, 28
	cmp	cl, 8
	jne	SHORT $LN6@stbi__gif_
$LN174@stbi__gif_:

; 6821 :          // restore what was changed last frame to background before that frame;
; 6822 :          for (pi = 0; pi < pcount; ++pi) {

	test	r8, r8
	jle	SHORT $LN6@stbi__gif_
	mov	rdx, r12
	npad	1
$LL7@stbi__gif_:

; 6823 :             if (g->history[pi]) {

	mov	rax, QWORD PTR [rsi+24]
	cmp	BYTE PTR [rdx+rax], r12b
	je	SHORT $LN5@stbi__gif_

; 6824 :                memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );

	mov	rax, QWORD PTR [rsi+16]
	mov	rcx, QWORD PTR [rsi+8]
	mov	eax, DWORD PTR [rax+rdx*4]
	mov	DWORD PTR [rcx+rdx*4], eax
$LN5@stbi__gif_:

; 6821 :          // restore what was changed last frame to background before that frame;
; 6822 :          for (pi = 0; pi < pcount; ++pi) {

	inc	rdx
	cmp	rdx, r8
	jl	SHORT $LL7@stbi__gif_
$LN6@stbi__gif_:

; 6825 :             }
; 6826 :          }
; 6827 :       } else {
; 6828 :          // This is a non-disposal case eithe way, so just
; 6829 :          // leave the pixels as is, and they will become the new background
; 6830 :          // 1: do not dispose
; 6831 :          // 0:  not specified.
; 6832 :       }
; 6833 : 
; 6834 :       // background is what out is after the undoing of the previou frame;
; 6835 :       memcpy( g->background, g->out, 4 * g->w * g->h );

	mov	eax, DWORD PTR [rsi+4]
	imul	eax, DWORD PTR [rsi]
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rsi+16]
	shl	eax, 2
	movsxd	r8, eax
	call	memcpy
$LN19@stbi__gif_:

; 6836 :    }
; 6837 : 
; 6838 :    // clear my history;
; 6839 :    memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame

	mov	eax, DWORD PTR [rsi]
	xor	edx, edx
	imul	eax, DWORD PTR [rsi+4]
	mov	rcx, QWORD PTR [rsi+24]
	movsxd	r8, eax
	call	memset
	mov	r13d, -1
$LN85@stbi__gif_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	lea	rdi, QWORD PTR [rbx+48]
	npad	9
$LL8@stbi__gif_:
	mov	rcx, QWORD PTR [rbx+192]
	cmp	rcx, QWORD PTR [rbx+200]
	jae	SHORT $LN68@stbi__gif_

; 1615 :       return *s->img_buffer++;

	movzx	edx, BYTE PTR [rcx]
	inc	rcx
	jmp	SHORT $LN245@stbi__gif_
$LN68@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], r12d
	lea	rdi, QWORD PTR [rbx+48]
	je	$LN177@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edx, BYTE PTR [rax]
	lea	rcx, QWORD PTR [rax+1]
$LN245@stbi__gif_:

; 6840 : 
; 6841 :    for (;;) {
; 6842 :       int tag = stbi__get8(s);

	mov	QWORD PTR [rbx+192], rcx
	mov	rbp, rdi

; 6843 :       switch (tag) {

	cmp	dl, 33					; 00000021H
	jne	$LN142@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rcx, QWORD PTR [rbx+200]
	jae	SHORT $LN72@stbi__gif_

; 1615 :       return *s->img_buffer++;

	movzx	edx, BYTE PTR [rcx]
	inc	rcx
	jmp	SHORT $LN246@stbi__gif_
$LN72@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi], r12d
	je	$LL16@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edx, BYTE PTR [rax]
	lea	rcx, QWORD PTR [rax+1]
$LN246@stbi__gif_:

; 6905 :          }
; 6906 : 
; 6907 :          case 0x21: // Comment Extension.
; 6908 :          {
; 6909 :             int len;
; 6910 :             int ext = stbi__get8(s);
; 6911 :             if (ext == 0xF9) { // Graphic Control Extension.

	mov	QWORD PTR [rbx+192], rcx
	cmp	dl, 249					; 000000f9H
	jne	$LL16@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rcx, QWORD PTR [rbx+200]
	jae	SHORT $LN76@stbi__gif_

; 1615 :       return *s->img_buffer++;

	movzx	edx, BYTE PTR [rcx]
	inc	rcx
	mov	QWORD PTR [rbx+192], rcx
	jmp	SHORT $LN75@stbi__gif_
$LN76@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi], r12d
	je	SHORT $LN77@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edx, BYTE PTR [rax]
	lea	rcx, QWORD PTR [rax+1]
	mov	QWORD PTR [rbx+192], rcx
	jmp	SHORT $LN75@stbi__gif_
$LN77@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

	xor	dl, dl
$LN75@stbi__gif_:

; 6912 :                len = stbi__get8(s);

	movzx	edx, dl

; 6913 :                if (len == 4) {

	cmp	edx, 4
	jne	$LN46@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rcx, QWORD PTR [rbx+200]
	jae	SHORT $LN82@stbi__gif_

; 1615 :       return *s->img_buffer++;

	movzx	edx, BYTE PTR [rcx]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN81@stbi__gif_
$LN82@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi], r12d
	je	SHORT $LN83@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN81@stbi__gif_
$LN83@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

	xor	dl, dl
$LN81@stbi__gif_:

; 6914 :                   g->eflags = stbi__get8(s);

	movzx	eax, dl

; 6915 :                   g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.

	mov	rcx, rbx
	mov	DWORD PTR [rsi+48], eax
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	lea	ecx, DWORD PTR [rax+rax*4]

; 6916 : 
; 6917 :                   // unset old transparent
; 6918 :                   if (g->transparent >= 0) {

	movsxd	rax, DWORD PTR [rsi+44]
	add	ecx, ecx
	mov	DWORD PTR [rsi+34920], ecx
	test	eax, eax
	js	SHORT $LN48@stbi__gif_

; 6919 :                      g->pal[g->transparent][3] = 255;

	mov	BYTE PTR [rsi+rax*4+55], 255		; 000000ffH
$LN48@stbi__gif_:

; 6920 :                   }
; 6921 :                   if (g->eflags & 0x01) {

	test	BYTE PTR [rsi+48], 1
	je	$LN49@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN94@stbi__gif_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN93@stbi__gif_
$LN94@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi], r12d
	je	SHORT $LN95@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN93@stbi__gif_
$LN95@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN93@stbi__gif_:

; 6922 :                      g->transparent = stbi__get8(s);

	movzx	eax, cl
	mov	DWORD PTR [rsi+44], eax

; 6923 :                      if (g->transparent >= 0) {
; 6924 :                         g->pal[g->transparent][3] = 0;

	mov	BYTE PTR [rsi+rax*4+55], r12b
	npad	10
$LL16@stbi__gif_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rcx, QWORD PTR [rbx+192]
	cmp	rcx, QWORD PTR [rbx+200]
	jae	$LN58@stbi__gif_

; 1615 :       return *s->img_buffer++;

	movzx	edx, BYTE PTR [rcx]
	lea	rdi, QWORD PTR [rbx+48]
	inc	rcx
	mov	QWORD PTR [rbx+192], rcx
	jmp	$LN57@stbi__gif_
$LN49@stbi__gif_:

; 1649 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], r12
	je	SHORT $LN105@stbi__gif_

; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);

	mov	ecx, DWORD PTR [rbx+200]
	sub	ecx, DWORD PTR [rbx+192]

; 1651 :       if (blen < n) {

	cmp	ecx, 1
	jge	SHORT $LN105@stbi__gif_

; 1652 :          s->img_buffer = s->img_buffer_end;

	mov	rax, QWORD PTR [rbx+200]

; 1653 :          (s->io.skip)(s->io_user_data, n - blen);

	mov	edx, 1
	sub	edx, ecx
	mov	QWORD PTR [rbx+192], rax
	mov	rcx, QWORD PTR [rbx+40]
	call	QWORD PTR [rbx+24]

; 6925 :                      }
; 6926 :                   } else {
; 6927 :                      // don't need transparent
; 6928 :                      stbi__skip(s, 1);
; 6929 :                      g->transparent = -1;

	mov	DWORD PTR [rsi+44], r13d

; 6930 :                   }
; 6931 :                } else {

	jmp	SHORT $LL16@stbi__gif_
$LN105@stbi__gif_:

; 1657 :    s->img_buffer += n;

	inc	QWORD PTR [rbx+192]

; 6925 :                      }
; 6926 :                   } else {
; 6927 :                      // don't need transparent
; 6928 :                      stbi__skip(s, 1);
; 6929 :                      g->transparent = -1;

	mov	DWORD PTR [rsi+44], r13d

; 6930 :                   }
; 6931 :                } else {

	jmp	SHORT $LL16@stbi__gif_
$LN46@stbi__gif_:

; 1644 :    if (n == 0) return;  // already there!

	test	edx, edx
	je	$LN85@stbi__gif_

; 1645 :    if (n < 0) {
; 1646 :       s->img_buffer = s->img_buffer_end;
; 1647 :       return;
; 1648 :    }
; 1649 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], r12
	je	SHORT $LN89@stbi__gif_

; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);

	mov	r8d, DWORD PTR [rbx+200]
	sub	r8d, ecx

; 1651 :       if (blen < n) {

	cmp	r8d, edx
	jge	SHORT $LN89@stbi__gif_

; 1652 :          s->img_buffer = s->img_buffer_end;

	mov	rax, QWORD PTR [rbx+200]

; 1653 :          (s->io.skip)(s->io_user_data, n - blen);

	sub	edx, r8d
	mov	rcx, QWORD PTR [rbx+40]
	mov	QWORD PTR [rbx+192], rax
	call	QWORD PTR [rbx+24]

; 1654 :          return;

	jmp	$LN85@stbi__gif_
$LN89@stbi__gif_:

; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;

	lea	rax, QWORD PTR [rcx+rdx]
	mov	QWORD PTR [rbx+192], rax

; 6932 :                   stbi__skip(s, len);
; 6933 :                   break;

	jmp	$LN85@stbi__gif_
$LN58@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

	mov	rdi, rbp
	cmp	DWORD PTR [rbp], r12d
	je	SHORT $LN59@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edx, BYTE PTR [rax]
	lea	rcx, QWORD PTR [rax+1]
	mov	QWORD PTR [rbx+192], rcx
	jmp	SHORT $LN57@stbi__gif_
$LN59@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

	xor	dl, dl
$LN57@stbi__gif_:

; 6934 :                }
; 6935 :             }
; 6936 :             while ((len = stbi__get8(s)) != 0) {

	movzx	edx, dl
	test	edx, edx
	je	$LL8@stbi__gif_

; 1649 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], r12
	je	SHORT $LN65@stbi__gif_

; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);

	mov	r8d, DWORD PTR [rbx+200]
	sub	r8d, ecx

; 1651 :       if (blen < n) {

	cmp	r8d, edx
	jge	SHORT $LN65@stbi__gif_

; 1652 :          s->img_buffer = s->img_buffer_end;

	mov	rax, QWORD PTR [rbx+200]

; 1653 :          (s->io.skip)(s->io_user_data, n - blen);

	sub	edx, r8d
	mov	rcx, QWORD PTR [rbx+40]
	mov	QWORD PTR [rbx+192], rax
	call	QWORD PTR [rbx+24]

; 1654 :          return;

	jmp	$LL16@stbi__gif_
$LN65@stbi__gif_:

; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;

	lea	rax, QWORD PTR [rcx+rdx]
	mov	QWORD PTR [rbx+192], rax

; 6937 :                stbi__skip(s, len);
; 6938 :             }

	jmp	$LL16@stbi__gif_
$LN142@stbi__gif_:

; 6843 :       switch (tag) {

	cmp	dl, 44					; 0000002cH
	je	SHORT $LN31@stbi__gif_
	cmp	dl, 59					; 0000003bH
	jne	$LN177@stbi__gif_

; 6939 :             break;
; 6940 :          }
; 6941 : 
; 6942 :          case 0x3B: // gif stream termination code
; 6943 :             return (stbi_uc *) s; // using '1' causes warning on some compilers

	mov	rax, rbx
	jmp	$LN9@stbi__gif_
$LN31@stbi__gif_:

; 6844 :          case 0x2C: /* Image Descriptor */
; 6845 :          {
; 6846 :             stbi__int32 x, y, w, h;
; 6847 :             stbi_uc *o;
; 6848 : 
; 6849 :             x = stbi__get16le(s);

	mov	rcx, rbx
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 6850 :             y = stbi__get16le(s);

	mov	rcx, rbx
	mov	r15d, eax
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 6851 :             w = stbi__get16le(s);

	mov	rcx, rbx
	mov	edi, eax
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 6852 :             h = stbi__get16le(s);

	mov	rcx, rbx
	mov	r14d, eax
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 6853 :             if (((x + w) > (g->w)) || ((y + h) > (g->h)))

	mov	r8d, DWORD PTR [rsi]
	lea	ecx, DWORD PTR [r14+r15]
	mov	r9d, eax
	cmp	ecx, r8d
	jg	$LN33@stbi__gif_
	lea	ecx, DWORD PTR [rax+rdi]
	cmp	ecx, DWORD PTR [rsi+4]
	jg	$LN33@stbi__gif_

; 6855 : 
; 6856 :             g->line_size = g->w * 4;

	lea	r8d, DWORD PTR [r8*4]

; 6857 :             g->start_x = x * 4;

	lea	ecx, DWORD PTR [r15*4]
	mov	DWORD PTR [rsi+34916], r8d

; 6858 :             g->start_y = y * g->line_size;

	mov	edx, r8d
	mov	DWORD PTR [rsi+34892], ecx
	imul	edx, edi

; 6859 :             g->max_x   = g->start_x + w * 4;

	lea	eax, DWORD PTR [rcx+r14*4]

; 6860 :             g->max_y   = g->start_y + h * g->line_size;

	imul	r8d, r9d
	mov	DWORD PTR [rsi+34900], eax

; 6861 :             g->cur_x   = g->start_x;

	mov	DWORD PTR [rsi+34908], ecx
	mov	DWORD PTR [rsi+34896], edx

; 6862 :             g->cur_y   = g->start_y;

	mov	DWORD PTR [rsi+34912], edx
	lea	eax, DWORD PTR [r8+rdx]
	mov	DWORD PTR [rsi+34904], eax

; 6863 : 
; 6864 :             // if the width of the specified rectangle is 0, that means
; 6865 :             // we may not see *any* pixels or the image is malformed;
; 6866 :             // to make sure this is caught, move the current y down to
; 6867 :             // max_y (which is what out_gif_code checks).
; 6868 :             if (w == 0)

	test	r14d, r14d
	jne	SHORT $LN34@stbi__gif_

; 6869 :                g->cur_y = g->max_y;

	mov	DWORD PTR [rsi+34912], eax
$LN34@stbi__gif_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN98@stbi__gif_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN97@stbi__gif_
$LN98@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbp], r12d
	je	SHORT $LN99@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN97@stbi__gif_
$LN99@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN97@stbi__gif_:

; 6870 : 
; 6871 :             g->lflags = stbi__get8(s);
; 6872 : 
; 6873 :             if (g->lflags & 0x40) {

	mov	edx, DWORD PTR [rsi+34916]
	movzx	r9d, cl
	mov	DWORD PTR [rsi+34888], r9d
	mov	r8d, r9d
	and	r8d, 64					; 00000040H

; 6874 :                g->step = 8 * g->line_size; // first interlaced spacing
; 6875 :                g->parse = 3;
; 6876 :             } else {
; 6877 :                g->step = g->line_size;
; 6878 :                g->parse = 0;
; 6879 :             }
; 6880 : 
; 6881 :             if (g->lflags & 0x80) {

	mov	eax, r8d
	neg	eax
	lea	eax, DWORD PTR [rdx*8]
	sbb	ecx, ecx
	and	ecx, 3
	test	r8d, r8d
	cmove	eax, edx
	mov	DWORD PTR [rsi+34884], eax
	mov	DWORD PTR [rsi+34880], ecx
	test	r9b, r9b
	jns	SHORT $LN37@stbi__gif_

; 6882 :                stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);

	test	BYTE PTR [rsi+48], 1
	je	SHORT $LN55@stbi__gif_
	mov	r13d, DWORD PTR [rsi+44]
$LN55@stbi__gif_:
	and	r9d, 7
	lea	rdi, QWORD PTR [rsi+1076]
	movzx	ecx, r9b
	mov	r8d, 2
	shl	r8d, cl
	mov	r9d, r13d
	mov	rcx, rbx
	mov	rdx, rdi
	call	?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z ; stbi__gif_parse_colortable

; 6883 :                g->color_table = (stbi_uc *) g->lpal;

	jmp	SHORT $LN40@stbi__gif_
$LN37@stbi__gif_:

; 6884 :             } else if (g->flags & 0x80) {

	test	BYTE PTR [rsi+32], 128			; 00000080H
	je	SHORT $LN39@stbi__gif_

; 6885 :                g->color_table = (stbi_uc *) g->pal;

	lea	rdi, QWORD PTR [rsi+52]
$LN40@stbi__gif_:

; 6888 : 
; 6889 :             o = stbi__process_gif_raster(s, g);

	mov	rdx, rsi
	mov	QWORD PTR [rsi+34872], rdi
	mov	rcx, rbx
	call	?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z ; stbi__process_gif_raster
	mov	r8, rax

; 6890 :             if (!o) return NULL;

	test	rax, rax
	je	$LN178@stbi__gif_

; 6894 :             if (first_frame && (g->bgindex > 0)) {

	cmp	DWORD PTR first_frame$1$[rsp], r12d
	je	SHORT $LN14@stbi__gif_
	cmp	DWORD PTR [rsi+36], r12d
	jle	SHORT $LN14@stbi__gif_

; 6891 : 
; 6892 :             // if this was the first frame,
; 6893 :             pcount = g->w * g->h;

	mov	eax, DWORD PTR [rsi]
	imul	eax, DWORD PTR [rsi+4]

; 6895 :                // if first frame, any pixel not drawn to gets the background color
; 6896 :                for (pi = 0; pi < pcount; ++pi) {

	movsxd	rdx, eax
	test	eax, eax
	jle	SHORT $LN14@stbi__gif_
	npad	1
$LL15@stbi__gif_:

; 6897 :                   if (g->history[pi] == 0) {

	mov	rax, QWORD PTR [rsi+24]
	cmp	BYTE PTR [r12+rax], 0
	jne	SHORT $LN13@stbi__gif_

; 6898 :                      g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;

	movsxd	rax, DWORD PTR [rsi+36]
	mov	BYTE PTR [rsi+rax*4+55], 255		; 000000ffH

; 6899 :                      memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );

	movsxd	rax, DWORD PTR [rsi+36]
	mov	rcx, QWORD PTR [rsi+8]
	mov	eax, DWORD PTR [rsi+rax*4+52]
	mov	DWORD PTR [rcx+r12*4], eax
$LN13@stbi__gif_:

; 6895 :                // if first frame, any pixel not drawn to gets the background color
; 6896 :                for (pi = 0; pi < pcount; ++pi) {

	inc	r12
	cmp	r12, rdx
	jl	SHORT $LL15@stbi__gif_
$LN14@stbi__gif_:

; 6900 :                   }
; 6901 :                }
; 6902 :             }
; 6903 : 
; 6904 :             return o;

	mov	rax, r8
	jmp	SHORT $LN9@stbi__gif_
$LN39@stbi__gif_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BE@NAMJKDNF@missing?5color?5table@

; 6886 :             } else
; 6887 :                return stbi__errpuc("missing color table", "Corrupt GIF");

	jmp	SHORT $LN244@stbi__gif_
$LN33@stbi__gif_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BF@GIAALCNJ@bad?5Image?5Descriptor@

; 6854 :                return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");

	jmp	SHORT $LN244@stbi__gif_
$LN177@stbi__gif_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0N@DJABBOOH@unknown?5code@
$LN244@stbi__gif_:

; 6944 : 
; 6945 :          default:
; 6946 :             return stbi__errpuc("unknown code", "Corrupt GIF");
; 6947 :       }
; 6948 :    }
; 6949 : }

	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	QWORD PTR [rdx+rcx], rax
$LN178@stbi__gif_:
	xor	eax, eax
$LN9@stbi__gif_:
	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z ENDP ; stbi__gif_load_next
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
_TEXT	SEGMENT
g$ = 48
__$ArrayPad$ = 34976
s$ = 35040
x$ = 35048
y$ = 35056
comp$ = 35064
req_comp$dead$ = 35072
ri$dead$ = 35080
?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__gif_load, COMDAT

; 7048 : {

	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15
	mov	eax, 34992				; 000088b0H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r15, r8
	mov	r14, rdx
	mov	rdi, rcx

; 7049 :    stbi_uc *u = 0;
; 7050 :    stbi__gif g;
; 7051 :    memset(&g, 0, sizeof(g));

	xor	edx, edx
	mov	r8d, 34928				; 00008870H
	lea	rcx, QWORD PTR g$[rsp]
	mov	rbx, r9
	call	memset

; 7052 :    STBI_NOTUSED(ri);
; 7053 : 
; 7054 :    u = stbi__gif_load_next(s, &g, comp, req_comp, 0);

	xor	esi, esi
	lea	rdx, QWORD PTR g$[rsp]
	mov	r8, rbx
	mov	QWORD PTR [rsp+32], rsi
	mov	rcx, rdi
	lea	r9d, QWORD PTR [rsi+4]
	call	?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z ; stbi__gif_load_next

; 7055 :    if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
; 7056 :    if (u) {

	cmp	rax, rdi
	cmovne	rsi, rax
	test	rsi, rsi
	je	SHORT $LN3@stbi__gif_

; 7057 :       *x = g.w;

	mov	eax, DWORD PTR g$[rsp]
	mov	DWORD PTR [r14], eax

; 7058 :       *y = g.h;

	mov	eax, DWORD PTR g$[rsp+4]
	mov	DWORD PTR [r15], eax

; 7059 : 
; 7060 :       // moved conversion to after successful load so that the same
; 7061 :       // can be done for multiple frames.
; 7062 :       if (req_comp && req_comp != 4)
; 7063 :          u = stbi__convert_format(u, 4, req_comp, g.w, g.h);

	jmp	SHORT $LN6@stbi__gif_
$LN3@stbi__gif_:

; 7064 :    } else if (g.out) {

	mov	rcx, QWORD PTR g$[rsp+8]
	test	rcx, rcx
	je	SHORT $LN6@stbi__gif_

; 7065 :       // if there was an error and we allocated an image buffer, free it!
; 7066 :       STBI_FREE(g.out);

	call	QWORD PTR __imp_free
$LN6@stbi__gif_:

; 7067 :    }
; 7068 : 
; 7069 :    // free buffers needed for multiple frame loading;
; 7070 :    STBI_FREE(g.history);

	mov	rcx, QWORD PTR g$[rsp+24]
	call	QWORD PTR __imp_free

; 7071 :    STBI_FREE(g.background);

	mov	rcx, QWORD PTR g$[rsp+16]
	call	QWORD PTR __imp_free

; 7072 : 
; 7073 :    return u;

	mov	rax, rsi

; 7074 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 34992				; 000088b0H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__gif_load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z
_TEXT	SEGMENT
s$ = 48
signature$ = 56
?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z PROC	; stbi__hdr_test_core, COMDAT

; 7087 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 7088 :    int i;
; 7089 :    for (i=0; signature[i]; ++i)

	cmp	BYTE PTR [rdx], 0
	mov	rbx, rdx
	mov	rsi, rcx
	je	SHORT $LN18@stbi__hdr_
$LL4@stbi__hdr_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rsi+192]
	cmp	rax, QWORD PTR [rsi+200]
	jae	SHORT $LN8@stbi__hdr_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rsi+192], rax
	jmp	SHORT $LN7@stbi__hdr_
$LN8@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rsi+48], 0
	je	SHORT $LN9@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rsi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rsi+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rsi+192], rax
	jmp	SHORT $LN7@stbi__hdr_
$LN9@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN7@stbi__hdr_:

; 7090 :       if (stbi__get8(s) != signature[i])

	movsx	eax, BYTE PTR [rbx]
	movzx	ecx, cl
	cmp	ecx, eax
	jne	SHORT $LN14@stbi__hdr_

; 7088 :    int i;
; 7089 :    for (i=0; signature[i]; ++i)

	inc	rbx
	cmp	BYTE PTR [rbx], 0
	jne	SHORT $LL4@stbi__hdr_
$LN18@stbi__hdr_:

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	rax, QWORD PTR [rsi+208]
	mov	QWORD PTR [rsi+192], rax

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	rax, QWORD PTR [rsi+216]
	mov	QWORD PTR [rsi+200], rax

; 7092 :    stbi__rewind(s);
; 7093 :    return 1;

	mov	eax, 1
$LN1@stbi__hdr_:

; 7094 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN14@stbi__hdr_:

; 7091 :           return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__hdr_
?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z ENDP	; stbi__hdr_test_core
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__hdr_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__hdr_test, COMDAT

; 7097 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx
	lea	rdi, QWORD PTR [rcx+192]
	lea	rbx, OFFSET FLAT:??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@
	npad	10
$LL7@stbi__hdr_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rdi]
	cmp	rax, QWORD PTR [rsi+200]
	jae	SHORT $LN11@stbi__hdr_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi], rax
	jmp	SHORT $LN10@stbi__hdr_
$LN11@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rsi+48], 0
	je	SHORT $LN12@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rsi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi], rax
	jmp	SHORT $LN10@stbi__hdr_
$LN12@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN10@stbi__hdr_:

; 7090 :       if (stbi__get8(s) != signature[i])

	movsx	eax, BYTE PTR [rbx]
	movzx	ecx, cl
	cmp	ecx, eax
	jne	SHORT $LN21@stbi__hdr_

; 1621 : }
; 1622 : 
; 1623 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1624 : // nothing
; 1625 : #else
; 1626 : stbi_inline static int stbi__at_eof(stbi__context *s)
; 1627 : {
; 1628 :    if (s->io.read) {
; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;
; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;
; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;
; 1636 : }
; 1637 : #endif
; 1638 : 
; 1639 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
; 1640 : // nothing
; 1641 : #else
; 1642 : static void stbi__skip(stbi__context *s, int n)
; 1643 : {
; 1644 :    if (n == 0) return;  // already there!
; 1645 :    if (n < 0) {
; 1646 :       s->img_buffer = s->img_buffer_end;
; 1647 :       return;
; 1648 :    }
; 1649 :    if (s->io.read) {
; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1651 :       if (blen < n) {
; 1652 :          s->img_buffer = s->img_buffer_end;
; 1653 :          (s->io.skip)(s->io_user_data, n - blen);
; 1654 :          return;
; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;
; 1658 : }
; 1659 : #endif
; 1660 : 
; 1661 : #if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
; 1662 : // nothing
; 1663 : #else
; 1664 : static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
; 1665 : {
; 1666 :    if (s->io.read) {
; 1667 :       int blen = (int) (s->img_buffer_end - s->img_buffer);
; 1668 :       if (blen < n) {
; 1669 :          int res, count;
; 1670 : 
; 1671 :          memcpy(buffer, s->img_buffer, blen);
; 1672 : 
; 1673 :          count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
; 1674 :          res = (count == (n-blen));
; 1675 :          s->img_buffer = s->img_buffer_end;
; 1676 :          return res;
; 1677 :       }
; 1678 :    }
; 1679 : 
; 1680 :    if (s->img_buffer+n <= s->img_buffer_end) {
; 1681 :       memcpy(buffer, s->img_buffer, n);
; 1682 :       s->img_buffer += n;
; 1683 :       return 1;
; 1684 :    } else
; 1685 :       return 0;
; 1686 : }
; 1687 : #endif
; 1688 : 
; 1689 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1690 : // nothing
; 1691 : #else
; 1692 : static int stbi__get16be(stbi__context *s)
; 1693 : {
; 1694 :    int z = stbi__get8(s);
; 1695 :    return (z << 8) + stbi__get8(s);
; 1696 : }
; 1697 : #endif
; 1698 : 
; 1699 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
; 1700 : // nothing
; 1701 : #else
; 1702 : static stbi__uint32 stbi__get32be(stbi__context *s)
; 1703 : {
; 1704 :    stbi__uint32 z = stbi__get16be(s);
; 1705 :    return (z << 16) + stbi__get16be(s);
; 1706 : }
; 1707 : #endif
; 1708 : 
; 1709 : #if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
; 1710 : // nothing
; 1711 : #else
; 1712 : static int stbi__get16le(stbi__context *s)
; 1713 : {
; 1714 :    int z = stbi__get8(s);
; 1715 :    return z + (stbi__get8(s) << 8);
; 1716 : }
; 1717 : #endif
; 1718 : 
; 1719 : #ifndef STBI_NO_BMP
; 1720 : static stbi__uint32 stbi__get32le(stbi__context *s)
; 1721 : {
; 1722 :    stbi__uint32 z = stbi__get16le(s);
; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;
; 1724 :    return z;
; 1725 : }
; 1726 : #endif
; 1727 : 
; 1728 : #define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
; 1729 : 
; 1730 : #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1731 : // nothing
; 1732 : #else
; 1733 : //////////////////////////////////////////////////////////////////////////////
; 1734 : //
; 1735 : //  generic converter from built-in img_n to req_comp
; 1736 : //    individual types do this automatically as much as possible (e.g. jpeg
; 1737 : //    does all cases internally since it needs to colorspace convert anyway,
; 1738 : //    and it never has alpha, so very few cases ). png can automatically
; 1739 : //    interleave an alpha=255 channel, but falls back to this for other cases
; 1740 : //
; 1741 : //  assume data buffer is malloced, so malloc a new one and free that one
; 1742 : //  only failure mode is malloc failing
; 1743 : 
; 1744 : static stbi_uc stbi__compute_y(int r, int g, int b)
; 1745 : {
; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1747 : }
; 1748 : #endif
; 1749 : 
; 1750 : #if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
; 1751 : // nothing
; 1752 : #else
; 1753 : static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1754 : {
; 1755 :    int i,j;
; 1756 :    unsigned char *good;
; 1757 : 
; 1758 :    if (req_comp == img_n) return data;
; 1759 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1760 : 
; 1761 :    good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
; 1762 :    if (good == NULL) {
; 1763 :       STBI_FREE(data);
; 1764 :       return stbi__errpuc("outofmem", "Out of memory");
; 1765 :    }
; 1766 : 
; 1767 :    for (j=0; j < (int) y; ++j) {
; 1768 :       unsigned char *src  = data + j * x * img_n   ;
; 1769 :       unsigned char *dest = good + j * x * req_comp;
; 1770 : 
; 1771 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1772 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1773 :       // convert source image with img_n components to one with req_comp components;
; 1774 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1775 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1776 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
; 1777 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1778 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
; 1779 :          STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
; 1780 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
; 1781 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
; 1782 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
; 1783 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1784 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
; 1785 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
; 1786 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1787 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
; 1788 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
; 1789 :       }
; 1790 :       #undef STBI__CASE
; 1791 :    }
; 1792 : 
; 1793 :    STBI_FREE(data);
; 1794 :    return good;
; 1795 : }
; 1796 : #endif
; 1797 : 
; 1798 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1799 : // nothing
; 1800 : #else
; 1801 : static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
; 1802 : {
; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
; 1804 : }
; 1805 : #endif
; 1806 : 
; 1807 : #if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
; 1808 : // nothing
; 1809 : #else
; 1810 : static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
; 1811 : {
; 1812 :    int i,j;
; 1813 :    stbi__uint16 *good;
; 1814 : 
; 1815 :    if (req_comp == img_n) return data;
; 1816 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1817 : 
; 1818 :    good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
; 1819 :    if (good == NULL) {
; 1820 :       STBI_FREE(data);
; 1821 :       return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
; 1822 :    }
; 1823 : 
; 1824 :    for (j=0; j < (int) y; ++j) {
; 1825 :       stbi__uint16 *src  = data + j * x * img_n   ;
; 1826 :       stbi__uint16 *dest = good + j * x * req_comp;
; 1827 : 
; 1828 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1829 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1830 :       // convert source image with img_n components to one with req_comp components;
; 1831 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1832 :       switch (STBI__COMBO(img_n, req_comp)) {
; 1833 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
; 1834 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1835 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
; 1836 :          STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
; 1837 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
; 1838 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
; 1839 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
; 1840 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1841 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
; 1842 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
; 1843 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
; 1844 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
; 1845 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
; 1846 :       }
; 1847 :       #undef STBI__CASE
; 1848 :    }
; 1849 : 
; 1850 :    STBI_FREE(data);
; 1851 :    return good;
; 1852 : }
; 1853 : #endif
; 1854 : 
; 1855 : #ifndef STBI_NO_LINEAR
; 1856 : static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
; 1857 : {
; 1858 :    int i,k,n;
; 1859 :    float *output;
; 1860 :    if (!data) return NULL;
; 1861 :    output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
; 1862 :    if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
; 1863 :    // compute number of non-alpha components
; 1864 :    if (comp & 1) n = comp; else n = comp-1;
; 1865 :    for (i=0; i < x*y; ++i) {
; 1866 :       for (k=0; k < n; ++k) {
; 1867 :          output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
; 1868 :       }
; 1869 :    }
; 1870 :    if (n < comp) {
; 1871 :       for (i=0; i < x*y; ++i) {
; 1872 :          output[i*comp + n] = data[i*comp + n]/255.0f;
; 1873 :       }
; 1874 :    }
; 1875 :    STBI_FREE(data);
; 1876 :    return output;
; 1877 : }
; 1878 : #endif
; 1879 : 
; 1880 : #ifndef STBI_NO_HDR
; 1881 : #define stbi__float2int(x)   ((int) (x))
; 1882 : static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
; 1883 : {
; 1884 :    int i,k,n;
; 1885 :    stbi_uc *output;
; 1886 :    if (!data) return NULL;
; 1887 :    output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
; 1888 :    if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
; 1889 :    // compute number of non-alpha components
; 1890 :    if (comp & 1) n = comp; else n = comp-1;
; 1891 :    for (i=0; i < x*y; ++i) {
; 1892 :       for (k=0; k < n; ++k) {
; 1893 :          float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
; 1894 :          if (z < 0) z = 0;
; 1895 :          if (z > 255) z = 255;
; 1896 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1897 :       }
; 1898 :       if (k < comp) {
; 1899 :          float z = data[i*comp+k] * 255 + 0.5f;
; 1900 :          if (z < 0) z = 0;
; 1901 :          if (z > 255) z = 255;
; 1902 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);
; 1903 :       }
; 1904 :    }
; 1905 :    STBI_FREE(data);
; 1906 :    return output;
; 1907 : }
; 1908 : #endif
; 1909 : 
; 1910 : //////////////////////////////////////////////////////////////////////////////
; 1911 : //
; 1912 : //  "baseline" JPEG/JFIF decoder
; 1913 : //
; 1914 : //    simple implementation
; 1915 : //      - doesn't support delayed output of y-dimension
; 1916 : //      - simple interface (only one output format: 8-bit interleaved RGB)
; 1917 : //      - doesn't try to recover corrupt jpegs
; 1918 : //      - doesn't allow partial loading, loading multiple at once
; 1919 : //      - still fast on x86 (copying globals into locals doesn't help x86)
; 1920 : //      - allocates lots of intermediate memory (full size of all components)
; 1921 : //        - non-interleaved case requires this anyway
; 1922 : //        - allows good upsampling (see next)
; 1923 : //    high-quality
; 1924 : //      - upsampled channels are bilinearly interpolated, even across blocks
; 1925 : //      - quality integer IDCT derived from IJG's 'slow'
; 1926 : //    performance
; 1927 : //      - fast huffman; reasonable integer IDCT
; 1928 : //      - some SIMD kernels for common paths on targets with SSE2/NEON
; 1929 : //      - uses a lot of intermediate memory, could cache poorly
; 1930 : 
; 1931 : #ifndef STBI_NO_JPEG
; 1932 : 
; 1933 : // huffman decoding acceleration
; 1934 : #define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
; 1935 : 
; 1936 : typedef struct
; 1937 : {
; 1938 :    stbi_uc  fast[1 << FAST_BITS];
; 1939 :    // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
; 1940 :    stbi__uint16 code[256];
; 1941 :    stbi_uc  values[256];
; 1942 :    stbi_uc  size[257];
; 1943 :    unsigned int maxcode[18];
; 1944 :    int    delta[17];   // old 'firstsymbol' - old 'firstcode'
; 1945 : } stbi__huffman;
; 1946 : 
; 1947 : typedef struct
; 1948 : {
; 1949 :    stbi__context *s;
; 1950 :    stbi__huffman huff_dc[4];
; 1951 :    stbi__huffman huff_ac[4];
; 1952 :    stbi__uint16 dequant[4][64];
; 1953 :    stbi__int16 fast_ac[4][1 << FAST_BITS];
; 1954 : 
; 1955 : // sizes for components, interleaved MCUs
; 1956 :    int img_h_max, img_v_max;
; 1957 :    int img_mcu_x, img_mcu_y;
; 1958 :    int img_mcu_w, img_mcu_h;
; 1959 : 
; 1960 : // definition of jpeg image component
; 1961 :    struct
; 1962 :    {
; 1963 :       int id;
; 1964 :       int h,v;
; 1965 :       int tq;
; 1966 :       int hd,ha;
; 1967 :       int dc_pred;
; 1968 : 
; 1969 :       int x,y,w2,h2;
; 1970 :       stbi_uc *data;
; 1971 :       void *raw_data, *raw_coeff;
; 1972 :       stbi_uc *linebuf;
; 1973 :       short   *coeff;   // progressive only
; 1974 :       int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
; 1975 :    } img_comp[4];
; 1976 : 
; 1977 :    stbi__uint32   code_buffer; // jpeg entropy-coded buffer
; 1978 :    int            code_bits;   // number of valid bits
; 1979 :    unsigned char  marker;      // marker seen while filling entropy buffer
; 1980 :    int            nomore;      // flag if we saw a marker so must stop
; 1981 : 
; 1982 :    int            progressive;
; 1983 :    int            spec_start;
; 1984 :    int            spec_end;
; 1985 :    int            succ_high;
; 1986 :    int            succ_low;
; 1987 :    int            eob_run;
; 1988 :    int            jfif;
; 1989 :    int            app14_color_transform; // Adobe APP14 tag
; 1990 :    int            rgb;
; 1991 : 
; 1992 :    int scan_n, order[4];
; 1993 :    int restart_interval, todo;
; 1994 : 
; 1995 : // kernels
; 1996 :    void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
; 1997 :    void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
; 1998 :    stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
; 1999 : } stbi__jpeg;
; 2000 : 
; 2001 : static int stbi__build_huffman(stbi__huffman *h, int *count)
; 2002 : {
; 2003 :    int i,j,k=0;
; 2004 :    unsigned int code;
; 2005 :    // build size list for each symbol (from JPEG spec)
; 2006 :    for (i=0; i < 16; ++i) {
; 2007 :       for (j=0; j < count[i]; ++j) {
; 2008 :          h->size[k++] = (stbi_uc) (i+1);
; 2009 :          if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");
; 2010 :       }
; 2011 :    }
; 2012 :    h->size[k] = 0;
; 2013 : 
; 2014 :    // compute actual symbols (from jpeg spec)
; 2015 :    code = 0;
; 2016 :    k = 0;
; 2017 :    for(j=1; j <= 16; ++j) {
; 2018 :       // compute delta to add to code to compute symbol id
; 2019 :       h->delta[j] = k - code;
; 2020 :       if (h->size[k] == j) {
; 2021 :          while (h->size[k] == j)
; 2022 :             h->code[k++] = (stbi__uint16) (code++);
; 2023 :          if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
; 2024 :       }
; 2025 :       // compute largest code + 1 for this size, preshifted as needed later
; 2026 :       h->maxcode[j] = code << (16-j);
; 2027 :       code <<= 1;
; 2028 :    }
; 2029 :    h->maxcode[j] = 0xffffffff;
; 2030 : 
; 2031 :    // build non-spec acceleration table; 255 is flag for not-accelerated
; 2032 :    memset(h->fast, 255, 1 << FAST_BITS);
; 2033 :    for (i=0; i < k; ++i) {
; 2034 :       int s = h->size[i];
; 2035 :       if (s <= FAST_BITS) {
; 2036 :          int c = h->code[i] << (FAST_BITS-s);
; 2037 :          int m = 1 << (FAST_BITS-s);
; 2038 :          for (j=0; j < m; ++j) {
; 2039 :             h->fast[c+j] = (stbi_uc) i;
; 2040 :          }
; 2041 :       }
; 2042 :    }
; 2043 :    return 1;
; 2044 : }
; 2045 : 
; 2046 : // build a table that decodes both magnitude and value of small ACs in
; 2047 : // one go.
; 2048 : static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
; 2049 : {
; 2050 :    int i;
; 2051 :    for (i=0; i < (1 << FAST_BITS); ++i) {
; 2052 :       stbi_uc fast = h->fast[i];
; 2053 :       fast_ac[i] = 0;
; 2054 :       if (fast < 255) {
; 2055 :          int rs = h->values[fast];
; 2056 :          int run = (rs >> 4) & 15;
; 2057 :          int magbits = rs & 15;
; 2058 :          int len = h->size[fast];
; 2059 : 
; 2060 :          if (magbits && len + magbits <= FAST_BITS) {
; 2061 :             // magnitude code followed by receive_extend code
; 2062 :             int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
; 2063 :             int m = 1 << (magbits - 1);
; 2064 :             if (k < m) k += (~0U << magbits) + 1;
; 2065 :             // if the result is small enough, we can fit it in fast_ac table
; 2066 :             if (k >= -128 && k <= 127)
; 2067 :                fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
; 2068 :          }
; 2069 :       }
; 2070 :    }
; 2071 : }
; 2072 : 
; 2073 : static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
; 2074 : {
; 2075 :    do {
; 2076 :       unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
; 2077 :       if (b == 0xff) {
; 2078 :          int c = stbi__get8(j->s);
; 2079 :          while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
; 2080 :          if (c != 0) {
; 2081 :             j->marker = (unsigned char) c;
; 2082 :             j->nomore = 1;
; 2083 :             return;
; 2084 :          }
; 2085 :       }
; 2086 :       j->code_buffer |= b << (24 - j->code_bits);
; 2087 :       j->code_bits += 8;
; 2088 :    } while (j->code_bits <= 24);
; 2089 : }
; 2090 : 
; 2091 : // (1 << n) - 1
; 2092 : static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
; 2093 : 
; 2094 : // decode a jpeg huffman value from the bitstream
; 2095 : stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
; 2096 : {
; 2097 :    unsigned int temp;
; 2098 :    int c,k;
; 2099 : 
; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2105 :    k = h->fast[c];
; 2106 :    if (k < 255) {
; 2107 :       int s = h->size[k];
; 2108 :       if (s > j->code_bits)
; 2109 :          return -1;
; 2110 :       j->code_buffer <<= s;
; 2111 :       j->code_bits -= s;
; 2112 :       return h->values[k];
; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;
; 2122 :    for (k=FAST_BITS+1 ; ; ++k)
; 2123 :       if (temp < h->maxcode[k])
; 2124 :          break;
; 2125 :    if (k == 17) {
; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;
; 2128 :       return -1;
; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)
; 2132 :       return -1;
; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!
; 2137 :        return -1;
; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;
; 2142 :    j->code_buffer <<= k;
; 2143 :    return h->values[c];
; 2144 : }
; 2145 : 
; 2146 : // bias[n] = (-1<<n) + 1
; 2147 : static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};
; 2148 : 
; 2149 : // combined JPEG 'receive' and JPEG 'extend', since baseline
; 2150 : // always extends everything it receives.
; 2151 : stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
; 2152 : {
; 2153 :    unsigned int k;
; 2154 :    int sgn;
; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
; 2159 :    k = stbi_lrot(j->code_buffer, n);
; 2160 :    j->code_buffer = k & ~stbi__bmask[n];
; 2161 :    k &= stbi__bmask[n];
; 2162 :    j->code_bits -= n;
; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));
; 2164 : }
; 2165 : 
; 2166 : // get some unsigned bits
; 2167 : stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
; 2168 : {
; 2169 :    unsigned int k;
; 2170 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
; 2171 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2172 :    k = stbi_lrot(j->code_buffer, n);
; 2173 :    j->code_buffer = k & ~stbi__bmask[n];
; 2174 :    k &= stbi__bmask[n];
; 2175 :    j->code_bits -= n;
; 2176 :    return k;
; 2177 : }
; 2178 : 
; 2179 : stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
; 2180 : {
; 2181 :    unsigned int k;
; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
; 2184 :    k = j->code_buffer;
; 2185 :    j->code_buffer <<= 1;
; 2186 :    --j->code_bits;
; 2187 :    return k & 0x80000000;
; 2188 : }
; 2189 : 
; 2190 : // given a value that's at position X in the zigzag stream,
; 2191 : // where does it appear in the 8x8 matrix coded as row-major?
; 2192 : static const stbi_uc stbi__jpeg_dezigzag[64+15] =
; 2193 : {
; 2194 :     0,  1,  8, 16,  9,  2,  3, 10,
; 2195 :    17, 24, 32, 25, 18, 11,  4,  5,
; 2196 :    12, 19, 26, 33, 40, 48, 41, 34,
; 2197 :    27, 20, 13,  6,  7, 14, 21, 28,
; 2198 :    35, 42, 49, 56, 57, 50, 43, 36,
; 2199 :    29, 22, 15, 23, 30, 37, 44, 51,
; 2200 :    58, 59, 52, 45, 38, 31, 39, 46,
; 2201 :    53, 60, 61, 54, 47, 55, 62, 63,
; 2202 :    // let corrupt input sample past end
; 2203 :    63, 63, 63, 63, 63, 63, 63, 63,
; 2204 :    63, 63, 63, 63, 63, 63, 63
; 2205 : };
; 2206 : 
; 2207 : // decode one 64-entry block--
; 2208 : static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
; 2209 : {
; 2210 :    int diff,dc,k;
; 2211 :    int t;
; 2212 : 
; 2213 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2214 :    t = stbi__jpeg_huff_decode(j, hdc);
; 2215 :    if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");
; 2216 : 
; 2217 :    // 0 all the ac values now so we can do it 32-bits at a time
; 2218 :    memset(data,0,64*sizeof(data[0]));
; 2219 : 
; 2220 :    diff = t ? stbi__extend_receive(j, t) : 0;
; 2221 :    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");
; 2222 :    dc = j->img_comp[b].dc_pred + diff;
; 2223 :    j->img_comp[b].dc_pred = dc;
; 2224 :    if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2225 :    data[0] = (short) (dc * dequant[0]);
; 2226 : 
; 2227 :    // decode AC components, see JPEG spec
; 2228 :    k = 1;
; 2229 :    do {
; 2230 :       unsigned int zig;
; 2231 :       int c,r,s;
; 2232 :       if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2233 :       c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2234 :       r = fac[c];
; 2235 :       if (r) { // fast-AC path
; 2236 :          k += (r >> 4) & 15; // run
; 2237 :          s = r & 15; // combined length
; 2238 :          if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2239 :          j->code_buffer <<= s;
; 2240 :          j->code_bits -= s;
; 2241 :          // decode into unzigzag'd location
; 2242 :          zig = stbi__jpeg_dezigzag[k++];
; 2243 :          data[zig] = (short) ((r >> 8) * dequant[zig]);
; 2244 :       } else {
; 2245 :          int rs = stbi__jpeg_huff_decode(j, hac);
; 2246 :          if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2247 :          s = rs & 15;
; 2248 :          r = rs >> 4;
; 2249 :          if (s == 0) {
; 2250 :             if (rs != 0xf0) break; // end block
; 2251 :             k += 16;
; 2252 :          } else {
; 2253 :             k += r;
; 2254 :             // decode into unzigzag'd location
; 2255 :             zig = stbi__jpeg_dezigzag[k++];
; 2256 :             data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
; 2257 :          }
; 2258 :       }
; 2259 :    } while (k < 64);
; 2260 :    return 1;
; 2261 : }
; 2262 : 
; 2263 : static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
; 2264 : {
; 2265 :    int diff,dc;
; 2266 :    int t;
; 2267 :    if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2268 : 
; 2269 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2270 : 
; 2271 :    if (j->succ_high == 0) {
; 2272 :       // first scan for DC coefficient, must be first
; 2273 :       memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
; 2274 :       t = stbi__jpeg_huff_decode(j, hdc);
; 2275 :       if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2276 :       diff = t ? stbi__extend_receive(j, t) : 0;
; 2277 : 
; 2278 :       if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");
; 2279 :       dc = j->img_comp[b].dc_pred + diff;
; 2280 :       j->img_comp[b].dc_pred = dc;
; 2281 :       if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2282 :       data[0] = (short) (dc * (1 << j->succ_low));
; 2283 :    } else {
; 2284 :       // refinement scan for DC coefficient
; 2285 :       if (stbi__jpeg_get_bit(j))
; 2286 :          data[0] += (short) (1 << j->succ_low);
; 2287 :    }
; 2288 :    return 1;
; 2289 : }
; 2290 : 
; 2291 : // @OPTIMIZE: store non-zigzagged during the decode passes,
; 2292 : // and only de-zigzag when dequantizing
; 2293 : static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
; 2294 : {
; 2295 :    int k;
; 2296 :    if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
; 2297 : 
; 2298 :    if (j->succ_high == 0) {
; 2299 :       int shift = j->succ_low;
; 2300 : 
; 2301 :       if (j->eob_run) {
; 2302 :          --j->eob_run;
; 2303 :          return 1;
; 2304 :       }
; 2305 : 
; 2306 :       k = j->spec_start;
; 2307 :       do {
; 2308 :          unsigned int zig;
; 2309 :          int c,r,s;
; 2310 :          if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
; 2311 :          c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
; 2312 :          r = fac[c];
; 2313 :          if (r) { // fast-AC path
; 2314 :             k += (r >> 4) & 15; // run
; 2315 :             s = r & 15; // combined length
; 2316 :             if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
; 2317 :             j->code_buffer <<= s;
; 2318 :             j->code_bits -= s;
; 2319 :             zig = stbi__jpeg_dezigzag[k++];
; 2320 :             data[zig] = (short) ((r >> 8) * (1 << shift));
; 2321 :          } else {
; 2322 :             int rs = stbi__jpeg_huff_decode(j, hac);
; 2323 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2324 :             s = rs & 15;
; 2325 :             r = rs >> 4;
; 2326 :             if (s == 0) {
; 2327 :                if (r < 15) {
; 2328 :                   j->eob_run = (1 << r);
; 2329 :                   if (r)
; 2330 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2331 :                   --j->eob_run;
; 2332 :                   break;
; 2333 :                }
; 2334 :                k += 16;
; 2335 :             } else {
; 2336 :                k += r;
; 2337 :                zig = stbi__jpeg_dezigzag[k++];
; 2338 :                data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
; 2339 :             }
; 2340 :          }
; 2341 :       } while (k <= j->spec_end);
; 2342 :    } else {
; 2343 :       // refinement scan for these AC coefficients
; 2344 : 
; 2345 :       short bit = (short) (1 << j->succ_low);
; 2346 : 
; 2347 :       if (j->eob_run) {
; 2348 :          --j->eob_run;
; 2349 :          for (k = j->spec_start; k <= j->spec_end; ++k) {
; 2350 :             short *p = &data[stbi__jpeg_dezigzag[k]];
; 2351 :             if (*p != 0)
; 2352 :                if (stbi__jpeg_get_bit(j))
; 2353 :                   if ((*p & bit)==0) {
; 2354 :                      if (*p > 0)
; 2355 :                         *p += bit;
; 2356 :                      else
; 2357 :                         *p -= bit;
; 2358 :                   }
; 2359 :          }
; 2360 :       } else {
; 2361 :          k = j->spec_start;
; 2362 :          do {
; 2363 :             int r,s;
; 2364 :             int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
; 2365 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
; 2366 :             s = rs & 15;
; 2367 :             r = rs >> 4;
; 2368 :             if (s == 0) {
; 2369 :                if (r < 15) {
; 2370 :                   j->eob_run = (1 << r) - 1;
; 2371 :                   if (r)
; 2372 :                      j->eob_run += stbi__jpeg_get_bits(j, r);
; 2373 :                   r = 64; // force end of block
; 2374 :                } else {
; 2375 :                   // r=15 s=0 should write 16 0s, so we just do
; 2376 :                   // a run of 15 0s and then write s (which is 0),
; 2377 :                   // so we don't have to do anything special here
; 2378 :                }
; 2379 :             } else {
; 2380 :                if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
; 2381 :                // sign bit
; 2382 :                if (stbi__jpeg_get_bit(j))
; 2383 :                   s = bit;
; 2384 :                else
; 2385 :                   s = -bit;
; 2386 :             }
; 2387 : 
; 2388 :             // advance by r
; 2389 :             while (k <= j->spec_end) {
; 2390 :                short *p = &data[stbi__jpeg_dezigzag[k++]];
; 2391 :                if (*p != 0) {
; 2392 :                   if (stbi__jpeg_get_bit(j))
; 2393 :                      if ((*p & bit)==0) {
; 2394 :                         if (*p > 0)
; 2395 :                            *p += bit;
; 2396 :                         else
; 2397 :                            *p -= bit;
; 2398 :                      }
; 2399 :                } else {
; 2400 :                   if (r == 0) {
; 2401 :                      *p = (short) s;
; 2402 :                      break;
; 2403 :                   }
; 2404 :                   --r;
; 2405 :                }
; 2406 :             }
; 2407 :          } while (k <= j->spec_end);
; 2408 :       }
; 2409 :    }
; 2410 :    return 1;
; 2411 : }
; 2412 : 
; 2413 : // take a -128..127 value and stbi__clamp it and convert to 0..255
; 2414 : stbi_inline static stbi_uc stbi__clamp(int x)
; 2415 : {
; 2416 :    // trick to use a single test to catch both cases
; 2417 :    if ((unsigned int) x > 255) {
; 2418 :       if (x < 0) return 0;
; 2419 :       if (x > 255) return 255;
; 2420 :    }
; 2421 :    return (stbi_uc) x;
; 2422 : }
; 2423 : 
; 2424 : #define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
; 2425 : #define stbi__fsh(x)  ((x) * 4096)
; 2426 : 
; 2427 : // derived from jidctint -- DCT_ISLOW
; 2428 : #define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
; 2429 :    int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
; 2430 :    p2 = s2;                                    \
; 2431 :    p3 = s6;                                    \
; 2432 :    p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
; 2433 :    t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
; 2434 :    t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
; 2435 :    p2 = s0;                                    \
; 2436 :    p3 = s4;                                    \
; 2437 :    t0 = stbi__fsh(p2+p3);                      \
; 2438 :    t1 = stbi__fsh(p2-p3);                      \
; 2439 :    x0 = t0+t3;                                 \
; 2440 :    x3 = t0-t3;                                 \
; 2441 :    x1 = t1+t2;                                 \
; 2442 :    x2 = t1-t2;                                 \
; 2443 :    t0 = s7;                                    \
; 2444 :    t1 = s5;                                    \
; 2445 :    t2 = s3;                                    \
; 2446 :    t3 = s1;                                    \
; 2447 :    p3 = t0+t2;                                 \
; 2448 :    p4 = t1+t3;                                 \
; 2449 :    p1 = t0+t3;                                 \
; 2450 :    p2 = t1+t2;                                 \
; 2451 :    p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
; 2452 :    t0 = t0*stbi__f2f( 0.298631336f);           \
; 2453 :    t1 = t1*stbi__f2f( 2.053119869f);           \
; 2454 :    t2 = t2*stbi__f2f( 3.072711026f);           \
; 2455 :    t3 = t3*stbi__f2f( 1.501321110f);           \
; 2456 :    p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
; 2457 :    p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
; 2458 :    p3 = p3*stbi__f2f(-1.961570560f);           \
; 2459 :    p4 = p4*stbi__f2f(-0.390180644f);           \
; 2460 :    t3 += p1+p4;                                \
; 2461 :    t2 += p2+p3;                                \
; 2462 :    t1 += p2+p4;                                \
; 2463 :    t0 += p1+p3;
; 2464 : 
; 2465 : static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
; 2466 : {
; 2467 :    int i,val[64],*v=val;
; 2468 :    stbi_uc *o;
; 2469 :    short *d = data;
; 2470 : 
; 2471 :    // columns
; 2472 :    for (i=0; i < 8; ++i,++d, ++v) {
; 2473 :       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2474 :       if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2475 :            && d[40]==0 && d[48]==0 && d[56]==0) {
; 2476 :          //    no shortcut                 0     seconds
; 2477 :          //    (1|2|3|4|5|6|7)==0          0     seconds
; 2478 :          //    all separate               -0.047 seconds
; 2479 :          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2480 :          int dcterm = d[0]*4;
; 2481 :          v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
; 2482 :       } else {
; 2483 :          STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
; 2484 :          // constants scaled things up by 1<<12; let's bring them back
; 2485 :          // down, but keep 2 extra bits of precision
; 2486 :          x0 += 512; x1 += 512; x2 += 512; x3 += 512;
; 2487 :          v[ 0] = (x0+t3) >> 10;
; 2488 :          v[56] = (x0-t3) >> 10;
; 2489 :          v[ 8] = (x1+t2) >> 10;
; 2490 :          v[48] = (x1-t2) >> 10;
; 2491 :          v[16] = (x2+t1) >> 10;
; 2492 :          v[40] = (x2-t1) >> 10;
; 2493 :          v[24] = (x3+t0) >> 10;
; 2494 :          v[32] = (x3-t0) >> 10;
; 2495 :       }
; 2496 :    }
; 2497 : 
; 2498 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
; 2499 :       // no fast case since the first 1D IDCT spread components out
; 2500 :       STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
; 2501 :       // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2502 :       // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2503 :       // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2504 :       // so we want to round that, which means adding 0.5 * 1<<17,
; 2505 :       // aka 65536. Also, we'll end up with -128 to 127 that we want
; 2506 :       // to encode as 0..255 by adding 128, so we'll add that before the shift
; 2507 :       x0 += 65536 + (128<<17);
; 2508 :       x1 += 65536 + (128<<17);
; 2509 :       x2 += 65536 + (128<<17);
; 2510 :       x3 += 65536 + (128<<17);
; 2511 :       // tried computing the shifts into temps, or'ing the temps to see
; 2512 :       // if any were out of range, but that was slower
; 2513 :       o[0] = stbi__clamp((x0+t3) >> 17);
; 2514 :       o[7] = stbi__clamp((x0-t3) >> 17);
; 2515 :       o[1] = stbi__clamp((x1+t2) >> 17);
; 2516 :       o[6] = stbi__clamp((x1-t2) >> 17);
; 2517 :       o[2] = stbi__clamp((x2+t1) >> 17);
; 2518 :       o[5] = stbi__clamp((x2-t1) >> 17);
; 2519 :       o[3] = stbi__clamp((x3+t0) >> 17);
; 2520 :       o[4] = stbi__clamp((x3-t0) >> 17);
; 2521 :    }
; 2522 : }
; 2523 : 
; 2524 : #ifdef STBI_SSE2
; 2525 : // sse2 integer IDCT. not the fastest possible implementation but it
; 2526 : // produces bit-identical results to the generic C version so it's
; 2527 : // fully "transparent".
; 2528 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2529 : {
; 2530 :    // This is constructed to match our regular (generic) integer IDCT exactly.
; 2531 :    __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2532 :    __m128i tmp;
; 2533 : 
; 2534 :    // dot product constant: even elems=x, odd elems=y
; 2535 :    #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2536 : 
; 2537 :    // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2538 :    // out(1) = c1[even]*x + c1[odd]*y
; 2539 :    #define dct_rot(out0,out1, x,y,c0,c1) \
; 2540 :       __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2541 :       __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2542 :       __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2543 :       __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2544 :       __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2545 :       __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2546 : 
; 2547 :    // out = in << 12  (in 16-bit, out 32-bit)
; 2548 :    #define dct_widen(out, in) \
; 2549 :       __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2550 :       __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2551 : 
; 2552 :    // wide add
; 2553 :    #define dct_wadd(out, a, b) \
; 2554 :       __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2555 :       __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2556 : 
; 2557 :    // wide sub
; 2558 :    #define dct_wsub(out, a, b) \
; 2559 :       __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2560 :       __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2561 : 
; 2562 :    // butterfly a/b, add bias, then shift by "s" and pack
; 2563 :    #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2564 :       { \
; 2565 :          __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2566 :          __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2567 :          dct_wadd(sum, abiased, b); \
; 2568 :          dct_wsub(dif, abiased, b); \
; 2569 :          out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2570 :          out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2571 :       }
; 2572 : 
; 2573 :    // 8-bit interleave step (for transposes)
; 2574 :    #define dct_interleave8(a, b) \
; 2575 :       tmp = a; \
; 2576 :       a = _mm_unpacklo_epi8(a, b); \
; 2577 :       b = _mm_unpackhi_epi8(tmp, b)
; 2578 : 
; 2579 :    // 16-bit interleave step (for transposes)
; 2580 :    #define dct_interleave16(a, b) \
; 2581 :       tmp = a; \
; 2582 :       a = _mm_unpacklo_epi16(a, b); \
; 2583 :       b = _mm_unpackhi_epi16(tmp, b)
; 2584 : 
; 2585 :    #define dct_pass(bias,shift) \
; 2586 :       { \
; 2587 :          /* even part */ \
; 2588 :          dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2589 :          __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2590 :          __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2591 :          dct_widen(t0e, sum04); \
; 2592 :          dct_widen(t1e, dif04); \
; 2593 :          dct_wadd(x0, t0e, t3e); \
; 2594 :          dct_wsub(x3, t0e, t3e); \
; 2595 :          dct_wadd(x1, t1e, t2e); \
; 2596 :          dct_wsub(x2, t1e, t2e); \
; 2597 :          /* odd part */ \
; 2598 :          dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2599 :          dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2600 :          __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2601 :          __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2602 :          dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2603 :          dct_wadd(x4, y0o, y4o); \
; 2604 :          dct_wadd(x5, y1o, y5o); \
; 2605 :          dct_wadd(x6, y2o, y5o); \
; 2606 :          dct_wadd(x7, y3o, y4o); \
; 2607 :          dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2608 :          dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2609 :          dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2610 :          dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2611 :       }
; 2612 : 
; 2613 :    __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
; 2614 :    __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
; 2615 :    __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
; 2616 :    __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
; 2617 :    __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
; 2618 :    __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
; 2619 :    __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
; 2620 :    __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
; 2621 : 
; 2622 :    // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2623 :    __m128i bias_0 = _mm_set1_epi32(512);
; 2624 :    __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
; 2625 : 
; 2626 :    // load
; 2627 :    row0 = _mm_load_si128((const __m128i *) (data + 0*8));
; 2628 :    row1 = _mm_load_si128((const __m128i *) (data + 1*8));
; 2629 :    row2 = _mm_load_si128((const __m128i *) (data + 2*8));
; 2630 :    row3 = _mm_load_si128((const __m128i *) (data + 3*8));
; 2631 :    row4 = _mm_load_si128((const __m128i *) (data + 4*8));
; 2632 :    row5 = _mm_load_si128((const __m128i *) (data + 5*8));
; 2633 :    row6 = _mm_load_si128((const __m128i *) (data + 6*8));
; 2634 :    row7 = _mm_load_si128((const __m128i *) (data + 7*8));
; 2635 : 
; 2636 :    // column pass
; 2637 :    dct_pass(bias_0, 10);
; 2638 : 
; 2639 :    {
; 2640 :       // 16bit 8x8 transpose pass 1
; 2641 :       dct_interleave16(row0, row4);
; 2642 :       dct_interleave16(row1, row5);
; 2643 :       dct_interleave16(row2, row6);
; 2644 :       dct_interleave16(row3, row7);
; 2645 : 
; 2646 :       // transpose pass 2
; 2647 :       dct_interleave16(row0, row2);
; 2648 :       dct_interleave16(row1, row3);
; 2649 :       dct_interleave16(row4, row6);
; 2650 :       dct_interleave16(row5, row7);
; 2651 : 
; 2652 :       // transpose pass 3
; 2653 :       dct_interleave16(row0, row1);
; 2654 :       dct_interleave16(row2, row3);
; 2655 :       dct_interleave16(row4, row5);
; 2656 :       dct_interleave16(row6, row7);
; 2657 :    }
; 2658 : 
; 2659 :    // row pass
; 2660 :    dct_pass(bias_1, 17);
; 2661 : 
; 2662 :    {
; 2663 :       // pack
; 2664 :       __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
; 2665 :       __m128i p1 = _mm_packus_epi16(row2, row3);
; 2666 :       __m128i p2 = _mm_packus_epi16(row4, row5);
; 2667 :       __m128i p3 = _mm_packus_epi16(row6, row7);
; 2668 : 
; 2669 :       // 8bit 8x8 transpose pass 1
; 2670 :       dct_interleave8(p0, p2); // a0e0a1e1...
; 2671 :       dct_interleave8(p1, p3); // c0g0c1g1...
; 2672 : 
; 2673 :       // transpose pass 2
; 2674 :       dct_interleave8(p0, p1); // a0c0e0g0...
; 2675 :       dct_interleave8(p2, p3); // b0d0f0h0...
; 2676 : 
; 2677 :       // transpose pass 3
; 2678 :       dct_interleave8(p0, p2); // a0b0c0d0...
; 2679 :       dct_interleave8(p1, p3); // a4b4c4d4...
; 2680 : 
; 2681 :       // store
; 2682 :       _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
; 2683 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
; 2684 :       _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
; 2685 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
; 2686 :       _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
; 2687 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
; 2688 :       _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
; 2689 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
; 2690 :    }
; 2691 : 
; 2692 : #undef dct_const
; 2693 : #undef dct_rot
; 2694 : #undef dct_widen
; 2695 : #undef dct_wadd
; 2696 : #undef dct_wsub
; 2697 : #undef dct_bfly32o
; 2698 : #undef dct_interleave8
; 2699 : #undef dct_interleave16
; 2700 : #undef dct_pass
; 2701 : }
; 2702 : 
; 2703 : #endif // STBI_SSE2
; 2704 : 
; 2705 : #ifdef STBI_NEON
; 2706 : 
; 2707 : // NEON integer IDCT. should produce bit-identical
; 2708 : // results to the generic C version.
; 2709 : static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
; 2710 : {
; 2711 :    int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;
; 2712 : 
; 2713 :    int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
; 2714 :    int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
; 2715 :    int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
; 2716 :    int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
; 2717 :    int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
; 2718 :    int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
; 2719 :    int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
; 2720 :    int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
; 2721 :    int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
; 2722 :    int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
; 2723 :    int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
; 2724 :    int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));
; 2725 : 
; 2726 : #define dct_long_mul(out, inq, coeff) \
; 2727 :    int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
; 2728 :    int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)
; 2729 : 
; 2730 : #define dct_long_mac(out, acc, inq, coeff) \
; 2731 :    int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
; 2732 :    int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)
; 2733 : 
; 2734 : #define dct_widen(out, inq) \
; 2735 :    int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
; 2736 :    int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)
; 2737 : 
; 2738 : // wide add
; 2739 : #define dct_wadd(out, a, b) \
; 2740 :    int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
; 2741 :    int32x4_t out##_h = vaddq_s32(a##_h, b##_h)
; 2742 : 
; 2743 : // wide sub
; 2744 : #define dct_wsub(out, a, b) \
; 2745 :    int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
; 2746 :    int32x4_t out##_h = vsubq_s32(a##_h, b##_h)
; 2747 : 
; 2748 : // butterfly a/b, then shift using "shiftop" by "s" and pack
; 2749 : #define dct_bfly32o(out0,out1, a,b,shiftop,s) \
; 2750 :    { \
; 2751 :       dct_wadd(sum, a, b); \
; 2752 :       dct_wsub(dif, a, b); \
; 2753 :       out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
; 2754 :       out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
; 2755 :    }
; 2756 : 
; 2757 : #define dct_pass(shiftop, shift) \
; 2758 :    { \
; 2759 :       /* even part */ \
; 2760 :       int16x8_t sum26 = vaddq_s16(row2, row6); \
; 2761 :       dct_long_mul(p1e, sum26, rot0_0); \
; 2762 :       dct_long_mac(t2e, p1e, row6, rot0_1); \
; 2763 :       dct_long_mac(t3e, p1e, row2, rot0_2); \
; 2764 :       int16x8_t sum04 = vaddq_s16(row0, row4); \
; 2765 :       int16x8_t dif04 = vsubq_s16(row0, row4); \
; 2766 :       dct_widen(t0e, sum04); \
; 2767 :       dct_widen(t1e, dif04); \
; 2768 :       dct_wadd(x0, t0e, t3e); \
; 2769 :       dct_wsub(x3, t0e, t3e); \
; 2770 :       dct_wadd(x1, t1e, t2e); \
; 2771 :       dct_wsub(x2, t1e, t2e); \
; 2772 :       /* odd part */ \
; 2773 :       int16x8_t sum15 = vaddq_s16(row1, row5); \
; 2774 :       int16x8_t sum17 = vaddq_s16(row1, row7); \
; 2775 :       int16x8_t sum35 = vaddq_s16(row3, row5); \
; 2776 :       int16x8_t sum37 = vaddq_s16(row3, row7); \
; 2777 :       int16x8_t sumodd = vaddq_s16(sum17, sum35); \
; 2778 :       dct_long_mul(p5o, sumodd, rot1_0); \
; 2779 :       dct_long_mac(p1o, p5o, sum17, rot1_1); \
; 2780 :       dct_long_mac(p2o, p5o, sum35, rot1_2); \
; 2781 :       dct_long_mul(p3o, sum37, rot2_0); \
; 2782 :       dct_long_mul(p4o, sum15, rot2_1); \
; 2783 :       dct_wadd(sump13o, p1o, p3o); \
; 2784 :       dct_wadd(sump24o, p2o, p4o); \
; 2785 :       dct_wadd(sump23o, p2o, p3o); \
; 2786 :       dct_wadd(sump14o, p1o, p4o); \
; 2787 :       dct_long_mac(x4, sump13o, row7, rot3_0); \
; 2788 :       dct_long_mac(x5, sump24o, row5, rot3_1); \
; 2789 :       dct_long_mac(x6, sump23o, row3, rot3_2); \
; 2790 :       dct_long_mac(x7, sump14o, row1, rot3_3); \
; 2791 :       dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
; 2792 :       dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
; 2793 :       dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
; 2794 :       dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
; 2795 :    }
; 2796 : 
; 2797 :    // load
; 2798 :    row0 = vld1q_s16(data + 0*8);
; 2799 :    row1 = vld1q_s16(data + 1*8);
; 2800 :    row2 = vld1q_s16(data + 2*8);
; 2801 :    row3 = vld1q_s16(data + 3*8);
; 2802 :    row4 = vld1q_s16(data + 4*8);
; 2803 :    row5 = vld1q_s16(data + 5*8);
; 2804 :    row6 = vld1q_s16(data + 6*8);
; 2805 :    row7 = vld1q_s16(data + 7*8);
; 2806 : 
; 2807 :    // add DC bias
; 2808 :    row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));
; 2809 : 
; 2810 :    // column pass
; 2811 :    dct_pass(vrshrn_n_s32, 10);
; 2812 : 
; 2813 :    // 16bit 8x8 transpose
; 2814 :    {
; 2815 : // these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
; 2816 : // whether compilers actually get this is another story, sadly.
; 2817 : #define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
; 2818 : #define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
; 2819 : #define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }
; 2820 : 
; 2821 :       // pass 1
; 2822 :       dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
; 2823 :       dct_trn16(row2, row3);
; 2824 :       dct_trn16(row4, row5);
; 2825 :       dct_trn16(row6, row7);
; 2826 : 
; 2827 :       // pass 2
; 2828 :       dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
; 2829 :       dct_trn32(row1, row3);
; 2830 :       dct_trn32(row4, row6);
; 2831 :       dct_trn32(row5, row7);
; 2832 : 
; 2833 :       // pass 3
; 2834 :       dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
; 2835 :       dct_trn64(row1, row5);
; 2836 :       dct_trn64(row2, row6);
; 2837 :       dct_trn64(row3, row7);
; 2838 : 
; 2839 : #undef dct_trn16
; 2840 : #undef dct_trn32
; 2841 : #undef dct_trn64
; 2842 :    }
; 2843 : 
; 2844 :    // row pass
; 2845 :    // vrshrn_n_s32 only supports shifts up to 16, we need
; 2846 :    // 17. so do a non-rounding shift of 16 first then follow
; 2847 :    // up with a rounding shift by 1.
; 2848 :    dct_pass(vshrn_n_s32, 16);
; 2849 : 
; 2850 :    {
; 2851 :       // pack and round
; 2852 :       uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
; 2853 :       uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
; 2854 :       uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
; 2855 :       uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
; 2856 :       uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
; 2857 :       uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
; 2858 :       uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
; 2859 :       uint8x8_t p7 = vqrshrun_n_s16(row7, 1);
; 2860 : 
; 2861 :       // again, these can translate into one instruction, but often don't.
; 2862 : #define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
; 2863 : #define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
; 2864 : #define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }
; 2865 : 
; 2866 :       // sadly can't use interleaved stores here since we only write
; 2867 :       // 8 bytes to each scan line!
; 2868 : 
; 2869 :       // 8x8 8-bit transpose pass 1
; 2870 :       dct_trn8_8(p0, p1);
; 2871 :       dct_trn8_8(p2, p3);
; 2872 :       dct_trn8_8(p4, p5);
; 2873 :       dct_trn8_8(p6, p7);
; 2874 : 
; 2875 :       // pass 2
; 2876 :       dct_trn8_16(p0, p2);
; 2877 :       dct_trn8_16(p1, p3);
; 2878 :       dct_trn8_16(p4, p6);
; 2879 :       dct_trn8_16(p5, p7);
; 2880 : 
; 2881 :       // pass 3
; 2882 :       dct_trn8_32(p0, p4);
; 2883 :       dct_trn8_32(p1, p5);
; 2884 :       dct_trn8_32(p2, p6);
; 2885 :       dct_trn8_32(p3, p7);
; 2886 : 
; 2887 :       // store
; 2888 :       vst1_u8(out, p0); out += out_stride;
; 2889 :       vst1_u8(out, p1); out += out_stride;
; 2890 :       vst1_u8(out, p2); out += out_stride;
; 2891 :       vst1_u8(out, p3); out += out_stride;
; 2892 :       vst1_u8(out, p4); out += out_stride;
; 2893 :       vst1_u8(out, p5); out += out_stride;
; 2894 :       vst1_u8(out, p6); out += out_stride;
; 2895 :       vst1_u8(out, p7);
; 2896 : 
; 2897 : #undef dct_trn8_8
; 2898 : #undef dct_trn8_16
; 2899 : #undef dct_trn8_32
; 2900 :    }
; 2901 : 
; 2902 : #undef dct_long_mul
; 2903 : #undef dct_long_mac
; 2904 : #undef dct_widen
; 2905 : #undef dct_wadd
; 2906 : #undef dct_wsub
; 2907 : #undef dct_bfly32o
; 2908 : #undef dct_pass
; 2909 : }
; 2910 : 
; 2911 : #endif // STBI_NEON
; 2912 : 
; 2913 : #define STBI__MARKER_none  0xff
; 2914 : // if there's a pending marker from the entropy stream, return that
; 2915 : // otherwise, fetch from the stream and get a marker. if there's no
; 2916 : // marker, return 0xff, which is never a valid marker value
; 2917 : static stbi_uc stbi__get_marker(stbi__jpeg *j)
; 2918 : {
; 2919 :    stbi_uc x;
; 2920 :    if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
; 2921 :    x = stbi__get8(j->s);
; 2922 :    if (x != 0xff) return STBI__MARKER_none;
; 2923 :    while (x == 0xff)
; 2924 :       x = stbi__get8(j->s); // consume repeated 0xff fill bytes
; 2925 :    return x;
; 2926 : }
; 2927 : 
; 2928 : // in each scan, we'll have scan_n components, and the order
; 2929 : // of the components is specified by order[]
; 2930 : #define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
; 2931 : 
; 2932 : // after a restart interval, stbi__jpeg_reset the entropy decoder and
; 2933 : // the dc prediction
; 2934 : static void stbi__jpeg_reset(stbi__jpeg *j)
; 2935 : {
; 2936 :    j->code_bits = 0;
; 2937 :    j->code_buffer = 0;
; 2938 :    j->nomore = 0;
; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
; 2940 :    j->marker = STBI__MARKER_none;
; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
; 2942 :    j->eob_run = 0;
; 2943 :    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2944 :    // since we don't even allow 1<<30 pixels
; 2945 : }
; 2946 : 
; 2947 : static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
; 2948 : {
; 2949 :    stbi__jpeg_reset(z);
; 2950 :    if (!z->progressive) {
; 2951 :       if (z->scan_n == 1) {
; 2952 :          int i,j;
; 2953 :          STBI_SIMD_ALIGN(short, data[64]);
; 2954 :          int n = z->order[0];
; 2955 :          // non-interleaved data, we just need to process one block at a time,
; 2956 :          // in trivial scanline order
; 2957 :          // number of blocks to do just depends on how many actual "pixels" this
; 2958 :          // component has, independent of interleaved MCU blocking and such
; 2959 :          int w = (z->img_comp[n].x+7) >> 3;
; 2960 :          int h = (z->img_comp[n].y+7) >> 3;
; 2961 :          for (j=0; j < h; ++j) {
; 2962 :             for (i=0; i < w; ++i) {
; 2963 :                int ha = z->img_comp[n].ha;
; 2964 :                if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2965 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 2966 :                // every data block is an MCU, so countdown the restart interval
; 2967 :                if (--z->todo <= 0) {
; 2968 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 2969 :                   // if it's NOT a restart, then just bail, so we get corrupt data
; 2970 :                   // rather than no data
; 2971 :                   if (!STBI__RESTART(z->marker)) return 1;
; 2972 :                   stbi__jpeg_reset(z);
; 2973 :                }
; 2974 :             }
; 2975 :          }
; 2976 :          return 1;
; 2977 :       } else { // interleaved
; 2978 :          int i,j,k,x,y;
; 2979 :          STBI_SIMD_ALIGN(short, data[64]);
; 2980 :          for (j=0; j < z->img_mcu_y; ++j) {
; 2981 :             for (i=0; i < z->img_mcu_x; ++i) {
; 2982 :                // scan an interleaved mcu... process scan_n components in order
; 2983 :                for (k=0; k < z->scan_n; ++k) {
; 2984 :                   int n = z->order[k];
; 2985 :                   // scan out an mcu's worth of this component; that's just determined
; 2986 :                   // by the basic H and V specified for the component
; 2987 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 2988 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 2989 :                         int x2 = (i*z->img_comp[n].h + x)*8;
; 2990 :                         int y2 = (j*z->img_comp[n].v + y)*8;
; 2991 :                         int ha = z->img_comp[n].ha;
; 2992 :                         if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
; 2993 :                         z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
; 2994 :                      }
; 2995 :                   }
; 2996 :                }
; 2997 :                // after all interleaved components, that's an interleaved MCU,
; 2998 :                // so now count down the restart interval
; 2999 :                if (--z->todo <= 0) {
; 3000 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3001 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3002 :                   stbi__jpeg_reset(z);
; 3003 :                }
; 3004 :             }
; 3005 :          }
; 3006 :          return 1;
; 3007 :       }
; 3008 :    } else {
; 3009 :       if (z->scan_n == 1) {
; 3010 :          int i,j;
; 3011 :          int n = z->order[0];
; 3012 :          // non-interleaved data, we just need to process one block at a time,
; 3013 :          // in trivial scanline order
; 3014 :          // number of blocks to do just depends on how many actual "pixels" this
; 3015 :          // component has, independent of interleaved MCU blocking and such
; 3016 :          int w = (z->img_comp[n].x+7) >> 3;
; 3017 :          int h = (z->img_comp[n].y+7) >> 3;
; 3018 :          for (j=0; j < h; ++j) {
; 3019 :             for (i=0; i < w; ++i) {
; 3020 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3021 :                if (z->spec_start == 0) {
; 3022 :                   if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3023 :                      return 0;
; 3024 :                } else {
; 3025 :                   int ha = z->img_comp[n].ha;
; 3026 :                   if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
; 3027 :                      return 0;
; 3028 :                }
; 3029 :                // every data block is an MCU, so countdown the restart interval
; 3030 :                if (--z->todo <= 0) {
; 3031 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3032 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3033 :                   stbi__jpeg_reset(z);
; 3034 :                }
; 3035 :             }
; 3036 :          }
; 3037 :          return 1;
; 3038 :       } else { // interleaved
; 3039 :          int i,j,k,x,y;
; 3040 :          for (j=0; j < z->img_mcu_y; ++j) {
; 3041 :             for (i=0; i < z->img_mcu_x; ++i) {
; 3042 :                // scan an interleaved mcu... process scan_n components in order
; 3043 :                for (k=0; k < z->scan_n; ++k) {
; 3044 :                   int n = z->order[k];
; 3045 :                   // scan out an mcu's worth of this component; that's just determined
; 3046 :                   // by the basic H and V specified for the component
; 3047 :                   for (y=0; y < z->img_comp[n].v; ++y) {
; 3048 :                      for (x=0; x < z->img_comp[n].h; ++x) {
; 3049 :                         int x2 = (i*z->img_comp[n].h + x);
; 3050 :                         int y2 = (j*z->img_comp[n].v + y);
; 3051 :                         short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
; 3052 :                         if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
; 3053 :                            return 0;
; 3054 :                      }
; 3055 :                   }
; 3056 :                }
; 3057 :                // after all interleaved components, that's an interleaved MCU,
; 3058 :                // so now count down the restart interval
; 3059 :                if (--z->todo <= 0) {
; 3060 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
; 3061 :                   if (!STBI__RESTART(z->marker)) return 1;
; 3062 :                   stbi__jpeg_reset(z);
; 3063 :                }
; 3064 :             }
; 3065 :          }
; 3066 :          return 1;
; 3067 :       }
; 3068 :    }
; 3069 : }
; 3070 : 
; 3071 : static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
; 3072 : {
; 3073 :    int i;
; 3074 :    for (i=0; i < 64; ++i)
; 3075 :       data[i] *= dequant[i];
; 3076 : }
; 3077 : 
; 3078 : static void stbi__jpeg_finish(stbi__jpeg *z)
; 3079 : {
; 3080 :    if (z->progressive) {
; 3081 :       // dequantize and idct the data
; 3082 :       int i,j,n;
; 3083 :       for (n=0; n < z->s->img_n; ++n) {
; 3084 :          int w = (z->img_comp[n].x+7) >> 3;
; 3085 :          int h = (z->img_comp[n].y+7) >> 3;
; 3086 :          for (j=0; j < h; ++j) {
; 3087 :             for (i=0; i < w; ++i) {
; 3088 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
; 3089 :                stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
; 3090 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
; 3091 :             }
; 3092 :          }
; 3093 :       }
; 3094 :    }
; 3095 : }
; 3096 : 
; 3097 : static int stbi__process_marker(stbi__jpeg *z, int m)
; 3098 : {
; 3099 :    int L;
; 3100 :    switch (m) {
; 3101 :       case STBI__MARKER_none: // no marker found
; 3102 :          return stbi__err("expected marker","Corrupt JPEG");
; 3103 : 
; 3104 :       case 0xDD: // DRI - specify restart interval
; 3105 :          if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
; 3106 :          z->restart_interval = stbi__get16be(z->s);
; 3107 :          return 1;
; 3108 : 
; 3109 :       case 0xDB: // DQT - define quantization table
; 3110 :          L = stbi__get16be(z->s)-2;
; 3111 :          while (L > 0) {
; 3112 :             int q = stbi__get8(z->s);
; 3113 :             int p = q >> 4, sixteen = (p != 0);
; 3114 :             int t = q & 15,i;
; 3115 :             if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
; 3116 :             if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");
; 3117 : 
; 3118 :             for (i=0; i < 64; ++i)
; 3119 :                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
; 3120 :             L -= (sixteen ? 129 : 65);
; 3121 :          }
; 3122 :          return L==0;
; 3123 : 
; 3124 :       case 0xC4: // DHT - define huffman table
; 3125 :          L = stbi__get16be(z->s)-2;
; 3126 :          while (L > 0) {
; 3127 :             stbi_uc *v;
; 3128 :             int sizes[16],i,n=0;
; 3129 :             int q = stbi__get8(z->s);
; 3130 :             int tc = q >> 4;
; 3131 :             int th = q & 15;
; 3132 :             if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
; 3133 :             for (i=0; i < 16; ++i) {
; 3134 :                sizes[i] = stbi__get8(z->s);
; 3135 :                n += sizes[i];
; 3136 :             }
; 3137 :             if(n > 256) return stbi__err("bad DHT header","Corrupt JPEG"); // Loop over i < n would write past end of values!
; 3138 :             L -= 17;
; 3139 :             if (tc == 0) {
; 3140 :                if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
; 3141 :                v = z->huff_dc[th].values;
; 3142 :             } else {
; 3143 :                if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
; 3144 :                v = z->huff_ac[th].values;
; 3145 :             }
; 3146 :             for (i=0; i < n; ++i)
; 3147 :                v[i] = stbi__get8(z->s);
; 3148 :             if (tc != 0)
; 3149 :                stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
; 3150 :             L -= n;
; 3151 :          }
; 3152 :          return L==0;
; 3153 :    }
; 3154 : 
; 3155 :    // check for comment block or APP blocks
; 3156 :    if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
; 3157 :       L = stbi__get16be(z->s);
; 3158 :       if (L < 2) {
; 3159 :          if (m == 0xFE)
; 3160 :             return stbi__err("bad COM len","Corrupt JPEG");
; 3161 :          else
; 3162 :             return stbi__err("bad APP len","Corrupt JPEG");
; 3163 :       }
; 3164 :       L -= 2;
; 3165 : 
; 3166 :       if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
; 3167 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3168 :          int ok = 1;
; 3169 :          int i;
; 3170 :          for (i=0; i < 5; ++i)
; 3171 :             if (stbi__get8(z->s) != tag[i])
; 3172 :                ok = 0;
; 3173 :          L -= 5;
; 3174 :          if (ok)
; 3175 :             z->jfif = 1;
; 3176 :       } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;
; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)
; 3181 :             if (stbi__get8(z->s) != tag[i])
; 3182 :                ok = 0;
; 3183 :          L -= 6;
; 3184 :          if (ok) {
; 3185 :             stbi__get8(z->s); // version
; 3186 :             stbi__get16be(z->s); // flags0
; 3187 :             stbi__get16be(z->s); // flags1
; 3188 :             z->app14_color_transform = stbi__get8(z->s); // color transform
; 3189 :             L -= 6;
; 3190 :          }
; 3191 :       }
; 3192 : 
; 3193 :       stbi__skip(z->s, L);
; 3194 :       return 1;
; 3195 :    }
; 3196 : 
; 3197 :    return stbi__err("unknown marker","Corrupt JPEG");
; 3198 : }
; 3199 : 
; 3200 : // after we see SOS
; 3201 : static int stbi__process_scan_header(stbi__jpeg *z)
; 3202 : {
; 3203 :    int i;
; 3204 :    int Ls = stbi__get16be(z->s);
; 3205 :    z->scan_n = stbi__get8(z->s);
; 3206 :    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
; 3207 :    if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
; 3208 :    for (i=0; i < z->scan_n; ++i) {
; 3209 :       int id = stbi__get8(z->s), which;
; 3210 :       int q = stbi__get8(z->s);
; 3211 :       for (which = 0; which < z->s->img_n; ++which)
; 3212 :          if (z->img_comp[which].id == id)
; 3213 :             break;
; 3214 :       if (which == z->s->img_n) return 0; // no match
; 3215 :       z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
; 3216 :       z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
; 3217 :       z->order[i] = which;
; 3218 :    }
; 3219 : 
; 3220 :    {
; 3221 :       int aa;
; 3222 :       z->spec_start = stbi__get8(z->s);
; 3223 :       z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
; 3224 :       aa = stbi__get8(z->s);
; 3225 :       z->succ_high = (aa >> 4);
; 3226 :       z->succ_low  = (aa & 15);
; 3227 :       if (z->progressive) {
; 3228 :          if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
; 3229 :             return stbi__err("bad SOS", "Corrupt JPEG");
; 3230 :       } else {
; 3231 :          if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3232 :          if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
; 3233 :          z->spec_end = 63;
; 3234 :       }
; 3235 :    }
; 3236 : 
; 3237 :    return 1;
; 3238 : }
; 3239 : 
; 3240 : static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
; 3241 : {
; 3242 :    int i;
; 3243 :    for (i=0; i < ncomp; ++i) {
; 3244 :       if (z->img_comp[i].raw_data) {
; 3245 :          STBI_FREE(z->img_comp[i].raw_data);
; 3246 :          z->img_comp[i].raw_data = NULL;
; 3247 :          z->img_comp[i].data = NULL;
; 3248 :       }
; 3249 :       if (z->img_comp[i].raw_coeff) {
; 3250 :          STBI_FREE(z->img_comp[i].raw_coeff);
; 3251 :          z->img_comp[i].raw_coeff = 0;
; 3252 :          z->img_comp[i].coeff = 0;
; 3253 :       }
; 3254 :       if (z->img_comp[i].linebuf) {
; 3255 :          STBI_FREE(z->img_comp[i].linebuf);
; 3256 :          z->img_comp[i].linebuf = NULL;
; 3257 :       }
; 3258 :    }
; 3259 :    return why;
; 3260 : }
; 3261 : 
; 3262 : static int stbi__process_frame_header(stbi__jpeg *z, int scan)
; 3263 : {
; 3264 :    stbi__context *s = z->s;
; 3265 :    int Lf,p,i,q, h_max=1,v_max=1,c;
; 3266 :    Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
; 3267 :    p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
; 3268 :    s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
; 3269 :    s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
; 3270 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 3271 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 3272 :    c = stbi__get8(s);
; 3273 :    if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");
; 3274 :    s->img_n = c;
; 3275 :    for (i=0; i < c; ++i) {
; 3276 :       z->img_comp[i].data = NULL;
; 3277 :       z->img_comp[i].linebuf = NULL;
; 3278 :    }
; 3279 : 
; 3280 :    if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");
; 3281 : 
; 3282 :    z->rgb = 0;
; 3283 :    for (i=0; i < s->img_n; ++i) {
; 3284 :       static const unsigned char rgb[3] = { 'R', 'G', 'B' };
; 3285 :       z->img_comp[i].id = stbi__get8(s);
; 3286 :       if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
; 3287 :          ++z->rgb;
; 3288 :       q = stbi__get8(s);
; 3289 :       z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
; 3290 :       z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
; 3291 :       z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
; 3292 :    }
; 3293 : 
; 3294 :    if (scan != STBI__SCAN_load) return 1;
; 3295 : 
; 3296 :    if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");
; 3297 : 
; 3298 :    for (i=0; i < s->img_n; ++i) {
; 3299 :       if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
; 3300 :       if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
; 3301 :    }
; 3302 : 
; 3303 :    // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
; 3304 :    // and I've never seen a non-corrupted JPEG file actually use them
; 3305 :    for (i=0; i < s->img_n; ++i) {
; 3306 :       if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");
; 3307 :       if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");
; 3308 :    }
; 3309 : 
; 3310 :    // compute interleaved mcu info
; 3311 :    z->img_h_max = h_max;
; 3312 :    z->img_v_max = v_max;
; 3313 :    z->img_mcu_w = h_max * 8;
; 3314 :    z->img_mcu_h = v_max * 8;
; 3315 :    // these sizes can't be more than 17 bits
; 3316 :    z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
; 3317 :    z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;
; 3318 : 
; 3319 :    for (i=0; i < s->img_n; ++i) {
; 3320 :       // number of effective pixels (e.g. for non-interleaved MCU)
; 3321 :       z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
; 3322 :       z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
; 3323 :       // to simplify generation, we'll allocate enough memory to decode
; 3324 :       // the bogus oversized data from using interleaved MCUs and their
; 3325 :       // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
; 3326 :       // discard the extra data until colorspace conversion
; 3327 :       //
; 3328 :       // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
; 3329 :       // so these muls can't overflow with 32-bit ints (which we require)
; 3330 :       z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
; 3331 :       z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
; 3332 :       z->img_comp[i].coeff = 0;
; 3333 :       z->img_comp[i].raw_coeff = 0;
; 3334 :       z->img_comp[i].linebuf = NULL;
; 3335 :       z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
; 3336 :       if (z->img_comp[i].raw_data == NULL)
; 3337 :          return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
; 3338 :       // align blocks for idct using mmx/sse
; 3339 :       z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
; 3340 :       if (z->progressive) {
; 3341 :          // w2, h2 are multiples of 8 (see above)
; 3342 :          z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
; 3343 :          z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
; 3344 :          z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
; 3345 :          if (z->img_comp[i].raw_coeff == NULL)
; 3346 :             return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
; 3347 :          z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
; 3348 :       }
; 3349 :    }
; 3350 : 
; 3351 :    return 1;
; 3352 : }
; 3353 : 
; 3354 : // use comparisons since in some cases we handle more than one case (e.g. SOF)
; 3355 : #define stbi__DNL(x)         ((x) == 0xdc)
; 3356 : #define stbi__SOI(x)         ((x) == 0xd8)
; 3357 : #define stbi__EOI(x)         ((x) == 0xd9)
; 3358 : #define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
; 3359 : #define stbi__SOS(x)         ((x) == 0xda)
; 3360 : 
; 3361 : #define stbi__SOF_progressive(x)   ((x) == 0xc2)
; 3362 : 
; 3363 : static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
; 3364 : {
; 3365 :    int m;
; 3366 :    z->jfif = 0;
; 3367 :    z->app14_color_transform = -1; // valid values are 0,1,2
; 3368 :    z->marker = STBI__MARKER_none; // initialize cached marker to empty
; 3369 :    m = stbi__get_marker(z);
; 3370 :    if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
; 3371 :    if (scan == STBI__SCAN_type) return 1;
; 3372 :    m = stbi__get_marker(z);
; 3373 :    while (!stbi__SOF(m)) {
; 3374 :       if (!stbi__process_marker(z,m)) return 0;
; 3375 :       m = stbi__get_marker(z);
; 3376 :       while (m == STBI__MARKER_none) {
; 3377 :          // some files have extra padding after their blocks, so ok, we'll scan
; 3378 :          if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
; 3379 :          m = stbi__get_marker(z);
; 3380 :       }
; 3381 :    }
; 3382 :    z->progressive = stbi__SOF_progressive(m);
; 3383 :    if (!stbi__process_frame_header(z, scan)) return 0;
; 3384 :    return 1;
; 3385 : }
; 3386 : 
; 3387 : static int stbi__skip_jpeg_junk_at_end(stbi__jpeg *j)
; 3388 : {
; 3389 :    // some JPEGs have junk at end, skip over it but if we find what looks
; 3390 :    // like a valid marker, resume there
; 3391 :    while (!stbi__at_eof(j->s)) {
; 3392 :       int x = stbi__get8(j->s);
; 3393 :       while (x == 255) { // might be a marker
; 3394 :          if (stbi__at_eof(j->s)) return STBI__MARKER_none;
; 3395 :          x = stbi__get8(j->s);
; 3396 :          if (x != 0x00 && x != 0xff) {
; 3397 :             // not a stuffed zero or lead-in to another marker, looks
; 3398 :             // like an actual marker, return it
; 3399 :             return x;
; 3400 :          }
; 3401 :          // stuffed zero has x=0 now which ends the loop, meaning we go
; 3402 :          // back to regular scan loop.
; 3403 :          // repeated 0xff keeps trying to read the next byte of the marker.
; 3404 :       }
; 3405 :    }
; 3406 :    return STBI__MARKER_none;
; 3407 : }
; 3408 : 
; 3409 : // decode image to YCbCr format
; 3410 : static int stbi__decode_jpeg_image(stbi__jpeg *j)
; 3411 : {
; 3412 :    int m;
; 3413 :    for (m = 0; m < 4; m++) {
; 3414 :       j->img_comp[m].raw_data = NULL;
; 3415 :       j->img_comp[m].raw_coeff = NULL;
; 3416 :    }
; 3417 :    j->restart_interval = 0;
; 3418 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
; 3419 :    m = stbi__get_marker(j);
; 3420 :    while (!stbi__EOI(m)) {
; 3421 :       if (stbi__SOS(m)) {
; 3422 :          if (!stbi__process_scan_header(j)) return 0;
; 3423 :          if (!stbi__parse_entropy_coded_data(j)) return 0;
; 3424 :          if (j->marker == STBI__MARKER_none ) {
; 3425 :          j->marker = stbi__skip_jpeg_junk_at_end(j);
; 3426 :             // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
; 3427 :          }
; 3428 :          m = stbi__get_marker(j);
; 3429 :          if (STBI__RESTART(m))
; 3430 :             m = stbi__get_marker(j);
; 3431 :       } else if (stbi__DNL(m)) {
; 3432 :          int Ld = stbi__get16be(j->s);
; 3433 :          stbi__uint32 NL = stbi__get16be(j->s);
; 3434 :          if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
; 3435 :          if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
; 3436 :          m = stbi__get_marker(j);
; 3437 :       } else {
; 3438 :          if (!stbi__process_marker(j, m)) return 1;
; 3439 :          m = stbi__get_marker(j);
; 3440 :       }
; 3441 :    }
; 3442 :    if (j->progressive)
; 3443 :       stbi__jpeg_finish(j);
; 3444 :    return 1;
; 3445 : }
; 3446 : 
; 3447 : // static jfif-centered resampling (across block boundaries)
; 3448 : 
; 3449 : typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
; 3450 :                                     int w, int hs);
; 3451 : 
; 3452 : #define stbi__div4(x) ((stbi_uc) ((x) >> 2))
; 3453 : 
; 3454 : static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3455 : {
; 3456 :    STBI_NOTUSED(out);
; 3457 :    STBI_NOTUSED(in_far);
; 3458 :    STBI_NOTUSED(w);
; 3459 :    STBI_NOTUSED(hs);
; 3460 :    return in_near;
; 3461 : }
; 3462 : 
; 3463 : static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3464 : {
; 3465 :    // need to generate two samples vertically for every one in input
; 3466 :    int i;
; 3467 :    STBI_NOTUSED(hs);
; 3468 :    for (i=0; i < w; ++i)
; 3469 :       out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
; 3470 :    return out;
; 3471 : }
; 3472 : 
; 3473 : static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3474 : {
; 3475 :    // need to generate two samples horizontally for every one in input
; 3476 :    int i;
; 3477 :    stbi_uc *input = in_near;
; 3478 : 
; 3479 :    if (w == 1) {
; 3480 :       // if only one sample, can't do any interpolation
; 3481 :       out[0] = out[1] = input[0];
; 3482 :       return out;
; 3483 :    }
; 3484 : 
; 3485 :    out[0] = input[0];
; 3486 :    out[1] = stbi__div4(input[0]*3 + input[1] + 2);
; 3487 :    for (i=1; i < w-1; ++i) {
; 3488 :       int n = 3*input[i]+2;
; 3489 :       out[i*2+0] = stbi__div4(n+input[i-1]);
; 3490 :       out[i*2+1] = stbi__div4(n+input[i+1]);
; 3491 :    }
; 3492 :    out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
; 3493 :    out[i*2+1] = input[w-1];
; 3494 : 
; 3495 :    STBI_NOTUSED(in_far);
; 3496 :    STBI_NOTUSED(hs);
; 3497 : 
; 3498 :    return out;
; 3499 : }
; 3500 : 
; 3501 : #define stbi__div16(x) ((stbi_uc) ((x) >> 4))
; 3502 : 
; 3503 : static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3504 : {
; 3505 :    // need to generate 2x2 samples for every one in input
; 3506 :    int i,t0,t1;
; 3507 :    if (w == 1) {
; 3508 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
; 3509 :       return out;
; 3510 :    }
; 3511 : 
; 3512 :    t1 = 3*in_near[0] + in_far[0];
; 3513 :    out[0] = stbi__div4(t1+2);
; 3514 :    for (i=1; i < w; ++i) {
; 3515 :       t0 = t1;
; 3516 :       t1 = 3*in_near[i]+in_far[i];
; 3517 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
; 3518 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
; 3519 :    }
; 3520 :    out[w*2-1] = stbi__div4(t1+2);
; 3521 : 
; 3522 :    STBI_NOTUSED(hs);
; 3523 : 
; 3524 :    return out;
; 3525 : }
; 3526 : 
; 3527 : #if defined(STBI_SSE2) || defined(STBI_NEON)
; 3528 : static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3529 : {
; 3530 :    // need to generate 2x2 samples for every one in input
; 3531 :    int i=0,t0,t1;
; 3532 : 
; 3533 :    if (w == 1) {
; 3534 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
; 3535 :       return out;
; 3536 :    }
; 3537 : 
; 3538 :    t1 = 3*in_near[0] + in_far[0];
; 3539 :    // process groups of 8 pixels for as long as we can.
; 3540 :    // note we can't handle the last pixel in a row in this loop
; 3541 :    // because we need to handle the filter boundary conditions.
; 3542 :    for (; i < ((w-1) & ~7); i += 8) {
; 3543 : #if defined(STBI_SSE2)
; 3544 :       // load and perform the vertical filtering pass
; 3545 :       // this uses 3*x + y = 4*x + (y - x)
; 3546 :       __m128i zero  = _mm_setzero_si128();
; 3547 :       __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
; 3548 :       __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
; 3549 :       __m128i farw  = _mm_unpacklo_epi8(farb, zero);
; 3550 :       __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
; 3551 :       __m128i diff  = _mm_sub_epi16(farw, nearw);
; 3552 :       __m128i nears = _mm_slli_epi16(nearw, 2);
; 3553 :       __m128i curr  = _mm_add_epi16(nears, diff); // current row
; 3554 : 
; 3555 :       // horizontal filter works the same based on shifted vers of current
; 3556 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3557 :       // insert the previous pixel value (from t1).
; 3558 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3559 :       // of next block of 8 pixels added in.
; 3560 :       __m128i prv0 = _mm_slli_si128(curr, 2);
; 3561 :       __m128i nxt0 = _mm_srli_si128(curr, 2);
; 3562 :       __m128i prev = _mm_insert_epi16(prv0, t1, 0);
; 3563 :       __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);
; 3564 : 
; 3565 :       // horizontal filter, polyphase implementation since it's convenient:
; 3566 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3567 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3568 :       // note the shared term.
; 3569 :       __m128i bias  = _mm_set1_epi16(8);
; 3570 :       __m128i curs = _mm_slli_epi16(curr, 2);
; 3571 :       __m128i prvd = _mm_sub_epi16(prev, curr);
; 3572 :       __m128i nxtd = _mm_sub_epi16(next, curr);
; 3573 :       __m128i curb = _mm_add_epi16(curs, bias);
; 3574 :       __m128i even = _mm_add_epi16(prvd, curb);
; 3575 :       __m128i odd  = _mm_add_epi16(nxtd, curb);
; 3576 : 
; 3577 :       // interleave even and odd pixels, then undo scaling.
; 3578 :       __m128i int0 = _mm_unpacklo_epi16(even, odd);
; 3579 :       __m128i int1 = _mm_unpackhi_epi16(even, odd);
; 3580 :       __m128i de0  = _mm_srli_epi16(int0, 4);
; 3581 :       __m128i de1  = _mm_srli_epi16(int1, 4);
; 3582 : 
; 3583 :       // pack and write output
; 3584 :       __m128i outv = _mm_packus_epi16(de0, de1);
; 3585 :       _mm_storeu_si128((__m128i *) (out + i*2), outv);
; 3586 : #elif defined(STBI_NEON)
; 3587 :       // load and perform the vertical filtering pass
; 3588 :       // this uses 3*x + y = 4*x + (y - x)
; 3589 :       uint8x8_t farb  = vld1_u8(in_far + i);
; 3590 :       uint8x8_t nearb = vld1_u8(in_near + i);
; 3591 :       int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
; 3592 :       int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
; 3593 :       int16x8_t curr  = vaddq_s16(nears, diff); // current row
; 3594 : 
; 3595 :       // horizontal filter works the same based on shifted vers of current
; 3596 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3597 :       // insert the previous pixel value (from t1).
; 3598 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3599 :       // of next block of 8 pixels added in.
; 3600 :       int16x8_t prv0 = vextq_s16(curr, curr, 7);
; 3601 :       int16x8_t nxt0 = vextq_s16(curr, curr, 1);
; 3602 :       int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
; 3603 :       int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);
; 3604 : 
; 3605 :       // horizontal filter, polyphase implementation since it's convenient:
; 3606 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3607 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3608 :       // note the shared term.
; 3609 :       int16x8_t curs = vshlq_n_s16(curr, 2);
; 3610 :       int16x8_t prvd = vsubq_s16(prev, curr);
; 3611 :       int16x8_t nxtd = vsubq_s16(next, curr);
; 3612 :       int16x8_t even = vaddq_s16(curs, prvd);
; 3613 :       int16x8_t odd  = vaddq_s16(curs, nxtd);
; 3614 : 
; 3615 :       // undo scaling and round, then store with even/odd phases interleaved
; 3616 :       uint8x8x2_t o;
; 3617 :       o.val[0] = vqrshrun_n_s16(even, 4);
; 3618 :       o.val[1] = vqrshrun_n_s16(odd,  4);
; 3619 :       vst2_u8(out + i*2, o);
; 3620 : #endif
; 3621 : 
; 3622 :       // "previous" value for next iter
; 3623 :       t1 = 3*in_near[i+7] + in_far[i+7];
; 3624 :    }
; 3625 : 
; 3626 :    t0 = t1;
; 3627 :    t1 = 3*in_near[i] + in_far[i];
; 3628 :    out[i*2] = stbi__div16(3*t1 + t0 + 8);
; 3629 : 
; 3630 :    for (++i; i < w; ++i) {
; 3631 :       t0 = t1;
; 3632 :       t1 = 3*in_near[i]+in_far[i];
; 3633 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
; 3634 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
; 3635 :    }
; 3636 :    out[w*2-1] = stbi__div4(t1+2);
; 3637 : 
; 3638 :    STBI_NOTUSED(hs);
; 3639 : 
; 3640 :    return out;
; 3641 : }
; 3642 : #endif
; 3643 : 
; 3644 : static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
; 3645 : {
; 3646 :    // resample with nearest-neighbor
; 3647 :    int i,j;
; 3648 :    STBI_NOTUSED(in_far);
; 3649 :    for (i=0; i < w; ++i)
; 3650 :       for (j=0; j < hs; ++j)
; 3651 :          out[i*hs+j] = in_near[i];
; 3652 :    return out;
; 3653 : }
; 3654 : 
; 3655 : // this is a reduced-precision calculation of YCbCr-to-RGB introduced
; 3656 : // to make sure the code produces the same results in both SIMD and scalar
; 3657 : #define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
; 3658 : static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
; 3659 : {
; 3660 :    int i;
; 3661 :    for (i=0; i < count; ++i) {
; 3662 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding
; 3663 :       int r,g,b;
; 3664 :       int cr = pcr[i] - 128;
; 3665 :       int cb = pcb[i] - 128;
; 3666 :       r = y_fixed +  cr* stbi__float2fixed(1.40200f);
; 3667 :       g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
; 3668 :       b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
; 3669 :       r >>= 20;
; 3670 :       g >>= 20;
; 3671 :       b >>= 20;
; 3672 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
; 3673 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
; 3674 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
; 3675 :       out[0] = (stbi_uc)r;
; 3676 :       out[1] = (stbi_uc)g;
; 3677 :       out[2] = (stbi_uc)b;
; 3678 :       out[3] = 255;
; 3679 :       out += step;
; 3680 :    }
; 3681 : }
; 3682 : 
; 3683 : #if defined(STBI_SSE2) || defined(STBI_NEON)
; 3684 : static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
; 3685 : {
; 3686 :    int i = 0;
; 3687 : 
; 3688 : #ifdef STBI_SSE2
; 3689 :    // step == 3 is pretty ugly on the final interleave, and i'm not convinced
; 3690 :    // it's useful in practice (you wouldn't use it for textures, for example).
; 3691 :    // so just accelerate step == 4 case.
; 3692 :    if (step == 4) {
; 3693 :       // this is a fairly straightforward implementation and not super-optimized.
; 3694 :       __m128i signflip  = _mm_set1_epi8(-0x80);
; 3695 :       __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3696 :       __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3697 :       __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3698 :       __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3699 :       __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
; 3700 :       __m128i xw = _mm_set1_epi16(255); // alpha channel
; 3701 : 
; 3702 :       for (; i+7 < count; i += 8) {
; 3703 :          // load
; 3704 :          __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
; 3705 :          __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
; 3706 :          __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
; 3707 :          __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
; 3708 :          __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128
; 3709 : 
; 3710 :          // unpack to short (and left-shift cr, cb by 8)
; 3711 :          __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
; 3712 :          __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
; 3713 :          __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);
; 3714 : 
; 3715 :          // color transform
; 3716 :          __m128i yws = _mm_srli_epi16(yw, 4);
; 3717 :          __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
; 3718 :          __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
; 3719 :          __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
; 3720 :          __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
; 3721 :          __m128i rws = _mm_add_epi16(cr0, yws);
; 3722 :          __m128i gwt = _mm_add_epi16(cb0, yws);
; 3723 :          __m128i bws = _mm_add_epi16(yws, cb1);
; 3724 :          __m128i gws = _mm_add_epi16(gwt, cr1);
; 3725 : 
; 3726 :          // descale
; 3727 :          __m128i rw = _mm_srai_epi16(rws, 4);
; 3728 :          __m128i bw = _mm_srai_epi16(bws, 4);
; 3729 :          __m128i gw = _mm_srai_epi16(gws, 4);
; 3730 : 
; 3731 :          // back to byte, set up for transpose
; 3732 :          __m128i brb = _mm_packus_epi16(rw, bw);
; 3733 :          __m128i gxb = _mm_packus_epi16(gw, xw);
; 3734 : 
; 3735 :          // transpose to interleave channels
; 3736 :          __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
; 3737 :          __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
; 3738 :          __m128i o0 = _mm_unpacklo_epi16(t0, t1);
; 3739 :          __m128i o1 = _mm_unpackhi_epi16(t0, t1);
; 3740 : 
; 3741 :          // store
; 3742 :          _mm_storeu_si128((__m128i *) (out + 0), o0);
; 3743 :          _mm_storeu_si128((__m128i *) (out + 16), o1);
; 3744 :          out += 32;
; 3745 :       }
; 3746 :    }
; 3747 : #endif
; 3748 : 
; 3749 : #ifdef STBI_NEON
; 3750 :    // in this version, step=3 support would be easy to add. but is there demand?
; 3751 :    if (step == 4) {
; 3752 :       // this is a fairly straightforward implementation and not super-optimized.
; 3753 :       uint8x8_t signflip = vdup_n_u8(0x80);
; 3754 :       int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3755 :       int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3756 :       int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3757 :       int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3758 : 
; 3759 :       for (; i+7 < count; i += 8) {
; 3760 :          // load
; 3761 :          uint8x8_t y_bytes  = vld1_u8(y + i);
; 3762 :          uint8x8_t cr_bytes = vld1_u8(pcr + i);
; 3763 :          uint8x8_t cb_bytes = vld1_u8(pcb + i);
; 3764 :          int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
; 3765 :          int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
; 3766 : 
; 3767 :          // expand to s16
; 3768 :          int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
; 3769 :          int16x8_t crw = vshll_n_s8(cr_biased, 7);
; 3770 :          int16x8_t cbw = vshll_n_s8(cb_biased, 7);
; 3771 : 
; 3772 :          // color transform
; 3773 :          int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
; 3774 :          int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
; 3775 :          int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
; 3776 :          int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
; 3777 :          int16x8_t rws = vaddq_s16(yws, cr0);
; 3778 :          int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
; 3779 :          int16x8_t bws = vaddq_s16(yws, cb1);
; 3780 : 
; 3781 :          // undo scaling, round, convert to byte
; 3782 :          uint8x8x4_t o;
; 3783 :          o.val[0] = vqrshrun_n_s16(rws, 4);
; 3784 :          o.val[1] = vqrshrun_n_s16(gws, 4);
; 3785 :          o.val[2] = vqrshrun_n_s16(bws, 4);
; 3786 :          o.val[3] = vdup_n_u8(255);
; 3787 : 
; 3788 :          // store, interleaving r/g/b/a
; 3789 :          vst4_u8(out, o);
; 3790 :          out += 8*4;
; 3791 :       }
; 3792 :    }
; 3793 : #endif
; 3794 : 
; 3795 :    for (; i < count; ++i) {
; 3796 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding
; 3797 :       int r,g,b;
; 3798 :       int cr = pcr[i] - 128;
; 3799 :       int cb = pcb[i] - 128;
; 3800 :       r = y_fixed + cr* stbi__float2fixed(1.40200f);
; 3801 :       g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
; 3802 :       b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
; 3803 :       r >>= 20;
; 3804 :       g >>= 20;
; 3805 :       b >>= 20;
; 3806 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
; 3807 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
; 3808 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
; 3809 :       out[0] = (stbi_uc)r;
; 3810 :       out[1] = (stbi_uc)g;
; 3811 :       out[2] = (stbi_uc)b;
; 3812 :       out[3] = 255;
; 3813 :       out += step;
; 3814 :    }
; 3815 : }
; 3816 : #endif
; 3817 : 
; 3818 : // set up the kernels
; 3819 : static void stbi__setup_jpeg(stbi__jpeg *j)
; 3820 : {
; 3821 :    j->idct_block_kernel = stbi__idct_block;
; 3822 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
; 3823 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;
; 3824 : 
; 3825 : #ifdef STBI_SSE2
; 3826 :    if (stbi__sse2_available()) {
; 3827 :       j->idct_block_kernel = stbi__idct_simd;
; 3828 :       j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3829 :       j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3830 :    }
; 3831 : #endif
; 3832 : 
; 3833 : #ifdef STBI_NEON
; 3834 :    j->idct_block_kernel = stbi__idct_simd;
; 3835 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3836 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3837 : #endif
; 3838 : }
; 3839 : 
; 3840 : // clean up the temporary component buffers
; 3841 : static void stbi__cleanup_jpeg(stbi__jpeg *j)
; 3842 : {
; 3843 :    stbi__free_jpeg_components(j, j->s->img_n, 0);
; 3844 : }
; 3845 : 
; 3846 : typedef struct
; 3847 : {
; 3848 :    resample_row_func resample;
; 3849 :    stbi_uc *line0,*line1;
; 3850 :    int hs,vs;   // expansion factor in each axis
; 3851 :    int w_lores; // horizontal pixels pre-expansion
; 3852 :    int ystep;   // how far through vertical expansion we are
; 3853 :    int ypos;    // which pre-expansion row we're on
; 3854 : } stbi__resample;
; 3855 : 
; 3856 : // fast 0..255 * 0..255 => 0..255 rounded multiplication
; 3857 : static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
; 3858 : {
; 3859 :    unsigned int t = x*y + 128;
; 3860 :    return (stbi_uc) ((t + (t >>8)) >> 8);
; 3861 : }
; 3862 : 
; 3863 : static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
; 3864 : {
; 3865 :    int n, decode_n, is_rgb;
; 3866 :    z->s->img_n = 0; // make stbi__cleanup_jpeg safe
; 3867 : 
; 3868 :    // validate req_comp
; 3869 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
; 3870 : 
; 3871 :    // load a jpeg image from whichever source, but leave in YCbCr format
; 3872 :    if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }
; 3873 : 
; 3874 :    // determine actual number of components to generate
; 3875 :    n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;
; 3876 : 
; 3877 :    is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));
; 3878 : 
; 3879 :    if (z->s->img_n == 3 && n < 3 && !is_rgb)
; 3880 :       decode_n = 1;
; 3881 :    else
; 3882 :       decode_n = z->s->img_n;
; 3883 : 
; 3884 :    // nothing to do if no components requested; check this now to avoid
; 3885 :    // accessing uninitialized coutput[0] later
; 3886 :    if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }
; 3887 : 
; 3888 :    // resample and color-convert
; 3889 :    {
; 3890 :       int k;
; 3891 :       unsigned int i,j;
; 3892 :       stbi_uc *output;
; 3893 :       stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };
; 3894 : 
; 3895 :       stbi__resample res_comp[4];
; 3896 : 
; 3897 :       for (k=0; k < decode_n; ++k) {
; 3898 :          stbi__resample *r = &res_comp[k];
; 3899 : 
; 3900 :          // allocate line buffer big enough for upsampling off the edges
; 3901 :          // with upsample factor of 4
; 3902 :          z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
; 3903 :          if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
; 3904 : 
; 3905 :          r->hs      = z->img_h_max / z->img_comp[k].h;
; 3906 :          r->vs      = z->img_v_max / z->img_comp[k].v;
; 3907 :          r->ystep   = r->vs >> 1;
; 3908 :          r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
; 3909 :          r->ypos    = 0;
; 3910 :          r->line0   = r->line1 = z->img_comp[k].data;
; 3911 : 
; 3912 :          if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
; 3913 :          else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
; 3914 :          else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
; 3915 :          else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
; 3916 :          else                               r->resample = stbi__resample_row_generic;
; 3917 :       }
; 3918 : 
; 3919 :       // can't error after this so, this is safe
; 3920 :       output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
; 3921 :       if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
; 3922 : 
; 3923 :       // now go ahead and resample
; 3924 :       for (j=0; j < z->s->img_y; ++j) {
; 3925 :          stbi_uc *out = output + n * z->s->img_x * j;
; 3926 :          for (k=0; k < decode_n; ++k) {
; 3927 :             stbi__resample *r = &res_comp[k];
; 3928 :             int y_bot = r->ystep >= (r->vs >> 1);
; 3929 :             coutput[k] = r->resample(z->img_comp[k].linebuf,
; 3930 :                                      y_bot ? r->line1 : r->line0,
; 3931 :                                      y_bot ? r->line0 : r->line1,
; 3932 :                                      r->w_lores, r->hs);
; 3933 :             if (++r->ystep >= r->vs) {
; 3934 :                r->ystep = 0;
; 3935 :                r->line0 = r->line1;
; 3936 :                if (++r->ypos < z->img_comp[k].y)
; 3937 :                   r->line1 += z->img_comp[k].w2;
; 3938 :             }
; 3939 :          }
; 3940 :          if (n >= 3) {
; 3941 :             stbi_uc *y = coutput[0];
; 3942 :             if (z->s->img_n == 3) {
; 3943 :                if (is_rgb) {
; 3944 :                   for (i=0; i < z->s->img_x; ++i) {
; 3945 :                      out[0] = y[i];
; 3946 :                      out[1] = coutput[1][i];
; 3947 :                      out[2] = coutput[2][i];
; 3948 :                      out[3] = 255;
; 3949 :                      out += n;
; 3950 :                   }
; 3951 :                } else {
; 3952 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3953 :                }
; 3954 :             } else if (z->s->img_n == 4) {
; 3955 :                if (z->app14_color_transform == 0) { // CMYK
; 3956 :                   for (i=0; i < z->s->img_x; ++i) {
; 3957 :                      stbi_uc m = coutput[3][i];
; 3958 :                      out[0] = stbi__blinn_8x8(coutput[0][i], m);
; 3959 :                      out[1] = stbi__blinn_8x8(coutput[1][i], m);
; 3960 :                      out[2] = stbi__blinn_8x8(coutput[2][i], m);
; 3961 :                      out[3] = 255;
; 3962 :                      out += n;
; 3963 :                   }
; 3964 :                } else if (z->app14_color_transform == 2) { // YCCK
; 3965 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3966 :                   for (i=0; i < z->s->img_x; ++i) {
; 3967 :                      stbi_uc m = coutput[3][i];
; 3968 :                      out[0] = stbi__blinn_8x8(255 - out[0], m);
; 3969 :                      out[1] = stbi__blinn_8x8(255 - out[1], m);
; 3970 :                      out[2] = stbi__blinn_8x8(255 - out[2], m);
; 3971 :                      out += n;
; 3972 :                   }
; 3973 :                } else { // YCbCr + alpha?  Ignore the fourth channel for now
; 3974 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
; 3975 :                }
; 3976 :             } else
; 3977 :                for (i=0; i < z->s->img_x; ++i) {
; 3978 :                   out[0] = out[1] = out[2] = y[i];
; 3979 :                   out[3] = 255; // not used if n==3
; 3980 :                   out += n;
; 3981 :                }
; 3982 :          } else {
; 3983 :             if (is_rgb) {
; 3984 :                if (n == 1)
; 3985 :                   for (i=0; i < z->s->img_x; ++i)
; 3986 :                      *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
; 3987 :                else {
; 3988 :                   for (i=0; i < z->s->img_x; ++i, out += 2) {
; 3989 :                      out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
; 3990 :                      out[1] = 255;
; 3991 :                   }
; 3992 :                }
; 3993 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
; 3994 :                for (i=0; i < z->s->img_x; ++i) {
; 3995 :                   stbi_uc m = coutput[3][i];
; 3996 :                   stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
; 3997 :                   stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
; 3998 :                   stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
; 3999 :                   out[0] = stbi__compute_y(r, g, b);
; 4000 :                   out[1] = 255;
; 4001 :                   out += n;
; 4002 :                }
; 4003 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
; 4004 :                for (i=0; i < z->s->img_x; ++i) {
; 4005 :                   out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
; 4006 :                   out[1] = 255;
; 4007 :                   out += n;
; 4008 :                }
; 4009 :             } else {
; 4010 :                stbi_uc *y = coutput[0];
; 4011 :                if (n == 1)
; 4012 :                   for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
; 4013 :                else
; 4014 :                   for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
; 4015 :             }
; 4016 :          }
; 4017 :       }
; 4018 :       stbi__cleanup_jpeg(z);
; 4019 :       *out_x = z->s->img_x;
; 4020 :       *out_y = z->s->img_y;
; 4021 :       if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
; 4022 :       return output;
; 4023 :    }
; 4024 : }
; 4025 : 
; 4026 : static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 4027 : {
; 4028 :    unsigned char* result;
; 4029 :    stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
; 4030 :    if (!j) return stbi__errpuc("outofmem", "Out of memory");
; 4031 :    memset(j, 0, sizeof(stbi__jpeg));
; 4032 :    STBI_NOTUSED(ri);
; 4033 :    j->s = s;
; 4034 :    stbi__setup_jpeg(j);
; 4035 :    result = load_jpeg_image(j, x,y,comp,req_comp);
; 4036 :    STBI_FREE(j);
; 4037 :    return result;
; 4038 : }
; 4039 : 
; 4040 : static int stbi__jpeg_test(stbi__context *s)
; 4041 : {
; 4042 :    int r;
; 4043 :    stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
; 4044 :    if (!j) return stbi__err("outofmem", "Out of memory");
; 4045 :    memset(j, 0, sizeof(stbi__jpeg));
; 4046 :    j->s = s;
; 4047 :    stbi__setup_jpeg(j);
; 4048 :    r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
; 4049 :    stbi__rewind(s);
; 4050 :    STBI_FREE(j);
; 4051 :    return r;
; 4052 : }
; 4053 : 
; 4054 : static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
; 4055 : {
; 4056 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
; 4057 :       stbi__rewind( j->s );
; 4058 :       return 0;
; 4059 :    }
; 4060 :    if (x) *x = j->s->img_x;
; 4061 :    if (y) *y = j->s->img_y;
; 4062 :    if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
; 4063 :    return 1;
; 4064 : }
; 4065 : 
; 4066 : static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
; 4067 : {
; 4068 :    int result;
; 4069 :    stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
; 4070 :    if (!j) return stbi__err("outofmem", "Out of memory");
; 4071 :    memset(j, 0, sizeof(stbi__jpeg));
; 4072 :    j->s = s;
; 4073 :    result = stbi__jpeg_info_raw(j, x, y, comp);
; 4074 :    STBI_FREE(j);
; 4075 :    return result;
; 4076 : }
; 4077 : #endif
; 4078 : 
; 4079 : // public domain zlib decode    v0.2  Sean Barrett 2006-11-18
; 4080 : //    simple implementation
; 4081 : //      - all input must be provided in an upfront buffer
; 4082 : //      - all output is written to a single output buffer (can malloc/realloc)
; 4083 : //    performance
; 4084 : //      - fast huffman
; 4085 : 
; 4086 : #ifndef STBI_NO_ZLIB
; 4087 : 
; 4088 : // fast-way is faster to check than jpeg huffman, but slow way is slower
; 4089 : #define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
; 4090 : #define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
; 4091 : #define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet
; 4092 : 
; 4093 : // zlib-style huffman encoding
; 4094 : // (jpegs packs from left, zlib from right, so can't share code)
; 4095 : typedef struct
; 4096 : {
; 4097 :    stbi__uint16 fast[1 << STBI__ZFAST_BITS];
; 4098 :    stbi__uint16 firstcode[16];
; 4099 :    int maxcode[17];
; 4100 :    stbi__uint16 firstsymbol[16];
; 4101 :    stbi_uc  size[STBI__ZNSYMS];
; 4102 :    stbi__uint16 value[STBI__ZNSYMS];
; 4103 : } stbi__zhuffman;
; 4104 : 
; 4105 : stbi_inline static int stbi__bitreverse16(int n)
; 4106 : {
; 4107 :   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
; 4108 :   n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
; 4109 :   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
; 4110 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
; 4111 :   return n;
; 4112 : }
; 4113 : 
; 4114 : stbi_inline static int stbi__bit_reverse(int v, int bits)
; 4115 : {
; 4116 :    STBI_ASSERT(bits <= 16);
; 4117 :    // to bit reverse n bits, reverse 16 and shift
; 4118 :    // e.g. 11 bits, bit reverse and shift away 5
; 4119 :    return stbi__bitreverse16(v) >> (16-bits);
; 4120 : }
; 4121 : 
; 4122 : static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
; 4123 : {
; 4124 :    int i,k=0;
; 4125 :    int code, next_code[16], sizes[17];
; 4126 : 
; 4127 :    // DEFLATE spec for generating codes
; 4128 :    memset(sizes, 0, sizeof(sizes));
; 4129 :    memset(z->fast, 0, sizeof(z->fast));
; 4130 :    for (i=0; i < num; ++i)
; 4131 :       ++sizes[sizelist[i]];
; 4132 :    sizes[0] = 0;
; 4133 :    for (i=1; i < 16; ++i)
; 4134 :       if (sizes[i] > (1 << i))
; 4135 :          return stbi__err("bad sizes", "Corrupt PNG");
; 4136 :    code = 0;
; 4137 :    for (i=1; i < 16; ++i) {
; 4138 :       next_code[i] = code;
; 4139 :       z->firstcode[i] = (stbi__uint16) code;
; 4140 :       z->firstsymbol[i] = (stbi__uint16) k;
; 4141 :       code = (code + sizes[i]);
; 4142 :       if (sizes[i])
; 4143 :          if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
; 4144 :       z->maxcode[i] = code << (16-i); // preshift for inner loop
; 4145 :       code <<= 1;
; 4146 :       k += sizes[i];
; 4147 :    }
; 4148 :    z->maxcode[16] = 0x10000; // sentinel
; 4149 :    for (i=0; i < num; ++i) {
; 4150 :       int s = sizelist[i];
; 4151 :       if (s) {
; 4152 :          int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
; 4153 :          stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
; 4154 :          z->size [c] = (stbi_uc     ) s;
; 4155 :          z->value[c] = (stbi__uint16) i;
; 4156 :          if (s <= STBI__ZFAST_BITS) {
; 4157 :             int j = stbi__bit_reverse(next_code[s],s);
; 4158 :             while (j < (1 << STBI__ZFAST_BITS)) {
; 4159 :                z->fast[j] = fastv;
; 4160 :                j += (1 << s);
; 4161 :             }
; 4162 :          }
; 4163 :          ++next_code[s];
; 4164 :       }
; 4165 :    }
; 4166 :    return 1;
; 4167 : }
; 4168 : 
; 4169 : // zlib-from-memory implementation for PNG reading
; 4170 : //    because PNG allows splitting the zlib stream arbitrarily,
; 4171 : //    and it's annoying structurally to have PNG call ZLIB call PNG,
; 4172 : //    we require PNG read all the IDATs and combine them into a single
; 4173 : //    memory buffer
; 4174 : 
; 4175 : typedef struct
; 4176 : {
; 4177 :    stbi_uc *zbuffer, *zbuffer_end;
; 4178 :    int num_bits;
; 4179 :    stbi__uint32 code_buffer;
; 4180 : 
; 4181 :    char *zout;
; 4182 :    char *zout_start;
; 4183 :    char *zout_end;
; 4184 :    int   z_expandable;
; 4185 : 
; 4186 :    stbi__zhuffman z_length, z_distance;
; 4187 : } stbi__zbuf;
; 4188 : 
; 4189 : stbi_inline static int stbi__zeof(stbi__zbuf *z)
; 4190 : {
; 4191 :    return (z->zbuffer >= z->zbuffer_end);
; 4192 : }
; 4193 : 
; 4194 : stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
; 4195 : {
; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;
; 4197 : }
; 4198 : 
; 4199 : static void stbi__fill_bits(stbi__zbuf *z)
; 4200 : {
; 4201 :    do {
; 4202 :       if (z->code_buffer >= (1U << z->num_bits)) {
; 4203 :         z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
; 4204 :         return;
; 4205 :       }
; 4206 :       z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
; 4207 :       z->num_bits += 8;
; 4208 :    } while (z->num_bits <= 24);
; 4209 : }
; 4210 : 
; 4211 : stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
; 4212 : {
; 4213 :    unsigned int k;
; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);
; 4215 :    k = z->code_buffer & ((1 << n) - 1);
; 4216 :    z->code_buffer >>= n;
; 4217 :    z->num_bits -= n;
; 4218 :    return k;
; 4219 : }
; 4220 : 
; 4221 : static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
; 4222 : {
; 4223 :    int b,s,k;
; 4224 :    // not resolved by fast table, so compute it the slow way
; 4225 :    // use jpeg approach, which requires MSbits at top
; 4226 :    k = stbi__bit_reverse(a->code_buffer, 16);
; 4227 :    for (s=STBI__ZFAST_BITS+1; ; ++s)
; 4228 :       if (k < z->maxcode[s])
; 4229 :          break;
; 4230 :    if (s >= 16) return -1; // invalid code!
; 4231 :    // code size is s, so:
; 4232 :    b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
; 4233 :    if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
; 4234 :    if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
; 4235 :    a->code_buffer >>= s;
; 4236 :    a->num_bits -= s;
; 4237 :    return z->value[b];
; 4238 : }
; 4239 : 
; 4240 : stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
; 4241 : {
; 4242 :    int b,s;
; 4243 :    if (a->num_bits < 16) {
; 4244 :       if (stbi__zeof(a)) {
; 4245 :          return -1;   /* report error for unexpected end of data. */
; 4246 :       }
; 4247 :       stbi__fill_bits(a);
; 4248 :    }
; 4249 :    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
; 4250 :    if (b) {
; 4251 :       s = b >> 9;
; 4252 :       a->code_buffer >>= s;
; 4253 :       a->num_bits -= s;
; 4254 :       return b & 511;
; 4255 :    }
; 4256 :    return stbi__zhuffman_decode_slowpath(a, z);
; 4257 : }
; 4258 : 
; 4259 : static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
; 4260 : {
; 4261 :    char *q;
; 4262 :    unsigned int cur, limit, old_limit;
; 4263 :    z->zout = zout;
; 4264 :    if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
; 4265 :    cur   = (unsigned int) (z->zout - z->zout_start);
; 4266 :    limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
; 4267 :    if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");
; 4268 :    while (cur + n > limit) {
; 4269 :       if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");
; 4270 :       limit *= 2;
; 4271 :    }
; 4272 :    q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
; 4273 :    STBI_NOTUSED(old_limit);
; 4274 :    if (q == NULL) return stbi__err("outofmem", "Out of memory");
; 4275 :    z->zout_start = q;
; 4276 :    z->zout       = q + cur;
; 4277 :    z->zout_end   = q + limit;
; 4278 :    return 1;
; 4279 : }
; 4280 : 
; 4281 : static const int stbi__zlength_base[31] = {
; 4282 :    3,4,5,6,7,8,9,10,11,13,
; 4283 :    15,17,19,23,27,31,35,43,51,59,
; 4284 :    67,83,99,115,131,163,195,227,258,0,0 };
; 4285 : 
; 4286 : static const int stbi__zlength_extra[31]=
; 4287 : { 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };
; 4288 : 
; 4289 : static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
; 4290 : 257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};
; 4291 : 
; 4292 : static const int stbi__zdist_extra[32] =
; 4293 : { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
; 4294 : 
; 4295 : static int stbi__parse_huffman_block(stbi__zbuf *a)
; 4296 : {
; 4297 :    char *zout = a->zout;
; 4298 :    for(;;) {
; 4299 :       int z = stbi__zhuffman_decode(a, &a->z_length);
; 4300 :       if (z < 256) {
; 4301 :          if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
; 4302 :          if (zout >= a->zout_end) {
; 4303 :             if (!stbi__zexpand(a, zout, 1)) return 0;
; 4304 :             zout = a->zout;
; 4305 :          }
; 4306 :          *zout++ = (char) z;
; 4307 :       } else {
; 4308 :          stbi_uc *p;
; 4309 :          int len,dist;
; 4310 :          if (z == 256) {
; 4311 :             a->zout = zout;
; 4312 :             return 1;
; 4313 :          }
; 4314 :          if (z >= 286) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, length codes 286 and 287 must not appear in compressed data
; 4315 :          z -= 257;
; 4316 :          len = stbi__zlength_base[z];
; 4317 :          if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
; 4318 :          z = stbi__zhuffman_decode(a, &a->z_distance);
; 4319 :          if (z < 0 || z >= 30) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data
; 4320 :          dist = stbi__zdist_base[z];
; 4321 :          if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
; 4322 :          if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
; 4323 :          if (zout + len > a->zout_end) {
; 4324 :             if (!stbi__zexpand(a, zout, len)) return 0;
; 4325 :             zout = a->zout;
; 4326 :          }
; 4327 :          p = (stbi_uc *) (zout - dist);
; 4328 :          if (dist == 1) { // run of one byte; common in images.
; 4329 :             stbi_uc v = *p;
; 4330 :             if (len) { do *zout++ = v; while (--len); }
; 4331 :          } else {
; 4332 :             if (len) { do *zout++ = *p++; while (--len); }
; 4333 :          }
; 4334 :       }
; 4335 :    }
; 4336 : }
; 4337 : 
; 4338 : static int stbi__compute_huffman_codes(stbi__zbuf *a)
; 4339 : {
; 4340 :    static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
; 4341 :    stbi__zhuffman z_codelength;
; 4342 :    stbi_uc lencodes[286+32+137];//padding for maximum single op
; 4343 :    stbi_uc codelength_sizes[19];
; 4344 :    int i,n;
; 4345 : 
; 4346 :    int hlit  = stbi__zreceive(a,5) + 257;
; 4347 :    int hdist = stbi__zreceive(a,5) + 1;
; 4348 :    int hclen = stbi__zreceive(a,4) + 4;
; 4349 :    int ntot  = hlit + hdist;
; 4350 : 
; 4351 :    memset(codelength_sizes, 0, sizeof(codelength_sizes));
; 4352 :    for (i=0; i < hclen; ++i) {
; 4353 :       int s = stbi__zreceive(a,3);
; 4354 :       codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
; 4355 :    }
; 4356 :    if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;
; 4357 : 
; 4358 :    n = 0;
; 4359 :    while (n < ntot) {
; 4360 :       int c = stbi__zhuffman_decode(a, &z_codelength);
; 4361 :       if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
; 4362 :       if (c < 16)
; 4363 :          lencodes[n++] = (stbi_uc) c;
; 4364 :       else {
; 4365 :          stbi_uc fill = 0;
; 4366 :          if (c == 16) {
; 4367 :             c = stbi__zreceive(a,2)+3;
; 4368 :             if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
; 4369 :             fill = lencodes[n-1];
; 4370 :          } else if (c == 17) {
; 4371 :             c = stbi__zreceive(a,3)+3;
; 4372 :          } else if (c == 18) {
; 4373 :             c = stbi__zreceive(a,7)+11;
; 4374 :          } else {
; 4375 :             return stbi__err("bad codelengths", "Corrupt PNG");
; 4376 :          }
; 4377 :          if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
; 4378 :          memset(lencodes+n, fill, c);
; 4379 :          n += c;
; 4380 :       }
; 4381 :    }
; 4382 :    if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");
; 4383 :    if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
; 4384 :    if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
; 4385 :    return 1;
; 4386 : }
; 4387 : 
; 4388 : static int stbi__parse_uncompressed_block(stbi__zbuf *a)
; 4389 : {
; 4390 :    stbi_uc header[4];
; 4391 :    int len,nlen,k;
; 4392 :    if (a->num_bits & 7)
; 4393 :       stbi__zreceive(a, a->num_bits & 7); // discard
; 4394 :    // drain the bit-packed data into header
; 4395 :    k = 0;
; 4396 :    while (a->num_bits > 0) {
; 4397 :       header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
; 4398 :       a->code_buffer >>= 8;
; 4399 :       a->num_bits -= 8;
; 4400 :    }
; 4401 :    if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");
; 4402 :    // now fill header the normal way
; 4403 :    while (k < 4)
; 4404 :       header[k++] = stbi__zget8(a);
; 4405 :    len  = header[1] * 256 + header[0];
; 4406 :    nlen = header[3] * 256 + header[2];
; 4407 :    if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
; 4408 :    if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
; 4409 :    if (a->zout + len > a->zout_end)
; 4410 :       if (!stbi__zexpand(a, a->zout, len)) return 0;
; 4411 :    memcpy(a->zout, a->zbuffer, len);
; 4412 :    a->zbuffer += len;
; 4413 :    a->zout += len;
; 4414 :    return 1;
; 4415 : }
; 4416 : 
; 4417 : static int stbi__parse_zlib_header(stbi__zbuf *a)
; 4418 : {
; 4419 :    int cmf   = stbi__zget8(a);
; 4420 :    int cm    = cmf & 15;
; 4421 :    /* int cinfo = cmf >> 4; */
; 4422 :    int flg   = stbi__zget8(a);
; 4423 :    if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
; 4424 :    if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
; 4425 :    if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
; 4426 :    if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
; 4427 :    // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
; 4428 :    return 1;
; 4429 : }
; 4430 : 
; 4431 : static const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =
; 4432 : {
; 4433 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4434 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4435 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4436 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
; 4437 :    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4438 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4439 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4440 :    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
; 4441 :    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
; 4442 : };
; 4443 : static const stbi_uc stbi__zdefault_distance[32] =
; 4444 : {
; 4445 :    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
; 4446 : };
; 4447 : /*
; 4448 : Init algorithm:
; 4449 : {
; 4450 :    int i;   // use <= to match clearly with spec
; 4451 :    for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
; 4452 :    for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
; 4453 :    for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
; 4454 :    for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;
; 4455 : 
; 4456 :    for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
; 4457 : }
; 4458 : */
; 4459 : 
; 4460 : static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
; 4461 : {
; 4462 :    int final, type;
; 4463 :    if (parse_header)
; 4464 :       if (!stbi__parse_zlib_header(a)) return 0;
; 4465 :    a->num_bits = 0;
; 4466 :    a->code_buffer = 0;
; 4467 :    do {
; 4468 :       final = stbi__zreceive(a,1);
; 4469 :       type = stbi__zreceive(a,2);
; 4470 :       if (type == 0) {
; 4471 :          if (!stbi__parse_uncompressed_block(a)) return 0;
; 4472 :       } else if (type == 3) {
; 4473 :          return 0;
; 4474 :       } else {
; 4475 :          if (type == 1) {
; 4476 :             // use fixed code lengths
; 4477 :             if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
; 4478 :             if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
; 4479 :          } else {
; 4480 :             if (!stbi__compute_huffman_codes(a)) return 0;
; 4481 :          }
; 4482 :          if (!stbi__parse_huffman_block(a)) return 0;
; 4483 :       }
; 4484 :    } while (!final);
; 4485 :    return 1;
; 4486 : }
; 4487 : 
; 4488 : static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
; 4489 : {
; 4490 :    a->zout_start = obuf;
; 4491 :    a->zout       = obuf;
; 4492 :    a->zout_end   = obuf + olen;
; 4493 :    a->z_expandable = exp;
; 4494 : 
; 4495 :    return stbi__parse_zlib(a, parse_header);
; 4496 : }
; 4497 : 
; 4498 : STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
; 4499 : {
; 4500 :    stbi__zbuf a;
; 4501 :    char *p = (char *) stbi__malloc(initial_size);
; 4502 :    if (p == NULL) return NULL;
; 4503 :    a.zbuffer = (stbi_uc *) buffer;
; 4504 :    a.zbuffer_end = (stbi_uc *) buffer + len;
; 4505 :    if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
; 4506 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4507 :       return a.zout_start;
; 4508 :    } else {
; 4509 :       STBI_FREE(a.zout_start);
; 4510 :       return NULL;
; 4511 :    }
; 4512 : }
; 4513 : 
; 4514 : STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
; 4515 : {
; 4516 :    return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
; 4517 : }
; 4518 : 
; 4519 : STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
; 4520 : {
; 4521 :    stbi__zbuf a;
; 4522 :    char *p = (char *) stbi__malloc(initial_size);
; 4523 :    if (p == NULL) return NULL;
; 4524 :    a.zbuffer = (stbi_uc *) buffer;
; 4525 :    a.zbuffer_end = (stbi_uc *) buffer + len;
; 4526 :    if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
; 4527 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4528 :       return a.zout_start;
; 4529 :    } else {
; 4530 :       STBI_FREE(a.zout_start);
; 4531 :       return NULL;
; 4532 :    }
; 4533 : }
; 4534 : 
; 4535 : STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
; 4536 : {
; 4537 :    stbi__zbuf a;
; 4538 :    a.zbuffer = (stbi_uc *) ibuffer;
; 4539 :    a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
; 4540 :    if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
; 4541 :       return (int) (a.zout - a.zout_start);
; 4542 :    else
; 4543 :       return -1;
; 4544 : }
; 4545 : 
; 4546 : STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
; 4547 : {
; 4548 :    stbi__zbuf a;
; 4549 :    char *p = (char *) stbi__malloc(16384);
; 4550 :    if (p == NULL) return NULL;
; 4551 :    a.zbuffer = (stbi_uc *) buffer;
; 4552 :    a.zbuffer_end = (stbi_uc *) buffer+len;
; 4553 :    if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
; 4554 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);
; 4555 :       return a.zout_start;
; 4556 :    } else {
; 4557 :       STBI_FREE(a.zout_start);
; 4558 :       return NULL;
; 4559 :    }
; 4560 : }
; 4561 : 
; 4562 : STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
; 4563 : {
; 4564 :    stbi__zbuf a;
; 4565 :    a.zbuffer = (stbi_uc *) ibuffer;
; 4566 :    a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
; 4567 :    if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
; 4568 :       return (int) (a.zout - a.zout_start);
; 4569 :    else
; 4570 :       return -1;
; 4571 : }
; 4572 : #endif
; 4573 : 
; 4574 : // public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
; 4575 : //    simple implementation
; 4576 : //      - only 8-bit samples
; 4577 : //      - no CRC checking
; 4578 : //      - allocates lots of intermediate memory
; 4579 : //        - avoids problem of streaming data between subsystems
; 4580 : //        - avoids explicit window management
; 4581 : //    performance
; 4582 : //      - uses stb_zlib, a PD zlib implementation with fast huffman decoding
; 4583 : 
; 4584 : #ifndef STBI_NO_PNG
; 4585 : typedef struct
; 4586 : {
; 4587 :    stbi__uint32 length;
; 4588 :    stbi__uint32 type;
; 4589 : } stbi__pngchunk;
; 4590 : 
; 4591 : static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
; 4592 : {
; 4593 :    stbi__pngchunk c;
; 4594 :    c.length = stbi__get32be(s);
; 4595 :    c.type   = stbi__get32be(s);
; 4596 :    return c;
; 4597 : }
; 4598 : 
; 4599 : static int stbi__check_png_header(stbi__context *s)
; 4600 : {
; 4601 :    static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
; 4602 :    int i;
; 4603 :    for (i=0; i < 8; ++i)
; 4604 :       if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
; 4605 :    return 1;
; 4606 : }
; 4607 : 
; 4608 : typedef struct
; 4609 : {
; 4610 :    stbi__context *s;
; 4611 :    stbi_uc *idata, *expanded, *out;
; 4612 :    int depth;
; 4613 : } stbi__png;
; 4614 : 
; 4615 : 
; 4616 : enum {
; 4617 :    STBI__F_none=0,
; 4618 :    STBI__F_sub=1,
; 4619 :    STBI__F_up=2,
; 4620 :    STBI__F_avg=3,
; 4621 :    STBI__F_paeth=4,
; 4622 :    // synthetic filters used for first scanline to avoid needing a dummy row of 0s
; 4623 :    STBI__F_avg_first,
; 4624 :    STBI__F_paeth_first
; 4625 : };
; 4626 : 
; 4627 : static stbi_uc first_row_filter[5] =
; 4628 : {
; 4629 :    STBI__F_none,
; 4630 :    STBI__F_sub,
; 4631 :    STBI__F_none,
; 4632 :    STBI__F_avg_first,
; 4633 :    STBI__F_paeth_first
; 4634 : };
; 4635 : 
; 4636 : static int stbi__paeth(int a, int b, int c)
; 4637 : {
; 4638 :    int p = a + b - c;
; 4639 :    int pa = abs(p-a);
; 4640 :    int pb = abs(p-b);
; 4641 :    int pc = abs(p-c);
; 4642 :    if (pa <= pb && pa <= pc) return a;
; 4643 :    if (pb <= pc) return b;
; 4644 :    return c;
; 4645 : }
; 4646 : 
; 4647 : static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };
; 4648 : 
; 4649 : // create the png data from post-deflated data
; 4650 : static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
; 4651 : {
; 4652 :    int bytes = (depth == 16? 2 : 1);
; 4653 :    stbi__context *s = a->s;
; 4654 :    stbi__uint32 i,j,stride = x*out_n*bytes;
; 4655 :    stbi__uint32 img_len, img_width_bytes;
; 4656 :    int k;
; 4657 :    int img_n = s->img_n; // copy it into a local for later
; 4658 : 
; 4659 :    int output_bytes = out_n*bytes;
; 4660 :    int filter_bytes = img_n*bytes;
; 4661 :    int width = x;
; 4662 : 
; 4663 :    STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
; 4664 :    a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
; 4665 :    if (!a->out) return stbi__err("outofmem", "Out of memory");
; 4666 : 
; 4667 :    if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
; 4668 :    img_width_bytes = (((img_n * x * depth) + 7) >> 3);
; 4669 :    img_len = (img_width_bytes + 1) * y;
; 4670 : 
; 4671 :    // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
; 4672 :    // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
; 4673 :    // so just check for raw_len < img_len always.
; 4674 :    if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");
; 4675 : 
; 4676 :    for (j=0; j < y; ++j) {
; 4677 :       stbi_uc *cur = a->out + stride*j;
; 4678 :       stbi_uc *prior;
; 4679 :       int filter = *raw++;
; 4680 : 
; 4681 :       if (filter > 4)
; 4682 :          return stbi__err("invalid filter","Corrupt PNG");
; 4683 : 
; 4684 :       if (depth < 8) {
; 4685 :          if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");
; 4686 :          cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
; 4687 :          filter_bytes = 1;
; 4688 :          width = img_width_bytes;
; 4689 :       }
; 4690 :       prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above
; 4691 : 
; 4692 :       // if first row, use special filter that doesn't sample previous row
; 4693 :       if (j == 0) filter = first_row_filter[filter];
; 4694 : 
; 4695 :       // handle first byte explicitly
; 4696 :       for (k=0; k < filter_bytes; ++k) {
; 4697 :          switch (filter) {
; 4698 :             case STBI__F_none       : cur[k] = raw[k]; break;
; 4699 :             case STBI__F_sub        : cur[k] = raw[k]; break;
; 4700 :             case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
; 4701 :             case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;
; 4702 :             case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;
; 4703 :             case STBI__F_avg_first  : cur[k] = raw[k]; break;
; 4704 :             case STBI__F_paeth_first: cur[k] = raw[k]; break;
; 4705 :          }
; 4706 :       }
; 4707 : 
; 4708 :       if (depth == 8) {
; 4709 :          if (img_n != out_n)
; 4710 :             cur[img_n] = 255; // first pixel
; 4711 :          raw += img_n;
; 4712 :          cur += out_n;
; 4713 :          prior += out_n;
; 4714 :       } else if (depth == 16) {
; 4715 :          if (img_n != out_n) {
; 4716 :             cur[filter_bytes]   = 255; // first pixel top byte
; 4717 :             cur[filter_bytes+1] = 255; // first pixel bottom byte
; 4718 :          }
; 4719 :          raw += filter_bytes;
; 4720 :          cur += output_bytes;
; 4721 :          prior += output_bytes;
; 4722 :       } else {
; 4723 :          raw += 1;
; 4724 :          cur += 1;
; 4725 :          prior += 1;
; 4726 :       }
; 4727 : 
; 4728 :       // this is a little gross, so that we don't switch per-pixel or per-component
; 4729 :       if (depth < 8 || img_n == out_n) {
; 4730 :          int nk = (width - 1)*filter_bytes;
; 4731 :          #define STBI__CASE(f) \
; 4732 :              case f:     \
; 4733 :                 for (k=0; k < nk; ++k)
; 4734 :          switch (filter) {
; 4735 :             // "none" filter turns into a memcpy here; make that explicit.
; 4736 :             case STBI__F_none:         memcpy(cur, raw, nk); break;
; 4737 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;
; 4738 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
; 4739 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;
; 4740 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;
; 4741 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;
; 4742 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;
; 4743 :          }
; 4744 :          #undef STBI__CASE
; 4745 :          raw += nk;
; 4746 :       } else {
; 4747 :          STBI_ASSERT(img_n+1 == out_n);
; 4748 :          #define STBI__CASE(f) \
; 4749 :              case f:     \
; 4750 :                 for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
; 4751 :                    for (k=0; k < filter_bytes; ++k)
; 4752 :          switch (filter) {
; 4753 :             STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;
; 4754 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;
; 4755 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
; 4756 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;
; 4757 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;
; 4758 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;
; 4759 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;
; 4760 :          }
; 4761 :          #undef STBI__CASE
; 4762 : 
; 4763 :          // the loop above sets the high byte of the pixels' alpha, but for
; 4764 :          // 16 bit png files we also need the low byte set. we'll do that here.
; 4765 :          if (depth == 16) {
; 4766 :             cur = a->out + stride*j; // start at the beginning of the row again
; 4767 :             for (i=0; i < x; ++i,cur+=output_bytes) {
; 4768 :                cur[filter_bytes+1] = 255;
; 4769 :             }
; 4770 :          }
; 4771 :       }
; 4772 :    }
; 4773 : 
; 4774 :    // we make a separate pass to expand bits to pixels; for performance,
; 4775 :    // this could run two scanlines behind the above code, so it won't
; 4776 :    // intefere with filtering but will still be in the cache.
; 4777 :    if (depth < 8) {
; 4778 :       for (j=0; j < y; ++j) {
; 4779 :          stbi_uc *cur = a->out + stride*j;
; 4780 :          stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
; 4781 :          // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
; 4782 :          // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
; 4783 :          stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range
; 4784 : 
; 4785 :          // note that the final byte might overshoot and write more data than desired.
; 4786 :          // we can allocate enough data that this never writes out of memory, but it
; 4787 :          // could also overwrite the next scanline. can it overwrite non-empty data
; 4788 :          // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
; 4789 :          // so we need to explicitly clamp the final ones
; 4790 : 
; 4791 :          if (depth == 4) {
; 4792 :             for (k=x*img_n; k >= 2; k-=2, ++in) {
; 4793 :                *cur++ = scale * ((*in >> 4)       );
; 4794 :                *cur++ = scale * ((*in     ) & 0x0f);
; 4795 :             }
; 4796 :             if (k > 0) *cur++ = scale * ((*in >> 4)       );
; 4797 :          } else if (depth == 2) {
; 4798 :             for (k=x*img_n; k >= 4; k-=4, ++in) {
; 4799 :                *cur++ = scale * ((*in >> 6)       );
; 4800 :                *cur++ = scale * ((*in >> 4) & 0x03);
; 4801 :                *cur++ = scale * ((*in >> 2) & 0x03);
; 4802 :                *cur++ = scale * ((*in     ) & 0x03);
; 4803 :             }
; 4804 :             if (k > 0) *cur++ = scale * ((*in >> 6)       );
; 4805 :             if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
; 4806 :             if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
; 4807 :          } else if (depth == 1) {
; 4808 :             for (k=x*img_n; k >= 8; k-=8, ++in) {
; 4809 :                *cur++ = scale * ((*in >> 7)       );
; 4810 :                *cur++ = scale * ((*in >> 6) & 0x01);
; 4811 :                *cur++ = scale * ((*in >> 5) & 0x01);
; 4812 :                *cur++ = scale * ((*in >> 4) & 0x01);
; 4813 :                *cur++ = scale * ((*in >> 3) & 0x01);
; 4814 :                *cur++ = scale * ((*in >> 2) & 0x01);
; 4815 :                *cur++ = scale * ((*in >> 1) & 0x01);
; 4816 :                *cur++ = scale * ((*in     ) & 0x01);
; 4817 :             }
; 4818 :             if (k > 0) *cur++ = scale * ((*in >> 7)       );
; 4819 :             if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
; 4820 :             if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
; 4821 :             if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
; 4822 :             if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
; 4823 :             if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
; 4824 :             if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
; 4825 :          }
; 4826 :          if (img_n != out_n) {
; 4827 :             int q;
; 4828 :             // insert alpha = 255
; 4829 :             cur = a->out + stride*j;
; 4830 :             if (img_n == 1) {
; 4831 :                for (q=x-1; q >= 0; --q) {
; 4832 :                   cur[q*2+1] = 255;
; 4833 :                   cur[q*2+0] = cur[q];
; 4834 :                }
; 4835 :             } else {
; 4836 :                STBI_ASSERT(img_n == 3);
; 4837 :                for (q=x-1; q >= 0; --q) {
; 4838 :                   cur[q*4+3] = 255;
; 4839 :                   cur[q*4+2] = cur[q*3+2];
; 4840 :                   cur[q*4+1] = cur[q*3+1];
; 4841 :                   cur[q*4+0] = cur[q*3+0];
; 4842 :                }
; 4843 :             }
; 4844 :          }
; 4845 :       }
; 4846 :    } else if (depth == 16) {
; 4847 :       // force the image data from big-endian to platform-native.
; 4848 :       // this is done in a separate pass due to the decoding relying
; 4849 :       // on the data being untouched, but could probably be done
; 4850 :       // per-line during decode if care is taken.
; 4851 :       stbi_uc *cur = a->out;
; 4852 :       stbi__uint16 *cur16 = (stbi__uint16*)cur;
; 4853 : 
; 4854 :       for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {
; 4855 :          *cur16 = (cur[0] << 8) | cur[1];
; 4856 :       }
; 4857 :    }
; 4858 : 
; 4859 :    return 1;
; 4860 : }
; 4861 : 
; 4862 : static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
; 4863 : {
; 4864 :    int bytes = (depth == 16 ? 2 : 1);
; 4865 :    int out_bytes = out_n * bytes;
; 4866 :    stbi_uc *final;
; 4867 :    int p;
; 4868 :    if (!interlaced)
; 4869 :       return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);
; 4870 : 
; 4871 :    // de-interlacing
; 4872 :    final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
; 4873 :    if (!final) return stbi__err("outofmem", "Out of memory");
; 4874 :    for (p=0; p < 7; ++p) {
; 4875 :       int xorig[] = { 0,4,0,2,0,1,0 };
; 4876 :       int yorig[] = { 0,0,4,0,2,0,1 };
; 4877 :       int xspc[]  = { 8,8,4,4,2,2,1 };
; 4878 :       int yspc[]  = { 8,8,8,4,4,2,2 };
; 4879 :       int i,j,x,y;
; 4880 :       // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
; 4881 :       x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
; 4882 :       y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
; 4883 :       if (x && y) {
; 4884 :          stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
; 4885 :          if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
; 4886 :             STBI_FREE(final);
; 4887 :             return 0;
; 4888 :          }
; 4889 :          for (j=0; j < y; ++j) {
; 4890 :             for (i=0; i < x; ++i) {
; 4891 :                int out_y = j*yspc[p]+yorig[p];
; 4892 :                int out_x = i*xspc[p]+xorig[p];
; 4893 :                memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
; 4894 :                       a->out + (j*x+i)*out_bytes, out_bytes);
; 4895 :             }
; 4896 :          }
; 4897 :          STBI_FREE(a->out);
; 4898 :          image_data += img_len;
; 4899 :          image_data_len -= img_len;
; 4900 :       }
; 4901 :    }
; 4902 :    a->out = final;
; 4903 : 
; 4904 :    return 1;
; 4905 : }
; 4906 : 
; 4907 : static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
; 4908 : {
; 4909 :    stbi__context *s = z->s;
; 4910 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 4911 :    stbi_uc *p = z->out;
; 4912 : 
; 4913 :    // compute color-based transparency, assuming we've
; 4914 :    // already got 255 as the alpha value in the output
; 4915 :    STBI_ASSERT(out_n == 2 || out_n == 4);
; 4916 : 
; 4917 :    if (out_n == 2) {
; 4918 :       for (i=0; i < pixel_count; ++i) {
; 4919 :          p[1] = (p[0] == tc[0] ? 0 : 255);
; 4920 :          p += 2;
; 4921 :       }
; 4922 :    } else {
; 4923 :       for (i=0; i < pixel_count; ++i) {
; 4924 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
; 4925 :             p[3] = 0;
; 4926 :          p += 4;
; 4927 :       }
; 4928 :    }
; 4929 :    return 1;
; 4930 : }
; 4931 : 
; 4932 : static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
; 4933 : {
; 4934 :    stbi__context *s = z->s;
; 4935 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 4936 :    stbi__uint16 *p = (stbi__uint16*) z->out;
; 4937 : 
; 4938 :    // compute color-based transparency, assuming we've
; 4939 :    // already got 65535 as the alpha value in the output
; 4940 :    STBI_ASSERT(out_n == 2 || out_n == 4);
; 4941 : 
; 4942 :    if (out_n == 2) {
; 4943 :       for (i = 0; i < pixel_count; ++i) {
; 4944 :          p[1] = (p[0] == tc[0] ? 0 : 65535);
; 4945 :          p += 2;
; 4946 :       }
; 4947 :    } else {
; 4948 :       for (i = 0; i < pixel_count; ++i) {
; 4949 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
; 4950 :             p[3] = 0;
; 4951 :          p += 4;
; 4952 :       }
; 4953 :    }
; 4954 :    return 1;
; 4955 : }
; 4956 : 
; 4957 : static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
; 4958 : {
; 4959 :    stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
; 4960 :    stbi_uc *p, *temp_out, *orig = a->out;
; 4961 : 
; 4962 :    p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
; 4963 :    if (p == NULL) return stbi__err("outofmem", "Out of memory");
; 4964 : 
; 4965 :    // between here and free(out) below, exitting would leak
; 4966 :    temp_out = p;
; 4967 : 
; 4968 :    if (pal_img_n == 3) {
; 4969 :       for (i=0; i < pixel_count; ++i) {
; 4970 :          int n = orig[i]*4;
; 4971 :          p[0] = palette[n  ];
; 4972 :          p[1] = palette[n+1];
; 4973 :          p[2] = palette[n+2];
; 4974 :          p += 3;
; 4975 :       }
; 4976 :    } else {
; 4977 :       for (i=0; i < pixel_count; ++i) {
; 4978 :          int n = orig[i]*4;
; 4979 :          p[0] = palette[n  ];
; 4980 :          p[1] = palette[n+1];
; 4981 :          p[2] = palette[n+2];
; 4982 :          p[3] = palette[n+3];
; 4983 :          p += 4;
; 4984 :       }
; 4985 :    }
; 4986 :    STBI_FREE(a->out);
; 4987 :    a->out = temp_out;
; 4988 : 
; 4989 :    STBI_NOTUSED(len);
; 4990 : 
; 4991 :    return 1;
; 4992 : }
; 4993 : 
; 4994 : static int stbi__unpremultiply_on_load_global = 0;
; 4995 : static int stbi__de_iphone_flag_global = 0;
; 4996 : 
; 4997 : STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
; 4998 : {
; 4999 :    stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
; 5000 : }
; 5001 : 
; 5002 : STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
; 5003 : {
; 5004 :    stbi__de_iphone_flag_global = flag_true_if_should_convert;
; 5005 : }
; 5006 : 
; 5007 : #ifndef STBI_THREAD_LOCAL
; 5008 : #define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global
; 5009 : #define stbi__de_iphone_flag  stbi__de_iphone_flag_global
; 5010 : #else
; 5011 : static STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;
; 5012 : static STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;
; 5013 : 
; 5014 : STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
; 5015 : {
; 5016 :    stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
; 5017 :    stbi__unpremultiply_on_load_set = 1;
; 5018 : }
; 5019 : 
; 5020 : STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
; 5021 : {
; 5022 :    stbi__de_iphone_flag_local = flag_true_if_should_convert;
; 5023 :    stbi__de_iphone_flag_set = 1;
; 5024 : }
; 5025 : 
; 5026 : #define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \
; 5027 :                                        ? stbi__unpremultiply_on_load_local      \
; 5028 :                                        : stbi__unpremultiply_on_load_global)
; 5029 : #define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \
; 5030 :                                 ? stbi__de_iphone_flag_local                    \
; 5031 :                                 : stbi__de_iphone_flag_global)
; 5032 : #endif // STBI_THREAD_LOCAL
; 5033 : 
; 5034 : static void stbi__de_iphone(stbi__png *z)
; 5035 : {
; 5036 :    stbi__context *s = z->s;
; 5037 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
; 5038 :    stbi_uc *p = z->out;
; 5039 : 
; 5040 :    if (s->img_out_n == 3) {  // convert bgr to rgb
; 5041 :       for (i=0; i < pixel_count; ++i) {
; 5042 :          stbi_uc t = p[0];
; 5043 :          p[0] = p[2];
; 5044 :          p[2] = t;
; 5045 :          p += 3;
; 5046 :       }
; 5047 :    } else {
; 5048 :       STBI_ASSERT(s->img_out_n == 4);
; 5049 :       if (stbi__unpremultiply_on_load) {
; 5050 :          // convert bgr to rgb and unpremultiply
; 5051 :          for (i=0; i < pixel_count; ++i) {
; 5052 :             stbi_uc a = p[3];
; 5053 :             stbi_uc t = p[0];
; 5054 :             if (a) {
; 5055 :                stbi_uc half = a / 2;
; 5056 :                p[0] = (p[2] * 255 + half) / a;
; 5057 :                p[1] = (p[1] * 255 + half) / a;
; 5058 :                p[2] = ( t   * 255 + half) / a;
; 5059 :             } else {
; 5060 :                p[0] = p[2];
; 5061 :                p[2] = t;
; 5062 :             }
; 5063 :             p += 4;
; 5064 :          }
; 5065 :       } else {
; 5066 :          // convert bgr to rgb
; 5067 :          for (i=0; i < pixel_count; ++i) {
; 5068 :             stbi_uc t = p[0];
; 5069 :             p[0] = p[2];
; 5070 :             p[2] = t;
; 5071 :             p += 4;
; 5072 :          }
; 5073 :       }
; 5074 :    }
; 5075 : }
; 5076 : 
; 5077 : #define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))
; 5078 : 
; 5079 : static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
; 5080 : {
; 5081 :    stbi_uc palette[1024], pal_img_n=0;
; 5082 :    stbi_uc has_trans=0, tc[3]={0};
; 5083 :    stbi__uint16 tc16[3];
; 5084 :    stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
; 5085 :    int first=1,k,interlace=0, color=0, is_iphone=0;
; 5086 :    stbi__context *s = z->s;
; 5087 : 
; 5088 :    z->expanded = NULL;
; 5089 :    z->idata = NULL;
; 5090 :    z->out = NULL;
; 5091 : 
; 5092 :    if (!stbi__check_png_header(s)) return 0;
; 5093 : 
; 5094 :    if (scan == STBI__SCAN_type) return 1;
; 5095 : 
; 5096 :    for (;;) {
; 5097 :       stbi__pngchunk c = stbi__get_chunk_header(s);
; 5098 :       switch (c.type) {
; 5099 :          case STBI__PNG_TYPE('C','g','B','I'):
; 5100 :             is_iphone = 1;
; 5101 :             stbi__skip(s, c.length);
; 5102 :             break;
; 5103 :          case STBI__PNG_TYPE('I','H','D','R'): {
; 5104 :             int comp,filter;
; 5105 :             if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
; 5106 :             first = 0;
; 5107 :             if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
; 5108 :             s->img_x = stbi__get32be(s);
; 5109 :             s->img_y = stbi__get32be(s);
; 5110 :             if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 5111 :             if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 5112 :             z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
; 5113 :             color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
; 5114 :             if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
; 5115 :             if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
; 5116 :             comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
; 5117 :             filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
; 5118 :             interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
; 5119 :             if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
; 5120 :             if (!pal_img_n) {
; 5121 :                s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
; 5122 :                if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
; 5123 :             } else {
; 5124 :                // if paletted, then pal_n is our final components, and
; 5125 :                // img_n is # components to decompress/filter.
; 5126 :                s->img_n = 1;
; 5127 :                if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
; 5128 :             }
; 5129 :             // even with SCAN_header, have to scan to see if we have a tRNS
; 5130 :             break;
; 5131 :          }
; 5132 : 
; 5133 :          case STBI__PNG_TYPE('P','L','T','E'):  {
; 5134 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5135 :             if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
; 5136 :             pal_len = c.length / 3;
; 5137 :             if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
; 5138 :             for (i=0; i < pal_len; ++i) {
; 5139 :                palette[i*4+0] = stbi__get8(s);
; 5140 :                palette[i*4+1] = stbi__get8(s);
; 5141 :                palette[i*4+2] = stbi__get8(s);
; 5142 :                palette[i*4+3] = 255;
; 5143 :             }
; 5144 :             break;
; 5145 :          }
; 5146 : 
; 5147 :          case STBI__PNG_TYPE('t','R','N','S'): {
; 5148 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5149 :             if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
; 5150 :             if (pal_img_n) {
; 5151 :                if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
; 5152 :                if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
; 5153 :                if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
; 5154 :                pal_img_n = 4;
; 5155 :                for (i=0; i < c.length; ++i)
; 5156 :                   palette[i*4+3] = stbi__get8(s);
; 5157 :             } else {
; 5158 :                if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
; 5159 :                if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
; 5160 :                has_trans = 1;
; 5161 :                // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.
; 5162 :                if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }
; 5163 :                if (z->depth == 16) {
; 5164 :                   for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
; 5165 :                } else {
; 5166 :                   for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
; 5167 :                }
; 5168 :             }
; 5169 :             break;
; 5170 :          }
; 5171 : 
; 5172 :          case STBI__PNG_TYPE('I','D','A','T'): {
; 5173 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5174 :             if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
; 5175 :             if (scan == STBI__SCAN_header) {
; 5176 :                // header scan definitely stops at first IDAT
; 5177 :                if (pal_img_n)
; 5178 :                   s->img_n = pal_img_n;
; 5179 :                return 1;
; 5180 :             }
; 5181 :             if (c.length > (1u << 30)) return stbi__err("IDAT size limit", "IDAT section larger than 2^30 bytes");
; 5182 :             if ((int)(ioff + c.length) < (int)ioff) return 0;
; 5183 :             if (ioff + c.length > idata_limit) {
; 5184 :                stbi__uint32 idata_limit_old = idata_limit;
; 5185 :                stbi_uc *p;
; 5186 :                if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
; 5187 :                while (ioff + c.length > idata_limit)
; 5188 :                   idata_limit *= 2;
; 5189 :                STBI_NOTUSED(idata_limit_old);
; 5190 :                p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
; 5191 :                z->idata = p;
; 5192 :             }
; 5193 :             if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
; 5194 :             ioff += c.length;
; 5195 :             break;
; 5196 :          }
; 5197 : 
; 5198 :          case STBI__PNG_TYPE('I','E','N','D'): {
; 5199 :             stbi__uint32 raw_len, bpl;
; 5200 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5201 :             if (scan != STBI__SCAN_load) return 1;
; 5202 :             if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
; 5203 :             // initial guess for decoded data size to avoid unnecessary reallocs
; 5204 :             bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
; 5205 :             raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
; 5206 :             z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
; 5207 :             if (z->expanded == NULL) return 0; // zlib should set error
; 5208 :             STBI_FREE(z->idata); z->idata = NULL;
; 5209 :             if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
; 5210 :                s->img_out_n = s->img_n+1;
; 5211 :             else
; 5212 :                s->img_out_n = s->img_n;
; 5213 :             if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
; 5214 :             if (has_trans) {
; 5215 :                if (z->depth == 16) {
; 5216 :                   if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
; 5217 :                } else {
; 5218 :                   if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
; 5219 :                }
; 5220 :             }
; 5221 :             if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
; 5222 :                stbi__de_iphone(z);
; 5223 :             if (pal_img_n) {
; 5224 :                // pal_img_n == 3 or 4
; 5225 :                s->img_n = pal_img_n; // record the actual colors we had
; 5226 :                s->img_out_n = pal_img_n;
; 5227 :                if (req_comp >= 3) s->img_out_n = req_comp;
; 5228 :                if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
; 5229 :                   return 0;
; 5230 :             } else if (has_trans) {
; 5231 :                // non-paletted image with tRNS -> source image has (constant) alpha
; 5232 :                ++s->img_n;
; 5233 :             }
; 5234 :             STBI_FREE(z->expanded); z->expanded = NULL;
; 5235 :             // end of PNG chunk, read and skip CRC
; 5236 :             stbi__get32be(s);
; 5237 :             return 1;
; 5238 :          }
; 5239 : 
; 5240 :          default:
; 5241 :             // if critical, fail
; 5242 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
; 5243 :             if ((c.type & (1 << 29)) == 0) {
; 5244 :                #ifndef STBI_NO_FAILURE_STRINGS
; 5245 :                // not threadsafe
; 5246 :                static char invalid_chunk[] = "XXXX PNG chunk not known";
; 5247 :                invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
; 5248 :                invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
; 5249 :                invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
; 5250 :                invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
; 5251 :                #endif
; 5252 :                return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
; 5253 :             }
; 5254 :             stbi__skip(s, c.length);
; 5255 :             break;
; 5256 :       }
; 5257 :       // end of PNG chunk, read and skip CRC
; 5258 :       stbi__get32be(s);
; 5259 :    }
; 5260 : }
; 5261 : 
; 5262 : static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
; 5263 : {
; 5264 :    void *result=NULL;
; 5265 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
; 5266 :    if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
; 5267 :       if (p->depth <= 8)
; 5268 :          ri->bits_per_channel = 8;
; 5269 :       else if (p->depth == 16)
; 5270 :          ri->bits_per_channel = 16;
; 5271 :       else
; 5272 :          return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
; 5273 :       result = p->out;
; 5274 :       p->out = NULL;
; 5275 :       if (req_comp && req_comp != p->s->img_out_n) {
; 5276 :          if (ri->bits_per_channel == 8)
; 5277 :             result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
; 5278 :          else
; 5279 :             result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
; 5280 :          p->s->img_out_n = req_comp;
; 5281 :          if (result == NULL) return result;
; 5282 :       }
; 5283 :       *x = p->s->img_x;
; 5284 :       *y = p->s->img_y;
; 5285 :       if (n) *n = p->s->img_n;
; 5286 :    }
; 5287 :    STBI_FREE(p->out);      p->out      = NULL;
; 5288 :    STBI_FREE(p->expanded); p->expanded = NULL;
; 5289 :    STBI_FREE(p->idata);    p->idata    = NULL;
; 5290 : 
; 5291 :    return result;
; 5292 : }
; 5293 : 
; 5294 : static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5295 : {
; 5296 :    stbi__png p;
; 5297 :    p.s = s;
; 5298 :    return stbi__do_png(&p, x,y,comp,req_comp, ri);
; 5299 : }
; 5300 : 
; 5301 : static int stbi__png_test(stbi__context *s)
; 5302 : {
; 5303 :    int r;
; 5304 :    r = stbi__check_png_header(s);
; 5305 :    stbi__rewind(s);
; 5306 :    return r;
; 5307 : }
; 5308 : 
; 5309 : static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
; 5310 : {
; 5311 :    if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
; 5312 :       stbi__rewind( p->s );
; 5313 :       return 0;
; 5314 :    }
; 5315 :    if (x) *x = p->s->img_x;
; 5316 :    if (y) *y = p->s->img_y;
; 5317 :    if (comp) *comp = p->s->img_n;
; 5318 :    return 1;
; 5319 : }
; 5320 : 
; 5321 : static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
; 5322 : {
; 5323 :    stbi__png p;
; 5324 :    p.s = s;
; 5325 :    return stbi__png_info_raw(&p, x, y, comp);
; 5326 : }
; 5327 : 
; 5328 : static int stbi__png_is16(stbi__context *s)
; 5329 : {
; 5330 :    stbi__png p;
; 5331 :    p.s = s;
; 5332 :    if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
; 5333 : 	   return 0;
; 5334 :    if (p.depth != 16) {
; 5335 :       stbi__rewind(p.s);
; 5336 :       return 0;
; 5337 :    }
; 5338 :    return 1;
; 5339 : }
; 5340 : #endif
; 5341 : 
; 5342 : // Microsoft/Windows BMP image
; 5343 : 
; 5344 : #ifndef STBI_NO_BMP
; 5345 : static int stbi__bmp_test_raw(stbi__context *s)
; 5346 : {
; 5347 :    int r;
; 5348 :    int sz;
; 5349 :    if (stbi__get8(s) != 'B') return 0;
; 5350 :    if (stbi__get8(s) != 'M') return 0;
; 5351 :    stbi__get32le(s); // discard filesize
; 5352 :    stbi__get16le(s); // discard reserved
; 5353 :    stbi__get16le(s); // discard reserved
; 5354 :    stbi__get32le(s); // discard data offset
; 5355 :    sz = stbi__get32le(s);
; 5356 :    r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
; 5357 :    return r;
; 5358 : }
; 5359 : 
; 5360 : static int stbi__bmp_test(stbi__context *s)
; 5361 : {
; 5362 :    int r = stbi__bmp_test_raw(s);
; 5363 :    stbi__rewind(s);
; 5364 :    return r;
; 5365 : }
; 5366 : 
; 5367 : 
; 5368 : // returns 0..31 for the highest set bit
; 5369 : static int stbi__high_bit(unsigned int z)
; 5370 : {
; 5371 :    int n=0;
; 5372 :    if (z == 0) return -1;
; 5373 :    if (z >= 0x10000) { n += 16; z >>= 16; }
; 5374 :    if (z >= 0x00100) { n +=  8; z >>=  8; }
; 5375 :    if (z >= 0x00010) { n +=  4; z >>=  4; }
; 5376 :    if (z >= 0x00004) { n +=  2; z >>=  2; }
; 5377 :    if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
; 5378 :    return n;
; 5379 : }
; 5380 : 
; 5381 : static int stbi__bitcount(unsigned int a)
; 5382 : {
; 5383 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
; 5384 :    a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
; 5385 :    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
; 5386 :    a = (a + (a >> 8)); // max 16 per 8 bits
; 5387 :    a = (a + (a >> 16)); // max 32 per 8 bits
; 5388 :    return a & 0xff;
; 5389 : }
; 5390 : 
; 5391 : // extract an arbitrarily-aligned N-bit value (N=bits)
; 5392 : // from v, and then make it 8-bits long and fractionally
; 5393 : // extend it to full full range.
; 5394 : static int stbi__shiftsigned(unsigned int v, int shift, int bits)
; 5395 : {
; 5396 :    static unsigned int mul_table[9] = {
; 5397 :       0,
; 5398 :       0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
; 5399 :       0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
; 5400 :    };
; 5401 :    static unsigned int shift_table[9] = {
; 5402 :       0, 0,0,1,0,2,4,6,0,
; 5403 :    };
; 5404 :    if (shift < 0)
; 5405 :       v <<= -shift;
; 5406 :    else
; 5407 :       v >>= shift;
; 5408 :    STBI_ASSERT(v < 256);
; 5409 :    v >>= (8-bits);
; 5410 :    STBI_ASSERT(bits >= 0 && bits <= 8);
; 5411 :    return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
; 5412 : }
; 5413 : 
; 5414 : typedef struct
; 5415 : {
; 5416 :    int bpp, offset, hsz;
; 5417 :    unsigned int mr,mg,mb,ma, all_a;
; 5418 :    int extra_read;
; 5419 : } stbi__bmp_data;
; 5420 : 
; 5421 : static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
; 5422 : {
; 5423 :    // BI_BITFIELDS specifies masks explicitly, don't override
; 5424 :    if (compress == 3)
; 5425 :       return 1;
; 5426 : 
; 5427 :    if (compress == 0) {
; 5428 :       if (info->bpp == 16) {
; 5429 :          info->mr = 31u << 10;
; 5430 :          info->mg = 31u <<  5;
; 5431 :          info->mb = 31u <<  0;
; 5432 :       } else if (info->bpp == 32) {
; 5433 :          info->mr = 0xffu << 16;
; 5434 :          info->mg = 0xffu <<  8;
; 5435 :          info->mb = 0xffu <<  0;
; 5436 :          info->ma = 0xffu << 24;
; 5437 :          info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
; 5438 :       } else {
; 5439 :          // otherwise, use defaults, which is all-0
; 5440 :          info->mr = info->mg = info->mb = info->ma = 0;
; 5441 :       }
; 5442 :       return 1;
; 5443 :    }
; 5444 :    return 0; // error
; 5445 : }
; 5446 : 
; 5447 : static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
; 5448 : {
; 5449 :    int hsz;
; 5450 :    if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
; 5451 :    stbi__get32le(s); // discard filesize
; 5452 :    stbi__get16le(s); // discard reserved
; 5453 :    stbi__get16le(s); // discard reserved
; 5454 :    info->offset = stbi__get32le(s);
; 5455 :    info->hsz = hsz = stbi__get32le(s);
; 5456 :    info->mr = info->mg = info->mb = info->ma = 0;
; 5457 :    info->extra_read = 14;
; 5458 : 
; 5459 :    if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");
; 5460 : 
; 5461 :    if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
; 5462 :    if (hsz == 12) {
; 5463 :       s->img_x = stbi__get16le(s);
; 5464 :       s->img_y = stbi__get16le(s);
; 5465 :    } else {
; 5466 :       s->img_x = stbi__get32le(s);
; 5467 :       s->img_y = stbi__get32le(s);
; 5468 :    }
; 5469 :    if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
; 5470 :    info->bpp = stbi__get16le(s);
; 5471 :    if (hsz != 12) {
; 5472 :       int compress = stbi__get32le(s);
; 5473 :       if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
; 5474 :       if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes
; 5475 :       if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel
; 5476 :       stbi__get32le(s); // discard sizeof
; 5477 :       stbi__get32le(s); // discard hres
; 5478 :       stbi__get32le(s); // discard vres
; 5479 :       stbi__get32le(s); // discard colorsused
; 5480 :       stbi__get32le(s); // discard max important
; 5481 :       if (hsz == 40 || hsz == 56) {
; 5482 :          if (hsz == 56) {
; 5483 :             stbi__get32le(s);
; 5484 :             stbi__get32le(s);
; 5485 :             stbi__get32le(s);
; 5486 :             stbi__get32le(s);
; 5487 :          }
; 5488 :          if (info->bpp == 16 || info->bpp == 32) {
; 5489 :             if (compress == 0) {
; 5490 :                stbi__bmp_set_mask_defaults(info, compress);
; 5491 :             } else if (compress == 3) {
; 5492 :                info->mr = stbi__get32le(s);
; 5493 :                info->mg = stbi__get32le(s);
; 5494 :                info->mb = stbi__get32le(s);
; 5495 :                info->extra_read += 12;
; 5496 :                // not documented, but generated by photoshop and handled by mspaint
; 5497 :                if (info->mr == info->mg && info->mg == info->mb) {
; 5498 :                   // ?!?!?
; 5499 :                   return stbi__errpuc("bad BMP", "bad BMP");
; 5500 :                }
; 5501 :             } else
; 5502 :                return stbi__errpuc("bad BMP", "bad BMP");
; 5503 :          }
; 5504 :       } else {
; 5505 :          // V4/V5 header
; 5506 :          int i;
; 5507 :          if (hsz != 108 && hsz != 124)
; 5508 :             return stbi__errpuc("bad BMP", "bad BMP");
; 5509 :          info->mr = stbi__get32le(s);
; 5510 :          info->mg = stbi__get32le(s);
; 5511 :          info->mb = stbi__get32le(s);
; 5512 :          info->ma = stbi__get32le(s);
; 5513 :          if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
; 5514 :             stbi__bmp_set_mask_defaults(info, compress);
; 5515 :          stbi__get32le(s); // discard color space
; 5516 :          for (i=0; i < 12; ++i)
; 5517 :             stbi__get32le(s); // discard color space parameters
; 5518 :          if (hsz == 124) {
; 5519 :             stbi__get32le(s); // discard rendering intent
; 5520 :             stbi__get32le(s); // discard offset of profile data
; 5521 :             stbi__get32le(s); // discard size of profile data
; 5522 :             stbi__get32le(s); // discard reserved
; 5523 :          }
; 5524 :       }
; 5525 :    }
; 5526 :    return (void *) 1;
; 5527 : }
; 5528 : 
; 5529 : 
; 5530 : static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5531 : {
; 5532 :    stbi_uc *out;
; 5533 :    unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
; 5534 :    stbi_uc pal[256][4];
; 5535 :    int psize=0,i,j,width;
; 5536 :    int flip_vertically, pad, target;
; 5537 :    stbi__bmp_data info;
; 5538 :    STBI_NOTUSED(ri);
; 5539 : 
; 5540 :    info.all_a = 255;
; 5541 :    if (stbi__bmp_parse_header(s, &info) == NULL)
; 5542 :       return NULL; // error code already set
; 5543 : 
; 5544 :    flip_vertically = ((int) s->img_y) > 0;
; 5545 :    s->img_y = abs((int) s->img_y);
; 5546 : 
; 5547 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5548 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5549 : 
; 5550 :    mr = info.mr;
; 5551 :    mg = info.mg;
; 5552 :    mb = info.mb;
; 5553 :    ma = info.ma;
; 5554 :    all_a = info.all_a;
; 5555 : 
; 5556 :    if (info.hsz == 12) {
; 5557 :       if (info.bpp < 24)
; 5558 :          psize = (info.offset - info.extra_read - 24) / 3;
; 5559 :    } else {
; 5560 :       if (info.bpp < 16)
; 5561 :          psize = (info.offset - info.extra_read - info.hsz) >> 2;
; 5562 :    }
; 5563 :    if (psize == 0) {
; 5564 :       // accept some number of extra bytes after the header, but if the offset points either to before
; 5565 :       // the header ends or implies a large amount of extra data, reject the file as malformed
; 5566 :       int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);
; 5567 :       int header_limit = 1024; // max we actually read is below 256 bytes currently.
; 5568 :       int extra_data_limit = 256*4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.
; 5569 :       if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {
; 5570 :          return stbi__errpuc("bad header", "Corrupt BMP");
; 5571 :       }
; 5572 :       // we established that bytes_read_so_far is positive and sensible.
; 5573 :       // the first half of this test rejects offsets that are either too small positives, or
; 5574 :       // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn
; 5575 :       // ensures the number computed in the second half of the test can't overflow.
; 5576 :       if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {
; 5577 :          return stbi__errpuc("bad offset", "Corrupt BMP");
; 5578 :       } else {
; 5579 :          stbi__skip(s, info.offset - bytes_read_so_far);
; 5580 :       }
; 5581 :    }
; 5582 : 
; 5583 :    if (info.bpp == 24 && ma == 0xff000000)
; 5584 :       s->img_n = 3;
; 5585 :    else
; 5586 :       s->img_n = ma ? 4 : 3;
; 5587 :    if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
; 5588 :       target = req_comp;
; 5589 :    else
; 5590 :       target = s->img_n; // if they want monochrome, we'll post-convert
; 5591 : 
; 5592 :    // sanity-check size
; 5593 :    if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
; 5594 :       return stbi__errpuc("too large", "Corrupt BMP");
; 5595 : 
; 5596 :    out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
; 5597 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");
; 5598 :    if (info.bpp < 16) {
; 5599 :       int z=0;
; 5600 :       if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
; 5601 :       for (i=0; i < psize; ++i) {
; 5602 :          pal[i][2] = stbi__get8(s);
; 5603 :          pal[i][1] = stbi__get8(s);
; 5604 :          pal[i][0] = stbi__get8(s);
; 5605 :          if (info.hsz != 12) stbi__get8(s);
; 5606 :          pal[i][3] = 255;
; 5607 :       }
; 5608 :       stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
; 5609 :       if (info.bpp == 1) width = (s->img_x + 7) >> 3;
; 5610 :       else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
; 5611 :       else if (info.bpp == 8) width = s->img_x;
; 5612 :       else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
; 5613 :       pad = (-width)&3;
; 5614 :       if (info.bpp == 1) {
; 5615 :          for (j=0; j < (int) s->img_y; ++j) {
; 5616 :             int bit_offset = 7, v = stbi__get8(s);
; 5617 :             for (i=0; i < (int) s->img_x; ++i) {
; 5618 :                int color = (v>>bit_offset)&0x1;
; 5619 :                out[z++] = pal[color][0];
; 5620 :                out[z++] = pal[color][1];
; 5621 :                out[z++] = pal[color][2];
; 5622 :                if (target == 4) out[z++] = 255;
; 5623 :                if (i+1 == (int) s->img_x) break;
; 5624 :                if((--bit_offset) < 0) {
; 5625 :                   bit_offset = 7;
; 5626 :                   v = stbi__get8(s);
; 5627 :                }
; 5628 :             }
; 5629 :             stbi__skip(s, pad);
; 5630 :          }
; 5631 :       } else {
; 5632 :          for (j=0; j < (int) s->img_y; ++j) {
; 5633 :             for (i=0; i < (int) s->img_x; i += 2) {
; 5634 :                int v=stbi__get8(s),v2=0;
; 5635 :                if (info.bpp == 4) {
; 5636 :                   v2 = v & 15;
; 5637 :                   v >>= 4;
; 5638 :                }
; 5639 :                out[z++] = pal[v][0];
; 5640 :                out[z++] = pal[v][1];
; 5641 :                out[z++] = pal[v][2];
; 5642 :                if (target == 4) out[z++] = 255;
; 5643 :                if (i+1 == (int) s->img_x) break;
; 5644 :                v = (info.bpp == 8) ? stbi__get8(s) : v2;
; 5645 :                out[z++] = pal[v][0];
; 5646 :                out[z++] = pal[v][1];
; 5647 :                out[z++] = pal[v][2];
; 5648 :                if (target == 4) out[z++] = 255;
; 5649 :             }
; 5650 :             stbi__skip(s, pad);
; 5651 :          }
; 5652 :       }
; 5653 :    } else {
; 5654 :       int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
; 5655 :       int z = 0;
; 5656 :       int easy=0;
; 5657 :       stbi__skip(s, info.offset - info.extra_read - info.hsz);
; 5658 :       if (info.bpp == 24) width = 3 * s->img_x;
; 5659 :       else if (info.bpp == 16) width = 2*s->img_x;
; 5660 :       else /* bpp = 32 and pad = 0 */ width=0;
; 5661 :       pad = (-width) & 3;
; 5662 :       if (info.bpp == 24) {
; 5663 :          easy = 1;
; 5664 :       } else if (info.bpp == 32) {
; 5665 :          if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
; 5666 :             easy = 2;
; 5667 :       }
; 5668 :       if (!easy) {
; 5669 :          if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
; 5670 :          // right shift amt to put high bit in position #7
; 5671 :          rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
; 5672 :          gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
; 5673 :          bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
; 5674 :          ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
; 5675 :          if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
; 5676 :       }
; 5677 :       for (j=0; j < (int) s->img_y; ++j) {
; 5678 :          if (easy) {
; 5679 :             for (i=0; i < (int) s->img_x; ++i) {
; 5680 :                unsigned char a;
; 5681 :                out[z+2] = stbi__get8(s);
; 5682 :                out[z+1] = stbi__get8(s);
; 5683 :                out[z+0] = stbi__get8(s);
; 5684 :                z += 3;
; 5685 :                a = (easy == 2 ? stbi__get8(s) : 255);
; 5686 :                all_a |= a;
; 5687 :                if (target == 4) out[z++] = a;
; 5688 :             }
; 5689 :          } else {
; 5690 :             int bpp = info.bpp;
; 5691 :             for (i=0; i < (int) s->img_x; ++i) {
; 5692 :                stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
; 5693 :                unsigned int a;
; 5694 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
; 5695 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
; 5696 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
; 5697 :                a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
; 5698 :                all_a |= a;
; 5699 :                if (target == 4) out[z++] = STBI__BYTECAST(a);
; 5700 :             }
; 5701 :          }
; 5702 :          stbi__skip(s, pad);
; 5703 :       }
; 5704 :    }
; 5705 : 
; 5706 :    // if alpha channel is all 0s, replace with all 255s
; 5707 :    if (target == 4 && all_a == 0)
; 5708 :       for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
; 5709 :          out[i] = 255;
; 5710 : 
; 5711 :    if (flip_vertically) {
; 5712 :       stbi_uc t;
; 5713 :       for (j=0; j < (int) s->img_y>>1; ++j) {
; 5714 :          stbi_uc *p1 = out +      j     *s->img_x*target;
; 5715 :          stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
; 5716 :          for (i=0; i < (int) s->img_x*target; ++i) {
; 5717 :             t = p1[i]; p1[i] = p2[i]; p2[i] = t;
; 5718 :          }
; 5719 :       }
; 5720 :    }
; 5721 : 
; 5722 :    if (req_comp && req_comp != target) {
; 5723 :       out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
; 5724 :       if (out == NULL) return out; // stbi__convert_format frees input on failure
; 5725 :    }
; 5726 : 
; 5727 :    *x = s->img_x;
; 5728 :    *y = s->img_y;
; 5729 :    if (comp) *comp = s->img_n;
; 5730 :    return out;
; 5731 : }
; 5732 : #endif
; 5733 : 
; 5734 : // Targa Truevision - TGA
; 5735 : // by Jonathan Dummer
; 5736 : #ifndef STBI_NO_TGA
; 5737 : // returns STBI_rgb or whatever, 0 on error
; 5738 : static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
; 5739 : {
; 5740 :    // only RGB or RGBA (incl. 16bit) or grey allowed
; 5741 :    if (is_rgb16) *is_rgb16 = 0;
; 5742 :    switch(bits_per_pixel) {
; 5743 :       case 8:  return STBI_grey;
; 5744 :       case 16: if(is_grey) return STBI_grey_alpha;
; 5745 :                // fallthrough
; 5746 :       case 15: if(is_rgb16) *is_rgb16 = 1;
; 5747 :                return STBI_rgb;
; 5748 :       case 24: // fallthrough
; 5749 :       case 32: return bits_per_pixel/8;
; 5750 :       default: return 0;
; 5751 :    }
; 5752 : }
; 5753 : 
; 5754 : static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
; 5755 : {
; 5756 :     int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
; 5757 :     int sz, tga_colormap_type;
; 5758 :     stbi__get8(s);                   // discard Offset
; 5759 :     tga_colormap_type = stbi__get8(s); // colormap type
; 5760 :     if( tga_colormap_type > 1 ) {
; 5761 :         stbi__rewind(s);
; 5762 :         return 0;      // only RGB or indexed allowed
; 5763 :     }
; 5764 :     tga_image_type = stbi__get8(s); // image type
; 5765 :     if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
; 5766 :         if (tga_image_type != 1 && tga_image_type != 9) {
; 5767 :             stbi__rewind(s);
; 5768 :             return 0;
; 5769 :         }
; 5770 :         stbi__skip(s,4);       // skip index of first colormap entry and number of entries
; 5771 :         sz = stbi__get8(s);    //   check bits per palette color entry
; 5772 :         if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
; 5773 :             stbi__rewind(s);
; 5774 :             return 0;
; 5775 :         }
; 5776 :         stbi__skip(s,4);       // skip image x and y origin
; 5777 :         tga_colormap_bpp = sz;
; 5778 :     } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
; 5779 :         if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
; 5780 :             stbi__rewind(s);
; 5781 :             return 0; // only RGB or grey allowed, +/- RLE
; 5782 :         }
; 5783 :         stbi__skip(s,9); // skip colormap specification and image x/y origin
; 5784 :         tga_colormap_bpp = 0;
; 5785 :     }
; 5786 :     tga_w = stbi__get16le(s);
; 5787 :     if( tga_w < 1 ) {
; 5788 :         stbi__rewind(s);
; 5789 :         return 0;   // test width
; 5790 :     }
; 5791 :     tga_h = stbi__get16le(s);
; 5792 :     if( tga_h < 1 ) {
; 5793 :         stbi__rewind(s);
; 5794 :         return 0;   // test height
; 5795 :     }
; 5796 :     tga_bits_per_pixel = stbi__get8(s); // bits per pixel
; 5797 :     stbi__get8(s); // ignore alpha bits
; 5798 :     if (tga_colormap_bpp != 0) {
; 5799 :         if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
; 5800 :             // when using a colormap, tga_bits_per_pixel is the size of the indexes
; 5801 :             // I don't think anything but 8 or 16bit indexes makes sense
; 5802 :             stbi__rewind(s);
; 5803 :             return 0;
; 5804 :         }
; 5805 :         tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
; 5806 :     } else {
; 5807 :         tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
; 5808 :     }
; 5809 :     if(!tga_comp) {
; 5810 :       stbi__rewind(s);
; 5811 :       return 0;
; 5812 :     }
; 5813 :     if (x) *x = tga_w;
; 5814 :     if (y) *y = tga_h;
; 5815 :     if (comp) *comp = tga_comp;
; 5816 :     return 1;                   // seems to have passed everything
; 5817 : }
; 5818 : 
; 5819 : static int stbi__tga_test(stbi__context *s)
; 5820 : {
; 5821 :    int res = 0;
; 5822 :    int sz, tga_color_type;
; 5823 :    stbi__get8(s);      //   discard Offset
; 5824 :    tga_color_type = stbi__get8(s);   //   color type
; 5825 :    if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
; 5826 :    sz = stbi__get8(s);   //   image type
; 5827 :    if ( tga_color_type == 1 ) { // colormapped (paletted) image
; 5828 :       if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
; 5829 :       stbi__skip(s,4);       // skip index of first colormap entry and number of entries
; 5830 :       sz = stbi__get8(s);    //   check bits per palette color entry
; 5831 :       if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
; 5832 :       stbi__skip(s,4);       // skip image x and y origin
; 5833 :    } else { // "normal" image w/o colormap
; 5834 :       if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
; 5835 :       stbi__skip(s,9); // skip colormap specification and image x/y origin
; 5836 :    }
; 5837 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
; 5838 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
; 5839 :    sz = stbi__get8(s);   //   bits per pixel
; 5840 :    if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
; 5841 :    if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
; 5842 : 
; 5843 :    res = 1; // if we got this far, everything's good and we can return 1 instead of 0
; 5844 : 
; 5845 : errorEnd:
; 5846 :    stbi__rewind(s);
; 5847 :    return res;
; 5848 : }
; 5849 : 
; 5850 : // read 16bit value and convert to 24bit RGB
; 5851 : static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
; 5852 : {
; 5853 :    stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
; 5854 :    stbi__uint16 fiveBitMask = 31;
; 5855 :    // we have 3 channels with 5bits each
; 5856 :    int r = (px >> 10) & fiveBitMask;
; 5857 :    int g = (px >> 5) & fiveBitMask;
; 5858 :    int b = px & fiveBitMask;
; 5859 :    // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
; 5860 :    out[0] = (stbi_uc)((r * 255)/31);
; 5861 :    out[1] = (stbi_uc)((g * 255)/31);
; 5862 :    out[2] = (stbi_uc)((b * 255)/31);
; 5863 : 
; 5864 :    // some people claim that the most significant bit might be used for alpha
; 5865 :    // (possibly if an alpha-bit is set in the "image descriptor byte")
; 5866 :    // but that only made 16bit test images completely translucent..
; 5867 :    // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
; 5868 : }
; 5869 : 
; 5870 : static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 5871 : {
; 5872 :    //   read in the TGA header stuff
; 5873 :    int tga_offset = stbi__get8(s);
; 5874 :    int tga_indexed = stbi__get8(s);
; 5875 :    int tga_image_type = stbi__get8(s);
; 5876 :    int tga_is_RLE = 0;
; 5877 :    int tga_palette_start = stbi__get16le(s);
; 5878 :    int tga_palette_len = stbi__get16le(s);
; 5879 :    int tga_palette_bits = stbi__get8(s);
; 5880 :    int tga_x_origin = stbi__get16le(s);
; 5881 :    int tga_y_origin = stbi__get16le(s);
; 5882 :    int tga_width = stbi__get16le(s);
; 5883 :    int tga_height = stbi__get16le(s);
; 5884 :    int tga_bits_per_pixel = stbi__get8(s);
; 5885 :    int tga_comp, tga_rgb16=0;
; 5886 :    int tga_inverted = stbi__get8(s);
; 5887 :    // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
; 5888 :    //   image data
; 5889 :    unsigned char *tga_data;
; 5890 :    unsigned char *tga_palette = NULL;
; 5891 :    int i, j;
; 5892 :    unsigned char raw_data[4] = {0};
; 5893 :    int RLE_count = 0;
; 5894 :    int RLE_repeating = 0;
; 5895 :    int read_next_pixel = 1;
; 5896 :    STBI_NOTUSED(ri);
; 5897 :    STBI_NOTUSED(tga_x_origin); // @TODO
; 5898 :    STBI_NOTUSED(tga_y_origin); // @TODO
; 5899 : 
; 5900 :    if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5901 :    if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 5902 : 
; 5903 :    //   do a tiny bit of precessing
; 5904 :    if ( tga_image_type >= 8 )
; 5905 :    {
; 5906 :       tga_image_type -= 8;
; 5907 :       tga_is_RLE = 1;
; 5908 :    }
; 5909 :    tga_inverted = 1 - ((tga_inverted >> 5) & 1);
; 5910 : 
; 5911 :    //   If I'm paletted, then I'll use the number of bits from the palette
; 5912 :    if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
; 5913 :    else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);
; 5914 : 
; 5915 :    if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
; 5916 :       return stbi__errpuc("bad format", "Can't find out TGA pixelformat");
; 5917 : 
; 5918 :    //   tga info
; 5919 :    *x = tga_width;
; 5920 :    *y = tga_height;
; 5921 :    if (comp) *comp = tga_comp;
; 5922 : 
; 5923 :    if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
; 5924 :       return stbi__errpuc("too large", "Corrupt TGA");
; 5925 : 
; 5926 :    tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
; 5927 :    if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");
; 5928 : 
; 5929 :    // skip to the data's starting position (offset usually = 0)
; 5930 :    stbi__skip(s, tga_offset );
; 5931 : 
; 5932 :    if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
; 5933 :       for (i=0; i < tga_height; ++i) {
; 5934 :          int row = tga_inverted ? tga_height -i - 1 : i;
; 5935 :          stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
; 5936 :          stbi__getn(s, tga_row, tga_width * tga_comp);
; 5937 :       }
; 5938 :    } else  {
; 5939 :       //   do I need to load a palette?
; 5940 :       if ( tga_indexed)
; 5941 :       {
; 5942 :          if (tga_palette_len == 0) {  /* you have to have at least one entry! */
; 5943 :             STBI_FREE(tga_data);
; 5944 :             return stbi__errpuc("bad palette", "Corrupt TGA");
; 5945 :          }
; 5946 : 
; 5947 :          //   any data to skip? (offset usually = 0)
; 5948 :          stbi__skip(s, tga_palette_start );
; 5949 :          //   load the palette
; 5950 :          tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
; 5951 :          if (!tga_palette) {
; 5952 :             STBI_FREE(tga_data);
; 5953 :             return stbi__errpuc("outofmem", "Out of memory");
; 5954 :          }
; 5955 :          if (tga_rgb16) {
; 5956 :             stbi_uc *pal_entry = tga_palette;
; 5957 :             STBI_ASSERT(tga_comp == STBI_rgb);
; 5958 :             for (i=0; i < tga_palette_len; ++i) {
; 5959 :                stbi__tga_read_rgb16(s, pal_entry);
; 5960 :                pal_entry += tga_comp;
; 5961 :             }
; 5962 :          } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
; 5963 :                STBI_FREE(tga_data);
; 5964 :                STBI_FREE(tga_palette);
; 5965 :                return stbi__errpuc("bad palette", "Corrupt TGA");
; 5966 :          }
; 5967 :       }
; 5968 :       //   load the data
; 5969 :       for (i=0; i < tga_width * tga_height; ++i)
; 5970 :       {
; 5971 :          //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
; 5972 :          if ( tga_is_RLE )
; 5973 :          {
; 5974 :             if ( RLE_count == 0 )
; 5975 :             {
; 5976 :                //   yep, get the next byte as a RLE command
; 5977 :                int RLE_cmd = stbi__get8(s);
; 5978 :                RLE_count = 1 + (RLE_cmd & 127);
; 5979 :                RLE_repeating = RLE_cmd >> 7;
; 5980 :                read_next_pixel = 1;
; 5981 :             } else if ( !RLE_repeating )
; 5982 :             {
; 5983 :                read_next_pixel = 1;
; 5984 :             }
; 5985 :          } else
; 5986 :          {
; 5987 :             read_next_pixel = 1;
; 5988 :          }
; 5989 :          //   OK, if I need to read a pixel, do it now
; 5990 :          if ( read_next_pixel )
; 5991 :          {
; 5992 :             //   load however much data we did have
; 5993 :             if ( tga_indexed )
; 5994 :             {
; 5995 :                // read in index, then perform the lookup
; 5996 :                int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
; 5997 :                if ( pal_idx >= tga_palette_len ) {
; 5998 :                   // invalid index
; 5999 :                   pal_idx = 0;
; 6000 :                }
; 6001 :                pal_idx *= tga_comp;
; 6002 :                for (j = 0; j < tga_comp; ++j) {
; 6003 :                   raw_data[j] = tga_palette[pal_idx+j];
; 6004 :                }
; 6005 :             } else if(tga_rgb16) {
; 6006 :                STBI_ASSERT(tga_comp == STBI_rgb);
; 6007 :                stbi__tga_read_rgb16(s, raw_data);
; 6008 :             } else {
; 6009 :                //   read in the data raw
; 6010 :                for (j = 0; j < tga_comp; ++j) {
; 6011 :                   raw_data[j] = stbi__get8(s);
; 6012 :                }
; 6013 :             }
; 6014 :             //   clear the reading flag for the next pixel
; 6015 :             read_next_pixel = 0;
; 6016 :          } // end of reading a pixel
; 6017 : 
; 6018 :          // copy data
; 6019 :          for (j = 0; j < tga_comp; ++j)
; 6020 :            tga_data[i*tga_comp+j] = raw_data[j];
; 6021 : 
; 6022 :          //   in case we're in RLE mode, keep counting down
; 6023 :          --RLE_count;
; 6024 :       }
; 6025 :       //   do I need to invert the image?
; 6026 :       if ( tga_inverted )
; 6027 :       {
; 6028 :          for (j = 0; j*2 < tga_height; ++j)
; 6029 :          {
; 6030 :             int index1 = j * tga_width * tga_comp;
; 6031 :             int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
; 6032 :             for (i = tga_width * tga_comp; i > 0; --i)
; 6033 :             {
; 6034 :                unsigned char temp = tga_data[index1];
; 6035 :                tga_data[index1] = tga_data[index2];
; 6036 :                tga_data[index2] = temp;
; 6037 :                ++index1;
; 6038 :                ++index2;
; 6039 :             }
; 6040 :          }
; 6041 :       }
; 6042 :       //   clear my palette, if I had one
; 6043 :       if ( tga_palette != NULL )
; 6044 :       {
; 6045 :          STBI_FREE( tga_palette );
; 6046 :       }
; 6047 :    }
; 6048 : 
; 6049 :    // swap RGB - if the source data was RGB16, it already is in the right order
; 6050 :    if (tga_comp >= 3 && !tga_rgb16)
; 6051 :    {
; 6052 :       unsigned char* tga_pixel = tga_data;
; 6053 :       for (i=0; i < tga_width * tga_height; ++i)
; 6054 :       {
; 6055 :          unsigned char temp = tga_pixel[0];
; 6056 :          tga_pixel[0] = tga_pixel[2];
; 6057 :          tga_pixel[2] = temp;
; 6058 :          tga_pixel += tga_comp;
; 6059 :       }
; 6060 :    }
; 6061 : 
; 6062 :    // convert to target component count
; 6063 :    if (req_comp && req_comp != tga_comp)
; 6064 :       tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);
; 6065 : 
; 6066 :    //   the things I do to get rid of an error message, and yet keep
; 6067 :    //   Microsoft's C compilers happy... [8^(
; 6068 :    tga_palette_start = tga_palette_len = tga_palette_bits =
; 6069 :          tga_x_origin = tga_y_origin = 0;
; 6070 :    STBI_NOTUSED(tga_palette_start);
; 6071 :    //   OK, done
; 6072 :    return tga_data;
; 6073 : }
; 6074 : #endif
; 6075 : 
; 6076 : // *************************************************************************************************
; 6077 : // Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB
; 6078 : 
; 6079 : #ifndef STBI_NO_PSD
; 6080 : static int stbi__psd_test(stbi__context *s)
; 6081 : {
; 6082 :    int r = (stbi__get32be(s) == 0x38425053);
; 6083 :    stbi__rewind(s);
; 6084 :    return r;
; 6085 : }
; 6086 : 
; 6087 : static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
; 6088 : {
; 6089 :    int count, nleft, len;
; 6090 : 
; 6091 :    count = 0;
; 6092 :    while ((nleft = pixelCount - count) > 0) {
; 6093 :       len = stbi__get8(s);
; 6094 :       if (len == 128) {
; 6095 :          // No-op.
; 6096 :       } else if (len < 128) {
; 6097 :          // Copy next len+1 bytes literally.
; 6098 :          len++;
; 6099 :          if (len > nleft) return 0; // corrupt data
; 6100 :          count += len;
; 6101 :          while (len) {
; 6102 :             *p = stbi__get8(s);
; 6103 :             p += 4;
; 6104 :             len--;
; 6105 :          }
; 6106 :       } else if (len > 128) {
; 6107 :          stbi_uc   val;
; 6108 :          // Next -len+1 bytes in the dest are replicated from next source byte.
; 6109 :          // (Interpret len as a negative 8-bit int.)
; 6110 :          len = 257 - len;
; 6111 :          if (len > nleft) return 0; // corrupt data
; 6112 :          val = stbi__get8(s);
; 6113 :          count += len;
; 6114 :          while (len) {
; 6115 :             *p = val;
; 6116 :             p += 4;
; 6117 :             len--;
; 6118 :          }
; 6119 :       }
; 6120 :    }
; 6121 : 
; 6122 :    return 1;
; 6123 : }
; 6124 : 
; 6125 : static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
; 6126 : {
; 6127 :    int pixelCount;
; 6128 :    int channelCount, compression;
; 6129 :    int channel, i;
; 6130 :    int bitdepth;
; 6131 :    int w,h;
; 6132 :    stbi_uc *out;
; 6133 :    STBI_NOTUSED(ri);
; 6134 : 
; 6135 :    // Check identifier
; 6136 :    if (stbi__get32be(s) != 0x38425053)   // "8BPS"
; 6137 :       return stbi__errpuc("not PSD", "Corrupt PSD image");
; 6138 : 
; 6139 :    // Check file type version.
; 6140 :    if (stbi__get16be(s) != 1)
; 6141 :       return stbi__errpuc("wrong version", "Unsupported version of PSD image");
; 6142 : 
; 6143 :    // Skip 6 reserved bytes.
; 6144 :    stbi__skip(s, 6 );
; 6145 : 
; 6146 :    // Read the number of channels (R, G, B, A, etc).
; 6147 :    channelCount = stbi__get16be(s);
; 6148 :    if (channelCount < 0 || channelCount > 16)
; 6149 :       return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");
; 6150 : 
; 6151 :    // Read the rows and columns of the image.
; 6152 :    h = stbi__get32be(s);
; 6153 :    w = stbi__get32be(s);
; 6154 : 
; 6155 :    if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 6156 :    if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 6157 : 
; 6158 :    // Make sure the depth is 8 bits.
; 6159 :    bitdepth = stbi__get16be(s);
; 6160 :    if (bitdepth != 8 && bitdepth != 16)
; 6161 :       return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");
; 6162 : 
; 6163 :    // Make sure the color mode is RGB.
; 6164 :    // Valid options are:
; 6165 :    //   0: Bitmap
; 6166 :    //   1: Grayscale
; 6167 :    //   2: Indexed color
; 6168 :    //   3: RGB color
; 6169 :    //   4: CMYK color
; 6170 :    //   7: Multichannel
; 6171 :    //   8: Duotone
; 6172 :    //   9: Lab color
; 6173 :    if (stbi__get16be(s) != 3)
; 6174 :       return stbi__errpuc("wrong color format", "PSD is not in RGB color format");
; 6175 : 
; 6176 :    // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
; 6177 :    stbi__skip(s,stbi__get32be(s) );
; 6178 : 
; 6179 :    // Skip the image resources.  (resolution, pen tool paths, etc)
; 6180 :    stbi__skip(s, stbi__get32be(s) );
; 6181 : 
; 6182 :    // Skip the reserved data.
; 6183 :    stbi__skip(s, stbi__get32be(s) );
; 6184 : 
; 6185 :    // Find out if the data is compressed.
; 6186 :    // Known values:
; 6187 :    //   0: no compression
; 6188 :    //   1: RLE compressed
; 6189 :    compression = stbi__get16be(s);
; 6190 :    if (compression > 1)
; 6191 :       return stbi__errpuc("bad compression", "PSD has an unknown compression format");
; 6192 : 
; 6193 :    // Check size
; 6194 :    if (!stbi__mad3sizes_valid(4, w, h, 0))
; 6195 :       return stbi__errpuc("too large", "Corrupt PSD");
; 6196 : 
; 6197 :    // Create the destination image.
; 6198 : 
; 6199 :    if (!compression && bitdepth == 16 && bpc == 16) {
; 6200 :       out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
; 6201 :       ri->bits_per_channel = 16;
; 6202 :    } else
; 6203 :       out = (stbi_uc *) stbi__malloc(4 * w*h);
; 6204 : 
; 6205 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");
; 6206 :    pixelCount = w*h;
; 6207 : 
; 6208 :    // Initialize the data to zero.
; 6209 :    //memset( out, 0, pixelCount * 4 );
; 6210 : 
; 6211 :    // Finally, the image data.
; 6212 :    if (compression) {
; 6213 :       // RLE as used by .PSD and .TIFF
; 6214 :       // Loop until you get the number of unpacked bytes you are expecting:
; 6215 :       //     Read the next source byte into n.
; 6216 :       //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
; 6217 :       //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
; 6218 :       //     Else if n is 128, noop.
; 6219 :       // Endloop
; 6220 : 
; 6221 :       // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
; 6222 :       // which we're going to just skip.
; 6223 :       stbi__skip(s, h * channelCount * 2 );
; 6224 : 
; 6225 :       // Read the RLE data by channel.
; 6226 :       for (channel = 0; channel < 4; channel++) {
; 6227 :          stbi_uc *p;
; 6228 : 
; 6229 :          p = out+channel;
; 6230 :          if (channel >= channelCount) {
; 6231 :             // Fill this channel with default data.
; 6232 :             for (i = 0; i < pixelCount; i++, p += 4)
; 6233 :                *p = (channel == 3 ? 255 : 0);
; 6234 :          } else {
; 6235 :             // Read the RLE data.
; 6236 :             if (!stbi__psd_decode_rle(s, p, pixelCount)) {
; 6237 :                STBI_FREE(out);
; 6238 :                return stbi__errpuc("corrupt", "bad RLE data");
; 6239 :             }
; 6240 :          }
; 6241 :       }
; 6242 : 
; 6243 :    } else {
; 6244 :       // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
; 6245 :       // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.
; 6246 : 
; 6247 :       // Read the data by channel.
; 6248 :       for (channel = 0; channel < 4; channel++) {
; 6249 :          if (channel >= channelCount) {
; 6250 :             // Fill this channel with default data.
; 6251 :             if (bitdepth == 16 && bpc == 16) {
; 6252 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
; 6253 :                stbi__uint16 val = channel == 3 ? 65535 : 0;
; 6254 :                for (i = 0; i < pixelCount; i++, q += 4)
; 6255 :                   *q = val;
; 6256 :             } else {
; 6257 :                stbi_uc *p = out+channel;
; 6258 :                stbi_uc val = channel == 3 ? 255 : 0;
; 6259 :                for (i = 0; i < pixelCount; i++, p += 4)
; 6260 :                   *p = val;
; 6261 :             }
; 6262 :          } else {
; 6263 :             if (ri->bits_per_channel == 16) {    // output bpc
; 6264 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
; 6265 :                for (i = 0; i < pixelCount; i++, q += 4)
; 6266 :                   *q = (stbi__uint16) stbi__get16be(s);
; 6267 :             } else {
; 6268 :                stbi_uc *p = out+channel;
; 6269 :                if (bitdepth == 16) {  // input bpc
; 6270 :                   for (i = 0; i < pixelCount; i++, p += 4)
; 6271 :                      *p = (stbi_uc) (stbi__get16be(s) >> 8);
; 6272 :                } else {
; 6273 :                   for (i = 0; i < pixelCount; i++, p += 4)
; 6274 :                      *p = stbi__get8(s);
; 6275 :                }
; 6276 :             }
; 6277 :          }
; 6278 :       }
; 6279 :    }
; 6280 : 
; 6281 :    // remove weird white matte from PSD
; 6282 :    if (channelCount >= 4) {
; 6283 :       if (ri->bits_per_channel == 16) {
; 6284 :          for (i=0; i < w*h; ++i) {
; 6285 :             stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
; 6286 :             if (pixel[3] != 0 && pixel[3] != 65535) {
; 6287 :                float a = pixel[3] / 65535.0f;
; 6288 :                float ra = 1.0f / a;
; 6289 :                float inv_a = 65535.0f * (1 - ra);
; 6290 :                pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
; 6291 :                pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
; 6292 :                pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
; 6293 :             }
; 6294 :          }
; 6295 :       } else {
; 6296 :          for (i=0; i < w*h; ++i) {
; 6297 :             unsigned char *pixel = out + 4*i;
; 6298 :             if (pixel[3] != 0 && pixel[3] != 255) {
; 6299 :                float a = pixel[3] / 255.0f;
; 6300 :                float ra = 1.0f / a;
; 6301 :                float inv_a = 255.0f * (1 - ra);
; 6302 :                pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
; 6303 :                pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
; 6304 :                pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
; 6305 :             }
; 6306 :          }
; 6307 :       }
; 6308 :    }
; 6309 : 
; 6310 :    // convert to desired output format
; 6311 :    if (req_comp && req_comp != 4) {
; 6312 :       if (ri->bits_per_channel == 16)
; 6313 :          out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
; 6314 :       else
; 6315 :          out = stbi__convert_format(out, 4, req_comp, w, h);
; 6316 :       if (out == NULL) return out; // stbi__convert_format frees input on failure
; 6317 :    }
; 6318 : 
; 6319 :    if (comp) *comp = 4;
; 6320 :    *y = h;
; 6321 :    *x = w;
; 6322 : 
; 6323 :    return out;
; 6324 : }
; 6325 : #endif
; 6326 : 
; 6327 : // *************************************************************************************************
; 6328 : // Softimage PIC loader
; 6329 : // by Tom Seddon
; 6330 : //
; 6331 : // See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
; 6332 : // See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/
; 6333 : 
; 6334 : #ifndef STBI_NO_PIC
; 6335 : static int stbi__pic_is4(stbi__context *s,const char *str)
; 6336 : {
; 6337 :    int i;
; 6338 :    for (i=0; i<4; ++i)
; 6339 :       if (stbi__get8(s) != (stbi_uc)str[i])
; 6340 :          return 0;
; 6341 : 
; 6342 :    return 1;
; 6343 : }
; 6344 : 
; 6345 : static int stbi__pic_test_core(stbi__context *s)
; 6346 : {
; 6347 :    int i;
; 6348 : 
; 6349 :    if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
; 6350 :       return 0;
; 6351 : 
; 6352 :    for(i=0;i<84;++i)
; 6353 :       stbi__get8(s);
; 6354 : 
; 6355 :    if (!stbi__pic_is4(s,"PICT"))
; 6356 :       return 0;
; 6357 : 
; 6358 :    return 1;
; 6359 : }
; 6360 : 
; 6361 : typedef struct
; 6362 : {
; 6363 :    stbi_uc size,type,channel;
; 6364 : } stbi__pic_packet;
; 6365 : 
; 6366 : static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
; 6367 : {
; 6368 :    int mask=0x80, i;
; 6369 : 
; 6370 :    for (i=0; i<4; ++i, mask>>=1) {
; 6371 :       if (channel & mask) {
; 6372 :          if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
; 6373 :          dest[i]=stbi__get8(s);
; 6374 :       }
; 6375 :    }
; 6376 : 
; 6377 :    return dest;
; 6378 : }
; 6379 : 
; 6380 : static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
; 6381 : {
; 6382 :    int mask=0x80,i;
; 6383 : 
; 6384 :    for (i=0;i<4; ++i, mask>>=1)
; 6385 :       if (channel&mask)
; 6386 :          dest[i]=src[i];
; 6387 : }
; 6388 : 
; 6389 : static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
; 6390 : {
; 6391 :    int act_comp=0,num_packets=0,y,chained;
; 6392 :    stbi__pic_packet packets[10];
; 6393 : 
; 6394 :    // this will (should...) cater for even some bizarre stuff like having data
; 6395 :     // for the same channel in multiple packets.
; 6396 :    do {
; 6397 :       stbi__pic_packet *packet;
; 6398 : 
; 6399 :       if (num_packets==sizeof(packets)/sizeof(packets[0]))
; 6400 :          return stbi__errpuc("bad format","too many packets");
; 6401 : 
; 6402 :       packet = &packets[num_packets++];
; 6403 : 
; 6404 :       chained = stbi__get8(s);
; 6405 :       packet->size    = stbi__get8(s);
; 6406 :       packet->type    = stbi__get8(s);
; 6407 :       packet->channel = stbi__get8(s);
; 6408 : 
; 6409 :       act_comp |= packet->channel;
; 6410 : 
; 6411 :       if (stbi__at_eof(s))          return stbi__errpuc("bad file","file too short (reading packets)");
; 6412 :       if (packet->size != 8)  return stbi__errpuc("bad format","packet isn't 8bpp");
; 6413 :    } while (chained);
; 6414 : 
; 6415 :    *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?
; 6416 : 
; 6417 :    for(y=0; y<height; ++y) {
; 6418 :       int packet_idx;
; 6419 : 
; 6420 :       for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
; 6421 :          stbi__pic_packet *packet = &packets[packet_idx];
; 6422 :          stbi_uc *dest = result+y*width*4;
; 6423 : 
; 6424 :          switch (packet->type) {
; 6425 :             default:
; 6426 :                return stbi__errpuc("bad format","packet has bad compression type");
; 6427 : 
; 6428 :             case 0: {//uncompressed
; 6429 :                int x;
; 6430 : 
; 6431 :                for(x=0;x<width;++x, dest+=4)
; 6432 :                   if (!stbi__readval(s,packet->channel,dest))
; 6433 :                      return 0;
; 6434 :                break;
; 6435 :             }
; 6436 : 
; 6437 :             case 1://Pure RLE
; 6438 :                {
; 6439 :                   int left=width, i;
; 6440 : 
; 6441 :                   while (left>0) {
; 6442 :                      stbi_uc count,value[4];
; 6443 : 
; 6444 :                      count=stbi__get8(s);
; 6445 :                      if (stbi__at_eof(s))   return stbi__errpuc("bad file","file too short (pure read count)");
; 6446 : 
; 6447 :                      if (count > left)
; 6448 :                         count = (stbi_uc) left;
; 6449 : 
; 6450 :                      if (!stbi__readval(s,packet->channel,value))  return 0;
; 6451 : 
; 6452 :                      for(i=0; i<count; ++i,dest+=4)
; 6453 :                         stbi__copyval(packet->channel,dest,value);
; 6454 :                      left -= count;
; 6455 :                   }
; 6456 :                }
; 6457 :                break;
; 6458 : 
; 6459 :             case 2: {//Mixed RLE
; 6460 :                int left=width;
; 6461 :                while (left>0) {
; 6462 :                   int count = stbi__get8(s), i;
; 6463 :                   if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");
; 6464 : 
; 6465 :                   if (count >= 128) { // Repeated
; 6466 :                      stbi_uc value[4];
; 6467 : 
; 6468 :                      if (count==128)
; 6469 :                         count = stbi__get16be(s);
; 6470 :                      else
; 6471 :                         count -= 127;
; 6472 :                      if (count > left)
; 6473 :                         return stbi__errpuc("bad file","scanline overrun");
; 6474 : 
; 6475 :                      if (!stbi__readval(s,packet->channel,value))
; 6476 :                         return 0;
; 6477 : 
; 6478 :                      for(i=0;i<count;++i, dest += 4)
; 6479 :                         stbi__copyval(packet->channel,dest,value);
; 6480 :                   } else { // Raw
; 6481 :                      ++count;
; 6482 :                      if (count>left) return stbi__errpuc("bad file","scanline overrun");
; 6483 : 
; 6484 :                      for(i=0;i<count;++i, dest+=4)
; 6485 :                         if (!stbi__readval(s,packet->channel,dest))
; 6486 :                            return 0;
; 6487 :                   }
; 6488 :                   left-=count;
; 6489 :                }
; 6490 :                break;
; 6491 :             }
; 6492 :          }
; 6493 :       }
; 6494 :    }
; 6495 : 
; 6496 :    return result;
; 6497 : }
; 6498 : 
; 6499 : static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)
; 6500 : {
; 6501 :    stbi_uc *result;
; 6502 :    int i, x,y, internal_comp;
; 6503 :    STBI_NOTUSED(ri);
; 6504 : 
; 6505 :    if (!comp) comp = &internal_comp;
; 6506 : 
; 6507 :    for (i=0; i<92; ++i)
; 6508 :       stbi__get8(s);
; 6509 : 
; 6510 :    x = stbi__get16be(s);
; 6511 :    y = stbi__get16be(s);
; 6512 : 
; 6513 :    if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 6514 :    if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
; 6515 : 
; 6516 :    if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");
; 6517 :    if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");
; 6518 : 
; 6519 :    stbi__get32be(s); //skip `ratio'
; 6520 :    stbi__get16be(s); //skip `fields'
; 6521 :    stbi__get16be(s); //skip `pad'
; 6522 : 
; 6523 :    // intermediate buffer is RGBA
; 6524 :    result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
; 6525 :    if (!result) return stbi__errpuc("outofmem", "Out of memory");
; 6526 :    memset(result, 0xff, x*y*4);
; 6527 : 
; 6528 :    if (!stbi__pic_load_core(s,x,y,comp, result)) {
; 6529 :       STBI_FREE(result);
; 6530 :       result=0;
; 6531 :    }
; 6532 :    *px = x;
; 6533 :    *py = y;
; 6534 :    if (req_comp == 0) req_comp = *comp;
; 6535 :    result=stbi__convert_format(result,4,req_comp,x,y);
; 6536 : 
; 6537 :    return result;
; 6538 : }
; 6539 : 
; 6540 : static int stbi__pic_test(stbi__context *s)
; 6541 : {
; 6542 :    int r = stbi__pic_test_core(s);
; 6543 :    stbi__rewind(s);
; 6544 :    return r;
; 6545 : }
; 6546 : #endif
; 6547 : 
; 6548 : // *************************************************************************************************
; 6549 : // GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb
; 6550 : 
; 6551 : #ifndef STBI_NO_GIF
; 6552 : typedef struct
; 6553 : {
; 6554 :    stbi__int16 prefix;
; 6555 :    stbi_uc first;
; 6556 :    stbi_uc suffix;
; 6557 : } stbi__gif_lzw;
; 6558 : 
; 6559 : typedef struct
; 6560 : {
; 6561 :    int w,h;
; 6562 :    stbi_uc *out;                 // output buffer (always 4 components)
; 6563 :    stbi_uc *background;          // The current "background" as far as a gif is concerned
; 6564 :    stbi_uc *history;
; 6565 :    int flags, bgindex, ratio, transparent, eflags;
; 6566 :    stbi_uc  pal[256][4];
; 6567 :    stbi_uc lpal[256][4];
; 6568 :    stbi__gif_lzw codes[8192];
; 6569 :    stbi_uc *color_table;
; 6570 :    int parse, step;
; 6571 :    int lflags;
; 6572 :    int start_x, start_y;
; 6573 :    int max_x, max_y;
; 6574 :    int cur_x, cur_y;
; 6575 :    int line_size;
; 6576 :    int delay;
; 6577 : } stbi__gif;
; 6578 : 
; 6579 : static int stbi__gif_test_raw(stbi__context *s)
; 6580 : {
; 6581 :    int sz;
; 6582 :    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
; 6583 :    sz = stbi__get8(s);
; 6584 :    if (sz != '9' && sz != '7') return 0;
; 6585 :    if (stbi__get8(s) != 'a') return 0;
; 6586 :    return 1;
; 6587 : }
; 6588 : 
; 6589 : static int stbi__gif_test(stbi__context *s)
; 6590 : {
; 6591 :    int r = stbi__gif_test_raw(s);
; 6592 :    stbi__rewind(s);
; 6593 :    return r;
; 6594 : }
; 6595 : 
; 6596 : static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
; 6597 : {
; 6598 :    int i;
; 6599 :    for (i=0; i < num_entries; ++i) {
; 6600 :       pal[i][2] = stbi__get8(s);
; 6601 :       pal[i][1] = stbi__get8(s);
; 6602 :       pal[i][0] = stbi__get8(s);
; 6603 :       pal[i][3] = transp == i ? 0 : 255;
; 6604 :    }
; 6605 : }
; 6606 : 
; 6607 : static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
; 6608 : {
; 6609 :    stbi_uc version;
; 6610 :    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
; 6611 :       return stbi__err("not GIF", "Corrupt GIF");
; 6612 : 
; 6613 :    version = stbi__get8(s);
; 6614 :    if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");
; 6615 :    if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");
; 6616 : 
; 6617 :    stbi__g_failure_reason = "";
; 6618 :    g->w = stbi__get16le(s);
; 6619 :    g->h = stbi__get16le(s);
; 6620 :    g->flags = stbi__get8(s);
; 6621 :    g->bgindex = stbi__get8(s);
; 6622 :    g->ratio = stbi__get8(s);
; 6623 :    g->transparent = -1;
; 6624 : 
; 6625 :    if (g->w > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 6626 :    if (g->h > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
; 6627 : 
; 6628 :    if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments
; 6629 : 
; 6630 :    if (is_info) return 1;
; 6631 : 
; 6632 :    if (g->flags & 0x80)
; 6633 :       stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);
; 6634 : 
; 6635 :    return 1;
; 6636 : }
; 6637 : 
; 6638 : static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
; 6639 : {
; 6640 :    stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
; 6641 :    if (!g) return stbi__err("outofmem", "Out of memory");
; 6642 :    if (!stbi__gif_header(s, g, comp, 1)) {
; 6643 :       STBI_FREE(g);
; 6644 :       stbi__rewind( s );
; 6645 :       return 0;
; 6646 :    }
; 6647 :    if (x) *x = g->w;
; 6648 :    if (y) *y = g->h;
; 6649 :    STBI_FREE(g);
; 6650 :    return 1;
; 6651 : }
; 6652 : 
; 6653 : static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
; 6654 : {
; 6655 :    stbi_uc *p, *c;
; 6656 :    int idx;
; 6657 : 
; 6658 :    // recurse to decode the prefixes, since the linked-list is backwards,
; 6659 :    // and working backwards through an interleaved image would be nasty
; 6660 :    if (g->codes[code].prefix >= 0)
; 6661 :       stbi__out_gif_code(g, g->codes[code].prefix);
; 6662 : 
; 6663 :    if (g->cur_y >= g->max_y) return;
; 6664 : 
; 6665 :    idx = g->cur_x + g->cur_y;
; 6666 :    p = &g->out[idx];
; 6667 :    g->history[idx / 4] = 1;
; 6668 : 
; 6669 :    c = &g->color_table[g->codes[code].suffix * 4];
; 6670 :    if (c[3] > 128) { // don't render transparent pixels;
; 6671 :       p[0] = c[2];
; 6672 :       p[1] = c[1];
; 6673 :       p[2] = c[0];
; 6674 :       p[3] = c[3];
; 6675 :    }
; 6676 :    g->cur_x += 4;
; 6677 : 
; 6678 :    if (g->cur_x >= g->max_x) {
; 6679 :       g->cur_x = g->start_x;
; 6680 :       g->cur_y += g->step;
; 6681 : 
; 6682 :       while (g->cur_y >= g->max_y && g->parse > 0) {
; 6683 :          g->step = (1 << g->parse) * g->line_size;
; 6684 :          g->cur_y = g->start_y + (g->step >> 1);
; 6685 :          --g->parse;
; 6686 :       }
; 6687 :    }
; 6688 : }
; 6689 : 
; 6690 : static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
; 6691 : {
; 6692 :    stbi_uc lzw_cs;
; 6693 :    stbi__int32 len, init_code;
; 6694 :    stbi__uint32 first;
; 6695 :    stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
; 6696 :    stbi__gif_lzw *p;
; 6697 : 
; 6698 :    lzw_cs = stbi__get8(s);
; 6699 :    if (lzw_cs > 12) return NULL;
; 6700 :    clear = 1 << lzw_cs;
; 6701 :    first = 1;
; 6702 :    codesize = lzw_cs + 1;
; 6703 :    codemask = (1 << codesize) - 1;
; 6704 :    bits = 0;
; 6705 :    valid_bits = 0;
; 6706 :    for (init_code = 0; init_code < clear; init_code++) {
; 6707 :       g->codes[init_code].prefix = -1;
; 6708 :       g->codes[init_code].first = (stbi_uc) init_code;
; 6709 :       g->codes[init_code].suffix = (stbi_uc) init_code;
; 6710 :    }
; 6711 : 
; 6712 :    // support no starting clear code
; 6713 :    avail = clear+2;
; 6714 :    oldcode = -1;
; 6715 : 
; 6716 :    len = 0;
; 6717 :    for(;;) {
; 6718 :       if (valid_bits < codesize) {
; 6719 :          if (len == 0) {
; 6720 :             len = stbi__get8(s); // start new block
; 6721 :             if (len == 0)
; 6722 :                return g->out;
; 6723 :          }
; 6724 :          --len;
; 6725 :          bits |= (stbi__int32) stbi__get8(s) << valid_bits;
; 6726 :          valid_bits += 8;
; 6727 :       } else {
; 6728 :          stbi__int32 code = bits & codemask;
; 6729 :          bits >>= codesize;
; 6730 :          valid_bits -= codesize;
; 6731 :          // @OPTIMIZE: is there some way we can accelerate the non-clear path?
; 6732 :          if (code == clear) {  // clear code
; 6733 :             codesize = lzw_cs + 1;
; 6734 :             codemask = (1 << codesize) - 1;
; 6735 :             avail = clear + 2;
; 6736 :             oldcode = -1;
; 6737 :             first = 0;
; 6738 :          } else if (code == clear + 1) { // end of stream code
; 6739 :             stbi__skip(s, len);
; 6740 :             while ((len = stbi__get8(s)) > 0)
; 6741 :                stbi__skip(s,len);
; 6742 :             return g->out;
; 6743 :          } else if (code <= avail) {
; 6744 :             if (first) {
; 6745 :                return stbi__errpuc("no clear code", "Corrupt GIF");
; 6746 :             }
; 6747 : 
; 6748 :             if (oldcode >= 0) {
; 6749 :                p = &g->codes[avail++];
; 6750 :                if (avail > 8192) {
; 6751 :                   return stbi__errpuc("too many codes", "Corrupt GIF");
; 6752 :                }
; 6753 : 
; 6754 :                p->prefix = (stbi__int16) oldcode;
; 6755 :                p->first = g->codes[oldcode].first;
; 6756 :                p->suffix = (code == avail) ? p->first : g->codes[code].first;
; 6757 :             } else if (code == avail)
; 6758 :                return stbi__errpuc("illegal code in raster", "Corrupt GIF");
; 6759 : 
; 6760 :             stbi__out_gif_code(g, (stbi__uint16) code);
; 6761 : 
; 6762 :             if ((avail & codemask) == 0 && avail <= 0x0FFF) {
; 6763 :                codesize++;
; 6764 :                codemask = (1 << codesize) - 1;
; 6765 :             }
; 6766 : 
; 6767 :             oldcode = code;
; 6768 :          } else {
; 6769 :             return stbi__errpuc("illegal code in raster", "Corrupt GIF");
; 6770 :          }
; 6771 :       }
; 6772 :    }
; 6773 : }
; 6774 : 
; 6775 : // this function is designed to support animated gifs, although stb_image doesn't support it
; 6776 : // two back is the image from two frames ago, used for a very specific disposal format
; 6777 : static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)
; 6778 : {
; 6779 :    int dispose;
; 6780 :    int first_frame;
; 6781 :    int pi;
; 6782 :    int pcount;
; 6783 :    STBI_NOTUSED(req_comp);
; 6784 : 
; 6785 :    // on first frame, any non-written pixels get the background colour (non-transparent)
; 6786 :    first_frame = 0;
; 6787 :    if (g->out == 0) {
; 6788 :       if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header
; 6789 :       if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))
; 6790 :          return stbi__errpuc("too large", "GIF image is too large");
; 6791 :       pcount = g->w * g->h;
; 6792 :       g->out = (stbi_uc *) stbi__malloc(4 * pcount);
; 6793 :       g->background = (stbi_uc *) stbi__malloc(4 * pcount);
; 6794 :       g->history = (stbi_uc *) stbi__malloc(pcount);
; 6795 :       if (!g->out || !g->background || !g->history)
; 6796 :          return stbi__errpuc("outofmem", "Out of memory");
; 6797 : 
; 6798 :       // image is treated as "transparent" at the start - ie, nothing overwrites the current background;
; 6799 :       // background colour is only used for pixels that are not rendered first frame, after that "background"
; 6800 :       // color refers to the color that was there the previous frame.
; 6801 :       memset(g->out, 0x00, 4 * pcount);
; 6802 :       memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)
; 6803 :       memset(g->history, 0x00, pcount);        // pixels that were affected previous frame
; 6804 :       first_frame = 1;
; 6805 :    } else {
; 6806 :       // second frame - how do we dispose of the previous one?
; 6807 :       dispose = (g->eflags & 0x1C) >> 2;
; 6808 :       pcount = g->w * g->h;
; 6809 : 
; 6810 :       if ((dispose == 3) && (two_back == 0)) {
; 6811 :          dispose = 2; // if I don't have an image to revert back to, default to the old background
; 6812 :       }
; 6813 : 
; 6814 :       if (dispose == 3) { // use previous graphic
; 6815 :          for (pi = 0; pi < pcount; ++pi) {
; 6816 :             if (g->history[pi]) {
; 6817 :                memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );
; 6818 :             }
; 6819 :          }
; 6820 :       } else if (dispose == 2) {
; 6821 :          // restore what was changed last frame to background before that frame;
; 6822 :          for (pi = 0; pi < pcount; ++pi) {
; 6823 :             if (g->history[pi]) {
; 6824 :                memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );
; 6825 :             }
; 6826 :          }
; 6827 :       } else {
; 6828 :          // This is a non-disposal case eithe way, so just
; 6829 :          // leave the pixels as is, and they will become the new background
; 6830 :          // 1: do not dispose
; 6831 :          // 0:  not specified.
; 6832 :       }
; 6833 : 
; 6834 :       // background is what out is after the undoing of the previou frame;
; 6835 :       memcpy( g->background, g->out, 4 * g->w * g->h );
; 6836 :    }
; 6837 : 
; 6838 :    // clear my history;
; 6839 :    memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame
; 6840 : 
; 6841 :    for (;;) {
; 6842 :       int tag = stbi__get8(s);
; 6843 :       switch (tag) {
; 6844 :          case 0x2C: /* Image Descriptor */
; 6845 :          {
; 6846 :             stbi__int32 x, y, w, h;
; 6847 :             stbi_uc *o;
; 6848 : 
; 6849 :             x = stbi__get16le(s);
; 6850 :             y = stbi__get16le(s);
; 6851 :             w = stbi__get16le(s);
; 6852 :             h = stbi__get16le(s);
; 6853 :             if (((x + w) > (g->w)) || ((y + h) > (g->h)))
; 6854 :                return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");
; 6855 : 
; 6856 :             g->line_size = g->w * 4;
; 6857 :             g->start_x = x * 4;
; 6858 :             g->start_y = y * g->line_size;
; 6859 :             g->max_x   = g->start_x + w * 4;
; 6860 :             g->max_y   = g->start_y + h * g->line_size;
; 6861 :             g->cur_x   = g->start_x;
; 6862 :             g->cur_y   = g->start_y;
; 6863 : 
; 6864 :             // if the width of the specified rectangle is 0, that means
; 6865 :             // we may not see *any* pixels or the image is malformed;
; 6866 :             // to make sure this is caught, move the current y down to
; 6867 :             // max_y (which is what out_gif_code checks).
; 6868 :             if (w == 0)
; 6869 :                g->cur_y = g->max_y;
; 6870 : 
; 6871 :             g->lflags = stbi__get8(s);
; 6872 : 
; 6873 :             if (g->lflags & 0x40) {
; 6874 :                g->step = 8 * g->line_size; // first interlaced spacing
; 6875 :                g->parse = 3;
; 6876 :             } else {
; 6877 :                g->step = g->line_size;
; 6878 :                g->parse = 0;
; 6879 :             }
; 6880 : 
; 6881 :             if (g->lflags & 0x80) {
; 6882 :                stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
; 6883 :                g->color_table = (stbi_uc *) g->lpal;
; 6884 :             } else if (g->flags & 0x80) {
; 6885 :                g->color_table = (stbi_uc *) g->pal;
; 6886 :             } else
; 6887 :                return stbi__errpuc("missing color table", "Corrupt GIF");
; 6888 : 
; 6889 :             o = stbi__process_gif_raster(s, g);
; 6890 :             if (!o) return NULL;
; 6891 : 
; 6892 :             // if this was the first frame,
; 6893 :             pcount = g->w * g->h;
; 6894 :             if (first_frame && (g->bgindex > 0)) {
; 6895 :                // if first frame, any pixel not drawn to gets the background color
; 6896 :                for (pi = 0; pi < pcount; ++pi) {
; 6897 :                   if (g->history[pi] == 0) {
; 6898 :                      g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;
; 6899 :                      memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );
; 6900 :                   }
; 6901 :                }
; 6902 :             }
; 6903 : 
; 6904 :             return o;
; 6905 :          }
; 6906 : 
; 6907 :          case 0x21: // Comment Extension.
; 6908 :          {
; 6909 :             int len;
; 6910 :             int ext = stbi__get8(s);
; 6911 :             if (ext == 0xF9) { // Graphic Control Extension.
; 6912 :                len = stbi__get8(s);
; 6913 :                if (len == 4) {
; 6914 :                   g->eflags = stbi__get8(s);
; 6915 :                   g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.
; 6916 : 
; 6917 :                   // unset old transparent
; 6918 :                   if (g->transparent >= 0) {
; 6919 :                      g->pal[g->transparent][3] = 255;
; 6920 :                   }
; 6921 :                   if (g->eflags & 0x01) {
; 6922 :                      g->transparent = stbi__get8(s);
; 6923 :                      if (g->transparent >= 0) {
; 6924 :                         g->pal[g->transparent][3] = 0;
; 6925 :                      }
; 6926 :                   } else {
; 6927 :                      // don't need transparent
; 6928 :                      stbi__skip(s, 1);
; 6929 :                      g->transparent = -1;
; 6930 :                   }
; 6931 :                } else {
; 6932 :                   stbi__skip(s, len);
; 6933 :                   break;
; 6934 :                }
; 6935 :             }
; 6936 :             while ((len = stbi__get8(s)) != 0) {
; 6937 :                stbi__skip(s, len);
; 6938 :             }
; 6939 :             break;
; 6940 :          }
; 6941 : 
; 6942 :          case 0x3B: // gif stream termination code
; 6943 :             return (stbi_uc *) s; // using '1' causes warning on some compilers
; 6944 : 
; 6945 :          default:
; 6946 :             return stbi__errpuc("unknown code", "Corrupt GIF");
; 6947 :       }
; 6948 :    }
; 6949 : }
; 6950 : 
; 6951 : static void *stbi__load_gif_main_outofmem(stbi__gif *g, stbi_uc *out, int **delays)
; 6952 : {
; 6953 :    STBI_FREE(g->out);
; 6954 :    STBI_FREE(g->history);
; 6955 :    STBI_FREE(g->background);
; 6956 : 
; 6957 :    if (out) STBI_FREE(out);
; 6958 :    if (delays && *delays) STBI_FREE(*delays);
; 6959 :    return stbi__errpuc("outofmem", "Out of memory");
; 6960 : }
; 6961 : 
; 6962 : static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
; 6963 : {
; 6964 :    if (stbi__gif_test(s)) {
; 6965 :       int layers = 0;
; 6966 :       stbi_uc *u = 0;
; 6967 :       stbi_uc *out = 0;
; 6968 :       stbi_uc *two_back = 0;
; 6969 :       stbi__gif g;
; 6970 :       int stride;
; 6971 :       int out_size = 0;
; 6972 :       int delays_size = 0;
; 6973 : 
; 6974 :       STBI_NOTUSED(out_size);
; 6975 :       STBI_NOTUSED(delays_size);
; 6976 : 
; 6977 :       memset(&g, 0, sizeof(g));
; 6978 :       if (delays) {
; 6979 :          *delays = 0;
; 6980 :       }
; 6981 : 
; 6982 :       do {
; 6983 :          u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);
; 6984 :          if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
; 6985 : 
; 6986 :          if (u) {
; 6987 :             *x = g.w;
; 6988 :             *y = g.h;
; 6989 :             ++layers;
; 6990 :             stride = g.w * g.h * 4;
; 6991 : 
; 6992 :             if (out) {
; 6993 :                void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );
; 6994 :                if (!tmp)
; 6995 :                   return stbi__load_gif_main_outofmem(&g, out, delays);
; 6996 :                else {
; 6997 :                    out = (stbi_uc*) tmp;
; 6998 :                    out_size = layers * stride;
; 6999 :                }
; 7000 : 
; 7001 :                if (delays) {
; 7002 :                   int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );
; 7003 :                   if (!new_delays)
; 7004 :                      return stbi__load_gif_main_outofmem(&g, out, delays);
; 7005 :                   *delays = new_delays;
; 7006 :                   delays_size = layers * sizeof(int);
; 7007 :                }
; 7008 :             } else {
; 7009 :                out = (stbi_uc*)stbi__malloc( layers * stride );
; 7010 :                if (!out)
; 7011 :                   return stbi__load_gif_main_outofmem(&g, out, delays);
; 7012 :                out_size = layers * stride;
; 7013 :                if (delays) {
; 7014 :                   *delays = (int*) stbi__malloc( layers * sizeof(int) );
; 7015 :                   if (!*delays)
; 7016 :                      return stbi__load_gif_main_outofmem(&g, out, delays);
; 7017 :                   delays_size = layers * sizeof(int);
; 7018 :                }
; 7019 :             }
; 7020 :             memcpy( out + ((layers - 1) * stride), u, stride );
; 7021 :             if (layers >= 2) {
; 7022 :                two_back = out - 2 * stride;
; 7023 :             }
; 7024 : 
; 7025 :             if (delays) {
; 7026 :                (*delays)[layers - 1U] = g.delay;
; 7027 :             }
; 7028 :          }
; 7029 :       } while (u != 0);
; 7030 : 
; 7031 :       // free temp buffer;
; 7032 :       STBI_FREE(g.out);
; 7033 :       STBI_FREE(g.history);
; 7034 :       STBI_FREE(g.background);
; 7035 : 
; 7036 :       // do the final conversion after loading everything;
; 7037 :       if (req_comp && req_comp != 4)
; 7038 :          out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);
; 7039 : 
; 7040 :       *z = layers;
; 7041 :       return out;
; 7042 :    } else {
; 7043 :       return stbi__errpuc("not GIF", "Image was not as a gif type.");
; 7044 :    }
; 7045 : }
; 7046 : 
; 7047 : static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
; 7048 : {
; 7049 :    stbi_uc *u = 0;
; 7050 :    stbi__gif g;
; 7051 :    memset(&g, 0, sizeof(g));
; 7052 :    STBI_NOTUSED(ri);
; 7053 : 
; 7054 :    u = stbi__gif_load_next(s, &g, comp, req_comp, 0);
; 7055 :    if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
; 7056 :    if (u) {
; 7057 :       *x = g.w;
; 7058 :       *y = g.h;
; 7059 : 
; 7060 :       // moved conversion to after successful load so that the same
; 7061 :       // can be done for multiple frames.
; 7062 :       if (req_comp && req_comp != 4)
; 7063 :          u = stbi__convert_format(u, 4, req_comp, g.w, g.h);
; 7064 :    } else if (g.out) {
; 7065 :       // if there was an error and we allocated an image buffer, free it!
; 7066 :       STBI_FREE(g.out);
; 7067 :    }
; 7068 : 
; 7069 :    // free buffers needed for multiple frame loading;
; 7070 :    STBI_FREE(g.history);
; 7071 :    STBI_FREE(g.background);
; 7072 : 
; 7073 :    return u;
; 7074 : }
; 7075 : 
; 7076 : static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
; 7077 : {
; 7078 :    return stbi__gif_info_raw(s,x,y,comp);
; 7079 : }
; 7080 : #endif
; 7081 : 
; 7082 : // *************************************************************************************************
; 7083 : // Radiance RGBE HDR loader
; 7084 : // originally by Nicolas Schulz
; 7085 : #ifndef STBI_NO_HDR
; 7086 : static int stbi__hdr_test_core(stbi__context *s, const char *signature)
; 7087 : {
; 7088 :    int i;
; 7089 :    for (i=0; signature[i]; ++i)

	inc	rbx
	cmp	BYTE PTR [rbx], 0
	jne	SHORT $LL7@stbi__hdr_

; 7092 :    stbi__rewind(s);
; 7093 :    return 1;

	mov	eax, 1
	jmp	SHORT $LN30@stbi__hdr_
$LN21@stbi__hdr_:

; 7091 :           return 0;

	mov	rax, QWORD PTR [rsi+208]

; 7098 :    int r = stbi__hdr_test_core(s, "#?RADIANCE\n");
; 7099 :    stbi__rewind(s);
; 7100 :    if(!r) {
; 7101 :        r = stbi__hdr_test_core(s, "#?RGBE\n");

	lea	rdx, OFFSET FLAT:??_C@_07KFDJIKCK@?$CD?$DPRGBE?6@

; 7091 :           return 0;

	mov	QWORD PTR [rdi], rax

; 7098 :    int r = stbi__hdr_test_core(s, "#?RADIANCE\n");
; 7099 :    stbi__rewind(s);
; 7100 :    if(!r) {
; 7101 :        r = stbi__hdr_test_core(s, "#?RGBE\n");

	mov	rcx, rsi

; 7091 :           return 0;

	mov	rax, QWORD PTR [rsi+216]
	mov	QWORD PTR [rsi+200], rax

; 7098 :    int r = stbi__hdr_test_core(s, "#?RADIANCE\n");
; 7099 :    stbi__rewind(s);
; 7100 :    if(!r) {
; 7101 :        r = stbi__hdr_test_core(s, "#?RGBE\n");

	call	?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z ; stbi__hdr_test_core
$LN30@stbi__hdr_:

; 7102 :        stbi__rewind(s);
; 7103 :    }
; 7104 :    return r;

	mov	rdx, QWORD PTR [rsi+208]
	mov	rcx, QWORD PTR [rsi+216]
	mov	QWORD PTR [rdi], rdx
	mov	QWORD PTR [rsi+200], rcx

; 7105 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__hdr_test
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z
_TEXT	SEGMENT
z$ = 64
buffer$ = 72
?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z PROC ; stbi__hdr_gettoken, COMDAT

; 7109 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rcx+192]

; 7110 :    int len=0;

	xor	r15d, r15d
	mov	r12, rdx
	mov	rbx, rcx

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rcx+200]
	jae	SHORT $LN9@stbi__hdr_

; 1615 :       return *s->img_buffer++;

	movzx	edi, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rcx+192], rax
	jmp	SHORT $LN66@stbi__hdr_
$LN9@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rcx+48], r15d
	je	SHORT $LN10@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edi, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN66@stbi__hdr_
$LN10@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

	xor	dil, dil
$LN66@stbi__hdr_:

; 7111 :    char c = '\0';
; 7112 : 
; 7113 :    c = (char) stbi__get8(z);

	mov	r14, rbx
	mov	ebp, 48					; 00000030H
	mov	rsi, r15
$LL2@stbi__hdr_:

; 1628 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], 0
	je	SHORT $LN41@stbi__hdr_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	rax, QWORD PTR [rbx+32]
	mov	rcx, QWORD PTR [rbx+40]
	call	rax
	test	eax, eax
	je	SHORT $LN44@stbi__hdr_

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

	cmp	DWORD PTR [r14+rbp], 0
	je	$LN52@stbi__hdr_
$LN41@stbi__hdr_:

; 7114 : 
; 7115 :    while (!stbi__at_eof(z) && c != '\n') {

	mov	rax, QWORD PTR [rbx+200]
	cmp	QWORD PTR [rbx+192], rax
	jae	$LN52@stbi__hdr_
$LN44@stbi__hdr_:
	cmp	dil, 10
	je	$LN52@stbi__hdr_

; 7116 :       buffer[len++] = c;

	mov	BYTE PTR [rsi+r12], dil
	inc	r15d
	inc	rsi

; 7117 :       if (len == STBI__HDR_BUFLEN-1) {

	cmp	rsi, 1023				; 000003ffH
	je	SHORT $LL4@stbi__hdr_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN27@stbi__hdr_

; 1615 :       return *s->img_buffer++;

	movzx	edi, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LL2@stbi__hdr_
$LN27@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r14+rbp], 0
	je	SHORT $LN28@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edi, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	$LL2@stbi__hdr_
$LN28@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

	xor	dil, dil

; 7120 :             ;
; 7121 :          break;
; 7122 :       }
; 7123 :       c = (char) stbi__get8(z);
; 7124 :    }

	jmp	$LL2@stbi__hdr_
$LL4@stbi__hdr_:

; 1628 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], 0
	je	SHORT $LN42@stbi__hdr_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	rax, QWORD PTR [rbx+32]
	mov	rcx, QWORD PTR [rbx+40]
	call	rax
	test	eax, eax
	je	SHORT $LN43@stbi__hdr_

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

	cmp	DWORD PTR [r14+rbp], 0
	je	SHORT $LN52@stbi__hdr_
$LN42@stbi__hdr_:

; 7118 :          // flush to end of line
; 7119 :          while (!stbi__at_eof(z) && stbi__get8(z) != '\n')

	mov	rax, QWORD PTR [rbx+200]
	cmp	QWORD PTR [rbx+192], rax
	jae	SHORT $LN52@stbi__hdr_
$LN43@stbi__hdr_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN67@stbi__hdr_

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r14+rbp], 0
	je	SHORT $LL4@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN67@stbi__hdr_:

; 7118 :          // flush to end of line
; 7119 :          while (!stbi__at_eof(z) && stbi__get8(z) != '\n')

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	cl, 10
	jne	SHORT $LL4@stbi__hdr_
$LN52@stbi__hdr_:

; 7125 : 
; 7126 :    buffer[len] = 0;
; 7127 :    return buffer;
; 7128 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	movsxd	rax, r15d
	mov	BYTE PTR [rax+r12], 0
	mov	rax, r12
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ENDP ; stbi__hdr_gettoken
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__hdr_convert@@YAXPEAMPEAEH@Z
_TEXT	SEGMENT
output$ = 48
input$ = 56
req_comp$ = 64
?stbi__hdr_convert@@YAXPEAMPEAEH@Z PROC			; stbi__hdr_convert, COMDAT

; 7131 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 7132 :    if ( input[3] != 0 ) {

	movzx	eax, BYTE PTR [rdx+3]
	mov	ebx, r8d
	mov	rsi, rdx
	mov	rdi, rcx
	test	al, al
	je	$LN4@stbi__hdr_

; 7133 :       float f1;
; 7134 :       // Exponent
; 7135 :       f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	lea	edx, DWORD PTR [rax-136]
	call	QWORD PTR __imp_ldexp
	xorps	xmm2, xmm2
	cvtsd2ss xmm2, xmm0

; 7136 :       if (req_comp <= 2)

	cmp	ebx, 2
	jg	SHORT $LN6@stbi__hdr_

; 7137 :          output[0] = (input[0] + input[1] + input[2]) * f1 / 3;

	movzx	eax, BYTE PTR [rsi+1]
	movzx	ecx, BYTE PTR [rsi+2]
	add	ecx, eax
	movzx	eax, BYTE PTR [rsi]
	add	ecx, eax
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm2
	divss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [rdi], xmm0

; 7142 :       }
; 7143 :       if (req_comp == 2) output[1] = 1;

	cmp	ebx, 2
	jne	$LN2@stbi__hdr_
	mov	DWORD PTR [rdi+4], 1065353216		; 3f800000H

; 7152 :                  break;
; 7153 :       }
; 7154 :    }
; 7155 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@stbi__hdr_:

; 7138 :       else {
; 7139 :          output[0] = input[0] * f1;

	movzx	eax, BYTE PTR [rsi]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm2
	movss	DWORD PTR [rdi], xmm0

; 7140 :          output[1] = input[1] * f1;

	movzx	eax, BYTE PTR [rsi+1]
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	mulss	xmm1, xmm2
	movss	DWORD PTR [rdi+4], xmm1

; 7141 :          output[2] = input[2] * f1;

	movzx	eax, BYTE PTR [rsi+2]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm2
	movss	DWORD PTR [rdi+8], xmm0

; 7144 :       if (req_comp == 4) output[3] = 1;

	cmp	ebx, 4
	jne	SHORT $LN2@stbi__hdr_
	mov	DWORD PTR [rdi+12], 1065353216		; 3f800000H

; 7152 :                  break;
; 7153 :       }
; 7154 :    }
; 7155 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@stbi__hdr_:

; 7145 :    } else {
; 7146 :       switch (req_comp) {

	sub	ebx, 1
	je	SHORT $LN13@stbi__hdr_
	sub	ebx, 1
	je	SHORT $LN12@stbi__hdr_
	sub	ebx, 1
	je	SHORT $LN11@stbi__hdr_
	cmp	ebx, 1
	jne	SHORT $LN2@stbi__hdr_

; 7147 :          case 4: output[3] = 1; /* fallthrough */

	mov	DWORD PTR [rcx+12], 1065353216		; 3f800000H
$LN11@stbi__hdr_:

; 7148 :          case 3: output[0] = output[1] = output[2] = 0;

	xor	eax, eax
	mov	QWORD PTR [rcx+4], rax

; 7152 :                  break;
; 7153 :       }
; 7154 :    }
; 7155 : }

	mov	DWORD PTR [rcx], eax
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN12@stbi__hdr_:

; 7149 :                  break;
; 7150 :          case 2: output[1] = 1; /* fallthrough */

	mov	DWORD PTR [rcx+4], 1065353216		; 3f800000H
$LN13@stbi__hdr_:

; 7151 :          case 1: output[0] = 0;

	xor	eax, eax

; 7152 :                  break;
; 7153 :       }
; 7154 :    }
; 7155 : }

	mov	DWORD PTR [rcx], eax
$LN2@stbi__hdr_:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__hdr_convert@@YAXPEAMPEAEH@Z ENDP			; stbi__hdr_convert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
_TEXT	SEGMENT
tv1599 = 32
rgbe$1 = 32
scanline$1$ = 40
tv1588 = 48
j$1$ = 52
height$1$ = 56
hdr_data$1$ = 64
token$ = 72
tv1598 = 80
rgbe$2 = 80
buffer$ = 96
__$ArrayPad$ = 1120
s$ = 1216
x$ = 1224
y$ = 1232
comp$ = 1240
req_comp$dead$ = 1248
ri$dead$ = 1256
?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__hdr_load, COMDAT

; 7158 : {

	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 1160				; 00000488H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r15, rdx
	mov	r14, r9

; 7159 :    char buffer[STBI__HDR_BUFLEN];
; 7160 :    char *token;
; 7161 :    int valid = 0;
; 7162 :    int width, height;
; 7163 :    stbi_uc *scanline;
; 7164 :    float *hdr_data;
; 7165 :    int len;
; 7166 :    unsigned char count, value;
; 7167 :    int i, j, k, c1,c2, z;
; 7168 :    const char *headerToken;
; 7169 :    STBI_NOTUSED(ri);
; 7170 : 
; 7171 :    // Check identifier
; 7172 :    headerToken = stbi__hdr_gettoken(s,buffer);

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rbp, r8
	mov	rbx, rcx
	xor	edi, edi
	call	?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken

; 7173 :    if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)

	lea	rdx, OFFSET FLAT:??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@
	mov	rcx, rax
	mov	rsi, rax
	call	strcmp
	test	eax, eax
	je	SHORT $LN30@stbi__hdr_
	xor	ecx, ecx
	lea	rdx, OFFSET FLAT:??_C@_06NDOKKIDJ@?$CD?$DPRGBE@
	npad	7
$LL239@stbi__hdr_:
	movzx	eax, BYTE PTR [rsi+rcx]
	inc	rcx
	cmp	al, BYTE PTR [rdx+rcx-1]
	jne	$LN240@stbi__hdr_
	cmp	rcx, 7
	jne	SHORT $LL239@stbi__hdr_
$LN30@stbi__hdr_:

; 7175 : 
; 7176 :    // Parse header
; 7177 :    for(;;) {
; 7178 :       token = stbi__hdr_gettoken(s,buffer);

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rbx
	call	?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken
	mov	QWORD PTR token$[rsp], rax

; 7179 :       if (token[0] == 0) break;

	cmp	BYTE PTR [rax], dil
	je	$LN218@stbi__hdr_
	mov	esi, 1
	npad	9
$LL2@stbi__hdr_:

; 7180 :       if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;

	lea	rdx, OFFSET FLAT:??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rbx
	cmove	edi, esi
	call	?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken
	mov	QWORD PTR token$[rsp], rax
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LL2@stbi__hdr_

; 7181 :    }
; 7182 : 
; 7183 :    if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

	test	edi, edi
	je	$LN218@stbi__hdr_

; 7184 : 
; 7185 :    // Parse width and height
; 7186 :    // can't use sscanf() if we're not using stdio!
; 7187 :    token = stbi__hdr_gettoken(s,buffer);

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rbx
	call	?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken

; 7188 :    if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");

	mov	r8d, 3
	mov	QWORD PTR token$[rsp], rax
	lea	rdx, OFFSET FLAT:??_C@_03HKAKGGJN@?9Y?5@
	mov	rcx, rax
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN34@stbi__hdr_
$LN313@stbi__hdr_:

; 7286 : }

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@
	mov	QWORD PTR [rdx+rcx], rax
	xor	eax, eax
	jmp	$LN1@stbi__hdr_
$LN240@stbi__hdr_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_07NCIOKENI@not?5HDR@
	mov	QWORD PTR [rdx+rcx], rax

; 7174 :       return stbi__errpf("not HDR", "Corrupt HDR image");

	xor	eax, eax
	jmp	$LN1@stbi__hdr_
$LN34@stbi__hdr_:

; 7189 :    token += 3;

	mov	rcx, QWORD PTR token$[rsp]

; 7190 :    height = (int) strtol(token, &token, 10);

	lea	rdx, QWORD PTR token$[rsp]
	add	rcx, 3
	mov	r8d, 10
	mov	QWORD PTR token$[rsp], rcx
	call	QWORD PTR __imp_strtol

; 7191 :    while (*token == ' ') ++token;

	mov	rcx, QWORD PTR token$[rsp]
	mov	esi, eax
	mov	DWORD PTR height$1$[rsp], eax
	cmp	BYTE PTR [rcx], 32			; 00000020H
	jne	SHORT $LN6@stbi__hdr_
	npad	12
$LL5@stbi__hdr_:
	inc	rcx
	mov	QWORD PTR token$[rsp], rcx
	cmp	BYTE PTR [rcx], 32			; 00000020H
	je	SHORT $LL5@stbi__hdr_
$LN6@stbi__hdr_:

; 7192 :    if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");

	mov	r8d, 3
	lea	rdx, OFFSET FLAT:??_C@_03FOKDFDHG@?$CLX?5@
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	jne	$LN313@stbi__hdr_

; 7193 :    token += 3;

	mov	rcx, QWORD PTR token$[rsp]

; 7194 :    width = (int) strtol(token, NULL, 10);

	lea	r8d, QWORD PTR [rax+10]
	add	rcx, 3
	mov	QWORD PTR [rsp+1144], r13
	xor	edx, edx
	mov	QWORD PTR token$[rsp], rcx
	call	QWORD PTR __imp_strtol
	mov	r13d, eax

; 7195 : 
; 7196 :    if (height > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");

	cmp	esi, 16777216				; 01000000H
	jg	$LN225@stbi__hdr_

; 7197 :    if (width > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");

	cmp	r13d, 16777216				; 01000000H
	jg	$LN225@stbi__hdr_

; 7198 : 
; 7199 :    *x = width;

	mov	DWORD PTR [r15], r13d

; 7200 :    *y = height;

	mov	DWORD PTR [rbp], esi

; 7201 : 
; 7202 :    if (comp) *comp = 3;

	test	r14, r14
	je	SHORT $LN38@stbi__hdr_
	mov	DWORD PTR [r14], 3
$LN38@stbi__hdr_:

; 1014 :    if (a < 0 || b < 0) return 0;

	test	r13d, r13d
	js	$LN225@stbi__hdr_
	test	esi, esi
	js	$LN225@stbi__hdr_

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	je	SHORT $LN226@stbi__hdr_

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	esi

; 1039 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	r13d, eax
	jg	$LN225@stbi__hdr_
$LN226@stbi__hdr_:
	mov	eax, r13d
	imul	eax, esi

; 1014 :    if (a < 0 || b < 0) return 0;

	test	eax, eax
	js	$LN225@stbi__hdr_

; 1039 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	eax, 536870911				; 1fffffffH
	jg	$LN225@stbi__hdr_
	mov	ecx, r13d
	imul	ecx, esi
	shl	ecx, 2

; 1014 :    if (a < 0 || b < 0) return 0;

	test	ecx, ecx
	js	$LN225@stbi__hdr_

; 1039 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	ecx, 536870911				; 1fffffffH
	jg	$LN225@stbi__hdr_
	mov	QWORD PTR [rsp+1152], r12

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

	test	esi, esi
	je	SHORT $LN224@stbi__hdr_

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	esi

; 1039 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

	cmp	r13d, eax
	jg	$LN219@stbi__hdr_
$LN224@stbi__hdr_:

; 1017 :    return a <= INT_MAX/b;

	lea	edi, DWORD PTR [r13*4]

; 1063 :    return stbi__malloc(a*b*c*d + add);

	mov	eax, edi

; 1017 :    return a <= INT_MAX/b;

	mov	DWORD PTR tv1588[rsp], edi

; 1063 :    return stbi__malloc(a*b*c*d + add);

	imul	eax, esi
	shl	eax, 2
	movsxd	rcx, eax

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc
	mov	QWORD PTR hdr_data$1$[rsp], rax
	mov	r12, rax

; 7207 : 
; 7208 :    // Read data
; 7209 :    hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);
; 7210 :    if (!hdr_data)

	test	rax, rax
	je	$LN219@stbi__hdr_

; 7211 :       return stbi__errpf("outofmem", "Out of memory");
; 7212 : 
; 7213 :    // Load image data
; 7214 :    // image data is stored as some number of sca
; 7215 :    if ( width < 8 || width >= 32768) {

	lea	ecx, DWORD PTR [r13-8]
	cmp	ecx, 32759				; 00007ff7H
	ja	$LN44@stbi__hdr_

; 7223 :          }
; 7224 :       }
; 7225 :    } else {
; 7226 :       // Read RLE-encoded data
; 7227 :       scanline = NULL;

	xor	r15d, r15d
	mov	QWORD PTR scanline$1$[rsp], r15

; 7228 : 
; 7229 :       for (j = 0; j < height; ++j) {

	mov	DWORD PTR j$1$[rsp], r15d
	test	esi, esi
	jle	$LN245@stbi__hdr_
	mov	DWORD PTR tv1599[rsp], r15d
	mov	DWORD PTR tv1598[rsp], edi
	npad	5
$LL15@stbi__hdr_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN130@stbi__hdr_

; 1615 :       return *s->img_buffer++;

	movzx	ebp, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN310@stbi__hdr_
$LN130@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN131@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ebp, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN310@stbi__hdr_
$LN131@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

	xor	bpl, bpl
$LN310@stbi__hdr_:

; 7230 :          c1 = stbi__get8(s);

	mov	edx, 48					; 00000030H
	mov	rcx, rbx
	lea	r14, QWORD PTR [rdx+rbx]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN134@stbi__hdr_

; 1615 :       return *s->img_buffer++;

	movzx	esi, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN133@stbi__hdr_
$LN134@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r14], 0
	je	SHORT $LN135@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	esi, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN133@stbi__hdr_
$LN135@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

	xor	sil, sil
$LN133@stbi__hdr_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN126@stbi__hdr_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN125@stbi__hdr_
$LN126@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r14], 0
	je	SHORT $LN127@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN125@stbi__hdr_
$LN127@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN125@stbi__hdr_:

; 7231 :          c2 = stbi__get8(s);
; 7232 :          len = stbi__get8(s);

	movzx	edi, cl

; 7233 :          if (c1 != 2 || c2 != 2 || (len & 0x80)) {

	cmp	bpl, 2
	jne	$LN46@stbi__hdr_
	cmp	sil, bpl
	jne	$LN46@stbi__hdr_
	test	dil, dil
	js	$LN46@stbi__hdr_

; 7246 :          }
; 7247 :          len <<= 8;

	shl	edi, 8

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN156@stbi__hdr_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN155@stbi__hdr_
$LN156@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r14], 0
	je	SHORT $LN157@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN155@stbi__hdr_
$LN157@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN155@stbi__hdr_:

; 7248 :          len |= stbi__get8(s);

	movzx	eax, cl
	or	eax, edi

; 7249 :          if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }

	cmp	eax, r13d
	jne	$LN193@stbi__hdr_

; 7250 :          if (scanline == NULL) {

	test	r15, r15
	jne	SHORT $LN49@stbi__hdr_

; 1049 :    return stbi__malloc(a*b + add);

	movsxd	rdi, DWORD PTR tv1588[rsp]
	mov	rcx, rdi

; 985  :     return STBI_MALLOC(size);

	call	QWORD PTR __imp_malloc
	mov	QWORD PTR scanline$1$[rsp], rax

; 7251 :             scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);
; 7252 :             if (!scanline) {

	test	rax, rax
	je	$LN194@stbi__hdr_
	mov	DWORD PTR tv1588[rsp], edi
$LN49@stbi__hdr_:

; 7254 :                return stbi__errpf("outofmem", "Out of memory");
; 7255 :             }
; 7256 :          }
; 7257 : 
; 7258 :          for (k = 0; k < 4; ++k) {

	xor	r12d, r12d
$LL18@stbi__hdr_:

; 7259 :             int nleft;
; 7260 :             i = 0;

	xor	ebp, ebp
	xor	r15d, r15d

; 7261 :             while ((nleft = width - i) > 0) {

	mov	esi, r13d
	test	r13d, r13d
	jle	$LN16@stbi__hdr_
	npad	10
$LL19@stbi__hdr_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jb	SHORT $LN311@stbi__hdr_

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r14], 0
	je	$LN191@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
$LN311@stbi__hdr_:

; 7262 :                count = stbi__get8(s);
; 7263 :                if (count > 128) {

	movzx	edi, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	cmp	dil, 128				; 00000080H
	jbe	$LN50@stbi__hdr_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN148@stbi__hdr_

; 1615 :       return *s->img_buffer++;

	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN147@stbi__hdr_
$LN148@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r14], 0
	je	SHORT $LN149@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN147@stbi__hdr_
$LN149@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

	xor	dl, dl
$LN147@stbi__hdr_:

; 7264 :                   // Run
; 7265 :                   value = stbi__get8(s);
; 7266 :                   count -= 128;

	add	dil, 128				; 00000080H

; 7267 :                   if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }

	je	$LN191@stbi__hdr_
	movzx	r8d, dil
	cmp	r8d, esi
	ja	$LN191@stbi__hdr_

; 7268 :                   for (z = 0; z < count; ++z)

	test	dil, dil
	je	$LN25@stbi__hdr_
	lea	rax, QWORD PTR [r12+r15*4]
	add	ebp, r8d
	add	rax, QWORD PTR scanline$1$[rsp]
	mov	ecx, r8d
	add	r15, r8
$LL23@stbi__hdr_:

; 7269 :                      scanline[i++ * 4 + k] = value;

	mov	BYTE PTR [rax], dl
	lea	rax, QWORD PTR [rax+4]
	sub	rcx, 1
	jne	SHORT $LL23@stbi__hdr_

; 7270 :                } else {

	jmp	$LN25@stbi__hdr_
$LN50@stbi__hdr_:

; 7271 :                   // Dump
; 7272 :                   if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }

	test	dil, dil
	je	$LN191@stbi__hdr_
	movzx	eax, dil
	cmp	eax, esi
	ja	$LN191@stbi__hdr_

; 7273 :                   for (z = 0; z < count; ++z)

	test	dil, dil
	je	$LN25@stbi__hdr_
	lea	rdi, QWORD PTR [r12+r15*4]
	add	ebp, eax
	add	rdi, QWORD PTR scanline$1$[rsp]
	mov	esi, eax
	add	r15, rax
	npad	1
$LL26@stbi__hdr_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN144@stbi__hdr_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN143@stbi__hdr_
$LN144@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r14], 0
	je	SHORT $LN145@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN143@stbi__hdr_
$LN145@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN143@stbi__hdr_:

; 7274 :                      scanline[i++ * 4 + k] = stbi__get8(s);

	mov	BYTE PTR [rdi], cl
	add	rdi, 4
	sub	rsi, 1
	jne	SHORT $LL26@stbi__hdr_
$LN25@stbi__hdr_:

; 7261 :             while ((nleft = width - i) > 0) {

	mov	esi, r13d
	sub	esi, ebp
	test	esi, esi
	jg	$LL19@stbi__hdr_
$LN16@stbi__hdr_:

; 7254 :                return stbi__errpf("outofmem", "Out of memory");
; 7255 :             }
; 7256 :          }
; 7257 : 
; 7258 :          for (k = 0; k < 4; ++k) {

	inc	r12
	cmp	r12, 4
	jl	$LL18@stbi__hdr_

; 7275 :                }
; 7276 :             }
; 7277 :          }
; 7278 :          for (i=0; i < width; ++i)

	mov	r15, QWORD PTR scanline$1$[rsp]
	mov	r12, QWORD PTR hdr_data$1$[rsp]
	test	r13d, r13d
	jle	SHORT $LN13@stbi__hdr_
	movsxd	rax, DWORD PTR tv1599[rsp]
	mov	rdi, r15
	mov	rbp, r13
	lea	rsi, QWORD PTR [r12+rax*4]
	npad	7
$LL29@stbi__hdr_:

; 7279 :             stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);

	mov	r8d, 4
	mov	rdx, rdi
	mov	rcx, rsi
	call	?stbi__hdr_convert@@YAXPEAMPEAEH@Z	; stbi__hdr_convert
	add	rdi, 4
	add	rsi, 16
	sub	rbp, 1
	jne	SHORT $LL29@stbi__hdr_
$LN13@stbi__hdr_:

; 7228 : 
; 7229 :       for (j = 0; j < height; ++j) {

	mov	ecx, DWORD PTR j$1$[rsp]
	mov	eax, DWORD PTR tv1598[rsp]
	inc	ecx
	add	DWORD PTR tv1599[rsp], eax
	mov	DWORD PTR j$1$[rsp], ecx
	cmp	ecx, DWORD PTR height$1$[rsp]
	jl	$LL15@stbi__hdr_

; 7280 :       }
; 7281 :       if (scanline)

	test	r15, r15
	je	SHORT $LN245@stbi__hdr_

; 7282 :          STBI_FREE(scanline);

	mov	rcx, r15
	call	QWORD PTR __imp_free
$LN245@stbi__hdr_:

; 7283 :    }
; 7284 : 
; 7285 :    return hdr_data;

	mov	rax, r12
	jmp	SHORT $LN309@stbi__hdr_
$LN194@stbi__hdr_:

; 7253 :                STBI_FREE(hdr_data);

	mov	rcx, r12
	call	QWORD PTR __imp_free
$LN219@stbi__hdr_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
$LN312@stbi__hdr_:
	mov	QWORD PTR [rdx+rcx], rax

; 7271 :                   // Dump
; 7272 :                   if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }

	xor	eax, eax
$LN309@stbi__hdr_:
	mov	r12, QWORD PTR [rsp+1152]
$LN308@stbi__hdr_:
	mov	r13, QWORD PTR [rsp+1144]
$LN1@stbi__hdr_:

; 7286 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1160				; 00000488H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN191@stbi__hdr_:

; 7271 :                   // Dump
; 7272 :                   if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }

	mov	rcx, QWORD PTR hdr_data$1$[rsp]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR scanline$1$[rsp]
	call	QWORD PTR __imp_free

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_07DPPMCAKL@corrupt@

; 7271 :                   // Dump
; 7272 :                   if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }

	jmp	SHORT $LN312@stbi__hdr_
$LN193@stbi__hdr_:

; 7249 :          if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }

	mov	rcx, r12
	call	QWORD PTR __imp_free
	mov	rcx, r15
	call	QWORD PTR __imp_free

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0CA@JBEOCDFN@invalid?5decoded?5scanline?5length@

; 7249 :          if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }

	jmp	$LN312@stbi__hdr_
$LN46@stbi__hdr_:

; 7234 :             // not run-length encoded, so we have to actually use THIS data as a decoded
; 7235 :             // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
; 7236 :             stbi_uc rgbe[4];
; 7237 :             rgbe[0] = (stbi_uc) c1;

	mov	BYTE PTR rgbe$1[rsp], bpl

; 7238 :             rgbe[1] = (stbi_uc) c2;

	mov	BYTE PTR rgbe$1[rsp+1], sil

; 7239 :             rgbe[2] = (stbi_uc) len;

	mov	BYTE PTR rgbe$1[rsp+2], cl

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN138@stbi__hdr_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN137@stbi__hdr_
$LN138@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r14], 0
	je	SHORT $LN139@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN137@stbi__hdr_
$LN139@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN137@stbi__hdr_:

; 7240 :             rgbe[3] = (stbi_uc) stbi__get8(s);

	mov	BYTE PTR rgbe$1[rsp+3], cl

; 7241 :             stbi__hdr_convert(hdr_data, rgbe, req_comp);

	lea	rdx, QWORD PTR rgbe$1[rsp]
	mov	rcx, r12
	mov	r8d, 4
	call	?stbi__hdr_convert@@YAXPEAMPEAEH@Z	; stbi__hdr_convert

; 7242 :             i = 1;
; 7243 :             j = 0;
; 7244 :             STBI_FREE(scanline);

	mov	rcx, r15
	xor	edi, edi
	call	QWORD PTR __imp_free

; 7245 :             goto main_decode_loop; // yes, this makes no sense

	lea	esi, QWORD PTR [rdi+1]
	jmp	SHORT $main_decode_loop$315
$LN44@stbi__hdr_:

; 7216 :       // Read flat data
; 7217 :       for (j=0; j < height; ++j) {

	xor	edi, edi
$LN9@stbi__hdr_:
	cmp	edi, esi
	jge	$LN245@stbi__hdr_

; 7218 :          for (i=0; i < width; ++i) {

	xor	esi, esi
$LN12@stbi__hdr_:
	cmp	esi, r13d
	jge	SHORT $LN7@stbi__hdr_
$main_decode_loop$315:

; 7219 :             stbi_uc rgbe[4];
; 7220 :            main_decode_loop:
; 7221 :             stbi__getn(s, rgbe, 4);

	mov	r8d, 4
	lea	rdx, QWORD PTR rgbe$2[rsp]
	mov	rcx, rbx
	call	?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn

; 7222 :             stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);

	mov	eax, r13d
	mov	r8d, 4
	imul	eax, edi
	shl	eax, 2
	movsxd	rdx, eax
	lea	eax, DWORD PTR [rsi*4]
	movsxd	rcx, eax
	add	rdx, rcx
	lea	rcx, QWORD PTR [r12+rdx*4]
	lea	rdx, QWORD PTR rgbe$2[rsp]
	call	?stbi__hdr_convert@@YAXPEAMPEAEH@Z	; stbi__hdr_convert
	inc	esi
	jmp	SHORT $LN12@stbi__hdr_
$LN7@stbi__hdr_:

; 7216 :       // Read flat data
; 7217 :       for (j=0; j < height; ++j) {

	mov	esi, DWORD PTR height$1$[rsp]
	inc	edi
	jmp	SHORT $LN9@stbi__hdr_
$LN225@stbi__hdr_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
	mov	QWORD PTR [rdx+rcx], rax

; 7203 :    if (req_comp == 0) req_comp = 3;
; 7204 : 
; 7205 :    if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
; 7206 :       return stbi__errpf("too large", "HDR image is too large");

	xor	eax, eax
	jmp	$LN308@stbi__hdr_
$LN218@stbi__hdr_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BD@NKJFFLKL@unsupported?5format@
	mov	QWORD PTR [rdx+rcx], rax

; 7181 :    }
; 7182 : 
; 7183 :    if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

	xor	eax, eax
	jmp	$LN1@stbi__hdr_
?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__hdr_load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__pnm_test@@YAHPEAUstbi__context@@@Z
_TEXT	SEGMENT
s$ = 48
?stbi__pnm_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__pnm_test, COMDAT

; 7494 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rcx+192]

; 7494 : {

	mov	rbx, rcx

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rax, QWORD PTR [rcx+200]
	jae	SHORT $LN6@stbi__pnm_

; 1615 :       return *s->img_buffer++;

	movzx	edi, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rcx+192], rax
	jmp	SHORT $LN22@stbi__pnm_
$LN6@stbi__pnm_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rcx+48], 0
	je	SHORT $LN7@stbi__pnm_

; 1617 :       stbi__refill_buffer(s);

	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edi, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN22@stbi__pnm_
$LN7@stbi__pnm_:

; 1619 :    }
; 1620 :    return 0;

	xor	dil, dil
$LN22@stbi__pnm_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	ecx, 48					; 00000030H
	mov	rdx, rbx
	lea	r8, QWORD PTR [rcx+rbx]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN10@stbi__pnm_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN9@stbi__pnm_
$LN10@stbi__pnm_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [r8], 0
	je	SHORT $LN11@stbi__pnm_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN9@stbi__pnm_
$LN11@stbi__pnm_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN9@stbi__pnm_:

; 7495 :    char p, t;
; 7496 :    p = (char) stbi__get8(s);
; 7497 :    t = (char) stbi__get8(s);
; 7498 :    if (p != 'P' || (t != '5' && t != '6')) {

	cmp	dil, 80					; 00000050H
	jne	SHORT $LN3@stbi__pnm_
	sub	cl, 53					; 00000035H
	cmp	cl, 1
	ja	SHORT $LN3@stbi__pnm_

; 7501 :    }
; 7502 :    return 1;

	mov	eax, 1

; 7503 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@stbi__pnm_:

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	rax, QWORD PTR [rbx+208]
	mov	QWORD PTR [rbx+192], rax

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	rax, QWORD PTR [rbx+216]
	mov	QWORD PTR [rbx+200], rax

; 7499 :        stbi__rewind( s );
; 7500 :        return 0;

	xor	eax, eax

; 7503 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbi__pnm_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__pnm_test
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
_TEXT	SEGMENT
s$ = 80
x$ = 88
y$ = 96
comp$ = 104
req_comp$dead$ = 112
ri$ = 120
?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__pnm_load, COMDAT

; 7506 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rbp, r8
	mov	r12, rdx

; 7507 :    stbi_uc *out;
; 7508 :    STBI_NOTUSED(ri);
; 7509 : 
; 7510 :    ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);

	lea	r9, QWORD PTR [rcx+8]
	lea	r8, QWORD PTR [rcx+4]
	mov	rdx, rcx
	mov	rdi, rcx
	call	?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__pnm_info
	mov	r15, QWORD PTR ri$[rsp]
	mov	ecx, eax
	mov	DWORD PTR [r15], eax

; 7511 :    if (ri->bits_per_channel == 0)

	test	eax, eax
	je	SHORT $LN24@stbi__pnm_

; 7512 :       return 0;
; 7513 : 
; 7514 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

	cmp	DWORD PTR [rdi+4], 16777216		; 01000000H
	jbe	SHORT $LN3@stbi__pnm_
$LN36@stbi__pnm_:

; 7540 : }

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
$LN37@stbi__pnm_:
	mov	QWORD PTR [rdx+rcx], rax
$LN24@stbi__pnm_:
	xor	eax, eax
$LN1@stbi__pnm_:
	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	ret	0
$LN3@stbi__pnm_:

; 7515 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

	mov	eax, DWORD PTR [rdi]
	cmp	eax, 16777216				; 01000000H
	ja	SHORT $LN36@stbi__pnm_

; 7516 : 
; 7517 :    *x = s->img_x;

	mov	DWORD PTR [r12], eax

; 7518 :    *y = s->img_y;

	mov	eax, DWORD PTR [rdi+4]
	mov	DWORD PTR [rbp], eax

; 7519 :    if (comp) *comp = s->img_n;

	test	rbx, rbx
	je	SHORT $LN5@stbi__pnm_
	mov	eax, DWORD PTR [rdi+8]
	mov	DWORD PTR [rbx], eax
$LN5@stbi__pnm_:

; 7520 : 
; 7521 :    if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))

	mov	r11d, DWORD PTR [rdi]
	mov	eax, ecx
	mov	ebx, DWORD PTR [rdi+8]
	cdq
	mov	r8d, DWORD PTR [rdi+4]
	and	edx, 7
	mov	ecx, ebx
	lea	r9d, DWORD PTR [rdx+rax]
	mov	edx, r11d
	sar	r9d, 3
	call	?stbi__mad4sizes_valid@@YAHHHHHH@Z	; stbi__mad4sizes_valid
	test	eax, eax
	je	SHORT $LN36@stbi__pnm_

; 7522 :       return stbi__errpuc("too large", "PNM too large");
; 7523 : 
; 7524 :    out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);

	mov	edx, r11d
	mov	ecx, ebx
	call	?stbi__malloc_mad4@@YAPEAXHHHHH@Z	; stbi__malloc_mad4
	mov	rbx, rax

; 7525 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");

	test	rax, rax
	jne	SHORT $LN7@stbi__pnm_

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@

; 7525 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");

	jmp	$LN37@stbi__pnm_
$LN7@stbi__pnm_:

; 7526 :    if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {

	mov	eax, DWORD PTR [r15]
	mov	rcx, rdi
	cdq
	and	edx, 7
	lea	r8d, DWORD PTR [rdx+rax]
	mov	rdx, rbx
	sar	r8d, 3
	imul	r8d, DWORD PTR [rdi+8]
	imul	r8d, DWORD PTR [rdi+4]
	imul	r8d, DWORD PTR [rdi]
	call	?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn
	test	eax, eax
	jne	SHORT $LN8@stbi__pnm_

; 7527 :       STBI_FREE(out);

	mov	rcx, rbx
	call	QWORD PTR __imp_free

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_07IDKIDMGJ@bad?5PNM@

; 7528 :       return stbi__errpuc("bad PNM", "PNM file truncated");

	jmp	$LN37@stbi__pnm_
$LN8@stbi__pnm_:

; 7529 :    }
; 7530 : 
; 7531 :    if (req_comp && req_comp != s->img_n) {

	mov	edx, DWORD PTR [rdi+8]
	cmp	edx, 4
	je	SHORT $LN12@stbi__pnm_

; 7532 :       if (ri->bits_per_channel == 16) {

	cmp	DWORD PTR [r15], 16
	mov	rcx, rbx
	mov	eax, DWORD PTR [rdi+4]
	mov	r9d, DWORD PTR [rdi]
	mov	DWORD PTR [rsp+32], eax
	jne	SHORT $LN10@stbi__pnm_

; 7533 :          out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, s->img_n, req_comp, s->img_x, s->img_y);

	call	?stbi__convert_format16@@YAPEAGPEAGHHII@Z ; stbi__convert_format16

; 7534 :       } else {

	jmp	SHORT $LN35@stbi__pnm_
$LN10@stbi__pnm_:

; 7535 :          out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);

	mov	r8d, 4
	call	?stbi__convert_format@@YAPEAEPEAEHHII@Z	; stbi__convert_format
$LN35@stbi__pnm_:

; 7536 :       }
; 7537 :       if (out == NULL) return out; // stbi__convert_format frees input on failure

	mov	rbx, rax
	test	rax, rax
	je	$LN24@stbi__pnm_
$LN12@stbi__pnm_:

; 7538 :    }
; 7539 :    return out;

	mov	rax, rbx
	jmp	$LN1@stbi__pnm_
?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__pnm_load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__pnm_isspace@@YAHD@Z
_TEXT	SEGMENT
c$ = 8
?stbi__pnm_isspace@@YAHD@Z PROC				; stbi__pnm_isspace, COMDAT

; 7544 :    return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';

	cmp	cl, 32					; 00000020H
	je	SHORT $LN3@stbi__pnm_
	sub	cl, 9
	cmp	cl, 4
	jbe	SHORT $LN3@stbi__pnm_
	xor	eax, eax

; 7545 : }

	ret	0
$LN3@stbi__pnm_:

; 7544 :    return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';

	mov	eax, 1

; 7545 : }

	ret	0
?stbi__pnm_isspace@@YAHD@Z ENDP				; stbi__pnm_isspace
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z
_TEXT	SEGMENT
tv428 = 80
s$ = 80
c$ = 88
?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z PROC ; stbi__pnm_skip_whitespace, COMDAT

; 7548 : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	r13, rdx
	lea	r14, QWORD PTR [rcx+32]
	mov	rsi, rcx
	npad	10
$LL2@stbi__pnm_:
	lea	rdi, QWORD PTR [rsi+48]
	lea	r15, QWORD PTR [rsi+200]
	lea	rbx, QWORD PTR [rsi+192]
$LL5@stbi__pnm_:

; 1628 :    if (s->io.read) {

	cmp	QWORD PTR [rsi+16], 0
	lea	rbp, QWORD PTR [rsi+40]
	mov	QWORD PTR tv428[rsp], r14
	mov	rax, r15
	mov	rcx, rbx
	je	SHORT $LN15@stbi__pnm_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	rax, QWORD PTR [r14]
	mov	rcx, QWORD PTR [rbp]
	call	rax
	test	eax, eax
	je	SHORT $LN55@stbi__pnm_

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

	cmp	DWORD PTR [rdi], 0
	mov	rax, r15
	mov	rcx, rbx
	je	SHORT $LN56@stbi__pnm_
$LN15@stbi__pnm_:

; 7549 :    for (;;) {
; 7550 :       while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))

	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR [rcx], rax
	jae	SHORT $LN56@stbi__pnm_
$LN55@stbi__pnm_:
	movzx	eax, BYTE PTR [r13]

; 7544 :    return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';

	cmp	al, 32					; 00000020H
	je	SHORT $LN54@stbi__pnm_
	sub	al, 9
	cmp	al, 4
	ja	SHORT $LN56@stbi__pnm_
$LN54@stbi__pnm_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx]
	cmp	rax, QWORD PTR [r15]
	jae	SHORT $LN22@stbi__pnm_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	lea	rdi, QWORD PTR [rsi+48]
	inc	rax

; 7551 :          *c = (char) stbi__get8(s);

	mov	BYTE PTR [r13], cl

; 1615 :       return *s->img_buffer++;

	mov	QWORD PTR [rbx], rax

; 7551 :          *c = (char) stbi__get8(s);

	lea	r14, QWORD PTR [rsi+32]
	jmp	SHORT $LL5@stbi__pnm_
$LN22@stbi__pnm_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi], 0
	je	SHORT $LN23@stbi__pnm_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rsi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx]

; 7551 :          *c = (char) stbi__get8(s);

	lea	r14, QWORD PTR [rsi+32]

; 1618 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx], rax

; 7551 :          *c = (char) stbi__get8(s);

	mov	BYTE PTR [r13], cl
	jmp	$LL5@stbi__pnm_
$LN23@stbi__pnm_:

; 1620 :    return 0;

	xor	cl, cl

; 7551 :          *c = (char) stbi__get8(s);

	lea	r14, QWORD PTR [rsi+32]
	mov	BYTE PTR [r13], cl
	jmp	$LL5@stbi__pnm_
$LN56@stbi__pnm_:

; 1628 :    if (s->io.read) {

	cmp	QWORD PTR [rsi+16], 0
	je	SHORT $LN28@stbi__pnm_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	rax, QWORD PTR [r14]
	mov	rcx, QWORD PTR [rbp]
	call	rax
	test	eax, eax
	je	SHORT $LN53@stbi__pnm_

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

	cmp	DWORD PTR [rdi], 0
	je	$LN59@stbi__pnm_
$LN28@stbi__pnm_:

; 7552 : 
; 7553 :       if (stbi__at_eof(s) || *c != '#')

	mov	rax, QWORD PTR [r15]
	cmp	QWORD PTR [rbx], rax
	jae	$LN59@stbi__pnm_
$LN53@stbi__pnm_:
	cmp	BYTE PTR [r13], 35			; 00000023H
	jne	$LN59@stbi__pnm_
	npad	1
$LL7@stbi__pnm_:

; 1628 :    if (s->io.read) {

	cmp	QWORD PTR [rsi+16], 0
	je	SHORT $LN50@stbi__pnm_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	rax, QWORD PTR tv428[rsp]
	mov	rcx, QWORD PTR [rbp]
	mov	r14, rax
	mov	rax, QWORD PTR [rax]
	call	rax
	test	eax, eax
	je	SHORT $LN52@stbi__pnm_

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

	cmp	DWORD PTR [rdi], 0
	je	$LL2@stbi__pnm_
$LN50@stbi__pnm_:

; 7554 :          break;
; 7555 : 
; 7556 :       while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )

	mov	rax, QWORD PTR [r15]

; 1635 :    return s->img_buffer >= s->img_buffer_end;

	lea	r14, QWORD PTR [rsi+32]

; 7554 :          break;
; 7555 : 
; 7556 :       while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )

	cmp	QWORD PTR [rbx], rax
	jae	$LL2@stbi__pnm_
$LN52@stbi__pnm_:
	movzx	eax, BYTE PTR [r13]
	cmp	al, 10
	je	$LL2@stbi__pnm_
	cmp	al, 13
	je	$LL2@stbi__pnm_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx]
	cmp	rax, QWORD PTR [r15]
	jae	SHORT $LN36@stbi__pnm_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx], rax

; 7557 :          *c = (char) stbi__get8(s);

	mov	BYTE PTR [r13], cl
	jmp	SHORT $LL7@stbi__pnm_
$LN36@stbi__pnm_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rdi], 0
	je	SHORT $LN37@stbi__pnm_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rsi
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx], rax

; 7557 :          *c = (char) stbi__get8(s);

	mov	BYTE PTR [r13], cl
	jmp	SHORT $LL7@stbi__pnm_
$LN37@stbi__pnm_:

; 1620 :    return 0;

	xor	cl, cl

; 7557 :          *c = (char) stbi__get8(s);

	mov	BYTE PTR [r13], cl
	jmp	$LL7@stbi__pnm_
$LN59@stbi__pnm_:

; 7558 :    }
; 7559 : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z ENDP ; stbi__pnm_skip_whitespace
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__pnm_isdigit@@YAHD@Z
_TEXT	SEGMENT
c$ = 8
?stbi__pnm_isdigit@@YAHD@Z PROC				; stbi__pnm_isdigit, COMDAT

; 7563 :    return c >= '0' && c <= '9';

	xor	eax, eax
	sub	cl, 48					; 00000030H
	cmp	cl, 9
	setbe	al

; 7564 : }

	ret	0
?stbi__pnm_isdigit@@YAHD@Z ENDP				; stbi__pnm_isdigit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z
_TEXT	SEGMENT
s$ = 64
c$ = 72
?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z PROC ; stbi__pnm_getinteger, COMDAT

; 7567 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 7568 :    int value = 0;

	lea	rdi, QWORD PTR [rcx+192]
	mov	r12, rdx
	mov	rbp, rdi
	lea	r14, QWORD PTR [rcx+200]
	mov	rbx, rcx
	xor	esi, esi
$LL2@stbi__pnm_:

; 1628 :    if (s->io.read) {

	cmp	QWORD PTR [rbx+16], 0
	je	SHORT $LN27@stbi__pnm_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	rax, QWORD PTR [rbx+32]
	mov	rcx, QWORD PTR [rbx+40]
	call	rax
	test	eax, eax
	je	SHORT $LN29@stbi__pnm_

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

	cmp	DWORD PTR [rbx+48], 0
	lea	r14, QWORD PTR [rbx+200]
	mov	rbp, rdi
	je	$LN3@stbi__pnm_
$LN27@stbi__pnm_:

; 7569 : 
; 7570 :    while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {

	mov	rax, QWORD PTR [r14]
	cmp	QWORD PTR [rbp], rax
	jae	$LN3@stbi__pnm_
$LN29@stbi__pnm_:
	movsx	edx, BYTE PTR [r12]

; 7563 :    return c >= '0' && c <= '9';

	lea	eax, DWORD PTR [rdx-48]
	cmp	al, 9
	ja	$LN3@stbi__pnm_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rdi]

; 7571 :       value = value*10 + (*c - '0');

	lea	esi, DWORD PTR [rsi+rsi*4]
	lea	esi, DWORD PTR [rsi-24]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rbp, rdi

; 7571 :       value = value*10 + (*c - '0');

	lea	esi, DWORD PTR [rdx+rsi*2]

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	lea	r14, QWORD PTR [rbx+200]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN17@stbi__pnm_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi], rax
	jmp	SHORT $LN16@stbi__pnm_
$LN17@stbi__pnm_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN18@stbi__pnm_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rdi]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdi], rax
	jmp	SHORT $LN16@stbi__pnm_
$LN18@stbi__pnm_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN16@stbi__pnm_:

; 7572 :       *c = (char) stbi__get8(s);

	mov	BYTE PTR [r12], cl

; 7573 :       if((value > 214748364) || (value == 214748364 && *c > '7'))

	cmp	esi, 214748364				; 0cccccccH
	jg	SHORT $LN23@stbi__pnm_
	jne	$LL2@stbi__pnm_
	cmp	cl, 55					; 00000037H
	jle	$LL2@stbi__pnm_
$LN23@stbi__pnm_:

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BH@OBINMOBC@integer?5parse?5overflow@
	mov	QWORD PTR [rdx+rcx], rax

; 7574 :           return stbi__err("integer parse overflow", "Parsing an integer in the PPM header overflowed a 32-bit int");

	xor	eax, eax
	jmp	SHORT $LN1@stbi__pnm_
$LN3@stbi__pnm_:

; 7575 :    }
; 7576 : 
; 7577 :    return value;

	mov	eax, esi
$LN1@stbi__pnm_:

; 7578 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z ENDP ; stbi__pnm_getinteger
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
;	COMDAT ?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z
_TEXT	SEGMENT
c$ = 32
dummy$ = 36
__$ArrayPad$ = 40
s$ = 112
x$ = 120
y$ = 128
comp$ = 136
?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__pnm_info, COMDAT

; 7581 : {

	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 7582 :    int maxv, dummy;
; 7583 :    char c, p, t;
; 7584 : 
; 7585 :    if (!x) x = &dummy;
; 7586 :    if (!y) y = &dummy;

	test	rdx, rdx
	lea	rbp, QWORD PTR dummy$[rsp]
	mov	rbx, rcx

; 7587 :    if (!comp) comp = &dummy;

	lea	r15, QWORD PTR dummy$[rsp]

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	rcx, QWORD PTR [rcx+208]
	lea	r14, QWORD PTR dummy$[rsp]

; 7582 :    int maxv, dummy;
; 7583 :    char c, p, t;
; 7584 : 
; 7585 :    if (!x) x = &dummy;
; 7586 :    if (!y) y = &dummy;

	cmovne	rbp, rdx

; 7587 :    if (!comp) comp = &dummy;

	test	r8, r8

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	rax, QWORD PTR [rbx+216]

; 7587 :    if (!comp) comp = &dummy;

	cmovne	r15, r8

; 889  :    s->img_buffer = s->img_buffer_original;

	test	r9, r9
	mov	QWORD PTR [rbx+192], rcx

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	QWORD PTR [rbx+200], rax
	cmovne	r14, r9

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	cmp	rcx, rax
	jae	SHORT $LN17@stbi__pnm_

; 1615 :       return *s->img_buffer++;

	movzx	edi, BYTE PTR [rcx]
	inc	rcx
	mov	QWORD PTR [rbx+192], rcx
	jmp	SHORT $LN48@stbi__pnm_
$LN17@stbi__pnm_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rbx+48], 0
	je	SHORT $LN18@stbi__pnm_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edi, BYTE PTR [rax]
	lea	rcx, QWORD PTR [rax+1]
	mov	QWORD PTR [rbx+192], rcx
	jmp	SHORT $LN48@stbi__pnm_
$LN18@stbi__pnm_:

; 1619 :    }
; 1620 :    return 0;

	xor	dil, dil
$LN48@stbi__pnm_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	eax, 48					; 00000030H
	mov	rdx, rbx
	lea	rsi, QWORD PTR [rax+rbx]
	cmp	rcx, QWORD PTR [rbx+200]
	jae	SHORT $LN21@stbi__pnm_

; 1615 :       return *s->img_buffer++;

	movzx	edx, BYTE PTR [rcx]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN20@stbi__pnm_
$LN21@stbi__pnm_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rsi], 0
	je	SHORT $LN22@stbi__pnm_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN20@stbi__pnm_
$LN22@stbi__pnm_:

; 1619 :    }
; 1620 :    return 0;

	xor	dl, dl
$LN20@stbi__pnm_:

; 7588 : 
; 7589 :    stbi__rewind(s);
; 7590 : 
; 7591 :    // Get identifier
; 7592 :    p = (char) stbi__get8(s);
; 7593 :    t = (char) stbi__get8(s);
; 7594 :    if (p != 'P' || (t != '5' && t != '6')) {

	cmp	dil, 80					; 00000050H
	jne	$LN6@stbi__pnm_
	lea	eax, DWORD PTR [rdx-53]
	cmp	al, 1
	ja	$LN6@stbi__pnm_

; 7595 :        stbi__rewind(s);
; 7596 :        return 0;
; 7597 :    }
; 7598 : 
; 7599 :    *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

	cmp	dl, 54					; 00000036H
	mov	eax, 1
	mov	ecx, 3
	cmove	eax, ecx
	mov	DWORD PTR [r14], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
	jae	SHORT $LN27@stbi__pnm_

; 1615 :       return *s->img_buffer++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN26@stbi__pnm_
$LN27@stbi__pnm_:

; 1616 :    if (s->read_from_callbacks) {

	cmp	DWORD PTR [rsi], 0
	je	SHORT $LN28@stbi__pnm_

; 1617 :       stbi__refill_buffer(s);

	mov	rcx, rbx
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

	mov	rax, QWORD PTR [rbx+192]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx+192], rax
	jmp	SHORT $LN26@stbi__pnm_
$LN28@stbi__pnm_:

; 1619 :    }
; 1620 :    return 0;

	xor	cl, cl
$LN26@stbi__pnm_:

; 7600 : 
; 7601 :    c = (char) stbi__get8(s);

	mov	BYTE PTR c$[rsp], cl

; 7602 :    stbi__pnm_skip_whitespace(s, &c);

	lea	rdx, QWORD PTR c$[rsp]
	mov	rcx, rbx
	call	?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z ; stbi__pnm_skip_whitespace

; 7603 : 
; 7604 :    *x = stbi__pnm_getinteger(s, &c); // read width

	lea	rdx, QWORD PTR c$[rsp]
	mov	rcx, rbx
	call	?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z ; stbi__pnm_getinteger
	mov	DWORD PTR [rbp], eax

; 7605 :    if(*x == 0)

	test	eax, eax
	jne	SHORT $LN7@stbi__pnm_
$LN50@stbi__pnm_:

; 7618 :       return 16;
; 7619 :    else
; 7620 :       return 8;
; 7621 : }

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0O@MKGNGALN@invalid?5width@
	mov	QWORD PTR [rdx+rcx], rax
	jmp	$LN49@stbi__pnm_
$LN7@stbi__pnm_:

; 7606 :        return stbi__err("invalid width", "PPM image header had zero or overflowing width");
; 7607 :    stbi__pnm_skip_whitespace(s, &c);

	lea	rdx, QWORD PTR c$[rsp]
	mov	rcx, rbx
	call	?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z ; stbi__pnm_skip_whitespace

; 7608 : 
; 7609 :    *y = stbi__pnm_getinteger(s, &c); // read height

	lea	rdx, QWORD PTR c$[rsp]
	mov	rcx, rbx
	call	?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z ; stbi__pnm_getinteger
	mov	DWORD PTR [r15], eax

; 7610 :    if (*y == 0)

	test	eax, eax
	je	SHORT $LN50@stbi__pnm_

; 7611 :        return stbi__err("invalid width", "PPM image header had zero or overflowing width");
; 7612 :    stbi__pnm_skip_whitespace(s, &c);

	lea	rdx, QWORD PTR c$[rsp]
	mov	rcx, rbx
	call	?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z ; stbi__pnm_skip_whitespace

; 7613 : 
; 7614 :    maxv = stbi__pnm_getinteger(s, &c);  // read max value

	lea	rdx, QWORD PTR c$[rsp]
	mov	rcx, rbx
	call	?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z ; stbi__pnm_getinteger
	mov	ecx, eax

; 7615 :    if (maxv > 65535)

	cmp	eax, 65535				; 0000ffffH
	jle	SHORT $LN9@stbi__pnm_

; 978  :    stbi__g_failure_reason = str;

	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
	mov	rcx, QWORD PTR [rax]
	lea	rax, OFFSET FLAT:??_C@_0BC@CNFMOKHC@max?5value?5?$DO?565535@
	mov	QWORD PTR [rdx+rcx], rax

; 7616 :       return stbi__err("max value > 65535", "PPM image supports only 8-bit and 16-bit images");

	jmp	SHORT $LN49@stbi__pnm_
$LN9@stbi__pnm_:

; 7617 :    else if (maxv > 255)

	cmp	ecx, 255				; 000000ffH
	mov	eax, 8
	mov	edx, 16
	cmovg	eax, edx
	jmp	SHORT $LN12@stbi__pnm_
$LN6@stbi__pnm_:

; 889  :    s->img_buffer = s->img_buffer_original;

	mov	rax, QWORD PTR [rbx+208]
	mov	QWORD PTR [rbx+192], rax

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

	mov	rax, QWORD PTR [rbx+216]
	mov	QWORD PTR [rbx+200], rax
$LN49@stbi__pnm_:

; 7618 :       return 16;
; 7619 :    else
; 7620 :       return 8;
; 7621 : }

	xor	eax, eax
$LN12@stbi__pnm_:
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__pnm_info
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image_write.h
;	COMDAT ?stbi__stdio_write@@YAXPEAX0H@Z
_TEXT	SEGMENT
context$ = 8
data$ = 16
size$ = 24
?stbi__stdio_write@@YAXPEAX0H@Z PROC			; stbi__stdio_write, COMDAT

; 286  : {

	mov	rax, rdx

; 287  :    fwrite(data,1,size,(FILE*) context);

	movsxd	r8, r8d
	mov	r9, rcx
	mov	edx, 1
	mov	rcx, rax
	rex_jmp	QWORD PTR __imp_fwrite
?stbi__stdio_write@@YAXPEAX0H@Z ENDP			; stbi__stdio_write
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image_write.h
;	COMDAT ?stbiw__sbgrowf@@YAPEAXPEAPEAXHH@Z
_TEXT	SEGMENT
arr$ = 48
increment$dead$ = 56
itemsize$ = 64
?stbiw__sbgrowf@@YAPEAXPEAPEAXHH@Z PROC			; stbiw__sbgrowf, COMDAT

; 828  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	mov	rcx, QWORD PTR [rcx]
	lea	r9, QWORD PTR [rcx-8]
	test	rcx, rcx
	je	SHORT $LN5@stbiw__sbg
	mov	eax, DWORD PTR [r9]
	lea	edi, DWORD PTR [rax*2+1]
	jmp	SHORT $LN6@stbiw__sbg
$LN5@stbiw__sbg:
	mov	edi, 2
$LN6@stbiw__sbg:

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	mov	eax, edi
	imul	eax, r8d
	movsxd	rdx, eax
	mov	rax, -1
	add	rdx, 8
	cmovb	rdx, rax
	xor	esi, esi
	test	rcx, rcx
	cmove	r9, rsi
	mov	rcx, r9
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN9@stbiw__sbg

; 833  :       if (!*arr) ((int *) p)[1] = 0;

	cmp	QWORD PTR [rbx], rsi
	jne	SHORT $LN3@stbiw__sbg
	mov	DWORD PTR [rax+4], esi
$LN3@stbiw__sbg:

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rbx], rcx

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], edi
$LN9@stbiw__sbg:

; 836  :    }
; 837  :    return *arr;
; 838  : }

	mov	rax, QWORD PTR [rbx]
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stbiw__sbgrowf@@YAPEAXPEAPEAXHH@Z ENDP			; stbiw__sbgrowf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image_write.h
;	COMDAT ?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z
_TEXT	SEGMENT
data$ = 96
bitbuffer$ = 104
bitcount$ = 112
?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z PROC		; stbiw__zlib_flushf, COMDAT

; 841  : {

	push	rbx
	push	rsi
	push	r15
	sub	rsp, 64					; 00000040H

; 842  :    while (*bitcount >= 8) {

	cmp	DWORD PTR [r8], 8
	mov	rsi, r8
	mov	r15, rdx
	mov	rbx, rcx
	jl	$LN20@stbiw__zli
	mov	QWORD PTR [rsp+56], rbp
	xor	ebp, ebp
	mov	QWORD PTR [rsp+40], r12
	mov	QWORD PTR [rsp+32], r14
	lea	r14, QWORD PTR [rcx-8]
	mov	QWORD PTR [rsp+48], rdi
	lea	r12, QWORD PTR [rbp-1]
	npad	6
$LL2@stbiw__zli:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	test	rbx, rbx
	je	SHORT $LN11@stbiw__zli
	mov	eax, DWORD PTR [rbx-4]
	mov	edi, DWORD PTR [r14]
	inc	eax
	cmp	eax, edi
	jl	SHORT $LN8@stbiw__zli

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	edi, DWORD PTR [rdi*2+1]
	jmp	SHORT $LN12@stbiw__zli
$LN11@stbiw__zli:
	mov	edi, 2
$LN12@stbiw__zli:

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, edi
	mov	rcx, r14
	add	rdx, 8
	cmovb	rdx, r12
	test	rbx, rbx
	cmove	rcx, rbp
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN8@stbiw__zli

; 833  :       if (!*arr) ((int *) p)[1] = 0;

	test	rbx, rbx
	jne	SHORT $LN9@stbiw__zli
	mov	DWORD PTR [rax+4], ebp
$LN9@stbiw__zli:

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], edi
	mov	r14, rax
$LN8@stbiw__zli:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	movsxd	rdx, DWORD PTR [rbx-4]
	movzx	ecx, BYTE PTR [r15]
	mov	BYTE PTR [rdx+rbx], cl
	inc	DWORD PTR [rbx-4]

; 844  :       *bitbuffer >>= 8;

	shr	DWORD PTR [r15], 8

; 845  :       *bitcount -= 8;

	add	DWORD PTR [rsi], -8
	cmp	DWORD PTR [rsi], 8
	jge	SHORT $LL2@stbiw__zli

; 842  :    while (*bitcount >= 8) {

	mov	r14, QWORD PTR [rsp+32]
	mov	r12, QWORD PTR [rsp+40]
	mov	rdi, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
$LN20@stbiw__zli:

; 846  :    }
; 847  :    return data;
; 848  : }

	mov	rax, rbx
	add	rsp, 64					; 00000040H
	pop	r15
	pop	rsi
	pop	rbx
	ret	0
?stbiw__zlib_flushf@@YAPEAEPEAEPEAIPEAH@Z ENDP		; stbiw__zlib_flushf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image_write.h
;	COMDAT ?stbiw__zlib_bitrev@@YAHHH@Z
_TEXT	SEGMENT
code$ = 8
codebits$ = 16
?stbiw__zlib_bitrev@@YAHHH@Z PROC			; stbiw__zlib_bitrev, COMDAT

; 852  :    int res=0;

	xor	eax, eax
$LL2@stbiw__zli:

; 853  :    while (codebits--) {
; 854  :       res = (res << 1) | (code & 1);

	mov	r8d, ecx
	add	eax, eax
	and	r8d, 1

; 855  :       code >>= 1;

	sar	ecx, 1
	or	eax, r8d
	sub	edx, 1
	jne	SHORT $LL2@stbiw__zli

; 856  :    }
; 857  :    return res;
; 858  : }

	ret	0
?stbiw__zlib_bitrev@@YAHHH@Z ENDP			; stbiw__zlib_bitrev
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image_write.h
;	COMDAT ?stbiw__zlib_countm@@YAIPEAE0H@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
limit$ = 24
?stbiw__zlib_countm@@YAIPEAE0H@Z PROC			; stbiw__zlib_countm, COMDAT

; 862  :    int i;
; 863  :    for (i=0; i < limit && i < 258; ++i)

	xor	eax, eax
	movsxd	r9, r8d
	mov	r11, rdx
	mov	r10, rcx
	test	r8d, r8d
	jle	SHORT $LN13@stbiw__zli
	mov	r8d, eax
	sub	r10, rdx
$LL4@stbiw__zli:
	cmp	r8, 258					; 00000102H
	jge	SHORT $LN13@stbiw__zli

; 864  :       if (a[i] != b[i]) break;

	movzx	ecx, BYTE PTR [r8+r11]
	lea	rdx, QWORD PTR [r8+r11]
	cmp	BYTE PTR [r10+rdx], cl
	jne	SHORT $LN13@stbiw__zli

; 862  :    int i;
; 863  :    for (i=0; i < limit && i < 258; ++i)

	inc	eax
	inc	r8
	cmp	r8, r9
	jl	SHORT $LL4@stbiw__zli
$LN13@stbiw__zli:

; 865  :    return i;
; 866  : }

	ret	0
?stbiw__zlib_countm@@YAIPEAE0H@Z ENDP			; stbiw__zlib_countm
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image_write.h
;	COMDAT ?stbiw__zhash@@YAIPEAE@Z
_TEXT	SEGMENT
data$ = 8
?stbiw__zhash@@YAIPEAE@Z PROC				; stbiw__zhash, COMDAT

; 870  :    stbiw_uint32 hash = data[0] + (data[1] << 8) + (data[2] << 16);

	movzx	edx, BYTE PTR [rcx+2]
	movzx	eax, BYTE PTR [rcx+1]
	shl	eax, 8
	shl	edx, 16
	add	edx, eax
	movzx	eax, BYTE PTR [rcx]
	add	edx, eax

; 871  :    hash ^= hash << 3;

	lea	eax, DWORD PTR [rdx*8]
	xor	edx, eax

; 872  :    hash += hash >> 5;

	mov	eax, edx
	shr	eax, 5
	add	edx, eax

; 873  :    hash ^= hash << 4;

	mov	eax, edx
	shl	eax, 4
	xor	edx, eax

; 874  :    hash += hash >> 17;

	mov	eax, edx
	shr	eax, 17
	add	edx, eax

; 875  :    hash ^= hash << 25;

	mov	eax, edx
	shl	eax, 25
	xor	edx, eax

; 876  :    hash += hash >> 6;

	mov	eax, edx
	shr	eax, 6
	add	eax, edx

; 877  :    return hash;
; 878  : }

	ret	0
?stbiw__zhash@@YAIPEAE@Z ENDP				; stbiw__zhash
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image_write.h
;	COMDAT stbi_zlib_compress
_TEXT	SEGMENT
bitcount$1$ = 32
best$1$ = 36
i$1$ = 40
tv5800 = 40
data$GSCopy$1$ = 48
data_len$GSCopy$1$ = 56
bestloc$1$ = 64
hash_table$1$ = 72
tv5688 = 80
data$1$ = 88
tv5967 = 96
out_len$GSCopy$1$ = 104
data$ = 176
data_len$ = 184
out_len$ = 192
quality$dead$ = 200
stbi_zlib_compress PROC					; COMDAT

; 897  : {

$LN898:
	push	rbx
	push	rbp
	push	rsi
	push	r15
	sub	rsp, 136				; 00000088H
	mov	r15, rcx
	mov	QWORD PTR data$GSCopy$1$[rsp], rcx

; 898  : #ifdef STBIW_ZLIB_COMPRESS
; 899  :    // user provided a zlib compress implementation, use that
; 900  :    return STBIW_ZLIB_COMPRESS(data, data_len, out_len, quality);
; 901  : #else // use builtin
; 902  :    static unsigned short lengthc[] = { 3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258, 259 };
; 903  :    static unsigned char  lengtheb[]= { 0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0 };
; 904  :    static unsigned short distc[]   = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 32768 };
; 905  :    static unsigned char  disteb[]  = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13 };
; 906  :    unsigned int bitbuf=0;
; 907  :    int i,j, bitcount=0;
; 908  :    unsigned char *out = NULL;

	xor	ebp, ebp
	mov	QWORD PTR out_len$GSCopy$1$[rsp], r8

; 909  :    unsigned char ***hash_table = (unsigned char***) STBIW_MALLOC(stbiw__ZHASH * sizeof(unsigned char**));

	mov	ecx, 131072				; 00020000H
	mov	DWORD PTR data_len$GSCopy$1$[rsp], edx
	mov	ebx, ebp
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR hash_table$1$[rsp], rax
	mov	rsi, rax

; 910  :    if (hash_table == NULL)

	test	rax, rax
	jne	SHORT $LN508@stbi_zlib_

; 1022 : #endif // STBIW_ZLIB_COMPRESS
; 1023 : }

	add	rsp, 136				; 00000088H
	pop	r15
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN508@stbi_zlib_:
	mov	QWORD PTR [rsp+200], rdi

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	mov	edx, 10
	mov	QWORD PTR [rsp+128], r12
	xor	ecx, ecx
	mov	QWORD PTR [rsp+120], r13
	mov	QWORD PTR [rsp+112], r14
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN505@stbi_zlib_

; 835  :       stbiw__sbm(*arr) = m;

	mov	QWORD PTR [rax], 2
	lea	rbx, QWORD PTR [rax+8]
$LN505@stbi_zlib_:

; 911  :       return NULL;
; 912  :    if (quality < 5) quality = 5;
; 913  : 
; 914  :    stbiw__sbpush(out, 0x78);   // DEFLATE 32K window

	movsxd	rax, DWORD PTR [rbx-4]

; 915  :    stbiw__sbpush(out, 0x5e);   // FLEVEL = 1

	lea	rcx, QWORD PTR [rbx-8]
	mov	r8, -1
	mov	BYTE PTR [rax+rbx], 120			; 00000078H
	inc	DWORD PTR [rbx-4]
	mov	eax, DWORD PTR [rbx-4]
	mov	edx, DWORD PTR [rcx]
	inc	eax
	cmp	eax, edx
	jl	SHORT $LN497@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	eax, DWORD PTR [rdx+rdx]

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, eax
	lea	edi, DWORD PTR [rax+1]
	inc	rdx
	add	rdx, 8
	cmovb	rdx, r8
	test	rbx, rbx
	cmove	rcx, rbp
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN497@stbi_zlib_

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], edi
$LN497@stbi_zlib_:

; 915  :    stbiw__sbpush(out, 0x5e);   // FLEVEL = 1

	movsxd	rax, DWORD PTR [rbx-4]

; 916  :    stbiw__zlib_add(1,1);  // BFINAL = 1
; 917  :    stbiw__zlib_add(1,2);  // BTYPE = 1 -- fixed huffman

	mov	edi, 3
	xor	edx, edx
	mov	DWORD PTR bitcount$1$[rsp], edi
	mov	r8d, 131072				; 00020000H
	mov	rcx, rsi
	mov	r13d, edi
	mov	BYTE PTR [rax+rbx], 94			; 0000005eH
	inc	DWORD PTR [rbx-4]
	call	memset

; 918  : 
; 919  :    for (i=0; i < stbiw__ZHASH; ++i)
; 920  :       hash_table[i] = NULL;
; 921  : 
; 922  :    i=0;
; 923  :    while (i < data_len-3) {

	mov	r11d, DWORD PTR data_len$GSCopy$1$[rsp]
	mov	r9d, ebp
	mov	DWORD PTR i$1$[rsp], ebp
	lea	eax, DWORD PTR [r11-3]
	test	eax, eax
	jle	$LN6@stbi_zlib_
	lea	r8, QWORD PTR [rdi-7]
	jmp	SHORT $LN5@stbi_zlib_
$LL715@stbi_zlib_:
	mov	rsi, QWORD PTR hash_table$1$[rsp]
$LN5@stbi_zlib_:

; 924  :       // hash next 3 bytes of data to be compressed
; 925  :       int h = stbiw__zhash(data+i)&(stbiw__ZHASH-1), best=3;

	movsxd	rax, r9d

; 870  :    stbiw_uint32 hash = data[0] + (data[1] << 8) + (data[2] << 16);

	movzx	ecx, BYTE PTR [rax+r15+2]

; 924  :       // hash next 3 bytes of data to be compressed
; 925  :       int h = stbiw__zhash(data+i)&(stbiw__ZHASH-1), best=3;

	lea	rdx, QWORD PTR [rax+r15]
	mov	QWORD PTR tv5688[rsp], rax

; 926  :       unsigned char *bestloc = 0;

	mov	r15, rbp

; 870  :    stbiw_uint32 hash = data[0] + (data[1] << 8) + (data[2] << 16);

	movzx	eax, BYTE PTR [rdx+1]
	shl	eax, 8
	shl	ecx, 16
	add	ecx, eax

; 924  :       // hash next 3 bytes of data to be compressed
; 925  :       int h = stbiw__zhash(data+i)&(stbiw__ZHASH-1), best=3;

	mov	QWORD PTR data$1$[rsp], rdx

; 870  :    stbiw_uint32 hash = data[0] + (data[1] << 8) + (data[2] << 16);

	movzx	eax, BYTE PTR [rdx]
	add	ecx, eax

; 924  :       // hash next 3 bytes of data to be compressed
; 925  :       int h = stbiw__zhash(data+i)&(stbiw__ZHASH-1), best=3;

	mov	DWORD PTR best$1$[rsp], 3

; 926  :       unsigned char *bestloc = 0;

	mov	QWORD PTR bestloc$1$[rsp], rbp

; 871  :    hash ^= hash << 3;

	lea	eax, DWORD PTR [rcx*8]
	xor	ecx, eax

; 872  :    hash += hash >> 5;

	mov	eax, ecx
	shr	eax, 5
	add	ecx, eax

; 873  :    hash ^= hash << 4;

	mov	eax, ecx
	shl	eax, 4
	xor	ecx, eax

; 874  :    hash += hash >> 17;

	mov	eax, ecx
	shr	eax, 17
	add	ecx, eax

; 875  :    hash ^= hash << 25;

	mov	eax, ecx
	shl	eax, 25
	xor	ecx, eax

; 876  :    hash += hash >> 6;

	mov	eax, ecx
	shr	eax, 6
	add	eax, ecx

; 924  :       // hash next 3 bytes of data to be compressed
; 925  :       int h = stbiw__zhash(data+i)&(stbiw__ZHASH-1), best=3;

	and	eax, 16383				; 00003fffH

; 927  :       unsigned char **hlist = hash_table[h];

	mov	r14, QWORD PTR [rsi+rax*8]
	lea	r12, QWORD PTR [rsi+rax*8]
	mov	QWORD PTR tv5967[rsp], r12

; 928  :       int n = stbiw__sbcount(hlist);

	test	r14, r14
	je	SHORT $LN54@stbi_zlib_
	mov	eax, DWORD PTR [r14-4]
	jmp	SHORT $LN55@stbi_zlib_
$LN54@stbi_zlib_:
	mov	eax, ebp
$LN55@stbi_zlib_:

; 929  :       for (j=0; j < n; ++j) {

	test	r14, r14
	mov	rsi, rbp
	movsxd	rbp, eax
	lea	rax, QWORD PTR [r14-4]
	cmove	rax, r8
	test	rbp, rbp
	jle	$LN8@stbi_zlib_
	mov	r12, QWORD PTR tv5688[rsp]
	lea	eax, DWORD PTR [r9-32768]
	mov	rcx, QWORD PTR data$GSCopy$1$[rsp]
	xor	r13d, r13d
	movsxd	r15, eax
	npad	7
$LL9@stbi_zlib_:

; 930  :          if (hlist[j]-data > i-32768) { // if entry lies within window

	mov	r10, QWORD PTR [r14+rsi*8]
	mov	rax, r10
	sub	rax, rcx
	cmp	rax, r15
	jle	SHORT $LN7@stbi_zlib_

; 931  :             int d = stbiw__zlib_countm(hlist[j], data+i, data_len-i);

	mov	eax, r11d

; 863  :    for (i=0; i < limit && i < 258; ++i)

	mov	r8d, r13d

; 931  :             int d = stbiw__zlib_countm(hlist[j], data+i, data_len-i);

	sub	eax, r9d

; 863  :    for (i=0; i < limit && i < 258; ++i)

	mov	rdx, r13
	test	eax, eax
	jle	SHORT $LN551@stbi_zlib_
	mov	r9, r12
	movsxd	r11, eax
	sub	r9, r10
	add	r9, rcx
	npad	5
$LL387@stbi_zlib_:
	cmp	rdx, 258				; 00000102H
	jge	SHORT $LN712@stbi_zlib_

; 864  :       if (a[i] != b[i]) break;

	lea	rcx, QWORD PTR [rdx+r10]
	movzx	eax, BYTE PTR [r9+rcx]
	cmp	BYTE PTR [rcx], al
	jne	SHORT $LN712@stbi_zlib_

; 856  :    }
; 857  :    return res;
; 858  : }
; 859  : 
; 860  : static unsigned int stbiw__zlib_countm(unsigned char *a, unsigned char *b, int limit)
; 861  : {
; 862  :    int i;
; 863  :    for (i=0; i < limit && i < 258; ++i)

	inc	r8d
	inc	rdx
	cmp	rdx, r11
	jl	SHORT $LL387@stbi_zlib_
$LN712@stbi_zlib_:
	mov	r9d, DWORD PTR i$1$[rsp]
	mov	rcx, QWORD PTR data$GSCopy$1$[rsp]
	mov	r11d, DWORD PTR data_len$GSCopy$1$[rsp]
$LN551@stbi_zlib_:

; 932  :             if (d >= best) { best=d; bestloc=hlist[j]; }

	cmp	r8d, DWORD PTR best$1$[rsp]
	jl	SHORT $LN7@stbi_zlib_
	mov	DWORD PTR best$1$[rsp], r8d
	mov	QWORD PTR bestloc$1$[rsp], r10
$LN7@stbi_zlib_:

; 929  :       for (j=0; j < n; ++j) {

	inc	rsi
	cmp	rsi, rbp
	jl	SHORT $LL9@stbi_zlib_
	mov	r12, QWORD PTR tv5967[rsp]
	lea	rax, QWORD PTR [r14-4]
	mov	r13d, DWORD PTR bitcount$1$[rsp]
	mov	r15, QWORD PTR bestloc$1$[rsp]
$LN8@stbi_zlib_:

; 933  :          }
; 934  :       }
; 935  :       // when hash table entry is too long, delete half the entries
; 936  :       if (hash_table[h] && stbiw__sbn(hash_table[h]) == 2*quality) {

	test	r14, r14
	je	SHORT $LN39@stbi_zlib_
	cmp	DWORD PTR [rax], 16
	jne	SHORT $LN39@stbi_zlib_

; 937  :          STBIW_MEMMOVE(hash_table[h], hash_table[h]+quality, sizeof(hash_table[h][0])*quality);

	lea	rdx, QWORD PTR [r14+64]
	mov	r8d, 64					; 00000040H
	mov	rcx, r14
	call	memmove

; 938  :          stbiw__sbn(hash_table[h]) = quality;

	mov	rax, QWORD PTR [r12]
	mov	DWORD PTR [rax-4], 8
$LN39@stbi_zlib_:

; 939  :       }
; 940  :       stbiw__sbpush(hash_table[h],data+i);

	mov	r9, QWORD PTR [r12]
	lea	r8, QWORD PTR [r9-8]
	test	r9, r9
	je	SHORT $LN709@stbi_zlib_
	mov	eax, DWORD PTR [r9-4]
	inc	eax
	cmp	eax, DWORD PTR [r8]
	jl	SHORT $LN343@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	mov	eax, DWORD PTR [r8]
	lea	ebp, DWORD PTR [rax*2+1]
	jmp	SHORT $LN892@stbi_zlib_
$LN709@stbi_zlib_:
	mov	ebp, 2
$LN892@stbi_zlib_:

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	lea	eax, DWORD PTR [rbp*8]
	mov	rsi, r12
	movsxd	rdx, eax
	mov	rax, -1
	add	rdx, 8
	cmovb	rdx, rax
	xor	r14d, r14d
	test	r9, r9
	mov	ecx, r14d
	cmovne	rcx, r8
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN343@stbi_zlib_

; 833  :       if (!*arr) ((int *) p)[1] = 0;

	cmp	QWORD PTR [r12], r14
	jne	SHORT $LN344@stbi_zlib_
	mov	DWORD PTR [rax+4], r14d
$LN344@stbi_zlib_:

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rsi], rcx

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], ebp
$LN343@stbi_zlib_:

; 939  :       }
; 940  :       stbiw__sbpush(hash_table[h],data+i);

	mov	rcx, QWORD PTR [r12]
	mov	rdx, QWORD PTR data$1$[rsp]
	movsxd	rax, DWORD PTR [rcx-4]
	mov	QWORD PTR [rcx+rax*8], rdx
	mov	rax, QWORD PTR [r12]
	inc	DWORD PTR [rax-4]

; 941  : 
; 942  :       if (bestloc) {

	test	r15, r15
	je	$LN43@stbi_zlib_

; 870  :    stbiw_uint32 hash = data[0] + (data[1] << 8) + (data[2] << 16);

	movzx	eax, BYTE PTR [rdx+2]

; 946  :          n = stbiw__sbcount(hlist);

	xor	r10d, r10d

; 870  :    stbiw_uint32 hash = data[0] + (data[1] << 8) + (data[2] << 16);

	movzx	ecx, BYTE PTR [rdx+3]

; 945  :          hlist = hash_table[h];

	mov	r14, QWORD PTR hash_table$1$[rsp]

; 870  :    stbiw_uint32 hash = data[0] + (data[1] << 8) + (data[2] << 16);

	shl	eax, 8
	shl	ecx, 16
	add	ecx, eax
	movzx	eax, BYTE PTR [rdx+1]
	add	ecx, eax

; 871  :    hash ^= hash << 3;

	lea	eax, DWORD PTR [rcx*8]
	xor	ecx, eax

; 872  :    hash += hash >> 5;

	mov	eax, ecx
	shr	eax, 5
	add	ecx, eax

; 873  :    hash ^= hash << 4;

	mov	eax, ecx
	shl	eax, 4
	xor	ecx, eax

; 874  :    hash += hash >> 17;

	mov	eax, ecx
	shr	eax, 17
	add	ecx, eax

; 875  :    hash ^= hash << 25;

	mov	eax, ecx
	shl	eax, 25
	xor	ecx, eax

; 876  :    hash += hash >> 6;

	mov	eax, ecx
	shr	eax, 6
	add	eax, ecx

; 943  :          // "lazy matching" - check match at *next* byte, and if it's better, do cur byte as literal
; 944  :          h = stbiw__zhash(data+i+1)&(stbiw__ZHASH-1);

	and	eax, 16383				; 00003fffH

; 945  :          hlist = hash_table[h];

	mov	r14, QWORD PTR [r14+rax*8]

; 946  :          n = stbiw__sbcount(hlist);

	test	r14, r14
	je	SHORT $LN58@stbi_zlib_
	mov	eax, DWORD PTR [r14-4]
	jmp	SHORT $LN59@stbi_zlib_
$LN58@stbi_zlib_:
	mov	eax, r10d
$LN59@stbi_zlib_:

; 947  :          for (j=0; j < n; ++j) {

	movsxd	rbp, eax
	mov	rsi, r10
	test	eax, eax
	jle	$LN710@stbi_zlib_
	mov	ecx, DWORD PTR i$1$[rsp]
	mov	r12, QWORD PTR tv5688[rsp]
	mov	r11, QWORD PTR data$GSCopy$1$[rsp]
	lea	eax, DWORD PTR [rcx-32767]
	movsxd	r15, eax
	npad	6
$LL12@stbi_zlib_:

; 948  :             if (hlist[j]-data > i-32767) {

	mov	r9, QWORD PTR [r14+rsi*8]
	mov	rax, r9
	sub	rax, r11
	cmp	rax, r15
	jle	SHORT $LN10@stbi_zlib_

; 863  :    for (i=0; i < limit && i < 258; ++i)

	mov	eax, DWORD PTR data_len$GSCopy$1$[rsp]
	mov	r8d, r10d
	sub	eax, ecx
	mov	rdx, r10

; 949  :                int e = stbiw__zlib_countm(hlist[j], data+i+1, data_len-i-1);

	dec	eax

; 863  :    for (i=0; i < limit && i < 258; ++i)

	test	eax, eax
	jle	SHORT $LN552@stbi_zlib_
	movsxd	r10, eax
	mov	rax, r12
	sub	rax, r9
	add	r11, rax
	npad	3
$LL267@stbi_zlib_:
	cmp	rdx, 258				; 00000102H
	jge	SHORT $LN713@stbi_zlib_

; 864  :       if (a[i] != b[i]) break;

	lea	rcx, QWORD PTR [rdx+r9]
	movzx	eax, BYTE PTR [r11+rcx+1]
	cmp	BYTE PTR [rcx], al
	jne	SHORT $LN713@stbi_zlib_

; 856  :    }
; 857  :    return res;
; 858  : }
; 859  : 
; 860  : static unsigned int stbiw__zlib_countm(unsigned char *a, unsigned char *b, int limit)
; 861  : {
; 862  :    int i;
; 863  :    for (i=0; i < limit && i < 258; ++i)

	inc	r8d
	inc	rdx
	cmp	rdx, r10
	jl	SHORT $LL267@stbi_zlib_
$LN713@stbi_zlib_:
	mov	ecx, DWORD PTR i$1$[rsp]
	xor	r10d, r10d
	mov	r11, QWORD PTR data$GSCopy$1$[rsp]
$LN552@stbi_zlib_:

; 950  :                if (e > best) { // if next match is better, bail on current match

	cmp	r8d, DWORD PTR best$1$[rsp]
	jg	$LN714@stbi_zlib_
$LN10@stbi_zlib_:

; 947  :          for (j=0; j < n; ++j) {

	inc	rsi
	cmp	rsi, rbp
	jl	SHORT $LL12@stbi_zlib_
	mov	r15, QWORD PTR bestloc$1$[rsp]
$LN710@stbi_zlib_:

; 951  :                   bestloc = NULL;
; 952  :                   break;
; 953  :                }
; 954  :             }
; 955  :          }
; 956  :       }
; 957  : 
; 958  :       if (bestloc) {
; 959  :          int d = (int) (data+i - bestloc); // distance back

	mov	r12d, DWORD PTR data$GSCopy$1$[rsp]

; 960  :          STBIW_ASSERT(d <= 32767 && best <= 258);
; 961  :          for (j=0; best > lengthc[j+1]-1; ++j);

	mov	ecx, r10d
	sub	r12d, r15d
	mov	r14, r10
	add	r12d, DWORD PTR i$1$[rsp]
	mov	r15d, DWORD PTR best$1$[rsp]
	cmp	r15d, 3
	jle	SHORT $LN14@stbi_zlib_
	lea	rdx, OFFSET FLAT:__ImageBase
	npad	5
$LL15@stbi_zlib_:
	movzx	eax, WORD PTR ?lengthc@?1??stbi_zlib_compress@@9@4PAGA[rdx+r14*2+4]
	inc	r14
	dec	eax
	inc	ecx
	cmp	r15d, eax
	jg	SHORT $LL15@stbi_zlib_
$LN14@stbi_zlib_:

; 962  :          stbiw__zlib_huff(j+257);

	lea	eax, DWORD PTR [rcx+257]
	mov	edx, r10d
	cmp	eax, 143				; 0000008fH
	jg	$LN64@stbi_zlib_
	add	ecx, 305				; 00000131H
	mov	r8d, 8
$LL215@stbi_zlib_:

; 854  :       res = (res << 1) | (code & 1);

	mov	eax, ecx
	add	edx, edx
	and	eax, 1

; 855  :       code >>= 1;

	sar	ecx, 1
	or	edx, eax
	sub	r8d, 1
	jne	SHORT $LL215@stbi_zlib_

; 962  :          stbiw__zlib_huff(j+257);

	mov	ecx, r13d
	add	r13d, 8
	shl	edx, cl
	or	edi, edx

; 842  :    while (*bitcount >= 8) {

	cmp	r13d, 8
	jl	$LN294@stbi_zlib_

; 962  :          stbiw__zlib_huff(j+257);

	mov	ebp, r13d
	mov	r15, -1
	shr	rbp, 3
	mov	eax, ebp
	neg	eax
	lea	r13d, DWORD PTR [r13+rax*8]
$LL219@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	lea	rcx, QWORD PTR [rbx-8]
	test	rbx, rbx
	je	SHORT $LN228@stbi_zlib_
	mov	eax, DWORD PTR [rbx-4]
	mov	esi, DWORD PTR [rcx]
	inc	eax
	cmp	eax, esi
	jl	SHORT $LN225@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	esi, DWORD PTR [rsi*2+1]
	jmp	SHORT $LN229@stbi_zlib_
$LN228@stbi_zlib_:
	mov	esi, 2
$LN229@stbi_zlib_:

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, esi
	add	rdx, 8
	cmovb	rdx, r15
	test	rbx, rbx
	cmove	rcx, r10
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	xor	r10d, r10d
	test	rax, rax
	je	SHORT $LN225@stbi_zlib_

; 833  :       if (!*arr) ((int *) p)[1] = 0;

	test	rbx, rbx
	jne	SHORT $LN226@stbi_zlib_
	mov	DWORD PTR [rax+4], r10d
$LN226@stbi_zlib_:

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], esi
$LN225@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	movsxd	rax, DWORD PTR [rbx-4]
	mov	BYTE PTR [rax+rbx], dil
	inc	DWORD PTR [rbx-4]

; 844  :       *bitbuffer >>= 8;

	shr	edi, 8
	sub	rbp, 1
	jne	SHORT $LL219@stbi_zlib_

; 962  :          stbiw__zlib_huff(j+257);

	jmp	$LN893@stbi_zlib_
$LN64@stbi_zlib_:
	cmp	eax, 255				; 000000ffH
	jg	$LN62@stbi_zlib_
	add	ecx, 513				; 00000201H
	mov	r8d, 9
$LL247@stbi_zlib_:

; 854  :       res = (res << 1) | (code & 1);

	mov	eax, ecx
	add	edx, edx
	and	eax, 1

; 855  :       code >>= 1;

	sar	ecx, 1
	or	edx, eax
	sub	r8d, 1
	jne	SHORT $LL247@stbi_zlib_

; 962  :          stbiw__zlib_huff(j+257);

	mov	ecx, r13d
	add	r13d, 9
	shl	edx, cl
	or	edi, edx

; 842  :    while (*bitcount >= 8) {

	cmp	r13d, 8
	jl	$LN294@stbi_zlib_

; 962  :          stbiw__zlib_huff(j+257);

	mov	ebp, r13d
	mov	r15, -1
	shr	rbp, 3
	mov	eax, ebp
	neg	eax
	lea	r13d, DWORD PTR [r13+rax*8]
$LL251@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	lea	rcx, QWORD PTR [rbx-8]
	test	rbx, rbx
	je	SHORT $LN260@stbi_zlib_
	mov	eax, DWORD PTR [rbx-4]
	mov	esi, DWORD PTR [rcx]
	inc	eax
	cmp	eax, esi
	jl	SHORT $LN257@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	esi, DWORD PTR [rsi*2+1]
	jmp	SHORT $LN261@stbi_zlib_
$LN260@stbi_zlib_:
	mov	esi, 2
$LN261@stbi_zlib_:

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, esi
	add	rdx, 8
	cmovb	rdx, r15
	test	rbx, rbx
	cmove	rcx, r10
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	xor	r10d, r10d
	test	rax, rax
	je	SHORT $LN257@stbi_zlib_

; 833  :       if (!*arr) ((int *) p)[1] = 0;

	test	rbx, rbx
	jne	SHORT $LN258@stbi_zlib_
	mov	DWORD PTR [rax+4], r10d
$LN258@stbi_zlib_:

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], esi
$LN257@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	movsxd	rax, DWORD PTR [rbx-4]
	mov	BYTE PTR [rax+rbx], dil
	inc	DWORD PTR [rbx-4]

; 844  :       *bitbuffer >>= 8;

	shr	edi, 8
	sub	rbp, 1
	jne	SHORT $LL251@stbi_zlib_

; 962  :          stbiw__zlib_huff(j+257);

	jmp	$LN893@stbi_zlib_
$LN62@stbi_zlib_:
	cmp	eax, 279				; 00000117H
	jg	$LN60@stbi_zlib_
	inc	ecx
	mov	r8d, 7
	npad	3
$LL271@stbi_zlib_:

; 854  :       res = (res << 1) | (code & 1);

	mov	eax, ecx
	add	edx, edx
	and	eax, 1

; 855  :       code >>= 1;

	sar	ecx, 1
	or	edx, eax
	sub	r8d, 1
	jne	SHORT $LL271@stbi_zlib_

; 962  :          stbiw__zlib_huff(j+257);

	mov	ecx, r13d
	add	r13d, 7
	shl	edx, cl
	or	edi, edx

; 842  :    while (*bitcount >= 8) {

	cmp	r13d, 8
	jl	$LN294@stbi_zlib_

; 962  :          stbiw__zlib_huff(j+257);

	mov	ebp, r13d
	mov	r15, -1
	shr	rbp, 3
	mov	eax, ebp
	neg	eax
	lea	r13d, DWORD PTR [r13+rax*8]
	npad	3
$LL275@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	lea	rcx, QWORD PTR [rbx-8]
	test	rbx, rbx
	je	SHORT $LN284@stbi_zlib_
	mov	eax, DWORD PTR [rbx-4]
	mov	esi, DWORD PTR [rcx]
	inc	eax
	cmp	eax, esi
	jl	SHORT $LN281@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	esi, DWORD PTR [rsi*2+1]
	jmp	SHORT $LN285@stbi_zlib_
$LN284@stbi_zlib_:
	mov	esi, 2
$LN285@stbi_zlib_:

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, esi
	add	rdx, 8
	cmovb	rdx, r15
	test	rbx, rbx
	cmove	rcx, r10
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	xor	r10d, r10d
	test	rax, rax
	je	SHORT $LN281@stbi_zlib_

; 833  :       if (!*arr) ((int *) p)[1] = 0;

	test	rbx, rbx
	jne	SHORT $LN282@stbi_zlib_
	mov	DWORD PTR [rax+4], r10d
$LN282@stbi_zlib_:

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], esi
$LN281@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	movsxd	rax, DWORD PTR [rbx-4]
	mov	BYTE PTR [rax+rbx], dil
	inc	DWORD PTR [rbx-4]

; 844  :       *bitbuffer >>= 8;

	shr	edi, 8
	sub	rbp, 1
	jne	SHORT $LL275@stbi_zlib_

; 962  :          stbiw__zlib_huff(j+257);

	jmp	$LN893@stbi_zlib_
$LN60@stbi_zlib_:
	add	ecx, 169				; 000000a9H
	mov	r8d, 8
	npad	10
$LL289@stbi_zlib_:

; 854  :       res = (res << 1) | (code & 1);

	mov	eax, ecx
	add	edx, edx
	and	eax, 1

; 855  :       code >>= 1;

	sar	ecx, 1
	or	edx, eax
	sub	r8d, 1
	jne	SHORT $LL289@stbi_zlib_

; 962  :          stbiw__zlib_huff(j+257);

	mov	ecx, r13d
	add	r13d, 8
	shl	edx, cl
	or	edi, edx

; 842  :    while (*bitcount >= 8) {

	cmp	r13d, 8
	jl	$LN294@stbi_zlib_

; 962  :          stbiw__zlib_huff(j+257);

	mov	ebp, r13d
	mov	r15, -1
	shr	rbp, 3
	mov	eax, ebp
	neg	eax
	lea	r13d, DWORD PTR [r13+rax*8]
	npad	3
$LL293@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	lea	rcx, QWORD PTR [rbx-8]
	test	rbx, rbx
	je	SHORT $LN302@stbi_zlib_
	mov	eax, DWORD PTR [rbx-4]
	mov	esi, DWORD PTR [rcx]
	inc	eax
	cmp	eax, esi
	jl	SHORT $LN299@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	esi, DWORD PTR [rsi*2+1]
	jmp	SHORT $LN303@stbi_zlib_
$LN302@stbi_zlib_:
	mov	esi, 2
$LN303@stbi_zlib_:

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, esi
	add	rdx, 8
	cmovb	rdx, r15
	test	rbx, rbx
	cmove	rcx, r10
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	xor	r10d, r10d
	test	rax, rax
	je	SHORT $LN299@stbi_zlib_

; 833  :       if (!*arr) ((int *) p)[1] = 0;

	test	rbx, rbx
	jne	SHORT $LN300@stbi_zlib_
	mov	DWORD PTR [rax+4], r10d
$LN300@stbi_zlib_:

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], esi
$LN299@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	movsxd	rax, DWORD PTR [rbx-4]
	mov	BYTE PTR [rax+rbx], dil
	inc	DWORD PTR [rbx-4]

; 844  :       *bitbuffer >>= 8;

	shr	edi, 8
	sub	rbp, 1
	jne	SHORT $LL293@stbi_zlib_
$LN893@stbi_zlib_:

; 963  :          if (lengtheb[j]) stbiw__zlib_add(best - lengthc[j], lengtheb[j]);

	mov	r15d, DWORD PTR best$1$[rsp]
$LN294@stbi_zlib_:
	lea	rax, OFFSET FLAT:__ImageBase
	movzx	r8d, BYTE PTR ?lengtheb@?1??stbi_zlib_compress@@9@4PAEA[r14+rax]
	test	r8b, r8b
	je	$LN234@stbi_zlib_
	movzx	eax, WORD PTR ?lengthc@?1??stbi_zlib_compress@@9@4PAGA[rax+r14*2]
	mov	ecx, r13d
	mov	edx, r15d
	add	r13d, r8d
	sub	edx, eax
	shl	edx, cl
	or	edi, edx

; 842  :    while (*bitcount >= 8) {

	cmp	r13d, 8
	jl	$LN234@stbi_zlib_

; 963  :          if (lengtheb[j]) stbiw__zlib_add(best - lengthc[j], lengtheb[j]);

	mov	ebp, r13d

; 842  :    while (*bitcount >= 8) {

	mov	r15, -1

; 963  :          if (lengtheb[j]) stbiw__zlib_add(best - lengthc[j], lengtheb[j]);

	shr	rbp, 3
	mov	eax, ebp
	neg	eax
	lea	r13d, DWORD PTR [r13+rax*8]

; 842  :    while (*bitcount >= 8) {

	jmp	SHORT $LN233@stbi_zlib_
	npad	2
$LL716@stbi_zlib_:
	xor	r10d, r10d
$LN233@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	lea	rcx, QWORD PTR [rbx-8]
	test	rbx, rbx
	je	SHORT $LN242@stbi_zlib_
	mov	eax, DWORD PTR [rbx-4]
	mov	esi, DWORD PTR [rcx]
	inc	eax
	cmp	eax, esi
	jl	SHORT $LN239@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	esi, DWORD PTR [rsi*2+1]
	jmp	SHORT $LN243@stbi_zlib_
$LN242@stbi_zlib_:
	mov	esi, 2
$LN243@stbi_zlib_:

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, esi
	add	rdx, 8
	cmovb	rdx, r15
	test	rbx, rbx
	cmove	rcx, r10
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN239@stbi_zlib_

; 833  :       if (!*arr) ((int *) p)[1] = 0;

	test	rbx, rbx
	jne	SHORT $LN240@stbi_zlib_
	xor	r14d, r14d
	mov	DWORD PTR [rax+4], r14d
$LN240@stbi_zlib_:

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], esi
$LN239@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	movsxd	rax, DWORD PTR [rbx-4]
	mov	BYTE PTR [rax+rbx], dil
	inc	DWORD PTR [rbx-4]

; 844  :       *bitbuffer >>= 8;

	shr	edi, 8
	sub	rbp, 1
	jne	SHORT $LL716@stbi_zlib_
	mov	r15d, DWORD PTR best$1$[rsp]
$LN234@stbi_zlib_:

; 964  :          for (j=0; d > distc[j+1]-1; ++j);

	xor	edx, edx
	mov	ecx, edx
	mov	r14d, edx
	cmp	r12d, 1
	jle	SHORT $LN17@stbi_zlib_
	lea	rdx, OFFSET FLAT:__ImageBase
	npad	15
$LL18@stbi_zlib_:
	movzx	eax, WORD PTR ?distc@?1??stbi_zlib_compress@@9@4PAGA[rdx+r14*2+4]
	inc	r14
	dec	eax
	inc	ecx
	cmp	r12d, eax
	jg	SHORT $LL18@stbi_zlib_
	xor	edx, edx
$LN17@stbi_zlib_:

; 965  :          stbiw__zlib_add(stbiw__zlib_bitrev(j,5),5);

	mov	r8d, 5
	npad	3
$LL129@stbi_zlib_:

; 854  :       res = (res << 1) | (code & 1);

	mov	eax, ecx
	add	edx, edx
	and	eax, 1

; 855  :       code >>= 1;

	sar	ecx, 1
	or	edx, eax
	sub	r8d, 1
	jne	SHORT $LL129@stbi_zlib_

; 965  :          stbiw__zlib_add(stbiw__zlib_bitrev(j,5),5);

	mov	ecx, r13d
	add	r13d, 5
	shl	edx, cl
	or	edi, edx
	mov	DWORD PTR bitcount$1$[rsp], r13d

; 842  :    while (*bitcount >= 8) {

	cmp	r13d, 8
	jl	$LN134@stbi_zlib_

; 965  :          stbiw__zlib_add(stbiw__zlib_bitrev(j,5),5);

	mov	ebp, r13d
	shr	rbp, 3
	mov	eax, ebp
	neg	eax
	xor	r15d, r15d
	lea	r13d, DWORD PTR [r13+rax*8]
	mov	DWORD PTR bitcount$1$[rsp], r13d
	lea	r13, QWORD PTR [r15-1]
$LL133@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	lea	rcx, QWORD PTR [rbx-8]
	test	rbx, rbx
	je	SHORT $LN142@stbi_zlib_
	mov	eax, DWORD PTR [rbx-4]
	mov	esi, DWORD PTR [rcx]
	inc	eax
	cmp	eax, esi
	jl	SHORT $LN139@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	esi, DWORD PTR [rsi*2+1]
	jmp	SHORT $LN143@stbi_zlib_
$LN142@stbi_zlib_:
	mov	esi, 2
$LN143@stbi_zlib_:

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, esi
	add	rdx, 8
	cmovb	rdx, r13
	test	rbx, rbx
	cmove	rcx, r15
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN139@stbi_zlib_

; 833  :       if (!*arr) ((int *) p)[1] = 0;

	test	rbx, rbx
	jne	SHORT $LN140@stbi_zlib_
	mov	DWORD PTR [rax+4], r15d
$LN140@stbi_zlib_:

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], esi
$LN139@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	movsxd	rax, DWORD PTR [rbx-4]
	mov	BYTE PTR [rax+rbx], dil
	inc	DWORD PTR [rbx-4]

; 844  :       *bitbuffer >>= 8;

	shr	edi, 8
	sub	rbp, 1
	jne	SHORT $LL133@stbi_zlib_
	mov	r13d, DWORD PTR bitcount$1$[rsp]
	mov	r15d, DWORD PTR best$1$[rsp]
$LN134@stbi_zlib_:

; 966  :          if (disteb[j]) stbiw__zlib_add(d - distc[j], disteb[j]);

	lea	rax, OFFSET FLAT:__ImageBase
	movzx	edx, BYTE PTR ?disteb@?1??stbi_zlib_compress@@9@4PAEA[r14+rax]
	test	dl, dl
	je	$LN148@stbi_zlib_
	movzx	eax, WORD PTR ?distc@?1??stbi_zlib_compress@@9@4PAGA[rax+r14*2]
	mov	ecx, r13d
	sub	r12d, eax
	add	r13d, edx
	shl	r12d, cl
	or	edi, r12d
	mov	DWORD PTR bitcount$1$[rsp], r13d

; 842  :    while (*bitcount >= 8) {

	cmp	r13d, 8
	jl	$LN148@stbi_zlib_

; 966  :          if (disteb[j]) stbiw__zlib_add(d - distc[j], disteb[j]);

	mov	ebp, r13d
	shr	rbp, 3
	mov	eax, ebp
	neg	eax
	xor	r15d, r15d
	lea	r13d, DWORD PTR [r13+rax*8]
	mov	DWORD PTR bitcount$1$[rsp], r13d
	lea	r13, QWORD PTR [r15-1]
	npad	2
$LL147@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	lea	rcx, QWORD PTR [rbx-8]
	test	rbx, rbx
	je	SHORT $LN156@stbi_zlib_
	mov	eax, DWORD PTR [rbx-4]
	mov	esi, DWORD PTR [rcx]
	inc	eax
	cmp	eax, esi
	jl	SHORT $LN153@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	esi, DWORD PTR [rsi*2+1]
	jmp	SHORT $LN157@stbi_zlib_
$LN156@stbi_zlib_:
	mov	esi, 2
$LN157@stbi_zlib_:

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, esi
	add	rdx, 8
	cmovb	rdx, r13
	test	rbx, rbx
	cmove	rcx, r15
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN153@stbi_zlib_

; 833  :       if (!*arr) ((int *) p)[1] = 0;

	test	rbx, rbx
	jne	SHORT $LN154@stbi_zlib_
	mov	DWORD PTR [rax+4], r15d
$LN154@stbi_zlib_:

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], esi
$LN153@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	movsxd	rax, DWORD PTR [rbx-4]
	mov	BYTE PTR [rax+rbx], dil
	inc	DWORD PTR [rbx-4]

; 844  :       *bitbuffer >>= 8;

	shr	edi, 8
	sub	rbp, 1
	jne	SHORT $LL147@stbi_zlib_
	mov	r13d, DWORD PTR bitcount$1$[rsp]
	mov	r15d, DWORD PTR best$1$[rsp]
$LN148@stbi_zlib_:

; 967  :          i += best;

	mov	r9d, DWORD PTR i$1$[rsp]
	add	r9d, r15d

; 968  :       } else {

	jmp	$LN894@stbi_zlib_
$LN714@stbi_zlib_:

; 950  :                if (e > best) { // if next match is better, bail on current match

	mov	rdx, QWORD PTR data$1$[rsp]
$LN43@stbi_zlib_:

; 969  :          stbiw__zlib_huffb(data[i]);

	movzx	ecx, BYTE PTR [rdx]
	cmp	cl, 143					; 0000008fH
	ja	$LN66@stbi_zlib_
	add	ecx, 48					; 00000030H

; 852  :    int res=0;

	xor	r14d, r14d
	mov	edx, r14d

; 969  :          stbiw__zlib_huffb(data[i]);

	lea	r8d, QWORD PTR [r14+8]
	npad	9
$LL321@stbi_zlib_:

; 854  :       res = (res << 1) | (code & 1);

	mov	eax, ecx
	add	edx, edx
	and	eax, 1

; 855  :       code >>= 1;

	sar	ecx, 1
	or	edx, eax
	sub	r8d, 1
	jne	SHORT $LL321@stbi_zlib_

; 969  :          stbiw__zlib_huffb(data[i]);

	mov	ecx, r13d
	add	r13d, 8
	shl	edx, cl
	or	edi, edx
	mov	DWORD PTR bitcount$1$[rsp], r13d

; 842  :    while (*bitcount >= 8) {

	cmp	r13d, 8
	jl	$LN308@stbi_zlib_

; 969  :          stbiw__zlib_huffb(data[i]);

	mov	ebp, r13d
	shr	rbp, 3
	mov	eax, ebp
	neg	eax
	lea	r13d, DWORD PTR [r13+rax*8]
	mov	DWORD PTR bitcount$1$[rsp], r13d
	mov	r13, -1
$LL325@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	lea	rcx, QWORD PTR [rbx-8]
	test	rbx, rbx
	je	SHORT $LN334@stbi_zlib_
	mov	eax, DWORD PTR [rbx-4]
	mov	esi, DWORD PTR [rcx]
	inc	eax
	cmp	eax, esi
	jl	SHORT $LN331@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	esi, DWORD PTR [rsi*2+1]
	jmp	SHORT $LN335@stbi_zlib_
$LN334@stbi_zlib_:
	mov	esi, 2
$LN335@stbi_zlib_:

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, esi
	add	rdx, 8
	cmovb	rdx, r13
	test	rbx, rbx
	cmove	rcx, r14
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN331@stbi_zlib_

; 833  :       if (!*arr) ((int *) p)[1] = 0;

	test	rbx, rbx
	jne	SHORT $LN332@stbi_zlib_
	mov	DWORD PTR [rax+4], r14d
$LN332@stbi_zlib_:

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], esi
$LN331@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	movsxd	rax, DWORD PTR [rbx-4]
	mov	BYTE PTR [rax+rbx], dil
	inc	DWORD PTR [rbx-4]

; 844  :       *bitbuffer >>= 8;

	shr	edi, 8
	sub	rbp, 1
	jne	SHORT $LL325@stbi_zlib_

; 969  :          stbiw__zlib_huffb(data[i]);

	jmp	$LN895@stbi_zlib_
$LN66@stbi_zlib_:
	add	ecx, 256				; 00000100H

; 852  :    int res=0;

	xor	r14d, r14d
	mov	edx, r14d

; 969  :          stbiw__zlib_huffb(data[i]);

	lea	r8d, QWORD PTR [r14+9]
	npad	2
$LL339@stbi_zlib_:

; 854  :       res = (res << 1) | (code & 1);

	mov	eax, ecx
	add	edx, edx
	and	eax, 1

; 855  :       code >>= 1;

	sar	ecx, 1
	or	edx, eax
	sub	r8d, 1
	jne	SHORT $LL339@stbi_zlib_

; 969  :          stbiw__zlib_huffb(data[i]);

	mov	ecx, r13d
	add	r13d, 9
	shl	edx, cl
	or	edi, edx
	mov	DWORD PTR bitcount$1$[rsp], r13d

; 842  :    while (*bitcount >= 8) {

	cmp	r13d, 8
	jl	$LN308@stbi_zlib_

; 969  :          stbiw__zlib_huffb(data[i]);

	mov	ebp, r13d
	shr	rbp, 3
	mov	eax, ebp
	neg	eax
	lea	r13d, DWORD PTR [r13+rax*8]
	mov	DWORD PTR bitcount$1$[rsp], r13d
	mov	r13, -1
$LL307@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	lea	rcx, QWORD PTR [rbx-8]
	test	rbx, rbx
	je	SHORT $LN316@stbi_zlib_
	mov	eax, DWORD PTR [rbx-4]
	mov	esi, DWORD PTR [rcx]
	inc	eax
	cmp	eax, esi
	jl	SHORT $LN313@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	esi, DWORD PTR [rsi*2+1]
	jmp	SHORT $LN317@stbi_zlib_
$LN316@stbi_zlib_:
	mov	esi, 2
$LN317@stbi_zlib_:

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, esi
	add	rdx, 8
	cmovb	rdx, r13
	test	rbx, rbx
	cmove	rcx, r14
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN313@stbi_zlib_

; 833  :       if (!*arr) ((int *) p)[1] = 0;

	test	rbx, rbx
	jne	SHORT $LN314@stbi_zlib_
	mov	DWORD PTR [rax+4], r14d
$LN314@stbi_zlib_:

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], esi
$LN313@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	movsxd	rax, DWORD PTR [rbx-4]
	mov	BYTE PTR [rax+rbx], dil
	inc	DWORD PTR [rbx-4]

; 844  :       *bitbuffer >>= 8;

	shr	edi, 8
	sub	rbp, 1
	jne	SHORT $LL307@stbi_zlib_
$LN895@stbi_zlib_:

; 970  :          ++i;

	mov	r13d, DWORD PTR bitcount$1$[rsp]
$LN308@stbi_zlib_:
	mov	r9d, DWORD PTR i$1$[rsp]
	inc	r9d
$LN894@stbi_zlib_:

; 918  : 
; 919  :    for (i=0; i < stbiw__ZHASH; ++i)
; 920  :       hash_table[i] = NULL;
; 921  : 
; 922  :    i=0;
; 923  :    while (i < data_len-3) {

	mov	r11d, DWORD PTR data_len$GSCopy$1$[rsp]
	mov	ebp, 0
	mov	r15, QWORD PTR data$GSCopy$1$[rsp]
	mov	DWORD PTR i$1$[rsp], r9d
	lea	eax, DWORD PTR [r11-3]
	lea	r8, QWORD PTR [rbp-4]
	cmp	r9d, eax
	jl	$LL715@stbi_zlib_
$LN6@stbi_zlib_:

; 971  :       }
; 972  :    }
; 973  :    // write out final bytes
; 974  :    for (;i < data_len; ++i)

	movsxd	r12, r11d
	movsxd	r14, r9d
	mov	QWORD PTR tv5800[rsp], r12
	cmp	r14, r12
	jge	$LN20@stbi_zlib_
	npad	1
$LL21@stbi_zlib_:

; 975  :       stbiw__zlib_huffb(data[i]);

	movzx	r8d, BYTE PTR [r14+r15]
	mov	edx, ebp
	cmp	r8b, 143				; 0000008fH
	ja	$LN68@stbi_zlib_
	lea	ecx, DWORD PTR [r8+48]
	mov	r8d, 8
	npad	5
$LL391@stbi_zlib_:

; 854  :       res = (res << 1) | (code & 1);

	mov	eax, ecx
	add	edx, edx
	and	eax, 1

; 855  :       code >>= 1;

	sar	ecx, 1
	or	edx, eax
	sub	r8d, 1
	jne	SHORT $LL391@stbi_zlib_

; 975  :       stbiw__zlib_huffb(data[i]);

	mov	ecx, r13d
	add	r13d, 8
	shl	edx, cl
	or	edi, edx

; 842  :    while (*bitcount >= 8) {

	cmp	r13d, 8
	jl	$LN19@stbi_zlib_

; 975  :       stbiw__zlib_huffb(data[i]);

	mov	ebp, r13d
	shr	rbp, 3
	mov	eax, ebp
	neg	eax
	xor	r15d, r15d
	lea	r13d, DWORD PTR [r13+rax*8]
	lea	r12, QWORD PTR [r15-1]
	npad	3
$LL395@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	lea	rcx, QWORD PTR [rbx-8]
	test	rbx, rbx
	je	SHORT $LN404@stbi_zlib_
	mov	eax, DWORD PTR [rbx-4]
	mov	esi, DWORD PTR [rcx]
	inc	eax
	cmp	eax, esi
	jl	SHORT $LN401@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	esi, DWORD PTR [rsi*2+1]
	jmp	SHORT $LN405@stbi_zlib_
$LN404@stbi_zlib_:
	mov	esi, 2
$LN405@stbi_zlib_:

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, esi
	add	rdx, 8
	cmovb	rdx, r12
	test	rbx, rbx
	cmove	rcx, r15
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN401@stbi_zlib_

; 833  :       if (!*arr) ((int *) p)[1] = 0;

	test	rbx, rbx
	jne	SHORT $LN402@stbi_zlib_
	mov	DWORD PTR [rax+4], r15d
$LN402@stbi_zlib_:

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], esi
$LN401@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	movsxd	rax, DWORD PTR [rbx-4]
	mov	BYTE PTR [rax+rbx], dil
	inc	DWORD PTR [rbx-4]

; 844  :       *bitbuffer >>= 8;

	shr	edi, 8
	sub	rbp, 1
	jne	SHORT $LL395@stbi_zlib_

; 975  :       stbiw__zlib_huffb(data[i]);

	jmp	$LN896@stbi_zlib_
$LN68@stbi_zlib_:
	add	r8d, 256				; 00000100H
	mov	r9d, 9
	npad	12
$LL409@stbi_zlib_:

; 854  :       res = (res << 1) | (code & 1);

	mov	ecx, r8d
	lea	eax, DWORD PTR [rdx+rdx]
	and	ecx, 1

; 855  :       code >>= 1;

	sar	r8d, 1
	mov	edx, ecx
	or	edx, eax
	sub	r9d, 1
	jne	SHORT $LL409@stbi_zlib_

; 975  :       stbiw__zlib_huffb(data[i]);

	mov	ecx, r13d
	add	r13d, 9
	shl	edx, cl
	or	edi, edx

; 842  :    while (*bitcount >= 8) {

	cmp	r13d, 8
	jl	$LN19@stbi_zlib_

; 975  :       stbiw__zlib_huffb(data[i]);

	mov	ebp, r13d
	shr	rbp, 3
	mov	eax, ebp
	neg	eax
	xor	r15d, r15d
	lea	r13d, DWORD PTR [r13+rax*8]
	lea	r12, QWORD PTR [r15-1]
$LL351@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	lea	rcx, QWORD PTR [rbx-8]
	test	rbx, rbx
	je	SHORT $LN360@stbi_zlib_
	mov	eax, DWORD PTR [rbx-4]
	mov	esi, DWORD PTR [rcx]
	inc	eax
	cmp	eax, esi
	jl	SHORT $LN357@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	esi, DWORD PTR [rsi*2+1]
	jmp	SHORT $LN361@stbi_zlib_
$LN360@stbi_zlib_:
	mov	esi, 2
$LN361@stbi_zlib_:

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, esi
	add	rdx, 8
	cmovb	rdx, r12
	test	rbx, rbx
	cmove	rcx, r15
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN357@stbi_zlib_

; 833  :       if (!*arr) ((int *) p)[1] = 0;

	test	rbx, rbx
	jne	SHORT $LN358@stbi_zlib_
	mov	DWORD PTR [rax+4], r15d
$LN358@stbi_zlib_:

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], esi
$LN357@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	movsxd	rax, DWORD PTR [rbx-4]
	mov	BYTE PTR [rax+rbx], dil
	inc	DWORD PTR [rbx-4]

; 844  :       *bitbuffer >>= 8;

	shr	edi, 8
	sub	rbp, 1
	jne	SHORT $LL351@stbi_zlib_
$LN896@stbi_zlib_:

; 971  :       }
; 972  :    }
; 973  :    // write out final bytes
; 974  :    for (;i < data_len; ++i)

	mov	r15, QWORD PTR data$GSCopy$1$[rsp]
	xor	ebp, ebp
	mov	r12, QWORD PTR tv5800[rsp]
$LN19@stbi_zlib_:
	inc	r14
	cmp	r14, r12
	jl	$LL21@stbi_zlib_
$LN20@stbi_zlib_:

; 976  :    stbiw__zlib_huff(256); // end of block

	mov	ecx, ebp

; 852  :    int res=0;

	mov	edx, ebp

; 976  :    stbiw__zlib_huff(256); // end of block

	mov	r8d, 7
	npad	10
$LL433@stbi_zlib_:

; 854  :       res = (res << 1) | (code & 1);

	mov	eax, ecx
	add	edx, edx
	and	eax, 1

; 855  :       code >>= 1;

	sar	ecx, 1
	or	edx, eax
	sub	r8d, 1
	jne	SHORT $LL433@stbi_zlib_

; 976  :    stbiw__zlib_huff(256); // end of block

	mov	ecx, r13d
	add	r13d, 7
	shl	edx, cl
	or	edi, edx

; 842  :    while (*bitcount >= 8) {

	cmp	r13d, 8
	jl	$LN438@stbi_zlib_

; 976  :    stbiw__zlib_huff(256); // end of block

	mov	ebp, r13d
	shr	rbp, 3
	mov	eax, ebp
	neg	eax
	xor	r12d, r12d
	lea	r13d, DWORD PTR [r13+rax*8]
	lea	r15, QWORD PTR [r12-1]
	npad	2
$LL437@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	lea	rcx, QWORD PTR [rbx-8]
	test	rbx, rbx
	je	SHORT $LN446@stbi_zlib_
	mov	eax, DWORD PTR [rbx-4]
	mov	esi, DWORD PTR [rcx]
	inc	eax
	cmp	eax, esi
	jl	SHORT $LN443@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	esi, DWORD PTR [rsi*2+1]
	jmp	SHORT $LN447@stbi_zlib_
$LN446@stbi_zlib_:
	mov	esi, 2
$LN447@stbi_zlib_:

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, esi
	add	rdx, 8
	cmovb	rdx, r15
	test	rbx, rbx
	cmove	rcx, r12
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN443@stbi_zlib_

; 833  :       if (!*arr) ((int *) p)[1] = 0;

	test	rbx, rbx
	jne	SHORT $LN444@stbi_zlib_
	mov	DWORD PTR [rax+4], r12d
$LN444@stbi_zlib_:

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], esi
$LN443@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	movsxd	rax, DWORD PTR [rbx-4]
	mov	BYTE PTR [rax+rbx], dil
	inc	DWORD PTR [rbx-4]

; 844  :       *bitbuffer >>= 8;

	shr	edi, 8
	sub	rbp, 1
	jne	SHORT $LL437@stbi_zlib_
	mov	r12, QWORD PTR tv5800[rsp]
	mov	r15, QWORD PTR data$GSCopy$1$[rsp]
$LN438@stbi_zlib_:

; 977  :    // pad with 0 bits to byte boundary
; 978  :    while (bitcount)

	test	r13d, r13d
	je	$LN23@stbi_zlib_
	xor	r15d, r15d
	lea	r12, QWORD PTR [r15-1]
	npad	4
$LL22@stbi_zlib_:

; 979  :       stbiw__zlib_add(0,1);

	inc	r13d

; 842  :    while (*bitcount >= 8) {

	cmp	r13d, 8
	jl	SHORT $LN202@stbi_zlib_

; 979  :       stbiw__zlib_add(0,1);

	mov	ebp, r13d
	shr	rbp, 3
	mov	eax, ebp
	neg	eax
	lea	r13d, DWORD PTR [r13+rax*8]
	npad	7
$LL201@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	lea	rcx, QWORD PTR [rbx-8]
	test	rbx, rbx
	je	SHORT $LN210@stbi_zlib_
	mov	eax, DWORD PTR [rbx-4]
	mov	esi, DWORD PTR [rcx]
	inc	eax
	cmp	eax, esi
	jl	SHORT $LN207@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	esi, DWORD PTR [rsi*2+1]
	jmp	SHORT $LN211@stbi_zlib_
$LN210@stbi_zlib_:
	mov	esi, 2
$LN211@stbi_zlib_:

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, esi
	add	rdx, 8
	cmovb	rdx, r12
	test	rbx, rbx
	cmove	rcx, r15
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN207@stbi_zlib_

; 833  :       if (!*arr) ((int *) p)[1] = 0;

	test	rbx, rbx
	jne	SHORT $LN208@stbi_zlib_
	mov	DWORD PTR [rax+4], r15d
$LN208@stbi_zlib_:

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], esi
$LN207@stbi_zlib_:

; 843  :       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));

	movsxd	rax, DWORD PTR [rbx-4]
	mov	BYTE PTR [rax+rbx], dil
	inc	DWORD PTR [rbx-4]

; 844  :       *bitbuffer >>= 8;

	shr	edi, 8
	sub	rbp, 1
	jne	SHORT $LL201@stbi_zlib_
$LN202@stbi_zlib_:

; 977  :    // pad with 0 bits to byte boundary
; 978  :    while (bitcount)

	test	r13d, r13d
	jne	$LL22@stbi_zlib_
	mov	r12, QWORD PTR tv5800[rsp]
	mov	r15, QWORD PTR data$GSCopy$1$[rsp]
$LN23@stbi_zlib_:

; 980  : 
; 981  :    for (i=0; i < stbiw__ZHASH; ++i)

	mov	r14, QWORD PTR hash_table$1$[rsp]
	mov	esi, 16384				; 00004000H
	mov	rdi, r14
$LL26@stbi_zlib_:

; 982  :       (void) stbiw__sbfree(hash_table[i]);

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN24@stbi_zlib_
	add	rcx, -8
	call	QWORD PTR __imp_free
$LN24@stbi_zlib_:

; 980  : 
; 981  :    for (i=0; i < stbiw__ZHASH; ++i)

	add	rdi, 8
	sub	rsi, 1
	jne	SHORT $LL26@stbi_zlib_

; 983  :    STBIW_FREE(hash_table);

	mov	rcx, r14
	call	QWORD PTR __imp_free

; 984  : 
; 985  :    // store uncompressed instead if compression was worse
; 986  :    if (stbiw__sbn(out) > data_len + 2 + ((data_len+32766)/32767)*5) {

	mov	r13d, DWORD PTR data_len$GSCopy$1$[rsp]
	mov	eax, -2147418109			; ffffffff80010003H
	lea	ecx, DWORD PTR [r13+32766]
	imul	ecx
	add	edx, ecx
	lea	ecx, DWORD PTR [r13+2]
	sar	edx, 14
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	lea	ecx, DWORD PTR [rcx+rdx*4]
	add	ecx, edx
	cmp	DWORD PTR [rbx-4], ecx
	jle	$LN28@stbi_zlib_

; 987  :       stbiw__sbn(out) = 2;  // truncate to DEFLATE 32K window and FLEVEL = 1
; 988  :       for (j = 0; j < data_len;) {

	xor	r14d, r14d
	mov	DWORD PTR [rbx-4], 2
	test	r13d, r13d
	jle	$LN28@stbi_zlib_
	lea	rsi, QWORD PTR [rbx-8]
	mov	eax, 32767				; 00007fffH
	xor	r12d, r12d
	npad	9
$LL27@stbi_zlib_:

; 989  :          int blocklen = data_len - j;
; 990  :          if (blocklen > 32767) blocklen = 32767;
; 991  :          stbiw__sbpush(out, data_len - j == blocklen); // BFINAL = ?, BTYPE = 0 -- no compression

	mov	ecx, DWORD PTR [rsi]
	mov	ebp, r13d
	sub	ebp, r14d
	cmp	ebp, eax
	mov	edi, ebp
	cmovg	edi, eax
	mov	eax, DWORD PTR [rbx-4]
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LN185@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	eax, DWORD PTR [rcx+rcx]

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	mov	rcx, rsi
	movsxd	rdx, eax
	lea	r15d, DWORD PTR [rax+1]
	inc	rdx
	mov	rax, -1
	add	rdx, 8
	cmovb	rdx, rax
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN185@stbi_zlib_

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], r15d
$LN185@stbi_zlib_:

; 989  :          int blocklen = data_len - j;
; 990  :          if (blocklen > 32767) blocklen = 32767;
; 991  :          stbiw__sbpush(out, data_len - j == blocklen); // BFINAL = ?, BTYPE = 0 -- no compression

	movsxd	rax, DWORD PTR [rbx-4]
	cmp	ebp, edi

; 992  :          stbiw__sbpush(out, STBIW_UCHAR(blocklen)); // LEN

	mov	r15, -1
	sete	cl
	mov	BYTE PTR [rax+rbx], cl
	lea	rcx, QWORD PTR [rbx-8]
	inc	DWORD PTR [rbx-4]
	mov	eax, DWORD PTR [rbx-4]
	mov	edx, DWORD PTR [rcx]
	inc	eax
	cmp	eax, edx
	jl	SHORT $LN177@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	eax, DWORD PTR [rdx+rdx]

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, eax
	lea	esi, DWORD PTR [rax+1]
	inc	rdx
	add	rdx, 8
	cmovb	rdx, r15
	test	rbx, rbx
	cmove	rcx, r12
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN177@stbi_zlib_

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], esi
$LN177@stbi_zlib_:

; 992  :          stbiw__sbpush(out, STBIW_UCHAR(blocklen)); // LEN

	movsxd	rax, DWORD PTR [rbx-4]

; 993  :          stbiw__sbpush(out, STBIW_UCHAR(blocklen >> 8));

	lea	rcx, QWORD PTR [rbx-8]
	mov	BYTE PTR [rax+rbx], dil
	inc	DWORD PTR [rbx-4]
	mov	eax, DWORD PTR [rbx-4]
	mov	edx, DWORD PTR [rcx]
	inc	eax
	cmp	eax, edx
	jl	SHORT $LN193@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	eax, DWORD PTR [rdx+rdx]

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, eax
	lea	esi, DWORD PTR [rax+1]
	inc	rdx
	add	rdx, 8
	cmovb	rdx, r15
	test	rbx, rbx
	cmove	rcx, r12
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN193@stbi_zlib_

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], esi
$LN193@stbi_zlib_:

; 993  :          stbiw__sbpush(out, STBIW_UCHAR(blocklen >> 8));

	movsxd	rax, DWORD PTR [rbx-4]
	mov	ecx, edi
	sar	ecx, 8
	mov	BYTE PTR [rax+rbx], cl

; 994  :          stbiw__sbpush(out, STBIW_UCHAR(~blocklen)); // NLEN

	lea	rcx, QWORD PTR [rbx-8]
	inc	DWORD PTR [rbx-4]
	mov	eax, DWORD PTR [rbx-4]
	mov	edx, DWORD PTR [rcx]
	inc	eax
	cmp	eax, edx
	jl	SHORT $LN169@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	eax, DWORD PTR [rdx+rdx]

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, eax
	lea	esi, DWORD PTR [rax+1]
	inc	rdx
	add	rdx, 8
	cmovb	rdx, r15
	test	rbx, rbx
	cmove	rcx, r12
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN169@stbi_zlib_

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], esi
$LN169@stbi_zlib_:

; 994  :          stbiw__sbpush(out, STBIW_UCHAR(~blocklen)); // NLEN

	movsxd	rax, DWORD PTR [rbx-4]

; 995  :          stbiw__sbpush(out, STBIW_UCHAR(~blocklen >> 8));

	lea	rsi, QWORD PTR [rbx-8]
	movzx	ecx, dil
	not	cl
	mov	BYTE PTR [rax+rbx], cl
	inc	DWORD PTR [rbx-4]
	mov	eax, DWORD PTR [rbx-4]
	mov	ecx, DWORD PTR [rsi]
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LN161@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	eax, DWORD PTR [rcx+rcx]

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	mov	rcx, rsi
	movsxd	rdx, eax
	lea	ebp, DWORD PTR [rax+1]
	inc	rdx
	add	rdx, 8
	cmovb	rdx, r15
	test	rbx, rbx
	cmove	rcx, r12
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN161@stbi_zlib_

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], ebp
	mov	rsi, rax
$LN161@stbi_zlib_:

; 995  :          stbiw__sbpush(out, STBIW_UCHAR(~blocklen >> 8));

	movsxd	rax, DWORD PTR [rbx-4]
	mov	ecx, edi

; 996  :          memcpy(out+stbiw__sbn(out), data+j, blocklen);

	mov	r15, QWORD PTR data$GSCopy$1$[rsp]
	not	ecx
	sar	ecx, 8
	movsxd	rdx, r14d
	mov	BYTE PTR [rax+rbx], cl
	add	rdx, r15
	inc	DWORD PTR [rbx-4]
	movsxd	rcx, DWORD PTR [rbx-4]
	add	rcx, rbx
	movsxd	r8, edi
	call	memcpy

; 997  :          stbiw__sbn(out) += blocklen;

	add	DWORD PTR [rbx-4], edi

; 998  :          j += blocklen;

	add	r14d, edi
	mov	eax, 32767				; 00007fffH
	cmp	r14d, r13d
	jl	$LL27@stbi_zlib_
	mov	r12, QWORD PTR tv5800[rsp]
$LN28@stbi_zlib_:

; 999  :       }
; 1000 :    }
; 1001 : 
; 1002 :    {
; 1003 :       // compute adler32 on input
; 1004 :       unsigned int s1=1, s2=0;

	xor	r14d, r14d
	mov	edi, 1
	mov	esi, r14d

; 1006 :       j=0;
; 1007 :       while (j < data_len) {

	test	r12, r12
	jle	SHORT $LN31@stbi_zlib_

; 995  :          stbiw__sbpush(out, STBIW_UCHAR(~blocklen >> 8));

	mov	eax, 1584310703				; 5e6ea9afH
	mov	r9d, r14d

; 1005 :       int blocklen = (int) (data_len % 5552);

	imul	r13d
	sar	edx, 11
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	imul	eax, edx, 5552				; 000015b0H
	sub	r13d, eax
	movsxd	r8, r13d
$LL30@stbi_zlib_:

; 1008 :          for (i=0; i < blocklen; ++i) { s1 += data[j+i]; s2 += s1; }

	mov	rcx, r14
	test	r8, r8
	jle	SHORT $LN33@stbi_zlib_
	lea	rdx, QWORD PTR [r9+r15]
	npad	4
$LL602@stbi_zlib_:
	movzx	eax, BYTE PTR [rcx+rdx]
	inc	rcx
	add	edi, eax
	add	esi, edi
	cmp	rcx, r8
	jl	SHORT $LL602@stbi_zlib_
$LN33@stbi_zlib_:

; 1009 :          s1 %= 65521; s2 %= 65521;

	mov	eax, -2146992015			; 80078071H

; 1010 :          j += blocklen;

	add	r9, r8
	mul	edi

; 1011 :          blocklen = 5552;

	mov	r8d, 5552				; 000015b0H
	shr	edx, 15
	imul	eax, edx, -65521			; ffff000fH
	add	edi, eax
	mov	eax, -2146992015			; 80078071H
	mul	esi
	shr	edx, 15
	imul	eax, edx, -65521			; ffff000fH
	add	esi, eax
	cmp	r9, r12
	jl	SHORT $LL30@stbi_zlib_
$LN31@stbi_zlib_:

; 1012 :       }
; 1013 :       stbiw__sbpush(out, STBIW_UCHAR(s2 >> 8));

	mov	eax, DWORD PTR [rbx-4]
	lea	rcx, QWORD PTR [rbx-8]
	mov	edx, DWORD PTR [rcx]
	inc	eax
	mov	r13, QWORD PTR [rsp+120]
	mov	r15, -1
	mov	r12, QWORD PTR [rsp+128]
	cmp	eax, edx
	jl	SHORT $LN105@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	eax, DWORD PTR [rdx+rdx]

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, eax
	lea	ebp, DWORD PTR [rax+1]
	inc	rdx
	add	rdx, 8
	cmovb	rdx, r15
	test	rbx, rbx
	cmove	rcx, r14
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN105@stbi_zlib_

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], ebp
$LN105@stbi_zlib_:

; 1012 :       }
; 1013 :       stbiw__sbpush(out, STBIW_UCHAR(s2 >> 8));

	movsxd	rax, DWORD PTR [rbx-4]
	mov	ecx, esi
	shr	ecx, 8
	mov	BYTE PTR [rax+rbx], cl

; 1014 :       stbiw__sbpush(out, STBIW_UCHAR(s2));

	lea	rcx, QWORD PTR [rbx-8]
	inc	DWORD PTR [rbx-4]
	mov	eax, DWORD PTR [rbx-4]
	mov	edx, DWORD PTR [rcx]
	inc	eax
	cmp	eax, edx
	jl	SHORT $LN113@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	eax, DWORD PTR [rdx+rdx]

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, eax
	lea	ebp, DWORD PTR [rax+1]
	inc	rdx
	add	rdx, 8
	cmovb	rdx, r15
	test	rbx, rbx
	cmove	rcx, r14
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN113@stbi_zlib_

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], ebp
$LN113@stbi_zlib_:

; 1014 :       stbiw__sbpush(out, STBIW_UCHAR(s2));

	movsxd	rax, DWORD PTR [rbx-4]

; 1015 :       stbiw__sbpush(out, STBIW_UCHAR(s1 >> 8));

	lea	rcx, QWORD PTR [rbx-8]
	mov	BYTE PTR [rax+rbx], sil
	inc	DWORD PTR [rbx-4]
	mov	eax, DWORD PTR [rbx-4]
	mov	edx, DWORD PTR [rcx]
	inc	eax
	cmp	eax, edx
	jl	SHORT $LN121@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	eax, DWORD PTR [rdx+rdx]

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, eax
	lea	esi, DWORD PTR [rax+1]
	inc	rdx
	add	rdx, 8
	cmovb	rdx, r15
	test	rbx, rbx
	cmove	rcx, r14
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN121@stbi_zlib_

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], esi
$LN121@stbi_zlib_:

; 1015 :       stbiw__sbpush(out, STBIW_UCHAR(s1 >> 8));

	movsxd	rax, DWORD PTR [rbx-4]
	mov	ecx, edi
	shr	ecx, 8
	mov	BYTE PTR [rax+rbx], cl

; 1016 :       stbiw__sbpush(out, STBIW_UCHAR(s1));

	lea	rcx, QWORD PTR [rbx-8]
	inc	DWORD PTR [rbx-4]
	mov	eax, DWORD PTR [rbx-4]
	mov	edx, DWORD PTR [rcx]
	inc	eax
	cmp	eax, edx
	jl	SHORT $LN97@stbi_zlib_

; 829  :    int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;

	lea	eax, DWORD PTR [rdx+rdx]

; 830  :    void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);

	movsxd	rdx, eax
	lea	esi, DWORD PTR [rax+1]
	inc	rdx
	add	rdx, 8
	cmovb	rdx, r15
	test	rbx, rbx
	cmove	rcx, r14
	call	QWORD PTR __imp_realloc

; 831  :    STBIW_ASSERT(p);
; 832  :    if (p) {

	test	rax, rax
	je	SHORT $LN97@stbi_zlib_

; 834  :       *arr = (void *) ((int *) p + 2);

	lea	rbx, QWORD PTR [rax+8]

; 835  :       stbiw__sbm(*arr) = m;

	mov	DWORD PTR [rax], esi
$LN97@stbi_zlib_:

; 1016 :       stbiw__sbpush(out, STBIW_UCHAR(s1));

	movsxd	rax, DWORD PTR [rbx-4]

; 1017 :    }
; 1018 :    *out_len = stbiw__sbn(out);
; 1019 :    // make returned pointer freeable
; 1020 :    STBIW_MEMMOVE(stbiw__sbraw(out), out, *out_len);

	mov	rdx, rbx
	mov	BYTE PTR [rax+rbx], dil
	inc	DWORD PTR [rbx-4]
	movsxd	rcx, DWORD PTR [rbx-4]
	mov	rax, QWORD PTR out_len$GSCopy$1$[rsp]
	mov	r8, rcx
	mov	DWORD PTR [rax], ecx
	lea	rcx, QWORD PTR [rbx-8]
	call	memmove

; 1021 :    return (unsigned char *) stbiw__sbraw(out);

	mov	r14, QWORD PTR [rsp+112]
	lea	rax, QWORD PTR [rbx-8]
	mov	rdi, QWORD PTR [rsp+200]

; 1022 : #endif // STBIW_ZLIB_COMPRESS
; 1023 : }

	add	rsp, 136				; 00000088H
	pop	r15
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
stbi_zlib_compress ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image_write.h
;	COMDAT ?stbiw__crc32@@YAIPEAEH@Z
_TEXT	SEGMENT
buffer$ = 16
len$ = 24
?stbiw__crc32@@YAIPEAEH@Z PROC				; stbiw__crc32, COMDAT

; 1026 : {

	sub	rsp, 8

; 1027 : #ifdef STBIW_CRC32
; 1028 :     return STBIW_CRC32(buffer, len);
; 1029 : #else
; 1030 :    static unsigned int crc_table[256] =
; 1031 :    {
; 1032 :       0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
; 1033 :       0x0eDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
; 1034 :       0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
; 1035 :       0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
; 1036 :       0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
; 1037 :       0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
; 1038 :       0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
; 1039 :       0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
; 1040 :       0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
; 1041 :       0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
; 1042 :       0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
; 1043 :       0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
; 1044 :       0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
; 1045 :       0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
; 1046 :       0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
; 1047 :       0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
; 1048 :       0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
; 1049 :       0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
; 1050 :       0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
; 1051 :       0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
; 1052 :       0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
; 1053 :       0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
; 1054 :       0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
; 1055 :       0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
; 1056 :       0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
; 1057 :       0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
; 1058 :       0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
; 1059 :       0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
; 1060 :       0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
; 1061 :       0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
; 1062 :       0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
; 1063 :       0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
; 1064 :    };
; 1065 : 
; 1066 :    unsigned int crc = ~0u;
; 1067 :    int i;
; 1068 :    for (i=0; i < len; ++i)

	movsxd	r11, edx
	mov	eax, -1					; ffffffffH
	test	edx, edx
	jle	SHORT $LN3@stbiw__crc
	mov	QWORD PTR [rsp], rbx
	xor	r10d, r10d
	lea	rbx, OFFSET FLAT:?crc_table@?1??stbiw__crc32@@YAIPEAEH@Z@4PAIA
	npad	2
$LL4@stbiw__crc:

; 1069 :       crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)];

	movzx	r9d, BYTE PTR [r10+rcx]
	inc	r10
	movzx	r8d, al
	xor	r9, r8
	shr	eax, 8
	xor	eax, DWORD PTR [rbx+r9*4]
	cmp	r10, r11
	jl	SHORT $LL4@stbiw__crc

; 1027 : #ifdef STBIW_CRC32
; 1028 :     return STBIW_CRC32(buffer, len);
; 1029 : #else
; 1030 :    static unsigned int crc_table[256] =
; 1031 :    {
; 1032 :       0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
; 1033 :       0x0eDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
; 1034 :       0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
; 1035 :       0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
; 1036 :       0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
; 1037 :       0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
; 1038 :       0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
; 1039 :       0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
; 1040 :       0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
; 1041 :       0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
; 1042 :       0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
; 1043 :       0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
; 1044 :       0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
; 1045 :       0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
; 1046 :       0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
; 1047 :       0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
; 1048 :       0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
; 1049 :       0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
; 1050 :       0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
; 1051 :       0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
; 1052 :       0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
; 1053 :       0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
; 1054 :       0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
; 1055 :       0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
; 1056 :       0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
; 1057 :       0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
; 1058 :       0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
; 1059 :       0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
; 1060 :       0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
; 1061 :       0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
; 1062 :       0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
; 1063 :       0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
; 1064 :    };
; 1065 : 
; 1066 :    unsigned int crc = ~0u;
; 1067 :    int i;
; 1068 :    for (i=0; i < len; ++i)

	mov	rbx, QWORD PTR [rsp]
$LN3@stbiw__crc:

; 1070 :    return ~crc;

	not	eax

; 1071 : #endif
; 1072 : }

	add	rsp, 8
	ret	0
?stbiw__crc32@@YAIPEAEH@Z ENDP				; stbiw__crc32
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image_write.h
;	COMDAT ?stbiw__wpcrc@@YAXPEAPEAEH@Z
_TEXT	SEGMENT
data$ = 8
len$ = 16
?stbiw__wpcrc@@YAXPEAPEAEH@Z PROC			; stbiw__wpcrc, COMDAT

; 1080 :    unsigned int crc = stbiw__crc32(*data - len - 4, len+4);

	lea	r8d, DWORD PTR [rdx+4]
	mov	r10, rcx

; 1068 :    for (i=0; i < len; ++i)

	movsxd	r9, r8d
	mov	eax, -1					; ffffffffH
	test	r8d, r8d
	jle	SHORT $LN5@stbiw__wpc

; 1080 :    unsigned int crc = stbiw__crc32(*data - len - 4, len+4);

	mov	r8, QWORD PTR [rcx]
	lea	r11, OFFSET FLAT:?crc_table@?1??stbiw__crc32@@YAIPEAEH@Z@4PAIA
	movsxd	rdx, edx
	sub	r8, rdx
	sub	r8, 4
	npad	8
$LL6@stbiw__wpc:

; 1069 :       crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)];

	movzx	ecx, BYTE PTR [r8]
	lea	r8, QWORD PTR [r8+1]
	movzx	edx, al
	xor	rdx, rcx
	shr	eax, 8
	xor	eax, DWORD PTR [r11+rdx*4]
	sub	r9, 1
	jne	SHORT $LL6@stbiw__wpc
$LN5@stbiw__wpc:

; 1081 :    stbiw__wp32(*data, crc);

	mov	rdx, QWORD PTR [r10]

; 1070 :    return ~crc;

	not	eax

; 1081 :    stbiw__wp32(*data, crc);

	mov	ecx, eax
	shr	ecx, 24
	mov	BYTE PTR [rdx], cl
	mov	ecx, eax
	shr	ecx, 16
	mov	BYTE PTR [rdx+1], cl
	mov	ecx, eax
	shr	ecx, 8
	mov	BYTE PTR [rdx+2], cl
	mov	BYTE PTR [rdx+3], al
	lea	rax, QWORD PTR [rdx+4]
	mov	QWORD PTR [r10], rax

; 1082 : }

	ret	0
?stbiw__wpcrc@@YAXPEAPEAEH@Z ENDP			; stbiw__wpcrc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image_write.h
;	COMDAT ?stbiw__paeth@@YAEHHH@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
c$ = 24
?stbiw__paeth@@YAEHHH@Z PROC				; stbiw__paeth, COMDAT

; 1085 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi
	mov	edi, edx
	mov	ebx, r8d

; 1086 :    int p = a + b - c, pa = abs(p-a), pb = abs(p-b), pc = abs(p-c);

	mov	r9d, ecx
	sub	r9d, r8d
	lea	r10d, DWORD PTR [r9+rdx]
	mov	eax, r10d
	sub	r10d, r8d
	sub	eax, ecx
	cdq
	mov	r11d, eax
	mov	eax, r9d
	xor	r11d, edx
	sub	r11d, edx
	cdq
	mov	r9d, eax
	mov	eax, r10d
	xor	r9d, edx
	sub	r9d, edx
	cdq
	mov	r8d, eax
	xor	r8d, edx
	sub	r8d, edx

; 1087 :    if (pa <= pb && pa <= pc) return STBIW_UCHAR(a);

	cmp	r11d, r9d
	jg	SHORT $LN2@stbiw__pae
	cmp	r11d, r8d
	jg	SHORT $LN2@stbiw__pae
	movzx	eax, cl

; 1089 :    return STBIW_UCHAR(c);
; 1090 : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
$LN2@stbiw__pae:

; 1088 :    if (pb <= pc) return STBIW_UCHAR(b);

	movzx	eax, bl
	cmp	r9d, r8d

; 1089 :    return STBIW_UCHAR(c);
; 1090 : }

	mov	rbx, QWORD PTR [rsp+8]
	movzx	ecx, dil
	mov	rdi, QWORD PTR [rsp+16]
	cmovle	eax, ecx
	ret	0
?stbiw__paeth@@YAEHHH@Z ENDP				; stbiw__paeth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image_write.h
;	COMDAT ?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z
_TEXT	SEGMENT
tv1915 = 80
pixels$ = 80
stride_bytes$ = 88
width$ = 96
height$ = 104
y$ = 112
n$dead$ = 120
filter_type$ = 128
line_buffer$ = 136
?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z PROC	; stbiw__encode_png_line, COMDAT

; 1094 : {

	push	rbx
	push	rbp
	push	r12
	sub	rsp, 48					; 00000030H

; 1095 :    static int mapping[] = { 0,1,2,3,4 };
; 1096 :    static int firstmap[] = { 0,1,0,5,6 };
; 1097 :    int *mymap = (y != 0) ? mapping : firstmap;

	mov	r10d, DWORD PTR y$[rsp]
	lea	rax, OFFSET FLAT:?mapping@?1??stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z@4PAHA
	test	r10d, r10d
	mov	r11, rcx

; 1098 :    int i;
; 1099 :    int type = mymap[filter_type];
; 1100 :    unsigned char *z = pixels + stride_bytes * (stbi__flip_vertically_on_write ? height-1-y : y);

	mov	ecx, DWORD PTR ?stbi__flip_vertically_on_write@@3HA
	mov	r12d, r8d
	mov	r8d, edx
	lea	rdx, OFFSET FLAT:?firstmap@?1??stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z@4PAHA
	cmovne	rdx, rax
	movsxd	rax, DWORD PTR filter_type$[rsp]
	sub	r9d, r10d
	dec	r9d
	test	ecx, ecx
	mov	ebp, DWORD PTR [rdx+rax*4]
	cmovne	r10d, r9d
	imul	r10d, r8d
	movsxd	rbx, r10d
	add	rbx, r11

; 1101 :    int signed_stride = stbi__flip_vertically_on_write ? -stride_bytes : stride_bytes;

	test	ecx, ecx
	je	SHORT $LN43@stbiw__enc
	neg	r8d
$LN43@stbiw__enc:

; 1102 : 
; 1103 :    if (type==0) {

	test	ebp, ebp
	jne	SHORT $LN27@stbiw__enc

; 1104 :       memcpy(line_buffer, z, width*n);

	mov	rcx, QWORD PTR line_buffer$[rsp]
	lea	eax, DWORD PTR [r12*4]
	movsxd	r8, eax
	mov	rdx, rbx

; 1126 :    }
; 1127 : }

	add	rsp, 48					; 00000030H
	pop	r12
	pop	rbp
	pop	rbx

; 1104 :       memcpy(line_buffer, z, width*n);

	jmp	memcpy
$LN27@stbiw__enc:
	mov	QWORD PTR [rsp+88], rsi

; 1105 :       return;
; 1106 :    }
; 1107 : 
; 1108 :    // first loop isn't optimized since it's just one pixel
; 1109 :    for (i = 0; i < n; ++i) {

	lea	rdx, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [rsp+96], rdi
	dec	ebp
	mov	QWORD PTR [rsp+104], r13
	mov	rdi, rbx
	mov	QWORD PTR [rsp+40], r14
	mov	r13d, 4
	movsxd	r14, r8d
	mov	QWORD PTR [rsp+32], r15
	mov	r15, QWORD PTR line_buffer$[rsp]
	mov	QWORD PTR tv1915[rsp], r14
	mov	rsi, r15
	neg	r14
	sub	rsi, rbx
$LL4@stbiw__enc:

; 1110 :       switch (type) {

	cmp	ebp, 5
	ja	SHORT $LN2@stbiw__enc
	movsxd	rax, ebp
	mov	ecx, DWORD PTR $LN75@stbiw__enc[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN29@stbiw__enc:

; 1111 :          case 1: line_buffer[i] = z[i]; break;
; 1112 :          case 2: line_buffer[i] = z[i] - z[i-signed_stride]; break;

	movzx	eax, BYTE PTR [rdi]
	sub	al, BYTE PTR [r14+rdi]
	jmp	SHORT $LN91@stbiw__enc
$LN30@stbiw__enc:

; 1113 :          case 3: line_buffer[i] = z[i] - (z[i-signed_stride]>>1); break;

	movzx	ecx, BYTE PTR [r14+rdi]
	movzx	eax, BYTE PTR [rdi]
	shr	cl, 1
	sub	al, cl
	jmp	SHORT $LN91@stbiw__enc
$LN31@stbiw__enc:

; 1114 :          case 4: line_buffer[i] = (signed char) (z[i] - stbiw__paeth(0,z[i-signed_stride],0)); break;

	movzx	edx, BYTE PTR [r14+rdi]
	xor	r8d, r8d
	xor	ecx, ecx
	call	?stbiw__paeth@@YAEHHH@Z			; stbiw__paeth
	movzx	ecx, BYTE PTR [rdi]
	lea	rdx, OFFSET FLAT:__ImageBase
	sub	cl, al
	mov	BYTE PTR [rsi+rdi], cl
	jmp	SHORT $LN2@stbiw__enc
$LN33@stbiw__enc:

; 1105 :       return;
; 1106 :    }
; 1107 : 
; 1108 :    // first loop isn't optimized since it's just one pixel
; 1109 :    for (i = 0; i < n; ++i) {

	movzx	eax, BYTE PTR [rdi]
$LN91@stbiw__enc:
	mov	BYTE PTR [rsi+rdi], al
$LN2@stbiw__enc:
	inc	rdi
	sub	r13, 1
	jne	SHORT $LL4@stbiw__enc
	mov	r13, QWORD PTR [rsp+104]

; 1115 :          case 5: line_buffer[i] = z[i]; break;
; 1116 :          case 6: line_buffer[i] = z[i]; break;
; 1117 :       }
; 1118 :    }
; 1119 :    switch (type) {

	cmp	ebp, 5
	ja	$LN90@stbiw__enc
	movsxd	rax, ebp
	mov	ecx, DWORD PTR $LN74@stbiw__enc[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN34@stbiw__enc:

; 1120 :       case 1: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - z[i-n]; break;

	lea	eax, DWORD PTR [r12*4]
	movsxd	rdx, eax
	cmp	rdx, 4
	jle	$LN90@stbiw__enc
	mov	r8, rbx
	lea	rcx, QWORD PTR [r15+4]
	sub	r8, r15
	add	rdx, -4
	npad	1
$LL11@stbiw__enc:
	movzx	eax, BYTE PTR [r8+rcx]
	lea	rcx, QWORD PTR [rcx+1]
	sub	al, BYTE PTR [rbx]
	lea	rbx, QWORD PTR [rbx+1]
	mov	BYTE PTR [rcx-1], al
	sub	rdx, 1
	jne	SHORT $LL11@stbiw__enc
	jmp	$LN90@stbiw__enc
$LN35@stbiw__enc:

; 1121 :       case 2: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - z[i-signed_stride]; break;

	lea	eax, DWORD PTR [r12*4]
	movsxd	rcx, eax
	cmp	rcx, 4
	jle	$LN90@stbiw__enc
	add	rbx, 4
	add	rcx, -4
	npad	6
$LL14@stbiw__enc:
	movzx	eax, BYTE PTR [rbx]
	sub	al, BYTE PTR [r14+rbx]
	mov	BYTE PTR [rsi+rbx], al
	lea	rbx, QWORD PTR [rbx+1]
	sub	rcx, 1
	jne	SHORT $LL14@stbiw__enc
	jmp	$LN90@stbiw__enc
$LN36@stbiw__enc:

; 1122 :       case 3: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - ((z[i-n] + z[i-signed_stride])>>1); break;

	lea	eax, DWORD PTR [r12*4]
	movsxd	r8, eax
	cmp	r8, 4
	jle	$LN90@stbiw__enc
	lea	rdx, QWORD PTR [rbx+4]
	add	r8, -4
	npad	10
$LL17@stbiw__enc:
	movzx	eax, BYTE PTR [rbx]
	lea	rbx, QWORD PTR [rbx+1]
	movzx	ecx, BYTE PTR [r14+rdx]
	lea	rdx, QWORD PTR [rdx+1]
	add	ecx, eax
	movzx	eax, BYTE PTR [rdx-1]
	shr	ecx, 1
	sub	al, cl
	mov	BYTE PTR [rsi+rdx-1], al
	sub	r8, 1
	jne	SHORT $LL17@stbiw__enc
	jmp	$LN90@stbiw__enc
$LN37@stbiw__enc:

; 1123 :       case 4: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - stbiw__paeth(z[i-n], z[i-signed_stride], z[i-signed_stride-n]); break;

	lea	eax, DWORD PTR [r12*4]
	movsxd	rsi, eax
	cmp	rsi, 4
	jle	$LN90@stbiw__enc
	mov	r12, QWORD PTR tv1915[rsp]
	mov	rdi, rbx
	sub	rdi, r12
	mov	r14, r12
	sub	r14, rbx
	add	rdi, 4
	add	r14, r15
	add	rsi, -4
	npad	6
$LL20@stbiw__enc:
	movzx	r8d, BYTE PTR [rdi-4]
	movzx	edx, BYTE PTR [rdi]
	movzx	ecx, BYTE PTR [rbx]
	call	?stbiw__paeth@@YAEHHH@Z			; stbiw__paeth
	movzx	ecx, BYTE PTR [r12+rdi]
	lea	rdi, QWORD PTR [rdi+1]
	sub	cl, al
	lea	rbx, QWORD PTR [rbx+1]
	mov	BYTE PTR [r14+rdi-1], cl
	sub	rsi, 1
	jne	SHORT $LL20@stbiw__enc
	jmp	$LN90@stbiw__enc
$LN38@stbiw__enc:

; 1124 :       case 5: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - (z[i-n]>>1); break;

	lea	eax, DWORD PTR [r12*4]
	movsxd	r8, eax
	cmp	r8, 4
	jle	SHORT $LN90@stbiw__enc
	mov	r9, rbx
	lea	rdx, QWORD PTR [r15+4]
	sub	r9, r15
	add	r8, -4
	npad	2
$LL23@stbiw__enc:
	movzx	ecx, BYTE PTR [rbx]
	lea	rbx, QWORD PTR [rbx+1]
	movzx	eax, BYTE PTR [r9+rdx]
	lea	rdx, QWORD PTR [rdx+1]
	shr	cl, 1
	sub	al, cl
	mov	BYTE PTR [rdx-1], al
	sub	r8, 1
	jne	SHORT $LL23@stbiw__enc
	jmp	SHORT $LN90@stbiw__enc
$LN39@stbiw__enc:

; 1125 :       case 6: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - stbiw__paeth(z[i-n], 0,0); break;

	lea	eax, DWORD PTR [r12*4]
	movsxd	rsi, eax
	cmp	rsi, 4
	jle	SHORT $LN90@stbiw__enc
	mov	r14, rbx
	lea	rdi, QWORD PTR [r15+4]
	sub	r14, r15
	add	rsi, -4
	npad	2
$LL26@stbiw__enc:
	movzx	ecx, BYTE PTR [rbx]
	xor	r8d, r8d
	xor	edx, edx
	call	?stbiw__paeth@@YAEHHH@Z			; stbiw__paeth
	movzx	ecx, BYTE PTR [r14+rdi]
	lea	rdi, QWORD PTR [rdi+1]
	sub	cl, al
	lea	rbx, QWORD PTR [rbx+1]
	mov	BYTE PTR [rdi-1], cl
	sub	rsi, 1
	jne	SHORT $LL26@stbiw__enc
$LN90@stbiw__enc:
	mov	r14, QWORD PTR [rsp+40]
	mov	rdi, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+88]
	mov	r15, QWORD PTR [rsp+32]

; 1126 :    }
; 1127 : }

	add	rsp, 48					; 00000030H
	pop	r12
	pop	rbp
	pop	rbx
	ret	0
	npad	2
$LN75@stbiw__enc:
	DD	$LN33@stbiw__enc
	DD	$LN29@stbiw__enc
	DD	$LN30@stbiw__enc
	DD	$LN31@stbiw__enc
	DD	$LN33@stbiw__enc
	DD	$LN33@stbiw__enc
$LN74@stbiw__enc:
	DD	$LN34@stbiw__enc
	DD	$LN35@stbiw__enc
	DD	$LN36@stbiw__enc
	DD	$LN37@stbiw__enc
	DD	$LN38@stbiw__enc
	DD	$LN39@stbiw__enc
?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z ENDP	; stbiw__encode_png_line
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image_write.h
;	COMDAT stbi_write_png_to_mem
_TEXT	SEGMENT
y$GSCopy$1$ = 64
stride_bytes$GSCopy$1$ = 68
x$GSCopy$1$ = 72
tv2587 = 76
tv2730 = 80
pixels$GSCopy$1$ = 88
filt$1$ = 96
out_len$GSCopy$1$ = 104
zlen$ = 112
sig$ = 120
__$ArrayPad$ = 128
pixels$ = 224
stride_bytes$ = 232
x$ = 240
y$ = 248
n$dead$ = 256
out_len$ = 264
stbi_write_png_to_mem PROC				; COMDAT

; 1130 : {

$LN121:
	push	rbx
	push	rbp
	push	rsi
	push	r12
	push	r14
	push	r15
	sub	rsp, 168				; 000000a8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rax, QWORD PTR out_len$[rsp]
	mov	r14d, r8d
	mov	QWORD PTR out_len$GSCopy$1$[rsp], rax

; 1131 :    int force_filter = stbi_write_force_png_filter;
; 1132 :    int ctype[5] = { -1, 0, 4, 2, 6 };
; 1133 :    unsigned char sig[8] = { 137,80,78,71,13,10,26,10 };

	lea	ebp, DWORD PTR [r8*4]
	mov	DWORD PTR y$GSCopy$1$[rsp], r9d
	mov	DWORD PTR x$GSCopy$1$[rsp], r8d
	mov	DWORD PTR stride_bytes$GSCopy$1$[rsp], edx
	mov	QWORD PTR pixels$GSCopy$1$[rsp], rcx
	mov	DWORD PTR sig$[rsp], 1196314761		; 474e5089H
	mov	DWORD PTR sig$[rsp+4], 169478669	; 0a1a0a0dH

; 1134 :    unsigned char *out,*o, *filt, *zlib;
; 1135 :    signed char *line_buffer;
; 1136 :    int j,zlen;
; 1137 : 
; 1138 :    if (stride_bytes == 0)

	test	edx, edx
	jne	SHORT $LN96@stbi_write

; 1139 :       stride_bytes = x * n;

	mov	DWORD PTR stride_bytes$GSCopy$1$[rsp], ebp
$LN96@stbi_write:

; 1140 : 
; 1141 :    if (force_filter >= 5) {
; 1142 :       force_filter = -1;
; 1143 :    }
; 1144 : 
; 1145 :    filt = (unsigned char *) STBIW_MALLOC((x*n+1) * y); if (!filt) return 0;

	lea	r15d, DWORD PTR [rbp+1]
	mov	QWORD PTR [rsp+160], rdi
	mov	eax, r9d
	mov	DWORD PTR tv2730[rsp], r15d
	mul	r15d
	mov	rbx, -1
	mov	ecx, eax
	cmovo	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR filt$1$[rsp], rax
	mov	r12, rax
	test	rax, rax
	je	SHORT $LN98@stbi_write

; 1146 :    line_buffer = (signed char *) STBIW_MALLOC(x * n); if (!line_buffer) { STBIW_FREE(filt); return 0; }

	mov	eax, 4
	mul	r14d
	mov	ecx, eax
	cmovo	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	rbx, rax
	test	rax, rax
	jne	SHORT $LN14@stbi_write
	mov	rcx, r12
	call	QWORD PTR __imp_free
$LN98@stbi_write:

; 1213 : }

	xor	eax, eax
$LN1@stbi_write:
	mov	rdi, QWORD PTR [rsp+160]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 168				; 000000a8H
	pop	r15
	pop	r14
	pop	r12
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN14@stbi_write:

; 1147 :    for (j=0; j < y; ++j) {

	mov	eax, DWORD PTR y$GSCopy$1$[rsp]
	xor	edi, edi
	mov	QWORD PTR [rsp+152], r13
	mov	r13d, edi
	test	eax, eax
	jle	$LN3@stbi_write
	movsxd	r14, ebp
	mov	DWORD PTR tv2587[rsp], edi
	npad	3
$LL4@stbi_write:

; 1148 :       int filter_type;
; 1149 :       if (force_filter > -1) {
; 1150 :          filter_type = force_filter;
; 1151 :          stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, force_filter, line_buffer);
; 1152 :       } else { // Estimate the best filter by running through all of them:
; 1153 :          int best_filter = 0, best_filter_val = 0x7fffffff, est, i;

	mov	r12d, edi
	mov	r15d, 2147483647			; 7fffffffH

; 1154 :          for (filter_type = 0; filter_type < 5; filter_type++) {

	mov	esi, edi
	npad	5
$LL7@stbi_write:

; 1155 :             stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, filter_type, line_buffer);

	mov	r8d, DWORD PTR x$GSCopy$1$[rsp]
	mov	r9d, eax
	mov	edx, DWORD PTR stride_bytes$GSCopy$1$[rsp]
	mov	rcx, QWORD PTR pixels$GSCopy$1$[rsp]
	mov	QWORD PTR [rsp+56], rbx
	mov	DWORD PTR [rsp+48], esi
	mov	DWORD PTR [rsp+32], r13d
	call	?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z ; stbiw__encode_png_line

; 1156 : 
; 1157 :             // Estimate the entropy of the line using this filter; the less, the better.
; 1158 :             est = 0;

	mov	r10d, edi
	mov	rcx, rdi

; 1159 :             for (i = 0; i < x*n; ++i) {

	test	ebp, ebp
	jle	$LN56@stbi_write
	cmp	ebp, 8
	jb	SHORT $LN56@stbi_write

; 1155 :             stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, filter_type, line_buffer);

	cmp	DWORD PTR __isa_available, 2
	jl	SHORT $LN56@stbi_write

; 1160 :                est += abs((signed char) line_buffer[i]);

	mov	edx, ebp
	xorps	xmm3, xmm3
	xorps	xmm4, xmm4
	and	edx, -2147483641			; ffffffff80000007H
	jge	SHORT $LN101@stbi_write
	dec	edx
	or	edx, -8
	inc	edx
$LN101@stbi_write:
	mov	eax, ebp
	sub	eax, edx
	movsxd	rdx, eax
	npad	2
$LL10@stbi_write:
	pmovsxbd xmm1, DWORD PTR [rcx+rbx]
	pabsd	xmm2, xmm1
	pmovsxbd xmm1, DWORD PTR [rcx+rbx+4]
	paddd	xmm3, xmm2
	add	rcx, 8
	pabsd	xmm2, xmm1
	paddd	xmm2, xmm4
	movdqa	xmm4, xmm2
	cmp	rcx, rdx
	jl	SHORT $LL10@stbi_write

; 1155 :             stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, filter_type, line_buffer);

	paddd	xmm3, xmm2
	movdqa	xmm0, xmm3
	psrldq	xmm0, 8
	paddd	xmm3, xmm0
	movdqa	xmm0, xmm3
	psrldq	xmm0, 4
	paddd	xmm3, xmm0
	movd	r10d, xmm3
$LN56@stbi_write:

; 1159 :             for (i = 0; i < x*n; ++i) {

	mov	r8d, edi
	mov	r9d, edi
	cmp	rcx, r14
	jge	SHORT $LN84@stbi_write
	mov	rax, r14
	sub	rax, rcx
	cmp	rax, 2
	jl	SHORT $LN97@stbi_write
	lea	r11, QWORD PTR [r14-1]
	npad	6
$LL87@stbi_write:

; 1160 :                est += abs((signed char) line_buffer[i]);

	movsx	eax, BYTE PTR [rcx+rbx]
	cdq
	xor	eax, edx
	sub	eax, edx
	add	r8d, eax
	movsx	eax, BYTE PTR [rcx+rbx+1]
	cdq
	add	rcx, 2
	xor	eax, edx
	sub	eax, edx
	add	r9d, eax
	cmp	rcx, r11
	jl	SHORT $LL87@stbi_write

; 1159 :             for (i = 0; i < x*n; ++i) {

	cmp	rcx, r14
	jge	SHORT $LN86@stbi_write
$LN97@stbi_write:

; 1160 :                est += abs((signed char) line_buffer[i]);

	movsx	eax, BYTE PTR [rcx+rbx]
	cdq
	xor	eax, edx
	sub	eax, edx
	add	r10d, eax
$LN86@stbi_write:
	lea	eax, DWORD PTR [r9+r8]
	add	r10d, eax
$LN84@stbi_write:

; 1154 :          for (filter_type = 0; filter_type < 5; filter_type++) {

	cmp	r10d, r15d
	mov	eax, esi
	cmovge	eax, r12d
	inc	esi
	cmp	r10d, r15d
	mov	r12d, eax
	mov	eax, DWORD PTR y$GSCopy$1$[rsp]
	cmovge	r10d, r15d
	mov	r15d, r10d
	cmp	esi, 5
	jl	$LL7@stbi_write

; 1161 :             }
; 1162 :             if (est < best_filter_val) {
; 1163 :                best_filter_val = est;
; 1164 :                best_filter = filter_type;
; 1165 :             }
; 1166 :          }
; 1167 :          if (filter_type != best_filter) {  // If the last iteration already got us the best filter, don't redo it

	cmp	esi, r12d
	je	SHORT $LN18@stbi_write

; 1168 :             stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, best_filter, line_buffer);

	mov	r8d, DWORD PTR x$GSCopy$1$[rsp]
	mov	r9d, eax
	mov	edx, DWORD PTR stride_bytes$GSCopy$1$[rsp]
	mov	rcx, QWORD PTR pixels$GSCopy$1$[rsp]
	mov	QWORD PTR [rsp+56], rbx
	mov	DWORD PTR [rsp+48], r12d
	mov	DWORD PTR [rsp+32], r13d
	call	?stbiw__encode_png_line@@YAXPEAEHHHHHHPEAC@Z ; stbiw__encode_png_line

; 1169 :             filter_type = best_filter;

	mov	esi, r12d
$LN18@stbi_write:

; 1170 :          }
; 1171 :       }
; 1172 :       // when we get here, filter_type contains the filter type, and line_buffer contains the data
; 1173 :       filt[j*(x*n+1)] = (unsigned char) filter_type;

	mov	r12, QWORD PTR filt$1$[rsp]

; 1174 :       STBIW_MEMMOVE(filt+j*(x*n+1)+1, line_buffer, x*n);

	mov	r8, r14
	movsxd	r15, DWORD PTR tv2587[rsp]
	mov	rdx, rbx
	lea	rcx, QWORD PTR [r12+1]
	add	rcx, r15
	mov	BYTE PTR [r15+r12], sil
	call	memmove
	lea	eax, DWORD PTR [rbp+1]
	inc	r13d
	add	r15d, eax
	mov	eax, DWORD PTR y$GSCopy$1$[rsp]
	mov	DWORD PTR tv2587[rsp], r15d
	cmp	r13d, eax
	jl	$LL4@stbi_write
	mov	r14d, DWORD PTR x$GSCopy$1$[rsp]
	mov	r15d, DWORD PTR tv2730[rsp]
$LN3@stbi_write:

; 1175 :    }
; 1176 :    STBIW_FREE(line_buffer);

	mov	rcx, rbx
	call	QWORD PTR __imp_free

; 1177 :    zlib = stbi_zlib_compress(filt, y*( x*n+1), &zlen, stbi_write_png_compression_level);

	mov	esi, DWORD PTR y$GSCopy$1$[rsp]
	lea	r8, QWORD PTR zlen$[rsp]
	imul	r15d, esi
	mov	r9d, 8
	mov	rcx, r12
	mov	edx, r15d
	call	stbi_zlib_compress

; 1178 :    STBIW_FREE(filt);

	mov	rcx, r12
	mov	rbp, rax
	call	QWORD PTR __imp_free
	mov	r13, QWORD PTR [rsp+152]

; 1179 :    if (!zlib) return 0;

	test	rbp, rbp
	je	$LN98@stbi_write

; 1180 : 
; 1181 :    // each tag requires 12 bytes of overhead
; 1182 :    out = (unsigned char *) STBIW_MALLOC(8 + 12+13 + 12+zlen + 12);

	mov	ecx, DWORD PTR zlen$[rsp]
	mov	rax, -1
	add	ecx, 45					; 0000002dH
	add	ecx, 12
	cmovb	rcx, rax
	call	QWORD PTR __imp_malloc
	mov	r15, rax

; 1183 :    if (!out) return 0;

	test	rax, rax
	je	$LN98@stbi_write

; 1184 :    *out_len = 8 + 12+13 + 12+zlen + 12;

	mov	eax, DWORD PTR zlen$[rsp]

; 1193 :    *o++ = STBIW_UCHAR(ctype[n]);

	lea	rbx, QWORD PTR [r15+26]
	mov	rcx, QWORD PTR out_len$GSCopy$1$[rsp]
	add	eax, 57					; 00000039H
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR sig$[rsp]
	mov	QWORD PTR [r15], rax
	mov	eax, r14d
	sar	eax, 24
	mov	BYTE PTR [r15+16], al
	mov	eax, r14d
	sar	eax, 16
	mov	BYTE PTR [r15+17], al
	mov	eax, r14d
	sar	eax, 8
	mov	BYTE PTR [r15+18], al
	mov	eax, esi
	sar	eax, 24
	mov	BYTE PTR [r15+20], al
	mov	eax, esi
	sar	eax, 16
	mov	BYTE PTR [r15+21], al
	mov	eax, esi
	sar	eax, 8
	mov	BYTE PTR [r15+22], al
	mov	BYTE PTR [r15+23], sil

; 1069 :       crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)];

	lea	rsi, OFFSET FLAT:?crc_table@?1??stbiw__crc32@@YAIPEAEH@Z@4PAIA

; 1185 : 
; 1186 :    o=out;
; 1187 :    STBIW_MEMMOVE(o,sig,8); o+= 8;
; 1188 :    stbiw__wp32(o, 13); // header length

	mov	DWORD PTR [r15+8], 218103808		; 0d000000H

; 1189 :    stbiw__wptag(o, "IHDR");

	mov	DWORD PTR [r15+12], 1380206665		; 52444849H

; 1190 :    stbiw__wp32(o, x);

	mov	BYTE PTR [r15+19], r14b

; 1191 :    stbiw__wp32(o, y);
; 1192 :    *o++ = 8;

	mov	DWORD PTR [r15+24], 1544		; 00000608H

; 1194 :    *o++ = 0;
; 1195 :    *o++ = 0;
; 1196 :    *o++ = 0;

	mov	BYTE PTR [r15+28], dil

; 1069 :       crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)];

	movzx	eax, BYTE PTR [r15+12]
	not	al
	movzx	ecx, al
	movzx	eax, BYTE PTR [rbx-13]
	mov	edx, DWORD PTR [rsi+rcx*4]
	xor	edx, 16777215				; 00ffffffH
	movzx	ecx, dl
	xor	rcx, rax
	shr	edx, 8
	movzx	eax, BYTE PTR [rbx-12]
	xor	edx, DWORD PTR [rsi+rcx*4]
	movzx	ecx, dl
	xor	rcx, rax
	shr	edx, 8
	movzx	eax, BYTE PTR [rbx-11]
	xor	edx, DWORD PTR [rsi+rcx*4]
	movzx	ecx, dl
	xor	rcx, rax
	shr	edx, 8
	movzx	eax, BYTE PTR [rbx-10]
	xor	edx, DWORD PTR [rsi+rcx*4]
	movzx	ecx, dl
	xor	rcx, rax
	shr	edx, 8
	movzx	eax, BYTE PTR [rbx-9]
	xor	edx, DWORD PTR [rsi+rcx*4]
	movzx	ecx, dl
	xor	rcx, rax
	shr	edx, 8
	movzx	eax, BYTE PTR [rbx-8]
	xor	edx, DWORD PTR [rsi+rcx*4]
	movzx	ecx, dl
	xor	rcx, rax
	shr	edx, 8
	movzx	eax, BYTE PTR [rbx-7]
	xor	edx, DWORD PTR [rsi+rcx*4]
	movzx	ecx, dl
	xor	rcx, rax
	shr	edx, 8
	movzx	eax, BYTE PTR [rbx-6]
	xor	edx, DWORD PTR [rsi+rcx*4]
	movzx	ecx, dl
	xor	rcx, rax
	shr	edx, 8
	movzx	eax, BYTE PTR [rbx-5]
	xor	edx, DWORD PTR [rsi+rcx*4]
	movzx	ecx, dl
	xor	rcx, rax
	shr	edx, 8
	xor	edx, DWORD PTR [rsi+rcx*4]
	movzx	eax, BYTE PTR [rbx-4]
	movzx	ecx, dl
	xor	rcx, rax
	shr	edx, 8
	movzx	eax, BYTE PTR [rbx-3]
	xor	edx, DWORD PTR [rsi+rcx*4]
	movzx	ecx, dl
	xor	rcx, rax
	shr	edx, 8
	movzx	eax, BYTE PTR [rbx-2]
	xor	edx, DWORD PTR [rsi+rcx*4]
	movzx	ecx, dl
	xor	rcx, rax
	shr	edx, 8
	xor	edx, DWORD PTR [rsi+rcx*4]
	mov	eax, edx
	shr	edx, 8
	xor	rax, 6
	movzx	ecx, al
	xor	edx, DWORD PTR [rsi+rcx*4]
	movzx	ecx, dl
	shr	edx, 8
	xor	edx, DWORD PTR [rsi+rcx*4]
	movzx	ecx, dl
	shr	edx, 8
	xor	edx, DWORD PTR [rsi+rcx*4]
	movzx	ecx, dl
	shr	edx, 8
	xor	edx, DWORD PTR [rsi+rcx*4]

; 1070 :    return ~crc;

	not	edx

; 1081 :    stbiw__wp32(*data, crc);

	mov	BYTE PTR [rbx+6], dl
	mov	eax, edx
	shr	eax, 24
	mov	BYTE PTR [rbx+3], al
	mov	eax, edx
	shr	eax, 16
	mov	BYTE PTR [rbx+4], al
	mov	eax, edx
	shr	eax, 8

; 1201 :    STBIW_MEMMOVE(o, zlib, zlen);

	mov	rdx, rbp

; 1081 :    stbiw__wp32(*data, crc);

	mov	BYTE PTR [rbx+5], al

; 1197 :    stbiw__wpcrc(&o,13);
; 1198 : 
; 1199 :    stbiw__wp32(o, zlen);

	mov	eax, DWORD PTR zlen$[rsp]
	sar	eax, 24
	mov	BYTE PTR [rbx+7], al
	mov	eax, DWORD PTR zlen$[rsp]
	sar	eax, 16
	mov	BYTE PTR [rbx+8], al
	mov	eax, DWORD PTR zlen$[rsp]
	sar	eax, 8
	mov	BYTE PTR [rbx+9], al
	movzx	eax, BYTE PTR zlen$[rsp]
	mov	BYTE PTR [rbx+10], al

; 1200 :    stbiw__wptag(o, "IDAT");

	mov	DWORD PTR [rbx+11], 1413563465		; 54414449H
	add	rbx, 15

; 1201 :    STBIW_MEMMOVE(o, zlib, zlen);

	movsxd	r8, DWORD PTR zlen$[rsp]
	mov	rcx, rbx
	call	memmove

; 1202 :    o += zlen;

	movsxd	rax, DWORD PTR zlen$[rsp]

; 1203 :    STBIW_FREE(zlib);

	mov	rcx, rbp
	add	rbx, rax
	call	QWORD PTR __imp_free

; 1080 :    unsigned int crc = stbiw__crc32(*data - len - 4, len+4);

	movsxd	rcx, DWORD PTR zlen$[rsp]

; 1066 :    unsigned int crc = ~0u;

	mov	r8d, -1					; ffffffffH

; 1080 :    unsigned int crc = stbiw__crc32(*data - len - 4, len+4);

	lea	eax, DWORD PTR [rcx+4]

; 1068 :    for (i=0; i < len; ++i)

	movsxd	r10, eax
	test	eax, eax
	jle	SHORT $LN33@stbi_write
	mov	rax, rbx
	sub	rax, rcx
	npad	14
$LL34@stbi_write:

; 1069 :       crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)];

	movzx	edx, BYTE PTR [rdi+rax-4]
	inc	rdi
	movzx	ecx, r8b
	xor	rdx, rcx
	shr	r8d, 8
	xor	r8d, DWORD PTR [rsi+rdx*4]
	cmp	rdi, r10
	jl	SHORT $LL34@stbi_write
$LN33@stbi_write:
	mov	rdx, QWORD PTR ?crc_table@?1??stbiw__crc32@@YAIPEAEH@Z@4PAIA+728

; 1070 :    return ~crc;

	not	r8d

; 1069 :       crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)];

	xor	edx, 16777215				; 00ffffffH

; 1081 :    stbiw__wp32(*data, crc);

	mov	BYTE PTR [rbx+3], r8b

; 1069 :       crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)];

	movzx	ecx, dl

; 1081 :    stbiw__wp32(*data, crc);

	mov	eax, r8d
	shr	eax, 24
	mov	BYTE PTR [rbx], al
	mov	eax, r8d
	shr	eax, 16
	mov	BYTE PTR [rbx+1], al
	mov	eax, r8d

; 1204 :    stbiw__wpcrc(&o, zlen);
; 1205 : 
; 1206 :    stbiw__wp32(o,0);

	mov	DWORD PTR [rbx+4], 0

; 1207 :    stbiw__wptag(o, "IEND");

	mov	DWORD PTR [rbx+8], 1145980233		; 444e4549H

; 1069 :       crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)];

	shr	edx, 8

; 1081 :    stbiw__wp32(*data, crc);

	shr	eax, 8
	mov	BYTE PTR [rbx+2], al

; 1069 :       crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)];

	movzx	eax, BYTE PTR [rbx+9]
	xor	rcx, rax
	movzx	eax, BYTE PTR [rbx+10]
	xor	edx, DWORD PTR [rsi+rcx*4]
	movzx	ecx, dl
	xor	rcx, rax
	shr	edx, 8
	movzx	eax, BYTE PTR [rbx+11]
	xor	edx, DWORD PTR [rsi+rcx*4]
	movzx	ecx, dl
	xor	rcx, rax
	shr	edx, 8

; 1208 :    stbiw__wpcrc(&o,0);
; 1209 : 
; 1210 :    STBIW_ASSERT(o == out + *out_len);
; 1211 : 
; 1212 :    return out;

	mov	rax, r15

; 1069 :       crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)];

	xor	edx, DWORD PTR [rsi+rcx*4]

; 1070 :    return ~crc;

	not	edx

; 1081 :    stbiw__wp32(*data, crc);

	mov	ecx, edx
	mov	BYTE PTR [rbx+15], dl
	shr	ecx, 24
	mov	BYTE PTR [rbx+12], cl
	mov	ecx, edx
	shr	ecx, 16
	mov	BYTE PTR [rbx+13], cl
	mov	ecx, edx
	shr	ecx, 8
	mov	BYTE PTR [rbx+14], cl

; 1208 :    stbiw__wpcrc(&o,0);
; 1209 : 
; 1210 :    STBIW_ASSERT(o == out + *out_len);
; 1211 : 
; 1212 :    return out;

	jmp	$LN1@stbi_write
stbi_write_png_to_mem ENDP
_TEXT	ENDS
END
