; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0O@DJKIKBBP@?$CL?$CD?$CDSequential@	; `string'
PUBLIC	??_C@_0O@MBGKOKKJ@?9?$CD?$CDSequential@		; `string'
PUBLIC	??_R4UIAINBNodeSequential@@6B@			; UIAINBNodeSequential::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@UIAINBNodeSequential@@8		; UIAINBNodeSequential::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3UIAINBNodeSequential@@8			; UIAINBNodeSequential::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7UIAINBNodeSequential@@6B@			; UIAINBNodeSequential::`vftable'
PUBLIC	??_R2UIAINBNodeSequential@@8			; UIAINBNodeSequential::`RTTI Base Class Array'
PUBLIC	??_R0?AVUIAINBNodeSequential@@@8		; UIAINBNodeSequential `RTTI Type Descriptor'
;	COMDAT ??_R0?AVUIAINBNodeSequential@@@8
data$rs	SEGMENT
??_R0?AVUIAINBNodeSequential@@@8 DQ FLAT:??_7type_info@@6B@ ; UIAINBNodeSequential `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVUIAINBNodeSequential@@', 00H
data$rs	ENDS
;	COMDAT ??_R2UIAINBNodeSequential@@8
rdata$r	SEGMENT
??_R2UIAINBNodeSequential@@8 DD imagerel ??_R1A@?0A@EA@UIAINBNodeSequential@@8 ; UIAINBNodeSequential::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@UIAINBNodeBase@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7UIAINBNodeSequential@@6B@
CONST	SEGMENT
??_7UIAINBNodeSequential@@6B@ DQ FLAT:??_R4UIAINBNodeSequential@@6B@ ; UIAINBNodeSequential::`vftable'
	DQ	FLAT:?Render@UIAINBNodeSequential@@UEAAXXZ
	DQ	FLAT:?RebuildNode@UIAINBNodeSequential@@UEAAXXZ
	DQ	FLAT:?UpdateVisuals@UIAINBNodeSequential@@UEAAXXZ
	DQ	FLAT:?PostProcessLinkedNodeInfo@UIAINBNodeBase@@UEAAXAEAUPin@1@AEAULinkedNodeInfo@AINBFile@@@Z
	DQ	FLAT:?PostProcessNode@UIAINBNodeBase@@UEAAXXZ
	DQ	FLAT:?GetNodeType@UIAINBNodeBase@@UEAA?AW4NodeType@1@XZ
	DQ	FLAT:?RenderLinks@UIAINBNodeSequential@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
	DQ	FLAT:?GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ
	DQ	FLAT:?GetHeaderColor@UIAINBNodeSequential@@UEAA?AUImColor@@XZ
CONST	ENDS
;	COMDAT ??_R3UIAINBNodeSequential@@8
rdata$r	SEGMENT
??_R3UIAINBNodeSequential@@8 DD 00H			; UIAINBNodeSequential::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2UIAINBNodeSequential@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@UIAINBNodeSequential@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@UIAINBNodeSequential@@8 DD imagerel ??_R0?AVUIAINBNodeSequential@@@8 ; UIAINBNodeSequential::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3UIAINBNodeSequential@@8
rdata$r	ENDS
;	COMDAT ??_R4UIAINBNodeSequential@@6B@
rdata$r	SEGMENT
??_R4UIAINBNodeSequential@@6B@ DD 01H			; UIAINBNodeSequential::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVUIAINBNodeSequential@@@8
	DD	imagerel ??_R3UIAINBNodeSequential@@8
	DD	imagerel ??_R4UIAINBNodeSequential@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0O@MBGKOKKJ@?9?$CD?$CDSequential@
CONST	SEGMENT
??_C@_0O@MBGKOKKJ@?9?$CD?$CDSequential@ DB '-##Sequential', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DJKIKBBP@?$CL?$CD?$CDSequential@
CONST	SEGMENT
??_C@_0O@DJKIKBBP@?$CL?$CD?$CDSequential@ DB '+##Sequential', 00H ; `string'
PUBLIC	??$construct_at@ULinkedNodeInfo@AINBFile@@$$V$0A@@std@@YAPEAULinkedNodeInfo@AINBFile@@QEAU12@@Z ; std::construct_at<AINBFile::LinkedNodeInfo,0>
PUBLIC	??$construct@ULinkedNodeInfo@AINBFile@@$$V@?$_Default_allocator_traits@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@SAXAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@1@QEAULinkedNodeInfo@AINBFile@@@Z ; std::_Default_allocator_traits<std::allocator<AINBFile::LinkedNodeInfo> >::construct<AINBFile::LinkedNodeInfo>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<AINBFile::LinkedNodeInfo> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAPEAULinkedNodeInfo@AINBFile@@PEAU12@_KAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBFile::LinkedNodeInfo> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBFile::LinkedNodeInfo,std::allocator<AINBFile::LinkedNodeInfo> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBFile::LinkedNodeInfo,std::allocator<AINBFile::LinkedNodeInfo> >::_Resize<std::_Value_init_tag>
PUBLIC	?resize@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAX_K@Z ; std::vector<AINBFile::LinkedNodeInfo,std::allocator<AINBFile::LinkedNodeInfo> >::resize
PUBLIC	?GetHeaderColor@UIAINBNodeSequential@@UEAA?AUImColor@@XZ ; UIAINBNodeSequential::GetHeaderColor
PUBLIC	?RenderLinks@UIAINBNodeSequential@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z ; UIAINBNodeSequential::RenderLinks
PUBLIC	?Render@UIAINBNodeSequential@@UEAAXXZ		; UIAINBNodeSequential::Render
PUBLIC	?GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ ; UIAINBNodeSequential::GenerateNodeShapeInfo
PUBLIC	?UpdateVisuals@UIAINBNodeSequential@@UEAAXXZ	; UIAINBNodeSequential::UpdateVisuals
PUBLIC	?RebuildNode@UIAINBNodeSequential@@UEAAXXZ	; UIAINBNodeSequential::RebuildNode
PUBLIC	??0UIAINBNodeSequential@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z ; UIAINBNodeSequential::UIAINBNodeSequential
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@ULinkedNodeInfo@AINBFile@@$$V$0A@@std@@YAPEAULinkedNodeInfo@AINBFile@@QEAU12@@Z DD imagerel $LN4
	DD	imagerel $LN4+35
	DD	imagerel $unwind$??$construct_at@ULinkedNodeInfo@AINBFile@@$$V$0A@@std@@YAPEAULinkedNodeInfo@AINBFile@@QEAU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@ULinkedNodeInfo@AINBFile@@$$V@?$_Default_allocator_traits@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@SAXAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@1@QEAULinkedNodeInfo@AINBFile@@@Z DD imagerel $LN6
	DD	imagerel $LN6+38
	DD	imagerel $unwind$??$construct@ULinkedNodeInfo@AINBFile@@$$V@?$_Default_allocator_traits@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@SAXAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@1@QEAULinkedNodeInfo@AINBFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+60
	DD	imagerel $unwind$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAPEAULinkedNodeInfo@AINBFile@@PEAU12@_KAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+133
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAPEAULinkedNodeInfo@AINBFile@@PEAU12@_KAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN58
	DD	imagerel $LN58+259
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA DD imagerel ?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA+49
	DD	imagerel $unwind$?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28+50
	DD	imagerel $LN28+126
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28+126
	DD	imagerel $LN28+197
	DD	imagerel $chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30+50
	DD	imagerel $LN30+126
	DD	imagerel $chain$1$?resize@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30+126
	DD	imagerel $LN30+197
	DD	imagerel $chain$2$?resize@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RenderLinks@UIAINBNodeSequential@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z DD imagerel $LN59
	DD	imagerel $LN59+90
	DD	imagerel $unwind$?RenderLinks@UIAINBNodeSequential@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?RenderLinks@UIAINBNodeSequential@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z DD imagerel $LN59+90
	DD	imagerel $LN59+392
	DD	imagerel $chain$2$?RenderLinks@UIAINBNodeSequential@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?RenderLinks@UIAINBNodeSequential@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z DD imagerel $LN59+392
	DD	imagerel $LN59+416
	DD	imagerel $chain$3$?RenderLinks@UIAINBNodeSequential@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Render@UIAINBNodeSequential@@UEAAXXZ DD imagerel $LN1210
	DD	imagerel $LN1210+3912
	DD	imagerel $unwind$?Render@UIAINBNodeSequential@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$7@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA DD imagerel ?dtor$7@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA
	DD	imagerel ?dtor$7@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA+41
	DD	imagerel $unwind$?dtor$7@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$8@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA DD imagerel ?dtor$8@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA
	DD	imagerel ?dtor$8@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$8@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ DD imagerel $LN1353
	DD	imagerel $LN1353+3528
	DD	imagerel $unwind$?GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA DD imagerel ?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA
	DD	imagerel ?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA DD imagerel ?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA
	DD	imagerel ?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA DD imagerel ?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA
	DD	imagerel ?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA DD imagerel ?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA
	DD	imagerel ?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RebuildNode@UIAINBNodeSequential@@UEAAXXZ DD imagerel $LN113
	DD	imagerel $LN113+381
	DD	imagerel $unwind$?RebuildNode@UIAINBNodeSequential@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0UIAINBNodeSequential@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DD imagerel $LN19
	DD	imagerel $LN19+131
	DD	imagerel $unwind$??0UIAINBNodeSequential@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0UIAINBNodeSequential@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DB 04H
	DB	01aH
	DB	00H
	DB	0ceH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0UIAINBNodeSequential@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DB 04H
	DB	0cH
	DD	imagerel ??1UIAINBNodeBase@@QEAA@XZ
	DB	080H
	DB	036H
	DD	imagerel ?dtor$1@?0???0UIAINBNodeSequential@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0UIAINBNodeSequential@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DB 028H
	DD	imagerel $stateUnwindMap$??0UIAINBNodeSequential@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
	DD	imagerel $ip2state$??0UIAINBNodeSequential@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0UIAINBNodeSequential@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DD 020a11H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0UIAINBNodeSequential@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RebuildNode@UIAINBNodeSequential@@UEAAXXZ DD 0a1601H
	DD	0c5416H
	DD	0b3416H
	DD	0f0123216H
	DD	0d00ee010H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ DB 01cH
	DB	0feH
	DB	00H
	DB	0a9H, 07H
	DB	02H
	DB	'=', 03H
	DB	00H
	DB	0bcH
	DB	04H
	DB	'0'
	DB	06H
	DB	0b6H
	DB	08H
	DB	081H, 0cH
	DB	00H
	DB	'%', 08H
	DB	0cH
	DB	'.'
	DB	0eH
	DB	0b4H
	DB	010H
	DB	'm', 0fH
	DB	0cH
	DB	0cH
	DB	00H
	DB	0cH
	DB	04H
	DB	0cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ DB 010H
	DB	0eH
	DD	imagerel ?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	02H
	DB	0ceH
	DD	imagerel ?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ
	DD	imagerel $ip2state$?GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ DD 01d5511H
	DD	017d855H
	DD	018c84dH
	DD	019b845H
	DD	01aa83dH
	DD	01b9838H
	DD	01c8833H
	DD	01d782eH
	DD	01e682aH
	DD	0477426H
	DD	0466426H
	DD	0453426H
	DD	03e0126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$8@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$7@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Render@UIAINBNodeSequential@@UEAAXXZ DB '$'
	DB	'u', 02H
	DB	00H
	DB	']', 06H
	DB	02H
	DB	'('
	DB	00H
	DB	'q', 07H
	DB	04H
	DB	090H
	DB	08H
	DB	0cdH, 0bH
	DB	00H
	DB	0d9H, 02H
	DB	02H
	DB	096H
	DB	0aH
	DB	'B'
	DB	02H
	DB	')', 02H
	DB	00H
	DB	08eH
	DB	0cH
	DB	0a8H
	DB	0eH
	DB	'v'
	DB	0cH
	DB	0cdH, 07H
	DB	00H
	DB	'M', 03H
	DB	02H
	DB	'=', 04H
	DB	00H
	DB	'5', 04H
	DB	08H
	DB	0cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Render@UIAINBNodeSequential@@UEAAXXZ DB 0eH
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	04H
	DB	042H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	04H
	DB	0aaH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	04H
	DB	0daH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a0H
	DB	02dH
	DB	02H
	DD	imagerel ?dtor$7@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA
	DB	036H
	DD	imagerel ?dtor$8@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?Render@UIAINBNodeSequential@@UEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?Render@UIAINBNodeSequential@@UEAAXXZ
	DD	imagerel $ip2state$?Render@UIAINBNodeSequential@@UEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Render@UIAINBNodeSequential@@UEAAXXZ DD 01d6319H
	DD	016d855H
	DD	017c84dH
	DD	018b845H
	DD	019a83dH
	DD	01a9838H
	DD	01b8833H
	DD	01c782eH
	DD	01d682aH
	DD	0457426H
	DD	0446426H
	DD	0433426H
	DD	03c0126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?Render@UIAINBNodeSequential@@UEAAXXZ
	DD	015aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?RenderLinks@UIAINBNodeSequential@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z DD 021H
	DD	imagerel $LN59
	DD	imagerel $LN59+90
	DD	imagerel $unwind$?RenderLinks@UIAINBNodeSequential@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?RenderLinks@UIAINBNodeSequential@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z DD 061021H
	DD	076810H
	DD	017f40bH
	DD	0166404H
	DD	imagerel $LN59
	DD	imagerel $LN59+90
	DD	imagerel $unwind$?RenderLinks@UIAINBNodeSequential@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RenderLinks@UIAINBNodeSequential@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z DD 081601H
	DD	0183416H
	DD	0e00ff216H
	DD	0c00bd00dH
	DD	050087009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAX_K@Z DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAX_K@Z DD 040b01H
	DD	08740bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040b01H
	DD	08740bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 06H
	DB	0ecH
	DB	00H
	DB	'T'
	DB	02H
	DB	0baH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
	DD	imagerel $tryMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
	DD	imagerel $ip2state$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 081119H
	DD	0103411H
	DD	0f00d7211H
	DD	0c009e00bH
	DD	060067007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_value_construct_n@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAPEAULinkedNodeInfo@AINBFile@@PEAU12@_KAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z DB 04H
	DB	0a6H
	DB	02H
	DB	'D'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_value_construct_n@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAPEAULinkedNodeInfo@AINBFile@@PEAU12@_KAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_value_construct_n@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAPEAULinkedNodeInfo@AINBFile@@PEAU12@_KAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_value_construct_n@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAPEAULinkedNodeInfo@AINBFile@@PEAU12@_KAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_value_construct_n@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAPEAULinkedNodeInfo@AINBFile@@PEAU12@_KAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAPEAULinkedNodeInfo@AINBFile@@PEAU12@_KAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z DD 041919H
	DD	0a340aH
	DD	07006720aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_value_construct_n@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAPEAULinkedNodeInfo@AINBFile@@PEAU12@_KAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@ULinkedNodeInfo@AINBFile@@$$V@?$_Default_allocator_traits@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@SAXAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@1@QEAULinkedNodeInfo@AINBFile@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@ULinkedNodeInfo@AINBFile@@$$V$0A@@std@@YAPEAULinkedNodeInfo@AINBFile@@QEAU12@@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
;	COMDAT ??0UIAINBNodeSequential@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
_TEXT	SEGMENT
this$ = 64
Node$ = 72
EditorId$ = 80
HeaderBackground$ = 88
EnableFlow$dead$ = 96
??0UIAINBNodeSequential@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z PROC ; UIAINBNodeSequential::UIAINBNodeSequential, COMDAT

; 5    : {

$LN19:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx

; 4    :     : UIAINBNodeBase(&Node, EditorId, HeaderBackground, EnableFlow)

	call	??0UIAINBNodeBase@@QEAA@PEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z ; UIAINBNodeBase::UIAINBNodeBase
	npad	1

; 5    : {

	lea	rax, OFFSET FLAT:??_7UIAINBNodeSequential@@6B@
	mov	QWORD PTR [rbx], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.h

; 17   :     uint16_t mSeqCount = 2;

	mov	edx, 2
	mov	WORD PTR [rbx+272], dx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rbx+280], rax
	mov	QWORD PTR [rbx+288], rax
	mov	QWORD PTR [rbx+296], rax

; 1868 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rbx+8]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+448]
	sub	rcx, QWORD PTR [rax+440]
	sar	rcx, 3
	mov	rax, 8040888442386214807		; 6f96f96f96f96f97H
	imul	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 29   :     mSeqCount = std::max(2, (int)mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size());

	cmp	ecx, edx
	cmovg	dx, cx
	mov	WORD PTR [rbx+272], dx

; 6    :     UpdateVisuals();
; 7    :     GenerateNodeShapeInfo();

	mov	rcx, rbx
	call	?GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ ; UIAINBNodeSequential::GenerateNodeShapeInfo
	npad	1

; 8    : }

	mov	rax, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??0UIAINBNodeSequential@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z ENDP ; UIAINBNodeSequential::UIAINBNodeSequential
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
Node$ = 72
EditorId$ = 80
HeaderBackground$ = 88
EnableFlow$dead$ = 96
?dtor$0@?0???0UIAINBNodeSequential@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA PROC ; `UIAINBNodeSequential::UIAINBNodeSequential'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1UIAINBNodeBase@@QEAA@XZ
?dtor$0@?0???0UIAINBNodeSequential@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA ENDP ; `UIAINBNodeSequential::UIAINBNodeSequential'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
Node$ = 72
EditorId$ = 80
HeaderBackground$ = 88
EnableFlow$dead$ = 96
?dtor$1@?0???0UIAINBNodeSequential@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA PROC ; `UIAINBNodeSequential::UIAINBNodeSequential'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 280				; 00000118H
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
?dtor$1@?0???0UIAINBNodeSequential@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA ENDP ; `UIAINBNodeSequential::UIAINBNodeSequential'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
;	COMDAT ?RebuildNode@UIAINBNodeSequential@@UEAAXXZ
_TEXT	SEGMENT
$T1 = 80
this$ = 80
?RebuildNode@UIAINBNodeSequential@@UEAAXXZ PROC		; UIAINBNodeSequential::RebuildNode, COMDAT

; 11   : {

$LN113:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 12   :     mNode->Flags.clear();

	mov	rax, QWORD PTR [rcx+8]
	mov	r13, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rdx, QWORD PTR [rax+8]
	cmp	rdx, QWORD PTR [rax+16]
	je	SHORT $LN9@RebuildNod

; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [rax+16], rdx
$LN9@RebuildNod:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 13   :     mNode->Flags.push_back(AINBFile::FlagsStruct::IsResidentNode);

	mov	rcx, QWORD PTR [rcx+8]
	add	rcx, 8
	mov	BYTE PTR $T1[rsp], 6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN15@RebuildNod

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [rdx], 6

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	inc	QWORD PTR [rcx+8]

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN14@RebuildNod
$LN15@RebuildNod:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T1[rsp]
	call	??$_Emplace_reallocate@W4FlagsStruct@AINBFile@@@?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@AEAAPEAW4FlagsStruct@AINBFile@@QEAW423@$$QEAW423@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::_Emplace_reallocate<enum AINBFile::FlagsStruct>
$LN14@RebuildNod:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 15   :     for (int i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	ebp, ebp
	mov	r14d, ebp
	lea	r15d, QWORD PTR [rbp+6]
	npad	2
$LL4@RebuildNod:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r13+8]
	mov	rsi, QWORD PTR [rax+176]
	add	rsi, r14

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rbx, QWORD PTR [rsi]
	mov	rdi, QWORD PTR [rsi+8]
	cmp	rbx, rdi
	je	SHORT $LN21@RebuildNod
	npad	6
$LL27@RebuildNod:
	mov	rcx, rbx
	call	??1InputEntry@AINBFile@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 240				; 000000f0H
	cmp	rbx, rdi
	jne	SHORT $LL27@RebuildNod
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1776 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rsi]
	mov	QWORD PTR [rsi+8], rax
$LN21@RebuildNod:

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r13+8]
	mov	rsi, QWORD PTR [rax+200]
	add	rsi, r14

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rbx, QWORD PTR [rsi]
	mov	rdi, QWORD PTR [rsi+8]
	cmp	rbx, rdi
	je	SHORT $LN2@RebuildNod
$LL44@RebuildNod:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+40]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 72					; 00000048H
	cmp	rbx, rdi
	jne	SHORT $LL44@RebuildNod
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1776 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rsi]
	mov	QWORD PTR [rsi+8], rax
$LN2@RebuildNod:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 15   :     for (int i = 0; i < AINBFile::ValueTypeCount; i++) {

	add	r14, 24
	sub	r15, 1
	jne	SHORT $LL4@RebuildNod
$LL7@RebuildNod:

; 21   :         mNode->LinkedNodes[i].clear();

	mov	rsi, QWORD PTR [r13+8]
	add	rsi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rbx, QWORD PTR [rsi+392]
	mov	rdi, QWORD PTR [rsi+400]
	cmp	rbx, rdi
	je	SHORT $LN5@RebuildNod
	npad	6
$LL68@RebuildNod:
	mov	rcx, rbx
	call	??1LinkedNodeInfo@AINBFile@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 312				; 00000138H
	cmp	rbx, rdi
	jne	SHORT $LL68@RebuildNod
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1776 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rsi+392]
	mov	QWORD PTR [rsi+400], rax
$LN5@RebuildNod:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 20   :     for (int i = 0; i < 10; i++) {

	add	rbp, 24
	cmp	rbp, 240				; 000000f0H
	jl	SHORT $LL7@RebuildNod
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [r13+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 25   : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+448]
	sub	rcx, QWORD PTR [rax+440]
	mov	rax, 8040888442386214807		; 6f96f96f96f96f97H
	sar	rcx, 3
	imul	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	eax, 2
	cmp	ecx, eax
	cmovg	ax, cx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 24   :     mSeqCount = std::max(2, (int)mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size());

	mov	WORD PTR [r13+272], ax

; 25   : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	ret	0
?RebuildNode@UIAINBNodeSequential@@UEAAXXZ ENDP		; UIAINBNodeSequential::RebuildNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
;	COMDAT ?UpdateVisuals@UIAINBNodeSequential@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?UpdateVisuals@UIAINBNodeSequential@@UEAAXXZ PROC	; UIAINBNodeSequential::UpdateVisuals, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rcx+8]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rax+448]
	sub	rdx, QWORD PTR [rax+440]
	mov	rax, 8040888442386214807		; 6f96f96f96f96f97H
	sar	rdx, 3
	imul	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 29   :     mSeqCount = std::max(2, (int)mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size());

	mov	eax, 2
	cmp	edx, eax
	cmovg	ax, dx
	mov	WORD PTR [rcx+272], ax

; 30   : }

	ret	0
?UpdateVisuals@UIAINBNodeSequential@@UEAAXXZ ENDP	; UIAINBNodeSequential::UpdateVisuals
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
;	COMDAT ?GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ
_TEXT	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ PROC ; UIAINBNodeSequential::GenerateNodeShapeInfo, COMDAT

; 33   : {

$LN1353:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-280]
	sub	rsp, 496				; 000001f0H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-104], xmm9
	movaps	XMMWORD PTR [rax-120], xmm10
	movaps	XMMWORD PTR [rax-136], xmm11
	movaps	XMMWORD PTR [rax-152], xmm12
	movaps	XMMWORD PTR [rax-168], xmm13
	mov	rsi, rcx
	mov	QWORD PTR this$GSCopy$1$[rbp-256], rcx
	xor	r14d, r14d
	mov	DWORD PTR $T4[rsp], r14d

; 34   :     mNodeShapeInfo.FrameWidth = 8 * 2 + ImGui::CalcTextSize(mNode->GetName().c_str()).x + 24 + ImGui::GetStyle().ItemSpacing.x;

	mov	rdx, QWORD PTR [rcx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp

; 2908 : 	if (this->Type == (uint16_t)AINBFile::NodeTypes::UserDefined)

	movzx	eax, WORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 33   : {

	mov	ebx, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp

; 2908 : 	if (this->Type == (uint16_t)AINBFile::NodeTypes::UserDefined)

	bts	ebx, 12
	lea	rcx, QWORD PTR $T17[rbp-256]
	test	ax, ax
	jne	SHORT $LN1059@GenerateNo

; 2909 : 		return this->Name;

	add	rdx, 32					; 00000020H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	SHORT $LN1344@GenerateNo
$LN1059@GenerateNo:

; 2910 : 
; 2911 : 	return AINBFile::NodeTypeToString((AINBFile::NodeTypes)this->Type);

	movzx	edx, ax
	call	?NodeTypeToString@AINBFile@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4NodeTypes@1@@Z ; AINBFile::NodeTypeToString
$LN1344@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3085 :     return GImGui->Style;

	mov	DWORD PTR $T4[rsp], ebx
	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4107 :         return _Mypair._Myval2._Myptr();

	lea	rax, QWORD PTR $T17[rbp-256]
	mov	rdx, QWORD PTR $T17[rbp-256]
	mov	r8, QWORD PTR $T17[rbp-232]
	cmp	r8, 16
	cmovae	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5418 :     if (text == text_display_end)

	movss	xmm9, DWORD PTR __real@bf800000
	movss	xmm10, DWORD PTR __real@7f7fffff
	movss	xmm11, DWORD PTR __real@3f7fff58
	xorps	xmm7, xmm7
	test	rax, rax
	jne	SHORT $LN1041@GenerateNo
	xorps	xmm0, xmm0

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN1038@GenerateNo
$LN1041@GenerateNo:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r14
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], rax
	movss	DWORD PTR [rsp+32], xmm9
	movaps	xmm3, xmm10
	movss	xmm2, DWORD PTR [rdi+15696]
	lea	rdx, QWORD PTR text_size$9[rbp-256]
	mov	rcx, QWORD PTR [rdi+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$9[rbp-256]
	addss	xmm0, xmm11
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mov	r8, QWORD PTR $T17[rbp-232]
	mov	rdx, QWORD PTR $T17[rbp-256]
$LN1038@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 34   :     mNodeShapeInfo.FrameWidth = 8 * 2 + ImGui::CalcTextSize(mNode->GetName().c_str()).x + 24 + ImGui::GetStyle().ItemSpacing.x;

	movss	xmm8, DWORD PTR __real@41800000
	addss	xmm0, xmm8
	movss	xmm12, DWORD PTR __real@41c00000
	addss	xmm0, xmm12
	addss	xmm0, DWORD PTR [rdi+14628]
	movss	DWORD PTR [rsi+20], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	r8, 16
	jb	SHORT $LN1067@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1067@GenerateNo:

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T17[rbp-240], xmm0

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T17[rbp-256], r14b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 36   :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	r13b, r13b
	movss	xmm13, DWORD PTR __real@42000000
$LN1350@GenerateNo:

; 37   :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	lea	r9, OFFSET FLAT:__ImageBase
	mov	r11, -1
	lea	r10d, QWORD PTR [r11+23]
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
	mov	rcx, QWORD PTR [rsi+8]
	movzx	eax, r13b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rdx, QWORD PTR [rax+rax*2]
	mov	QWORD PTR tv6748[rbp-256], rdx
	mov	rax, QWORD PTR [rcx+176]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 37   :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	mov	r15, QWORD PTR [rax+rdx*8]
	mov	r12, QWORD PTR [rax+rdx*8+8]
	cmp	r15, r12
	je	$LN1327@GenerateNo
	npad	3
$LL7@GenerateNo:

; 39   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	cmp	r13b, 5
	jne	$LN16@GenerateNo
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T8[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T8[rsp+16], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T8[rbp-232], r14

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [r15+48]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r14, QWORD PTR [r15+32]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+56], 16
	jb	SHORT $LN1005@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r14]
$LN1005@GenerateNo:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, r8
	ja	$LN1108@GenerateNo

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	rsi, 16
	jae	SHORT $LN1011@GenerateNo

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T8[rsp+16], rsi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T8[rbp-232], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T8[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN1027@GenerateNo
$LN1011@GenerateNo:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdi, rsi
	or	rdi, 15
	cmp	rdi, r8

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN1022@GenerateNo

; 4716 :             return _Max;

	mov	rdi, r8
	jmp	SHORT $LN1021@GenerateNo
$LN1022@GenerateNo:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rdi, 22
	cmovb	rdi, r10
$LN1021@GenerateNo:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rdi
	add	rdx, 1
	cmovb	rdx, r11
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T8[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T8[rsp+16], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T8[rbp-232], rdi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
$LN1027@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 39   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	lea	rdi, QWORD PTR $T8[rsp]
	or	ebx, 1
	mov	rsi, QWORD PTR this$GSCopy$1$[rbp-256]
	xor	r14d, r14d
	jmp	$LN1345@GenerateNo
$LN16@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 210  :     switch (ValueType) {

	movzx	eax, r13b
	cmp	eax, 5
	ja	$LN880@GenerateNo
	mov	ecx, DWORD PTR $LN1335@GenerateNo[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN874@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T6[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T6[rsp+16], 3

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T6[rsp+24], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_03DBLNGNIM@Int@
	mov	WORD PTR $T6[rsp], ax
	movzx	eax, BYTE PTR ??_C@_03DBLNGNIM@Int@+2
	mov	BYTE PTR $T6[rsp+2], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T6[rsp+3], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 212  :         return "Int";

	jmp	SHORT $LN1346@GenerateNo
$LN875@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:??_C@_04PCGIEMCI@Bool@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 214  :         return "Bool";

	jmp	SHORT $LN1347@GenerateNo
$LN876@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05KKPNNHNB@Float@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 216  :         return "Float";

	jmp	SHORT $LN1347@GenerateNo
$LN877@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 6
	lea	rdx, OFFSET FLAT:??_C@_06ENNEIMBA@String@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 218  :         return "String";

	jmp	SHORT $LN1347@GenerateNo
$LN878@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05PJCBICIO@Vec3f@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 220  :         return "Vec3f";

	jmp	SHORT $LN1347@GenerateNo
$LN879@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 11
	lea	rdx, OFFSET FLAT:??_C@_0M@EALHFGP@UserDefined@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 222  :         return "UserDefined";

	jmp	SHORT $LN1347@GenerateNo
$LN880@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 7
	lea	rdx, OFFSET FLAT:??_C@_07NBCGADJA@Unknown@
$LN1347@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 39   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	xorps	xmm0, xmm0
	movups	XMMWORD PTR $T6[rsp], xmm0
	mov	QWORD PTR $T6[rsp+16], r14
	mov	QWORD PTR $T6[rsp+24], r14
	lea	rcx, QWORD PTR $T6[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
$LN1346@GenerateNo:
	bts	ebx, 11
	lea	rdi, QWORD PTR $T6[rsp]
	or	ebx, 2
$LN1345@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4938 :     const auto _Left_size  = _Left.size();

	mov	DWORD PTR $T4[rsp], ebx
	mov	rcx, QWORD PTR [r15+16]

; 4939 :     const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	rax, r8
	sub	rax, rcx
	cmp	rax, 2
	jb	$LN1110@GenerateNo

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r9, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+24], 16
	jb	SHORT $LN698@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r15]
$LN698@GenerateNo:

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	QWORD PTR [rsp+48], 2
	lea	rax, OFFSET FLAT:??_C@_02GFKOMOKH@?5?$CI@
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, QWORD PTR $T19[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	ebx, 9
	mov	DWORD PTR $T4[rsp], ebx

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	mov	r9, rdi
	lea	r8, QWORD PTR $T19[rbp-256]
	lea	rcx, QWORD PTR $T12[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	ebx, 10
	mov	DWORD PTR $T4[rsp], ebx

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T12[rbp-240]
	mov	rdx, QWORD PTR $T12[rbp-232]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 1
	jb	SHORT $LN636@GenerateNo

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR $T12[rbp-240], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T12[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rax, QWORD PTR $T12[rbp-256]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	WORD PTR [rax+rcx], 41			; 00000029H

; 3277 :             return *this;

	lea	rax, QWORD PTR $T12[rbp-256]
	jmp	SHORT $LN635@GenerateNo
$LN636@GenerateNo:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 1
	lea	r9, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ@
	mov	edx, 1
	lea	rcx, QWORD PTR $T12[rbp-256]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN635@GenerateNo:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T11[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T11[rbp-240], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T11[rbp-232], r14

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T11[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T11[rbp-240], xmm1

; 4998 :     return _STD move(_Left.append(_Right));

	mov	QWORD PTR [rax+16], r14
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	bts	ebx, 8
	mov	DWORD PTR $T4[rsp], ebx

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r8, QWORD PTR $T11[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	mov	rcx, QWORD PTR $T11[rbp-256]
	mov	rdx, QWORD PTR $T11[rbp-232]
	cmp	rdx, 16
	cmovae	r8, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5418 :     if (text == text_display_end)

	test	r8, r8
	jne	SHORT $LN716@GenerateNo

; 5419 :         return ImVec2(0.0f, font_size);

	movaps	xmm6, xmm7
	jmp	SHORT $LN713@GenerateNo
$LN716@GenerateNo:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r14
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], r8
	movss	DWORD PTR [rsp+32], xmm9
	movaps	xmm3, xmm10
	movss	xmm2, DWORD PTR [rax+15696]
	lea	rdx, QWORD PTR text_size$15[rbp-256]
	mov	rcx, QWORD PTR [rax+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$15[rbp-256]
	addss	xmm0, xmm11
	cvttss2si eax, xmm0
	movd	xmm6, eax
	cvtdq2ps xmm6, xmm6
	movss	DWORD PTR text_size$15[rbp-256], xmm6

; 5428 : 
; 5429 :     return text_size;

	mov	rdx, QWORD PTR $T11[rbp-232]
	mov	rcx, QWORD PTR $T11[rbp-256]
$LN713@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 39   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	addss	xmm6, xmm8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN738@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN750@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN747@GenerateNo
$LN750@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN738@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T11[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T11[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T11[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T12[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN767@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T12[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN779@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN776@GenerateNo
$LN779@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN767@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T12[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T12[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T12[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T19[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN796@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T19[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN808@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN805@GenerateNo
$LN808@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN796@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 39   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	test	bl, 2
	je	SHORT $LN854@GenerateNo
	and	ebx, -3
	mov	DWORD PTR $T4[rsp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T6[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN854@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T6[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN866@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN863@GenerateNo
$LN866@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN854@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 39   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	test	bl, 1
	je	SHORT $LN825@GenerateNo
	and	ebx, -2
	mov	DWORD PTR $T4[rsp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T8[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN825@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T8[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN837@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN834@GenerateNo
$LN837@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN825@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 40   :             Width += ImGui::GetStyle().ItemSpacing.x + 24;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm1, DWORD PTR [rax+14628]

; 41   :             Width += GetParamValueWidth(i);

	movzx	edx, r13b
	mov	rcx, rsi
	call	?GetParamValueWidth@UIAINBNodeBase@@QEAAME@Z ; UIAINBNodeBase::GetParamValueWidth

; 40   :             Width += ImGui::GetStyle().ItemSpacing.x + 24;

	movaps	xmm2, xmm1
	addss	xmm2, xmm12
	addss	xmm2, xmm6

; 41   :             Width += GetParamValueWidth(i);

	addss	xmm0, xmm2

; 42   :             if (i == (int)AINBFile::ValueType::Vec3f) {

	cmp	r13b, 4
	jne	SHORT $LN14@GenerateNo

; 43   :                 Width += ImGui::GetStyle().ItemSpacing.x;

	addss	xmm0, xmm1
$LN14@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 140  :     return _CSTD fmaxf(_Xx, _Yx);

	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR [rsi+20]
	call	QWORD PTR __imp_fmaxf
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 45   :             mNodeShapeInfo.FrameWidth = std::fmax(mNodeShapeInfo.FrameWidth, Width);

	movss	DWORD PTR [rsi+20], xmm0

; 37   :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	add	r15, 240				; 000000f0H
	cmp	r15, r12
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
	lea	r9, OFFSET FLAT:__ImageBase
	mov	r10d, 22
	lea	r11, QWORD PTR [r10-23]
	jne	$LL7@GenerateNo
	mov	rdx, QWORD PTR tv6748[rbp-256]
$LN1327@GenerateNo:

; 48   :         for (AINBFile::OutputEntry& Output : mNode->OutputParameters[i]) {

	mov	rax, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax+200]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 48   :         for (AINBFile::OutputEntry& Output : mNode->OutputParameters[i]) {

	mov	r15, QWORD PTR [rcx+rdx*8]
	mov	r12, QWORD PTR [rcx+rdx*8+8]
	cmp	r15, r12
	je	$LN1341@GenerateNo
$LL10@GenerateNo:

; 50   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	cmp	r13b, 5
	jne	$LN18@GenerateNo
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T7[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T7[rsp+16], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T7[rbp-232], r14

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [r15+56]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r14, QWORD PTR [r15+40]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+64], 16
	jb	SHORT $LN594@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r14]
$LN594@GenerateNo:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, r8
	ja	$LN1112@GenerateNo

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	rsi, 16
	jae	SHORT $LN600@GenerateNo

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T7[rsp+16], rsi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T7[rbp-232], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T7[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN616@GenerateNo
$LN600@GenerateNo:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdi, rsi
	or	rdi, 15
	cmp	rdi, r8

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN611@GenerateNo

; 4716 :             return _Max;

	mov	rdi, r8
	jmp	SHORT $LN610@GenerateNo
$LN611@GenerateNo:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rdi, 22
	cmovb	rdi, r10
$LN610@GenerateNo:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rdi
	add	rdx, 1
	cmovb	rdx, r11
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T7[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T7[rsp+16], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T7[rbp-232], rdi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
$LN616@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 50   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	lea	rdi, QWORD PTR $T7[rsp]
	or	ebx, 4
	mov	rsi, QWORD PTR this$GSCopy$1$[rbp-256]
	xor	r14d, r14d
	jmp	$LN1348@GenerateNo
$LN18@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 210  :     switch (ValueType) {

	movzx	eax, r13b
	cmp	eax, 5
	ja	$LN261@GenerateNo
	mov	ecx, DWORD PTR $LN1334@GenerateNo[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN255@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 3

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_03DBLNGNIM@Int@
	mov	WORD PTR $T5[rsp], ax
	movzx	eax, BYTE PTR ??_C@_03DBLNGNIM@Int@+2
	mov	BYTE PTR $T5[rsp+2], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+3], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 212  :         return "Int";

	jmp	$LN1349@GenerateNo
$LN256@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 4

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	DWORD PTR $T5[rsp], 1819242306		; 6c6f6f42H

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+4], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 214  :         return "Bool";

	jmp	$LN1349@GenerateNo
$LN257@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 5

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_05KKPNNHNB@Float@
	mov	DWORD PTR $T5[rsp], eax
	movzx	eax, BYTE PTR ??_C@_05KKPNNHNB@Float@+4
	mov	BYTE PTR $T5[rsp+4], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+5], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 216  :         return "Float";

	jmp	$LN1349@GenerateNo
$LN258@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 6

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_06ENNEIMBA@String@
	mov	DWORD PTR $T5[rsp], eax
	movzx	eax, WORD PTR ??_C@_06ENNEIMBA@String@+4
	mov	WORD PTR $T5[rsp+4], ax

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+6], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 218  :         return "String";

	jmp	$LN1349@GenerateNo
$LN259@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 5

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_05PJCBICIO@Vec3f@
	mov	DWORD PTR $T5[rsp], eax
	movzx	eax, BYTE PTR ??_C@_05PJCBICIO@Vec3f@+4
	mov	BYTE PTR $T5[rsp+4], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+5], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 220  :         return "Vec3f";

	jmp	SHORT $LN1349@GenerateNo
$LN260@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 11

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movsd	xmm0, QWORD PTR ??_C@_0M@EALHFGP@UserDefined@
	movsd	QWORD PTR $T5[rsp], xmm0
	movzx	eax, WORD PTR ??_C@_0M@EALHFGP@UserDefined@+8
	mov	WORD PTR $T5[rsp+8], ax
	movzx	eax, BYTE PTR ??_C@_0M@EALHFGP@UserDefined@+10
	mov	BYTE PTR $T5[rsp+10], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+11], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 222  :         return "UserDefined";

	jmp	SHORT $LN1349@GenerateNo
$LN261@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 7

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rax, QWORD PTR ??_C@_07NBCGADJA@Unknown@
	mov	DWORD PTR $T5[rsp], eax
	movzx	eax, WORD PTR ??_C@_07NBCGADJA@Unknown@+4
	mov	WORD PTR $T5[rsp+4], ax
	movzx	eax, BYTE PTR ??_C@_07NBCGADJA@Unknown@+6
	mov	BYTE PTR $T5[rsp+6], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+7], 0
$LN1349@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 50   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	mov	QWORD PTR $T5[rsp+24], 15
	bts	ebx, 7
	lea	rdi, QWORD PTR $T5[rsp]
	or	ebx, 8
$LN1348@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4938 :     const auto _Left_size  = _Left.size();

	mov	DWORD PTR $T4[rsp], ebx
	mov	rcx, QWORD PTR [r15+16]

; 4939 :     const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	rax, r8
	sub	rax, rcx
	cmp	rax, 2
	jb	$LN1120@GenerateNo

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r9, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+24], 16
	jb	SHORT $LN244@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r15]
$LN244@GenerateNo:

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	QWORD PTR [rsp+48], 2
	lea	rax, OFFSET FLAT:??_C@_02GFKOMOKH@?5?$CI@
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, QWORD PTR $T18[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	or	ebx, 64					; 00000040H
	mov	DWORD PTR $T4[rsp], ebx

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	mov	r9, rdi
	lea	r8, QWORD PTR $T18[rbp-256]
	lea	rcx, QWORD PTR $T14[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	or	ebx, 32					; 00000020H
	mov	DWORD PTR $T4[rsp], ebx

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T14[rbp-240]
	mov	rdx, QWORD PTR $T14[rbp-232]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 1
	jb	SHORT $LN178@GenerateNo

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR $T14[rbp-240], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T14[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rax, QWORD PTR $T14[rbp-256]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	WORD PTR [rax+rcx], 41			; 00000029H

; 3277 :             return *this;

	lea	rax, QWORD PTR $T14[rbp-256]
	jmp	SHORT $LN177@GenerateNo
$LN178@GenerateNo:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 1
	lea	r9, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ@
	mov	edx, 1
	lea	rcx, QWORD PTR $T14[rbp-256]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN177@GenerateNo:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T13[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T13[rbp-240], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T13[rbp-232], r14

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T13[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T13[rbp-240], xmm1

; 4998 :     return _STD move(_Left.append(_Right));

	mov	QWORD PTR [rax+16], r14
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	or	ebx, 16
	mov	DWORD PTR $T4[rsp], ebx

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r8, QWORD PTR $T13[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	mov	rcx, QWORD PTR $T13[rbp-256]
	mov	rdx, QWORD PTR $T13[rbp-232]
	cmp	rdx, 16
	cmovae	r8, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5418 :     if (text == text_display_end)

	test	r8, r8
	jne	SHORT $LN152@GenerateNo

; 5419 :         return ImVec2(0.0f, font_size);

	movaps	xmm6, xmm7
	jmp	SHORT $LN149@GenerateNo
$LN152@GenerateNo:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r14
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], r8
	movss	DWORD PTR [rsp+32], xmm9
	movaps	xmm3, xmm10
	movss	xmm2, DWORD PTR [rax+15696]
	lea	rdx, QWORD PTR text_size$16[rbp-256]
	mov	rcx, QWORD PTR [rax+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$16[rbp-256]
	addss	xmm0, xmm11
	cvttss2si eax, xmm0
	movd	xmm6, eax
	cvtdq2ps xmm6, xmm6
	movss	DWORD PTR text_size$16[rbp-256], xmm6

; 5428 : 
; 5429 :     return text_size;

	mov	rdx, QWORD PTR $T13[rbp-232]
	mov	rcx, QWORD PTR $T13[rbp-256]
$LN149@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 50   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	addss	xmm6, xmm8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN103@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN115@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN112@GenerateNo
$LN115@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN103@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T13[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T13[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T13[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T14[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN73@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T14[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN85@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN82@GenerateNo
$LN85@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN73@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T14[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T14[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T14[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T18[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN132@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T18[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN144@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN141@GenerateNo
$LN144@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN132@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 50   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	test	bl, 8
	je	SHORT $LN566@GenerateNo
	and	ebx, -9
	mov	DWORD PTR $T4[rsp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T5[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN566@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T5[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN578@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN575@GenerateNo
$LN578@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN566@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 50   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	test	bl, 4
	je	SHORT $LN537@GenerateNo
	and	ebx, -5
	mov	DWORD PTR $T4[rsp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T7[rbp-232]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN537@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T7[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN549@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN546@GenerateNo
$LN549@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN537@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 51   :             Width += 2 * ImGui::GetStyle().ItemSpacing.x + 32;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm1, DWORD PTR [rax+14628]
	addss	xmm1, xmm1
	addss	xmm1, xmm13
	addss	xmm1, xmm6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 140  :     return _CSTD fmaxf(_Xx, _Yx);

	movss	xmm0, DWORD PTR [rsi+20]
	call	QWORD PTR __imp_fmaxf
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 52   :             mNodeShapeInfo.FrameWidth = std::fmax(mNodeShapeInfo.FrameWidth, Width);

	movss	DWORD PTR [rsi+20], xmm0

; 48   :         for (AINBFile::OutputEntry& Output : mNode->OutputParameters[i]) {

	add	r15, 72					; 00000048H
	cmp	r15, r12
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
	lea	r9, OFFSET FLAT:__ImageBase
	mov	r10d, 22
	lea	r11, QWORD PTR [r10-23]
	jne	$LL10@GenerateNo
	mov	rdx, QWORD PTR tv6748[rbp-256]
$LN1341@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rax+152]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 55   :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	mov	r14, QWORD PTR [rcx+rdx*8+8]
	mov	rdi, QWORD PTR [rcx+rdx*8]
	cmp	rdi, r14
	je	$LN2@GenerateNo
	xor	r15d, r15d
	npad	2
$LL13@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN44@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN44@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5418 :     if (text == text_display_end)

	test	rax, rax
	jne	SHORT $LN51@GenerateNo

; 5419 :         return ImVec2(0.0f, font_size);

	movaps	xmm1, xmm7
	jmp	SHORT $LN48@GenerateNo
$LN51@GenerateNo:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r15
	mov	QWORD PTR [rsp+48], r15
	mov	QWORD PTR [rsp+40], rax
	movss	DWORD PTR [rsp+32], xmm9
	movaps	xmm3, xmm10
	movss	xmm2, DWORD PTR [rsi+15696]
	lea	rdx, QWORD PTR text_size$10[rbp-256]
	mov	rcx, QWORD PTR [rsi+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$10[rbp-256]
	addss	xmm0, xmm11
	cvttss2si eax, xmm0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	movss	DWORD PTR text_size$10[rbp-256], xmm1
$LN48@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 59   :             Width += GetParamValueWidth(i);

	movzx	edx, r13b
	mov	rcx, QWORD PTR this$GSCopy$1$[rbp-256]
	call	?GetParamValueWidth@UIAINBNodeBase@@QEAAME@Z ; UIAINBNodeBase::GetParamValueWidth

; 56   :             float Width = 8 * 2;
; 57   :             Width += ImGui::CalcTextSize(Immediate.Name.c_str()).x;

	addss	xmm1, xmm8

; 58   :             Width += ImGui::GetStyle().ItemSpacing.x;

	addss	xmm1, DWORD PTR [rsi+14628]

; 59   :             Width += GetParamValueWidth(i);

	addss	xmm0, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 140  :     return _CSTD fmaxf(_Xx, _Yx);

	movaps	xmm1, xmm0
	mov	rsi, rcx
	movss	xmm0, DWORD PTR [rcx+20]
	call	QWORD PTR __imp_fmaxf
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 60   :             mNodeShapeInfo.FrameWidth = std::fmax(mNodeShapeInfo.FrameWidth, Width);

	movss	DWORD PTR [rsi+20], xmm0

; 55   :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	add	rdi, 200				; 000000c8H
	cmp	rdi, r14
	jne	$LL13@GenerateNo
$LN2@GenerateNo:

; 36   :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	inc	r13b
	cmp	r13b, 6
	jae	SHORT $LN1331@GenerateNo
	xor	r14d, r14d
	jmp	$LN1350@GenerateNo
$LN747@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN776@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN805@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN863@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN834@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN112@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN82@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN141@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN575@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN546@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1331@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 63   : }

	lea	r11, QWORD PTR [rsp+496]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN1120@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4941 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1108@GenerateNo:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1110@GenerateNo:

; 4941 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1112@GenerateNo:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1343@GenerateNo:
	npad	2
$LN1335@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 63   : }

	DD	$LN874@GenerateNo
	DD	$LN875@GenerateNo
	DD	$LN876@GenerateNo
	DD	$LN877@GenerateNo
	DD	$LN878@GenerateNo
	DD	$LN879@GenerateNo
$LN1334@GenerateNo:
	DD	$LN255@GenerateNo
	DD	$LN256@GenerateNo
	DD	$LN257@GenerateNo
	DD	$LN258@GenerateNo
	DD	$LN259@GenerateNo
	DD	$LN260@GenerateNo
?GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ ENDP ; UIAINBNodeSequential::GenerateNodeShapeInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA PROC ; `UIAINBNodeSequential::GenerateNodeShapeInfo'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T4[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN22@dtor$1
	and	DWORD PTR $T4[rbp], -2
	lea	rcx, QWORD PTR $T8[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN22@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSequential::GenerateNodeShapeInfo'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA PROC ; `UIAINBNodeSequential::GenerateNodeShapeInfo'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T4[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN24@dtor$2
	and	DWORD PTR $T4[rbp], -3
	lea	rcx, QWORD PTR $T6[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN24@dtor$2:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSequential::GenerateNodeShapeInfo'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$3@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA PROC ; `UIAINBNodeSequential::GenerateNodeShapeInfo'::`1'::dtor$3
	lea	rcx, QWORD PTR $T19[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSequential::GenerateNodeShapeInfo'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$4@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA PROC ; `UIAINBNodeSequential::GenerateNodeShapeInfo'::`1'::dtor$4
	lea	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSequential::GenerateNodeShapeInfo'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA PROC ; `UIAINBNodeSequential::GenerateNodeShapeInfo'::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T4[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN31@dtor$6
	and	DWORD PTR $T4[rbp], -5
	lea	rcx, QWORD PTR $T7[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN31@dtor$6:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSequential::GenerateNodeShapeInfo'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA PROC ; `UIAINBNodeSequential::GenerateNodeShapeInfo'::`1'::dtor$7
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T4[rbp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN33@dtor$7
	and	DWORD PTR $T4[rbp], -9
	lea	rcx, QWORD PTR $T5[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN33@dtor$7:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSequential::GenerateNodeShapeInfo'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$8@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA PROC ; `UIAINBNodeSequential::GenerateNodeShapeInfo'::`1'::dtor$8
	lea	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSequential::GenerateNodeShapeInfo'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$9@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA PROC ; `UIAINBNodeSequential::GenerateNodeShapeInfo'::`1'::dtor$9
	lea	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$9@?0??GenerateNodeShapeInfo@UIAINBNodeSequential@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSequential::GenerateNodeShapeInfo'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_node_editor\imgui_node_editor_api.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_node_editor\imgui_node_editor_api.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
;	COMDAT ?Render@UIAINBNodeSequential@@UEAAXXZ
_TEXT	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
HasImmediate$1$ = 65
tv6081 = 68
$T9 = 68
CurrentId$1$ = 72
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 120
$T15 = 120
$T16 = 120
HeaderRect$17 = 120
$T18 = 120
$T19 = 136
$T20 = 136
this$GSCopy$1$ = 144
text_size$21 = 152
backup$22 = 160
backup$23 = 160
$T24 = 160
$T25 = 184
$T26 = 184
$T27 = 200
$T28 = 240
_Temp$29 = 256
$T30 = 256
$T31 = 256
$T32 = 256
$T33 = 256
$T34 = 256
$T35 = 256
$T36 = 256
$T37 = 288
Text$38 = 288
_Buff$39 = 320
__$ArrayPad$ = 344
this$ = 528
?Render@UIAINBNodeSequential@@UEAAXXZ PROC		; UIAINBNodeSequential::Render, COMDAT

; 66   : {

$LN1210:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-264]
	sub	rsp, 480				; 000001e0H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-104], xmm9
	movaps	XMMWORD PTR [rax-120], xmm10
	movaps	XMMWORD PTR [rax-136], xmm11
	movaps	XMMWORD PTR [rax-152], xmm12
	movaps	XMMWORD PTR [rax-168], xmm13
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rsi, rcx
	mov	QWORD PTR this$GSCopy$1$[rbp-256], rcx
	xor	r15d, r15d
	mov	DWORD PTR $T9[rsp], r15d

; 67   :     mSeqToPinId.clear();

	lea	r12, QWORD PTR [rcx+280]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR [r12]
	cmp	rax, QWORD PTR [r12+8]
	je	SHORT $LN989@Render

; 1767 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1768 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1769 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1770 :             return;
; 1771 :         }
; 1772 : 
; 1773 :         _My_data._Orphan_all();
; 1774 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1775 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [r12+8], rax
$LN989@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 68   :     uint32_t CurrentId = mEditorId;

	mov	edi, DWORD PTR [rcx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm0, XMMWORD PTR __xmm@41000000410000004100000041000000
	movups	XMMWORD PTR $T18[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 71   :     ed::PushStyleVar(ed::StyleVar_NodePadding, ImVec4(8, 8, 8, 8));

	lea	rdx, QWORD PTR $T18[rsp]
	call	?PushStyleVar@NodeEditor@ax@@YAXW4StyleVar@12@AEBUImVec4@@@Z ; ax::NodeEditor::PushStyleVar

; 72   :     ed::BeginNode(CurrentId++);

	mov	edx, edi
	inc	edi
	mov	DWORD PTR CurrentId$1$[rsp], edi
	mov	ebx, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_node_editor\imgui_node_editor_api.cpp

; 148  :     s_Editor->GetNodeBuilder().Begin(id);

	mov	rcx, QWORD PTR ?s_Editor@@3PEAUEditorContext@Detail@NodeEditor@ax@@EA
	add	rcx, 1032				; 00000408H
	call	?Begin@NodeBuilder@Detail@NodeEditor@ax@@QEAAXUNodeId@34@@Z ; ax::NodeEditor::Detail::NodeBuilder::Begin
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 76   :     if (mEnableFlow) {

	mov	rax, QWORD PTR [rsi+256]
	movss	xmm8, DWORD PTR __real@41000000
	mov	r13, -1
	movss	xmm12, DWORD PTR __real@437f0000
	cmp	BYTE PTR [rax], r15b
	je	$LN16@Render

; 77   :         float Alpha = ImGui::GetStyle().Alpha;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm6, DWORD PTR [rax+14552]

; 78   :         ImGui::PushStyleVar(ImGuiStyleVar_Alpha, Alpha);

	movaps	xmm1, xmm6
	xor	ecx, ecx
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 79   :         ImRect HeaderRect = DrawPin(CurrentId++, mFlowLinked, Alpha * 255, UIAINBNodeBase::PinType::Flow, ed::PinKind::Input, mNode->GetName());

	mov	rdx, QWORD PTR [rsi+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp

; 2908 : 	if (this->Type == (uint16_t)AINBFile::NodeTypes::UserDefined)

	movzx	eax, WORD PTR [rdx]
	lea	rcx, QWORD PTR $T36[rbp-256]
	test	ax, ax
	jne	SHORT $LN1039@Render

; 2909 : 		return this->Name;

	add	rdx, 32					; 00000020H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	SHORT $LN1203@Render
$LN1039@Render:

; 2910 : 
; 2911 : 	return AINBFile::NodeTypeToString((AINBFile::NodeTypes)this->Type);

	movzx	edx, ax
	call	?NodeTypeToString@AINBFile@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4NodeTypes@1@@Z ; AINBFile::NodeTypeToString
$LN1203@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 79   :         ImRect HeaderRect = DrawPin(CurrentId++, mFlowLinked, Alpha * 255, UIAINBNodeBase::PinType::Flow, ed::PinKind::Input, mNode->GetName());

	mov	r14d, 256				; 00000100H
	mov	r8d, edi
	inc	edi
	mov	DWORD PTR CurrentId$1$[rsp], edi
	mulss	xmm6, xmm12
	cvttss2si rax, xmm6
	lea	rcx, QWORD PTR $T36[rbp-256]
	mov	QWORD PTR [rsp+56], rcx
	mov	DWORD PTR [rsp+48], r15d
	mov	DWORD PTR [rsp+40], 6
	mov	DWORD PTR [rsp+32], eax
	movzx	r9d, BYTE PTR [rsi+264]
	lea	rdx, QWORD PTR HeaderRect$17[rsp]
	call	?DrawPin@UIAINBNodeBase@@QEAA?AUImRect@@I_NIW4PinType@1@W4PinKind@NodeEditor@ax@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; UIAINBNodeBase::DrawPin

; 80   :         ImGui::PopStyleVar();

	mov	ecx, 1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 81   :         mPins.insert({ CurrentId - 1, Pin { .Kind = ed::PinKind::Input, .Type = UIAINBNodeBase::PinType::Flow, .Node = mNode } });

	lea	rcx, QWORD PTR [rsi+120]
	mov	DWORD PTR $T35[rbp-256], r15d
	mov	DWORD PTR $T35[rbp-252], 6
	mov	rax, QWORD PTR [rsi+8]
	mov	QWORD PTR $T35[rbp-248], rax
	mov	QWORD PTR $T35[rbp-240], r15
	mov	DWORD PTR $T35[rbp-232], r13d
	mov	WORD PTR $T35[rbp-228], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	DWORD PTR $T13[rsp], ebx
	movups	xmm0, XMMWORD PTR $T35[rbp-256]
	movups	XMMWORD PTR $T13[rsp+8], xmm0
	movups	xmm1, XMMWORD PTR $T35[rbp-240]
	movups	XMMWORD PTR $T13[rsp+24], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T13[rsp]
	lea	rdx, QWORD PTR $T26[rbp-256]
	call	??$emplace@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IUPin@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIUPin@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Pin,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 83   :         mNodeShapeInfo.HeaderMin = ImVec2(HeaderRect.GetTL().x - 32 - ImGui::GetStyle().ItemSpacing.x - 1, HeaderRect.GetTL().y - 14);

	movss	xmm0, DWORD PTR HeaderRect$17[rsp+4]
	subss	xmm0, DWORD PTR __real@41600000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3085 :     return GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 83   :         mNodeShapeInfo.HeaderMin = ImVec2(HeaderRect.GetTL().x - 32 - ImGui::GetStyle().ItemSpacing.x - 1, HeaderRect.GetTL().y - 14);

	movss	xmm1, DWORD PTR HeaderRect$17[rsp]
	subss	xmm1, DWORD PTR __real@42000000
	subss	xmm1, DWORD PTR [rax+14628]
	subss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsi+24], xmm1
	movss	DWORD PTR [rsi+28], xmm0

; 84   :         mNodeShapeInfo.HeaderMax = ImVec2(mNodeShapeInfo.HeaderMin.x + mNodeShapeInfo.FrameWidth + 10, HeaderRect.GetBR().y + 12);

	movss	xmm2, DWORD PTR HeaderRect$17[rbp-244]
	addss	xmm2, DWORD PTR __real@41400000

; 85   :     } else {

	jmp	$LN1204@Render
$LN16@Render:

; 86   :         ImGui::Text(mNode->GetName().c_str());

	mov	rdx, QWORD PTR [rsi+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp

; 2908 : 	if (this->Type == (uint16_t)AINBFile::NodeTypes::UserDefined)

	movzx	eax, WORD PTR [rdx]
	lea	rcx, QWORD PTR $T34[rbp-256]
	test	ax, ax
	jne	SHORT $LN1020@Render

; 2909 : 		return this->Name;

	add	rdx, 32					; 00000020H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	SHORT $LN1205@Render
$LN1020@Render:

; 2910 : 
; 2911 : 	return AINBFile::NodeTypeToString((AINBFile::NodeTypes)this->Type);

	movzx	edx, ax
	call	?NodeTypeToString@AINBFile@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4NodeTypes@1@@Z ; AINBFile::NodeTypeToString
$LN1205@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 86   :         ImGui::Text(mNode->GetName().c_str());

	mov	r14d, 128				; 00000080H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T34[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T34[rbp-232], 16
	cmovae	rcx, QWORD PTR $T34[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 86   :         ImGui::Text(mNode->GetName().c_str());

	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T34[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN1006@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T34[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1006@Render:

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T34[rbp-240], r15

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T34[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T34[rbp-256], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5637 :     return g.LastItemData.Rect.Min;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm0, DWORD PTR [rax+18632]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 87   :         mNodeShapeInfo.HeaderMin = ImVec2(ImGui::GetItemRectMin().x - 1 - ImGui::GetStyle().ItemSpacing.x, ImGui::GetItemRectMin().y - 9);

	subss	xmm0, DWORD PTR __real@41100000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5637 :     return g.LastItemData.Rect.Min;

	movss	xmm1, DWORD PTR [rax+18628]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 87   :         mNodeShapeInfo.HeaderMin = ImVec2(ImGui::GetItemRectMin().x - 1 - ImGui::GetStyle().ItemSpacing.x, ImGui::GetItemRectMin().y - 9);

	subss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR [rax+14628]
	movss	DWORD PTR [rsi+24], xmm1
	movss	DWORD PTR [rsi+28], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5643 :     return g.LastItemData.Rect.Max;

	movss	xmm2, DWORD PTR [rax+18640]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 88   :         mNodeShapeInfo.HeaderMax = ImVec2(mNodeShapeInfo.HeaderMin.x + mNodeShapeInfo.FrameWidth + 10, ImGui::GetItemRectMax().y + 8);

	addss	xmm2, xmm8
$LN1204@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	r11d, 32				; 00000020H
	mov	rbx, rsi
	mov	QWORD PTR $T25[rbp-256], r11
	mov	QWORD PTR $T14[rsp], rbx
	addss	xmm1, DWORD PTR [rsi+20]
	mov	rax, rsi
	addss	xmm1, DWORD PTR __real@41200000
	movss	DWORD PTR [rbx+r11], xmm1
	movss	DWORD PTR [rax+36], xmm2
	xorps	xmm7, xmm7
	mov	DWORD PTR $T20[rbp-256], 0
	mov	DWORD PTR $T20[rbp-252], 1090519040	; 41000000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 91   :     ImGui::Dummy(ImVec2(0, 8));

	lea	rcx, QWORD PTR $T20[rbp-256]
	call	?Dummy@ImGui@@YAXAEBUImVec2@@@Z		; ImGui::Dummy

; 92   : 
; 93   :     bool AddedHeader = false;

	xor	cl, cl
	mov	BYTE PTR AddedHeader$1$[rsp], cl

; 95   :     for (int16_t i = 0; i < mSeqCount; i++) {

	movzx	r13d, r15w
	movss	xmm13, DWORD PTR __real@bf800000
	cmp	r15w, WORD PTR [rsi+272]
	jae	$LN3@Render
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	lea	eax, DWORD PTR [rdi-1]
	mov	DWORD PTR tv6081[rsp], eax
	movss	xmm9, DWORD PTR __real@7f7fffff
	movss	xmm10, DWORD PTR __real@3f7fff58
	movss	xmm11, DWORD PTR __real@41900000
	npad	2
$LL4@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 96   :         if (!AddedHeader) {

	test	cl, cl
	jne	SHORT $LN18@Render

; 97   :             mNodeShapeInfo.HeaderMax.x += 8;

	movss	xmm0, DWORD PTR [rbx+r11]
	addss	xmm0, xmm8
	movss	DWORD PTR [rbx+r11], xmm0

; 98   :             AddedHeader = true;

	mov	BYTE PTR AddedHeader$1$[rsp], 1
$LN18@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 482  :     if (_Val < 0) {

	lea	r9, QWORD PTR _Buff$39[rbp-235]
	mov	r8d, r15d
	test	r15d, r15d
	jns	SHORT $LL683@Render

; 447  :     auto _UVal_trunc = _UVal;

	neg	r8d
	npad	7
$LL678@Render:

; 448  : #else // ^^^ _WIN64 / !_WIN64 vvv
; 449  : 
; 450  :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 451  :     if constexpr (_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 452  :         while (_UVal > 0xFFFFFFFFU) {
; 453  :             auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 454  :             _UVal /= 1000000000;
; 455  : 
; 456  :             for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 457  :                 *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 458  :                 _UVal_chunk /= 10;
; 459  :             }
; 460  :         }
; 461  :     }
; 462  : 
; 463  :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 464  : #endif // _WIN64
; 465  : 
; 466  :     do {
; 467  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 468  :         _UVal_trunc /= 10;

	mov	r8d, edx

; 469  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL678@Render

; 484  :         *--_RNext = '-';

	dec	r9
	mov	BYTE PTR [r9], 45			; 0000002dH

; 485  :     } else {

	jmp	SHORT $LN671@Render
	npad	13
$LL683@Render:

; 467  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 468  :         _UVal_trunc /= 10;

	mov	r8d, edx

; 469  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL683@Render
$LN671@Render:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T12[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	edi, edi
	mov	QWORD PTR $T12[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T12[rsp+24], rdi

; 2574 :         if (_UFirst == _ULast) {

	lea	rax, QWORD PTR _Buff$39[rbp-235]
	cmp	r9, rax
	jne	SHORT $LN686@Render

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T12[rsp+16], rdi

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T12[rsp+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T12[rsp], dil

; 2577 :         } else {

	jmp	SHORT $LN687@Render
$LN686@Render:

; 2578 :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2579 :                 _Construct<_Construct_strategy::_From_ptr>(

	lea	r8, QWORD PTR _Buff$39[rbp-235]
	sub	r8, r9
	mov	rdx, r9
	lea	rcx, QWORD PTR $T12[rsp]
	call	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
$LN687@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 505  :     return _Integral_to_string<char>(_Val);

	or	r14d, 24
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r9d, 4
	lea	r8, OFFSET FLAT:??_C@_04IKCBJMAN@Seq?5@
	lea	rcx, QWORD PTR $T12[rsp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Text$38[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR Text$38[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR Text$38[rbp-232], rdi

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR Text$38[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR Text$38[rbp-240], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], rdi

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], 0

; 4986 :     return _STD move(_Right.insert(0, _Left));

	or	r14d, 32				; 00000020H

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T12[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN749@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T12[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN761@Render

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN758@Render
$LN761@Render:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN749@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T12[rsp+16], rdi

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T12[rsp+24], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T12[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10264:     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rbx+16408]

; 10265:     return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;

	movss	xmm6, DWORD PTR [rax+312]
	subss	xmm6, DWORD PTR [rax+80]
	addss	xmm6, DWORD PTR [rax+184]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR Text$38[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Text$38[rbp-232], 16
	cmovae	rax, QWORD PTR Text$38[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5418 :     if (text == text_display_end)

	test	rax, rax
	jne	SHORT $LN778@Render
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN775@Render
$LN778@Render:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], rdi
	mov	QWORD PTR [rsp+48], rdi
	mov	QWORD PTR [rsp+40], rax
	movss	DWORD PTR [rsp+32], xmm13
	movaps	xmm3, xmm9
	movss	xmm2, DWORD PTR [rbx+15696]
	lea	rdx, QWORD PTR text_size$21[rbp-256]
	mov	rcx, QWORD PTR [rbx+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$21[rbp-256]
	addss	xmm0, xmm10
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR text_size$21[rbp-256], xmm0
$LN775@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 103  :         ImGui::SetCursorPosX(ImGui::GetCursorPosX() + mNodeShapeInfo.FrameWidth - (8 + ImGui::CalcTextSize(Text.c_str()).x + 18 + ImGui::GetStyle().ItemSpacing.x));

	addss	xmm6, DWORD PTR [rsi+20]
	addss	xmm0, xmm8
	addss	xmm0, xmm11
	addss	xmm0, DWORD PTR [rbx+14628]
	subss	xmm6, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rbx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10285:     window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;

	movss	xmm0, DWORD PTR [rax+80]
	subss	xmm0, DWORD PTR [rax+184]
	addss	xmm0, xmm6
	movss	DWORD PTR [rax+312], xmm0

; 10286:     //window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
; 10287:     window->DC.IsSetPos = true;

	mov	BYTE PTR [rax+377], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 104  :         float Alpha = ImGui::GetStyle().Alpha;

	movss	xmm6, DWORD PTR [rbx+14552]

; 105  :         ImGui::PushStyleVar(ImGuiStyleVar_Alpha, Alpha);

	movaps	xmm1, xmm6
	xor	ecx, ecx
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T33[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T33[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T33[rbp-232], rdi

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rdi, QWORD PTR Text$38[rbp-240]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rsi, QWORD PTR Text$38[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Text$38[rbp-232], 16
	cmovae	rsi, QWORD PTR Text$38[rbp-256]

; 2620 :         if (_Count > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdi, rax
	ja	$LN1065@Render

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T33[rbp-232], 15
	cmp	rdi, 16
	jae	SHORT $LN809@Render

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T33[rbp-240], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR $T33[rbp-256], xmm0

; 2647 :             return;

	jmp	SHORT $LN825@Render
$LN809@Render:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;

	mov	rbx, rdi
	or	rbx, 15

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	rbx, rax

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN820@Render

; 4716 :             return _Max;

	mov	rbx, rax
	jmp	SHORT $LN819@Render
$LN820@Render:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN819@Render:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T33[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T33[rbp-240], rdi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T33[rbp-232], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rdi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy
$LN825@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	mov	rsi, QWORD PTR this$GSCopy$1$[rbp-256]
	mov	rax, QWORD PTR [rsi+8]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+448]
	sub	rcx, QWORD PTR [rax+440]
	sar	rcx, 3
	mov	rax, 8040888442386214807		; 6f96f96f96f96f97H
	imul	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 106  :         DrawPin(CurrentId++, mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size() > i, Alpha * 255, UIAINBNodeBase::PinType::Flow, ed::PinKind::Output, Text);

	movsx	rbx, r13w
	cmp	rcx, rbx
	seta	r9b
	mov	eax, DWORD PTR CurrentId$1$[rsp]
	mov	r8d, eax
	inc	eax
	mov	DWORD PTR CurrentId$1$[rsp], eax
	mov	edi, DWORD PTR tv6081[rsp]
	inc	edi
	mov	DWORD PTR tv6081[rsp], edi
	mulss	xmm6, xmm12
	cvttss2si rax, xmm6
	lea	rcx, QWORD PTR $T33[rbp-256]
	mov	QWORD PTR [rsp+56], rcx
	mov	DWORD PTR [rsp+48], 1
	mov	DWORD PTR [rsp+40], 6
	mov	DWORD PTR [rsp+32], eax
	lea	rdx, QWORD PTR $T28[rbp-256]
	call	?DrawPin@UIAINBNodeBase@@QEAA?AUImRect@@I_NIW4PinType@1@W4PinKind@NodeEditor@ax@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; UIAINBNodeBase::DrawPin

; 107  :         ImGui::PopStyleVar();

	mov	ecx, 1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 108  :         mSeqToPinId.push_back(CurrentId - 1);

	mov	DWORD PTR $T19[rbp-256], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [r12+8]
	cmp	rdx, QWORD PTR [r12+16]
	je	SHORT $LN837@Render

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [rdx], edi

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	add	QWORD PTR [r12+8], 4

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN836@Render
$LN837@Render:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T19[rbp-256]
	mov	rcx, r12
	call	??$_Emplace_reallocate@I@?$vector@IV?$allocator@I@std@@@std@@AEAAPEAIQEAI$$QEAI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Emplace_reallocate<unsigned int>
$LN836@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 109  :         mPins.insert({ CurrentId - 1, UIAINBNodeBase::Pin { .Kind = ed::PinKind::Output, .Type = UIAINBNodeBase::PinType::Flow, .Node = mNode, .ParameterIndex = i, .AllowMultipleLinks = false, .AlreadyLinked = mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size() > i } });

	lea	rcx, QWORD PTR [rsi+120]
	mov	DWORD PTR $T32[rbp-256], 1
	mov	DWORD PTR $T32[rbp-252], 6
	mov	rax, QWORD PTR [rsi+8]
	mov	QWORD PTR $T32[rbp-248], rax
	mov	QWORD PTR $T32[rbp-240], 0
	mov	DWORD PTR $T32[rbp-232], r15d
	mov	BYTE PTR $T32[rbp-228], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rax+448]
	sub	rdx, QWORD PTR [rax+440]
	sar	rdx, 3
	mov	rax, 8040888442386214807		; 6f96f96f96f96f97H
	imul	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 109  :         mPins.insert({ CurrentId - 1, UIAINBNodeBase::Pin { .Kind = ed::PinKind::Output, .Type = UIAINBNodeBase::PinType::Flow, .Node = mNode, .ParameterIndex = i, .AllowMultipleLinks = false, .AlreadyLinked = mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size() > i } });

	cmp	rdx, rbx
	seta	BYTE PTR $T32[rbp-227]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	DWORD PTR $T27[rbp-256], edi
	movups	xmm0, XMMWORD PTR $T32[rbp-256]
	movups	XMMWORD PTR $T27[rbp-248], xmm0
	movups	xmm1, XMMWORD PTR $T32[rbp-240]
	movups	XMMWORD PTR $T27[rbp-232], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T27[rbp-256]
	lea	rdx, QWORD PTR $T24[rbp-256]
	call	??$emplace@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IUPin@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIUPin@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Pin,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR Text$38[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN851@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR Text$38[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN851@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 95   :     for (int16_t i = 0; i < mSeqCount; i++) {

	inc	r13w
	movsx	r15d, r13w
	movzx	eax, WORD PTR [rsi+272]
	cmp	r15d, eax
	jge	SHORT $LN1201@Render
	mov	r11, QWORD PTR $T25[rbp-256]
	mov	rbx, QWORD PTR $T14[rsp]
	movzx	ecx, BYTE PTR AddedHeader$1$[rsp]
	jmp	$LL4@Render
$LN758@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN1201@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 95   :     for (int16_t i = 0; i < mSeqCount; i++) {

	xor	r15d, r15d
$LN3@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm6, XMMWORD PTR __xmm@3f800000000000003f80000000000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3133 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3134 :     ImGuiColorMod backup;
; 3135 :     backup.Col = idx;

	mov	DWORD PTR backup$23[rbp-256], r15d

; 3136 :     backup.BackupValue = g.Style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rbx+14776]
	movups	XMMWORD PTR backup$23[rbp-252], xmm0

; 3137 :     g.ColorStack.push_back(backup);

	lea	rcx, QWORD PTR [rbx+18824]
	lea	rdx, QWORD PTR backup$23[rbp-256]
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3138 :     g.Style.Colors[idx] = col;

	movups	XMMWORD PTR [rbx+14776], xmm6

; 10420:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	movss	xmm0, DWORD PTR [rax+14616]
	addss	xmm0, xmm0
	addss	xmm0, DWORD PTR [rax+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T16[rsp], xmm0
	mov	DWORD PTR $T16[rsp+4], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 113  :     if (ImGui::Button(("+##Sequential" + std::to_string(mNode->NodeIndex)).c_str(), ImVec2(ImGui::GetFrameHeight(), 0))) {

	mov	rax, QWORD PTR [rsi+8]
	movzx	edx, WORD PTR [rax+2]
	lea	rcx, QWORD PTR $T31[rbp-256]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r9d, 13
	lea	r8, OFFSET FLAT:??_C@_0O@DJKIKBBP@?$CL?$CD?$CDSequential@
	mov	rcx, rax
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T11[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T11[rsp+16], r15

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T11[rsp+24], r15

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T11[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T11[rsp+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], r15

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], 0

; 4986 :     return _STD move(_Right.insert(0, _Left));

	or	r14d, 64				; 00000040H

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T11[rsp]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T11[rsp+24], 16
	cmovae	rcx, QWORD PTR $T11[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T16[rsp]
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T11[rsp+24]
	cmp	r8, 16
	jb	SHORT $LN918@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T11[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN918@Render:

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T11[rsp+16], r15

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T11[rsp+24], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T11[rsp], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T31[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN926@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T31[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN926@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 113  :     if (ImGui::Button(("+##Sequential" + std::to_string(mNode->NodeIndex)).c_str(), ImVec2(ImGui::GetFrameHeight(), 0))) {

	test	bl, bl
	je	SHORT $LN1186@Render

; 114  :         mSeqCount++;

	inc	WORD PTR [rsi+272]
$LN1186@Render:

; 115  :     }
; 116  :     ImGui::PopStyleColor();

	mov	ecx, 1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor

; 117  :     ImGui::SameLine();

	movaps	xmm1, xmm13
	movaps	xmm0, xmm7
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm6, XMMWORD PTR __xmm@3f8000003d8f5c293d8f5c293ef0a3d7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3133 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3134 :     ImGuiColorMod backup;
; 3135 :     backup.Col = idx;

	mov	DWORD PTR backup$22[rbp-256], r15d

; 3136 :     backup.BackupValue = g.Style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rbx+14776]
	movups	XMMWORD PTR backup$22[rbp-252], xmm0

; 3137 :     g.ColorStack.push_back(backup);

	lea	rcx, QWORD PTR [rbx+18824]
	lea	rdx, QWORD PTR backup$22[rbp-256]
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3138 :     g.Style.Colors[idx] = col;

	movups	XMMWORD PTR [rbx+14776], xmm6

; 10420:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	movss	xmm0, DWORD PTR [rax+14616]
	addss	xmm0, xmm0
	addss	xmm0, DWORD PTR [rax+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T15[rsp], xmm0
	mov	DWORD PTR $T15[rsp+4], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 119  :     if (ImGui::Button(("-##Sequential" + std::to_string(mNode->NodeIndex)).c_str(), ImVec2(ImGui::GetFrameHeight(), 0)) && mSeqCount > 2) {

	mov	rax, QWORD PTR [rsi+8]
	movzx	edx, WORD PTR [rax+2]
	lea	rcx, QWORD PTR $T37[rbp-256]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	npad	1
	or	r14d, 1
	mov	DWORD PTR $T9[rsp], r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r9d, 13
	lea	r8, OFFSET FLAT:??_C@_0O@MBGKOKKJ@?9?$CD?$CDSequential@
	mov	rcx, rax
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T10[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T10[rsp+16], r15

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T10[rsp+24], r15

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T10[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T10[rsp+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], r15

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], 0

; 4986 :     return _STD move(_Right.insert(0, _Left));

	or	r14d, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 119  :     if (ImGui::Button(("-##Sequential" + std::to_string(mNode->NodeIndex)).c_str(), ImVec2(ImGui::GetFrameHeight(), 0)) && mSeqCount > 2) {

	or	r14d, 2
	mov	DWORD PTR $T9[rsp], r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T10[rsp]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T10[rsp+24], 16
	cmovae	rcx, QWORD PTR $T10[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T15[rsp]
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 119  :     if (ImGui::Button(("-##Sequential" + std::to_string(mNode->NodeIndex)).c_str(), ImVec2(ImGui::GetFrameHeight(), 0)) && mSeqCount > 2) {

	test	al, al
	je	SHORT $LN1187@Render
	cmp	WORD PTR [rsi+272], 2
	jbe	SHORT $LN1187@Render
	mov	bl, 1
	jmp	SHORT $LN33@Render
$LN1187@Render:
	xor	bl, bl
$LN33@Render:
	test	r14b, 2
	je	SHORT $LN955@Render
	and	r14d, -3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T10[rsp+24]
	cmp	r8, 16
	jb	SHORT $LN954@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T10[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN954@Render:

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T10[rsp+16], r15

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T10[rsp+24], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T10[rsp], 0
$LN955@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 119  :     if (ImGui::Button(("-##Sequential" + std::to_string(mNode->NodeIndex)).c_str(), ImVec2(ImGui::GetFrameHeight(), 0)) && mSeqCount > 2) {

	test	r14b, 1
	je	SHORT $LN947@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T37[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN946@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T37[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN946@Render:

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T37[rbp-240], r15

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T37[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T37[rbp-256], 0
$LN947@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 119  :     if (ImGui::Button(("-##Sequential" + std::to_string(mNode->NodeIndex)).c_str(), ImVec2(ImGui::GetFrameHeight(), 0)) && mSeqCount > 2) {

	test	bl, bl
	je	$LN962@Render

; 120  :         mSeqCount--;

	movzx	eax, WORD PTR [rsi+272]
	dec	ax
	movzx	ecx, ax
	mov	WORD PTR [rsi+272], cx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	mov	r14, QWORD PTR [rsi+8]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdi, QWORD PTR [r14+448]
	mov	rdx, QWORD PTR [r14+440]
	mov	rax, rdi
	sub	rax, rdx
	sar	rax, 3
	mov	r8, 8040888442386214807			; 6f96f96f96f96f97H
	imul	rax, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 121  :         if (mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size() >= mSeqCount) {

	cmp	rax, rcx
	jb	SHORT $LN962@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, rdi
	sub	rax, rdx
	sar	rax, 3
	imul	rax, r8

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rcx, rax
	jae	SHORT $LN962@Render

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rsi, rcx, 312				; 00000138H
	add	rsi, rdx

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN967@Render
$LL968@Render:
	mov	rcx, rbx
	call	??1LinkedNodeInfo@AINBFile@@QEAA@XZ
	add	rbx, 312				; 00000138H
	cmp	rbx, rdi
	jne	SHORT $LL968@Render
$LN967@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [r14+448], rsi
	mov	rsi, QWORD PTR this$GSCopy$1$[rbp-256]
$LN962@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3143 :     ImGuiContext& g = *GImGui;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3144 :     if (g.ColorStack.Size < count)

	movsxd	rax, DWORD PTR [r8+18824]
	cmp	eax, 1
	jl	SHORT $LN648@Render

; 3145 :     {
; 3146 :         IM_ASSERT_USER_ERROR(g.ColorStack.Size > count, "Calling PopStyleColor() too many times: stack underflow.");
; 3147 :         count = g.ColorStack.Size;
; 3148 :     }
; 3149 :     while (count > 0)
; 3150 :     {
; 3151 :         ImGuiColorMod& backup = g.ColorStack.back();

	lea	rdx, QWORD PTR [rax+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	rcx, QWORD PTR [r8+18832]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3152 :         g.Style.Colors[backup.Col] = backup.BackupValue;

	movsxd	rax, DWORD PTR [rcx+rdx*4-20]
	add	rax, rax
	movups	xmm0, XMMWORD PTR [rcx+rdx*4-16]
	movups	XMMWORD PTR [r8+rax*8+14776], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [r8+18824]
$LN648@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10258:     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rax, QWORD PTR [r8+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm8, DWORD PTR [rax+316]
	subss	xmm8, DWORD PTR [rax+84]
	movss	xmm6, DWORD PTR [rax+312]
	subss	xmm6, DWORD PTR [rax+80]

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm8, DWORD PTR [rax+188]
	addss	xmm6, DWORD PTR [rax+184]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 128  :     bool HasImmediate = false;

	mov	BYTE PTR HasImmediate$1$[rsp], 0

; 129  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	dl, dl
	mov	rax, QWORD PTR [rsi+8]
	mov	r8, QWORD PTR [rax+152]
	npad	14
$LL7@Render:

; 130  :         if (!mNode->ImmediateParameters[i].empty()) {

	movzx	eax, dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rcx, QWORD PTR [rax+rax*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 130  :         if (!mNode->ImmediateParameters[i].empty()) {

	mov	rax, QWORD PTR [r8+rcx*8+8]
	cmp	QWORD PTR [r8+rcx*8], rax
	jne	SHORT $LN1066@Render

; 129  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	inc	dl
	cmp	dl, 6
	jb	SHORT $LL7@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2620 :         if (_Count > max_size()) {

	jmp	SHORT $LN23@Render
$LN1066@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 131  :             HasImmediate = true;

	mov	BYTE PTR HasImmediate$1$[rsp], 1

; 132  :             break;
; 133  :         }
; 134  :     }
; 135  : 
; 136  :     if (HasImmediate)
; 137  :         ImGui::NewLine();

	call	?NewLine@ImGui@@YAXXZ			; ImGui::NewLine
$LN23@Render:

; 138  : 
; 139  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	r8b, r8b
	mov	BYTE PTR i$1$[rsp], r8b
	lea	rdi, OFFSET FLAT:__ImageBase
$LL10@Render:

; 140  :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	mov	rdx, QWORD PTR [rsi+8]
	movzx	eax, r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rcx, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR [rdx+152]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 140  :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	mov	r14, QWORD PTR [rax+rcx*8]
	mov	r13, QWORD PTR [rax+rcx*8+8]
	cmp	r14, r13
	je	$LN8@Render
	lea	rbx, QWORD PTR [r14+64]
	movzx	r12d, r8b
$LL13@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx-40], 16
	jb	SHORT $LN1189@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN1189@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 256  :     TextEx(text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);

	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+1]
	call	?TextEx@ImGui@@YAXPEBD0H@Z		; ImGui::TextEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 143  :             ImGui::SameLine();

	movaps	xmm1, xmm13
	movaps	xmm0, xmm7
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rdx, BYTE PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 145  :             bool ValueTypeMismatch = Immediate.ValueType != Immediate.Value.index();

	movsxd	rax, DWORD PTR [rbx+8]

; 146  :             if (ValueTypeMismatch) {

	cmp	rax, rdx
	je	$LN592@Render

; 147  :                 switch (i) {

	mov	ecx, r12d
	test	r12d, r12d
	je	$LN25@Render
	sub	ecx, 1
	je	$LN27@Render
	sub	ecx, 1
	je	$LN26@Render
	sub	ecx, 1
	je	SHORT $LN28@Render
	cmp	ecx, 1
	jne	$LN592@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1031 :         if (index() == _TargetIdx) {

	cmp	dl, 4
	jne	SHORT $LN105@Render

; 1032 :             auto& _Target = _STD _Variant_raw_get<_TargetIdx>(_Storage());
; 1033 :             _Target       = static_cast<_Ty&&>(_Obj);

	movaps	xmm0, xmm7
	unpcklps xmm0, xmm7
	movsd	QWORD PTR [rbx-32], xmm0
	movss	DWORD PTR [rbx-24], xmm7

; 1034 :         } else {

	jmp	$LN592@Render
$LN105@Render:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1198@Render[rdi+rdx*4+4]
	add	rax, rdi
	jmp	rax
$LN125@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN143@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 391  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movaps	xmm0, xmm7
	unpcklps xmm0, xmm7
	movsd	QWORD PTR [rbx-32], xmm0
	movss	DWORD PTR [rbx-24], xmm7

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 4
	jmp	$LN592@Render
$LN28@Render:

; 1031 :         if (index() == _TargetIdx) {

	cmp	dl, 3
	jne	SHORT $LN193@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3395 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rcx, QWORD PTR [rbx-32]
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1034 :         } else {

	jmp	$LN592@Render
$LN193@Render:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR _Temp$29[rbp-256], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR _Temp$29[rbp-240], r15

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR _Temp$29[rbp-232], 15

; 2631 : 
; 2632 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2633 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2634 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2635 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2636 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR _Temp$29[rbp-256], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1197@Render[rdi+rdx*4+4]
	add	rax, rdi
	jmp	rax
$LN258@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN276@Render:

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR _Temp$29[rbp-256]
	movups	XMMWORD PTR [rbx-32], xmm0
	movups	xmm1, XMMWORD PTR _Temp$29[rbp-240]
	movups	XMMWORD PTR [rbx-16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 159  :                     break;

	jmp	SHORT $LN592@Render
$LN26@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1031 :         if (index() == _TargetIdx) {

	cmp	dl, 2
	je	SHORT $LN1206@Render

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1196@Render[rdi+rdx*4+4]
	add	rax, rdi
	jmp	rax
$LN484@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN502@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	DWORD PTR [rbx-32], r15d

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 153  :                     break;

	jmp	SHORT $LN592@Render
$LN27@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1031 :         if (index() == _TargetIdx) {

	cmp	dl, 1
	je	SHORT $LN1207@Render

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1195@Render[rdi+rdx*4+4]
	add	rax, rdi
	jmp	rax
$LN430@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN448@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 1
$LN1207@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 156  :                     break;

	mov	rcx, -32				; ffffffffffffffe0H
	mov	rax, rbx
	mov	BYTE PTR [rbx+rcx], 0
	jmp	SHORT $LN592@Render
$LN25@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1031 :         if (index() == _TargetIdx) {

	test	dl, dl
	je	SHORT $LN1206@Render

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1194@Render[rdi+rdx*4+4]
	add	rax, rdi
	jmp	rax
$LN560@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN578@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 0
$LN1206@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	mov	DWORD PTR [rbx-32], r15d
$LN592@Render:
	xorps	xmm0, xmm0
	movups	XMMWORD PTR $T30[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T30[rbp-240], r15

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T30[rbp-232], r15

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [rbx-48]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, r14

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx-40], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN1188@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [r14]
$LN1188@Render:

; 2620 :         if (_Count > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rsi, rax
	ja	$LN1068@Render

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T30[rbp-232], 15
	cmp	rsi, 16
	jae	SHORT $LN67@Render

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T30[rbp-240], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T30[rbp-256], xmm0

; 2647 :             return;

	jmp	SHORT $LN83@Render
$LN67@Render:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdi, rsi
	or	rdi, 15

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	cmp	rdi, rax
	jbe	SHORT $LN78@Render

; 4716 :             return _Max;

	mov	rdi, rax
	jmp	SHORT $LN77@Render
$LN78@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	cmp	rdi, 22
	mov	eax, 22
	cmovb	rdi, rax
$LN77@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rdi
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T30[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T30[rbp-240], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T30[rbp-232], rdi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	lea	rdi, OFFSET FLAT:__ImageBase
$LN83@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 166  :             DrawParameterValue(static_cast<AINBFile::ValueType>(i), Immediate.Name, CurrentId, (void*)&Immediate.Value);

	lea	rax, QWORD PTR [rbx-32]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR CurrentId$1$[rsp]
	lea	r8, QWORD PTR $T30[rbp-256]
	mov	edx, r12d
	mov	rsi, QWORD PTR this$GSCopy$1$[rbp-256]
	mov	rcx, rsi
	call	?DrawParameterValue@UIAINBNodeBase@@QEAAXW4ValueType@AINBFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPEAX@Z ; UIAINBNodeBase::DrawParameterValue

; 140  :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	add	r14, 200				; 000000c8H
	add	rbx, 200				; 000000c8H
	cmp	r14, r13
	mov	r15d, 0
	jne	$LL13@Render
	movzx	r8d, BYTE PTR i$1$[rsp]
$LN8@Render:

; 138  : 
; 139  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	inc	r8b
	mov	BYTE PTR i$1$[rsp], r8b
	cmp	r8b, 6
	jb	$LL10@Render
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_node_editor\imgui_node_editor_api.cpp

; 193  :     s_Editor->GetNodeBuilder().End();

	mov	rcx, QWORD PTR ?s_Editor@@3PEAUEditorContext@Detail@NodeEditor@ax@@EA
	add	rcx, 1032				; 00000408H
	call	?End@NodeBuilder@Detail@NodeEditor@ax@@QEAAXXZ ; ax::NodeEditor::Detail::NodeBuilder::End
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 171  :     ed::PopStyleVar();

	call	?PopStyleVar@NodeEditor@ax@@YAXH@Z	; ax::NodeEditor::PopStyleVar

; 172  : 
; 173  :     DrawNodeHeader();

	mov	rcx, rsi
	call	?DrawNodeHeader@UIAINBNodeBase@@QEAAXXZ	; UIAINBNodeBase::DrawNodeHeader

; 174  :     if (HasImmediate)

	cmp	BYTE PTR HasImmediate$1$[rsp], 0
	je	SHORT $LN30@Render

; 175  :         DrawImmediateSeperator(CursorPos);

	movaps	xmm0, xmm6
	unpcklps xmm0, xmm8
	movq	rdx, xmm0
	mov	rcx, rsi
	call	?DrawImmediateSeperator@UIAINBNodeBase@@QEAAXUImVec2@@@Z ; UIAINBNodeBase::DrawImmediateSeperator
$LN30@Render:

; 176  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+480]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN138@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN271@Render:
$LN497@Render:
$LN443@Render:
$LN573@Render:
$LN1065@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1068@Render:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1202@Render:
	npad	1
$LN1198@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 176  : }

	DD	$LN143@Render
	DD	$LN143@Render
	DD	$LN143@Render
	DD	$LN143@Render
	DD	$LN125@Render
	DD	$LN143@Render
$LN1197@Render:
	DD	$LN276@Render
	DD	$LN276@Render
	DD	$LN276@Render
	DD	$LN276@Render
	DD	$LN258@Render
	DD	$LN276@Render
$LN1196@Render:
	DD	$LN502@Render
	DD	$LN502@Render
	DD	$LN502@Render
	DD	$LN502@Render
	DD	$LN484@Render
	DD	$LN502@Render
$LN1195@Render:
	DD	$LN448@Render
	DD	$LN448@Render
	DD	$LN448@Render
	DD	$LN448@Render
	DD	$LN430@Render
	DD	$LN448@Render
$LN1194@Render:
	DD	$LN578@Render
	DD	$LN578@Render
	DD	$LN578@Render
	DD	$LN578@Render
	DD	$LN560@Render
	DD	$LN578@Render
?Render@UIAINBNodeSequential@@UEAAXXZ ENDP		; UIAINBNodeSequential::Render
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
HasImmediate$1$ = 65
tv6081 = 68
$T9 = 68
CurrentId$1$ = 72
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 120
$T15 = 120
$T16 = 120
HeaderRect$17 = 120
$T18 = 120
$T19 = 136
$T20 = 136
this$GSCopy$1$ = 144
text_size$21 = 152
backup$22 = 160
backup$23 = 160
$T24 = 160
$T25 = 184
$T26 = 184
$T27 = 200
$T28 = 240
_Temp$29 = 256
$T30 = 256
$T31 = 256
$T32 = 256
$T33 = 256
$T34 = 256
$T35 = 256
$T36 = 256
$T37 = 288
Text$38 = 288
_Buff$39 = 320
__$ArrayPad$ = 344
this$ = 528
?dtor$1@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA PROC ; `UIAINBNodeSequential::Render'::`1'::dtor$1
	lea	rcx, QWORD PTR $T34[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSequential::Render'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
HasImmediate$1$ = 65
tv6081 = 68
$T9 = 68
CurrentId$1$ = 72
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 120
$T15 = 120
$T16 = 120
HeaderRect$17 = 120
$T18 = 120
$T19 = 136
$T20 = 136
this$GSCopy$1$ = 144
text_size$21 = 152
backup$22 = 160
backup$23 = 160
$T24 = 160
$T25 = 184
$T26 = 184
$T27 = 200
$T28 = 240
_Temp$29 = 256
$T30 = 256
$T31 = 256
$T32 = 256
$T33 = 256
$T34 = 256
$T35 = 256
$T36 = 256
$T37 = 288
Text$38 = 288
_Buff$39 = 320
__$ArrayPad$ = 344
this$ = 528
?dtor$2@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA PROC ; `UIAINBNodeSequential::Render'::`1'::dtor$2
	lea	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSequential::Render'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
HasImmediate$1$ = 65
tv6081 = 68
$T9 = 68
CurrentId$1$ = 72
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 120
$T15 = 120
$T16 = 120
HeaderRect$17 = 120
$T18 = 120
$T19 = 136
$T20 = 136
this$GSCopy$1$ = 144
text_size$21 = 152
backup$22 = 160
backup$23 = 160
$T24 = 160
$T25 = 184
$T26 = 184
$T27 = 200
$T28 = 240
_Temp$29 = 256
$T30 = 256
$T31 = 256
$T32 = 256
$T33 = 256
$T34 = 256
$T35 = 256
$T36 = 256
$T37 = 288
Text$38 = 288
_Buff$39 = 320
__$ArrayPad$ = 344
this$ = 528
?dtor$3@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA PROC ; `UIAINBNodeSequential::Render'::`1'::dtor$3
	lea	rcx, QWORD PTR Text$38[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSequential::Render'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
HasImmediate$1$ = 65
tv6081 = 68
$T9 = 68
CurrentId$1$ = 72
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 120
$T15 = 120
$T16 = 120
HeaderRect$17 = 120
$T18 = 120
$T19 = 136
$T20 = 136
this$GSCopy$1$ = 144
text_size$21 = 152
backup$22 = 160
backup$23 = 160
$T24 = 160
$T25 = 184
$T26 = 184
$T27 = 200
$T28 = 240
_Temp$29 = 256
$T30 = 256
$T31 = 256
$T32 = 256
$T33 = 256
$T34 = 256
$T35 = 256
$T36 = 256
$T37 = 288
Text$38 = 288
_Buff$39 = 320
__$ArrayPad$ = 344
this$ = 528
?dtor$5@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA PROC ; `UIAINBNodeSequential::Render'::`1'::dtor$5
	lea	rcx, QWORD PTR $T31[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSequential::Render'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
HasImmediate$1$ = 65
tv6081 = 68
$T9 = 68
CurrentId$1$ = 72
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 120
$T15 = 120
$T16 = 120
HeaderRect$17 = 120
$T18 = 120
$T19 = 136
$T20 = 136
this$GSCopy$1$ = 144
text_size$21 = 152
backup$22 = 160
backup$23 = 160
$T24 = 160
$T25 = 184
$T26 = 184
$T27 = 200
$T28 = 240
_Temp$29 = 256
$T30 = 256
$T31 = 256
$T32 = 256
$T33 = 256
$T34 = 256
$T35 = 256
$T36 = 256
$T37 = 288
Text$38 = 288
_Buff$39 = 320
__$ArrayPad$ = 344
this$ = 528
?dtor$6@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA PROC ; `UIAINBNodeSequential::Render'::`1'::dtor$6
	lea	rcx, QWORD PTR $T11[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSequential::Render'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
HasImmediate$1$ = 65
tv6081 = 68
$T9 = 68
CurrentId$1$ = 72
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 120
$T15 = 120
$T16 = 120
HeaderRect$17 = 120
$T18 = 120
$T19 = 136
$T20 = 136
this$GSCopy$1$ = 144
text_size$21 = 152
backup$22 = 160
backup$23 = 160
$T24 = 160
$T25 = 184
$T26 = 184
$T27 = 200
$T28 = 240
_Temp$29 = 256
$T30 = 256
$T31 = 256
$T32 = 256
$T33 = 256
$T34 = 256
$T35 = 256
$T36 = 256
$T37 = 288
Text$38 = 288
_Buff$39 = 320
__$ArrayPad$ = 344
this$ = 528
?dtor$7@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA PROC ; `UIAINBNodeSequential::Render'::`1'::dtor$7
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T9[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN42@dtor$7
	and	DWORD PTR $T9[rbp], -2
	lea	rcx, QWORD PTR $T37[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN42@dtor$7:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$7@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSequential::Render'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
HasImmediate$1$ = 65
tv6081 = 68
$T9 = 68
CurrentId$1$ = 72
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 120
$T15 = 120
$T16 = 120
HeaderRect$17 = 120
$T18 = 120
$T19 = 136
$T20 = 136
this$GSCopy$1$ = 144
text_size$21 = 152
backup$22 = 160
backup$23 = 160
$T24 = 160
$T25 = 184
$T26 = 184
$T27 = 200
$T28 = 240
_Temp$29 = 256
$T30 = 256
$T31 = 256
$T32 = 256
$T33 = 256
$T34 = 256
$T35 = 256
$T36 = 256
$T37 = 288
Text$38 = 288
_Buff$39 = 320
__$ArrayPad$ = 344
this$ = 528
?dtor$8@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA PROC ; `UIAINBNodeSequential::Render'::`1'::dtor$8
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T9[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN44@dtor$8
	and	DWORD PTR $T9[rbp], -3
	lea	rcx, QWORD PTR $T10[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN44@dtor$8:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$8@?0??Render@UIAINBNodeSequential@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSequential::Render'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
;	COMDAT ?RenderLinks@UIAINBNodeSequential@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 72
$T4 = 88
this$ = 176
Nodes$ = 184
?RenderLinks@UIAINBNodeSequential@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z PROC ; UIAINBNodeSequential::RenderLinks, COMDAT

; 179  : {

$LN59:
	mov	r11, rsp
	mov	QWORD PTR [r11+24], rbx
	push	rbp
	push	rdi
	push	r12
	push	r13
	push	r14
	sub	rsp, 128				; 00000080H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	mov	r8, QWORD PTR [rcx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 181  :     for (int i = 0; i < mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size(); i++) {

	xor	r13d, r13d
	mov	r14d, DWORD PTR [rcx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r12, 8040888442386214807		; 6f96f96f96f96f97H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 180  :     uint32_t CurrentLinkId = mEditorId + 500; // Link start at +500

	add	r14d, 500				; 000001f4H
	mov	rdi, rdx
	mov	rbp, rcx

; 181  :     for (int i = 0; i < mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size(); i++) {

	mov	ebx, r13d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [r8+448]
	sub	rax, QWORD PTR [r8+440]
	sar	rax, 3
	imul	rax, r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 181  :     for (int i = 0; i < mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size(); i++) {

	test	rax, rax
	je	$LN3@RenderLink
	mov	QWORD PTR [r11+8], rsi
	mov	r9d, r13d
	mov	QWORD PTR [r11+16], r15
	movaps	XMMWORD PTR [rsp+112], xmm6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	movss	xmm6, DWORD PTR __real@3f800000
$LL4@RenderLink:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 182  :         if (mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex == -1 || mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex >= Nodes.size())

	mov	rax, QWORD PTR [r8+440]
	mov	r15d, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rsi, r9, 312				; 00000138H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 182  :         if (mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex == -1 || mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex >= Nodes.size())

	mov	edx, DWORD PTR [rax+rsi+4]
	cmp	edx, -1					; ffffffffH
	je	$LN2@RenderLink
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rdi+8]
	sub	rcx, QWORD PTR [rdi]
	sar	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 182  :         if (mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex == -1 || mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex >= Nodes.size())

	cmp	rdx, rcx
	jae	$LN2@RenderLink

; 185  :         ed::Link(CurrentLinkId++, mSeqToPinId[i], Nodes[mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex]->mEditorId + 1, GetValueTypeColor(6));

	mov	r8b, 6
	lea	rdx, QWORD PTR $T3[rsp]
	call	?GetValueTypeColor@UIAINBNodeBase@@QEAA?AUImColor@@E@Z ; UIAINBNodeBase::GetValueTypeColor
	movss	DWORD PTR [rsp+32], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2591 :     inline operator ImVec4() const                                  { return Value; }

	movups	xmm0, XMMWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 185  :         ed::Link(CurrentLinkId++, mSeqToPinId[i], Nodes[mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex]->mEditorId + 1, GetValueTypeColor(6));

	mov	rax, QWORD PTR [rbp+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2591 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T2[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 185  :         ed::Link(CurrentLinkId++, mSeqToPinId[i], Nodes[mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex]->mEditorId + 1, GetValueTypeColor(6));

	mov	rcx, QWORD PTR [rax+440]
	mov	rax, QWORD PTR [rdi]
	mov	ecx, DWORD PTR [rcx+rsi+4]
	mov	rcx, QWORD PTR [rax+rcx*8]
	mov	rax, QWORD PTR [rbp+280]
	mov	r8d, DWORD PTR [rcx+16]
	mov	edx, DWORD PTR [rax+r9*4]
	inc	r8d
	mov	ecx, r14d
	lea	r9, QWORD PTR $T2[rsp]
	inc	r14d
	call	?Link@NodeEditor@ax@@YA_NULinkId@12@UPinId@12@1AEBUImVec4@@M@Z ; ax::NodeEditor::Link
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rbp+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 186  :         mLinks.insert({ CurrentLinkId - 1, Link { .ObjectPtr = mNode, .Type = LinkType::Flow, .ParameterIndex = (uint16_t)i } });

	lea	rcx, QWORD PTR [rbp+184]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T1[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR $T1[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	rdx, QWORD PTR $T4[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	DWORD PTR $T1[rsp], r15d
	mov	DWORD PTR $T1[rsp+16], 1
	mov	WORD PTR $T1[rsp+20], r13w
	mov	WORD PTR $T1[rsp+22], bx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	call	??$emplace@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IULink@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIULink@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Link,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Link> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Link> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 187  :         Nodes[mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex]->mFlowLinked = true;

	mov	rax, QWORD PTR [rbp+8]
	mov	rcx, QWORD PTR [rax+440]
	mov	rax, QWORD PTR [rdi]
	mov	ecx, DWORD PTR [rcx+rsi+4]
	mov	rcx, QWORD PTR [rax+rcx*8]
	mov	BYTE PTR [rcx+264], 1
$LN2@RenderLink:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	mov	r8, QWORD PTR [rbp+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 181  :     for (int i = 0; i < mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size(); i++) {

	inc	ebx
	movsxd	r9, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [r8+448]
	sub	rax, QWORD PTR [r8+440]
	sar	rax, 3
	imul	rax, r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 181  :     for (int i = 0; i < mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size(); i++) {

	cmp	r9, rax
	jb	$LL4@RenderLink
	movaps	xmm6, XMMWORD PTR [rsp+112]
	mov	r15, QWORD PTR [rsp+184]
	mov	rsi, QWORD PTR [rsp+176]
$LN3@RenderLink:

; 188  :     }
; 189  : }

	mov	rbx, QWORD PTR [rsp+192]
	add	rsp, 128				; 00000080H
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
?RenderLinks@UIAINBNodeSequential@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z ENDP ; UIAINBNodeSequential::RenderLinks
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp
;	COMDAT ?GetHeaderColor@UIAINBNodeSequential@@UEAA?AUImColor@@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?GetHeaderColor@UIAINBNodeSequential@@UEAA?AUImColor@@XZ PROC ; UIAINBNodeSequential::GetHeaderColor, COMDAT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	mov	DWORD PTR [rdx], 1055977714		; 3ef0f0f2H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 193  :     return ImColor(120, 20, 20);

	mov	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	mov	DWORD PTR [rdx+4], 1033937057		; 3da0a0a1H
	mov	DWORD PTR [rdx+8], 1033937057		; 3da0a0a1H
	mov	DWORD PTR [rdx+12], 1065353216		; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSequential.cpp

; 194  : }

	ret	0
?GetHeaderColor@UIAINBNodeSequential@@UEAA?AUImColor@@XZ ENDP ; UIAINBNodeSequential::GetHeaderColor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<AINBFile::LinkedNodeInfo,std::allocator<AINBFile::LinkedNodeInfo> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN30:
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	r14, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	r9, 8040888442386214807			; 6f96f96f96f96f97H
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN4@resize
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rsi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rsi, rdx, 312				; 00000138H
	add	rsi, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN10@resize
	npad	2
$LL11@resize:
	mov	rcx, rbx
	call	??1LinkedNodeInfo@AINBFile@@QEAA@XZ
	add	rbx, 312				; 00000138H
	cmp	rbx, rdi
	jne	SHORT $LL11@resize
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rsi
	mov	rsi, QWORD PTR [rsp+56]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBFile::LinkedNodeInfo,std::allocator<AINBFile::LinkedNodeInfo> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	r8, r14
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAPEAULinkedNodeInfo@AINBFile@@PEAU12@_KAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBFile::LinkedNodeInfo> >
	mov	QWORD PTR [r14+8], rax
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?resize@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<AINBFile::LinkedNodeInfo,std::allocator<AINBFile::LinkedNodeInfo> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<AINBFile::LinkedNodeInfo,std::allocator<AINBFile::LinkedNodeInfo> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN28:
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]
	mov	r14, rcx
	mov	r8, QWORD PTR [rcx]
	mov	r9, 8040888442386214807			; 6f96f96f96f96f97H
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rsi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rsi, rdx, 312				; 00000138H
	add	rsi, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN8@Resize
	npad	2
$LL9@Resize:
	mov	rcx, rbx
	call	??1LinkedNodeInfo@AINBFile@@QEAA@XZ
	add	rbx, 312				; 00000138H
	cmp	rbx, rdi
	jne	SHORT $LL9@Resize
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rsi
	mov	rsi, QWORD PTR [rsp+56]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<AINBFile::LinkedNodeInfo,std::allocator<AINBFile::LinkedNodeInfo> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	r8, r14
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAPEAULinkedNodeInfo@AINBFile@@PEAU12@_KAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBFile::LinkedNodeInfo> >
	mov	QWORD PTR [r14+8], rax
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<AINBFile::LinkedNodeInfo,std::allocator<AINBFile::LinkedNodeInfo> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
_Appended_last$ = 32
_Newcapacity$ = 40
_Appended_first$ = 48
_Newvec$ = 56
this$ = 112
_Newsize$ = 120
_Val$dead$ = 128
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<AINBFile::LinkedNodeInfo,std::allocator<AINBFile::LinkedNodeInfo> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN58:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	r15, rdx
	mov	r14, rcx

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 59124179723428050			; 00d20d20d20d20d2H
	cmp	rdx, rbx
	ja	$LN57@Resize_rea

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]
	sub	rdi, QWORD PTR [rcx]
	sar	rdi, 3
	mov	rdx, 8040888442386214807		; 6f96f96f96f96f97H
	imul	rdi, rdx

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [r14]
	sar	rcx, 3
	imul	rcx, rdx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	mov	rax, rbx
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN55@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, r15
	cmovb	rbx, r15
$LN55@Resize_rea:

; 1522 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1523 : 
; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	QWORD PTR _Newcapacity$[rsp], rbx
	mov	rdx, rbx
	call	?allocate@?$allocator@ULinkedNodeInfo@AINBFile@@@std@@QEAAPEAULinkedNodeInfo@AINBFile@@_K@Z ; std::allocator<AINBFile::LinkedNodeInfo>::allocate
	mov	r12, rax
	mov	QWORD PTR _Newvec$[rsp], rax

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	imul	rcx, rdi, 312				; 00000138H
	add	rcx, rax
	mov	QWORD PTR _Appended_first$[rsp], rcx

; 1526 :         pointer _Appended_last        = _Appended_first;

	mov	QWORD PTR _Appended_last$[rsp], rcx

; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	rdx, r15
	sub	rdx, rdi
	mov	r8, r14
	call	??$_Uninitialized_value_construct_n@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAPEAULinkedNodeInfo@AINBFile@@PEAU12@_KAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<AINBFile::LinkedNodeInfo> >
	mov	QWORD PTR _Appended_last$[rsp], rax

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rsi, QWORD PTR [r14+8]
	mov	r11, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	r11, rsi
	je	SHORT $LN17@Resize_rea
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rdi, r12
	sub	rdi, r11
	npad	4
$LL18@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	lea	rcx, QWORD PTR [rdi+r11]
	mov	rdx, r11
	call	??0LinkedNodeInfo@AINBFile@@QEAA@$$QEAU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	r11, 312				; 00000138H
	cmp	r11, rsi
	jne	SHORT $LL18@Resize_rea
$LN17@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, r15
	mov	rdx, r12
	mov	rcx, r14

; 1548 :     }

	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi

; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAXQEAULinkedNodeInfo@AINBFile@@_K1@Z ; std::vector<AINBFile::LinkedNodeInfo,std::allocator<AINBFile::LinkedNodeInfo> >::_Change_array
$LN57@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@CAXXZ ; std::vector<AINBFile::LinkedNodeInfo,std::allocator<AINBFile::LinkedNodeInfo> >::_Xlength
	int	3
$LN54@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<AINBFile::LinkedNodeInfo,std::allocator<AINBFile::LinkedNodeInfo> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Appended_last$ = 32
_Newcapacity$ = 40
_Appended_first$ = 48
_Newvec$ = 56
this$ = 112
_Newsize$ = 120
_Val$dead$ = 128
?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA PROC ; `std::vector<AINBFile::LinkedNodeInfo,std::allocator<AINBFile::LinkedNodeInfo> >::_Resize_reallocate<std::_Value_init_tag>'::`1'::catch$0

; 1541 :         _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z$0:

; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);

	mov	rdx, QWORD PTR _Appended_last$[rbp]
	mov	rcx, QWORD PTR _Appended_first$[rbp]
	call	??$_Destroy_range@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAXPEAULinkedNodeInfo@AINBFile@@QEAU12@AEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z ; std::_Destroy_range<std::allocator<AINBFile::LinkedNodeInfo> >

; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	call	?deallocate@?$allocator@ULinkedNodeInfo@AINBFile@@@std@@QEAAXQEAULinkedNodeInfo@AINBFile@@_K@Z ; std::allocator<AINBFile::LinkedNodeInfo>::deallocate

; 1544 :         _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA ENDP ; `std::vector<AINBFile::LinkedNodeInfo,std::allocator<AINBFile::LinkedNodeInfo> >::_Resize_reallocate<std::_Value_init_tag>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAPEAULinkedNodeInfo@AINBFile@@PEAU12@_KAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z
_TEXT	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Al$ = 96
??$_Uninitialized_value_construct_n@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAPEAULinkedNodeInfo@AINBFile@@PEAU12@_KAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<AINBFile::LinkedNodeInfo> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN44:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], rcx
	mov	QWORD PTR _Backout$[rsp+8], rcx
	mov	QWORD PTR _Backout$[rsp+16], r8

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN41@Uninitiali
	npad	5
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	edx, edx
	mov	r8d, 312				; 00000138H
	mov	rcx, rbx
	call	memset
	mov	rcx, rbx
	call	??0LinkedNodeInfo@AINBFile@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 312				; 00000138H
	mov	QWORD PTR _Backout$[rsp+8], rbx

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdi, 1
	jne	SHORT $LL4@Uninitiali
$LN41@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAPEAULinkedNodeInfo@AINBFile@@PEAU12@_KAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<AINBFile::LinkedNodeInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Al$ = 96
?dtor$0@?0???$_Uninitialized_value_construct_n@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAPEAULinkedNodeInfo@AINBFile@@PEAU12@_KAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z@4HA PROC ; `std::_Uninitialized_value_construct_n<std::allocator<AINBFile::LinkedNodeInfo> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<AINBFile::LinkedNodeInfo> >::~_Uninitialized_backout_al<std::allocator<AINBFile::LinkedNodeInfo> >
?dtor$0@?0???$_Uninitialized_value_construct_n@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@YAPEAULinkedNodeInfo@AINBFile@@PEAU12@_KAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@0@@Z@4HA ENDP ; `std::_Uninitialized_value_construct_n<std::allocator<AINBFile::LinkedNodeInfo> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<AINBFile::LinkedNodeInfo> >::_Emplace_back<>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rbx, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, rbx
	xor	edx, edx
	mov	r8d, 312				; 00000138H
	call	memset
	mov	rcx, rbx
	call	??0LinkedNodeInfo@AINBFile@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rdi+8], 312			; 00000138H

; 1804 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<AINBFile::LinkedNodeInfo> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@ULinkedNodeInfo@AINBFile@@$$V@?$_Default_allocator_traits@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@SAXAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@1@QEAULinkedNodeInfo@AINBFile@@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
??$construct@ULinkedNodeInfo@AINBFile@@$$V@?$_Default_allocator_traits@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@SAXAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@1@QEAULinkedNodeInfo@AINBFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<AINBFile::LinkedNodeInfo> >::construct<AINBFile::LinkedNodeInfo>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r8d, 312				; 00000138H
	mov	rcx, rbx
	xor	edx, edx
	call	memset
	mov	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	jmp	??0LinkedNodeInfo@AINBFile@@QEAA@XZ
??$construct@ULinkedNodeInfo@AINBFile@@$$V@?$_Default_allocator_traits@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@SAXAEAV?$allocator@ULinkedNodeInfo@AINBFile@@@1@QEAULinkedNodeInfo@AINBFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<AINBFile::LinkedNodeInfo> >::construct<AINBFile::LinkedNodeInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@ULinkedNodeInfo@AINBFile@@$$V$0A@@std@@YAPEAULinkedNodeInfo@AINBFile@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 48
??$construct_at@ULinkedNodeInfo@AINBFile@@$$V$0A@@std@@YAPEAULinkedNodeInfo@AINBFile@@QEAU12@@Z PROC ; std::construct_at<AINBFile::LinkedNodeInfo,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	edx, edx
	mov	r8d, 312				; 00000138H
	mov	rbx, rcx
	call	memset
	mov	rcx, rbx

; 242  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	jmp	??0LinkedNodeInfo@AINBFile@@QEAA@XZ
??$construct_at@ULinkedNodeInfo@AINBFile@@$$V$0A@@std@@YAPEAULinkedNodeInfo@AINBFile@@QEAU12@@Z ENDP ; std::construct_at<AINBFile::LinkedNodeInfo,0>
_TEXT	ENDS
END
