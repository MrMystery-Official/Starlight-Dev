; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_09IEDAEJCJ@X?5?3?5?$CF5?43f@		; `string'
PUBLIC	??_C@_09IAMFJJBE@Z?5?3?5?$CF5?43f@		; `string'
PUBLIC	??_C@_09GLPCCCBH@Y?5?3?5?$CF5?43f@		; `string'
PUBLIC	??_C@_0BE@CCMBIBJA@X?5?3?5?$CF5?43f?5Z?5?3?5?$CF5?43f@ ; `string'
PUBLIC	??_C@_0BE@EHKGLKNG@Y?5?3?5?$CF5?43f?5Z?5?3?5?$CF5?43f@ ; `string'
PUBLIC	??_C@_0BO@OLCODPHJ@X?5?3?5?$CF5?43f?5Y?5?3?5?$CF5?43f?5Z?5?3?5?$CF5?43f@ ; `string'
PUBLIC	??_C@_0BE@MJPGDKJD@X?5?3?5?$CF5?43f?5Y?5?3?5?$CF5?43f@ ; `string'
PUBLIC	??_C@_09GKDAEICA@Y?5?3?5?$CF5?42f@		; `string'
PUBLIC	??_C@_09IFPCCDBO@X?5?3?5?$CF5?42f@		; `string'
PUBLIC	??_C@_0M@CANMJCGJ@XYZ?5?3?5?$CF5?42f@		; `string'
PUBLIC	??_C@_09IBAHPDCD@Z?5?3?5?$CF5?42f@		; `string'
PUBLIC	??_C@_0BI@NAIKLCOB@Y?5?3?5?$CF5?42f?5deg?5?$CF5?42f?5rad@ ; `string'
PUBLIC	??_C@_0BI@FBKPNHMG@X?5?3?5?$CF5?42f?5deg?5?$CF5?42f?5rad@ ; `string'
PUBLIC	??_C@_0BN@IKEALIMN@Screen?5?3?5?$CF5?42f?5deg?5?$CF5?42f?5rad@ ; `string'
PUBLIC	??_C@_0BI@IIJEBLMJ@Z?5?3?5?$CF5?42f?5deg?5?$CF5?42f?5rad@ ; `string'
PUBLIC	??_C@_0BI@LOEGLDAO@X?3?5?$CF?42f?5Y?3?5?$CF?42f?5Z?3?5?$CF?42f@ ; `string'
PUBLIC	??_C@_05GJAGBLGB@gizmo@				; `string'
;	COMDAT ?panelSize@?1??ViewManipulate@ImGuizmo@@YAXPEAMMUImVec2@@1I@Z@4QBU3@B
CONST	SEGMENT
?panelSize@?1??ViewManipulate@ImGuizmo@@YAXPEAMMUImVec2@@1I@Z@4QBU3@B DD 03e800000r ; 0.25 ; `ImGuizmo::ViewManipulate'::`2'::panelSize
	DD	03e800000r			; 0.25
	DD	03f000000r			; 0.5
	DD	03e800000r			; 0.25
	DD	03e800000r			; 0.25
	DD	03e800000r			; 0.25
	DD	03e800000r			; 0.25
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03e800000r			; 0.25
	DD	03f000000r			; 0.5
	DD	03e800000r			; 0.25
	DD	03e800000r			; 0.25
	DD	03f000000r			; 0.5
	DD	03e800000r			; 0.25
	DD	03e800000r			; 0.25
	DD	03e800000r			; 0.25
CONST	ENDS
;	COMDAT ?panelPosition@?1??ViewManipulate@ImGuizmo@@YAXPEAMMUImVec2@@1I@Z@4QBU3@B
CONST	SEGMENT
?panelPosition@?1??ViewManipulate@ImGuizmo@@YAXPEAMMUImVec2@@1I@Z@4QBU3@B DD 03f400000r ; 0.75 ; `ImGuizmo::ViewManipulate'::`2'::panelPosition
	DD	03f400000r			; 0.75
	DD	03e800000r			; 0.25
	DD	03f400000r			; 0.75
	DD	000000000r			; 0
	DD	03f400000r			; 0.75
	DD	03f400000r			; 0.75
	DD	03e800000r			; 0.25
	DD	03e800000r			; 0.25
	DD	03e800000r			; 0.25
	DD	000000000r			; 0
	DD	03e800000r			; 0.25
	DD	03f400000r			; 0.75
	DD	000000000r			; 0
	DD	03e800000r			; 0.25
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_05GJAGBLGB@gizmo@
CONST	SEGMENT
??_C@_05GJAGBLGB@gizmo@ DB 'gizmo', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LOEGLDAO@X?3?5?$CF?42f?5Y?3?5?$CF?42f?5Z?3?5?$CF?42f@
CONST	SEGMENT
??_C@_0BI@LOEGLDAO@X?3?5?$CF?42f?5Y?3?5?$CF?42f?5Z?3?5?$CF?42f@ DB 'X: %.'
	DB	'2f Y: %.2f Z: %.2f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IIJEBLMJ@Z?5?3?5?$CF5?42f?5deg?5?$CF5?42f?5rad@
CONST	SEGMENT
??_C@_0BI@IIJEBLMJ@Z?5?3?5?$CF5?42f?5deg?5?$CF5?42f?5rad@ DB 'Z : %5.2f d'
	DB	'eg %5.2f rad', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IKEALIMN@Screen?5?3?5?$CF5?42f?5deg?5?$CF5?42f?5rad@
CONST	SEGMENT
??_C@_0BN@IKEALIMN@Screen?5?3?5?$CF5?42f?5deg?5?$CF5?42f?5rad@ DB 'Screen'
	DB	' : %5.2f deg %5.2f rad', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FBKPNHMG@X?5?3?5?$CF5?42f?5deg?5?$CF5?42f?5rad@
CONST	SEGMENT
??_C@_0BI@FBKPNHMG@X?5?3?5?$CF5?42f?5deg?5?$CF5?42f?5rad@ DB 'X : %5.2f d'
	DB	'eg %5.2f rad', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NAIKLCOB@Y?5?3?5?$CF5?42f?5deg?5?$CF5?42f?5rad@
CONST	SEGMENT
??_C@_0BI@NAIKLCOB@Y?5?3?5?$CF5?42f?5deg?5?$CF5?42f?5rad@ DB 'Y : %5.2f d'
	DB	'eg %5.2f rad', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09IBAHPDCD@Z?5?3?5?$CF5?42f@
CONST	SEGMENT
??_C@_09IBAHPDCD@Z?5?3?5?$CF5?42f@ DB 'Z : %5.2f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CANMJCGJ@XYZ?5?3?5?$CF5?42f@
CONST	SEGMENT
??_C@_0M@CANMJCGJ@XYZ?5?3?5?$CF5?42f@ DB 'XYZ : %5.2f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IFPCCDBO@X?5?3?5?$CF5?42f@
CONST	SEGMENT
??_C@_09IFPCCDBO@X?5?3?5?$CF5?42f@ DB 'X : %5.2f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GKDAEICA@Y?5?3?5?$CF5?42f@
CONST	SEGMENT
??_C@_09GKDAEICA@Y?5?3?5?$CF5?42f@ DB 'Y : %5.2f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MJPGDKJD@X?5?3?5?$CF5?43f?5Y?5?3?5?$CF5?43f@
CONST	SEGMENT
??_C@_0BE@MJPGDKJD@X?5?3?5?$CF5?43f?5Y?5?3?5?$CF5?43f@ DB 'X : %5.3f Y : '
	DB	'%5.3f', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OLCODPHJ@X?5?3?5?$CF5?43f?5Y?5?3?5?$CF5?43f?5Z?5?3?5?$CF5?43f@
CONST	SEGMENT
??_C@_0BO@OLCODPHJ@X?5?3?5?$CF5?43f?5Y?5?3?5?$CF5?43f?5Z?5?3?5?$CF5?43f@ DB 'X'
	DB	' : %5.3f Y : %5.3f Z : %5.3f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EHKGLKNG@Y?5?3?5?$CF5?43f?5Z?5?3?5?$CF5?43f@
CONST	SEGMENT
??_C@_0BE@EHKGLKNG@Y?5?3?5?$CF5?43f?5Z?5?3?5?$CF5?43f@ DB 'Y : %5.3f Z : '
	DB	'%5.3f', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CCMBIBJA@X?5?3?5?$CF5?43f?5Z?5?3?5?$CF5?43f@
CONST	SEGMENT
??_C@_0BE@CCMBIBJA@X?5?3?5?$CF5?43f?5Z?5?3?5?$CF5?43f@ DB 'X : %5.3f Z : '
	DB	'%5.3f', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09GLPCCCBH@Y?5?3?5?$CF5?43f@
CONST	SEGMENT
??_C@_09GLPCCCBH@Y?5?3?5?$CF5?43f@ DB 'Y : %5.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09IAMFJJBE@Z?5?3?5?$CF5?43f@
CONST	SEGMENT
??_C@_09IAMFJJBE@Z?5?3?5?$CF5?43f@ DB 'Z : %5.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09IEDAEJCJ@X?5?3?5?$CF5?43f@
CONST	SEGMENT
??_C@_09IEDAEJCJ@X?5?3?5?$CF5?43f@ DB 'X : %5.3f', 00H	; `string'
?translationInfoIndex@ImGuizmo@@3QBHB DD 00H		; ImGuizmo::translationInfoIndex
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	ORG $+4
?scaleInfoMask@ImGuizmo@@3PAPEBDA DQ FLAT:??_C@_09IFPCCDBO@X?5?3?5?$CF5?42f@ ; ImGuizmo::scaleInfoMask
	DQ	FLAT:??_C@_09GKDAEICA@Y?5?3?5?$CF5?42f@
	DQ	FLAT:??_C@_09IBAHPDCD@Z?5?3?5?$CF5?42f@
	DQ	FLAT:??_C@_0M@CANMJCGJ@XYZ?5?3?5?$CF5?42f@
?translationInfoMask@ImGuizmo@@3PAPEBDA DQ FLAT:??_C@_09IEDAEJCJ@X?5?3?5?$CF5?43f@ ; ImGuizmo::translationInfoMask
	DQ	FLAT:??_C@_09GLPCCCBH@Y?5?3?5?$CF5?43f@
	DQ	FLAT:??_C@_09IAMFJJBE@Z?5?3?5?$CF5?43f@
	DQ	FLAT:??_C@_0BE@EHKGLKNG@Y?5?3?5?$CF5?43f?5Z?5?3?5?$CF5?43f@
	DQ	FLAT:??_C@_0BE@CCMBIBJA@X?5?3?5?$CF5?43f?5Z?5?3?5?$CF5?43f@
	DQ	FLAT:??_C@_0BE@MJPGDKJD@X?5?3?5?$CF5?43f?5Y?5?3?5?$CF5?43f@
	DQ	FLAT:??_C@_0BO@OLCODPHJ@X?5?3?5?$CF5?43f?5Y?5?3?5?$CF5?43f?5Z?5?3?5?$CF5?43f@
?rotationInfoMask@ImGuizmo@@3PAPEBDA DQ FLAT:??_C@_0BI@FBKPNHMG@X?5?3?5?$CF5?42f?5deg?5?$CF5?42f?5rad@ ; ImGuizmo::rotationInfoMask
	DQ	FLAT:??_C@_0BI@NAIKLCOB@Y?5?3?5?$CF5?42f?5deg?5?$CF5?42f?5rad@
	DQ	FLAT:??_C@_0BI@IIJEBLMJ@Z?5?3?5?$CF5?42f?5deg?5?$CF5?42f?5rad@
	DQ	FLAT:??_C@_0BN@IKEALIMN@Screen?5?3?5?$CF5?42f?5deg?5?$CF5?42f?5rad@
?quadUV@ImGuizmo@@3QBMB DD 03f000000r		; 0.5	; ImGuizmo::quadUV
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03f4ccccdr			; 0.8
	DD	03f4ccccdr			; 0.8
	DD	03f4ccccdr			; 0.8
	DD	03f4ccccdr			; 0.8
	DD	03f000000r			; 0.5
PUBLIC	??$max@M@ImGuizmo@@YAMMM@Z			; ImGuizmo::max<float>
PUBLIC	??$min@H@ImGuizmo@@YAHHH@Z			; ImGuizmo::min<int>
PUBLIC	??$Clamp@M@ImGuizmo@@YAMMMM@Z			; ImGuizmo::Clamp<float>
PUBLIC	??$IsWithin@M@ImGuizmo@@YA_NMMM@Z		; ImGuizmo::IsWithin<float>
PUBLIC	?Manipulate@ImGuizmo@@YA_NPEBM0W4OPERATION@1@W4MODE@1@PEAM3000@Z ; ImGuizmo::Manipulate
PUBLIC	?RecomposeMatrixFromComponents@ImGuizmo@@YAXPEBM00PEAM@Z ; ImGuizmo::RecomposeMatrixFromComponents
PUBLIC	?DecomposeMatrixToComponents@ImGuizmo@@YAXPEBMPEAM11@Z ; ImGuizmo::DecomposeMatrixToComponents
PUBLIC	?Enable@ImGuizmo@@YAX_N@Z			; ImGuizmo::Enable
PUBLIC	?IsOver@ImGuizmo@@YA_NXZ			; ImGuizmo::IsOver
PUBLIC	?IsUsingAny@ImGuizmo@@YA_NXZ			; ImGuizmo::IsUsingAny
PUBLIC	?IsUsing@ImGuizmo@@YA_NXZ			; ImGuizmo::IsUsing
PUBLIC	?BeginFrame@ImGuizmo@@YAXXZ			; ImGuizmo::BeginFrame
PUBLIC	?SetDrawlist@ImGuizmo@@YAXPEAUImDrawList@@@Z	; ImGuizmo::SetDrawlist
PUBLIC	?SetRect@ImGuizmo@@YAXMMMM@Z			; ImGuizmo::SetRect
PUBLIC	?PointOnSegment@ImGuizmo@@YA?AUvec_t@1@AEBU21@00@Z ; ImGuizmo::PointOnSegment
PUBLIC	??0Context@ImGuizmo@@QEAA@XZ			; ImGuizmo::Context::Context
PUBLIC	??0Style@ImGuizmo@@QEAA@XZ			; ImGuizmo::Style::Style
PUBLIC	?RotationAxis@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@M@Z ; ImGuizmo::matrix_t::RotationAxis
PUBLIC	?Inverse@matrix_t@ImGuizmo@@QEAAMAEBU12@_N@Z	; ImGuizmo::matrix_t::Inverse
PUBLIC	?TransformVector@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z ; ImGuizmo::vec_t::TransformVector
PUBLIC	?TransformPoint@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z ; ImGuizmo::vec_t::TransformPoint
PUBLIC	?Transform@vec_t@ImGuizmo@@QEAAXAEBU12@AEBUmatrix_t@2@@Z ; ImGuizmo::vec_t::Transform
PUBLIC	?Transform@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z ; ImGuizmo::vec_t::Transform
PUBLIC	?OrthoNormalize@matrix_t@ImGuizmo@@QEAAXXZ	; ImGuizmo::matrix_t::OrthoNormalize
PUBLIC	?SetToIdentity@matrix_t@ImGuizmo@@QEAAXXZ	; ImGuizmo::matrix_t::SetToIdentity
PUBLIC	?GetDeterminant@matrix_t@ImGuizmo@@QEBAMXZ	; ImGuizmo::matrix_t::GetDeterminant
PUBLIC	?Multiply@matrix_t@ImGuizmo@@QEAAXAEBU12@0@Z	; ImGuizmo::matrix_t::Multiply
PUBLIC	??Dmatrix_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z	; ImGuizmo::matrix_t::operator*
PUBLIC	?Scale@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@@Z	; ImGuizmo::matrix_t::Scale
PUBLIC	?Scale@matrix_t@ImGuizmo@@QEAAXMMM@Z		; ImGuizmo::matrix_t::Scale
PUBLIC	?Translation@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@@Z ; ImGuizmo::matrix_t::Translation
PUBLIC	?BuildPlan@ImGuizmo@@YA?AUvec_t@1@AEBU21@0@Z	; ImGuizmo::BuildPlan
PUBLIC	?Dot@ImGuizmo@@YAMAEBUvec_t@1@0@Z		; ImGuizmo::Dot
PUBLIC	?Cross@ImGuizmo@@YA?AUvec_t@1@AEBU21@0@Z	; ImGuizmo::Cross
PUBLIC	?Normalized@ImGuizmo@@YA?AUvec_t@1@AEBU21@@Z	; ImGuizmo::Normalized
PUBLIC	?Abs@vec_t@ImGuizmo@@QEBA?AU12@XZ		; ImGuizmo::vec_t::Abs
PUBLIC	??Dvec_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z		; ImGuizmo::vec_t::operator*
PUBLIC	??Hvec_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z		; ImGuizmo::vec_t::operator+
PUBLIC	??Gvec_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z		; ImGuizmo::vec_t::operator-
PUBLIC	??Gvec_t@ImGuizmo@@QEBA?AU01@XZ			; ImGuizmo::vec_t::operator-
PUBLIC	??Dvec_t@ImGuizmo@@QEBA?AU01@M@Z		; ImGuizmo::vec_t::operator*
PUBLIC	?makeVect@ImGuizmo@@YA?AUvec_t@1@UImVec2@@@Z	; ImGuizmo::makeVect
PUBLIC	?makeVect@ImGuizmo@@YA?AUvec_t@1@MMMM@Z		; ImGuizmo::makeVect
PUBLIC	??9vec_t@ImGuizmo@@QEBA_NAEBU01@@Z		; ImGuizmo::vec_t::operator!=
PUBLIC	??Avec_t@ImGuizmo@@QEAAAEAM_K@Z			; ImGuizmo::vec_t::operator[]
PUBLIC	?TransformPoint@vec_t@ImGuizmo@@QEAAXAEBU12@AEBUmatrix_t@2@@Z ; ImGuizmo::vec_t::TransformPoint
PUBLIC	?TransformVector@vec_t@ImGuizmo@@QEAAXAEBU12@AEBUmatrix_t@2@@Z ; ImGuizmo::vec_t::TransformVector
PUBLIC	?Dot3@vec_t@ImGuizmo@@QEBAMAEBU12@@Z		; ImGuizmo::vec_t::Dot3
PUBLIC	?Dot@vec_t@ImGuizmo@@QEBAMAEBU12@@Z		; ImGuizmo::vec_t::Dot
PUBLIC	?Cross@vec_t@ImGuizmo@@QEAAXAEBU12@0@Z		; ImGuizmo::vec_t::Cross
PUBLIC	?Cross@vec_t@ImGuizmo@@QEAAXAEBU12@@Z		; ImGuizmo::vec_t::Cross
PUBLIC	?Normalize@vec_t@ImGuizmo@@QEAA?AU12@AEBU12@@Z	; ImGuizmo::vec_t::Normalize
PUBLIC	?Normalize@vec_t@ImGuizmo@@QEAA?AU12@XZ		; ImGuizmo::vec_t::Normalize
PUBLIC	?LengthSq@vec_t@ImGuizmo@@QEBAMXZ		; ImGuizmo::vec_t::LengthSq
PUBLIC	?Length@vec_t@ImGuizmo@@QEBAMXZ			; ImGuizmo::vec_t::Length
PUBLIC	??Xvec_t@ImGuizmo@@QEAAAEAU01@M@Z		; ImGuizmo::vec_t::operator*=
PUBLIC	??Yvec_t@ImGuizmo@@QEAAAEAU01@AEBU01@@Z		; ImGuizmo::vec_t::operator+=
PUBLIC	?Set@vec_t@ImGuizmo@@QEAAXMMMM@Z		; ImGuizmo::vec_t::Set
PUBLIC	?Set@vec_t@ImGuizmo@@QEAAXM@Z			; ImGuizmo::vec_t::Set
PUBLIC	?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z	; ImGuizmo::FPU_MatrixF_x_MatrixF
PUBLIC	??UImGuizmo@@YA?AW4OPERATION@0@W410@0@Z		; ImGuizmo::operator|
?gContext@ImGuizmo@@3UContext@1@A DB 05b0H DUP (?)	; ImGuizmo::gContext
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Manipulate@ImGuizmo@@YA_NPEBM0W4OPERATION@1@W4MODE@1@PEAM3000@Z DD imagerel $LN49
	DD	imagerel $LN49+286
	DD	imagerel $unwind$?Manipulate@ImGuizmo@@YA_NPEBM0W4OPERATION@1@W4MODE@1@PEAM3000@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RecomposeMatrixFromComponents@ImGuizmo@@YAXPEBM00PEAM@Z DD imagerel $LN89
	DD	imagerel $LN89+503
	DD	imagerel $unwind$?RecomposeMatrixFromComponents@ImGuizmo@@YAXPEBM00PEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DecomposeMatrixToComponents@ImGuizmo@@YAXPEBMPEAM11@Z DD imagerel $LN22
	DD	imagerel $LN22+519
	DD	imagerel $unwind$?DecomposeMatrixToComponents@ImGuizmo@@YAXPEBMPEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD imagerel ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
	DD	imagerel ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+124
	DD	imagerel $unwind$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD imagerel ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+124
	DD	imagerel ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+407
	DD	imagerel $chain$12$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD imagerel ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+407
	DD	imagerel ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+1104
	DD	imagerel $chain$13$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD imagerel ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+1104
	DD	imagerel ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+2144
	DD	imagerel $chain$14$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD imagerel ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+2144
	DD	imagerel ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+2171
	DD	imagerel $chain$15$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD imagerel ?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
	DD	imagerel ?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+117
	DD	imagerel $unwind$?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD imagerel ?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+117
	DD	imagerel ?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+2387
	DD	imagerel $chain$11$?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD imagerel ?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+2387
	DD	imagerel ?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+2414
	DD	imagerel $chain$12$?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD imagerel ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
	DD	imagerel ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+121
	DD	imagerel $unwind$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD imagerel ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+121
	DD	imagerel ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+1135
	DD	imagerel $chain$8$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD imagerel ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+1135
	DD	imagerel ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+2156
	DD	imagerel $chain$11$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD imagerel ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+2156
	DD	imagerel ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+2239
	DD	imagerel $chain$12$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD imagerel ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+2239
	DD	imagerel ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+2273
	DD	imagerel $chain$13$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z DD imagerel ?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z
	DD	imagerel ?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z+268
	DD	imagerel $unwind$?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z DD imagerel ?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z+268
	DD	imagerel ?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z+2767
	DD	imagerel $chain$7$?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z DD imagerel ?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z
	DD	imagerel ?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z+42
	DD	imagerel $unwind$?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z DD imagerel ?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z+42
	DD	imagerel ?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z+392
	DD	imagerel $chain$10$?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z DD imagerel ?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z+392
	DD	imagerel ?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z+1588
	DD	imagerel $chain$13$?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z DD imagerel ?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z+1588
	DD	imagerel ?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z+1610
	DD	imagerel $chain$14$?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z DD imagerel ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z
	DD	imagerel ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z+52
	DD	imagerel $unwind$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z DD imagerel ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z+52
	DD	imagerel ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z+98
	DD	imagerel $chain$3$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z DD imagerel ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z+98
	DD	imagerel ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z+2662
	DD	imagerel $chain$15$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$16$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z DD imagerel ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z+2662
	DD	imagerel ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z+3228
	DD	imagerel $chain$16$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$17$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z DD imagerel ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z+3228
	DD	imagerel ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z+3251
	DD	imagerel $chain$17$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?HandleAndDrawLocalBounds@ImGuizmo@@YAXPEBMPEAUmatrix_t@1@0W4OPERATION@1@@Z DD imagerel ?HandleAndDrawLocalBounds@ImGuizmo@@YAXPEBMPEAUmatrix_t@1@0W4OPERATION@1@@Z
	DD	imagerel ?HandleAndDrawLocalBounds@ImGuizmo@@YAXPEBMPEAUmatrix_t@1@0W4OPERATION@1@@Z+11668
	DD	imagerel $unwind$?HandleAndDrawLocalBounds@ImGuizmo@@YAXPEBMPEAUmatrix_t@1@0W4OPERATION@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CanActivate@ImGuizmo@@YA_NXZ DD imagerel ?CanActivate@ImGuizmo@@YA_NXZ
	DD	imagerel ?CanActivate@ImGuizmo@@YA_NXZ+67
	DD	imagerel $unwind$?CanActivate@ImGuizmo@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+73
	DD	imagerel $unwind$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+73
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+81
	DD	imagerel $chain$0$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+81
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+95
	DD	imagerel $chain$2$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+95
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+2609
	DD	imagerel $chain$14$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+2609
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+2724
	DD	imagerel $chain$15$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$16$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+2724
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+3426
	DD	imagerel $chain$16$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$17$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+3426
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+3448
	DD	imagerel $chain$17$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$18$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+3448
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+4342
	DD	imagerel $chain$18$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$19$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+4342
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+4369
	DD	imagerel $chain$19$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
	DD	imagerel ?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+68
	DD	imagerel $unwind$?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+68
	DD	imagerel ?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+2379
	DD	imagerel $chain$13$?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+2379
	DD	imagerel ?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+3211
	DD	imagerel $chain$14$?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+3211
	DD	imagerel ?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+3212
	DD	imagerel $chain$15$?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+70
	DD	imagerel $unwind$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+70
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+74
	DD	imagerel $chain$0$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+74
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+322
	DD	imagerel $chain$5$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+322
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+4904
	DD	imagerel $chain$13$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+4904
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+5771
	DD	imagerel $chain$14$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+5771
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+5772
	DD	imagerel $chain$15$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$16$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+5772
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+5789
	DD	imagerel $chain$16$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z DD imagerel ?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z
	DD	imagerel ?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z+30
	DD	imagerel $unwind$?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z DD imagerel ?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z+30
	DD	imagerel ?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z+894
	DD	imagerel $chain$10$?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z DD imagerel ?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z+894
	DD	imagerel ?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z+903
	DD	imagerel $chain$11$?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DrawRotationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD imagerel ?DrawRotationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
	DD	imagerel ?DrawRotationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+4151
	DD	imagerel $unwind$?DrawRotationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ComputeAngleOnPlan@ImGuizmo@@YAMXZ DD imagerel ?ComputeAngleOnPlan@ImGuizmo@@YAMXZ
	DD	imagerel ?ComputeAngleOnPlan@ImGuizmo@@YAMXZ+776
	DD	imagerel $unwind$?ComputeAngleOnPlan@ImGuizmo@@YAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z DD imagerel ?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z
	DD	imagerel ?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z+63
	DD	imagerel $unwind$?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z DD imagerel ?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z+63
	DD	imagerel ?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z+306
	DD	imagerel $chain$1$?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z DD imagerel ?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z+306
	DD	imagerel ?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z+425
	DD	imagerel $chain$2$?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ComputeSnap@ImGuizmo@@YAXPEAMM@Z DD imagerel ?ComputeSnap@ImGuizmo@@YAXPEAMM@Z
	DD	imagerel ?ComputeSnap@ImGuizmo@@YAXPEAMM@Z+30
	DD	imagerel $unwind$?ComputeSnap@ImGuizmo@@YAXPEAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ComputeSnap@ImGuizmo@@YAXPEAMM@Z DD imagerel ?ComputeSnap@ImGuizmo@@YAXPEAMM@Z+30
	DD	imagerel ?ComputeSnap@ImGuizmo@@YAXPEAMM@Z+135
	DD	imagerel $chain$0$?ComputeSnap@ImGuizmo@@YAXPEAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ComputeSnap@ImGuizmo@@YAXPEAMM@Z DD imagerel ?ComputeSnap@ImGuizmo@@YAXPEAMM@Z+135
	DD	imagerel ?ComputeSnap@ImGuizmo@@YAXPEAMM@Z+146
	DD	imagerel $chain$1$?ComputeSnap@ImGuizmo@@YAXPEAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z DD imagerel ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z
	DD	imagerel ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z+333
	DD	imagerel $unwind$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z DD imagerel ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z+333
	DD	imagerel ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z+355
	DD	imagerel $chain$1$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z DD imagerel ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z+355
	DD	imagerel ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z+1691
	DD	imagerel $chain$9$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z DD imagerel ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z+1691
	DD	imagerel ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z+1846
	DD	imagerel $chain$10$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z DD imagerel ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z+1846
	DD	imagerel ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z+1878
	DD	imagerel $chain$11$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ComputeColors@ImGuizmo@@YAXPEAIHW4OPERATION@1@@Z DD imagerel ?ComputeColors@ImGuizmo@@YAXPEAIHW4OPERATION@1@@Z
	DD	imagerel ?ComputeColors@ImGuizmo@@YAXPEAIHW4OPERATION@1@@Z+524
	DD	imagerel $unwind$?ComputeColors@ImGuizmo@@YAXPEAIHW4OPERATION@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ComputeContext@ImGuizmo@@YAXPEBM0PEAMW4MODE@1@@Z DD imagerel ?ComputeContext@ImGuizmo@@YAXPEBM0PEAMW4MODE@1@@Z
	DD	imagerel ?ComputeContext@ImGuizmo@@YAXPEBM0PEAMW4MODE@1@@Z+2107
	DD	imagerel $unwind$?ComputeContext@ImGuizmo@@YAXPEBM0PEAMW4MODE@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsOver@ImGuizmo@@YA_NXZ DD imagerel $LN40
	DD	imagerel $LN40+124
	DD	imagerel $unwind$?IsOver@ImGuizmo@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BeginFrame@ImGuizmo@@YAXXZ DD imagerel $LN38
	DD	imagerel $LN38+333
	DD	imagerel $unwind$?BeginFrame@ImGuizmo@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsHoveringWindow@ImGuizmo@@YA_NXZ DD imagerel ?IsHoveringWindow@ImGuizmo@@YA_NXZ
	DD	imagerel ?IsHoveringWindow@ImGuizmo@@YA_NXZ+90
	DD	imagerel $unwind$?IsHoveringWindow@ImGuizmo@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IntersectRayPlane@ImGuizmo@@YAMAEBUvec_t@1@00@Z DD imagerel ?IntersectRayPlane@ImGuizmo@@YAMAEBUvec_t@1@00@Z
	DD	imagerel ?IntersectRayPlane@ImGuizmo@@YAMAEBUvec_t@1@00@Z+147
	DD	imagerel $unwind$?IntersectRayPlane@ImGuizmo@@YAMAEBUvec_t@1@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PointOnSegment@ImGuizmo@@YA?AUvec_t@1@AEBU21@00@Z DD imagerel $LN50
	DD	imagerel $LN50+367
	DD	imagerel $unwind$?PointOnSegment@ImGuizmo@@YA?AUvec_t@1@AEBU21@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetParallelogram@ImGuizmo@@YAMAEBUvec_t@1@00@Z DD imagerel ?GetParallelogram@ImGuizmo@@YAMAEBUvec_t@1@00@Z
	DD	imagerel ?GetParallelogram@ImGuizmo@@YAMAEBUvec_t@1@00@Z+788
	DD	imagerel $unwind$?GetParallelogram@ImGuizmo@@YAMAEBUvec_t@1@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetSegmentLengthClipSpace@ImGuizmo@@YAMAEBUvec_t@1@0_N@Z DD imagerel ?GetSegmentLengthClipSpace@ImGuizmo@@YAMAEBUvec_t@1@0_N@Z
	DD	imagerel ?GetSegmentLengthClipSpace@ImGuizmo@@YAMAEBUvec_t@1@0_N@Z+584
	DD	imagerel $unwind$?GetSegmentLengthClipSpace@ImGuizmo@@YAMAEBUvec_t@1@0_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ComputeCameraRay@ImGuizmo@@YAXAEAUvec_t@1@0UImVec2@@1@Z DD imagerel ?ComputeCameraRay@ImGuizmo@@YAXAEAUvec_t@1@0UImVec2@@1@Z
	DD	imagerel ?ComputeCameraRay@ImGuizmo@@YAXAEAUvec_t@1@0UImVec2@@1@Z+1132
	DD	imagerel $unwind$?ComputeCameraRay@ImGuizmo@@YAXAEAUvec_t@1@0UImVec2@@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?worldToPos@ImGuizmo@@YA?AUImVec2@@AEBUvec_t@1@AEBUmatrix_t@1@U2@2@Z DD imagerel ?worldToPos@ImGuizmo@@YA?AUImVec2@@AEBUvec_t@1@AEBUmatrix_t@1@U2@2@Z
	DD	imagerel ?worldToPos@ImGuizmo@@YA?AUImVec2@@AEBUvec_t@1@AEBUmatrix_t@1@U2@2@Z+241
	DD	imagerel $unwind$?worldToPos@ImGuizmo@@YA?AUImVec2@@AEBUvec_t@1@AEBUmatrix_t@1@U2@2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RotationAxis@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@M@Z DD imagerel $LN26
	DD	imagerel $LN26+171
	DD	imagerel $unwind$?RotationAxis@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?RotationAxis@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@M@Z DD imagerel $LN26+171
	DD	imagerel $LN26+520
	DD	imagerel $chain$3$?RotationAxis@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?RotationAxis@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@M@Z DD imagerel $LN26+520
	DD	imagerel $LN26+596
	DD	imagerel $chain$4$?RotationAxis@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Inverse@matrix_t@ImGuizmo@@QEAAMAEBU12@_N@Z DD imagerel $LN36
	DD	imagerel $LN36+1999
	DD	imagerel $unwind$?Inverse@matrix_t@ImGuizmo@@QEAAMAEBU12@_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TransformVector@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z DD imagerel $LN4
	DD	imagerel $LN4+178
	DD	imagerel $unwind$?TransformVector@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TransformPoint@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z DD imagerel $LN4
	DD	imagerel $LN4+198
	DD	imagerel $unwind$?TransformPoint@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Transform@vec_t@ImGuizmo@@QEAAXAEBU12@AEBUmatrix_t@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+276
	DD	imagerel $unwind$?Transform@vec_t@ImGuizmo@@QEAAXAEBU12@AEBUmatrix_t@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Transform@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z DD imagerel $LN4
	DD	imagerel $LN4+249
	DD	imagerel $unwind$?Transform@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?OrthoNormalize@matrix_t@ImGuizmo@@QEAAXXZ DD imagerel $LN83
	DD	imagerel $LN83+300
	DD	imagerel $unwind$?OrthoNormalize@matrix_t@ImGuizmo@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetDeterminant@matrix_t@ImGuizmo@@QEBAMXZ DD imagerel $LN4
	DD	imagerel $LN4+160
	DD	imagerel $unwind$?GetDeterminant@matrix_t@ImGuizmo@@QEBAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Dmatrix_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+26
	DD	imagerel $unwind$??Dmatrix_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BuildPlan@ImGuizmo@@YA?AUvec_t@1@AEBU21@0@Z DD imagerel $LN23
	DD	imagerel $LN23+222
	DD	imagerel $unwind$?BuildPlan@ImGuizmo@@YA?AUvec_t@1@AEBU21@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Normalized@ImGuizmo@@YA?AUvec_t@1@AEBU21@@Z DD imagerel $LN30
	DD	imagerel $LN30+116
	DD	imagerel $unwind$?Normalized@ImGuizmo@@YA?AUvec_t@1@AEBU21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Cross@vec_t@ImGuizmo@@QEAAXAEBU12@@Z DD imagerel $LN4
	DD	imagerel $LN4+112
	DD	imagerel $unwind$?Cross@vec_t@ImGuizmo@@QEAAXAEBU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Normalize@vec_t@ImGuizmo@@QEAA?AU12@AEBU12@@Z DD imagerel $LN33
	DD	imagerel $LN33+167
	DD	imagerel $unwind$?Normalize@vec_t@ImGuizmo@@QEAA?AU12@AEBU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Normalize@vec_t@ImGuizmo@@QEAA?AU12@XZ DD imagerel $LN28
	DD	imagerel $LN28+125
	DD	imagerel $unwind$?Normalize@vec_t@ImGuizmo@@QEAA?AU12@XZ
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Normalize@vec_t@ImGuizmo@@QEAA?AU12@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Normalize@vec_t@ImGuizmo@@QEAA?AU12@AEBU12@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Cross@vec_t@ImGuizmo@@QEAAXAEBU12@@Z DD 032501H
	DD	08825H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Normalized@ImGuizmo@@YA?AUvec_t@1@AEBU21@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BuildPlan@ImGuizmo@@YA?AUvec_t@1@AEBU21@0@Z DD 083e01H
	DD	02683eH
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Dmatrix_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetDeterminant@matrix_t@ImGuizmo@@QEBAMXZ DD 073501H
	DD	0b835H
	DD	019830H
	DD	026818H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?OrthoNormalize@matrix_t@ImGuizmo@@QEAAXXZ DD 042c01H
	DD	02682cH
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Transform@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z DD 073201H
	DD	08832H
	DD	017825H
	DD	026813H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Transform@vec_t@ImGuizmo@@QEAAXAEBU12@AEBUmatrix_t@2@@Z DD 071301H
	DD	08813H
	DD	01780eH
	DD	026809H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TransformPoint@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z DD 052701H
	DD	07827H
	DD	016813H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TransformVector@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z DD 052701H
	DD	07827H
	DD	016813H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Inverse@matrix_t@ImGuizmo@@QEAAMAEBU12@_N@Z DD 0169701H
	DD	08f897H
	DD	09e88fH
	DD	0ad887H
	DD	0bc87fH
	DD	0cb87aH
	DD	0da875H
	DD	0e9870H
	DD	0f886bH
	DD	0107866H
	DD	0116859H
	DD	025010eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?RotationAxis@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@M@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+171
	DD	imagerel $unwind$?RotationAxis@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?RotationAxis@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@M@Z DD 081d21H
	DD	06a81dH
	DD	079817H
	DD	088811H
	DD	0a6808H
	DD	imagerel $LN26
	DD	imagerel $LN26+171
	DD	imagerel $unwind$?RotationAxis@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RotationAxis@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@M@Z DD 0d5601H
	DD	02e856H
	DD	03d846H
	DD	04c828H
	DD	05b81aH
	DD	097811H
	DD	0160109H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?worldToPos@ImGuizmo@@YA?AUImVec2@@AEBUvec_t@1@AEBUmatrix_t@1@U2@2@Z DD 051b01H
	DD	0781bH
	DD	016814H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ComputeCameraRay@ImGuizmo@@YAXAEAUvec_t@1@0UImVec2@@1@Z DD 0195b19H
	DD	0df849H
	DD	0ee841H
	DD	0fd839H
	DD	010c831H
	DD	011b829H
	DD	012a824H
	DD	013981fH
	DD	014881aH
	DD	0157815H
	DD	0166811H
	DD	02e010dH
	DD	060057006H
	DD	03004H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetSegmentLengthClipSpace@ImGuizmo@@YAMAEBUvec_t@1@0_N@Z DD 0168001H
	DD	02f880H
	DD	03e85dH
	DD	04d857H
	DD	05c83eH
	DD	06b839H
	DD	07a834H
	DD	08982fH
	DD	098827H
	DD	0a781fH
	DD	0b681bH
	DD	019010aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetParallelogram@ImGuizmo@@YAMAEBUvec_t@1@00@Z DD 0164e19H
	DD	06f83fH
	DD	07e839H
	DD	08d833H
	DD	09c82bH
	DD	0ab826H
	DD	0ba821H
	DD	0c981cH
	DD	0d8817H
	DD	0e7812H
	DD	0f680eH
	DD	021010aH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PointOnSegment@ImGuizmo@@YA?AUvec_t@1@AEBU21@00@Z DD 0e4801H
	DD	028848H
	DD	037830H
	DD	046819H
	DD	0e6414H
	DD	0d5414H
	DD	0c3414H
	DD	070109214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IntersectRayPlane@ImGuizmo@@YAMAEBUvec_t@1@00@Z DD 032201H
	DD	06822H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsHoveringWindow@ImGuizmo@@YA_NXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BeginFrame@ImGuizmo@@YAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsOver@ImGuizmo@@YA_NXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ComputeContext@ImGuizmo@@YAXPEBM0PEAMW4MODE@1@@Z DD 0113d19H
	DD	0dd82fH
	DD	0ec82aH
	DD	0fb825H
	DD	0108820H
	DD	011781bH
	DD	0126817H
	DD	02a3413H
	DD	0260113H
	DD	05008H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ComputeColors@ImGuizmo@@YAXPEAIHW4OPERATION@1@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z DD 021H
	DD	imagerel ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z
	DD	imagerel ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z+333
	DD	imagerel $unwind$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z DD 020021H
	DD	0ae800H
	DD	imagerel ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z+333
	DD	imagerel ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z+355
	DD	imagerel $chain$1$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z DD 0104821H
	DD	09f848H
	DD	0ae83fH
	DD	0bd836H
	DD	0cc82dH
	DD	0db824H
	DD	0ea81bH
	DD	0f9812H
	DD	0108809H
	DD	imagerel ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z+333
	DD	imagerel ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z+355
	DD	imagerel $chain$1$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z DD 041321H
	DD	0117813H
	DD	0126808H
	DD	imagerel ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z
	DD	imagerel ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z+333
	DD	imagerel $unwind$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z DD 0a2719H
	DD	0270119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	088H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ComputeSnap@ImGuizmo@@YAXPEAMM@Z DD 021H
	DD	imagerel ?ComputeSnap@ImGuizmo@@YAXPEAMM@Z
	DD	imagerel ?ComputeSnap@ImGuizmo@@YAXPEAMM@Z+30
	DD	imagerel $unwind$?ComputeSnap@ImGuizmo@@YAXPEAMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ComputeSnap@ImGuizmo@@YAXPEAMM@Z DD 020521H
	DD	036805H
	DD	imagerel ?ComputeSnap@ImGuizmo@@YAXPEAMM@Z
	DD	imagerel ?ComputeSnap@ImGuizmo@@YAXPEAMM@Z+30
	DD	imagerel $unwind$?ComputeSnap@ImGuizmo@@YAXPEAMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ComputeSnap@ImGuizmo@@YAXPEAMM@Z DD 041601H
	DD	027816H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z DD 021H
	DD	imagerel ?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z
	DD	imagerel ?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z+63
	DD	imagerel $unwind$?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z DD 040c21H
	DD	03a80cH
	DD	0127404H
	DD	imagerel ?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z
	DD	imagerel ?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z+63
	DD	imagerel $unwind$?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z DD 0c3b01H
	DD	02c83bH
	DD	04982dH
	DD	058823H
	DD	067816H
	DD	07680fH
	DD	03004f20bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ComputeAngleOnPlan@ImGuizmo@@YAMXZ DD 016a301H
	DD	02f8a3H
	DD	03e88fH
	DD	04d880H
	DD	05c87aH
	DD	06b86cH
	DD	07a85aH
	DD	089848H
	DD	098837H
	DD	0a782aH
	DD	0b681eH
	DD	019010aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DrawRotationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 055228a19H
	DD	054f879H
	DD	055e871H
	DD	056d869H
	DD	057c861H
	DD	058b859H
	DD	059a851H
	DD	05a9849H
	DD	05b8841H
	DD	05c7839H
	DD	05d6832H
	DD	0c4742bH
	DD	0c36424H
	DD	0c2341dH
	DD	01115316H
	DD	0f00a00bcH
	DD	0d006e008H
	DD	05002c004H
	DD	imagerel __GSHandlerCheck
	DD	0530H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z DD 021H
	DD	imagerel ?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z
	DD	imagerel ?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z+30
	DD	imagerel $unwind$?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z DD 0164521H
	DD	04f845H
	DD	05e83fH
	DD	06d839H
	DD	07c833H
	DD	08b82eH
	DD	09a829H
	DD	0a9824H
	DD	0b8816H
	DD	0c7811H
	DD	0d680dH
	DD	01e3404H
	DD	imagerel ?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z
	DD	imagerel ?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z+30
	DD	imagerel $unwind$?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z DD 030b01H
	DD	01c010bH
	DD	07004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$16$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 01c0021H
	DD	033f800H
	DD	034e800H
	DD	035d800H
	DD	036c800H
	DD	037b800H
	DD	038a800H
	DD	0399800H
	DD	03a8800H
	DD	03b7800H
	DD	03c6800H
	DD	07af400H
	DD	083d400H
	DD	082c400H
	DD	0807400H
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+70
	DD	imagerel $unwind$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 021H
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+70
	DD	imagerel $unwind$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 0c0021H
	DD	038a800H
	DD	0399800H
	DD	03a8800H
	DD	03b7800H
	DD	03c6800H
	DD	07af400H
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+70
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+74
	DD	imagerel $chain$0$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 0105221H
	DD	033f852H
	DD	034e849H
	DD	035d840H
	DD	036c837H
	DD	037b82eH
	DD	039981fH
	DD	03a8813H
	DD	03c6808H
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+74
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+322
	DD	imagerel $chain$5$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 0a1621H
	DD	038a816H
	DD	03b7811H
	DD	07af40cH
	DD	083d408H
	DD	082c404H
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+70
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+74
	DD	imagerel $chain$0$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 020421H
	DD	0807404H
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
	DD	imagerel ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+70
	DD	imagerel $unwind$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 063319H
	DD	07b0122H
	DD	06012e014H
	DD	050103011H
	DD	imagerel __GSHandlerCheck
	DD	0320H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 021H
	DD	imagerel ?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
	DD	imagerel ?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+68
	DD	imagerel $unwind$?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 0a0021H
	DD	035b800H
	DD	036a800H
	DD	0379800H
	DD	0397800H
	DD	03a6800H
	DD	imagerel ?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
	DD	imagerel ?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+68
	DD	imagerel $unwind$?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 01c5121H
	DD	031f851H
	DD	032e849H
	DD	033d841H
	DD	034c839H
	DD	035b831H
	DD	036a829H
	DD	0379824H
	DD	038881fH
	DD	039781aH
	DD	03a6815H
	DD	076f410H
	DD	07fe40cH
	DD	07ed408H
	DD	07cc404H
	DD	imagerel ?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
	DD	imagerel ?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+68
	DD	imagerel $unwind$?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 063219H
	DD	0770121H
	DD	060127013H
	DD	050103011H
	DD	imagerel __GSHandlerCheck
	DD	0300H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$19$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 021H
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+73
	DD	imagerel $unwind$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$18$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 0140021H
	DD	033f800H
	DD	034e800H
	DD	035d800H
	DD	036c800H
	DD	037b800H
	DD	038a800H
	DD	0399800H
	DD	03a8800H
	DD	03b7800H
	DD	03c6800H
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+73
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+81
	DD	imagerel $chain$0$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$17$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 01c0021H
	DD	033f800H
	DD	034e800H
	DD	035d800H
	DD	036c800H
	DD	037b800H
	DD	038a800H
	DD	0399800H
	DD	03a8800H
	DD	03b7800H
	DD	03c6800H
	DD	07af400H
	DD	07be400H
	DD	083c400H
	DD	0826400H
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+73
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+81
	DD	imagerel $chain$0$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$16$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 0140021H
	DD	033f800H
	DD	034e800H
	DD	035d800H
	DD	036c800H
	DD	037b800H
	DD	038a800H
	DD	0399800H
	DD	03a8800H
	DD	03b7800H
	DD	03c6800H
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+73
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+81
	DD	imagerel $chain$0$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 0140021H
	DD	033f800H
	DD	034e800H
	DD	035d800H
	DD	036c800H
	DD	037b800H
	DD	038a800H
	DD	0399800H
	DD	03a8800H
	DD	03b7800H
	DD	03c6800H
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+81
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+95
	DD	imagerel $chain$2$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 0184921H
	DD	033f849H
	DD	034e841H
	DD	035d839H
	DD	036c831H
	DD	037b829H
	DD	038a821H
	DD	039981cH
	DD	03a8817H
	DD	03b7812H
	DD	03c680dH
	DD	07af408H
	DD	07be404H
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+81
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+95
	DD	imagerel $chain$2$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 040e21H
	DD	083c40eH
	DD	0826404H
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+73
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+81
	DD	imagerel $chain$0$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 020421H
	DD	0803404H
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
	DD	imagerel ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z+73
	DD	imagerel $unwind$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z DD 052619H
	DD	07c0115H
	DD	07005d007H
	DD	05004H
	DD	imagerel __GSHandlerCheck
	DD	0320H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CanActivate@ImGuizmo@@YA_NXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?HandleAndDrawLocalBounds@ImGuizmo@@YAXPEBMPEAUmatrix_t@1@0W4OPERATION@1@@Z DD 0217619H
	DD	050f865H
	DD	051e85dH
	DD	052d855H
	DD	053c84dH
	DD	054b845H
	DD	055a83dH
	DD	0569838H
	DD	0578833H
	DD	058782eH
	DD	059682aH
	DD	0bc7426H
	DD	0bb6426H
	DD	0ba3426H
	DD	0b40126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	04f0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$17$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z DD 021H
	DD	imagerel ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z
	DD	imagerel ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z+52
	DD	imagerel $unwind$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$16$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z DD 060021H
	DD	0188800H
	DD	0197800H
	DD	01a6800H
	DD	imagerel ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z+52
	DD	imagerel ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z+98
	DD	imagerel $chain$3$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z DD 018ca21H
	DD	011f8caH
	DD	012e8c1H
	DD	013d8b8H
	DD	014c8afH
	DD	015b8a6H
	DD	016a89dH
	DD	0179891H
	DD	01a6885H
	DD	0188831H
	DD	0197818H
	DD	036f410H
	DD	037e408H
	DD	imagerel ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z+52
	DD	imagerel ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z+98
	DD	imagerel $chain$3$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z DD 082421H
	DD	038d424H
	DD	03e741cH
	DD	03d6412H
	DD	03c3408H
	DD	imagerel ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z
	DD	imagerel ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z+52
	DD	imagerel $unwind$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z DD 042119H
	DD	0390113H
	DD	05002c004H
	DD	imagerel __GSHandlerCheck
	DD	0100H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z DD 021H
	DD	imagerel ?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z
	DD	imagerel ?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z+42
	DD	imagerel $unwind$?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z DD 062921H
	DD	0c9829H
	DD	0d8820H
	DD	0e7808H
	DD	imagerel ?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z+42
	DD	imagerel ?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z+392
	DD	imagerel $chain$10$?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z DD 0168d21H
	DD	06f88dH
	DD	07e887H
	DD	08d879H
	DD	09c870H
	DD	0ab845H
	DD	0ba83cH
	DD	0f6833H
	DD	025e424H
	DD	024741cH
	DD	0236412H
	DD	0223408H
	DD	imagerel ?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z
	DD	imagerel ?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z+42
	DD	imagerel $unwind$?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z DD 031819H
	DD	0200109H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z DD 020921H
	DD	0ef809H
	DD	imagerel ?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z
	DD	imagerel ?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z+268
	DD	imagerel $unwind$?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z DD 01dfe19H
	DD	0fe8feH
	DD	010d8f5H
	DD	011c8ecH
	DD	013a8e3H
	DD	01498daH
	DD	01678d1H
	DD	01768c6H
	DD	012b82cH
	DD	0158824H
	DD	038641fH
	DD	036341fH
	DD	030011fH
	DD	0e011f013H
	DD	0700dc00fH
	DD	0500cH
	DD	imagerel __GSHandlerCheck
	DD	0d8H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD 021H
	DD	imagerel ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
	DD	imagerel ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+121
	DD	imagerel $unwind$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD 021H
	DD	imagerel ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+121
	DD	imagerel ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+1135
	DD	imagerel $chain$8$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD 063d21H
	DD	013f83dH
	DD	014e812H
	DD	015d809H
	DD	imagerel ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+121
	DD	imagerel ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+1135
	DD	imagerel $chain$8$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD 0125e21H
	DD	016c85eH
	DD	017b855H
	DD	018a84cH
	DD	0199843H
	DD	01a883aH
	DD	01b7831H
	DD	01c6829H
	DD	03fe417H
	DD	03e3408H
	DD	imagerel ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
	DD	imagerel ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+121
	DD	imagerel $unwind$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD 072619H
	DD	0406418H
	DD	03a0118H
	DD	07007f009H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0120H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD 021H
	DD	imagerel ?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
	DD	imagerel ?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+117
	DD	imagerel $unwind$?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD 0189921H
	DD	011a899H
	DD	0129890H
	DD	0138887H
	DD	014787eH
	DD	034d476H
	DD	033c46eH
	DD	0ed85dH
	DD	0fc84bH
	DD	010b83aH
	DD	0156829H
	DD	02ce417H
	DD	0326408H
	DD	imagerel ?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
	DD	imagerel ?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+117
	DD	imagerel $unwind$?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD 062019H
	DD	02d0112H
	DD	07004f006H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD 021H
	DD	imagerel ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
	DD	imagerel ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+124
	DD	imagerel $unwind$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD 021H
	DD	imagerel ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+124
	DD	imagerel ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+407
	DD	imagerel $chain$12$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD 020921H
	DD	016e809H
	DD	imagerel ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+124
	DD	imagerel ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+407
	DD	imagerel $chain$12$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD 01a9321H
	DD	017d893H
	DD	019b88aH
	DD	01aa881H
	DD	01b9878H
	DD	01c886fH
	DD	01d7866H
	DD	01e685eH
	DD	03ef456H
	DD	046d44eH
	DD	015f83dH
	DD	018c82bH
	DD	045c410H
	DD	0446408H
	DD	imagerel ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
	DD	imagerel ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z+124
	DD	imagerel $unwind$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z DD 062319H
	DD	03f0115H
	DD	07004e006H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	0140H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DecomposeMatrixToComponents@ImGuizmo@@YAXPEBMPEAM11@Z DD 0b2919H
	DD	07981aH
	DD	087815H
	DD	096811H
	DD	014010dH
	DD	060057006H
	DD	03004H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RecomposeMatrixFromComponents@ImGuizmo@@YAXPEBM00PEAM@Z DD 0133f19H
	DD	017982dH
	DD	0188828H
	DD	0197823H
	DD	01a681fH
	DD	03c641bH
	DD	03b541bH
	DD	03a341bH
	DD	036011bH
	DD	0e012f014H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0160H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Manipulate@ImGuizmo@@YA_NPEBM0W4OPERATION@1@W4MODE@1@PEAM3000@Z DD 068401H
	DD	086484H
	DD	09340aH
	DD	07006520aH
	ORG $+140
?directionUnary@ImGuizmo@@3QBUvec_t@1@B DD 03f800000r ; 1 ; ImGuizmo::directionUnary
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
?TRANSLATE_PLANS@ImGuizmo@@3QBW4OPERATION@1@B DD 06H	; ImGuizmo::TRANSLATE_PLANS
	DD	05H
	DD	03H
?gContext$initializer$@ImGuizmo@@3P6AXXZEA DQ FLAT:??__EgContext@ImGuizmo@@YAXXZ ; ImGuizmo::gContext$initializer$
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??H@YA?AUImVec2@@AEBU0@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??H@YA?AUImVec2@@AEBU0@0@Z PROC				; operator+, COMDAT

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm0, DWORD PTR [rdx]
	mov	rax, rcx
	movss	xmm1, DWORD PTR [rdx+4]
	addss	xmm0, DWORD PTR [r8]
	addss	xmm1, DWORD PTR [r8+4]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	ret	0
??H@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??G@YA?AUImVec2@@AEBU0@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??G@YA?AUImVec2@@AEBU0@0@Z PROC				; operator-, COMDAT

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm0, DWORD PTR [rdx]
	mov	rax, rcx
	movss	xmm1, DWORD PTR [rdx+4]
	subss	xmm0, DWORD PTR [r8]
	subss	xmm1, DWORD PTR [r8+4]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	ret	0
??G@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??X@YAAEAUImVec2@@AEAU0@M@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??X@YAAEAUImVec2@@AEAU0@M@Z PROC			; operator*=, COMDAT

; 2543 : static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)          { lhs.x *= rhs; lhs.y *= rhs; return lhs; }

	movaps	xmm0, xmm1
	mov	rax, rcx
	mulss	xmm0, DWORD PTR [rcx]
	mulss	xmm1, DWORD PTR [rcx+4]
	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1
	ret	0
??X@YAAEAUImVec2@@AEAU0@M@Z ENDP			; operator*=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??_0@YAAEAUImVec2@@AEAU0@M@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??_0@YAAEAUImVec2@@AEAU0@M@Z PROC			; operator/=, COMDAT

; 2544 : static inline ImVec2& operator/=(ImVec2& lhs, const float rhs)          { lhs.x /= rhs; lhs.y /= rhs; return lhs; }

	movss	xmm0, DWORD PTR [rcx]
	mov	rax, rcx
	movss	xmm2, DWORD PTR [rcx+4]
	divss	xmm0, xmm1
	divss	xmm2, xmm1
	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm2
	ret	0
??_0@YAAEAUImVec2@@AEAU0@M@Z ENDP			; operator/=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImAbs@@YAMM@Z
_TEXT	SEGMENT
x$ = 8
?ImAbs@@YAMM@Z PROC					; ImAbs, COMDAT
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 441  : static inline float  ImAbs(float x)             { return fabsf(x); }

	ret	0
?ImAbs@@YAMM@Z ENDP					; ImAbs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImLerp@@YA?AUImVec2@@AEBU1@00@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
a$ = 16
b$ = 24
t$ = 32
?ImLerp@@YA?AUImVec2@@AEBU1@00@Z PROC			; ImLerp, COMDAT

; 466  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	movss	xmm1, DWORD PTR [r8]
	mov	rax, rcx
	subss	xmm1, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [r8+4]
	subss	xmm0, DWORD PTR [rdx+4]
	mulss	xmm1, DWORD PTR [r9]
	mulss	xmm0, DWORD PTR [r9+4]
	addss	xmm1, DWORD PTR [rdx]
	addss	xmm0, DWORD PTR [rdx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm1
	movss	DWORD PTR [rcx+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 466  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	ret	0
?ImLerp@@YA?AUImVec2@@AEBU1@00@Z ENDP			; ImLerp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImLengthSqr@@YAMAEBUImVec2@@@Z
_TEXT	SEGMENT
lhs$ = 8
?ImLengthSqr@@YAMAEBUImVec2@@@Z PROC			; ImLengthSqr, COMDAT

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	movss	xmm1, DWORD PTR [rcx+4]
	movss	xmm0, DWORD PTR [rcx]
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm0, xmm1
	ret	0
?ImLengthSqr@@YAMAEBUImVec2@@@Z ENDP			; ImLengthSqr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.h
;	COMDAT ??UImGuizmo@@YA?AW4OPERATION@0@W410@0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??UImGuizmo@@YA?AW4OPERATION@0@W410@0@Z PROC		; ImGuizmo::operator|, COMDAT

; 199  :      return static_cast<OPERATION>(static_cast<int>(lhs) | static_cast<int>(rhs));

	or	ecx, edx
	mov	eax, ecx

; 200  :    }

	ret	0
??UImGuizmo@@YA?AW4OPERATION@0@W410@0@Z ENDP		; ImGuizmo::operator|
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??IImGuizmo@@YA?AW4OPERATION@0@W410@0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??IImGuizmo@@YA?AW4OPERATION@0@W410@0@Z PROC		; ImGuizmo::operator&, COMDAT

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	and	ecx, edx
	mov	eax, ecx

; 59   :    }

	ret	0
??IImGuizmo@@YA?AW4OPERATION@0@W410@0@Z ENDP		; ImGuizmo::operator&
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??9ImGuizmo@@YA_NW4OPERATION@0@H@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$dead$ = 16
??9ImGuizmo@@YA_NW4OPERATION@0@H@Z PROC			; ImGuizmo::operator!=, COMDAT

; 63   :      return static_cast<int>(lhs) != rhs;

	test	ecx, ecx
	setne	al

; 64   :    }

	ret	0
??9ImGuizmo@@YA_NW4OPERATION@0@H@Z ENDP			; ImGuizmo::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Intersects@ImGuizmo@@YA_NW4OPERATION@1@0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
?Intersects@ImGuizmo@@YA_NW4OPERATION@1@0@Z PROC	; ImGuizmo::Intersects, COMDAT

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	ecx, edx

; 63   :      return static_cast<int>(lhs) != rhs;

	setne	al

; 68   :      return (lhs & rhs) != 0;
; 69   :    }

	ret	0
?Intersects@ImGuizmo@@YA_NW4OPERATION@1@0@Z ENDP	; ImGuizmo::Intersects
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Contains@ImGuizmo@@YA_NW4OPERATION@1@0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
?Contains@ImGuizmo@@YA_NW4OPERATION@1@0@Z PROC		; ImGuizmo::Contains, COMDAT

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	and	ecx, edx

; 74   :      return (lhs & rhs) == rhs;

	cmp	ecx, edx
	sete	al

; 75   :    }

	ret	0
?Contains@ImGuizmo@@YA_NW4OPERATION@1@0@Z ENDP		; ImGuizmo::Contains
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
r$ = 24
?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z PROC	; ImGuizmo::FPU_MatrixF_x_MatrixF, COMDAT

; 82   :       r[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];

	movss	xmm2, DWORD PTR [rcx]
	mulss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+16]
	mulss	xmm0, DWORD PTR [rcx+4]
	movss	xmm1, DWORD PTR [rcx+8]
	mulss	xmm1, DWORD PTR [rdx+32]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [rcx+12]
	mulss	xmm0, DWORD PTR [rdx+48]
	addss	xmm2, xmm1
	addss	xmm2, xmm0
	movss	DWORD PTR [r8], xmm2

; 83   :       r[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];

	movss	xmm2, DWORD PTR [rdx+20]
	mulss	xmm2, DWORD PTR [rcx+4]
	movss	xmm0, DWORD PTR [rdx+4]
	mulss	xmm0, DWORD PTR [rcx]
	movss	xmm1, DWORD PTR [rdx+36]
	mulss	xmm1, DWORD PTR [rcx+8]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [rcx+12]
	mulss	xmm0, DWORD PTR [rdx+52]
	addss	xmm2, xmm1
	addss	xmm2, xmm0
	movss	DWORD PTR [r8+4], xmm2

; 84   :       r[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];

	movss	xmm2, DWORD PTR [rdx+24]
	mulss	xmm2, DWORD PTR [rcx+4]
	movss	xmm0, DWORD PTR [rdx+8]
	mulss	xmm0, DWORD PTR [rcx]
	movss	xmm1, DWORD PTR [rcx+8]
	mulss	xmm1, DWORD PTR [rdx+40]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [rcx+12]
	mulss	xmm0, DWORD PTR [rdx+56]
	addss	xmm2, xmm1
	addss	xmm2, xmm0
	movss	DWORD PTR [r8+8], xmm2

; 85   :       r[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];

	movss	xmm2, DWORD PTR [rcx]
	mulss	xmm2, DWORD PTR [rdx+12]
	movss	xmm0, DWORD PTR [rdx+28]
	mulss	xmm0, DWORD PTR [rcx+4]
	movss	xmm1, DWORD PTR [rcx+8]
	mulss	xmm1, DWORD PTR [rdx+44]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [rdx+60]
	mulss	xmm0, DWORD PTR [rcx+12]
	addss	xmm2, xmm1
	addss	xmm2, xmm0
	movss	DWORD PTR [r8+12], xmm2

; 86   : 
; 87   :       r[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];

	movss	xmm2, DWORD PTR [rcx+20]
	mulss	xmm2, DWORD PTR [rdx+16]
	movss	xmm0, DWORD PTR [rcx+16]
	mulss	xmm0, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rcx+24]
	mulss	xmm1, DWORD PTR [rdx+32]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [rcx+28]
	mulss	xmm0, DWORD PTR [rdx+48]
	addss	xmm2, xmm1
	addss	xmm2, xmm0
	movss	DWORD PTR [r8+16], xmm2

; 88   :       r[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];

	movss	xmm0, DWORD PTR [rcx+20]
	mulss	xmm0, DWORD PTR [rdx+20]
	movss	xmm1, DWORD PTR [rdx+36]
	mulss	xmm1, DWORD PTR [rcx+24]
	movss	xmm3, DWORD PTR [rdx+4]
	mulss	xmm3, DWORD PTR [rcx+16]
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR [rcx+28]
	mulss	xmm0, DWORD PTR [rdx+52]
	addss	xmm3, xmm1
	addss	xmm3, xmm0
	movss	DWORD PTR [r8+20], xmm3

; 89   :       r[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];

	movss	xmm0, DWORD PTR [rcx+16]
	mulss	xmm0, DWORD PTR [rdx+8]
	movss	xmm2, DWORD PTR [rcx+20]
	mulss	xmm2, DWORD PTR [rdx+24]
	movss	xmm1, DWORD PTR [rcx+24]
	mulss	xmm1, DWORD PTR [rdx+40]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [rcx+28]
	addss	xmm2, xmm1
	mulss	xmm0, DWORD PTR [rdx+56]
	addss	xmm2, xmm0
	movss	DWORD PTR [r8+24], xmm2

; 90   :       r[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];

	movss	xmm3, DWORD PTR [rcx+20]
	mulss	xmm3, DWORD PTR [rdx+28]
	movss	xmm0, DWORD PTR [rdx+12]
	mulss	xmm0, DWORD PTR [rcx+16]
	movss	xmm1, DWORD PTR [rcx+24]
	mulss	xmm1, DWORD PTR [rdx+44]
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR [rcx+28]
	mulss	xmm0, DWORD PTR [rdx+60]
	addss	xmm3, xmm1
	addss	xmm3, xmm0
	movss	DWORD PTR [r8+28], xmm3

; 91   : 
; 92   :       r[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];

	movss	xmm2, DWORD PTR [rcx+36]
	mulss	xmm2, DWORD PTR [rdx+16]
	movss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rdx+32]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [rcx+44]
	mulss	xmm0, DWORD PTR [rdx+48]
	addss	xmm2, xmm1
	addss	xmm2, xmm0
	movss	DWORD PTR [r8+32], xmm2

; 93   :       r[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];

	movss	xmm3, DWORD PTR [rcx+36]
	mulss	xmm3, DWORD PTR [rdx+20]
	movss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rdx+4]
	movss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rdx+36]
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR [rcx+44]
	mulss	xmm0, DWORD PTR [rdx+52]
	addss	xmm3, xmm1
	addss	xmm3, xmm0
	movss	DWORD PTR [r8+36], xmm3

; 94   :       r[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];

	movss	xmm2, DWORD PTR [rcx+36]
	mulss	xmm2, DWORD PTR [rdx+24]
	movss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rdx+40]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [rcx+44]
	mulss	xmm0, DWORD PTR [rdx+56]
	addss	xmm2, xmm1
	addss	xmm2, xmm0
	movss	DWORD PTR [r8+40], xmm2

; 95   :       r[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];

	movss	xmm3, DWORD PTR [rcx+32]
	mulss	xmm3, DWORD PTR [rdx+12]
	movss	xmm0, DWORD PTR [rdx+28]
	mulss	xmm0, DWORD PTR [rcx+36]
	movss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rdx+44]
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR [rcx+44]
	mulss	xmm0, DWORD PTR [rdx+60]
	addss	xmm3, xmm1
	addss	xmm3, xmm0
	movss	DWORD PTR [r8+44], xmm3

; 96   : 
; 97   :       r[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];

	movss	xmm0, DWORD PTR [rcx+48]
	mulss	xmm0, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rcx+56]
	mulss	xmm1, DWORD PTR [rdx+32]
	movss	xmm2, DWORD PTR [rcx+52]
	mulss	xmm2, DWORD PTR [rdx+16]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [rcx+60]
	mulss	xmm0, DWORD PTR [rdx+48]
	addss	xmm2, xmm1
	addss	xmm2, xmm0
	movss	DWORD PTR [r8+48], xmm2

; 98   :       r[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];

	movss	xmm3, DWORD PTR [rcx+52]
	movss	xmm0, DWORD PTR [rdx+4]
	mulss	xmm3, DWORD PTR [rdx+20]
	mulss	xmm0, DWORD PTR [rcx+48]
	movss	xmm1, DWORD PTR [rdx+36]
	addss	xmm3, xmm0
	mulss	xmm1, DWORD PTR [rcx+56]
	movss	xmm0, DWORD PTR [rdx+52]
	mulss	xmm0, DWORD PTR [rcx+60]
	addss	xmm3, xmm1
	addss	xmm3, xmm0
	movss	DWORD PTR [r8+52], xmm3

; 99   :       r[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];

	movss	xmm0, DWORD PTR [rcx+48]
	mulss	xmm0, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rdx+40]
	mulss	xmm1, DWORD PTR [rcx+56]
	movss	xmm2, DWORD PTR [rcx+52]
	mulss	xmm2, DWORD PTR [rdx+24]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [rcx+60]
	mulss	xmm0, DWORD PTR [rdx+56]
	addss	xmm2, xmm1
	addss	xmm2, xmm0
	movss	DWORD PTR [r8+56], xmm2

; 100  :       r[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];

	movss	xmm0, DWORD PTR [rdx+28]
	mulss	xmm0, DWORD PTR [rcx+52]
	movss	xmm3, DWORD PTR [rcx+48]
	mulss	xmm3, DWORD PTR [rdx+12]
	movss	xmm1, DWORD PTR [rcx+56]
	mulss	xmm1, DWORD PTR [rdx+44]
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR [rdx+60]
	mulss	xmm0, DWORD PTR [rcx+60]
	addss	xmm3, xmm1
	addss	xmm3, xmm0
	movss	DWORD PTR [r8+60], xmm3

; 101  :    }

	ret	0
?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z ENDP	; ImGuizmo::FPU_MatrixF_x_MatrixF
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Set@vec_t@ImGuizmo@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
?Set@vec_t@ImGuizmo@@QEAAXM@Z PROC			; ImGuizmo::vec_t::Set, COMDAT

; 207  :       void Set(float v) { x = y = z = w = v; }

	shufps	xmm1, xmm1, 0
	movups	XMMWORD PTR [rcx], xmm1
	ret	0
?Set@vec_t@ImGuizmo@@QEAAXM@Z ENDP			; ImGuizmo::vec_t::Set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Set@vec_t@ImGuizmo@@QEAAXMMMM@Z
_TEXT	SEGMENT
this$ = 8
_x$ = 16
_y$ = 24
_z$ = 32
_w$ = 40
?Set@vec_t@ImGuizmo@@QEAAXMMMM@Z PROC			; ImGuizmo::vec_t::Set, COMDAT

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm0, DWORD PTR _w$[rsp]
	movss	DWORD PTR [rcx+12], xmm0
	movss	DWORD PTR [rcx], xmm1
	movss	DWORD PTR [rcx+4], xmm2
	movss	DWORD PTR [rcx+8], xmm3
	ret	0
?Set@vec_t@ImGuizmo@@QEAAXMMMM@Z ENDP			; ImGuizmo::vec_t::Set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??Yvec_t@ImGuizmo@@QEAAAEAU01@AEBU01@@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
??Yvec_t@ImGuizmo@@QEAAAEAU01@AEBU01@@Z PROC		; ImGuizmo::vec_t::operator+=, COMDAT

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	movss	xmm0, DWORD PTR [rdx]
	mov	rax, rcx
	addss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [rcx], xmm0
	movss	xmm1, DWORD PTR [rdx+4]
	addss	xmm1, DWORD PTR [rcx+4]
	movss	DWORD PTR [rcx+4], xmm1
	movss	xmm0, DWORD PTR [rdx+8]
	addss	xmm0, DWORD PTR [rcx+8]
	movss	DWORD PTR [rcx+8], xmm0
	movss	xmm1, DWORD PTR [rdx+12]
	addss	xmm1, DWORD PTR [rcx+12]
	movss	DWORD PTR [rcx+12], xmm1
	ret	0
??Yvec_t@ImGuizmo@@QEAAAEAU01@AEBU01@@Z ENDP		; ImGuizmo::vec_t::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??Xvec_t@ImGuizmo@@QEAAAEAU01@M@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
??Xvec_t@ImGuizmo@@QEAAAEAU01@M@Z PROC			; ImGuizmo::vec_t::operator*=, COMDAT

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movups	xmm0, XMMWORD PTR [rcx]
	mov	rax, rcx
	movaps	xmm2, xmm1
	shufps	xmm2, xmm2, 0
	mulps	xmm2, xmm0
	movups	XMMWORD PTR [rcx], xmm2
	ret	0
??Xvec_t@ImGuizmo@@QEAAAEAU01@M@Z ENDP			; ImGuizmo::vec_t::operator*=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Length@vec_t@ImGuizmo@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?Length@vec_t@ImGuizmo@@QEBAMXZ PROC			; ImGuizmo::vec_t::Length, COMDAT

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm0, DWORD PTR [rcx+4]
	movss	xmm2, DWORD PTR [rcx]
	movss	xmm1, DWORD PTR [rcx+8]
	mulss	xmm2, xmm2
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN3@Length
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	ret	0
$LN3@Length:
	movaps	xmm0, xmm2
	jmp	sqrtf
?Length@vec_t@ImGuizmo@@QEBAMXZ ENDP			; ImGuizmo::vec_t::Length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?LengthSq@vec_t@ImGuizmo@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?LengthSq@vec_t@ImGuizmo@@QEBAMXZ PROC			; ImGuizmo::vec_t::LengthSq, COMDAT

; 223  :       float LengthSq() const { return (x * x + y * y + z * z); };

	movss	xmm1, DWORD PTR [rcx+4]
	movss	xmm0, DWORD PTR [rcx]
	movss	xmm2, DWORD PTR [rcx+8]
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	mulss	xmm2, xmm2
	addss	xmm0, xmm1
	addss	xmm0, xmm2
	ret	0
?LengthSq@vec_t@ImGuizmo@@QEBAMXZ ENDP			; ImGuizmo::vec_t::LengthSq
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Normalize@vec_t@ImGuizmo@@QEAA?AU12@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?Normalize@vec_t@ImGuizmo@@QEAA?AU12@XZ PROC		; ImGuizmo::vec_t::Normalize, COMDAT

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

$LN28:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm0, DWORD PTR [rcx+4]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mov	rdi, rdx

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm2, DWORD PTR [rcx]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mov	rbx, rcx

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm1, DWORD PTR [rcx+8]
	mulss	xmm2, xmm2
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN24@Normalize
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN25@Normalize
$LN24@Normalize:
	movaps	xmm0, xmm2
	call	sqrtf
$LN25@Normalize:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000
	movss	xmm2, DWORD PTR __real@3f800000
	mov	rax, rdi
	divss	xmm2, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movups	xmm0, XMMWORD PTR [rbx]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	shufps	xmm2, xmm2, 0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulps	xmm2, xmm0
	movups	XMMWORD PTR [rbx], xmm2

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mov	rbx, QWORD PTR [rsp+48]
	movups	XMMWORD PTR [rdi], xmm2
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Normalize@vec_t@ImGuizmo@@QEAA?AU12@XZ ENDP		; ImGuizmo::vec_t::Normalize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Normalize@vec_t@ImGuizmo@@QEAA?AU12@AEBU12@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
v$ = 64
?Normalize@vec_t@ImGuizmo@@QEAA?AU12@AEBU12@@Z PROC	; ImGuizmo::vec_t::Normalize, COMDAT

; 225  :       vec_t Normalize(const vec_t& v) { this->Set(v.x, v.y, v.z, v.w); this->Normalize(); return (*this); }

$LN33:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movss	xmm1, DWORD PTR [r8+4]
	mov	rdi, rdx

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm3, DWORD PTR [r8]

; 225  :       vec_t Normalize(const vec_t& v) { this->Set(v.x, v.y, v.z, v.w); this->Normalize(); return (*this); }

	mov	rbx, rcx
	movss	xmm0, DWORD PTR [r8+12]
	movss	xmm2, DWORD PTR [r8+8]

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR [rcx], xmm3

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm3, xmm3

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR [rcx+4], xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm1, xmm1

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR [rcx+8], xmm2

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm2, xmm2
	addss	xmm3, xmm1

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR [rcx+12], xmm0
	xorps	xmm0, xmm0

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm3, xmm2
	ucomiss	xmm0, xmm3
	ja	SHORT $LN28@Normalize
	xorps	xmm1, xmm1
	sqrtss	xmm1, xmm3
	jmp	SHORT $LN29@Normalize
$LN28@Normalize:
	movaps	xmm0, xmm3
	call	sqrtf
	movaps	xmm1, xmm0
$LN29@Normalize:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movss	xmm0, DWORD PTR __real@34000000
	comiss	xmm1, xmm0
	ja	SHORT $LN8@Normalize
	movaps	xmm1, xmm0
$LN8@Normalize:
	movss	xmm0, DWORD PTR __real@3f800000

; 225  :       vec_t Normalize(const vec_t& v) { this->Set(v.x, v.y, v.z, v.w); this->Normalize(); return (*this); }

	mov	rax, rdi

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm0, xmm1
	movaps	xmm1, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movups	xmm0, XMMWORD PTR [rbx]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	shufps	xmm1, xmm1, 0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulps	xmm1, xmm0
	movups	XMMWORD PTR [rbx], xmm1

; 225  :       vec_t Normalize(const vec_t& v) { this->Set(v.x, v.y, v.z, v.w); this->Normalize(); return (*this); }

	mov	rbx, QWORD PTR [rsp+48]
	movups	XMMWORD PTR [rdi], xmm1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Normalize@vec_t@ImGuizmo@@QEAA?AU12@AEBU12@@Z ENDP	; ImGuizmo::vec_t::Normalize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Cross@vec_t@ImGuizmo@@QEAAXAEBU12@@Z
_TEXT	SEGMENT
this$ = 32
v$ = 40
?Cross@vec_t@ImGuizmo@@QEAAXAEBU12@@Z PROC		; ImGuizmo::vec_t::Cross, COMDAT

; 229  :       {

$LN4:
	sub	rsp, 24

; 230  :          vec_t res;
; 231  :          res.x = y * v.z - z * v.y;

	movss	xmm1, DWORD PTR [rcx+8]

; 232  :          res.y = z * v.x - x * v.z;

	movss	xmm5, DWORD PTR [rcx]
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rdx+4]

; 233  :          res.z = x * v.y - y * v.x;
; 234  : 
; 235  :          x = res.x;
; 236  :          y = res.y;
; 237  :          z = res.z;
; 238  :          w = 0.f;

	mov	DWORD PTR [rcx+12], 0
	movss	xmm2, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp], xmm8
	movaps	xmm3, xmm2
	movss	xmm8, DWORD PTR [rcx+4]
	mulss	xmm8, DWORD PTR [rdx+8]
	mulss	xmm2, DWORD PTR [rcx+4]
	subss	xmm8, xmm0
	mulss	xmm3, xmm1
	movaps	xmm0, xmm5
	mulss	xmm5, DWORD PTR [rdx+4]
	mulss	xmm0, DWORD PTR [rdx+8]
	subss	xmm5, xmm2
	movss	DWORD PTR [rcx], xmm8

; 239  :       }

	movaps	xmm8, XMMWORD PTR [rsp]
	subss	xmm3, xmm0
	movss	DWORD PTR [rcx+8], xmm5
	movss	DWORD PTR [rcx+4], xmm3
	add	rsp, 24
	ret	0
?Cross@vec_t@ImGuizmo@@QEAAXAEBU12@@Z ENDP		; ImGuizmo::vec_t::Cross
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Cross@vec_t@ImGuizmo@@QEAAXAEBU12@0@Z
_TEXT	SEGMENT
this$ = 8
v1$ = 16
v2$ = 24
?Cross@vec_t@ImGuizmo@@QEAAXAEBU12@0@Z PROC		; ImGuizmo::vec_t::Cross, COMDAT

; 243  :          x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm1, DWORD PTR [r8+8]
	mulss	xmm1, DWORD PTR [rdx+4]
	movss	xmm0, DWORD PTR [rdx+8]
	mulss	xmm0, DWORD PTR [r8+4]
	subss	xmm1, xmm0
	movss	DWORD PTR [rcx], xmm1

; 244  :          y = v1.z * v2.x - v1.x * v2.z;

	movss	xmm0, DWORD PTR [rdx]
	mulss	xmm0, DWORD PTR [r8+8]
	movss	xmm2, DWORD PTR [rdx+8]
	mulss	xmm2, DWORD PTR [r8]
	subss	xmm2, xmm0
	movss	DWORD PTR [rcx+4], xmm2

; 245  :          z = v1.x * v2.y - v1.y * v2.x;

	movss	xmm1, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [r8]
	mulss	xmm1, DWORD PTR [r8+4]
	mulss	xmm0, DWORD PTR [rdx+4]

; 246  :          w = 0.f;

	mov	DWORD PTR [rcx+12], 0
	subss	xmm1, xmm0
	movss	DWORD PTR [rcx+8], xmm1

; 247  :       }

	ret	0
?Cross@vec_t@ImGuizmo@@QEAAXAEBU12@0@Z ENDP		; ImGuizmo::vec_t::Cross
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Dot@vec_t@ImGuizmo@@QEBAMAEBU12@@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
?Dot@vec_t@ImGuizmo@@QEBAMAEBU12@@Z PROC		; ImGuizmo::vec_t::Dot, COMDAT

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movss	xmm1, DWORD PTR [rdx]
	mulss	xmm1, DWORD PTR [rcx]
	movss	xmm0, DWORD PTR [rdx+4]
	mulss	xmm0, DWORD PTR [rcx+4]
	movss	xmm2, DWORD PTR [rdx+8]
	mulss	xmm2, DWORD PTR [rcx+8]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR [rdx+12]
	mulss	xmm1, DWORD PTR [rcx+12]
	addss	xmm0, xmm2
	addss	xmm0, xmm1

; 252  :       }

	ret	0
?Dot@vec_t@ImGuizmo@@QEBAMAEBU12@@Z ENDP		; ImGuizmo::vec_t::Dot
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Dot3@vec_t@ImGuizmo@@QEBAMAEBU12@@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
?Dot3@vec_t@ImGuizmo@@QEBAMAEBU12@@Z PROC		; ImGuizmo::vec_t::Dot3, COMDAT

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movss	xmm0, DWORD PTR [rdx+4]
	mulss	xmm0, DWORD PTR [rcx+4]
	movss	xmm1, DWORD PTR [rdx]
	mulss	xmm1, DWORD PTR [rcx]
	movss	xmm2, DWORD PTR [rdx+8]
	mulss	xmm2, DWORD PTR [rcx+8]
	addss	xmm0, xmm1
	addss	xmm0, xmm2

; 257  :       }

	ret	0
?Dot3@vec_t@ImGuizmo@@QEBAMAEBU12@@Z ENDP		; ImGuizmo::vec_t::Dot3
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?TransformVector@vec_t@ImGuizmo@@QEAAXAEBU12@AEBUmatrix_t@2@@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
matrix$ = 24
?TransformVector@vec_t@ImGuizmo@@QEAAXAEBU12@AEBUmatrix_t@2@@Z PROC ; ImGuizmo::vec_t::TransformVector, COMDAT

; 264  :       void TransformVector(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformVector(matrix); }

	movups	xmm0, XMMWORD PTR [rdx]
	mov	rdx, r8
	movups	XMMWORD PTR [rcx], xmm0
	jmp	?TransformVector@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z ; ImGuizmo::vec_t::TransformVector
?TransformVector@vec_t@ImGuizmo@@QEAAXAEBU12@AEBUmatrix_t@2@@Z ENDP ; ImGuizmo::vec_t::TransformVector
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?TransformPoint@vec_t@ImGuizmo@@QEAAXAEBU12@AEBUmatrix_t@2@@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
matrix$ = 24
?TransformPoint@vec_t@ImGuizmo@@QEAAXAEBU12@AEBUmatrix_t@2@@Z PROC ; ImGuizmo::vec_t::TransformPoint, COMDAT

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movups	xmm0, XMMWORD PTR [rdx]
	mov	rdx, r8
	movups	XMMWORD PTR [rcx], xmm0
	jmp	?TransformPoint@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z ; ImGuizmo::vec_t::TransformPoint
?TransformPoint@vec_t@ImGuizmo@@QEAAXAEBU12@AEBUmatrix_t@2@@Z ENDP ; ImGuizmo::vec_t::TransformPoint
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??Avec_t@ImGuizmo@@QEAAAEAM_K@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
??Avec_t@ImGuizmo@@QEAAAEAM_K@Z PROC			; ImGuizmo::vec_t::operator[], COMDAT

; 267  :       float& operator [] (size_t index) { return ((float*)&x)[index]; }

	lea	rax, QWORD PTR [rcx+rdx*4]
	ret	0
??Avec_t@ImGuizmo@@QEAAAEAM_K@Z ENDP			; ImGuizmo::vec_t::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??9vec_t@ImGuizmo@@QEBA_NAEBU01@@Z
_TEXT	SEGMENT
this$ = 8
other$ = 16
??9vec_t@ImGuizmo@@QEBA_NAEBU01@@Z PROC			; ImGuizmo::vec_t::operator!=, COMDAT

; 269  :       bool operator!=(const vec_t& other) const { return memcmp(this, &other, sizeof(vec_t)) != 0; }

	mov	rax, QWORD PTR [rcx]
	sub	rax, QWORD PTR [rdx]
	jne	SHORT $LN3@operator
	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rdx+8]
$LN3@operator:
	test	rax, rax
	setne	al
	ret	0
??9vec_t@ImGuizmo@@QEBA_NAEBU01@@Z ENDP			; ImGuizmo::vec_t::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?makeVect@ImGuizmo@@YA?AUvec_t@1@MMMM@Z
_TEXT	SEGMENT
__$ReturnAddress$ = 8
_x$ = 16
_y$ = 24
_z$ = 32
_w$ = 40
?makeVect@ImGuizmo@@YA?AUvec_t@1@MMMM@Z PROC		; ImGuizmo::makeVect, COMDAT

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movss	xmm0, DWORD PTR _w$[rsp]
	mov	rax, rcx
	movss	DWORD PTR [rcx+12], xmm0
	movss	DWORD PTR [rcx], xmm1
	movss	DWORD PTR [rcx+4], xmm2
	movss	DWORD PTR [rcx+8], xmm3
	ret	0
?makeVect@ImGuizmo@@YA?AUvec_t@1@MMMM@Z ENDP		; ImGuizmo::makeVect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?makeVect@ImGuizmo@@YA?AUvec_t@1@UImVec2@@@Z
_TEXT	SEGMENT
__$ReturnAddress$ = 8
v$ = 8
?makeVect@ImGuizmo@@YA?AUvec_t@1@UImVec2@@@Z PROC	; ImGuizmo::makeVect, COMDAT

; 273  :    vec_t makeVect(ImVec2 v) { vec_t res; res.x = v.x; res.y = v.y; res.z = 0.f; res.w = 0.f; return res; }

	mov	QWORD PTR v$[rsp], rdx
	xor	eax, eax
	movss	xmm0, DWORD PTR v$[rsp]
	movss	xmm1, DWORD PTR v$[rsp+4]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1
	ret	0
?makeVect@ImGuizmo@@YA?AUvec_t@1@UImVec2@@@Z ENDP	; ImGuizmo::makeVect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??Dvec_t@ImGuizmo@@QEBA?AU01@M@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
f$ = 24
??Dvec_t@ImGuizmo@@QEBA?AU01@M@Z PROC			; ImGuizmo::vec_t::operator*, COMDAT

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movups	xmm3, XMMWORD PTR [rcx]
	mov	rax, rdx
	shufps	xmm2, xmm2, 0
	mulps	xmm3, xmm2
	movups	XMMWORD PTR [rdx], xmm3
	ret	0
??Dvec_t@ImGuizmo@@QEBA?AU01@M@Z ENDP			; ImGuizmo::vec_t::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??Gvec_t@ImGuizmo@@QEBA?AU01@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
??Gvec_t@ImGuizmo@@QEBA?AU01@XZ PROC			; ImGuizmo::vec_t::operator-, COMDAT

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movups	xmm0, XMMWORD PTR [rcx]
	mov	rax, rdx
	xorps	xmm0, XMMWORD PTR __xmm@80000000800000008000000080000000
	movups	XMMWORD PTR [rdx], xmm0
	ret	0
??Gvec_t@ImGuizmo@@QEBA?AU01@XZ ENDP			; ImGuizmo::vec_t::operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??Gvec_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
v$ = 24
??Gvec_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z PROC		; ImGuizmo::vec_t::operator-, COMDAT

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm0, DWORD PTR [rcx]
	mov	rax, rdx
	movss	xmm3, DWORD PTR [rcx+4]
	movss	xmm2, DWORD PTR [rcx+8]
	movss	xmm1, DWORD PTR [rcx+12]
	subss	xmm0, DWORD PTR [r8]
	subss	xmm3, DWORD PTR [r8+4]
	subss	xmm2, DWORD PTR [r8+8]
	subss	xmm1, DWORD PTR [r8+12]
	movss	DWORD PTR [rdx], xmm0
	movss	DWORD PTR [rdx+4], xmm3
	movss	DWORD PTR [rdx+8], xmm2
	movss	DWORD PTR [rdx+12], xmm1
	ret	0
??Gvec_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z ENDP		; ImGuizmo::vec_t::operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??Hvec_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
v$ = 24
??Hvec_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z PROC		; ImGuizmo::vec_t::operator+, COMDAT

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	movss	xmm0, DWORD PTR [r8]
	mov	rax, rdx
	movss	xmm3, DWORD PTR [r8+4]
	movss	xmm2, DWORD PTR [r8+8]
	movss	xmm1, DWORD PTR [r8+12]
	addss	xmm0, DWORD PTR [rcx]
	addss	xmm3, DWORD PTR [rcx+4]
	addss	xmm2, DWORD PTR [rcx+8]
	addss	xmm1, DWORD PTR [rcx+12]
	movss	DWORD PTR [rdx], xmm0
	movss	DWORD PTR [rdx+4], xmm3
	movss	DWORD PTR [rdx+8], xmm2
	movss	DWORD PTR [rdx+12], xmm1
	ret	0
??Hvec_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z ENDP		; ImGuizmo::vec_t::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??Dvec_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
v$ = 24
??Dvec_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z PROC		; ImGuizmo::vec_t::operator*, COMDAT

; 278  :    vec_t vec_t::operator * (const vec_t& v) const { return makeVect(x * v.x, y * v.y, z * v.z, w * v.w); }

	movss	xmm0, DWORD PTR [r8]
	mov	rax, rdx
	movss	xmm3, DWORD PTR [r8+4]
	movss	xmm2, DWORD PTR [r8+8]
	movss	xmm1, DWORD PTR [r8+12]
	mulss	xmm0, DWORD PTR [rcx]
	mulss	xmm3, DWORD PTR [rcx+4]
	mulss	xmm2, DWORD PTR [rcx+8]
	mulss	xmm1, DWORD PTR [rcx+12]
	movss	DWORD PTR [rdx], xmm0
	movss	DWORD PTR [rdx+4], xmm3
	movss	DWORD PTR [rdx+8], xmm2
	movss	DWORD PTR [rdx+12], xmm1
	ret	0
??Dvec_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z ENDP		; ImGuizmo::vec_t::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Abs@vec_t@ImGuizmo@@QEBA?AU12@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?Abs@vec_t@ImGuizmo@@QEBA?AU12@XZ PROC			; ImGuizmo::vec_t::Abs, COMDAT
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movss	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 279  :    vec_t vec_t::Abs() const { return makeVect(fabsf(x), fabsf(y), fabsf(z)); }

	mov	rax, rdx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rcx]
	movss	xmm3, DWORD PTR [rcx+4]
	andps	xmm0, xmm1
	movss	xmm2, DWORD PTR [rcx+8]
	andps	xmm3, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 279  :    vec_t vec_t::Abs() const { return makeVect(fabsf(x), fabsf(y), fabsf(z)); }

	movss	DWORD PTR [rdx], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm2, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 279  :    vec_t vec_t::Abs() const { return makeVect(fabsf(x), fabsf(y), fabsf(z)); }

	movss	DWORD PTR [rdx+4], xmm3
	movss	DWORD PTR [rdx+8], xmm2
	mov	DWORD PTR [rdx+12], 0
	ret	0
?Abs@vec_t@ImGuizmo@@QEBA?AU12@XZ ENDP			; ImGuizmo::vec_t::Abs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Normalized@ImGuizmo@@YA?AUvec_t@1@AEBU21@@Z
_TEXT	SEGMENT
__$ReturnAddress$ = 48
v$ = 56
?Normalized@ImGuizmo@@YA?AUvec_t@1@AEBU21@@Z PROC	; ImGuizmo::Normalized, COMDAT

; 281  :    vec_t Normalized(const vec_t& v) { vec_t res; res = v; res.Normalize(); return res; }

$LN30:
	push	rbx
	sub	rsp, 32					; 00000020H
	movups	xmm2, XMMWORD PTR [rdx]
	mov	rbx, rcx

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm2
	movaps	xmm1, xmm2

; 281  :    vec_t Normalized(const vec_t& v) { vec_t res; res = v; res.Normalize(); return res; }

	movups	XMMWORD PTR [rcx], xmm2

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	shufps	xmm0, xmm0, 85				; 00000055H
	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
	shufps	xmm1, xmm1, 170				; 000000aaH
	mulss	xmm1, xmm1
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN26@Normalized
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN27@Normalized
$LN26@Normalized:
	movaps	xmm0, xmm2
	call	sqrtf
$LN27@Normalized:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000
	movss	xmm2, DWORD PTR __real@3f800000

; 281  :    vec_t Normalized(const vec_t& v) { vec_t res; res = v; res.Normalize(); return res; }

	mov	rax, rbx

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm2, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movups	xmm0, XMMWORD PTR [rbx]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	shufps	xmm2, xmm2, 0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulps	xmm2, xmm0
	movups	XMMWORD PTR [rbx], xmm2

; 281  :    vec_t Normalized(const vec_t& v) { vec_t res; res = v; res.Normalize(); return res; }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?Normalized@ImGuizmo@@YA?AUvec_t@1@AEBU21@@Z ENDP	; ImGuizmo::Normalized
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Cross@ImGuizmo@@YA?AUvec_t@1@AEBU21@0@Z
_TEXT	SEGMENT
__$ReturnAddress$ = 8
v1$ = 16
v2$ = 24
?Cross@ImGuizmo@@YA?AUvec_t@1@AEBU21@0@Z PROC		; ImGuizmo::Cross, COMDAT

; 284  :       vec_t res;
; 285  :       res.x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm5, DWORD PTR [r8+8]

; 286  :       res.y = v1.z * v2.x - v1.x * v2.z;
; 287  :       res.z = v1.x * v2.y - v1.y * v2.x;
; 288  :       res.w = 0.f;
; 289  :       return res;

	mov	rax, rcx
	movss	xmm0, DWORD PTR [r8+4]
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+12], 0
	mulss	xmm0, DWORD PTR [rdx+8]
	movss	xmm3, DWORD PTR [r8]
	movss	xmm4, DWORD PTR [rdx]
	subss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm4, DWORD PTR [r8+4]
	mulss	xmm0, xmm5
	movss	DWORD PTR [rcx], xmm1
	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR [rdx+8]
	mulss	xmm3, DWORD PTR [rdx+4]
	subss	xmm1, xmm0
	subss	xmm4, xmm3
	movss	DWORD PTR [rcx+4], xmm1
	movss	DWORD PTR [rcx+8], xmm4

; 290  :    }

	ret	0
?Cross@ImGuizmo@@YA?AUvec_t@1@AEBU21@0@Z ENDP		; ImGuizmo::Cross
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Dot@ImGuizmo@@YAMAEBUvec_t@1@0@Z
_TEXT	SEGMENT
v1$ = 8
v2$ = 16
?Dot@ImGuizmo@@YAMAEBUvec_t@1@0@Z PROC			; ImGuizmo::Dot, COMDAT

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	movss	xmm0, DWORD PTR [rcx+4]
	mulss	xmm0, DWORD PTR [rdx+4]
	movss	xmm1, DWORD PTR [rcx]
	mulss	xmm1, DWORD PTR [rdx]
	movss	xmm2, DWORD PTR [rcx+8]
	mulss	xmm2, DWORD PTR [rdx+8]
	addss	xmm0, xmm1
	addss	xmm0, xmm2

; 295  :    }

	ret	0
?Dot@ImGuizmo@@YAMAEBUvec_t@1@0@Z ENDP			; ImGuizmo::Dot
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?BuildPlan@ImGuizmo@@YA?AUvec_t@1@AEBU21@0@Z
_TEXT	SEGMENT
__$ReturnAddress$ = 64
p_point1$ = 72
p_normal$ = 80
?BuildPlan@ImGuizmo@@YA?AUvec_t@1@AEBU21@0@Z PROC	; ImGuizmo::BuildPlan, COMDAT

; 298  :    {

$LN23:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm0, DWORD PTR [r8]

; 298  :    {

	mov	rbx, r8

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm2, DWORD PTR [r8+4]

; 298  :    {

	mov	rsi, rdx

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm1, DWORD PTR [r8+8]

; 298  :    {

	mov	rdi, rcx

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm2, xmm2
	mulss	xmm0, xmm0

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	mulss	xmm1, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm2, xmm0
	movaps	XMMWORD PTR [rsp+32], xmm6
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN19@BuildPlan
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN20@BuildPlan
$LN19@BuildPlan:
	movaps	xmm0, xmm2
	call	sqrtf
$LN20@BuildPlan:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movss	xmm6, DWORD PTR __real@3f800000

; 305  :       return res;

	mov	rax, rdi

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000
	divss	xmm6, xmm0
	movaps	xmm5, xmm6

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm4, xmm6

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mulss	xmm5, DWORD PTR [rbx]

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm3, xmm6
	mulss	xmm4, DWORD PTR [rbx+4]
	mulss	xmm3, DWORD PTR [rbx+8]

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm0, xmm5

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm6, DWORD PTR [rbx+12]

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm2, xmm4

; 306  :    }

	mov	rbx, QWORD PTR [rsp+64]

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	mulss	xmm2, DWORD PTR [rsi+4]
	movaps	xmm1, xmm3
	mulss	xmm6, DWORD PTR [rsi+12]
	mulss	xmm0, DWORD PTR [rsi]
	mulss	xmm1, DWORD PTR [rsi+8]

; 306  :    }

	mov	rsi, QWORD PTR [rsp+72]

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	addss	xmm2, xmm0

; 299  :       vec_t normal, res;
; 300  :       normal.Normalize(p_normal);
; 301  :       res.w = normal.Dot(p_point1);
; 302  :       res.x = normal.x;

	movss	DWORD PTR [rdi], xmm5

; 303  :       res.y = normal.y;

	movss	DWORD PTR [rdi+4], xmm4

; 304  :       res.z = normal.z;

	movss	DWORD PTR [rdi+8], xmm3

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	addss	xmm2, xmm1
	addss	xmm2, xmm6

; 306  :    }

	movaps	xmm6, XMMWORD PTR [rsp+32]
	movss	DWORD PTR [rdi+12], xmm2
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?BuildPlan@ImGuizmo@@YA?AUvec_t@1@AEBU21@0@Z ENDP	; ImGuizmo::BuildPlan
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Translation@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@@Z
_TEXT	SEGMENT
this$ = 8
vt$ = 16
?Translation@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@@Z PROC ; ImGuizmo::matrix_t::Translation, COMDAT

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	xor	eax, eax
	mov	QWORD PTR [rcx], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+8], rax
	mov	DWORD PTR [rcx+16], eax
	mov	QWORD PTR [rcx+28], rax
	mov	DWORD PTR [rcx+36], eax
	mov	QWORD PTR [rcx+20], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+40], 1065353216		; 3f800000H

; 329  :          v.right.Set(1.f, 0.f, 0.f, 0.f);
; 330  :          v.up.Set(0.f, 1.f, 0.f, 0.f);
; 331  :          v.dir.Set(0.f, 0.f, 1.f, 0.f);
; 332  :          v.position.Set(vt.x, vt.y, vt.z, 1.f);

	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm0, DWORD PTR [rdx+4]

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	mov	eax, DWORD PTR [rdx]
	movss	DWORD PTR [rcx+52], xmm0
	movss	DWORD PTR [rcx+56], xmm1
	mov	DWORD PTR [rcx+48], eax
	mov	DWORD PTR [rcx+60], 1065353216		; 3f800000H

; 333  :       }

	ret	0
?Translation@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@@Z ENDP ; ImGuizmo::matrix_t::Translation
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Scale@matrix_t@ImGuizmo@@QEAAXMMM@Z
_TEXT	SEGMENT
this$ = 8
_x$ = 16
_y$ = 24
_z$ = 32
?Scale@matrix_t@ImGuizmo@@QEAAXMMM@Z PROC		; ImGuizmo::matrix_t::Scale, COMDAT

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	xor	eax, eax
	movss	DWORD PTR [rcx], xmm1
	mov	QWORD PTR [rcx+4], rax
	mov	QWORD PTR [rcx+12], rax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+44], rax
	mov	QWORD PTR [rcx+52], rax
	movss	DWORD PTR [rcx+20], xmm2
	movss	DWORD PTR [rcx+40], xmm3
	mov	DWORD PTR [rcx+60], 1065353216		; 3f800000H

; 337  :          v.right.Set(_x, 0.f, 0.f, 0.f);
; 338  :          v.up.Set(0.f, _y, 0.f, 0.f);
; 339  :          v.dir.Set(0.f, 0.f, _z, 0.f);
; 340  :          v.position.Set(0.f, 0.f, 0.f, 1.f);
; 341  :       }

	ret	0
?Scale@matrix_t@ImGuizmo@@QEAAXMMM@Z ENDP		; ImGuizmo::matrix_t::Scale
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Scale@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@@Z
_TEXT	SEGMENT
this$ = 8
s$ = 16
?Scale@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@@Z PROC	; ImGuizmo::matrix_t::Scale, COMDAT

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	mov	eax, DWORD PTR [rdx]

; 342  :       void Scale(const vec_t& s) { Scale(s.x, s.y, s.z); }

	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm0, DWORD PTR [rdx+4]

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	mov	DWORD PTR [rcx], eax
	xor	eax, eax
	mov	QWORD PTR [rcx+4], rax
	mov	QWORD PTR [rcx+12], rax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+44], rax
	mov	QWORD PTR [rcx+52], rax
	movss	DWORD PTR [rcx+20], xmm0
	movss	DWORD PTR [rcx+40], xmm1
	mov	DWORD PTR [rcx+60], 1065353216		; 3f800000H

; 342  :       void Scale(const vec_t& s) { Scale(s.x, s.y, s.z); }

	ret	0
?Scale@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@@Z ENDP	; ImGuizmo::matrix_t::Scale
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??Dmatrix_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
mat$ = 64
??Dmatrix_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z PROC		; ImGuizmo::matrix_t::operator*, COMDAT

; 353  :       {

$LN6:
	sub	rsp, 40					; 00000028H
	mov	rax, r8
	mov	r8, rdx

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	mov	rdx, rax
	call	?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z ; ImGuizmo::FPU_MatrixF_x_MatrixF

; 354  :          matrix_t matT;
; 355  :          matT.Multiply(*this, mat);
; 356  :          return matT;

	mov	rax, r8

; 357  :       }

	add	rsp, 40					; 00000028H
	ret	0
??Dmatrix_t@ImGuizmo@@QEBA?AU01@AEBU01@@Z ENDP		; ImGuizmo::matrix_t::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Multiply@matrix_t@ImGuizmo@@QEAAXAEBU12@0@Z
_TEXT	SEGMENT
this$ = 8
m1$ = 16
m2$ = 24
?Multiply@matrix_t@ImGuizmo@@QEAAXAEBU12@0@Z PROC	; ImGuizmo::matrix_t::Multiply, COMDAT

; 368  :       {

	mov	rax, r8
	mov	r9, rdx

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	mov	r8, rcx
	mov	rdx, rax
	mov	rcx, r9
	jmp	?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z ; ImGuizmo::FPU_MatrixF_x_MatrixF
?Multiply@matrix_t@ImGuizmo@@QEAAXAEBU12@0@Z ENDP	; ImGuizmo::matrix_t::Multiply
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?GetDeterminant@matrix_t@ImGuizmo@@QEBAMXZ
_TEXT	SEGMENT
this$ = 64
?GetDeterminant@matrix_t@ImGuizmo@@QEBAMXZ PROC		; ImGuizmo::matrix_t::GetDeterminant, COMDAT

; 373  :       {

$LN4:
	sub	rsp, 56					; 00000038H

; 374  :          return m[0][0] * m[1][1] * m[2][2] + m[0][1] * m[1][2] * m[2][0] + m[0][2] * m[1][0] * m[2][1] -

	movss	xmm0, DWORD PTR [rcx+4]
	mulss	xmm0, DWORD PTR [rcx+24]
	movss	xmm3, DWORD PTR [rcx+8]
	movaps	XMMWORD PTR [rsp+32], xmm6
	movaps	xmm1, xmm3
	movss	xmm6, DWORD PTR [rcx+16]
	mulss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm3, DWORD PTR [rcx+20]
	movaps	XMMWORD PTR [rsp+16], xmm9
	movaps	XMMWORD PTR [rsp], xmm11
	movss	xmm11, DWORD PTR [rcx]
	mulss	xmm3, DWORD PTR [rcx+32]
	movaps	xmm9, xmm11
	mulss	xmm9, DWORD PTR [rcx+20]
	mulss	xmm11, DWORD PTR [rcx+24]
	mulss	xmm9, DWORD PTR [rcx+40]
	mulss	xmm11, DWORD PTR [rcx+36]
	addss	xmm9, xmm0
	mulss	xmm1, xmm6
	mulss	xmm6, DWORD PTR [rcx+4]
	mulss	xmm1, DWORD PTR [rcx+36]
	mulss	xmm6, DWORD PTR [rcx+40]
	addss	xmm9, xmm1
	subss	xmm9, xmm3
	subss	xmm9, xmm6

; 375  :             m[0][2] * m[1][1] * m[2][0] - m[0][1] * m[1][0] * m[2][2] - m[0][0] * m[1][2] * m[2][1];
; 376  :       }

	movaps	xmm6, XMMWORD PTR [rsp+32]
	subss	xmm9, xmm11
	movaps	xmm11, XMMWORD PTR [rsp]
	movaps	xmm0, xmm9
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 56					; 00000038H
	ret	0
?GetDeterminant@matrix_t@ImGuizmo@@QEBAMXZ ENDP		; ImGuizmo::matrix_t::GetDeterminant
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?SetToIdentity@matrix_t@ImGuizmo@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?SetToIdentity@matrix_t@ImGuizmo@@QEAAXXZ PROC		; ImGuizmo::matrix_t::SetToIdentity, COMDAT

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	xor	eax, eax
	mov	QWORD PTR [rcx], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+8], rax
	mov	DWORD PTR [rcx+16], eax
	mov	QWORD PTR [rcx+28], rax
	mov	DWORD PTR [rcx+36], eax
	mov	QWORD PTR [rcx+48], rax
	mov	DWORD PTR [rcx+56], eax
	mov	QWORD PTR [rcx+20], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+40], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+60], 1065353216		; 3f800000H

; 381  :          v.right.Set(1.f, 0.f, 0.f, 0.f);
; 382  :          v.up.Set(0.f, 1.f, 0.f, 0.f);
; 383  :          v.dir.Set(0.f, 0.f, 1.f, 0.f);
; 384  :          v.position.Set(0.f, 0.f, 0.f, 1.f);
; 385  :       }

	ret	0
?SetToIdentity@matrix_t@ImGuizmo@@QEAAXXZ ENDP		; ImGuizmo::matrix_t::SetToIdentity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?OrthoNormalize@matrix_t@ImGuizmo@@QEAAXXZ
_TEXT	SEGMENT
this$ = 64
?OrthoNormalize@matrix_t@ImGuizmo@@QEAAXXZ PROC		; ImGuizmo::matrix_t::OrthoNormalize, COMDAT

; 402  :       {

$LN83:
	push	rbx
	sub	rsp, 48					; 00000030H

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm0, DWORD PTR [rcx+4]

; 402  :       {

	mov	rbx, rcx

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm2, DWORD PTR [rcx]
	movss	xmm1, DWORD PTR [rcx+8]
	mulss	xmm2, xmm2
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm2, xmm0
	movaps	XMMWORD PTR [rsp+32], xmm6
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN77@OrthoNorma
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN78@OrthoNorma
$LN77@OrthoNorma:
	movaps	xmm0, xmm2
	call	sqrtf
$LN78@OrthoNorma:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000
	movss	xmm6, DWORD PTR __real@3f800000
	movaps	xmm2, xmm6
	divss	xmm2, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movups	xmm0, XMMWORD PTR [rbx]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	shufps	xmm2, xmm2, 0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulps	xmm2, xmm0
	movups	XMMWORD PTR [rbx], xmm2

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm0, DWORD PTR [rbx+20]
	movss	xmm2, DWORD PTR [rbx+16]
	movss	xmm1, DWORD PTR [rbx+24]
	mulss	xmm2, xmm2
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN75@OrthoNorma
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN76@OrthoNorma
$LN75@OrthoNorma:
	movaps	xmm0, xmm2
	call	sqrtf
$LN76@OrthoNorma:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000
	movaps	xmm2, xmm6
	divss	xmm2, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movups	xmm0, XMMWORD PTR [rbx+16]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	shufps	xmm2, xmm2, 0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulps	xmm2, xmm0
	movups	XMMWORD PTR [rbx+16], xmm2

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm0, DWORD PTR [rbx+32]
	movss	xmm3, DWORD PTR [rbx+36]
	movss	xmm1, DWORD PTR [rbx+40]
	mulss	xmm3, xmm3
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm3, xmm0
	xorps	xmm0, xmm0
	addss	xmm3, xmm1
	ucomiss	xmm0, xmm3
	ja	SHORT $LN73@OrthoNorma
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm3
	jmp	SHORT $LN74@OrthoNorma
$LN73@OrthoNorma:
	movaps	xmm0, xmm3
	call	sqrtf
$LN74@OrthoNorma:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000
	divss	xmm6, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movups	xmm0, XMMWORD PTR [rbx+32]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movaps	xmm1, xmm6

; 403  :          v.right.Normalize();
; 404  :          v.up.Normalize();
; 405  :          v.dir.Normalize();
; 406  :       }

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	shufps	xmm1, xmm1, 0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulps	xmm1, xmm0
	movups	XMMWORD PTR [rbx+32], xmm1

; 403  :          v.right.Normalize();
; 404  :          v.up.Normalize();
; 405  :          v.dir.Normalize();
; 406  :       }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?OrthoNormalize@matrix_t@ImGuizmo@@QEAAXXZ ENDP		; ImGuizmo::matrix_t::OrthoNormalize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Transform@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z
_TEXT	SEGMENT
this$ = 64
matrix$ = 72
?Transform@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z PROC	; ImGuizmo::vec_t::Transform, COMDAT

; 410  :    {

$LN4:
	sub	rsp, 56					; 00000038H

; 411  :       vec_t out;
; 412  : 
; 413  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + w * matrix.m[3][0];

	movss	xmm4, DWORD PTR [rcx+4]
	movss	xmm5, DWORD PTR [rcx+8]
	movaps	XMMWORD PTR [rsp+32], xmm6
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR [rdx+32]
	movss	xmm6, DWORD PTR [rcx+12]
	movaps	XMMWORD PTR [rsp+16], xmm7
	movaps	xmm7, xmm4
	mulss	xmm7, DWORD PTR [rdx+16]
	movaps	XMMWORD PTR [rsp], xmm8
	movss	xmm8, DWORD PTR [rcx]
	movaps	xmm0, xmm8

; 414  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + w * matrix.m[3][1];

	movaps	xmm3, xmm8
	mulss	xmm0, DWORD PTR [rdx]

; 415  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + w * matrix.m[3][2];

	movaps	xmm2, xmm8

; 416  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + w * matrix.m[3][3];

	mulss	xmm8, DWORD PTR [rdx+12]
	mulss	xmm3, DWORD PTR [rdx+4]
	addss	xmm7, xmm0
	mulss	xmm2, DWORD PTR [rdx+8]
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rdx+48]
	addss	xmm7, xmm1
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR [rdx+36]
	addss	xmm7, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [rdx+20]
	addss	xmm3, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rdx+52]
	addss	xmm3, xmm1
	movaps	xmm1, xmm5
	mulss	xmm5, DWORD PTR [rdx+44]
	mulss	xmm1, DWORD PTR [rdx+40]
	addss	xmm3, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [rdx+24]
	mulss	xmm4, DWORD PTR [rdx+28]
	addss	xmm2, xmm0
	movaps	xmm0, xmm6
	mulss	xmm6, DWORD PTR [rdx+60]
	mulss	xmm0, DWORD PTR [rdx+56]
	addss	xmm8, xmm4
	addss	xmm2, xmm1

; 417  : 
; 418  :       x = out.x;

	movss	DWORD PTR [rcx], xmm7

; 419  :       y = out.y;
; 420  :       z = out.z;
; 421  :       w = out.w;
; 422  :    }

	movaps	xmm7, XMMWORD PTR [rsp+16]
	movss	DWORD PTR [rcx+4], xmm3
	addss	xmm8, xmm5
	addss	xmm2, xmm0
	addss	xmm8, xmm6
	movaps	xmm6, XMMWORD PTR [rsp+32]
	movss	DWORD PTR [rcx+8], xmm2
	movss	DWORD PTR [rcx+12], xmm8
	movaps	xmm8, XMMWORD PTR [rsp]
	add	rsp, 56					; 00000038H
	ret	0
?Transform@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z ENDP	; ImGuizmo::vec_t::Transform
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Transform@vec_t@ImGuizmo@@QEAAXAEBU12@AEBUmatrix_t@2@@Z
_TEXT	SEGMENT
this$ = 64
s$ = 72
matrix$ = 80
?Transform@vec_t@ImGuizmo@@QEAAXAEBU12@AEBUmatrix_t@2@@Z PROC ; ImGuizmo::vec_t::Transform, COMDAT

; 425  :    {

$LN6:
	sub	rsp, 56					; 00000038H
	movaps	XMMWORD PTR [rsp+32], xmm6
	movaps	XMMWORD PTR [rsp+16], xmm7
	movaps	XMMWORD PTR [rsp], xmm8

; 426  :       *this = s;

	movups	xmm8, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm8

; 413  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + w * matrix.m[3][0];

	movaps	xmm0, xmm8
	movaps	xmm7, xmm8
	mulss	xmm0, DWORD PTR [r8]
	movaps	xmm5, xmm8
	movaps	xmm6, xmm8
	shufps	xmm7, xmm7, 85				; 00000055H

; 414  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + w * matrix.m[3][1];

	movaps	xmm3, xmm8
	shufps	xmm6, xmm6, 255				; 000000ffH
	mulss	xmm3, DWORD PTR [r8+4]

; 415  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + w * matrix.m[3][2];

	movaps	xmm2, xmm8

; 416  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + w * matrix.m[3][3];

	mulss	xmm8, DWORD PTR [r8+12]
	movaps	xmm4, xmm7
	mulss	xmm4, DWORD PTR [r8+16]
	mulss	xmm2, DWORD PTR [r8+8]
	addss	xmm4, xmm0
	shufps	xmm5, xmm5, 170				; 000000aaH
	movaps	xmm0, xmm6
	movaps	xmm1, xmm5
	mulss	xmm0, DWORD PTR [r8+48]
	mulss	xmm1, DWORD PTR [r8+32]
	addss	xmm4, xmm1
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR [r8+36]
	addss	xmm4, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR [r8+20]
	addss	xmm3, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [r8+52]
	addss	xmm3, xmm1
	movaps	xmm1, xmm5
	mulss	xmm5, DWORD PTR [r8+44]
	mulss	xmm1, DWORD PTR [r8+40]
	addss	xmm3, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR [r8+24]
	mulss	xmm7, DWORD PTR [r8+28]
	addss	xmm2, xmm0
	movaps	xmm0, xmm6
	mulss	xmm6, DWORD PTR [r8+60]
	mulss	xmm0, DWORD PTR [r8+56]
	addss	xmm8, xmm7

; 427  :       Transform(matrix);
; 428  :    }

	movaps	xmm7, XMMWORD PTR [rsp+16]

; 415  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + w * matrix.m[3][2];

	addss	xmm2, xmm1

; 417  : 
; 418  :       x = out.x;

	movss	DWORD PTR [rcx], xmm4

; 419  :       y = out.y;

	movss	DWORD PTR [rcx+4], xmm3
	addss	xmm8, xmm5
	addss	xmm2, xmm0
	addss	xmm8, xmm6

; 427  :       Transform(matrix);
; 428  :    }

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 420  :       z = out.z;

	movss	DWORD PTR [rcx+8], xmm2

; 421  :       w = out.w;

	movss	DWORD PTR [rcx+12], xmm8

; 427  :       Transform(matrix);
; 428  :    }

	movaps	xmm8, XMMWORD PTR [rsp]
	add	rsp, 56					; 00000038H
	ret	0
?Transform@vec_t@ImGuizmo@@QEAAXAEBU12@AEBUmatrix_t@2@@Z ENDP ; ImGuizmo::vec_t::Transform
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?TransformPoint@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z
_TEXT	SEGMENT
this$ = 48
matrix$ = 56
?TransformPoint@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z PROC ; ImGuizmo::vec_t::TransformPoint, COMDAT

; 431  :    {

$LN4:
	sub	rsp, 40					; 00000028H

; 432  :       vec_t out;
; 433  : 
; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm4, DWORD PTR [rcx+4]
	movss	xmm5, DWORD PTR [rcx+8]
	movaps	XMMWORD PTR [rsp+16], xmm6
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR [rdx+32]
	movaps	xmm6, xmm4
	mulss	xmm6, DWORD PTR [rdx+16]
	movaps	XMMWORD PTR [rsp], xmm7
	movss	xmm7, DWORD PTR [rcx]
	movaps	xmm0, xmm7

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movaps	xmm3, xmm7
	mulss	xmm0, DWORD PTR [rdx]

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	movaps	xmm2, xmm7

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm7, DWORD PTR [rdx+12]
	mulss	xmm3, DWORD PTR [rdx+4]
	addss	xmm6, xmm0
	mulss	xmm2, DWORD PTR [rdx+8]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [rdx+20]
	addss	xmm6, xmm1
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR [rdx+36]
	addss	xmm3, xmm0
	movaps	xmm0, xmm4
	mulss	xmm4, DWORD PTR [rdx+28]
	mulss	xmm0, DWORD PTR [rdx+24]
	addss	xmm6, DWORD PTR [rdx+48]
	addss	xmm3, xmm1
	movaps	xmm1, xmm5
	mulss	xmm5, DWORD PTR [rdx+44]
	addss	xmm7, xmm4
	mulss	xmm1, DWORD PTR [rdx+40]
	addss	xmm2, xmm0
	addss	xmm3, DWORD PTR [rdx+52]
	addss	xmm7, xmm5
	addss	xmm2, xmm1
	addss	xmm7, DWORD PTR [rdx+60]
	addss	xmm2, DWORD PTR [rdx+56]

; 438  : 
; 439  :       x = out.x;

	movss	DWORD PTR [rcx], xmm6

; 440  :       y = out.y;
; 441  :       z = out.z;
; 442  :       w = out.w;
; 443  :    }

	movaps	xmm6, XMMWORD PTR [rsp+16]
	movss	DWORD PTR [rcx+12], xmm7
	movaps	xmm7, XMMWORD PTR [rsp]
	movss	DWORD PTR [rcx+8], xmm2
	movss	DWORD PTR [rcx+4], xmm3
	add	rsp, 40					; 00000028H
	ret	0
?TransformPoint@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z ENDP ; ImGuizmo::vec_t::TransformPoint
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?TransformVector@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z
_TEXT	SEGMENT
this$ = 48
matrix$ = 56
?TransformVector@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z PROC ; ImGuizmo::vec_t::TransformVector, COMDAT

; 446  :    {

$LN4:
	sub	rsp, 40					; 00000028H

; 447  :       vec_t out;
; 448  : 
; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm4, DWORD PTR [rcx+4]
	movss	xmm5, DWORD PTR [rcx+8]
	movaps	XMMWORD PTR [rsp+16], xmm6
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR [rdx+32]
	movaps	xmm6, xmm4
	mulss	xmm6, DWORD PTR [rdx+16]
	movaps	XMMWORD PTR [rsp], xmm7
	movss	xmm7, DWORD PTR [rcx]
	movaps	xmm0, xmm7

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	movaps	xmm3, xmm7
	mulss	xmm0, DWORD PTR [rdx]

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movaps	xmm2, xmm7

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	mulss	xmm7, DWORD PTR [rdx+12]
	mulss	xmm3, DWORD PTR [rdx+4]
	addss	xmm6, xmm0
	mulss	xmm2, DWORD PTR [rdx+8]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [rdx+20]
	addss	xmm6, xmm1
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR [rdx+36]
	addss	xmm3, xmm0
	movaps	xmm0, xmm4
	mulss	xmm4, DWORD PTR [rdx+28]
	mulss	xmm0, DWORD PTR [rdx+24]
	addss	xmm3, xmm1
	movaps	xmm1, xmm5
	mulss	xmm5, DWORD PTR [rdx+44]
	addss	xmm7, xmm4
	mulss	xmm1, DWORD PTR [rdx+40]
	addss	xmm2, xmm0

; 453  : 
; 454  :       x = out.x;

	movss	DWORD PTR [rcx], xmm6

; 455  :       y = out.y;
; 456  :       z = out.z;
; 457  :       w = out.w;
; 458  :    }

	movaps	xmm6, XMMWORD PTR [rsp+16]
	addss	xmm7, xmm5
	movss	DWORD PTR [rcx+4], xmm3
	addss	xmm2, xmm1
	movss	DWORD PTR [rcx+12], xmm7
	movaps	xmm7, XMMWORD PTR [rsp]
	movss	DWORD PTR [rcx+8], xmm2
	add	rsp, 40					; 00000028H
	ret	0
?TransformVector@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z ENDP ; ImGuizmo::vec_t::TransformVector
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Inverse@matrix_t@ImGuizmo@@QEAAMAEBU12@_N@Z
_TEXT	SEGMENT
tv3143 = 0
det$1$ = 4
tv3169 = 8
tv3157 = 12
tv3147 = 16
tv3149 = 20
tv3151 = 24
tv3245 = 28
tv3142 = 28
tv3155 = 32
tv3158 = 36
tv3133 = 40
tv3150 = 44
tv3156 = 48
tv3137 = 52
tv3145 = 56
tv3146 = 60
tv3159 = 64
tv3152 = 68
tv3164 = 72
tv3166 = 76
tv3161 = 80
tv3138 = 84
tv3135 = 88
tv3134 = 92
tv3139 = 96
tv3136 = 100
tv3124 = 112
this$ = 304
srcMatrix$ = 312
tv3140 = 320
affine$dead$ = 320
tv3141 = 328
?Inverse@matrix_t@ImGuizmo@@QEAAMAEBU12@_N@Z PROC	; ImGuizmo::matrix_t::Inverse, COMDAT

; 461  :    {

$LN36:
	mov	rax, rsp
	mov	BYTE PTR [rax+24], r8b
	sub	rsp, 296				; 00000128H

; 462  :       float det = 0;
; 463  : 
; 464  :       if (affine)
; 465  :       {
; 466  :          det = GetDeterminant();
; 467  :          float s = 1 / det;
; 468  :          m[0][0] = (srcMatrix.m[1][1] * srcMatrix.m[2][2] - srcMatrix.m[1][2] * srcMatrix.m[2][1]) * s;
; 469  :          m[0][1] = (srcMatrix.m[2][1] * srcMatrix.m[0][2] - srcMatrix.m[2][2] * srcMatrix.m[0][1]) * s;
; 470  :          m[0][2] = (srcMatrix.m[0][1] * srcMatrix.m[1][2] - srcMatrix.m[0][2] * srcMatrix.m[1][1]) * s;
; 471  :          m[1][0] = (srcMatrix.m[1][2] * srcMatrix.m[2][0] - srcMatrix.m[1][0] * srcMatrix.m[2][2]) * s;
; 472  :          m[1][1] = (srcMatrix.m[2][2] * srcMatrix.m[0][0] - srcMatrix.m[2][0] * srcMatrix.m[0][2]) * s;
; 473  :          m[1][2] = (srcMatrix.m[0][2] * srcMatrix.m[1][0] - srcMatrix.m[0][0] * srcMatrix.m[1][2]) * s;
; 474  :          m[2][0] = (srcMatrix.m[1][0] * srcMatrix.m[2][1] - srcMatrix.m[1][1] * srcMatrix.m[2][0]) * s;
; 475  :          m[2][1] = (srcMatrix.m[2][0] * srcMatrix.m[0][1] - srcMatrix.m[2][1] * srcMatrix.m[0][0]) * s;
; 476  :          m[2][2] = (srcMatrix.m[0][0] * srcMatrix.m[1][1] - srcMatrix.m[0][1] * srcMatrix.m[1][0]) * s;
; 477  :          m[3][0] = -(m[0][0] * srcMatrix.m[3][0] + m[1][0] * srcMatrix.m[3][1] + m[2][0] * srcMatrix.m[3][2]);
; 478  :          m[3][1] = -(m[0][1] * srcMatrix.m[3][0] + m[1][1] * srcMatrix.m[3][1] + m[2][1] * srcMatrix.m[3][2]);
; 479  :          m[3][2] = -(m[0][2] * srcMatrix.m[3][0] + m[1][2] * srcMatrix.m[3][1] + m[2][2] * srcMatrix.m[3][2]);
; 480  :       }
; 481  :       else
; 482  :       {
; 483  :          // transpose matrix
; 484  :          float src[16];
; 485  :          for (int i = 0; i < 4; ++i)
; 486  :          {
; 487  :             src[i] = srcMatrix.m16[i * 4];
; 488  :             src[i + 4] = srcMatrix.m16[i * 4 + 1];
; 489  :             src[i + 8] = srcMatrix.m16[i * 4 + 2];

	movss	xmm2, DWORD PTR [rdx+40]
	movss	xmm1, DWORD PTR [rdx+56]
	movss	xmm4, DWORD PTR [rdx+24]
	movss	xmm5, DWORD PTR [rdx+8]
	movss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR tv3143[rsp], xmm0
	movss	xmm0, DWORD PTR [rdx+16]
	movss	DWORD PTR det$1$[rsp], xmm0
	movss	xmm0, DWORD PTR [rdx+20]
	movss	DWORD PTR tv3141[rsp], xmm0
	movss	xmm0, DWORD PTR [rdx+48]
	movss	DWORD PTR tv3245[rsp], xmm0
	movss	xmm0, DWORD PTR [rdx+52]
	movaps	XMMWORD PTR [rax-24], xmm6

; 490  :             src[i + 12] = srcMatrix.m16[i * 4 + 3];
; 491  :          }
; 492  : 
; 493  :          // calculate pairs for first 8 elements (cofactors)
; 494  :          float tmp[12]; // temp array for pairs
; 495  :          tmp[0] = src[10] * src[15];
; 496  :          tmp[1] = src[11] * src[14];
; 497  :          tmp[2] = src[9] * src[15];
; 498  :          tmp[3] = src[11] * src[13];
; 499  :          tmp[4] = src[9] * src[14];

	movaps	xmm6, xmm2
	movss	DWORD PTR tv3169[rsp], xmm0
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rax-136], xmm13
	movaps	XMMWORD PTR [rax-152], xmm14
	movaps	XMMWORD PTR [rax-168], xmm15

; 500  :          tmp[5] = src[10] * src[13];
; 501  :          tmp[6] = src[8] * src[15];
; 502  :          tmp[7] = src[11] * src[12];
; 503  :          tmp[8] = src[8] * src[14];
; 504  :          tmp[9] = src[10] * src[12];

	movaps	xmm7, xmm5
	movss	xmm8, DWORD PTR [rdx+12]
	movaps	xmm9, xmm2
	movss	xmm13, DWORD PTR [rdx+60]
	movaps	xmm11, xmm1
	movss	xmm14, DWORD PTR [rdx+44]
	movaps	xmm0, xmm13
	movss	xmm10, DWORD PTR [rdx+28]
	movaps	xmm15, xmm14
	movss	xmm12, DWORD PTR [rdx+36]
	movaps	xmm3, xmm13
	mulss	xmm0, xmm2
	mulss	xmm3, xmm5
	movss	DWORD PTR tv3147[rsp], xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm14
	mulss	xmm15, xmm5
	movss	DWORD PTR tv3149[rsp], xmm0
	movaps	xmm0, xmm13
	mulss	xmm0, xmm4
	movss	DWORD PTR tv3146[rsp], xmm2
	movss	DWORD PTR tv3150[rsp], xmm4
	movss	DWORD PTR tv3155[rsp], xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm10
	movss	DWORD PTR tv3151[rsp], xmm5

; 505  :          tmp[10] = src[8] * src[13];

	movaps	xmm5, xmm4
	mulss	xmm6, xmm10
	movss	DWORD PTR tv3157[rsp], xmm0
	movaps	xmm0, xmm14
	mulss	xmm0, xmm4
	mulss	xmm5, xmm8

; 506  :          tmp[11] = src[9] * src[12];
; 507  : 
; 508  :          // calculate first 8 elements (cofactors)
; 509  :          m16[0] = (tmp[0] * src[5] + tmp[3] * src[6] + tmp[4] * src[7]) - (tmp[1] * src[5] + tmp[2] * src[6] + tmp[5] * src[7]);

	movaps	xmm4, xmm6
	mulss	xmm7, xmm10
	mulss	xmm11, xmm8
	movaps	xmm2, xmm5
	unpcklps xmm2, xmm7
	movss	DWORD PTR tv3140[rsp], xmm12
	unpcklps xmm4, xmm15
	movlhps	xmm4, xmm2
	movaps	xmm2, xmm11
	mulss	xmm9, xmm8
	movss	DWORD PTR tv3158[rsp], xmm0
	movss	xmm0, DWORD PTR tv3141[rsp]
	unpcklps xmm2, xmm15
	unpcklps xmm12, xmm3
	movss	DWORD PTR tv3145[rsp], xmm1
	movaps	xmm1, xmm0
	movlhps	xmm12, xmm2
	movss	DWORD PTR tv3152[rsp], xmm6
	movss	DWORD PTR tv3156[rsp], xmm3
	movss	DWORD PTR tv3159[rsp], xmm11
	movss	DWORD PTR tv3161[rsp], xmm9
	movss	DWORD PTR tv3166[rsp], xmm7
	movss	DWORD PTR tv3164[rsp], xmm5
	movaps	XMMWORD PTR tv3124[rsp], xmm4
	movss	xmm3, DWORD PTR tv3157[rsp]
	movaps	xmm2, xmm0
	movss	xmm0, DWORD PTR tv3140[rsp]
	movss	xmm4, DWORD PTR tv3147[rsp]
	unpcklps xmm3, xmm0
	movss	xmm0, DWORD PTR tv3149[rsp]
	unpcklps xmm2, xmm2
	movlhps	xmm3, xmm2
	movss	xmm2, DWORD PTR tv3155[rsp]
	mulps	xmm12, xmm3
	movss	xmm3, DWORD PTR tv3143[rsp]
	unpcklps xmm2, xmm3
	unpcklps xmm4, xmm0
	movaps	xmm0, xmm3
	movlhps	xmm4, xmm2
	movaps	xmm2, xmm3
	unpcklps xmm2, xmm6
	movaps	xmm3, xmm1
	movss	xmm6, DWORD PTR tv3158[rsp]
	unpcklps xmm3, xmm0
	movlhps	xmm3, xmm2
	movaps	xmm2, xmm7
	movss	xmm7, DWORD PTR tv3140[rsp]
	mulps	xmm4, xmm3
	movss	xmm3, DWORD PTR tv3169[rsp]
	unpcklps xmm2, xmm5
	movaps	xmm0, xmm3
	movss	xmm5, DWORD PTR tv3149[rsp]
	addps	xmm12, xmm4
	movaps	xmm4, xmm3
	unpcklps xmm4, xmm9
	movlhps	xmm4, xmm2
	movaps	xmm2, xmm3
	unpcklps xmm2, xmm7
	movaps	xmm3, xmm6
	unpcklps xmm3, xmm0
	movss	xmm0, DWORD PTR tv3147[rsp]
	movlhps	xmm3, xmm2
	mulps	xmm4, xmm3
	movss	xmm3, DWORD PTR tv3143[rsp]
	movaps	xmm2, xmm3
	unpcklps xmm5, xmm0
	unpcklps xmm2, xmm3
	movaps	xmm0, xmm3
	movlhps	xmm5, xmm2
	addps	xmm12, xmm4
	movss	xmm2, DWORD PTR tv3157[rsp]
	movaps	xmm4, xmm1
	unpcklps xmm2, xmm6
	movaps	xmm3, xmm1
	unpcklps xmm3, xmm0
	movaps	xmm1, xmm1
	movlhps	xmm3, xmm2
	movaps	xmm2, xmm4
	movss	xmm4, DWORD PTR tv3155[rsp]
	mulps	xmm5, xmm3
	movaps	xmm3, xmm7
	unpcklps xmm2, xmm1
	unpcklps xmm3, xmm11
	movss	xmm11, DWORD PTR tv3169[rsp]
	unpcklps xmm4, xmm7
	movlhps	xmm4, xmm2
	movss	xmm2, DWORD PTR tv3156[rsp]
	unpcklps xmm2, xmm9
	movlhps	xmm3, xmm2
	movaps	xmm2, xmm11
	mulps	xmm4, xmm3
	movaps	xmm3, xmm11
	unpcklps xmm3, xmm11
	unpcklps xmm2, xmm7
	movlhps	xmm3, xmm2
	mulps	xmm3, XMMWORD PTR tv3124[rsp]
	addps	xmm5, xmm4

; 510  :          m16[1] = (tmp[1] * src[4] + tmp[6] * src[6] + tmp[9] * src[7]) - (tmp[0] * src[4] + tmp[7] * src[6] + tmp[8] * src[7]);
; 511  :          m16[2] = (tmp[2] * src[4] + tmp[7] * src[5] + tmp[10] * src[7]) - (tmp[3] * src[4] + tmp[6] * src[5] + tmp[11] * src[7]);
; 512  :          m16[3] = (tmp[5] * src[4] + tmp[8] * src[5] + tmp[11] * src[6]) - (tmp[4] * src[4] + tmp[9] * src[5] + tmp[10] * src[6]);
; 513  :          m16[4] = (tmp[1] * src[1] + tmp[2] * src[2] + tmp[5] * src[3]) - (tmp[0] * src[1] + tmp[3] * src[2] + tmp[4] * src[3]);

	movss	xmm4, DWORD PTR [rdx]
	movaps	xmm2, xmm4
	unpcklps xmm2, xmm4
	addps	xmm5, xmm3
	movss	xmm3, DWORD PTR det$1$[rsp]
	movaps	xmm9, xmm3
	unpcklps xmm9, xmm4
	subps	xmm12, xmm5
	movss	xmm5, DWORD PTR tv3245[rsp]
	movaps	xmm0, xmm11
	movlhps	xmm9, xmm2
	movaps	xmm1, xmm3
	movaps	xmm2, xmm3
	movaps	xmm7, xmm5
	movss	xmm3, DWORD PTR [rdx+32]
	mulss	xmm0, xmm3
	movaps	xmm6, xmm3
	unpcklps xmm2, xmm2
	unpcklps xmm6, xmm3
	movss	DWORD PTR tv3134[rsp], xmm0
	movlhps	xmm6, xmm2
	movaps	xmm2, xmm5
	unpcklps xmm2, xmm3
	unpcklps xmm7, xmm5
	movlhps	xmm7, xmm2

; 514  :          m16[5] = (tmp[0] * src[0] + tmp[7] * src[2] + tmp[8] * src[3]) - (tmp[1] * src[0] + tmp[6] * src[2] + tmp[9] * src[3]);
; 515  :          m16[6] = (tmp[3] * src[0] + tmp[6] * src[1] + tmp[11] * src[3]) - (tmp[2] * src[0] + tmp[7] * src[1] + tmp[10] * src[3]);
; 516  :          m16[7] = (tmp[4] * src[0] + tmp[9] * src[1] + tmp[10] * src[2]) - (tmp[5] * src[0] + tmp[8] * src[1] + tmp[11] * src[2]);
; 517  : 
; 518  :          // calculate pairs for second 8 elements (cofactors)
; 519  :          tmp[0] = src[2] * src[7];

	movss	xmm2, DWORD PTR tv3140[rsp]
	movaps	xmm0, xmm2
	mulss	xmm0, xmm5
	movss	DWORD PTR tv3133[rsp], xmm0

; 520  :          tmp[1] = src[3] * src[6];

	movaps	xmm0, xmm11
	mulss	xmm0, xmm1

; 521  :          tmp[2] = src[1] * src[7];

	movss	xmm1, DWORD PTR tv3141[rsp]

; 522  :          tmp[3] = src[3] * src[5];
; 523  :          tmp[4] = src[1] * src[6];
; 524  :          tmp[5] = src[2] * src[5];

	mulss	xmm11, xmm4
	movss	DWORD PTR tv3135[rsp], xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm5
	movss	DWORD PTR tv3169[rsp], xmm11

; 525  :          tmp[6] = src[0] * src[7];
; 526  :          tmp[7] = src[3] * src[4];
; 527  :          tmp[8] = src[0] * src[6];
; 528  :          tmp[9] = src[2] * src[4];
; 529  :          tmp[10] = src[0] * src[5];
; 530  :          tmp[11] = src[1] * src[4];
; 531  : 
; 532  :          // calculate second 8 elements (cofactors)
; 533  :          m16[8] = (tmp[0] * src[13] + tmp[3] * src[14] + tmp[4] * src[15]) - (tmp[1] * src[13] + tmp[2] * src[14] + tmp[5] * src[15]);

	movaps	xmm11, xmm10
	unpcklps xmm11, xmm8
	movss	DWORD PTR tv3137[rsp], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR det$1$[rsp]
	movss	xmm2, DWORD PTR tv3143[rsp]
	movss	DWORD PTR tv3136[rsp], xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm3
	mulss	xmm1, xmm4
	movss	DWORD PTR tv3138[rsp], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm5
	movss	DWORD PTR tv3141[rsp], xmm1

; 538  :          m16[13] = (tmp[8] * src[11] + tmp[0] * src[8] + tmp[7] * src[10]) - (tmp[6] * src[10] + tmp[9] * src[11] + tmp[1] * src[8]);
; 539  :          m16[14] = (tmp[6] * src[9] + tmp[11] * src[11] + tmp[3] * src[8]) - (tmp[10] * src[11] + tmp[2] * src[8] + tmp[7] * src[9]);
; 540  :          m16[15] = (tmp[10] * src[10] + tmp[4] * src[8] + tmp[9] * src[9]) - (tmp[8] * src[9] + tmp[11] * src[10] + tmp[5] * src[8]);
; 541  : 
; 542  :          // calculate determinant
; 543  :          det = src[0] * m16[0] + src[1] * m16[1] + src[2] * m16[2] + src[3] * m16[3];

	movss	xmm1, DWORD PTR det$1$[rsp]
	movss	DWORD PTR tv3139[rsp], xmm0
	movss	xmm0, DWORD PTR tv3140[rsp]
	mulss	xmm0, xmm4
	mulss	xmm4, xmm12
	movss	DWORD PTR tv3140[rsp], xmm0
	movaps	xmm0, xmm2
	mulss	xmm2, DWORD PTR det$1$[rsp]
	mulss	xmm0, xmm3
	movss	DWORD PTR tv3143[rsp], xmm2
	movaps	xmm2, xmm8
	unpcklps xmm2, xmm8
	movaps	xmm8, xmm14
	movss	DWORD PTR tv3142[rsp], xmm0
	movaps	xmm0, xmm12
	shufps	xmm0, xmm0, 85				; 00000055H
	mulss	xmm1, xmm0
	movaps	xmm0, xmm12
	movlhps	xmm11, xmm2
	movaps	xmm2, xmm10
	unpcklps xmm2, xmm10
	movaps	xmm10, xmm13
	shufps	xmm0, xmm0, 170				; 000000aaH
	addss	xmm1, xmm4
	mulss	xmm3, xmm0
	movaps	xmm0, xmm12
	unpcklps xmm10, xmm13
	shufps	xmm0, xmm0, 255				; 000000ffH
	addss	xmm1, xmm3
	mulss	xmm5, xmm0
	unpcklps xmm8, xmm14
	movlhps	xmm8, xmm2
	movaps	xmm2, xmm13

; 544  : 
; 545  :          // calculate matrix inverse
; 546  :          float invdet = 1 / det;

	movss	xmm13, DWORD PTR __real@3f800000
	addss	xmm1, xmm5
	unpcklps xmm2, xmm14
	movlhps	xmm10, xmm2
	movss	DWORD PTR det$1$[rsp], xmm1

; 510  :          m16[1] = (tmp[1] * src[4] + tmp[6] * src[6] + tmp[9] * src[7]) - (tmp[0] * src[4] + tmp[7] * src[6] + tmp[8] * src[7]);
; 511  :          m16[2] = (tmp[2] * src[4] + tmp[7] * src[5] + tmp[10] * src[7]) - (tmp[3] * src[4] + tmp[6] * src[5] + tmp[11] * src[7]);
; 512  :          m16[3] = (tmp[5] * src[4] + tmp[8] * src[5] + tmp[11] * src[6]) - (tmp[4] * src[4] + tmp[9] * src[5] + tmp[10] * src[6]);
; 513  :          m16[4] = (tmp[1] * src[1] + tmp[2] * src[2] + tmp[5] * src[3]) - (tmp[0] * src[1] + tmp[3] * src[2] + tmp[4] * src[3]);

	movss	xmm14, DWORD PTR tv3156[rsp]
	movss	xmm4, DWORD PTR tv3161[rsp]
	movss	xmm5, DWORD PTR tv3157[rsp]
	movss	xmm3, DWORD PTR tv3147[rsp]
	unpcklps xmm5, xmm14

; 544  : 
; 545  :          // calculate matrix inverse
; 546  :          float invdet = 1 / det;

	divss	xmm13, xmm1
	movss	xmm1, DWORD PTR tv3152[rsp]
	shufps	xmm13, xmm13, 0

; 547  :          for (int j = 0; j < 16; ++j)
; 548  :          {
; 549  :             m16[j] *= invdet;

	movaps	xmm0, xmm13
	mulps	xmm0, xmm12
	movss	xmm12, DWORD PTR tv3159[rsp]
	movaps	xmm2, xmm12
	unpcklps xmm2, xmm15
	movss	xmm15, DWORD PTR tv3155[rsp]
	movlhps	xmm5, xmm2
	movaps	xmm2, xmm15
	unpcklps xmm2, xmm1
	movss	xmm1, DWORD PTR tv3164[rsp]
	mulps	xmm5, xmm6
	movups	XMMWORD PTR [rcx], xmm0
	movss	xmm0, DWORD PTR tv3149[rsp]
	unpcklps xmm3, xmm0
	movss	xmm0, DWORD PTR tv3147[rsp]
	movlhps	xmm3, xmm2
	movss	xmm2, DWORD PTR tv3166[rsp]
	mulps	xmm3, xmm9
	unpcklps xmm2, xmm1
	movaps	xmm1, xmm4
	addps	xmm5, xmm3
	movss	xmm3, DWORD PTR tv3158[rsp]
	unpcklps xmm3, xmm4
	movaps	xmm4, xmm15
	movss	xmm15, DWORD PTR tv3139[rsp]
	movlhps	xmm3, xmm2
	movaps	xmm2, xmm14
	movss	xmm14, DWORD PTR tv3138[rsp]
	mulps	xmm3, xmm7
	mulps	xmm7, XMMWORD PTR tv3124[rsp]
	unpcklps xmm2, xmm1
	movss	xmm1, DWORD PTR tv3158[rsp]
	addps	xmm5, xmm3
	movss	xmm3, DWORD PTR tv3149[rsp]
	unpcklps xmm3, xmm0
	movss	xmm0, DWORD PTR tv3133[rsp]
	unpcklps xmm4, xmm12
	movss	xmm12, DWORD PTR tv3134[rsp]
	movlhps	xmm4, xmm2
	movss	xmm2, DWORD PTR tv3157[rsp]
	unpcklps xmm2, xmm1
	movss	xmm1, DWORD PTR tv3140[rsp]
	movlhps	xmm3, xmm2
	mulps	xmm3, xmm9
	movss	xmm9, DWORD PTR tv3135[rsp]
	mulps	xmm4, xmm6
	movaps	xmm2, xmm9
	movss	xmm6, DWORD PTR tv3142[rsp]
	unpcklps xmm2, xmm14
	addps	xmm4, xmm3
	movss	xmm3, DWORD PTR tv3137[rsp]
	addps	xmm4, xmm7
	movss	xmm7, DWORD PTR tv3136[rsp]
	subps	xmm4, xmm5
	movaps	xmm5, xmm12
	unpcklps xmm5, xmm0
	movlhps	xmm5, xmm2
	movaps	xmm2, xmm15
	unpcklps xmm2, xmm1
	movss	xmm1, DWORD PTR tv3143[rsp]
	mulps	xmm4, xmm13
	mulps	xmm5, xmm11
	movups	XMMWORD PTR [rcx+16], xmm4
	movss	xmm4, DWORD PTR tv3169[rsp]
	unpcklps xmm3, xmm4
	movlhps	xmm3, xmm2
	movss	xmm2, DWORD PTR tv3141[rsp]
	mulps	xmm3, xmm8
	unpcklps xmm2, xmm1
	addps	xmm5, xmm3
	movaps	xmm3, xmm7
	unpcklps xmm3, xmm6
	movlhps	xmm3, xmm2

; 525  :          tmp[6] = src[0] * src[7];
; 526  :          tmp[7] = src[3] * src[4];
; 527  :          tmp[8] = src[0] * src[6];
; 528  :          tmp[9] = src[2] * src[4];
; 529  :          tmp[10] = src[0] * src[5];
; 530  :          tmp[11] = src[1] * src[4];
; 531  : 
; 532  :          // calculate second 8 elements (cofactors)
; 533  :          m16[8] = (tmp[0] * src[13] + tmp[3] * src[14] + tmp[4] * src[15]) - (tmp[1] * src[13] + tmp[2] * src[14] + tmp[5] * src[15]);

	mulps	xmm3, xmm10
	movaps	xmm2, xmm4
	unpcklps xmm2, xmm6
	movaps	xmm4, xmm9
	unpcklps xmm4, xmm15
	movlhps	xmm4, xmm2
	addps	xmm5, xmm3
	mulps	xmm4, xmm8
	movss	xmm8, DWORD PTR tv3137[rsp]
	movaps	xmm3, xmm0
	movss	xmm0, DWORD PTR tv3140[rsp]
	movaps	xmm2, xmm8
	unpcklps xmm2, xmm7
	unpcklps xmm3, xmm12
	movlhps	xmm3, xmm2
	movaps	xmm2, xmm1
	mulps	xmm3, xmm11
	movss	xmm11, DWORD PTR tv3141[rsp]
	unpcklps xmm2, xmm11
	addps	xmm4, xmm3
	movaps	xmm3, xmm14
	unpcklps xmm3, xmm0

; 534  :          m16[9] = (tmp[1] * src[12] + tmp[6] * src[14] + tmp[9] * src[15]) - (tmp[0] * src[12] + tmp[7] * src[14] + tmp[8] * src[15]);
; 535  :          m16[10] = (tmp[2] * src[12] + tmp[7] * src[13] + tmp[10] * src[15]) - (tmp[3] * src[12] + tmp[6] * src[13] + tmp[11] * src[15]);
; 536  :          m16[11] = (tmp[5] * src[12] + tmp[8] * src[13] + tmp[11] * src[14]) - (tmp[4] * src[12] + tmp[9] * src[13] + tmp[10] * src[14]);
; 537  :          m16[12] = (tmp[2] * src[10] + tmp[5] * src[11] + tmp[1] * src[9]) - (tmp[4] * src[11] + tmp[0] * src[9] + tmp[3] * src[10]);

	movaps	xmm0, xmm6
	movlhps	xmm3, xmm2
	movaps	xmm2, xmm11
	movss	xmm11, DWORD PTR tv3169[rsp]
	mulps	xmm3, xmm10
	movss	xmm10, DWORD PTR tv3150[rsp]
	unpcklps xmm2, xmm1
	movss	xmm1, DWORD PTR tv3140[rsp]
	addps	xmm4, xmm3
	movss	xmm3, DWORD PTR tv3145[rsp]
	movaps	xmm6, xmm3
	unpcklps xmm6, xmm0
	movaps	xmm0, xmm3
	movlhps	xmm6, xmm2
	movaps	xmm2, xmm3
	movaps	xmm3, xmm7
	subps	xmm5, xmm4
	unpcklps xmm3, xmm0
	movss	xmm0, DWORD PTR tv3151[rsp]
	movaps	xmm4, xmm12
	unpcklps xmm4, xmm11

; 547  :          for (int j = 0; j < 16; ++j)
; 548  :          {
; 549  :             m16[j] *= invdet;

	mulps	xmm5, xmm13
	movups	XMMWORD PTR [rcx+32], xmm5
	movss	xmm5, DWORD PTR tv3146[rsp]
	unpcklps xmm2, xmm5
	movlhps	xmm3, xmm2
	movaps	xmm2, xmm9
	unpcklps xmm2, xmm10
	movlhps	xmm4, xmm2
	movss	xmm2, DWORD PTR tv3151[rsp]
	mulps	xmm6, xmm3
	movaps	xmm3, xmm10
	unpcklps xmm2, xmm1
	unpcklps xmm3, xmm5
	movlhps	xmm3, xmm2
	movaps	xmm2, xmm10
	movss	xmm10, DWORD PTR tv3133[rsp]
	mulps	xmm4, xmm3
	movaps	xmm3, xmm5
	unpcklps xmm2, xmm14
	unpcklps xmm3, xmm0
	unpcklps xmm5, xmm0
	addps	xmm6, xmm4
	movaps	xmm4, xmm8
	unpcklps xmm4, xmm10
	movlhps	xmm4, xmm2
	movaps	xmm2, xmm15
	unpcklps xmm2, xmm0
	movlhps	xmm3, xmm2
	movss	xmm2, DWORD PTR tv3150[rsp]
	mulps	xmm4, xmm3
	movaps	xmm3, xmm9
	unpcklps xmm2, xmm0
	movlhps	xmm5, xmm2
	movaps	xmm2, xmm11
	unpcklps xmm2, xmm7
	unpcklps xmm3, xmm12
	addps	xmm6, xmm4
	movlhps	xmm3, xmm2

; 550  :          }
; 551  :       }
; 552  : 
; 553  :       return det;
; 554  :    }

	movss	xmm7, DWORD PTR tv3146[rsp]
	lea	r11, QWORD PTR [rax]
	movss	xmm1, DWORD PTR tv3141[rsp]
	movss	xmm0, DWORD PTR tv3140[rsp]
	movss	xmm2, DWORD PTR tv3143[rsp]
	movaps	xmm9, XMMWORD PTR [r11-72]
	movaps	xmm11, XMMWORD PTR [r11-104]
	movaps	xmm12, XMMWORD PTR [r11-120]
	mulps	xmm5, xmm3
	movss	xmm3, DWORD PTR tv3145[rsp]
	unpcklps xmm2, xmm1
	movaps	xmm4, xmm3
	movss	xmm1, DWORD PTR tv3142[rsp]
	unpcklps xmm4, xmm3
	movlhps	xmm4, xmm2
	movaps	xmm2, xmm3
	unpcklps xmm2, xmm7
	movaps	xmm3, xmm14
	movaps	xmm14, XMMWORD PTR [r11-152]
	unpcklps xmm3, xmm0
	movss	xmm0, DWORD PTR det$1$[rsp]
	movlhps	xmm3, xmm2
	movaps	xmm2, xmm8
	movaps	xmm8, XMMWORD PTR [r11-56]
	mulps	xmm4, xmm3
	movss	xmm3, DWORD PTR tv3150[rsp]
	unpcklps xmm2, xmm3
	unpcklps xmm3, xmm7
	movaps	xmm7, XMMWORD PTR [r11-40]
	addps	xmm5, xmm4
	movaps	xmm4, xmm10
	movaps	xmm10, XMMWORD PTR [r11-88]
	unpcklps xmm4, xmm15
	movaps	xmm15, XMMWORD PTR [r11-168]
	movlhps	xmm4, xmm2
	movss	xmm2, DWORD PTR tv3151[rsp]
	unpcklps xmm2, xmm1
	movlhps	xmm3, xmm2
	mulps	xmm4, xmm3
	addps	xmm5, xmm4
	subps	xmm5, xmm6
	movaps	xmm6, XMMWORD PTR [r11-24]
	mulps	xmm5, xmm13
	movaps	xmm13, XMMWORD PTR [r11-136]
	movups	XMMWORD PTR [rcx+48], xmm5
	mov	rsp, r11
	ret	0
?Inverse@matrix_t@ImGuizmo@@QEAAMAEBU12@_N@Z ENDP	; ImGuizmo::matrix_t::Inverse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?RotationAxis@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@M@Z
_TEXT	SEGMENT
this$ = 192
axis$ = 200
angle$ = 208
?RotationAxis@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@M@Z PROC ; ImGuizmo::matrix_t::RotationAxis, COMDAT

; 557  :    {

$LN26:
	push	rbx
	sub	rsp, 176				; 000000b0H
	movaps	XMMWORD PTR [rsp+144], xmm7
	mov	rbx, rcx
	movaps	XMMWORD PTR [rsp+80], xmm11
	movaps	xmm7, xmm2

; 223  :       float LengthSq() const { return (x * x + y * y + z * z); };

	movss	xmm11, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp+64], xmm12
	movaps	xmm3, xmm11
	movss	xmm12, DWORD PTR [rdx+4]
	movaps	xmm0, xmm12
	mulss	xmm3, xmm11
	mulss	xmm0, xmm12
	movaps	XMMWORD PTR [rsp+48], xmm13
	movss	xmm13, DWORD PTR [rdx+8]
	addss	xmm3, xmm0
	movaps	XMMWORD PTR [rsp+32], xmm14

; 558  :       float length2 = axis.LengthSq();
; 559  :       if (length2 < FLT_EPSILON)

	movss	xmm0, DWORD PTR __real@34000000

; 223  :       float LengthSq() const { return (x * x + y * y + z * z); };

	movaps	xmm1, xmm13
	mulss	xmm1, xmm13
	addss	xmm3, xmm1

; 558  :       float length2 = axis.LengthSq();
; 559  :       if (length2 < FLT_EPSILON)

	comiss	xmm0, xmm3
	xorps	xmm0, xmm0
	jbe	SHORT $LN2@RotationAx

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm14, DWORD PTR __real@3f800000
	xor	eax, eax
	mov	QWORD PTR [rcx+8], rax
	mov	DWORD PTR [rcx+16], eax
	mov	QWORD PTR [rcx+28], rax
	mov	DWORD PTR [rcx+36], eax
	mov	QWORD PTR [rcx], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+20], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+40], 1065353216		; 3f800000H

; 560  :       {
; 561  :          SetToIdentity();
; 562  :          return;

	jmp	$LN24@RotationAx
$LN2@RotationAx:

; 563  :       }
; 564  : 
; 565  :       vec_t n = axis * (1.f / sqrtf(length2));

	ucomiss	xmm0, xmm3
	movaps	XMMWORD PTR [rsp+160], xmm6
	movaps	XMMWORD PTR [rsp+128], xmm8
	movaps	XMMWORD PTR [rsp+112], xmm9
	movaps	XMMWORD PTR [rsp+96], xmm10
	ja	SHORT $LN20@RotationAx
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm3
	jmp	SHORT $LN21@RotationAx
$LN20@RotationAx:
	movaps	xmm0, xmm3
	call	sqrtf
$LN21@RotationAx:
	movss	xmm14, DWORD PTR __real@3f800000
	movaps	xmm1, xmm14
	divss	xmm1, xmm0

; 566  :       float s = sinf(angle);

	movaps	xmm0, xmm7

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm11, xmm1
	mulss	xmm12, xmm1
	mulss	xmm13, xmm1

; 566  :       float s = sinf(angle);

	call	sinf
	movaps	xmm6, xmm0

; 567  :       float c = cosf(angle);

	movaps	xmm0, xmm7
	call	cosf
	movaps	xmm10, xmm0

; 568  :       float k = 1.f - c;
; 569  : 
; 570  :       float xx = n.x * n.x * k + c;
; 571  :       float yy = n.y * n.y * k + c;
; 572  :       float zz = n.z * n.z * k + c;
; 573  :       float xy = n.x * n.y * k;
; 574  :       float yz = n.y * n.z * k;
; 575  :       float zx = n.z * n.x * k;
; 576  :       float xs = n.x * s;
; 577  :       float ys = n.y * s;
; 578  :       float zs = n.z * s;

	movaps	xmm2, xmm13
	movaps	xmm7, xmm13
	mulss	xmm2, xmm6

; 579  : 
; 580  :       m[0][0] = xx;
; 581  :       m[0][1] = xy + zs;
; 582  :       m[0][2] = zx - ys;
; 583  :       m[0][3] = 0.f;

	xor	eax, eax
	movaps	xmm8, xmm13
	mulss	xmm7, xmm11
	mov	DWORD PTR [rbx+12], eax
	mulss	xmm8, xmm12
	movaps	xmm5, xmm11

; 584  :       m[1][0] = xy - zs;
; 585  :       m[1][1] = yy;
; 586  :       m[1][2] = yz + xs;
; 587  :       m[1][3] = 0.f;

	mov	DWORD PTR [rbx+28], eax
	movaps	xmm4, xmm12
	mulss	xmm5, xmm6

; 588  :       m[2][0] = zx + ys;
; 589  :       m[2][1] = yz - xs;
; 590  :       m[2][2] = zz;
; 591  :       m[2][3] = 0.f;

	mov	DWORD PTR [rbx+44], eax
	mulss	xmm4, xmm11
	movaps	xmm3, xmm12
	mulss	xmm3, xmm6
	movaps	xmm9, xmm14

; 592  :       m[3][0] = 0.f;
; 593  :       m[3][1] = 0.f;
; 594  :       m[3][2] = 0.f;
; 595  :       m[3][3] = 1.f;

	movaps	xmm6, XMMWORD PTR [rsp+160]
	subss	xmm9, xmm10
	movaps	xmm0, xmm2
	mulss	xmm11, xmm11
	mulss	xmm12, xmm12
	mulss	xmm8, xmm9
	mulss	xmm4, xmm9
	mulss	xmm7, xmm9
	addss	xmm0, xmm4
	mulss	xmm13, xmm13
	mulss	xmm11, xmm9
	subss	xmm4, xmm2
	mulss	xmm12, xmm9
	movaps	xmm1, xmm7
	movss	DWORD PTR [rbx+4], xmm0
	subss	xmm1, xmm3
	mulss	xmm13, xmm9
	addss	xmm11, xmm10
	movaps	xmm9, XMMWORD PTR [rsp+112]
	addss	xmm12, xmm10
	movaps	xmm0, xmm5
	movss	DWORD PTR [rbx+16], xmm4
	addss	xmm0, xmm8
	movss	DWORD PTR [rbx+8], xmm1
	subss	xmm8, xmm5
	movss	DWORD PTR [rbx], xmm11
	addss	xmm13, xmm10
	movaps	xmm10, XMMWORD PTR [rsp+96]
	addss	xmm3, xmm7
	movss	DWORD PTR [rbx+20], xmm12
	movss	DWORD PTR [rbx+24], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR [rbx+36], xmm8
	movaps	xmm8, XMMWORD PTR [rsp+128]
	movss	DWORD PTR [rbx+32], xmm3
	movss	DWORD PTR [rbx+40], xmm13
$LN24@RotationAx:

; 596  :    }

	mov	r8d, 52					; 00000034H
	mov	ecx, 60					; 0000003cH
	movss	DWORD PTR [rbx+r8], xmm0
	lea	edx, QWORD PTR [r8+4]
	movss	DWORD PTR [rbx+rdx], xmm0
	movss	DWORD PTR [rbx+rcx], xmm14
	mov	DWORD PTR [rbx+48], eax
	movaps	xmm7, XMMWORD PTR [rsp+144]
	movaps	xmm11, XMMWORD PTR [rsp+80]
	movaps	xmm12, XMMWORD PTR [rsp+64]
	movaps	xmm13, XMMWORD PTR [rsp+48]
	movaps	xmm14, XMMWORD PTR [rsp+32]
	add	rsp, 176				; 000000b0H
	pop	rbx
	ret	0
?RotationAxis@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@M@Z ENDP ; ImGuizmo::matrix_t::RotationAxis
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?IsTranslateType@ImGuizmo@@YA_NH@Z
_TEXT	SEGMENT
type$ = 8
?IsTranslateType@ImGuizmo@@YA_NH@Z PROC			; ImGuizmo::IsTranslateType, COMDAT

; 623  :      return type >= MT_MOVE_X && type <= MT_MOVE_SCREEN;

	lea	eax, DWORD PTR [rcx-1]
	cmp	eax, 6
	setbe	al

; 624  :    }

	ret	0
?IsTranslateType@ImGuizmo@@YA_NH@Z ENDP			; ImGuizmo::IsTranslateType
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?IsRotateType@ImGuizmo@@YA_NH@Z
_TEXT	SEGMENT
type$ = 8
?IsRotateType@ImGuizmo@@YA_NH@Z PROC			; ImGuizmo::IsRotateType, COMDAT

; 628  :      return type >= MT_ROTATE_X && type <= MT_ROTATE_SCREEN;

	lea	eax, DWORD PTR [rcx-8]
	cmp	eax, 3
	setbe	al

; 629  :    }

	ret	0
?IsRotateType@ImGuizmo@@YA_NH@Z ENDP			; ImGuizmo::IsRotateType
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?IsScaleType@ImGuizmo@@YA_NH@Z
_TEXT	SEGMENT
type$ = 8
?IsScaleType@ImGuizmo@@YA_NH@Z PROC			; ImGuizmo::IsScaleType, COMDAT

; 633  :      return type >= MT_SCALE_X && type <= MT_SCALE_XYZ;

	lea	eax, DWORD PTR [rcx-12]
	cmp	eax, 3
	setbe	al

; 634  :    }

	ret	0
?IsScaleType@ImGuizmo@@YA_NH@Z ENDP			; ImGuizmo::IsScaleType
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??0Style@ImGuizmo@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Style@ImGuizmo@@QEAA@XZ PROC				; ImGuizmo::Style::Style, COMDAT

; 640  :    {

	lea	rax, QWORD PTR [rcx+32]
	mov	edx, 15
	xor	r9d, r9d
	npad	4
$LL44@Style:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 282  :     constexpr ImVec4()                                        : x(0.0f), y(0.0f), z(0.0f), w(0.0f) { }

	mov	QWORD PTR [rax], r9
	mov	QWORD PTR [rax+8], r9
	lea	rax, QWORD PTR [rax+16]
	sub	rdx, 1
	jne	SHORT $LL44@Style
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 642  :       TranslationLineThickness   = 3.0f;

	mov	DWORD PTR [rcx], 1077936128		; 40400000H

; 643  :       TranslationLineArrowSize   = 6.0f;
; 644  :       RotationLineThickness      = 2.0f;
; 645  :       RotationOuterLineThickness = 3.0f;
; 646  :       ScaleLineThickness         = 3.0f;
; 647  :       ScaleLineCircleSize        = 6.0f;
; 648  :       HatchedAxisLineThickness   = 6.0f;
; 649  :       CenterCircleSize           = 6.0f;
; 650  : 
; 651  :       // initialize default colors
; 652  :       Colors[DIRECTION_X]           = ImVec4(0.666f, 0.000f, 0.000f, 1.000f);
; 653  :       Colors[DIRECTION_Y]           = ImVec4(0.000f, 0.666f, 0.000f, 1.000f);
; 654  :       Colors[DIRECTION_Z]           = ImVec4(0.000f, 0.000f, 0.666f, 1.000f);
; 655  :       Colors[PLANE_X]               = ImVec4(0.666f, 0.000f, 0.000f, 0.380f);
; 656  :       Colors[PLANE_Y]               = ImVec4(0.000f, 0.666f, 0.000f, 0.380f);
; 657  :       Colors[PLANE_Z]               = ImVec4(0.000f, 0.000f, 0.666f, 0.380f);
; 658  :       Colors[SELECTION]             = ImVec4(1.000f, 0.500f, 0.062f, 0.541f);
; 659  :       Colors[INACTIVE]              = ImVec4(0.600f, 0.600f, 0.600f, 0.600f);
; 660  :       Colors[TRANSLATION_LINE]      = ImVec4(0.666f, 0.666f, 0.666f, 0.666f);
; 661  :       Colors[SCALE_LINE]            = ImVec4(0.250f, 0.250f, 0.250f, 1.000f);
; 662  :       Colors[ROTATION_USING_BORDER] = ImVec4(1.000f, 0.500f, 0.062f, 1.000f);
; 663  :       Colors[ROTATION_USING_FILL]   = ImVec4(1.000f, 0.500f, 0.062f, 0.500f);
; 664  :       Colors[HATCHED_AXIS_LINES]    = ImVec4(0.000f, 0.000f, 0.000f, 0.500f);
; 665  :       Colors[TEXT]                  = ImVec4(1.000f, 1.000f, 1.000f, 1.000f);
; 666  :       Colors[TEXT_SHADOW]           = ImVec4(0.000f, 0.000f, 0.000f, 1.000f);
; 667  :    }

	mov	rax, rcx
	mov	DWORD PTR [rcx+4], 1086324736		; 40c00000H
	mov	DWORD PTR [rcx+8], 1073741824		; 40000000H
	mov	DWORD PTR [rcx+12], 1077936128		; 40400000H
	mov	DWORD PTR [rcx+16], 1077936128		; 40400000H
	mov	DWORD PTR [rcx+20], 1086324736		; 40c00000H
	mov	DWORD PTR [rcx+24], 1086324736		; 40c00000H
	mov	DWORD PTR [rcx+28], 1086324736		; 40c00000H
	mov	QWORD PTR [rcx+32], 1059749626		; 3f2a7efaH
	mov	DWORD PTR [rcx+40], r9d
	mov	QWORD PTR [rcx+44], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+52], 1059749626		; 3f2a7efaH
	mov	QWORD PTR [rcx+60], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+68], r9d
	mov	DWORD PTR [rcx+72], 1059749626		; 3f2a7efaH
	mov	DWORD PTR [rcx+76], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+80], 1059749626		; 3f2a7efaH
	mov	DWORD PTR [rcx+88], r9d
	mov	QWORD PTR [rcx+92], 1052938076		; 3ec28f5cH
	mov	QWORD PTR [rcx+100], 1059749626		; 3f2a7efaH
	mov	QWORD PTR [rcx+108], 1052938076		; 3ec28f5cH
	mov	DWORD PTR [rcx+116], r9d
	mov	DWORD PTR [rcx+120], 1059749626		; 3f2a7efaH
	mov	DWORD PTR [rcx+124], 1052938076		; 3ec28f5cH
	mov	DWORD PTR [rcx+128], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+132], 1056964608		; 3f000000H
	mov	DWORD PTR [rcx+136], 1031664566		; 3d7df3b6H
	mov	DWORD PTR [rcx+140], 1057652474		; 3f0a7efaH
	mov	DWORD PTR [rcx+144], 1058642330		; 3f19999aH
	mov	DWORD PTR [rcx+148], 1058642330		; 3f19999aH
	mov	DWORD PTR [rcx+152], 1058642330		; 3f19999aH
	mov	DWORD PTR [rcx+156], 1058642330		; 3f19999aH
	mov	DWORD PTR [rcx+160], 1059749626		; 3f2a7efaH
	mov	DWORD PTR [rcx+164], 1059749626		; 3f2a7efaH
	mov	DWORD PTR [rcx+168], 1059749626		; 3f2a7efaH
	mov	DWORD PTR [rcx+172], 1059749626		; 3f2a7efaH
	mov	DWORD PTR [rcx+176], 1048576000		; 3e800000H
	mov	DWORD PTR [rcx+180], 1048576000		; 3e800000H
	mov	DWORD PTR [rcx+184], 1048576000		; 3e800000H
	mov	DWORD PTR [rcx+188], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+192], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+196], 1056964608		; 3f000000H
	mov	DWORD PTR [rcx+200], 1031664566		; 3d7df3b6H
	mov	DWORD PTR [rcx+204], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+208], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+212], 1056964608		; 3f000000H
	mov	DWORD PTR [rcx+216], 1031664566		; 3d7df3b6H
	mov	QWORD PTR [rcx+220], 1056964608		; 3f000000H
	mov	QWORD PTR [rcx+228], r9
	mov	DWORD PTR [rcx+236], 1056964608		; 3f000000H
	mov	DWORD PTR [rcx+240], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+244], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+248], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+252], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+260], r9
	mov	DWORD PTR [rcx+268], 1065353216		; 3f800000H
	ret	0
??0Style@ImGuizmo@@QEAA@XZ ENDP				; ImGuizmo::Style::Style
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??0Context@ImGuizmo@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??0Context@ImGuizmo@@QEAA@XZ PROC			; ImGuizmo::Context::Context, COMDAT

; 672  :       {

	mov	ecx, 15
	lea	rax, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+48
	xor	edx, edx
	npad	2
$LL52@Context:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 282  :     constexpr ImVec4()                                        : x(0.0f), y(0.0f), z(0.0f), w(0.0f) { }

	mov	QWORD PTR [rax-8], rdx
	mov	QWORD PTR [rax], rdx
	lea	rax, QWORD PTR [rax+16]
	sub	rcx, 1
	jne	SHORT $LL52@Context
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 644  :       RotationLineThickness      = 2.0f;

	movaps	xmm0, XMMWORD PTR __xmm@40c00000404000004040000040000000

; 673  :       }

	lea	rax, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A

; 648  :       HatchedAxisLineThickness   = 6.0f;

	movaps	xmm1, XMMWORD PTR __xmm@000000003f2a7efa40c0000040c00000
	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+16, xmm0

; 649  :       CenterCircleSize           = 6.0f;
; 650  : 
; 651  :       // initialize default colors
; 652  :       Colors[DIRECTION_X]           = ImVec4(0.666f, 0.000f, 0.000f, 1.000f);

	movaps	xmm0, XMMWORD PTR __xmm@3f2a7efa000000003f80000000000000
	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+48, xmm0

; 653  :       Colors[DIRECTION_Y]           = ImVec4(0.000f, 0.666f, 0.000f, 1.000f);
; 654  :       Colors[DIRECTION_Z]           = ImVec4(0.000f, 0.000f, 0.666f, 1.000f);

	movaps	xmm0, XMMWORD PTR __xmm@000000003f2a7efa3f8000003f2a7efa
	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+32, xmm1
	movaps	xmm1, XMMWORD PTR __xmm@00000000000000003f80000000000000
	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+80, xmm0

; 655  :       Colors[PLANE_X]               = ImVec4(0.666f, 0.000f, 0.000f, 0.380f);
; 656  :       Colors[PLANE_Y]               = ImVec4(0.000f, 0.666f, 0.000f, 0.380f);

	movaps	xmm0, XMMWORD PTR __xmm@00000000000000003ec28f5c00000000
	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+64, xmm1
	movaps	xmm1, XMMWORD PTR __xmm@3f2a7efa000000003ec28f5c00000000
	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+112, xmm0

; 657  :       Colors[PLANE_Z]               = ImVec4(0.000f, 0.000f, 0.666f, 0.380f);
; 658  :       Colors[SELECTION]             = ImVec4(1.000f, 0.500f, 0.062f, 0.541f);

	movaps	xmm0, XMMWORD PTR __xmm@3f19999a3f19999a3f0a7efa3d7df3b6
	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+96, xmm1
	movaps	xmm1, XMMWORD PTR __xmm@3f0000003f8000003ec28f5c3f2a7efa
	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+144, xmm0

; 659  :       Colors[INACTIVE]              = ImVec4(0.600f, 0.600f, 0.600f, 0.600f);
; 660  :       Colors[TRANSLATION_LINE]      = ImVec4(0.666f, 0.666f, 0.666f, 0.666f);

	movaps	xmm0, XMMWORD PTR __xmm@3e8000003e8000003f2a7efa3f2a7efa
	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+128, xmm1
	movaps	xmm1, XMMWORD PTR __xmm@3f2a7efa3f2a7efa3f19999a3f19999a
	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+176, xmm0

; 661  :       Colors[SCALE_LINE]            = ImVec4(0.250f, 0.250f, 0.250f, 1.000f);
; 662  :       Colors[ROTATION_USING_BORDER] = ImVec4(1.000f, 0.500f, 0.062f, 1.000f);

	movaps	xmm0, XMMWORD PTR __xmm@3f0000003f8000003f8000003d7df3b6
	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+160, xmm1
	movaps	xmm1, XMMWORD PTR __xmm@3f0000003f8000003f8000003e800000
	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+208, xmm0

; 664  :       Colors[HATCHED_AXIS_LINES]    = ImVec4(0.000f, 0.000f, 0.000f, 0.500f);

	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f8000003f00000000000000
	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+192, xmm1
	movaps	xmm1, XMMWORD PTR __xmm@00000000000000003f0000003d7df3b6
	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+240, xmm0
	xorps	xmm0, xmm0

; 663  :       Colors[ROTATION_USING_FILL]   = ImVec4(1.000f, 0.500f, 0.062f, 0.500f);

	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+224, xmm1

; 665  :       Colors[TEXT]                  = ImVec4(1.000f, 1.000f, 1.000f, 1.000f);

	movaps	xmm1, XMMWORD PTR __xmm@00000000000000003f8000003f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 269  :     constexpr ImVec2()                      : x(0.0f), y(0.0f) { }

	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1040, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 751  :       float mY = 0.f;

	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408, xmm0

; 642  :       TranslationLineThickness   = 3.0f;

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+8, 1077936128 ; 40400000H

; 643  :       TranslationLineArrowSize   = 6.0f;

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+12, 1086324736 ; 40c00000H

; 665  :       Colors[TEXT]                  = ImVec4(1.000f, 1.000f, 1.000f, 1.000f);

	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+256, xmm1

; 666  :       Colors[TEXT_SHADOW]           = ImVec4(0.000f, 0.000f, 0.000f, 1.000f);

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+272, edx
	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+276, 1065353216 ; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 269  :     constexpr ImVec2()                      : x(0.0f), y(0.0f) { }

	mov	QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1056, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 671  :       Context() : mbUsing(false), mbEnable(true), mbUsingBounds(false)

	mov	WORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 256 ; 00000100H

; 674  : 
; 675  :       ImDrawList* mDrawList;
; 676  :       Style mStyle;
; 677  : 
; 678  :       MODE mMode;
; 679  :       matrix_t mViewMat;
; 680  :       matrix_t mProjectionMat;
; 681  :       matrix_t mModel;
; 682  :       matrix_t mModelLocal; // orthonormalized model
; 683  :       matrix_t mModelInverse;
; 684  :       matrix_t mModelSource;
; 685  :       matrix_t mModelSourceInverse;
; 686  :       matrix_t mMVP;
; 687  :       matrix_t mMVPLocal; // MVP with full model matrix whereas mMVP's model matrix might only be translation in case of World space edition
; 688  :       matrix_t mViewProjection;
; 689  : 
; 690  :       vec_t mModelScaleOrigin;
; 691  :       vec_t mCameraEye;
; 692  :       vec_t mCameraRight;
; 693  :       vec_t mCameraDir;
; 694  :       vec_t mCameraUp;
; 695  :       vec_t mRayOrigin;
; 696  :       vec_t mRayVector;
; 697  : 
; 698  :       float  mRadiusSquareCenter;
; 699  :       ImVec2 mScreenSquareCenter;
; 700  :       ImVec2 mScreenSquareMin;
; 701  :       ImVec2 mScreenSquareMax;
; 702  : 
; 703  :       float mScreenFactor;
; 704  :       vec_t mRelativeOrigin;
; 705  : 
; 706  :       bool mbUsing;
; 707  :       bool mbEnable;
; 708  :       bool mbMouseOver;
; 709  :       bool mReversed; // reversed projection matrix
; 710  : 
; 711  :       // translation
; 712  :       vec_t mTranslationPlan;
; 713  :       vec_t mTranslationPlanOrigin;
; 714  :       vec_t mMatrixOrigin;
; 715  :       vec_t mTranslationLastDelta;
; 716  : 
; 717  :       // rotation
; 718  :       vec_t mRotationVectorSource;
; 719  :       float mRotationAngle;
; 720  :       float mRotationAngleOrigin;
; 721  :       //vec_t mWorldToLocalAxis;
; 722  : 
; 723  :       // scale
; 724  :       vec_t mScale;
; 725  :       vec_t mScaleValueOrigin;
; 726  :       vec_t mScaleLast;
; 727  :       float mSaveMousePosx;
; 728  : 
; 729  :       // save axis factor when using gizmo
; 730  :       bool mBelowAxisLimit[3];
; 731  :       bool mBelowPlaneLimit[3];
; 732  :       float mAxisFactor[3];
; 733  : 
; 734  :       float mAxisLimit=0.0025f;

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1248, 992204554 ; 3b23d70aH

; 735  :       float mPlaneLimit=0.02f;

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1252, 1017370378 ; 3ca3d70aH
	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1332, dl

; 736  : 
; 737  :       // bounds stretching
; 738  :       vec_t mBoundsPivot;
; 739  :       vec_t mBoundsAnchor;
; 740  :       vec_t mBoundsPlan;
; 741  :       vec_t mBoundsLocalPivot;
; 742  :       int mBoundsBestAxis;
; 743  :       int mBoundsAxis[2];
; 744  :       bool mbUsingBounds;
; 745  :       matrix_t mBoundsMatrix;
; 746  : 
; 747  :       //
; 748  :       int mCurrentOperation;
; 749  : 
; 750  :       float mX = 0.f;

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404, edx

; 752  :       float mWidth = 0.f;
; 753  :       float mHeight = 0.f;
; 754  :       float mXMax = 0.f;
; 755  :       float mYMax = 0.f;

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1424, edx

; 756  :       float mDisplayRatio = 1.f;

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1428, 1065353216 ; 3f800000H

; 757  : 
; 758  :       bool mIsOrthographic = false;

	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1432, dl

; 759  : 
; 760  :       int mActualID = -1;

	mov	QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436, -1

; 761  :       int mEditingID = -1;
; 762  :       OPERATION mOperation = OPERATION(-1);

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1444, -1

; 763  : 
; 764  :       bool mAllowAxisFlip = true;

	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1448, 1

; 765  :       float mGizmoSizeClipSpace = 0.1f;

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1452, 1036831949 ; 3dcccccdH
	ret	0
??0Context@ImGuizmo@@QEAA@XZ ENDP			; ImGuizmo::Context::Context
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??__EgContext@ImGuizmo@@YAXXZ
text$di	SEGMENT
??__EgContext@ImGuizmo@@YAXXZ PROC			; ImGuizmo::`dynamic initializer for 'gContext'', COMDAT

; 768  :    static Context gContext;

	jmp	??0Context@ImGuizmo@@QEAA@XZ		; ImGuizmo::Context::Context
??__EgContext@ImGuizmo@@YAXXZ ENDP			; ImGuizmo::`dynamic initializer for 'gContext''
text$di	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?GetColorU32@ImGuizmo@@YAIH@Z
_TEXT	SEGMENT
idx$ = 8
?GetColorU32@ImGuizmo@@YAIH@Z PROC			; ImGuizmo::GetColorU32, COMDAT

; 796  :       IM_ASSERT(idx < COLOR::COUNT);
; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	movsxd	rcx, ecx
	lea	rax, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+40
	shl	rcx, 4
	add	rcx, rax
	jmp	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
?GetColorU32@ImGuizmo@@YAIH@Z ENDP			; ImGuizmo::GetColorU32
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?worldToPos@ImGuizmo@@YA?AUImVec2@@AEBUvec_t@1@AEBUmatrix_t@1@U2@2@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
position$ = 48
worldPos$ = 56
mat$ = 64
size$ = 80
?worldToPos@ImGuizmo@@YA?AUImVec2@@AEBUvec_t@1@AEBUmatrix_t@1@U2@2@Z PROC ; ImGuizmo::worldToPos, COMDAT

; 801  :    {

	sub	rsp, 40					; 00000028H

; 802  :       vec_t trans;
; 803  :       trans.TransformPoint(worldPos, mat);
; 804  :       trans *= 0.5f / trans.w;

	movss	xmm4, DWORD PTR __real@3f000000

; 807  :       trans.x *= size.x;
; 808  :       trans.y *= size.y;
; 809  :       trans.x += position.x;
; 810  :       trans.y += position.y;
; 811  :       return ImVec2(trans.x, trans.y);

	mov	rax, rcx
	movaps	XMMWORD PTR [rsp+16], xmm6
	movaps	xmm3, xmm4
	movaps	XMMWORD PTR [rsp], xmm7

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movups	xmm7, XMMWORD PTR [rdx]

; 801  :    {

	mov	QWORD PTR position$[rsp], r9

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movaps	xmm1, xmm7
	movaps	xmm6, xmm7
	mulss	xmm1, DWORD PTR [r8+12]
	movaps	xmm5, xmm7
	shufps	xmm6, xmm7, 85				; 00000055H
	shufps	xmm5, xmm7, 170				; 000000aaH
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [r8+28]
	movaps	xmm2, xmm6
	mulss	xmm2, DWORD PTR [r8+16]
	mulss	xmm6, DWORD PTR [r8+20]
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [r8+44]
	addss	xmm1, xmm0
	movaps	xmm0, xmm7
	mulss	xmm7, DWORD PTR [r8+4]
	mulss	xmm0, DWORD PTR [r8]
	addss	xmm1, DWORD PTR [r8+60]
	addss	xmm7, xmm6

; 812  :    }

	movaps	xmm6, XMMWORD PTR [rsp+16]

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm2, xmm0

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm3, xmm1

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movaps	xmm1, xmm5

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm5, DWORD PTR [r8+36]
	mulss	xmm1, DWORD PTR [r8+32]
	addss	xmm7, xmm5
	addss	xmm2, xmm1
	addss	xmm7, DWORD PTR [r8+52]
	addss	xmm2, DWORD PTR [r8+48]

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm3
	mulss	xmm2, xmm3

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm7, xmm4

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm2, xmm4

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm0, xmm7

; 812  :    }

	movaps	xmm7, XMMWORD PTR [rsp]
	mulss	xmm2, DWORD PTR size$[rsp]
	mulss	xmm0, DWORD PTR size$[rsp+4]
	addss	xmm2, DWORD PTR position$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, DWORD PTR position$[rsp+4]
	movss	DWORD PTR [rcx], xmm2
	movss	DWORD PTR [rcx+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 812  :    }

	add	rsp, 40					; 00000028H
	ret	0
?worldToPos@ImGuizmo@@YA?AUImVec2@@AEBUvec_t@1@AEBUmatrix_t@1@U2@2@Z ENDP ; ImGuizmo::worldToPos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?ComputeCameraRay@ImGuizmo@@YAXAEAUvec_t@1@0UImVec2@@1@Z
_TEXT	SEGMENT
mViewProjInverse$13$ = 32
tv1788 = 36
v$1$ = 40
zNear$1$ = 40
size$ = 40
zFar$1$ = 48
mViewProjInverse$1$ = 52
mox$1$ = 52
position$ = 56
$T1 = 64
mViewProjInverse$ = 128
__$ArrayPad$ = 192
rayOrigin$ = 400
rayDir$ = 408
?ComputeCameraRay@ImGuizmo@@YAXAEAUvec_t@1@0UImVec2@@1@Z PROC ; ImGuizmo::ComputeCameraRay, COMDAT

; 815  :    {

	mov	rax, rsp
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 368				; 00000170H
	movaps	XMMWORD PTR [rax-40], xmm6
	movaps	XMMWORD PTR [rax-56], xmm7
	movaps	XMMWORD PTR [rax-72], xmm8
	movaps	XMMWORD PTR [rax-88], xmm9
	movaps	XMMWORD PTR [rax-104], xmm10
	movaps	XMMWORD PTR [rax-120], xmm11
	movaps	XMMWORD PTR [rax-136], xmm12
	movaps	XMMWORD PTR [rax-152], xmm13
	movaps	XMMWORD PTR [rax-168], xmm14
	movaps	XMMWORD PTR [rax-184], xmm15
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 816  :       ImGuiIO& io = ImGui::GetIO();

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rdi, rdx
	mov	rsi, rcx
	mov	QWORD PTR position$[rsp], r8

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	r8, QWORD PTR $T1[rsp]

; 815  :    {

	mov	QWORD PTR size$[rsp], r9

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+348
	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+284
	call	?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z ; ImGuizmo::FPU_MatrixF_x_MatrixF

; 817  : 
; 818  :       matrix_t mViewProjInverse;
; 819  :       mViewProjInverse.Inverse(gContext.mViewMat * gContext.mProjectionMat);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR mViewProjInverse$[rsp]
	call	?Inverse@matrix_t@ImGuizmo@@QEAAMAEBU12@_N@Z ; ImGuizmo::matrix_t::Inverse

; 820  : 
; 821  :       const float mox = ((io.MousePos.x - position.x) / size.x) * 2.f - 1.f;
; 822  :       const float moy = (1.f - ((io.MousePos.y - position.y) / size.y)) * 2.f - 1.f;

	movss	xmm0, DWORD PTR [rbx+3596]
	subss	xmm0, DWORD PTR position$[rsp+4]
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm6, DWORD PTR [rbx+3592]
	movaps	xmm3, xmm2
	subss	xmm6, DWORD PTR position$[rsp]

; 823  : 
; 824  :       const float zNear = gContext.mReversed ? (1.f - FLT_EPSILON) : 0.f;

	movzx	eax, BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1087
	movss	xmm1, DWORD PTR __real@3f7ffffe
	divss	xmm0, DWORD PTR size$[rsp+4]
	divss	xmm6, DWORD PTR size$[rsp]
	subss	xmm3, xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR zFar$1$[rsp], xmm0
	addss	xmm6, xmm6
	addss	xmm3, xmm3
	subss	xmm6, xmm2
	subss	xmm3, xmm2
	movss	DWORD PTR mox$1$[rsp], xmm6
	test	al, al
	je	SHORT $LN3@ComputeCam
	movaps	xmm5, xmm1
	jmp	SHORT $LN64@ComputeCam
$LN3@ComputeCam:
	xorps	xmm5, xmm5
$LN64@ComputeCam:

; 825  :       const float zFar = gContext.mReversed ? 0.f : (1.f - FLT_EPSILON);

	movss	DWORD PTR zNear$1$[rsp], xmm5
	test	al, al
	jne	SHORT $LN6@ComputeCam
	movss	DWORD PTR zFar$1$[rsp], xmm1
$LN6@ComputeCam:

; 416  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + w * matrix.m[3][3];

	movss	xmm12, DWORD PTR mViewProjInverse$[rsp+12]
	movaps	xmm4, xmm6
	movss	xmm1, DWORD PTR mViewProjInverse$[rsp+28]
	movaps	xmm0, xmm3
	movss	xmm11, DWORD PTR mViewProjInverse$[rsp]
	movaps	xmm15, xmm6
	movss	xmm7, DWORD PTR mViewProjInverse$[rsp+32]
	movaps	xmm14, xmm6
	movss	xmm10, DWORD PTR mViewProjInverse$[rsp+44]
	movaps	xmm13, xmm6
	movss	xmm9, DWORD PTR mViewProjInverse$[rsp+4]
	movaps	xmm8, xmm3
	movss	xmm6, DWORD PTR mViewProjInverse$[rsp+8]
	mulss	xmm0, xmm1
	mulss	xmm4, xmm12
	movss	DWORD PTR mViewProjInverse$13$[rsp], xmm1
	movaps	xmm1, xmm5
	mulss	xmm1, xmm10
	mulss	xmm10, DWORD PTR zFar$1$[rsp]
	addss	xmm4, xmm0
	mulss	xmm15, xmm11
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR mViewProjInverse$[rsp+16]
	addss	xmm4, xmm1
	mulss	xmm14, xmm9
	addss	xmm15, xmm0
	mulss	xmm13, xmm6
	movaps	xmm1, xmm5
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR mViewProjInverse$[rsp+20]
	addss	xmm4, DWORD PTR mViewProjInverse$[rsp+60]
	mulss	xmm1, xmm7
	addss	xmm14, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR mViewProjInverse$[rsp+24]

; 826  : 
; 827  :       rayOrigin.Transform(makeVect(mox, moy, zNear, 1.f), mViewProjInverse);
; 828  :       rayOrigin *= 1.f / rayOrigin.w;

	divss	xmm2, xmm4

; 413  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + w * matrix.m[3][0];

	addss	xmm15, xmm1

; 414  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + w * matrix.m[3][1];

	movaps	xmm1, xmm5
	movss	xmm5, DWORD PTR mViewProjInverse$[rsp+36]

; 415  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + w * matrix.m[3][2];

	addss	xmm13, xmm0
	movss	xmm0, DWORD PTR zNear$1$[rsp]

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm4, xmm2

; 413  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + w * matrix.m[3][0];

	addss	xmm15, DWORD PTR mViewProjInverse$[rsp+48]

; 414  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + w * matrix.m[3][1];

	mulss	xmm1, xmm5

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movss	DWORD PTR tv1788[rsp], xmm4
	movss	DWORD PTR [rsi+12], xmm4

; 829  :       vec_t rayEnd;
; 830  :       rayEnd.Transform(makeVect(mox, moy, zFar, 1.f), mViewProjInverse);
; 831  :       rayEnd *= 1.f / rayEnd.w;

	movss	xmm4, DWORD PTR __real@3f800000

; 414  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + w * matrix.m[3][1];

	addss	xmm14, xmm1

; 415  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + w * matrix.m[3][2];

	movss	xmm1, DWORD PTR mViewProjInverse$[rsp+40]

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm15, xmm2

; 415  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + w * matrix.m[3][2];

	mulss	xmm0, xmm1
	addss	xmm14, DWORD PTR mViewProjInverse$[rsp+52]

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movss	DWORD PTR [rsi], xmm15

; 415  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + w * matrix.m[3][2];

	addss	xmm13, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm14, xmm2

; 415  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + w * matrix.m[3][2];

	addss	xmm13, DWORD PTR mViewProjInverse$[rsp+56]

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movss	DWORD PTR [rsi+4], xmm14
	mulss	xmm13, xmm2

; 415  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + w * matrix.m[3][2];

	movss	xmm2, DWORD PTR mViewProjInverse$13$[rsp]
	mulss	xmm2, xmm8

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movss	DWORD PTR [rsi+8], xmm13

; 415  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + w * matrix.m[3][2];

	movss	DWORD PTR mViewProjInverse$13$[rsp], xmm2

; 416  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + w * matrix.m[3][3];

	movss	xmm2, DWORD PTR mox$1$[rsp]
	movss	xmm8, DWORD PTR mViewProjInverse$13$[rsp]
	mulss	xmm12, xmm2
	mulss	xmm11, xmm2
	addss	xmm8, xmm12
	movss	DWORD PTR mViewProjInverse$13$[rsp], xmm8
	movss	xmm12, DWORD PTR mViewProjInverse$13$[rsp]

; 426  :       *this = s;

	movss	xmm8, DWORD PTR mViewProjInverse$[rsp+16]

; 416  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + w * matrix.m[3][3];

	addss	xmm12, xmm10

; 426  :       *this = s;

	mulss	xmm8, xmm3

; 416  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + w * matrix.m[3][3];

	addss	xmm12, DWORD PTR mViewProjInverse$[rsp+60]
	addss	xmm8, xmm11
	movss	xmm11, DWORD PTR zFar$1$[rsp]
	mulss	xmm7, xmm11

; 829  :       vec_t rayEnd;
; 830  :       rayEnd.Transform(makeVect(mox, moy, zFar, 1.f), mViewProjInverse);
; 831  :       rayEnd *= 1.f / rayEnd.w;

	divss	xmm4, xmm12

; 413  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + w * matrix.m[3][0];

	addss	xmm8, xmm7

; 829  :       vec_t rayEnd;
; 830  :       rayEnd.Transform(makeVect(mox, moy, zFar, 1.f), mViewProjInverse);
; 831  :       rayEnd *= 1.f / rayEnd.w;

	movss	DWORD PTR v$1$[rsp], xmm4

; 413  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + w * matrix.m[3][0];

	movss	DWORD PTR mViewProjInverse$1$[rsp], xmm8
	movss	xmm7, DWORD PTR mViewProjInverse$1$[rsp]
	addss	xmm7, DWORD PTR mViewProjInverse$[rsp+48]

; 414  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + w * matrix.m[3][1];

	mulss	xmm9, xmm2

; 415  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + w * matrix.m[3][2];

	mulss	xmm6, xmm2
	mulss	xmm1, xmm11

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm4

; 414  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + w * matrix.m[3][1];

	mulss	xmm5, xmm11

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	subss	xmm7, xmm15

; 413  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + w * matrix.m[3][0];

	movss	xmm15, DWORD PTR mViewProjInverse$[rsp+20]
	mulss	xmm15, xmm3

; 414  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + w * matrix.m[3][1];

	addss	xmm15, xmm9

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movaps	xmm2, xmm7

; 414  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + w * matrix.m[3][1];

	movss	xmm9, DWORD PTR mViewProjInverse$[rsp+24]
	mulss	xmm9, xmm3

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm2, xmm7

; 415  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + w * matrix.m[3][2];

	addss	xmm9, xmm6
	addss	xmm15, xmm5
	addss	xmm9, xmm1
	addss	xmm15, DWORD PTR mViewProjInverse$[rsp+52]
	addss	xmm9, DWORD PTR mViewProjInverse$[rsp+56]

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm15, xmm4

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	subss	xmm15, xmm14

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm9, xmm4

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	subss	xmm9, xmm13

; 281  :    vec_t Normalized(const vec_t& v) { vec_t res; res = v; res.Normalize(); return res; }

	movaps	xmm0, xmm15
	mulss	xmm0, xmm15

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm9
	addss	xmm2, xmm0
	mulss	xmm1, xmm9
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN59@ComputeCam
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN60@ComputeCam
$LN59@ComputeCam:
	movaps	xmm0, xmm2
	call	sqrtf
	movss	xmm4, DWORD PTR v$1$[rsp]
$LN60@ComputeCam:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000
	movss	xmm8, DWORD PTR __real@3f800000

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm12, xmm4

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm8, xmm0

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	subss	xmm12, DWORD PTR tv1788[rsp]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movaps	xmm1, xmm8

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm0, xmm8

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mulss	xmm1, xmm15

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm0, xmm9
	mulss	xmm12, xmm8
	mulss	xmm8, xmm7

; 832  :       rayDir = Normalized(rayEnd - rayOrigin);

	movss	DWORD PTR [rdi], xmm8
	movss	DWORD PTR [rdi+4], xmm1
	movss	DWORD PTR [rdi+8], xmm0
	movss	DWORD PTR [rdi+12], xmm12

; 833  :    }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+368]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm14, XMMWORD PTR [r11-144]
	movaps	xmm15, XMMWORD PTR [r11-160]
	mov	rsp, r11
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?ComputeCameraRay@ImGuizmo@@YAXAEAUvec_t@1@0UImVec2@@1@Z ENDP ; ImGuizmo::ComputeCameraRay
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?GetSegmentLengthClipSpace@ImGuizmo@@YAMAEBUvec_t@1@0_N@Z
_TEXT	SEGMENT
start$ = 208
end$ = 216
localCoordinates$ = 224
?GetSegmentLengthClipSpace@ImGuizmo@@YAMAEBUvec_t@1@0_N@Z PROC ; ImGuizmo::GetSegmentLengthClipSpace, COMDAT

; 836  :    {

	mov	rax, rsp
	sub	rsp, 200				; 000000c8H

; 837  :       vec_t startOfSegment = start;

	movups	xmm4, XMMWORD PTR [rcx]

; 838  :       const matrix_t& mvp = localCoordinates ? gContext.mMVPLocal : gContext.mMVP;

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+796
	test	r8b, r8b
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movaps	xmm3, xmm4
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	xmm2, xmm4
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12

; 838  :       const matrix_t& mvp = localCoordinates ? gContext.mMVPLocal : gContext.mMVP;

	lea	rax, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+732
	cmovne	rax, rcx

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	shufps	xmm3, xmm4, 85				; 00000055H
	shufps	xmm2, xmm4, 170				; 000000aaH
	movaps	XMMWORD PTR [rsp+64], xmm13
	movaps	XMMWORD PTR [rsp+48], xmm14
	movss	xmm6, DWORD PTR [rax+16]
	movss	xmm11, DWORD PTR [rax]
	movaps	xmm0, xmm6
	movss	xmm12, DWORD PTR [rax+32]
	movaps	xmm7, xmm11

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];
; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm9, DWORD PTR [rax+28]
	movaps	XMMWORD PTR [rsp+32], xmm15

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movaps	xmm1, xmm12

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];
; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm13, DWORD PTR [rax+12]
	movss	xmm14, DWORD PTR [rax+44]
	movaps	xmm10, xmm13
	movss	xmm5, DWORD PTR [rax+20]
	movss	xmm15, DWORD PTR [rax+4]
	mulss	xmm0, xmm3
	movaps	xmm8, xmm15
	mulss	xmm1, xmm2
	mulss	xmm10, xmm4
	mulss	xmm7, xmm4
	mulss	xmm8, xmm4
	movss	xmm4, DWORD PTR [rax+36]
	addss	xmm7, xmm0
	movaps	xmm0, xmm9
	mulss	xmm0, xmm3
	addss	xmm7, xmm1
	movaps	xmm1, xmm14
	addss	xmm10, xmm0
	mulss	xmm1, xmm2
	movaps	xmm0, xmm5
	mulss	xmm0, xmm3
	addss	xmm7, DWORD PTR [rax+48]

; 840  :       if (fabsf(startOfSegment.w) > FLT_EPSILON) // check for axis aligned with camera direction

	movss	xmm3, DWORD PTR __real@3f800000

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm10, xmm1
	addss	xmm8, xmm0
	movaps	xmm1, xmm4
	mulss	xmm1, xmm2
	addss	xmm10, DWORD PTR [rax+60]
	addss	xmm8, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm0, xmm10
	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 840  :       if (fabsf(startOfSegment.w) > FLT_EPSILON) // check for axis aligned with camera direction

	comiss	xmm0, DWORD PTR __real@34000000

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm8, DWORD PTR [rax+52]

; 840  :       if (fabsf(startOfSegment.w) > FLT_EPSILON) // check for axis aligned with camera direction

	jbe	SHORT $LN2@GetSegment

; 841  :       {
; 842  :          startOfSegment *= 1.f / startOfSegment.w;

	movaps	xmm0, xmm3
	divss	xmm0, xmm10

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm0
	mulss	xmm8, xmm0
$LN2@GetSegment:

; 843  :       }
; 844  : 
; 845  :       vec_t endOfSegment = end;

	movups	xmm2, XMMWORD PTR [rdx]

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movaps	xmm1, xmm2

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];
; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm13, xmm2
	shufps	xmm1, xmm2, 85				; 00000055H
	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 170				; 000000aaH
	mulss	xmm9, xmm1
	mulss	xmm14, xmm0
	addss	xmm9, xmm13
	mulss	xmm6, xmm1
	mulss	xmm5, xmm1
	mulss	xmm12, xmm0
	mulss	xmm4, xmm0
	addss	xmm9, xmm14
	mulss	xmm11, xmm2
	mulss	xmm15, xmm2
	addss	xmm9, DWORD PTR [rax+60]
	addss	xmm6, xmm11
	addss	xmm5, xmm15
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm0, xmm9
	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm6, xmm12

; 846  :       endOfSegment.TransformPoint(mvp);
; 847  :       if (fabsf(endOfSegment.w) > FLT_EPSILON) // check for axis aligned with camera direction

	comiss	xmm0, DWORD PTR __real@34000000

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm6, DWORD PTR [rax+48]

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm5, xmm4
	addss	xmm5, DWORD PTR [rax+52]

; 846  :       endOfSegment.TransformPoint(mvp);
; 847  :       if (fabsf(endOfSegment.w) > FLT_EPSILON) // check for axis aligned with camera direction

	jbe	SHORT $LN3@GetSegment

; 848  :       {
; 849  :          endOfSegment *= 1.f / endOfSegment.w;

	movaps	xmm0, xmm3
	divss	xmm0, xmm9

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm6, xmm0
	mulss	xmm5, xmm0
$LN3@GetSegment:

; 850  :       }
; 851  : 
; 852  :       vec_t clipSpaceAxis = endOfSegment - startOfSegment;
; 853  :       if (gContext.mDisplayRatio < 1.0)

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1428

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm6, xmm7

; 850  :       }
; 851  : 
; 852  :       vec_t clipSpaceAxis = endOfSegment - startOfSegment;
; 853  :       if (gContext.mDisplayRatio < 1.0)

	comiss	xmm3, xmm0

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm5, xmm8

; 850  :       }
; 851  : 
; 852  :       vec_t clipSpaceAxis = endOfSegment - startOfSegment;
; 853  :       if (gContext.mDisplayRatio < 1.0)

	jbe	SHORT $LN4@GetSegment

; 854  :          clipSpaceAxis.x *= gContext.mDisplayRatio;

	mulss	xmm6, xmm0
	jmp	SHORT $LN5@GetSegment
$LN4@GetSegment:

; 855  :       else
; 856  :          clipSpaceAxis.y /= gContext.mDisplayRatio;

	divss	xmm5, xmm0
$LN5@GetSegment:

; 857  :       float segmentLengthInClipSpace = sqrtf(clipSpaceAxis.x * clipSpaceAxis.x + clipSpaceAxis.y * clipSpaceAxis.y);

	mulss	xmm5, xmm5
	xorps	xmm0, xmm0
	mulss	xmm6, xmm6
	addss	xmm5, xmm6
	ucomiss	xmm0, xmm5
	ja	SHORT $LN23@GetSegment
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm5
	jmp	SHORT $LN24@GetSegment
$LN23@GetSegment:
	movaps	xmm0, xmm5
	call	sqrtf
$LN24@GetSegment:

; 858  :       return segmentLengthInClipSpace;
; 859  :    }

	movaps	xmm13, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+200]
	movaps	xmm6, XMMWORD PTR [r11-24]
	movaps	xmm7, XMMWORD PTR [r11-40]
	movaps	xmm8, XMMWORD PTR [r11-56]
	movaps	xmm9, XMMWORD PTR [r11-72]
	movaps	xmm10, XMMWORD PTR [r11-88]
	movaps	xmm11, XMMWORD PTR [r11-104]
	movaps	xmm12, XMMWORD PTR [r11-120]
	movaps	xmm14, XMMWORD PTR [rsp+48]
	movaps	xmm15, XMMWORD PTR [rsp+32]
	mov	rsp, r11
	ret	0
?GetSegmentLengthClipSpace@ImGuizmo@@YAMAEBUvec_t@1@0_N@Z ENDP ; ImGuizmo::GetSegmentLengthClipSpace
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?GetParallelogram@ImGuizmo@@YAMAEBUvec_t@1@00@Z
_TEXT	SEGMENT
pts$ = 32
__$ArrayPad$ = 80
ptO$ = 272
ptA$ = 280
ptB$ = 288
?GetParallelogram@ImGuizmo@@YAMAEBUvec_t@1@00@Z PROC	; ImGuizmo::GetParallelogram, COMDAT

; 862  :    {

	mov	rax, rsp
	sub	rsp, 264				; 00000108H
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rax-136], xmm13
	movaps	XMMWORD PTR [rsp+112], xmm14
	movaps	XMMWORD PTR [rsp+96], xmm15
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 863  :       vec_t pts[] = { ptO, ptA, ptB };

	movups	xmm0, XMMWORD PTR [rcx]
	lea	rax, QWORD PTR pts$[rsp+8]
	mov	ecx, 3
	movups	xmm1, XMMWORD PTR [rdx]
	movss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+792
	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+788
	movss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+784
	movss	xmm14, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+780
	movss	xmm15, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+776
	movss	xmm9, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	movss	xmm10, DWORD PTR __real@34000000
	movss	xmm8, DWORD PTR __real@3f800000
	movups	XMMWORD PTR pts$[rsp], xmm0
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR pts$[rsp+16], xmm1
	movups	XMMWORD PTR pts$[rsp+32], xmm0
	npad	7
$LL4@GetParalle:

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm7, DWORD PTR [rax-8]
	movss	xmm4, DWORD PTR [rax-4]
	movaps	xmm6, xmm7
	movss	xmm5, DWORD PTR [rax]

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movaps	xmm3, xmm7
	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+732

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	movaps	xmm2, xmm7

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+744
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+748
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+764
	mulss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+736
	addss	xmm6, xmm0
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+740
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+752
	addss	xmm6, xmm1
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+768
	addss	xmm3, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+756
	mulss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+760
	addss	xmm6, xmm14
	addss	xmm2, xmm0
	addss	xmm3, xmm1
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+772
	addss	xmm7, xmm4
	mulss	xmm5, xmm15
	addss	xmm2, xmm1

; 438  : 
; 439  :       x = out.x;

	movss	DWORD PTR [rax-8], xmm6
	addss	xmm3, xmm13
	addss	xmm7, xmm5
	addss	xmm2, xmm12

; 440  :       y = out.y;

	movss	DWORD PTR [rax-4], xmm3
	addss	xmm7, xmm11

; 441  :       z = out.z;

	movss	DWORD PTR [rax], xmm2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 442  :       w = out.w;

	movss	DWORD PTR [rax+4], xmm7
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm0, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 867  :          if (fabsf(pts[i].w) > FLT_EPSILON) // check for axis aligned with camera direction

	comiss	xmm0, xmm10
	jbe	SHORT $LN2@GetParalle

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movups	xmm0, XMMWORD PTR [rax-8]

; 868  :          {
; 869  :             pts[i] *= 1.f / pts[i].w;

	movaps	xmm1, xmm8
	divss	xmm1, xmm7
	shufps	xmm1, xmm1, 0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulps	xmm1, xmm0
	movups	XMMWORD PTR [rax-8], xmm1
$LN2@GetParalle:

; 864  :       for (unsigned int i = 0; i < 3; i++)

	add	rax, 16
	sub	rcx, 1
	jne	$LL4@GetParalle

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm7, DWORD PTR pts$[rsp+20]
	xorps	xmm15, xmm15
	movss	xmm13, DWORD PTR pts$[rsp+4]
	xorps	xmm0, xmm0
	movss	xmm14, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1428
	subss	xmm7, xmm13
	movss	xmm10, DWORD PTR pts$[rsp+16]
	movss	xmm12, DWORD PTR pts$[rsp]
	subss	xmm10, xmm12
	divss	xmm7, xmm14

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm11, xmm10

; 870  :          }
; 871  :       }
; 872  :       vec_t segA = pts[1] - pts[0];
; 873  :       vec_t segB = pts[2] - pts[0];
; 874  :       segA.y /= gContext.mDisplayRatio;
; 875  :       segB.y /= gContext.mDisplayRatio;

	movaps	xmm9, xmm7

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm11, xmm10

; 870  :          }
; 871  :       }
; 872  :       vec_t segA = pts[1] - pts[0];
; 873  :       vec_t segB = pts[2] - pts[0];
; 874  :       segA.y /= gContext.mDisplayRatio;
; 875  :       segB.y /= gContext.mDisplayRatio;

	xorps	xmm9, DWORD PTR __xmm@80000000800000008000000080000000

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm9
	mulss	xmm1, xmm9
	addss	xmm1, xmm11
	addss	xmm1, xmm15
	ucomiss	xmm0, xmm1
	ja	SHORT $LN57@GetParalle
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	jmp	SHORT $LN58@GetParalle
$LN57@GetParalle:
	movaps	xmm0, xmm1
	call	sqrtf
$LN58@GetParalle:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm6, DWORD PTR pts$[rsp+36]
	movss	xmm1, DWORD PTR pts$[rsp+32]
	subss	xmm6, xmm13
	subss	xmm1, xmm12

; 879  :       float surface = sqrtf(segA.x * segA.x + segA.y * segA.y) * fabsf(dt);

	mulss	xmm7, xmm7

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm8, xmm0

; 870  :          }
; 871  :       }
; 872  :       vec_t segA = pts[1] - pts[0];
; 873  :       vec_t segB = pts[2] - pts[0];
; 874  :       segA.y /= gContext.mDisplayRatio;
; 875  :       segB.y /= gContext.mDisplayRatio;

	divss	xmm6, xmm14

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm0, xmm8
	mulss	xmm9, xmm8
	mulss	xmm0, xmm10

; 879  :       float surface = sqrtf(segA.x * segA.x + segA.y * segA.y) * fabsf(dt);

	addss	xmm7, xmm11

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm1, xmm9

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm6, xmm0

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm0, DWORD PTR pts$[rsp+40]
	subss	xmm0, DWORD PTR pts$[rsp+8]

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	addss	xmm6, xmm1

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm8, xmm15

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm0, xmm8
	addss	xmm6, xmm0
	xorps	xmm0, xmm0

; 879  :       float surface = sqrtf(segA.x * segA.x + segA.y * segA.y) * fabsf(dt);

	ucomiss	xmm0, xmm7
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm6, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 879  :       float surface = sqrtf(segA.x * segA.x + segA.y * segA.y) * fabsf(dt);

	ja	SHORT $LN55@GetParalle
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm7
	jmp	SHORT $LN56@GetParalle
$LN55@GetParalle:
	movaps	xmm0, xmm7
	call	sqrtf
$LN56@GetParalle:
	mulss	xmm6, xmm0

; 880  :       return surface;

	movaps	xmm0, xmm6

; 881  :    }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+264]
	movaps	xmm6, XMMWORD PTR [r11-24]
	movaps	xmm7, XMMWORD PTR [r11-40]
	movaps	xmm8, XMMWORD PTR [r11-56]
	movaps	xmm9, XMMWORD PTR [r11-72]
	movaps	xmm10, XMMWORD PTR [r11-88]
	movaps	xmm11, XMMWORD PTR [r11-104]
	movaps	xmm12, XMMWORD PTR [r11-120]
	movaps	xmm13, XMMWORD PTR [r11-136]
	movaps	xmm14, XMMWORD PTR [rsp+112]
	movaps	xmm15, XMMWORD PTR [rsp+96]
	mov	rsp, r11
	ret	0
?GetParallelogram@ImGuizmo@@YAMAEBUvec_t@1@00@Z ENDP	; ImGuizmo::GetParallelogram
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?PointOnSegment@ImGuizmo@@YA?AUvec_t@1@AEBU21@00@Z
_TEXT	SEGMENT
__$ReturnAddress$ = 96
point$ = 104
vertPos1$ = 112
vertPos2$ = 120
?PointOnSegment@ImGuizmo@@YA?AUvec_t@1@AEBU21@00@Z PROC	; ImGuizmo::PointOnSegment, COMDAT

; 884  :    {

$LN50:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 80					; 00000050H
	movaps	XMMWORD PTR [rsp+64], xmm6
	mov	rsi, r9

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm6, DWORD PTR [r9+4]

; 884  :    {

	mov	rdi, r8

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm6, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp+48], xmm7

; 884  :    {

	mov	rbp, rdx

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm7, DWORD PTR [r9+8]

; 884  :    {

	mov	rbx, rcx

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm7, DWORD PTR [r8+8]
	movaps	XMMWORD PTR [rsp+32], xmm8
	movss	xmm8, DWORD PTR [r9]

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm2, xmm6

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm8, DWORD PTR [r8]

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm2, xmm6

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movaps	xmm1, xmm7
	mulss	xmm1, xmm7

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm8
	mulss	xmm0, xmm8
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN43@PointOnSeg
	xorps	xmm5, xmm5
	sqrtss	xmm5, xmm2
	jmp	SHORT $LN44@PointOnSeg
$LN43@PointOnSeg:
	movaps	xmm0, xmm2
	call	sqrtf
	movaps	xmm5, xmm0
$LN44@PointOnSeg:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movss	xmm2, DWORD PTR __real@3f800000
	movaps	xmm1, xmm5
	maxss	xmm1, DWORD PTR __real@34000000

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm0, DWORD PTR [rbp]
	subss	xmm0, DWORD PTR [rdi]
	movss	xmm3, DWORD PTR [rbp+4]
	subss	xmm3, DWORD PTR [rdi+4]
	movss	xmm4, DWORD PTR [rsi+12]
	subss	xmm4, DWORD PTR [rdi+12]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm2, xmm1

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm1, DWORD PTR [rbp+8]
	subss	xmm1, DWORD PTR [rdi+8]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mulss	xmm8, xmm2

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm6, xmm2

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm0, xmm8

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	mulss	xmm3, xmm6

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm2

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	addss	xmm3, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm4, xmm2

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm1, xmm7
	xorps	xmm0, xmm0
	addss	xmm3, xmm1

; 885  :       vec_t c = point - vertPos1;
; 886  :       vec_t V;
; 887  : 
; 888  :       V.Normalize(vertPos2 - vertPos1);
; 889  :       float d = (vertPos2 - vertPos1).Length();
; 890  :       float t = V.Dot3(c);
; 891  : 
; 892  :       if (t < 0.f)

	comiss	xmm0, xmm3
	jbe	SHORT $LN2@PointOnSeg

; 893  :       {
; 894  :          return vertPos1;

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rbx], xmm0
	jmp	SHORT $LN48@PointOnSeg
$LN2@PointOnSeg:

; 895  :       }
; 896  : 
; 897  :       if (t > d)

	comiss	xmm3, xmm5
	jbe	SHORT $LN3@PointOnSeg

; 898  :       {
; 899  :          return vertPos2;

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rbx], xmm0
	jmp	SHORT $LN48@PointOnSeg
$LN3@PointOnSeg:

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm8, xmm3

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm6, xmm3

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm8, DWORD PTR [rdi]

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm7, xmm3

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm6, DWORD PTR [rdi+4]

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm4, xmm3

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm7, DWORD PTR [rdi+8]
	addss	xmm4, DWORD PTR [rdi+12]

; 900  :       }
; 901  : 
; 902  :       return vertPos1 + V * t;

	movss	DWORD PTR [rbx], xmm8
	movss	DWORD PTR [rbx+4], xmm6
	movss	DWORD PTR [rbx+8], xmm7
	movss	DWORD PTR [rbx+12], xmm4
$LN48@PointOnSeg:

; 903  :    }

	mov	rbp, QWORD PTR [rsp+104]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+112]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?PointOnSegment@ImGuizmo@@YA?AUvec_t@1@AEBU21@00@Z ENDP	; ImGuizmo::PointOnSegment
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?IntersectRayPlane@ImGuizmo@@YAMAEBUvec_t@1@00@Z
_TEXT	SEGMENT
rOrigin$ = 32
rVector$ = 40
plan$ = 48
?IntersectRayPlane@ImGuizmo@@YAMAEBUvec_t@1@00@Z PROC	; ImGuizmo::IntersectRayPlane, COMDAT

; 906  :    {

	sub	rsp, 24

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movss	xmm3, DWORD PTR [r8+4]
	movss	xmm5, DWORD PTR [r8]
	movaps	xmm4, xmm3
	mulss	xmm4, DWORD PTR [rdx+4]
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp], xmm6
	movss	xmm6, DWORD PTR [r8+8]
	addss	xmm4, xmm0
	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR [rdx+8]

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm0, DWORD PTR __real@34000000

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	addss	xmm4, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm2, xmm4
	andps	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	comiss	xmm0, xmm2
	jbe	SHORT $LN2@IntersectR

; 911  :       {
; 912  :          return -1.0f;

	movss	xmm0, DWORD PTR __real@bf800000

; 913  :       }
; 914  : 
; 915  :       return -(numer / denom);
; 916  :    }

	movaps	xmm6, XMMWORD PTR [rsp]
	add	rsp, 24
	ret	0
$LN2@IntersectR:

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm3, DWORD PTR [rcx+4]
	mulss	xmm6, DWORD PTR [rcx+8]
	mulss	xmm5, DWORD PTR [rcx]
	addss	xmm3, xmm5
	addss	xmm3, xmm6

; 913  :       }
; 914  : 
; 915  :       return -(numer / denom);
; 916  :    }

	movaps	xmm6, XMMWORD PTR [rsp]
	subss	xmm3, DWORD PTR [r8+12]
	divss	xmm3, xmm4
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	movaps	xmm0, xmm3
	add	rsp, 24
	ret	0
?IntersectRayPlane@ImGuizmo@@YAMAEBUvec_t@1@00@Z ENDP	; ImGuizmo::IntersectRayPlane
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?IsInContextRect@ImGuizmo@@YA_NUImVec2@@@Z
_TEXT	SEGMENT
p$ = 16
?IsInContextRect@ImGuizmo@@YA_NUImVec2@@@Z PROC		; ImGuizmo::IsInContextRect, COMDAT

; 924  :    {

	mov	QWORD PTR p$[rsp], rcx

; 191  :    template <typename T> bool IsWithin(T x, T y, T z) { return (x >= y) && (x <= z); }

	movss	xmm1, DWORD PTR p$[rsp]
	comiss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404
	jb	SHORT $LN3@IsInContex
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1420
	comiss	xmm0, xmm1
	jb	SHORT $LN3@IsInContex
	movss	xmm1, DWORD PTR p$[rsp+4]
	comiss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
	jb	SHORT $LN3@IsInContex
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1424
	comiss	xmm0, xmm1
	jb	SHORT $LN3@IsInContex

; 925  :       return IsWithin(p.x, gContext.mX, gContext.mXMax) && IsWithin(p.y, gContext.mY, gContext.mYMax);

	mov	al, 1

; 926  :    }

	ret	0
$LN3@IsInContex:

; 925  :       return IsWithin(p.x, gContext.mX, gContext.mXMax) && IsWithin(p.y, gContext.mY, gContext.mYMax);

	xor	al, al

; 926  :    }

	ret	0
?IsInContextRect@ImGuizmo@@YA_NUImVec2@@@Z ENDP		; ImGuizmo::IsInContextRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?IsHoveringWindow@ImGuizmo@@YA_NXZ
_TEXT	SEGMENT
?IsHoveringWindow@ImGuizmo@@YA_NXZ PROC			; ImGuizmo::IsHoveringWindow, COMDAT

; 929  :    {

	sub	rsp, 40					; 00000028H

; 930  :       ImGuiContext& g = *ImGui::GetCurrentContext();
; 931  :       ImGuiWindow* window = ImGui::FindWindowByName(gContext.mDrawList->_OwnerName);

	mov	rcx, QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A
	mov	rcx, QWORD PTR [rcx+64]
	call	?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z ; ImGui::FindWindowByName

; 932  :       if (g.HoveredWindow == window)   // Mouse hovering drawlist window

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rdx, QWORD PTR [rcx+16416]
	cmp	rdx, rax
	je	SHORT $LN7@IsHovering

; 933  :          return true;
; 934  :       if (g.HoveredWindow != NULL)     // Any other window is hovered

	test	rdx, rdx
	jne	SHORT $LN4@IsHovering

; 935  :          return false;
; 936  :       if (ImGui::IsMouseHoveringRect(window->InnerRect.Min, window->InnerRect.Max, false))   // Hovering drawlist window rect, while no other window is hovered (for _NoInputs windows)

	lea	rdx, QWORD PTR [rax+568]
	xor	r8d, r8d
	lea	rcx, QWORD PTR [rax+560]
	call	?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	test	al, al
	setne	al

; 939  :    }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@IsHovering:

; 938  :       return false;

	xor	al, al

; 939  :    }

	add	rsp, 40					; 00000028H
	ret	0
$LN7@IsHovering:

; 937  :          return true;

	mov	al, 1

; 939  :    }

	add	rsp, 40					; 00000028H
	ret	0
?IsHoveringWindow@ImGuizmo@@YA_NXZ ENDP			; ImGuizmo::IsHoveringWindow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?SetRect@ImGuizmo@@YAXMMMM@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
width$ = 24
height$ = 32
?SetRect@ImGuizmo@@YAXMMMM@Z PROC			; ImGuizmo::SetRect, COMDAT

; 943  :       gContext.mX = x;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404, xmm0

; 944  :       gContext.mY = y;
; 945  :       gContext.mWidth = width;
; 946  :       gContext.mHeight = height;

	addss	xmm0, xmm2
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412, xmm2

; 947  :       gContext.mXMax = gContext.mX + gContext.mWidth;
; 948  :       gContext.mYMax = gContext.mY + gContext.mXMax;
; 949  :       gContext.mDisplayRatio = width / height;

	divss	xmm2, xmm3
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1420, xmm0
	addss	xmm0, xmm1
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1428, xmm2
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408, xmm1
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416, xmm3
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1424, xmm0

; 950  :    }

	ret	0
?SetRect@ImGuizmo@@YAXMMMM@Z ENDP			; ImGuizmo::SetRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?SetDrawlist@ImGuizmo@@YAXPEAUImDrawList@@@Z
_TEXT	SEGMENT
drawlist$dead$ = 8
?SetDrawlist@ImGuizmo@@YAXPEAUImDrawList@@@Z PROC	; ImGuizmo::SetDrawlist, COMDAT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 959  :       gContext.mDrawList = drawlist ? drawlist : ImGui::GetWindowDrawList();

	mov	rax, QWORD PTR [rcx+16408]
	mov	rcx, QWORD PTR [rax+728]
	mov	QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A, rcx

; 960  :    }

	ret	0
?SetDrawlist@ImGuizmo@@YAXPEAUImDrawList@@@Z ENDP	; ImGuizmo::SetDrawlist
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?BeginFrame@ImGuizmo@@YAXXZ
_TEXT	SEGMENT
?BeginFrame@ImGuizmo@@YAXXZ PROC			; ImGuizmo::BeginFrame, COMDAT

; 968  :    {

$LN38:
	push	rbx
	sub	rsp, 32					; 00000020H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 980  :       ImGui::PushStyleColor(ImGuiCol_WindowBg, 0);

	mov	ebx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rax, QWORD PTR [r8+18984]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8126 :     g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;

	mov	edx, DWORD PTR [r8+18680]
	or	edx, 2

; 13999:     return g.Viewports[0];

	mov	rcx, QWORD PTR [rax]

; 8126 :     g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;

	mov	DWORD PTR [r8+18680], edx

; 8115 :     g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasPos;

	or	edx, 1

; 8127 :     g.NextWindowData.SizeVal = size;

	movsd	xmm0, QWORD PTR [rcx+16]
	movsd	QWORD PTR [r8+18716], xmm0

; 8128 :     g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;

	mov	DWORD PTR [r8+18688], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rax, QWORD PTR [r8+18984]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 973  :       ImGui::SetNextWindowPos(ImGui::GetMainViewport()->Pos);

	mov	rcx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8117 :     g.NextWindowData.PosPivotVal = pivot;

	xor	eax, eax
	mov	DWORD PTR [r8+18680], edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 980  :       ImGui::PushStyleColor(ImGuiCol_WindowBg, 0);

	xor	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8116 :     g.NextWindowData.PosVal = pos;

	movsd	xmm0, QWORD PTR [rcx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 980  :       ImGui::PushStyleColor(ImGuiCol_WindowBg, 0);

	mov	ecx, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8116 :     g.NextWindowData.PosVal = pos;

	movsd	QWORD PTR [r8+18700], xmm0

; 8117 :     g.NextWindowData.PosPivotVal = pivot;

	mov	QWORD PTR [r8+18708], rax

; 8118 :     g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;

	mov	DWORD PTR [r8+18684], 1

; 8119 :     g.NextWindowData.PosUndock = true;

	mov	BYTE PTR [r8+18740], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 980  :       ImGui::PushStyleColor(ImGuiCol_WindowBg, 0);

	call	?PushStyleColor@ImGui@@YAXHI@Z		; ImGui::PushStyleColor

; 981  :       ImGui::PushStyleColor(ImGuiCol_Border, 0);

	xor	edx, edx
	lea	ecx, QWORD PTR [rbx+3]
	call	?PushStyleColor@ImGui@@YAXHI@Z		; ImGui::PushStyleColor
	xorps	xmm1, xmm1

; 982  :       ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);

	lea	ecx, QWORD PTR [rbx+1]
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 983  : 
; 984  :       ImGui::Begin("gizmo", NULL, flags);

	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_05GJAGBLGB@gizmo@
	mov	r8d, 799499				; 000c330bH
	call	?Begin@ImGui@@YA_NPEBDPEA_NH@Z		; ImGui::Begin
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rdx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rdx+16408]
	mov	BYTE PTR [rax+237], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 985  :       gContext.mDrawList = ImGui::GetWindowDrawList();

	mov	rax, QWORD PTR [rdx+16408]
	mov	rdx, QWORD PTR [rax+728]
	mov	QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A, rdx

; 986  :       ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 987  :       ImGui::PopStyleVar();

	lea	ecx, QWORD PTR [rbx-1]
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3143 :     ImGuiContext& g = *GImGui;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3144 :     if (g.ColorStack.Size < count)

	mov	eax, DWORD PTR [r8+18824]
	cmp	eax, ebx
	jge	SHORT $LL22@BeginFrame

; 3145 :     {
; 3146 :         IM_ASSERT_USER_ERROR(g.ColorStack.Size > count, "Calling PopStyleColor() too many times: stack underflow.");
; 3147 :         count = g.ColorStack.Size;

	mov	ebx, eax

; 3149 :     while (count > 0)

	test	eax, eax
	jle	SHORT $LN23@BeginFrame
	npad	11
$LL22@BeginFrame:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	rcx, QWORD PTR [r8+18832]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3154 :         count--;

	dec	ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	cdqe
	lea	rdx, QWORD PTR [rax+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3152 :         g.Style.Colors[backup.Col] = backup.BackupValue;

	movsxd	rax, DWORD PTR [rcx+rdx*4-20]
	movups	xmm0, XMMWORD PTR [rcx+rdx*4-16]
	add	rax, rax
	movups	XMMWORD PTR [r8+rax*8+14776], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [r8+18824]
	mov	eax, DWORD PTR [r8+18824]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3149 :     while (count > 0)

	test	ebx, ebx
	jg	SHORT $LL22@BeginFrame
$LN23@BeginFrame:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 989  :    }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?BeginFrame@ImGuizmo@@YAXXZ ENDP			; ImGuizmo::BeginFrame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?IsUsing@ImGuizmo@@YA_NXZ
_TEXT	SEGMENT
?IsUsing@ImGuizmo@@YA_NXZ PROC				; ImGuizmo::IsUsing, COMDAT

; 993  :       return (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID)) || gContext.mbUsingBounds;

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	je	SHORT $LN4@IsUsing
	mov	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	cmp	eax, -1
	je	SHORT $LN3@IsUsing
	cmp	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440
	je	SHORT $LN3@IsUsing
$LN4@IsUsing:
	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1332, 0
	jne	SHORT $LN3@IsUsing
	xor	al, al

; 994  :    }

	ret	0
$LN3@IsUsing:

; 993  :       return (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID)) || gContext.mbUsingBounds;

	mov	al, 1

; 994  :    }

	ret	0
?IsUsing@ImGuizmo@@YA_NXZ ENDP				; ImGuizmo::IsUsing
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?IsUsingAny@ImGuizmo@@YA_NXZ
_TEXT	SEGMENT
?IsUsingAny@ImGuizmo@@YA_NXZ PROC			; ImGuizmo::IsUsingAny, COMDAT

; 998  :       return gContext.mbUsing || gContext.mbUsingBounds;

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	jne	SHORT $LN3@IsUsingAny
	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1332, 0
	jne	SHORT $LN3@IsUsingAny
	xor	al, al

; 999  :    }

	ret	0
$LN3@IsUsingAny:

; 998  :       return gContext.mbUsing || gContext.mbUsingBounds;

	mov	al, 1

; 999  :    }

	ret	0
?IsUsingAny@ImGuizmo@@YA_NXZ ENDP			; ImGuizmo::IsUsingAny
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?IsOver@ImGuizmo@@YA_NXZ
_TEXT	SEGMENT
?IsOver@ImGuizmo@@YA_NXZ PROC				; ImGuizmo::IsOver, COMDAT

; 1002 :    {

$LN40:
	push	rbx
	sub	rsp, 32					; 00000020H

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	mov	ebx, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1444
	test	bl, 7

; 1003 :       return (Intersects(gContext.mOperation, TRANSLATE) && GetMoveType(gContext.mOperation, NULL) != MT_NONE) ||

	je	SHORT $LN3@IsOver
	xor	edx, edx
	mov	ecx, ebx
	call	?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z ; ImGuizmo::GetMoveType
	test	eax, eax
	jne	SHORT $LN5@IsOver
	mov	ebx, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1444
$LN3@IsOver:

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	bl, 120					; 00000078H

; 1003 :       return (Intersects(gContext.mOperation, TRANSLATE) && GetMoveType(gContext.mOperation, NULL) != MT_NONE) ||

	je	SHORT $LN4@IsOver
	mov	ecx, ebx
	call	?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z ; ImGuizmo::GetRotateType
	test	eax, eax
	jne	SHORT $LN5@IsOver
$LN4@IsOver:

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	ebx, 896				; 00000380H

; 1003 :       return (Intersects(gContext.mOperation, TRANSLATE) && GetMoveType(gContext.mOperation, NULL) != MT_NONE) ||

	je	SHORT $LN6@IsOver
	mov	ecx, ebx
	call	?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z ; ImGuizmo::GetScaleType
	test	eax, eax
	jne	SHORT $LN5@IsOver
$LN6@IsOver:

; 993  :       return (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID)) || gContext.mbUsingBounds;

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	je	SHORT $LN29@IsOver
	mov	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	cmp	eax, -1
	je	SHORT $LN5@IsOver
	cmp	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440
	je	SHORT $LN5@IsOver
$LN29@IsOver:
	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1332, 0
	jne	SHORT $LN5@IsOver

; 1003 :       return (Intersects(gContext.mOperation, TRANSLATE) && GetMoveType(gContext.mOperation, NULL) != MT_NONE) ||

	xor	al, al

; 1004 :          (Intersects(gContext.mOperation, ROTATE) && GetRotateType(gContext.mOperation) != MT_NONE) ||
; 1005 :          (Intersects(gContext.mOperation, SCALE) && GetScaleType(gContext.mOperation) != MT_NONE) || IsUsing();
; 1006 :    }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN5@IsOver:

; 1003 :       return (Intersects(gContext.mOperation, TRANSLATE) && GetMoveType(gContext.mOperation, NULL) != MT_NONE) ||

	mov	al, 1

; 1004 :          (Intersects(gContext.mOperation, ROTATE) && GetRotateType(gContext.mOperation) != MT_NONE) ||
; 1005 :          (Intersects(gContext.mOperation, SCALE) && GetScaleType(gContext.mOperation) != MT_NONE) || IsUsing();
; 1006 :    }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?IsOver@ImGuizmo@@YA_NXZ ENDP				; ImGuizmo::IsOver
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Enable@ImGuizmo@@YAX_N@Z
_TEXT	SEGMENT
enable$ = 8
?Enable@ImGuizmo@@YAX_N@Z PROC				; ImGuizmo::Enable, COMDAT

; 1031 :       gContext.mbEnable = enable;

	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1085, cl

; 1032 :       if (!enable)

	test	cl, cl
	jne	SHORT $LN2@Enable

; 1033 :       {
; 1034 :          gContext.mbUsing = false;

	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, cl

; 1035 :          gContext.mbUsingBounds = false;

	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1332, cl
$LN2@Enable:

; 1036 :       }
; 1037 :    }

	ret	0
?Enable@ImGuizmo@@YAX_N@Z ENDP				; ImGuizmo::Enable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?ComputeContext@ImGuizmo@@YAXPEBM0PEAMW4MODE@1@@Z
_TEXT	SEGMENT
rightViewInverse$ = 32
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 112
viewInverse$ = 128
__$ArrayPad$ = 192
view$ = 320
projection$ = 328
matrix$dead$ = 336
mode$ = 344
?ComputeContext@ImGuizmo@@YAXPEBM0PEAMW4MODE@1@@Z PROC	; ImGuizmo::ComputeContext, COMDAT

; 1040 :    {

	mov	rax, rsp
	mov	QWORD PTR [rax+24], rbx
	push	rbp
	lea	rbp, QWORD PTR [rax-56]
	sub	rsp, 304				; 00000130H
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	XMMWORD PTR [rax-72], xmm11
	movaps	XMMWORD PTR [rax-88], xmm12
	movaps	XMMWORD PTR [rax-104], xmm13
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	ebx, r9d

; 1041 :       gContext.mMode = mode;

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+280, ebx

; 1042 :       gContext.mViewMat = *(matrix_t*)view;

	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+284, xmm0
	movups	xmm1, XMMWORD PTR [rcx+16]
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+300, xmm1
	movups	xmm0, XMMWORD PTR [rcx+32]
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+316, xmm0
	movups	xmm1, XMMWORD PTR [rcx+48]

; 931  :       ImGuiWindow* window = ImGui::FindWindowByName(gContext.mDrawList->_OwnerName);

	mov	rcx, QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A

; 1042 :       gContext.mViewMat = *(matrix_t*)view;

	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+332, xmm1

; 1043 :       gContext.mProjectionMat = *(matrix_t*)projection;

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+348, xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+364, xmm1
	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+380, xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+396, xmm1

; 931  :       ImGuiWindow* window = ImGui::FindWindowByName(gContext.mDrawList->_OwnerName);

	mov	rcx, QWORD PTR [rcx+64]
	call	?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z ; ImGui::FindWindowByName

; 932  :       if (g.HoveredWindow == window)   // Mouse hovering drawlist window

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rdx, QWORD PTR [rcx+16416]
	cmp	rdx, rax
	jne	SHORT $LN6@ComputeCon

; 933  :          return true;

	mov	al, 1
	jmp	SHORT $LN8@ComputeCon
$LN6@ComputeCon:

; 934  :       if (g.HoveredWindow != NULL)     // Any other window is hovered

	test	rdx, rdx
	je	SHORT $LN7@ComputeCon

; 935  :          return false;

	xor	al, al
	jmp	SHORT $LN8@ComputeCon
$LN7@ComputeCon:

; 936  :       if (ImGui::IsMouseHoveringRect(window->InnerRect.Min, window->InnerRect.Max, false))   // Hovering drawlist window rect, while no other window is hovered (for _NoInputs windows)

	lea	rdx, QWORD PTR [rax+568]
	xor	r8d, r8d
	lea	rcx, QWORD PTR [rax+560]
	call	?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	test	al, al
	setne	al
$LN8@ComputeCon:

; 1044 :       gContext.mbMouseOver = IsHoveringWindow();
; 1045 : 
; 1046 :       gContext.mModelLocal = *(matrix_t*)matrix;

	movaps	xmm0, XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA

; 1047 :       gContext.mModelLocal.OrthoNormalize();

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+476
	movaps	xmm1, XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+16
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+476, xmm0
	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1086, al
	movaps	xmm0, XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+32
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+492, xmm1
	movaps	xmm1, XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+48
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+508, xmm0
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+524, xmm1
	call	?OrthoNormalize@matrix_t@ImGuizmo@@QEAAXXZ ; ImGuizmo::matrix_t::OrthoNormalize

; 1048 : 
; 1049 :       if (mode == LOCAL)

	movss	xmm13, DWORD PTR __real@3f800000
	xorps	xmm12, xmm12
	test	ebx, ebx
	jne	SHORT $LN2@ComputeCon

; 1050 :       {
; 1051 :          gContext.mModel = gContext.mModelLocal;

	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+476
	movups	xmm1, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+492
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+412, xmm0
	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+508
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+428, xmm1
	movups	xmm1, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+524
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+444, xmm0
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460, xmm1

; 1052 :       }

	jmp	SHORT $LN3@ComputeCon
$LN2@ComputeCon:

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movaps	xmm1, XMMWORD PTR __xmm@0000000000000000000000003f800000
	xorps	xmm0, xmm0
	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+416, xmm0
	movss	xmm0, DWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+48
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460, xmm0
	movss	xmm0, DWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+56
	movaps	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+432, xmm1
	movss	xmm1, DWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+52
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468, xmm0
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464, xmm1
	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+412, 1065353216 ; 3f800000H
	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+448, 0
	mov	QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+452, 1065353216 ; 3f800000H
	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+472, 1065353216 ; 3f800000H
$LN3@ComputeCon:

; 1053 :       else
; 1054 :       {
; 1055 :          gContext.mModel.Translation(((matrix_t*)matrix)->v.position);
; 1056 :       }
; 1057 :       gContext.mModelSource = *(matrix_t*)matrix;

	movaps	xmm1, XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA
	movaps	xmm0, XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+48

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm2, xmm1

; 1053 :       else
; 1054 :       {
; 1055 :          gContext.mModel.Translation(((matrix_t*)matrix)->v.position);
; 1056 :       }
; 1057 :       gContext.mModelSource = *(matrix_t*)matrix;

	movaps	xmm7, XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+16
	movaps	xmm6, XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+32
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+652, xmm0

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm2, xmm1
	movaps	xmm0, xmm1
	shufps	xmm0, xmm1, 85				; 00000055H
	mulss	xmm0, xmm0

; 1053 :       else
; 1054 :       {
; 1055 :          gContext.mModel.Translation(((matrix_t*)matrix)->v.position);
; 1056 :       }
; 1057 :       gContext.mModelSource = *(matrix_t*)matrix;

	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+604, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm2, xmm0
	shufps	xmm1, xmm1, 170				; 000000aaH
	mulss	xmm1, xmm1
	xorps	xmm0, xmm0

; 1053 :       else
; 1054 :       {
; 1055 :          gContext.mModel.Translation(((matrix_t*)matrix)->v.position);
; 1056 :       }
; 1057 :       gContext.mModelSource = *(matrix_t*)matrix;

	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+620, xmm7

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm2, xmm1

; 1053 :       else
; 1054 :       {
; 1055 :          gContext.mModel.Translation(((matrix_t*)matrix)->v.position);
; 1056 :       }
; 1057 :       gContext.mModelSource = *(matrix_t*)matrix;

	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+636, xmm6

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	ucomiss	xmm0, xmm2
	ja	SHORT $LN122@ComputeCon
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN123@ComputeCon
$LN122@ComputeCon:
	movaps	xmm0, xmm2
	call	sqrtf
$LN123@ComputeCon:

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+924, xmm0

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm7
	mulss	xmm1, xmm7
	movaps	xmm0, xmm7
	shufps	xmm0, xmm7, 85				; 00000055H
	mulss	xmm0, xmm0
	shufps	xmm7, xmm7, 170				; 000000aaH
	mulss	xmm7, xmm7
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	addss	xmm1, xmm7
	ucomiss	xmm0, xmm1
	ja	SHORT $LN120@ComputeCon
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	jmp	SHORT $LN121@ComputeCon
$LN120@ComputeCon:
	movaps	xmm0, xmm1
	call	sqrtf
$LN121@ComputeCon:

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+928, xmm0

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm6
	mulss	xmm1, xmm6
	movaps	xmm0, xmm6
	shufps	xmm0, xmm6, 85				; 00000055H
	mulss	xmm0, xmm0
	shufps	xmm6, xmm6, 170				; 000000aaH
	mulss	xmm6, xmm6
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	addss	xmm1, xmm6
	ucomiss	xmm0, xmm1
	ja	SHORT $LN118@ComputeCon
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	jmp	SHORT $LN119@ComputeCon
$LN118@ComputeCon:
	movaps	xmm0, xmm1
	call	sqrtf
$LN119@ComputeCon:

; 1058 :       gContext.mModelScaleOrigin.Set(gContext.mModelSource.v.right.Length(), gContext.mModelSource.v.up.Length(), gContext.mModelSource.v.dir.Length());
; 1059 : 
; 1060 :       gContext.mModelInverse.Inverse(gContext.mModel);

	xor	r8d, r8d

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+932, xmm0

; 1058 :       gContext.mModelScaleOrigin.Set(gContext.mModelSource.v.right.Length(), gContext.mModelSource.v.up.Length(), gContext.mModelSource.v.dir.Length());
; 1059 : 
; 1060 :       gContext.mModelInverse.Inverse(gContext.mModel);

	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+412

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+936, 0

; 1058 :       gContext.mModelScaleOrigin.Set(gContext.mModelSource.v.right.Length(), gContext.mModelSource.v.up.Length(), gContext.mModelSource.v.dir.Length());
; 1059 : 
; 1060 :       gContext.mModelInverse.Inverse(gContext.mModel);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+540
	call	?Inverse@matrix_t@ImGuizmo@@QEAAMAEBU12@_N@Z ; ImGuizmo::matrix_t::Inverse

; 1061 :       gContext.mModelSourceInverse.Inverse(gContext.mModelSource);

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+604
	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+668
	call	?Inverse@matrix_t@ImGuizmo@@QEAAMAEBU12@_N@Z ; ImGuizmo::matrix_t::Inverse

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	r8, QWORD PTR $T6[rsp]
	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+348
	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+284
	call	?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z ; ImGuizmo::FPU_MatrixF_x_MatrixF

; 1062 :       gContext.mViewProjection = gContext.mViewMat * gContext.mProjectionMat;

	movups	xmm0, XMMWORD PTR $T6[rsp]

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	r8, QWORD PTR $T5[rsp]

; 1062 :       gContext.mViewProjection = gContext.mViewMat * gContext.mProjectionMat;

	movups	xmm1, XMMWORD PTR $T6[rsp+16]

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+860

; 1062 :       gContext.mViewProjection = gContext.mViewMat * gContext.mProjectionMat;

	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+860, xmm0

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+412

; 1062 :       gContext.mViewProjection = gContext.mViewMat * gContext.mProjectionMat;

	movups	xmm0, XMMWORD PTR $T6[rsp+32]
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+876, xmm1
	movups	xmm1, XMMWORD PTR $T6[rsp+48]
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+892, xmm0
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+908, xmm1

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	call	?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z ; ImGuizmo::FPU_MatrixF_x_MatrixF

; 1063 :       gContext.mMVP = gContext.mModel * gContext.mViewProjection;

	movups	xmm0, XMMWORD PTR $T5[rsp]

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	r8, QWORD PTR $T4[rsp]

; 1063 :       gContext.mMVP = gContext.mModel * gContext.mViewProjection;

	movups	xmm1, XMMWORD PTR $T5[rsp+16]

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+860

; 1063 :       gContext.mMVP = gContext.mModel * gContext.mViewProjection;

	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+732, xmm0

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+476

; 1063 :       gContext.mMVP = gContext.mModel * gContext.mViewProjection;

	movups	xmm0, XMMWORD PTR $T5[rsp+32]
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+748, xmm1
	movups	xmm1, XMMWORD PTR $T5[rsp+48]
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+764, xmm0
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+780, xmm1

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	call	?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z ; ImGuizmo::FPU_MatrixF_x_MatrixF

; 1064 :       gContext.mMVPLocal = gContext.mModelLocal * gContext.mViewProjection;

	movups	xmm0, XMMWORD PTR $T4[rsp]

; 1065 : 
; 1066 :       matrix_t viewInverse;
; 1067 :       viewInverse.Inverse(gContext.mViewMat);

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+284
	movups	xmm1, XMMWORD PTR $T4[rsp+16]
	lea	rcx, QWORD PTR viewInverse$[rbp-256]
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+796, xmm0
	movups	xmm0, XMMWORD PTR $T4[rsp+32]
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+812, xmm1
	movups	xmm1, XMMWORD PTR $T4[rsp+48]
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+828, xmm0
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+844, xmm1
	call	?Inverse@matrix_t@ImGuizmo@@QEAAMAEBU12@_N@Z ; ImGuizmo::matrix_t::Inverse

; 1068 :       gContext.mCameraDir = viewInverse.v.dir;

	movaps	xmm0, XMMWORD PTR viewInverse$[rbp-224]

; 415  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + w * matrix.m[3][2];

	movss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+356

; 416  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + w * matrix.m[3][3];

	movss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+360
	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+388
	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+392

; 1069 :       gContext.mCameraEye = viewInverse.v.position;

	movaps	xmm1, XMMWORD PTR viewInverse$[rbp-208]

; 1070 :       gContext.mCameraRight = viewInverse.v.right;

	movaps	xmm11, XMMWORD PTR viewInverse$[rbp-256]
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+972, xmm0

; 1071 :       gContext.mCameraUp = viewInverse.v.up;

	movaps	xmm0, XMMWORD PTR viewInverse$[rbp-240]
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+988, xmm0

; 426  :       *this = s;

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+372
	mulss	xmm0, xmm12

; 415  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + w * matrix.m[3][2];

	mulss	xmm8, xmm12

; 416  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + w * matrix.m[3][3];

	mulss	xmm7, xmm12
	addss	xmm8, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+376
	mulss	xmm0, xmm12

; 1069 :       gContext.mCameraEye = viewInverse.v.position;

	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+940, xmm1

; 416  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + w * matrix.m[3][3];

	addss	xmm7, xmm0
	movaps	xmm5, xmm8
	addss	xmm5, xmm4

; 415  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + w * matrix.m[3][2];

	mulss	xmm4, DWORD PTR __real@40000000

; 1070 :       gContext.mCameraRight = viewInverse.v.right;

	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+956, xmm11

; 416  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + w * matrix.m[3][3];

	movaps	xmm0, xmm7

; 415  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + w * matrix.m[3][2];

	addss	xmm4, xmm8
	addss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+404

; 416  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + w * matrix.m[3][3];

	addss	xmm0, xmm2
	mulss	xmm2, DWORD PTR __real@40000000
	addss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+404
	addss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+408

; 1072 : 
; 1073 :       // projection reverse
; 1074 :        vec_t nearPos, farPos;
; 1075 :        nearPos.Transform(makeVect(0, 0, 1.f, 1.f), gContext.mProjectionMat);
; 1076 :        farPos.Transform(makeVect(0, 0, 2.f, 1.f), gContext.mProjectionMat);
; 1077 : 
; 1078 :        gContext.mReversed = (nearPos.z/nearPos.w) > (farPos.z / farPos.w);

	divss	xmm5, xmm0

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+876

; 416  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + w * matrix.m[3][3];

	addss	xmm2, xmm7

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+892

; 1086 :       rightViewInverse.TransformVector(gContext.mModelInverse);
; 1087 :       float rightLength = GetSegmentLengthClipSpace(makeVect(0.f, 0.f), rightViewInverse);

	lea	rdx, QWORD PTR rightViewInverse$[rsp]
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+860
	lea	rcx, QWORD PTR $T7[rsp]
	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1452

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movaps	xmm8, xmm11

; 1079 : 
; 1080 :       // compute scale from the size of camera right vector projected on screen at the matrix position
; 1081 :       vec_t pointRight = viewInverse.v.right;

	mulss	xmm0, xmm11

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movaps	xmm7, xmm11

; 416  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + w * matrix.m[3][3];

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+408

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	shufps	xmm8, xmm11, 85				; 00000055H
	mulss	xmm3, xmm8
	shufps	xmm7, xmm11, 170			; 000000aaH

; 1072 : 
; 1073 :       // projection reverse
; 1074 :        vec_t nearPos, farPos;
; 1075 :        nearPos.Transform(makeVect(0, 0, 1.f, 1.f), gContext.mProjectionMat);
; 1076 :        farPos.Transform(makeVect(0, 0, 2.f, 1.f), gContext.mProjectionMat);
; 1077 : 
; 1078 :        gContext.mReversed = (nearPos.z/nearPos.w) > (farPos.z / farPos.w);

	divss	xmm4, xmm2

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+888
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+872
	mulss	xmm0, xmm11
	mulss	xmm1, xmm7
	mulss	xmm2, xmm8
	addss	xmm3, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+904
	mulss	xmm1, xmm7
	addss	xmm2, xmm0

; 1082 :       pointRight.TransformPoint(gContext.mViewProjection);
; 1083 :       gContext.mScreenFactor = gContext.mGizmoSizeClipSpace / (pointRight.x / pointRight.w - gContext.mMVP.v.position.x / gContext.mMVP.v.position.w);

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+780
	divss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+792

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+908

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];
; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm1

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+572

; 1072 : 
; 1073 :       // projection reverse
; 1074 :        vec_t nearPos, farPos;
; 1075 :        nearPos.Transform(makeVect(0, 0, 1.f, 1.f), gContext.mProjectionMat);
; 1076 :        farPos.Transform(makeVect(0, 0, 2.f, 1.f), gContext.mProjectionMat);
; 1077 : 
; 1078 :        gContext.mReversed = (nearPos.z/nearPos.w) > (farPos.z / farPos.w);

	comiss	xmm5, xmm4

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+920

; 1084 : 
; 1085 :       vec_t rightViewInverse = viewInverse.v.right;

	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+556

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+560

; 1072 : 
; 1073 :       // projection reverse
; 1074 :        vec_t nearPos, farPos;
; 1075 :        nearPos.Transform(makeVect(0, 0, 1.f, 1.f), gContext.mProjectionMat);
; 1076 :        farPos.Transform(makeVect(0, 0, 2.f, 1.f), gContext.mProjectionMat);
; 1077 : 
; 1078 :        gContext.mReversed = (nearPos.z/nearPos.w) > (farPos.z / farPos.w);

	seta	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1087

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	mulss	xmm1, xmm7

; 1086 :       rightViewInverse.TransformVector(gContext.mModelInverse);
; 1087 :       float rightLength = GetSegmentLengthClipSpace(makeVect(0.f, 0.f), rightViewInverse);

	xor	r8d, r8d
	divss	xmm3, xmm2

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+568

; 1082 :       pointRight.TransformPoint(gContext.mViewProjection);
; 1083 :       gContext.mScreenFactor = gContext.mGizmoSizeClipSpace / (pointRight.x / pointRight.w - gContext.mMVP.v.position.x / gContext.mMVP.v.position.w);

	subss	xmm3, xmm0

; 1084 : 
; 1085 :       vec_t rightViewInverse = viewInverse.v.right;

	mulss	xmm5, xmm8
	movaps	xmm0, xmm6

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	mulss	xmm4, xmm8

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	mulss	xmm2, xmm8

; 1082 :       pointRight.TransformPoint(gContext.mViewProjection);
; 1083 :       gContext.mScreenFactor = gContext.mGizmoSizeClipSpace / (pointRight.x / pointRight.w - gContext.mMVP.v.position.x / gContext.mMVP.v.position.w);

	divss	xmm0, xmm3

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+564

; 1082 :       pointRight.TransformPoint(gContext.mViewProjection);
; 1083 :       gContext.mScreenFactor = gContext.mGizmoSizeClipSpace / (pointRight.x / pointRight.w - gContext.mMVP.v.position.x / gContext.mMVP.v.position.w);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064, xmm0

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+540
	mulss	xmm0, xmm11

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	mulss	xmm3, xmm8
	addss	xmm5, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+544
	mulss	xmm0, xmm11
	addss	xmm5, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+576
	addss	xmm4, xmm0
	mulss	xmm1, xmm7

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+548
	mulss	xmm0, xmm11
	addss	xmm4, xmm1

; 453  : 
; 454  :       x = out.x;

	movss	DWORD PTR rightViewInverse$[rsp], xmm5
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+580
	addss	xmm3, xmm0
	mulss	xmm1, xmm7
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+552
	mulss	xmm0, xmm11
	addss	xmm3, xmm1

; 455  :       y = out.y;

	movss	DWORD PTR rightViewInverse$[rsp+4], xmm4
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+584
	addss	xmm2, xmm0
	mulss	xmm1, xmm7
	xorps	xmm0, xmm0

; 456  :       z = out.z;

	movss	DWORD PTR rightViewInverse$[rsp+8], xmm3

; 1086 :       rightViewInverse.TransformVector(gContext.mModelInverse);
; 1087 :       float rightLength = GetSegmentLengthClipSpace(makeVect(0.f, 0.f), rightViewInverse);

	movups	XMMWORD PTR $T7[rsp], xmm0

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	addss	xmm2, xmm1

; 457  :       w = out.w;

	movss	DWORD PTR rightViewInverse$[rsp+12], xmm2

; 1086 :       rightViewInverse.TransformVector(gContext.mModelInverse);
; 1087 :       float rightLength = GetSegmentLengthClipSpace(makeVect(0.f, 0.f), rightViewInverse);

	call	?GetSegmentLengthClipSpace@ImGuizmo@@YAMAEBUvec_t@1@0_N@Z ; ImGuizmo::GetSegmentLengthClipSpace

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+760

; 1088 :       gContext.mScreenFactor = gContext.mGizmoSizeClipSpace / rightLength;

	divss	xmm6, xmm0

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm2, xmm12

; 1088 :       gContext.mScreenFactor = gContext.mGizmoSizeClipSpace / rightLength;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064, xmm6

; 804  :       trans *= 0.5f / trans.w;

	movss	xmm4, DWORD PTR __real@3f000000

; 1095 :       ComputeCameraRay(gContext.mRayOrigin, gContext.mRayVector);

	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+1020

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+744

; 1095 :       ComputeCameraRay(gContext.mRayOrigin, gContext.mRayVector);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+1004

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+776

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm3, xmm4

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+748

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm0, xmm12

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];
; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm1, xmm12
	addss	xmm2, xmm0
	mulss	xmm7, xmm12

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+732
	mulss	xmm0, xmm12

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+764
	mulss	xmm1, xmm12
	addss	xmm7, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+736
	mulss	xmm0, xmm12
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+792
	addss	xmm7, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+768
	mulss	xmm1, xmm12

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+780

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+752
	mulss	xmm2, xmm12

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm3

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm0

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm7, xmm4

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm1

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+784

; 808  :       trans.y *= size.y;

	addss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm3

; 807  :       trans.x *= size.x;

	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416

; 1092 :       gContext.mScreenSquareMin = ImVec2(centerSSpace.x - 10.f, centerSSpace.y - 10.f);

	movaps	xmm1, xmm7
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1040, xmm7

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm2, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm13, xmm2

; 1092 :       gContext.mScreenSquareMin = ImVec2(centerSSpace.x - 10.f, centerSSpace.y - 10.f);

	movss	xmm2, DWORD PTR __real@41200000
	subss	xmm1, xmm2

; 1093 :       gContext.mScreenSquareMax = ImVec2(centerSSpace.x + 10.f, centerSSpace.y + 10.f);

	addss	xmm7, xmm2

; 807  :       trans.x *= size.x;

	mulss	xmm13, xmm3

; 1092 :       gContext.mScreenSquareMin = ImVec2(centerSSpace.x - 10.f, centerSSpace.y - 10.f);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1048, xmm1

; 1095 :       ComputeCameraRay(gContext.mRayOrigin, gContext.mRayVector);

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm13, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1095 :       ComputeCameraRay(gContext.mRayOrigin, gContext.mRayVector);

	unpcklps xmm1, xmm4
	movq	r8, xmm1
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1056, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm0, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1091 :       gContext.mScreenSquareCenter = centerSSpace;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1044, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm0, xmm2
	addss	xmm13, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1092 :       gContext.mScreenSquareMin = ImVec2(centerSSpace.x - 10.f, centerSSpace.y - 10.f);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1052, xmm0

; 1095 :       ComputeCameraRay(gContext.mRayOrigin, gContext.mRayVector);

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412
	unpcklps xmm0, xmm3
	movq	r9, xmm0
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1060, xmm13
	call	?ComputeCameraRay@ImGuizmo@@YAXAEAUvec_t@1@0UImVec2@@1@Z ; ImGuizmo::ComputeCameraRay

; 1096 :    }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+304]
	mov	rbx, QWORD PTR [r11+32]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm11, XMMWORD PTR [r11-64]
	movaps	xmm12, XMMWORD PTR [r11-80]
	movaps	xmm13, XMMWORD PTR [r11-96]
	mov	rsp, r11
	pop	rbp
	ret	0
?ComputeContext@ImGuizmo@@YAXPEBM0PEAMW4MODE@1@@Z ENDP	; ImGuizmo::ComputeContext
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?ComputeColors@ImGuizmo@@YAXPEAIHW4OPERATION@1@@Z
_TEXT	SEGMENT
colors$ = 48
type$ = 56
operation$ = 64
?ComputeColors@ImGuizmo@@YAXPEAIHW4OPERATION@1@@Z PROC	; ImGuizmo::ComputeColors, COMDAT

; 1099 :    {

	sub	rsp, 40					; 00000028H

; 1100 :       if (gContext.mbEnable)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1085, 0
	mov	r11d, edx
	mov	r9, rcx
	je	$LN16@ComputeCol

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+136
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r10d, eax

; 1101 :       {
; 1102 :          ImU32 selectionColor = GetColorU32(SELECTION);
; 1103 : 
; 1104 :          switch (operation)

	cmp	r8d, 7
	je	$LN18@ComputeCol
	cmp	r8d, 120				; 00000078H
	je	SHORT $LN19@ComputeCol
	cmp	r8d, 896				; 00000380H
	je	SHORT $LN20@ComputeCol
	cmp	r8d, 14336				; 00003800H
	jne	$LN14@ComputeCol
$LN20@ComputeCol:

; 1120 :             }
; 1121 :             break;
; 1122 :          case SCALEU:
; 1123 :          case SCALE:
; 1124 :             colors[0] = (type == MT_SCALE_XYZ) ? selectionColor : IM_COL32_WHITE;

	cmp	r11d, 15
	mov	eax, -1					; ffffffffH
	cmove	eax, r10d
	mov	DWORD PTR [r9], eax

; 1125 :             for (int i = 0; i < 3; i++)
; 1126 :             {
; 1127 :                colors[i + 1] = (type == (int)(MT_SCALE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	cmp	r11d, 12
	jne	SHORT $LN32@ComputeCol
	mov	DWORD PTR [r9+4], r10d
	jmp	SHORT $LN55@ComputeCol
$LN32@ComputeCol:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+40
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1125 :             for (int i = 0; i < 3; i++)
; 1126 :             {
; 1127 :                colors[i + 1] = (type == (int)(MT_SCALE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	mov	DWORD PTR [r9+4], eax
	cmp	r11d, 13
	je	SHORT $LN96@ComputeCol
$LN55@ComputeCol:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+56
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1125 :             for (int i = 0; i < 3; i++)
; 1126 :             {
; 1127 :                colors[i + 1] = (type == (int)(MT_SCALE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	cmp	r11d, 14

; 1128 :             }
; 1129 :             break;

	jmp	SHORT $LN95@ComputeCol
$LN19@ComputeCol:

; 1113 :             }
; 1114 :             break;
; 1115 :          case ROTATE:
; 1116 :             colors[0] = (type == MT_ROTATE_SCREEN) ? selectionColor : IM_COL32_WHITE;

	cmp	r11d, 11
	mov	eax, -1					; ffffffffH
	cmove	eax, r10d
	mov	DWORD PTR [r9], eax

; 1117 :             for (int i = 0; i < 3; i++)
; 1118 :             {
; 1119 :                colors[i + 1] = (type == (int)(MT_ROTATE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	cmp	r11d, 8
	jne	SHORT $LN30@ComputeCol
	mov	DWORD PTR [r9+4], r10d
$LN61@ComputeCol:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+56
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1117 :             for (int i = 0; i < 3; i++)
; 1118 :             {
; 1119 :                colors[i + 1] = (type == (int)(MT_ROTATE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	cmp	r11d, 10
$LN95@ComputeCol:

; 1141 :          }
; 1142 :       }
; 1143 :    }

	mov	DWORD PTR [r9+8], eax
	je	SHORT $LN65@ComputeCol
$LN64@ComputeCol:
	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+72
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r10d, eax
$LN65@ComputeCol:
	mov	DWORD PTR [r9+12], r10d
	add	rsp, 40					; 00000028H
	ret	0
$LN30@ComputeCol:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+40
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1117 :             for (int i = 0; i < 3; i++)
; 1118 :             {
; 1119 :                colors[i + 1] = (type == (int)(MT_ROTATE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	mov	DWORD PTR [r9+4], eax
	cmp	r11d, 9
	jne	SHORT $LN61@ComputeCol
$LN96@ComputeCol:

; 1141 :          }
; 1142 :       }
; 1143 :    }

	mov	DWORD PTR [r9+8], r10d
	jmp	SHORT $LN64@ComputeCol
$LN18@ComputeCol:

; 1105 :          {
; 1106 :          case TRANSLATE:
; 1107 :             colors[0] = (type == MT_MOVE_SCREEN) ? selectionColor : IM_COL32_WHITE;

	cmp	r11d, 7
	mov	eax, -1					; ffffffffH
	cmove	eax, r10d
	mov	DWORD PTR [r9], eax

; 1108 :             for (int i = 0; i < 3; i++)
; 1109 :             {
; 1110 :                colors[i + 1] = (type == (int)(MT_MOVE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	cmp	r11d, 1
	jne	SHORT $LN24@ComputeCol
	mov	DWORD PTR [r9+4], r10d
$LN26@ComputeCol:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+88
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1111 :                colors[i + 4] = (type == (int)(MT_MOVE_YZ + i)) ? selectionColor : GetColorU32(PLANE_X + i);

	mov	DWORD PTR [r9+16], eax

; 1112 :                colors[i + 4] = (type == MT_MOVE_SCREEN) ? selectionColor : colors[i + 4];

	cmp	r11d, 7
	jne	SHORT $LN28@ComputeCol
	mov	DWORD PTR [r9+16], r10d
$LN67@ComputeCol:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+56
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1108 :             for (int i = 0; i < 3; i++)
; 1109 :             {
; 1110 :                colors[i + 1] = (type == (int)(MT_MOVE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	mov	DWORD PTR [r9+8], eax

; 1111 :                colors[i + 4] = (type == (int)(MT_MOVE_YZ + i)) ? selectionColor : GetColorU32(PLANE_X + i);

	cmp	r11d, 5
	jne	SHORT $LN69@ComputeCol
	mov	DWORD PTR [r9+20], r10d
	mov	eax, r10d
$LN71@ComputeCol:

; 1112 :                colors[i + 4] = (type == MT_MOVE_SCREEN) ? selectionColor : colors[i + 4];

	mov	DWORD PTR [r9+20], eax
	cmp	r11d, 3
	jne	SHORT $LN74@ComputeCol

; 1108 :             for (int i = 0; i < 3; i++)
; 1109 :             {
; 1110 :                colors[i + 1] = (type == (int)(MT_MOVE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	mov	DWORD PTR [r9+12], r10d
$LN76@ComputeCol:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+120
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1111 :                colors[i + 4] = (type == (int)(MT_MOVE_YZ + i)) ? selectionColor : GetColorU32(PLANE_X + i);

	mov	DWORD PTR [r9+24], eax

; 1112 :                colors[i + 4] = (type == MT_MOVE_SCREEN) ? selectionColor : colors[i + 4];

	cmp	r11d, 7
	je	SHORT $LN79@ComputeCol
	mov	r10d, eax
$LN79@ComputeCol:
	mov	DWORD PTR [r9+24], r10d

; 1141 :          }
; 1142 :       }
; 1143 :    }

	add	rsp, 40					; 00000028H
	ret	0
$LN24@ComputeCol:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+40
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1108 :             for (int i = 0; i < 3; i++)
; 1109 :             {
; 1110 :                colors[i + 1] = (type == (int)(MT_MOVE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	mov	DWORD PTR [r9+4], eax

; 1111 :                colors[i + 4] = (type == (int)(MT_MOVE_YZ + i)) ? selectionColor : GetColorU32(PLANE_X + i);

	cmp	r11d, 4
	jne	SHORT $LN26@ComputeCol
	mov	DWORD PTR [r9+16], r10d
	mov	eax, r10d
$LN28@ComputeCol:

; 1112 :                colors[i + 4] = (type == MT_MOVE_SCREEN) ? selectionColor : colors[i + 4];

	mov	DWORD PTR [r9+16], eax
	cmp	r11d, 2
	jne	SHORT $LN67@ComputeCol

; 1108 :             for (int i = 0; i < 3; i++)
; 1109 :             {
; 1110 :                colors[i + 1] = (type == (int)(MT_MOVE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	mov	DWORD PTR [r9+8], r10d
$LN69@ComputeCol:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+104
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1111 :                colors[i + 4] = (type == (int)(MT_MOVE_YZ + i)) ? selectionColor : GetColorU32(PLANE_X + i);

	mov	DWORD PTR [r9+20], eax

; 1112 :                colors[i + 4] = (type == MT_MOVE_SCREEN) ? selectionColor : colors[i + 4];

	cmp	r11d, 7
	jne	SHORT $LN71@ComputeCol
	mov	DWORD PTR [r9+20], r10d
$LN74@ComputeCol:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+72
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1108 :             for (int i = 0; i < 3; i++)
; 1109 :             {
; 1110 :                colors[i + 1] = (type == (int)(MT_MOVE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	mov	DWORD PTR [r9+12], eax

; 1111 :                colors[i + 4] = (type == (int)(MT_MOVE_YZ + i)) ? selectionColor : GetColorU32(PLANE_X + i);

	cmp	r11d, 6
	jne	SHORT $LN76@ComputeCol
	mov	DWORD PTR [r9+24], r10d
	mov	eax, r10d

; 1112 :                colors[i + 4] = (type == MT_MOVE_SCREEN) ? selectionColor : colors[i + 4];

	mov	DWORD PTR [r9+24], r10d

; 1141 :          }
; 1142 :       }
; 1143 :    }

	add	rsp, 40					; 00000028H
	ret	0
$LN16@ComputeCol:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+152
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1130 :          // note: this internal function is only called with three possible values for operation
; 1131 :          default:
; 1132 :             break;
; 1133 :          }
; 1134 :       }
; 1135 :       else
; 1136 :       {
; 1137 :          ImU32 inactiveColor = GetColorU32(INACTIVE);
; 1138 :          for (int i = 0; i < 7; i++)
; 1139 :          {
; 1140 :             colors[i] = inactiveColor;

	mov	DWORD PTR [r9], eax
	mov	DWORD PTR [r9+4], eax
	mov	DWORD PTR [r9+8], eax
	mov	DWORD PTR [r9+12], eax
	mov	DWORD PTR [r9+16], eax
	mov	DWORD PTR [r9+20], eax
	mov	DWORD PTR [r9+24], eax
$LN14@ComputeCol:

; 1141 :          }
; 1142 :       }
; 1143 :    }

	add	rsp, 40					; 00000028H
	ret	0
?ComputeColors@ImGuizmo@@YAXPEAIHW4OPERATION@1@@Z ENDP	; ImGuizmo::ComputeColors
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z
_TEXT	SEGMENT
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
mulAxis$1$ = 48
mulAxisX$1$ = 52
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
axisLengthInClipSpace$1$ = 72
tv5930 = 80
pts$13 = 88
__$ArrayPad$ = 136
axisIndex$ = 384
dirAxis$ = 392
dirPlaneX$ = 400
dirPlaneY$ = 408
belowAxisLimit$ = 416
belowPlaneLimit$ = 424
localCoordinates$ = 432
?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z PROC ; ImGuizmo::ComputeTripodAxisAndVisibility, COMDAT

; 1146 :    {

	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-56]
	sub	rsp, 312				; 00000138H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r15, QWORD PTR belowAxisLimit$[rbp-256]
	mov	rsi, rdx
	mov	r12, QWORD PTR belowPlaneLimit$[rbp-256]
	mov	r14, r8
	movsxd	r10, ecx
	mov	rdi, r9

; 1147 :       dirAxis = directionUnary[axisIndex];

	lea	r9, OFFSET FLAT:__ImageBase
	mov	rax, r10
	add	rax, rax
	mov	rbx, r10

; 1148 :       dirPlaneX = directionUnary[(axisIndex + 1) % 3];

	lea	r8d, DWORD PTR [r10+1]
	movups	xmm0, XMMWORD PTR ?directionUnary@ImGuizmo@@3QBUvec_t@1@B[r9+rax*8]
	mov	eax, 1431655766				; 55555556H
	movups	XMMWORD PTR [rdx], xmm0
	imul	r8d
	mov	eax, edx
	shr	eax, 31
	add	edx, eax

; 1149 :       dirPlaneY = directionUnary[(axisIndex + 2) % 3];

	mov	eax, 1431655766				; 55555556H
	lea	ecx, DWORD PTR [rdx+rdx*2]
	sub	r8d, ecx
	movsxd	r13, r8d
	mov	rcx, r13
	add	rcx, rcx
	movups	xmm0, XMMWORD PTR ?directionUnary@ImGuizmo@@3QBUvec_t@1@B[r9+rcx*8]
	lea	ecx, DWORD PTR [r10+2]
	imul	ecx
	movups	XMMWORD PTR [r14], xmm0
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	lea	eax, DWORD PTR [rdx+rdx*2]
	sub	ecx, eax
	movsxd	rcx, ecx
	mov	rax, rcx
	mov	QWORD PTR tv5930[rsp], rcx
	add	rax, rax
	movups	xmm0, XMMWORD PTR ?directionUnary@ImGuizmo@@3QBUvec_t@1@B[r9+rax*8]
	movups	XMMWORD PTR [rdi], xmm0

; 1150 : 
; 1151 :       if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID))

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	je	SHORT $LL2@ComputeTri
	mov	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	cmp	eax, -1
	je	SHORT $LN4@ComputeTri
	cmp	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440
	jne	SHORT $LL2@ComputeTri
$LN4@ComputeTri:

; 1152 :       {
; 1153 :          // when using, use stored factors so the gizmo doesn't flip when we translate
; 1154 :          belowAxisLimit = gContext.mBelowAxisLimit[axisIndex];

	movzx	eax, BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A[r10+r9+1228]
	mov	BYTE PTR [r15], al

; 1155 :          belowPlaneLimit = gContext.mBelowPlaneLimit[axisIndex];

	movzx	eax, BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A[r10+r9+1231]
	mov	BYTE PTR [r12], al

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movups	xmm0, XMMWORD PTR [rsi]

; 1152 :       {
; 1153 :          // when using, use stored factors so the gizmo doesn't flip when we translate
; 1154 :          belowAxisLimit = gContext.mBelowAxisLimit[axisIndex];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A[r9+r10*4+1236]
	shufps	xmm1, xmm1, 0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulps	xmm1, xmm0
	movups	XMMWORD PTR [rsi], xmm1
	movups	xmm0, XMMWORD PTR [r14]

; 1156 : 
; 1157 :          dirAxis *= gContext.mAxisFactor[axisIndex];
; 1158 :          dirPlaneX *= gContext.mAxisFactor[(axisIndex + 1) % 3];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A[r9+r13*4+1236]
	shufps	xmm1, xmm1, 0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulps	xmm1, xmm0
	movups	XMMWORD PTR [r14], xmm1

; 1159 :          dirPlaneY *= gContext.mAxisFactor[(axisIndex + 2) % 3];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A[r9+rcx*4+1236]

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movups	xmm0, XMMWORD PTR [rdi]

; 1159 :          dirPlaneY *= gContext.mAxisFactor[(axisIndex + 2) % 3];

	shufps	xmm1, xmm1, 0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulps	xmm1, xmm0
	movups	XMMWORD PTR [rdi], xmm1
	jmp	$LN3@ComputeTri
	npad	2
$LL2@ComputeTri:

; 1160 :       }
; 1161 :       else
; 1162 :       {
; 1163 :          // new method
; 1164 :          float lenDir = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), dirAxis, localCoordinates);

	movzx	r8d, BYTE PTR localCoordinates$[rbp-256]
	lea	rcx, QWORD PTR $T6[rsp]
	movaps	XMMWORD PTR [rsp+288], xmm6
	xorps	xmm0, xmm0
	movaps	XMMWORD PTR [rsp+272], xmm7
	mov	rdx, rsi
	movaps	XMMWORD PTR [rsp+256], xmm8
	movaps	XMMWORD PTR [rsp+240], xmm9
	movaps	XMMWORD PTR [rsp+224], xmm10
	movaps	XMMWORD PTR [rsp+208], xmm11
	movaps	XMMWORD PTR [rsp+192], xmm12
	movaps	XMMWORD PTR [rsp+176], xmm13
	movaps	XMMWORD PTR [rsp+160], xmm14
	movaps	XMMWORD PTR [rsp+144], xmm15
	movups	XMMWORD PTR $T6[rsp], xmm0
	call	?GetSegmentLengthClipSpace@ImGuizmo@@YAMAEBUvec_t@1@0_N@Z ; ImGuizmo::GetSegmentLengthClipSpace

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movups	xmm3, XMMWORD PTR [rsi]

; 1165 :          float lenDirMinus = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), -dirAxis, localCoordinates);

	lea	rdx, QWORD PTR $T5[rsp]
	movzx	r8d, BYTE PTR localCoordinates$[rbp-256]

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movaps	xmm11, XMMWORD PTR __xmm@80000000800000008000000080000000

; 1165 :          float lenDirMinus = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), -dirAxis, localCoordinates);

	lea	rcx, QWORD PTR $T12[rsp]
	movaps	xmm6, xmm0

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	xorps	xmm3, xmm11
	xorps	xmm0, xmm0
	movups	XMMWORD PTR $T5[rsp], xmm3

; 1165 :          float lenDirMinus = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), -dirAxis, localCoordinates);

	movups	XMMWORD PTR $T12[rsp], xmm0
	call	?GetSegmentLengthClipSpace@ImGuizmo@@YAMAEBUvec_t@1@0_N@Z ; ImGuizmo::GetSegmentLengthClipSpace

; 1166 : 
; 1167 :          float lenDirPlaneX = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), dirPlaneX, localCoordinates);

	movzx	r8d, BYTE PTR localCoordinates$[rbp-256]
	lea	rcx, QWORD PTR $T11[rsp]
	xorps	xmm1, xmm1
	mov	rdx, r14
	movups	XMMWORD PTR $T11[rsp], xmm1
	movaps	xmm9, xmm0
	call	?GetSegmentLengthClipSpace@ImGuizmo@@YAMAEBUvec_t@1@0_N@Z ; ImGuizmo::GetSegmentLengthClipSpace

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movups	xmm3, XMMWORD PTR [r14]

; 1168 :          float lenDirMinusPlaneX = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), -dirPlaneX, localCoordinates);

	movzx	r8d, BYTE PTR localCoordinates$[rbp-256]
	lea	rdx, QWORD PTR $T4[rsp]
	movaps	xmm7, xmm0
	lea	rcx, QWORD PTR $T10[rsp]

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	xorps	xmm3, xmm11
	xorps	xmm0, xmm0
	movups	XMMWORD PTR $T4[rsp], xmm3

; 1168 :          float lenDirMinusPlaneX = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), -dirPlaneX, localCoordinates);

	movups	XMMWORD PTR $T10[rsp], xmm0
	call	?GetSegmentLengthClipSpace@ImGuizmo@@YAMAEBUvec_t@1@0_N@Z ; ImGuizmo::GetSegmentLengthClipSpace

; 1169 : 
; 1170 :          float lenDirPlaneY = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), dirPlaneY, localCoordinates);

	movzx	r8d, BYTE PTR localCoordinates$[rbp-256]
	lea	rcx, QWORD PTR $T9[rsp]
	xorps	xmm1, xmm1
	mov	rdx, rdi
	movups	XMMWORD PTR $T9[rsp], xmm1
	movaps	xmm10, xmm0
	call	?GetSegmentLengthClipSpace@ImGuizmo@@YAMAEBUvec_t@1@0_N@Z ; ImGuizmo::GetSegmentLengthClipSpace

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movups	xmm3, XMMWORD PTR [rdi]

; 1171 :          float lenDirMinusPlaneY = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), -dirPlaneY, localCoordinates);

	movzx	r8d, BYTE PTR localCoordinates$[rbp-256]
	lea	rdx, QWORD PTR $T3[rsp]
	movaps	xmm8, xmm0
	lea	rcx, QWORD PTR $T8[rsp]

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	xorps	xmm3, xmm11
	xorps	xmm0, xmm0
	movups	XMMWORD PTR $T3[rsp], xmm3

; 1171 :          float lenDirMinusPlaneY = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), -dirPlaneY, localCoordinates);

	movups	XMMWORD PTR $T8[rsp], xmm0
	call	?GetSegmentLengthClipSpace@ImGuizmo@@YAMAEBUvec_t@1@0_N@Z ; ImGuizmo::GetSegmentLengthClipSpace

; 1175 :          float mulAxis = (allowFlip && lenDir < lenDirMinus&& fabsf(lenDir - lenDirMinus) > FLT_EPSILON) ? -1.f : 1.f;

	movzx	eax, BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1448
	movaps	xmm3, xmm0
	movss	xmm11, DWORD PTR __real@3f800000
	movss	xmm14, DWORD PTR __real@bf800000
	movss	xmm12, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	movss	xmm13, DWORD PTR __real@34000000
	test	al, al
	je	SHORT $LN6@ComputeTri
	comiss	xmm9, xmm6
	jbe	SHORT $LN6@ComputeTri
	subss	xmm6, xmm9
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm6, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1175 :          float mulAxis = (allowFlip && lenDir < lenDirMinus&& fabsf(lenDir - lenDirMinus) > FLT_EPSILON) ? -1.f : 1.f;

	comiss	xmm6, xmm13
	jbe	SHORT $LN6@ComputeTri
	movaps	xmm0, xmm14
	jmp	SHORT $LN319@ComputeTri
$LN6@ComputeTri:
	movaps	xmm0, xmm11
$LN319@ComputeTri:

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movss	DWORD PTR mulAxis$1$[rsp], xmm0
	movaps	xmm2, xmm0
	shufps	xmm2, xmm2, 0

; 1176 :          float mulAxisX = (allowFlip && lenDirPlaneX < lenDirMinusPlaneX&& fabsf(lenDirPlaneX - lenDirMinusPlaneX) > FLT_EPSILON) ? -1.f : 1.f;

	test	al, al
	je	SHORT $LN8@ComputeTri
	comiss	xmm10, xmm7
	jbe	SHORT $LN8@ComputeTri
	subss	xmm7, xmm10
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm7, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1176 :          float mulAxisX = (allowFlip && lenDirPlaneX < lenDirMinusPlaneX&& fabsf(lenDirPlaneX - lenDirMinusPlaneX) > FLT_EPSILON) ? -1.f : 1.f;

	comiss	xmm7, xmm13
	jbe	SHORT $LN8@ComputeTri
	movaps	xmm0, xmm14
	jmp	SHORT $LN320@ComputeTri
$LN8@ComputeTri:
	movaps	xmm0, xmm11
$LN320@ComputeTri:

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movss	DWORD PTR mulAxisX$1$[rsp], xmm0
	movaps	xmm1, xmm0
	shufps	xmm1, xmm1, 0

; 1177 :          float mulAxisY = (allowFlip && lenDirPlaneY < lenDirMinusPlaneY&& fabsf(lenDirPlaneY - lenDirMinusPlaneY) > FLT_EPSILON) ? -1.f : 1.f;

	test	al, al
	je	SHORT $LN10@ComputeTri
	comiss	xmm3, xmm8
	jbe	SHORT $LN10@ComputeTri
	subss	xmm8, xmm3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm8, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1177 :          float mulAxisY = (allowFlip && lenDirPlaneY < lenDirMinusPlaneY&& fabsf(lenDirPlaneY - lenDirMinusPlaneY) > FLT_EPSILON) ? -1.f : 1.f;

	comiss	xmm8, xmm13
	ja	SHORT $LL11@ComputeTri
$LN10@ComputeTri:
	movaps	xmm14, xmm11
	npad	10
$LL11@ComputeTri:

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movups	xmm0, XMMWORD PTR [rsi]

; 1178 :          dirAxis *= mulAxis;
; 1179 :          dirPlaneX *= mulAxisX;
; 1180 :          dirPlaneY *= mulAxisY;
; 1181 : 
; 1182 :          // for axis
; 1183 :          float axisLengthInClipSpace = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), dirAxis * gContext.mScreenFactor, localCoordinates);

	movzx	r8d, BYTE PTR localCoordinates$[rbp-256]
	lea	rdx, QWORD PTR $T2[rsp]

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm10, xmm14

; 1178 :          dirAxis *= mulAxis;
; 1179 :          dirPlaneX *= mulAxisX;
; 1180 :          dirPlaneY *= mulAxisY;
; 1181 : 
; 1182 :          // for axis
; 1183 :          float axisLengthInClipSpace = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), dirAxis * gContext.mScreenFactor, localCoordinates);

	lea	rcx, QWORD PTR $T7[rsp]

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulps	xmm2, xmm0
	movaps	xmm7, xmm14
	movaps	xmm8, xmm14
	movaps	xmm9, xmm14
	movups	XMMWORD PTR [rsi], xmm2
	movups	xmm0, XMMWORD PTR [r14]
	mulps	xmm0, xmm1
	movups	XMMWORD PTR [r14], xmm0
	mulss	xmm10, DWORD PTR [rdi]
	xorps	xmm0, xmm0
	mulss	xmm7, DWORD PTR [rdi+4]
	mulss	xmm8, DWORD PTR [rdi+8]
	mulss	xmm9, DWORD PTR [rdi+12]
	movss	DWORD PTR [rdi], xmm10
	movss	DWORD PTR [rdi+4], xmm7
	movss	DWORD PTR [rdi+8], xmm8
	movss	DWORD PTR [rdi+12], xmm9

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movups	xmm3, XMMWORD PTR [rsi]
	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064
	shufps	xmm6, xmm6, 0
	mulps	xmm3, xmm6

; 1178 :          dirAxis *= mulAxis;
; 1179 :          dirPlaneX *= mulAxisX;
; 1180 :          dirPlaneY *= mulAxisY;
; 1181 : 
; 1182 :          // for axis
; 1183 :          float axisLengthInClipSpace = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), dirAxis * gContext.mScreenFactor, localCoordinates);

	movups	XMMWORD PTR $T7[rsp], xmm0

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movups	XMMWORD PTR $T2[rsp], xmm3

; 1178 :          dirAxis *= mulAxis;
; 1179 :          dirPlaneX *= mulAxisX;
; 1180 :          dirPlaneY *= mulAxisY;
; 1181 : 
; 1182 :          // for axis
; 1183 :          float axisLengthInClipSpace = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), dirAxis * gContext.mScreenFactor, localCoordinates);

	call	?GetSegmentLengthClipSpace@ImGuizmo@@YAMAEBUvec_t@1@0_N@Z ; ImGuizmo::GetSegmentLengthClipSpace

; 863  :       vec_t pts[] = { ptO, ptA, ptB };

	movss	xmm15, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+780
	lea	rax, QWORD PTR pts$13[rsp+8]

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm10, xmm6
	movaps	xmm3, xmm6

; 863  :       vec_t pts[] = { ptO, ptA, ptB };

	mov	ecx, 3

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm3, DWORD PTR [r14]
	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR [r14+4]
	movaps	xmm2, xmm6
	mulss	xmm2, DWORD PTR [r14+8]

; 863  :       vec_t pts[] = { ptO, ptA, ptB };

	shufps	xmm10, xmm10, 225			; 000000e1H
	shufps	xmm3, xmm3, 225				; 000000e1H
	movss	xmm3, xmm1

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm8, xmm6

; 863  :       vec_t pts[] = { ptO, ptA, ptB };

	shufps	xmm3, xmm3, 198				; 000000c6H

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm9, xmm6

; 863  :       vec_t pts[] = { ptO, ptA, ptB };

	movss	xmm3, xmm2

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm7, xmm6
	mulss	xmm6, DWORD PTR [r14+12]

; 863  :       vec_t pts[] = { ptO, ptA, ptB };

	movss	xmm10, xmm7
	shufps	xmm3, xmm3, 39				; 00000027H
	shufps	xmm10, xmm10, 198			; 000000c6H
	movss	xmm10, xmm8

; 1178 :          dirAxis *= mulAxis;
; 1179 :          dirPlaneX *= mulAxisX;
; 1180 :          dirPlaneY *= mulAxisY;
; 1181 : 
; 1182 :          // for axis
; 1183 :          float axisLengthInClipSpace = GetSegmentLengthClipSpace(makeVect(0.f, 0.f, 0.f), dirAxis * gContext.mScreenFactor, localCoordinates);

	movss	DWORD PTR axisLengthInClipSpace$1$[rsp], xmm0

; 863  :       vec_t pts[] = { ptO, ptA, ptB };

	movss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+792
	movss	xmm3, xmm6
	shufps	xmm10, xmm10, 39			; 00000027H
	xorps	xmm0, xmm0
	movss	xmm10, xmm9
	shufps	xmm3, xmm3, 57				; 00000039H
	movss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+788
	shufps	xmm10, xmm10, 57			; 00000039H
	movups	XMMWORD PTR pts$13[rsp+32], xmm10
	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+784
	movups	XMMWORD PTR pts$13[rsp+16], xmm3
	movups	XMMWORD PTR pts$13[rsp], xmm0
	npad	1
$LL61@ComputeTri:

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm7, DWORD PTR [rax-8]
	movss	xmm4, DWORD PTR [rax-4]
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+732

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movaps	xmm3, xmm7
	movss	xmm5, DWORD PTR [rax]

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	movaps	xmm2, xmm7

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+744
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+764
	movaps	xmm6, xmm4
	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+748
	mulss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+736
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+740
	addss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+752
	addss	xmm6, xmm1
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+768
	addss	xmm3, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+756
	mulss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+760
	addss	xmm6, xmm15
	addss	xmm2, xmm0
	addss	xmm3, xmm1
	movaps	xmm1, xmm5
	mulss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+776
	addss	xmm7, xmm4
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+772
	addss	xmm3, xmm10

; 438  : 
; 439  :       x = out.x;

	movss	DWORD PTR [rax-8], xmm6
	addss	xmm7, xmm5
	addss	xmm2, xmm1

; 440  :       y = out.y;

	movss	DWORD PTR [rax-4], xmm3
	addss	xmm7, xmm8
	addss	xmm2, xmm9
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 442  :       w = out.w;

	movss	DWORD PTR [rax+4], xmm7
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm0, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 441  :       z = out.z;

	movss	DWORD PTR [rax], xmm2

; 867  :          if (fabsf(pts[i].w) > FLT_EPSILON) // check for axis aligned with camera direction

	comiss	xmm0, xmm13
	jbe	SHORT $LN59@ComputeTri

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movups	xmm0, XMMWORD PTR [rax-8]

; 869  :             pts[i] *= 1.f / pts[i].w;

	movaps	xmm1, xmm11
	divss	xmm1, xmm7
	shufps	xmm1, xmm1, 0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulps	xmm1, xmm0
	movups	XMMWORD PTR [rax-8], xmm1
$LN59@ComputeTri:

; 864  :       for (unsigned int i = 0; i < 3; i++)

	add	rax, 16
	sub	rcx, 1
	jne	$LL61@ComputeTri

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm7, DWORD PTR pts$13[rsp+20]
	xorps	xmm0, xmm0
	subss	xmm7, DWORD PTR pts$13[rsp+4]
	movss	xmm9, DWORD PTR pts$13[rsp+16]
	movss	xmm15, DWORD PTR pts$13[rsp]
	subss	xmm9, xmm15
	divss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1428

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm10, xmm9

; 875  :       segB.y /= gContext.mDisplayRatio;

	movaps	xmm8, xmm7

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm10, xmm9

; 875  :       segB.y /= gContext.mDisplayRatio;

	xorps	xmm8, DWORD PTR __xmm@80000000800000008000000080000000

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm8
	mulss	xmm1, xmm8
	addss	xmm1, xmm10
	addss	xmm1, xmm0
	ucomiss	xmm0, xmm1
	ja	SHORT $LN303@ComputeTri
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	jmp	SHORT $LN304@ComputeTri
$LN303@ComputeTri:
	movaps	xmm0, xmm1
	call	sqrtf
$LN304@ComputeTri:

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm6, DWORD PTR pts$13[rsp+36]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, xmm13

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm6, DWORD PTR pts$13[rsp+4]

; 879  :       float surface = sqrtf(segA.x * segA.x + segA.y * segA.y) * fabsf(dt);

	movaps	xmm13, XMMWORD PTR [rsp+176]
	xorps	xmm1, xmm1
	mulss	xmm7, xmm7

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm11, xmm0

; 875  :       segB.y /= gContext.mDisplayRatio;

	divss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1428

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm0, DWORD PTR pts$13[rsp+32]

; 879  :       float surface = sqrtf(segA.x * segA.x + segA.y * segA.y) * fabsf(dt);

	addss	xmm7, xmm10
	movaps	xmm10, XMMWORD PTR [rsp+224]

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm0, xmm15

; 879  :       float surface = sqrtf(segA.x * segA.x + segA.y * segA.y) * fabsf(dt);

	movaps	xmm15, XMMWORD PTR [rsp+144]

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm8, xmm11
	mulss	xmm9, xmm11
	mulss	xmm8, xmm0

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm0, DWORD PTR pts$13[rbp-216]
	subss	xmm0, DWORD PTR pts$13[rsp+8]

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm6, xmm9

; 879  :       float surface = sqrtf(segA.x * segA.x + segA.y * segA.y) * fabsf(dt);

	movaps	xmm9, XMMWORD PTR [rsp+240]

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm11, xmm1

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	addss	xmm6, xmm8

; 879  :       float surface = sqrtf(segA.x * segA.x + segA.y * segA.y) * fabsf(dt);

	movaps	xmm8, XMMWORD PTR [rsp+256]

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm0, xmm11

; 879  :       float surface = sqrtf(segA.x * segA.x + segA.y * segA.y) * fabsf(dt);

	movaps	xmm11, XMMWORD PTR [rsp+208]

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	addss	xmm6, xmm0
	xorps	xmm0, xmm0

; 879  :       float surface = sqrtf(segA.x * segA.x + segA.y * segA.y) * fabsf(dt);

	ucomiss	xmm0, xmm7
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm6, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 879  :       float surface = sqrtf(segA.x * segA.x + segA.y * segA.y) * fabsf(dt);

	movaps	xmm12, XMMWORD PTR [rsp+192]
	ja	SHORT $LN301@ComputeTri
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm7
	jmp	SHORT $LN302@ComputeTri
$LN301@ComputeTri:
	movaps	xmm0, xmm7
	call	sqrtf
$LN302@ComputeTri:

; 1188 : 
; 1189 :          // and store values
; 1190 :          gContext.mAxisFactor[axisIndex] = mulAxis;
; 1191 :          gContext.mAxisFactor[(axisIndex + 1) % 3] = mulAxisX;
; 1192 :          gContext.mAxisFactor[(axisIndex + 2) % 3] = mulAxisY;
; 1193 :          gContext.mBelowAxisLimit[axisIndex] = belowAxisLimit;
; 1194 :          gContext.mBelowPlaneLimit[axisIndex] = belowPlaneLimit;

	movaps	xmm7, XMMWORD PTR [rsp+272]
	lea	rcx, OFFSET FLAT:__ImageBase

; 879  :       float surface = sqrtf(segA.x * segA.x + segA.y * segA.y) * fabsf(dt);

	mulss	xmm6, xmm0

; 1184 : 
; 1185 :          float paraSurf = GetParallelogram(makeVect(0.f, 0.f, 0.f), dirPlaneX * gContext.mScreenFactor, dirPlaneY * gContext.mScreenFactor);
; 1186 :          belowPlaneLimit = (paraSurf > gContext.mAxisLimit);
; 1187 :          belowAxisLimit = (axisLengthInClipSpace > gContext.mPlaneLimit);

	movss	xmm0, DWORD PTR axisLengthInClipSpace$1$[rsp]
	comiss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1248

; 1188 : 
; 1189 :          // and store values
; 1190 :          gContext.mAxisFactor[axisIndex] = mulAxis;
; 1191 :          gContext.mAxisFactor[(axisIndex + 1) % 3] = mulAxisX;
; 1192 :          gContext.mAxisFactor[(axisIndex + 2) % 3] = mulAxisY;
; 1193 :          gContext.mBelowAxisLimit[axisIndex] = belowAxisLimit;
; 1194 :          gContext.mBelowPlaneLimit[axisIndex] = belowPlaneLimit;

	movaps	xmm6, XMMWORD PTR [rsp+288]
	seta	al
	mov	BYTE PTR [r12], al
	comiss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1252
	movss	xmm0, DWORD PTR mulAxis$1$[rsp]
	seta	al
	mov	BYTE PTR [r15], al
	mov	rax, QWORD PTR tv5930[rsp]
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A[rcx+rbx*4+1236], xmm0
	movss	xmm0, DWORD PTR mulAxisX$1$[rsp]
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A[rcx+r13*4+1236], xmm0
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A[rcx+rax*4+1236], xmm14
	movzx	eax, BYTE PTR [r15]
	movaps	xmm14, XMMWORD PTR [rsp+160]
	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A[rbx+rcx+1228], al
	movzx	eax, BYTE PTR [r12]
	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A[rbx+rcx+1231], al
$LN3@ComputeTri:

; 1195 :       }
; 1196 :    }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 312				; 00000138H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z ENDP ; ImGuizmo::ComputeTripodAxisAndVisibility
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?ComputeSnap@ImGuizmo@@YAXPEAMM@Z
_TEXT	SEGMENT
value$ = 80
snap$ = 88
?ComputeSnap@ImGuizmo@@YAXPEAMM@Z PROC			; ImGuizmo::ComputeSnap, COMDAT

; 1199 :    {

	push	rbx
	sub	rsp, 64					; 00000040H

; 1200 :       if (snap <= FLT_EPSILON)

	movss	xmm0, DWORD PTR __real@34000000
	mov	rbx, rcx
	movaps	XMMWORD PTR [rsp+32], xmm7
	movaps	xmm7, xmm1
	comiss	xmm0, xmm7
	jae	SHORT $LN5@ComputeSna
	movaps	XMMWORD PTR [rsp+48], xmm6

; 1205 :       float modulo = fmodf(*value, snap);

	movss	xmm6, DWORD PTR [rcx]
	movaps	xmm0, xmm6
	call	fmodf
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1205 :       float modulo = fmodf(*value, snap);

	movaps	xmm2, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1207 :       if (moduloRatio < snapTension)

	movss	xmm0, DWORD PTR __real@3f000000
	divss	xmm1, xmm7
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@ComputeSna

; 1208 :       {
; 1209 :          *value -= modulo;

	subss	xmm6, xmm2

; 1210 :       }

	jmp	SHORT $LN16@ComputeSna
$LN3@ComputeSna:

; 1211 :       else if (moduloRatio > (1.f - snapTension))

	comiss	xmm1, xmm0
	jbe	SHORT $LN15@ComputeSna

; 1212 :       {
; 1213 :          *value = *value - modulo + snap * ((*value < 0.f) ? -1.f : 1.f);

	xorps	xmm0, xmm0
	comiss	xmm0, xmm6
	jbe	SHORT $LN7@ComputeSna
	movss	xmm0, DWORD PTR __real@bf800000
	jmp	SHORT $LN8@ComputeSna
$LN7@ComputeSna:
	movss	xmm0, DWORD PTR __real@3f800000
$LN8@ComputeSna:
	subss	xmm6, xmm2
	mulss	xmm0, xmm7
	addss	xmm6, xmm0
$LN16@ComputeSna:
	movss	DWORD PTR [rbx], xmm6
$LN15@ComputeSna:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN5@ComputeSna:

; 1214 :       }
; 1215 :    }

	movaps	xmm7, XMMWORD PTR [rsp+32]
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
?ComputeSnap@ImGuizmo@@YAXPEAMM@Z ENDP			; ImGuizmo::ComputeSnap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z
_TEXT	SEGMENT
value$ = 144
snap$ = 152
?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z PROC	; ImGuizmo::ComputeSnap, COMDAT

; 1217 :    {

	mov	rax, rsp
	push	rbx
	sub	rsp, 128				; 00000080H
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rbx, rcx
	movaps	XMMWORD PTR [rax-40], xmm7

; 1200 :       if (snap <= FLT_EPSILON)

	movss	xmm7, DWORD PTR __real@bf800000
	movaps	XMMWORD PTR [rax-56], xmm8

; 1218 :       for (int i = 0; i < 3; i++)
; 1219 :       {
; 1220 :          ComputeSnap(&value[i], snap[i]);

	movss	xmm8, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rax-72], xmm9

; 1200 :       if (snap <= FLT_EPSILON)

	movss	xmm9, DWORD PTR __real@3f000000
	movaps	XMMWORD PTR [rax-104], xmm12
	xorps	xmm12, xmm12

; 1217 :    {

	mov	QWORD PTR [rax+8], rdi
	mov	rdi, rdx
	movaps	XMMWORD PTR [rax-88], xmm10

; 1200 :       if (snap <= FLT_EPSILON)

	movss	xmm10, DWORD PTR __real@34000000
	comiss	xmm10, xmm8
	jae	SHORT $LN2@ComputeSna

; 1205 :       float modulo = fmodf(*value, snap);

	movss	xmm6, DWORD PTR [rcx]
	movaps	xmm1, xmm8
	movaps	xmm0, xmm6
	call	fmodf
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1205 :       float modulo = fmodf(*value, snap);

	movaps	xmm2, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1206 :       float moduloRatio = fabsf(modulo) / snap;

	divss	xmm1, xmm8

; 1207 :       if (moduloRatio < snapTension)

	comiss	xmm9, xmm1
	jbe	SHORT $LN10@ComputeSna

; 1208 :       {
; 1209 :          *value -= modulo;

	subss	xmm6, xmm2

; 1210 :       }

	jmp	SHORT $LN44@ComputeSna
$LN10@ComputeSna:

; 1211 :       else if (moduloRatio > (1.f - snapTension))

	comiss	xmm1, xmm9
	jbe	SHORT $LN2@ComputeSna

; 1212 :       {
; 1213 :          *value = *value - modulo + snap * ((*value < 0.f) ? -1.f : 1.f);

	comiss	xmm12, xmm6
	jbe	SHORT $LN14@ComputeSna
	movaps	xmm0, xmm7
	jmp	SHORT $LN15@ComputeSna
$LN14@ComputeSna:
	movss	xmm0, DWORD PTR __real@3f800000
$LN15@ComputeSna:
	subss	xmm6, xmm2
	mulss	xmm0, xmm8
	addss	xmm6, xmm0
$LN44@ComputeSna:

; 1218 :       for (int i = 0; i < 3; i++)
; 1219 :       {
; 1220 :          ComputeSnap(&value[i], snap[i]);

	movss	DWORD PTR [rbx], xmm6
$LN2@ComputeSna:
	movss	xmm8, DWORD PTR [rdi+4]

; 1200 :       if (snap <= FLT_EPSILON)

	comiss	xmm10, xmm8
	jae	SHORT $LN24@ComputeSna

; 1205 :       float modulo = fmodf(*value, snap);

	movss	xmm6, DWORD PTR [rbx+4]
	movaps	xmm1, xmm8
	movaps	xmm0, xmm6
	call	fmodf
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1205 :       float modulo = fmodf(*value, snap);

	movaps	xmm2, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1206 :       float moduloRatio = fabsf(modulo) / snap;

	divss	xmm1, xmm8

; 1207 :       if (moduloRatio < snapTension)

	comiss	xmm9, xmm1
	jbe	SHORT $LN21@ComputeSna

; 1208 :       {
; 1209 :          *value -= modulo;

	subss	xmm6, xmm2

; 1210 :       }

	jmp	SHORT $LN45@ComputeSna
$LN21@ComputeSna:

; 1211 :       else if (moduloRatio > (1.f - snapTension))

	comiss	xmm1, xmm9
	jbe	SHORT $LN24@ComputeSna

; 1212 :       {
; 1213 :          *value = *value - modulo + snap * ((*value < 0.f) ? -1.f : 1.f);

	comiss	xmm12, xmm6
	jbe	SHORT $LN22@ComputeSna
	movaps	xmm0, xmm7
	jmp	SHORT $LN23@ComputeSna
$LN22@ComputeSna:
	movss	xmm0, DWORD PTR __real@3f800000
$LN23@ComputeSna:
	subss	xmm6, xmm2
	mulss	xmm0, xmm8
	addss	xmm6, xmm0
$LN45@ComputeSna:

; 1218 :       for (int i = 0; i < 3; i++)
; 1219 :       {
; 1220 :          ComputeSnap(&value[i], snap[i]);

	movss	DWORD PTR [rbx+4], xmm6
$LN24@ComputeSna:
	movss	xmm8, DWORD PTR [rdi+8]
	mov	rdi, QWORD PTR [rsp+144]

; 1200 :       if (snap <= FLT_EPSILON)

	comiss	xmm10, xmm8
	movaps	xmm10, XMMWORD PTR [rsp+48]
	jae	SHORT $LN29@ComputeSna

; 1205 :       float modulo = fmodf(*value, snap);

	movss	xmm6, DWORD PTR [rbx+8]
	movaps	xmm1, xmm8
	movaps	xmm0, xmm6
	call	fmodf
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm1, xmm0
	andps	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1206 :       float moduloRatio = fabsf(modulo) / snap;

	divss	xmm1, xmm8

; 1207 :       if (moduloRatio < snapTension)

	comiss	xmm9, xmm1
	jbe	SHORT $LN26@ComputeSna

; 1208 :       {
; 1209 :          *value -= modulo;

	subss	xmm6, xmm0

; 1210 :       }

	jmp	SHORT $LN46@ComputeSna
$LN26@ComputeSna:

; 1211 :       else if (moduloRatio > (1.f - snapTension))

	comiss	xmm1, xmm9
	jbe	SHORT $LN29@ComputeSna

; 1212 :       {
; 1213 :          *value = *value - modulo + snap * ((*value < 0.f) ? -1.f : 1.f);

	comiss	xmm12, xmm6
	ja	SHORT $LN28@ComputeSna
	movss	xmm7, DWORD PTR __real@3f800000
$LN28@ComputeSna:
	subss	xmm6, xmm0
	mulss	xmm7, xmm8
	addss	xmm6, xmm7
$LN46@ComputeSna:

; 1221 :       }
; 1222 :    }

	movss	DWORD PTR [rbx+8], xmm6
$LN29@ComputeSna:
	movaps	xmm6, XMMWORD PTR [rsp+112]
	movaps	xmm7, XMMWORD PTR [rsp+96]
	movaps	xmm8, XMMWORD PTR [rsp+80]
	movaps	xmm9, XMMWORD PTR [rsp+64]
	movaps	xmm12, XMMWORD PTR [rsp+32]
	add	rsp, 128				; 00000080H
	pop	rbx
	ret	0
?ComputeSnap@ImGuizmo@@YAXAEAUvec_t@1@PEBM@Z ENDP	; ImGuizmo::ComputeSnap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?ComputeAngleOnPlan@ImGuizmo@@YAMXZ
_TEXT	SEGMENT
?ComputeAngleOnPlan@ImGuizmo@@YAMXZ PROC		; ImGuizmo::ComputeAngleOnPlan, COMDAT

; 1225 :    {

	mov	rax, rsp
	sub	rsp, 200				; 000000c8H

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1012
	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1008
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1004
	movaps	XMMWORD PTR [rax-40], xmm7

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1020
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	xmm3, xmm7
	movss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1024
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	xmm0, xmm8
	movss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1028
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	xmm1, xmm9

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm10, DWORD PTR __real@bf800000
	movaps	XMMWORD PTR [rax-104], xmm11
	movss	xmm11, DWORD PTR __real@34000000
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+64], xmm13

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1096
	movaps	XMMWORD PTR [rsp+48], xmm14
	movss	xmm14, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1088
	mulss	xmm3, xmm14
	movaps	XMMWORD PTR [rsp+32], xmm15
	movss	xmm15, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1092
	mulss	xmm0, xmm15
	mulss	xmm1, xmm13
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm0, xmm3
	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	comiss	xmm11, xmm0
	jbe	SHORT $LN6@ComputeAng

; 911  :       {
; 912  :          return -1.0f;

	movaps	xmm2, xmm10
	jmp	SHORT $LN5@ComputeAng
$LN6@ComputeAng:

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movaps	xmm2, xmm14
	movaps	xmm0, xmm15
	mulss	xmm2, xmm6
	movaps	xmm1, xmm13
	mulss	xmm0, xmm5
	mulss	xmm1, xmm4
	addss	xmm2, xmm0
	addss	xmm2, xmm1

; 907  :       const float numer = plan.Dot3(rOrigin) - plan.w;

	subss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1100

; 913  :       }
; 914  : 
; 915  :       return -(numer / denom);

	divss	xmm2, xmm3
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
$LN5@ComputeAng:

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm7, xmm2
	mulss	xmm9, xmm2
	mulss	xmm8, xmm2

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm7, xmm6
	addss	xmm9, xmm4
	addss	xmm8, xmm5

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	subss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460
	subss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468
	subss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464
	movaps	xmm0, xmm7
	mulss	xmm0, xmm7

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm9

; 281  :    vec_t Normalized(const vec_t& v) { vec_t res; res = v; res.Normalize(); return res; }

	movaps	xmm2, xmm8

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm1, xmm9

; 281  :    vec_t Normalized(const vec_t& v) { vec_t res; res = v; res.Normalize(); return res; }

	mulss	xmm2, xmm8

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN78@ComputeAng
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN79@ComputeAng
$LN78@ComputeAng:
	movaps	xmm0, xmm2
	call	sqrtf
$LN79@ComputeAng:

; 243  :          x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1156

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, xmm11

; 243  :          x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1160

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movss	xmm6, DWORD PTR __real@3f800000
	movaps	xmm11, xmm6
	divss	xmm11, xmm0

; 243  :          x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm2
	mulss	xmm0, xmm15

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movaps	xmm12, xmm11
	mulss	xmm12, xmm7
	movaps	xmm7, xmm11
	mulss	xmm7, xmm8

; 243  :          x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm8, xmm1
	mulss	xmm8, xmm13

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm11, xmm9

; 244  :          y = v1.z * v2.x - v1.x * v2.z;

	movaps	xmm9, xmm2
	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1152
	subss	xmm8, xmm0
	movaps	xmm0, xmm2
	mulss	xmm9, xmm14
	mulss	xmm0, xmm13

; 245  :          z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm13, xmm2
	mulss	xmm13, xmm15
	subss	xmm9, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm14
	subss	xmm13, xmm0
	movaps	xmm2, xmm9

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm8

; 245  :          z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm2, xmm9

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm0, xmm8
	movaps	xmm1, xmm13
	mulss	xmm1, xmm13
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN76@ComputeAng
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN77@ComputeAng
$LN76@ComputeAng:
	movaps	xmm0, xmm2
	call	sqrtf
$LN77@ComputeAng:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000
	movaps	xmm1, xmm6

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	movaps	xmm2, xmm12
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1152

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm1, xmm0

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1156

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mulss	xmm8, xmm1

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm9, xmm1

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	addss	xmm2, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm13, xmm1

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	movaps	xmm1, xmm11
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1160
	addss	xmm2, xmm1

; 188  :    template <typename T> T Clamp(T x, T y, T z) { return ((x < y) ? y : ((x > z) ? z : x)); }

	comiss	xmm10, xmm2
	jbe	SHORT $LN56@ComputeAng
	movaps	xmm0, xmm10
	jmp	SHORT $LN55@ComputeAng
$LN56@ComputeAng:
	movaps	xmm0, xmm6
	minss	xmm0, xmm2
$LN55@ComputeAng:

; 1226 :       const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);
; 1227 :       vec_t localPos = Normalized(gContext.mRayOrigin + gContext.mRayVector * len - gContext.mModel.v.position);
; 1228 : 
; 1229 :       vec_t perpendicularVector;
; 1230 :       perpendicularVector.Cross(gContext.mRotationVectorSource, gContext.mTranslationPlan);
; 1231 :       perpendicularVector.Normalize();
; 1232 :       float acosAngle = Clamp(Dot(localPos, gContext.mRotationVectorSource), -1.f, 1.f);
; 1233 :       float angle = acosf(acosAngle);

	call	acosf
	mulss	xmm7, xmm9
	xorps	xmm1, xmm1

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	mulss	xmm12, xmm8
	mulss	xmm11, xmm13
	addss	xmm7, xmm12
	addss	xmm7, xmm11

; 1234 :       angle *= (Dot(localPos, perpendicularVector) < 0.f) ? 1.f : -1.f;

	comiss	xmm1, xmm7
	ja	SHORT $LN4@ComputeAng
	movaps	xmm6, xmm10
$LN4@ComputeAng:

; 1235 :       return angle;
; 1236 :    }

	movaps	xmm13, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+200]
	movaps	xmm7, XMMWORD PTR [r11-40]
	movaps	xmm8, XMMWORD PTR [r11-56]
	movaps	xmm9, XMMWORD PTR [r11-72]
	movaps	xmm10, XMMWORD PTR [r11-88]
	movaps	xmm11, XMMWORD PTR [r11-104]
	movaps	xmm12, XMMWORD PTR [r11-120]
	movaps	xmm14, XMMWORD PTR [rsp+48]
	movaps	xmm15, XMMWORD PTR [rsp+32]
	mulss	xmm6, xmm0
	movaps	xmm0, xmm6
	movaps	xmm6, XMMWORD PTR [r11-24]
	mov	rsp, r11
	ret	0
?ComputeAngleOnPlan@ImGuizmo@@YAMXZ ENDP		; ImGuizmo::ComputeAngleOnPlan
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?DrawRotationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
_TEXT	SEGMENT
colors$1$ = 0
$T6 = 0
circlePos$1$ = 8
$T7 = 8
$T8 = 8
axis$1$ = 16
tv5293 = 24
$T9 = 24
type$1$ = 32
tv5596 = 36
op$1$ = 40
tv5766 = 44
tv5302 = 48
tv5789 = 56
tv5784 = 64
drawList$1$ = 72
clip_rect$10 = 80
clip_rect$11 = 80
cameraToModelNormalized$ = 80
axisPos$12 = 96
rotateVectorMatrix$13 = 112
viewInverse$14 = 112
colors$ = 176
circlePos$15 = 208
tmps$16 = 736
__$ArrayPad$ = 1248
op$ = 1472
type$ = 1480
?DrawRotationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z PROC	; ImGuizmo::DrawRotationGizmo, COMDAT

; 1239 :    {

	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 1504				; 000005e0H
	lea	rbp, QWORD PTR [rsp+80]
	mov	QWORD PTR [rbp+1472], rbx
	mov	QWORD PTR [rbp+1480], rsi
	mov	QWORD PTR [rbp+1488], rdi
	movaps	XMMWORD PTR [rbp+1408], xmm6
	movaps	XMMWORD PTR [rbp+1392], xmm7
	movaps	XMMWORD PTR [rbp+1376], xmm8
	movaps	XMMWORD PTR [rbp+1360], xmm9
	movaps	XMMWORD PTR [rbp+1344], xmm10
	movaps	XMMWORD PTR [rbp+1328], xmm11
	movaps	XMMWORD PTR [rbp+1312], xmm12
	movaps	XMMWORD PTR [rbp+1296], xmm13
	movaps	XMMWORD PTR [rbp+1280], xmm14
	movaps	XMMWORD PTR [rbp+1264], xmm15
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	mov	DWORD PTR type$1$[rbp], edx
	mov	esi, edx
	mov	DWORD PTR op$1$[rbp], ecx
	mov	edi, ecx

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	cl, 120					; 00000078H

; 1240 :       if(!Intersects(op, ROTATE))

	je	$LN133@DrawRotati

; 1100 :       if (gContext.mbEnable)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1085, 0

; 1241 :       {
; 1242 :          return;
; 1243 :       }
; 1244 :       ImDrawList* drawList = gContext.mDrawList;

	mov	r15, QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A
	mov	QWORD PTR drawList$1$[rbp], r15

; 1100 :       if (gContext.mbEnable)

	je	$LN303@DrawRotati

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+136
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1116 :             colors[0] = (type == MT_ROTATE_SCREEN) ? selectionColor : IM_COL32_WHITE;

	cmp	esi, 11
	mov	r12d, -1				; ffffffffH

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	mov	r8d, eax

; 1116 :             colors[0] = (type == MT_ROTATE_SCREEN) ? selectionColor : IM_COL32_WHITE;

	cmove	r12d, eax
	mov	DWORD PTR colors$1$[rbp], r12d
	mov	DWORD PTR colors$[rbp], r12d

; 1117 :             for (int i = 0; i < 3; i++)
; 1118 :             {
; 1119 :                colors[i + 1] = (type == (int)(MT_ROTATE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	cmp	esi, 8
	jne	SHORT $LN317@DrawRotati
	mov	DWORD PTR colors$[rbp+4], eax
$LN411@DrawRotati:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+56
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	DWORD PTR colors$[rbp+8], eax

; 1119 :                colors[i + 1] = (type == (int)(MT_ROTATE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	cmp	esi, 10
	je	SHORT $LN415@DrawRotati
$LN414@DrawRotati:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+72
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r8d, eax
$LN415@DrawRotati:

; 1119 :                colors[i + 1] = (type == (int)(MT_ROTATE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	mov	DWORD PTR colors$[rbp+12], r8d

; 1120 :             }
; 1121 :             break;
; 1122 :          case SCALEU:
; 1123 :          case SCALE:
; 1124 :             colors[0] = (type == MT_SCALE_XYZ) ? selectionColor : IM_COL32_WHITE;
; 1125 :             for (int i = 0; i < 3; i++)
; 1126 :             {
; 1127 :                colors[i + 1] = (type == (int)(MT_SCALE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);
; 1128 :             }
; 1129 :             break;
; 1130 :          // note: this internal function is only called with three possible values for operation
; 1131 :          default:
; 1132 :             break;
; 1133 :          }
; 1134 :       }

	jmp	SHORT $LN301@DrawRotati
$LN317@DrawRotati:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+40
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	DWORD PTR colors$[rbp+4], eax

; 1119 :                colors[i + 1] = (type == (int)(MT_ROTATE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	cmp	esi, 9
	jne	SHORT $LN411@DrawRotati
	mov	DWORD PTR colors$[rbp+8], r8d
	jmp	SHORT $LN414@DrawRotati
$LN303@DrawRotati:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+152
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	DWORD PTR colors$1$[rbp], eax

; 1140 :             colors[i] = inactiveColor;

	mov	DWORD PTR colors$[rbp], eax
	mov	DWORD PTR colors$[rbp+4], eax
	mov	DWORD PTR colors$[rbp+8], eax
	mov	DWORD PTR colors$[rbp+12], eax
	mov	DWORD PTR colors$[rbp+16], eax
	mov	DWORD PTR colors$[rbp+20], eax
	mov	DWORD PTR colors$[rbp+24], eax
$LN301@DrawRotati:

; 1245 : 
; 1246 :       // colors
; 1247 :       ImU32 colors[7];
; 1248 :       ComputeColors(colors, type, ROTATE);
; 1249 : 
; 1250 :       vec_t cameraToModelNormalized;
; 1251 :       if (gContext.mIsOrthographic)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1432, 0
	je	SHORT $LN12@DrawRotati

; 1252 :       {
; 1253 :          matrix_t viewInverse;
; 1254 :          viewInverse.Inverse(*(matrix_t*)&gContext.mViewMat);

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+284
	lea	rcx, QWORD PTR viewInverse$14[rbp]
	call	?Inverse@matrix_t@ImGuizmo@@QEAAMAEBU12@_N@Z ; ImGuizmo::matrix_t::Inverse

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movss	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm6, DWORD PTR viewInverse$14[rbp+32]
	movss	xmm7, DWORD PTR viewInverse$14[rbp+36]
	xorps	xmm6, xmm0
	movss	xmm8, DWORD PTR viewInverse$14[rbp+40]
	xorps	xmm7, xmm0

; 1255 :          cameraToModelNormalized = -viewInverse.v.dir;
; 1256 :       }

	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	xorps	xmm8, xmm0

; 1255 :          cameraToModelNormalized = -viewInverse.v.dir;
; 1256 :       }

	movss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464
	movss	xmm14, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460
	jmp	$LN13@DrawRotati
$LN12@DrawRotati:

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm14, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460
	movss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464
	movaps	xmm6, xmm14
	subss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+940
	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468
	movaps	xmm7, xmm13
	subss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+944
	movaps	xmm8, xmm12
	subss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+948

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	movaps	xmm2, xmm7
	mulss	xmm2, xmm7
	movaps	xmm1, xmm8
	mulss	xmm1, xmm8
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN469@DrawRotati
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN470@DrawRotati
$LN469@DrawRotati:
	movaps	xmm0, xmm2
	call	sqrtf
$LN470@DrawRotati:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm6, xmm1
	mulss	xmm7, xmm1
	mulss	xmm8, xmm1
$LN13@DrawRotati:

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+572
	lea	rax, QWORD PTR axisPos$12[rbp]

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+560
	movaps	xmm5, xmm6
	mulss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+540
	movaps	xmm0, xmm7

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	mov	edx, edi

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movzx	ebx, BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+556
	mov	r13d, 4
	mov	r8, 1152921504606846960			; 0ffffffffffffff0H

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	shr	edx, 6

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+564

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	and	dl, 1

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+568
	xor	r12d, r12d
	movss	xmm15, DWORD PTR __real@3f000000
	addss	xmm5, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+544
	movss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412
	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
	movss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404
	mulss	xmm1, xmm8
	mov	QWORD PTR tv5302[rbp], rax
	lea	rax, QWORD PTR colors$[rbp+12]
	mulss	xmm0, xmm6

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	mov	DWORD PTR tv5596[rbp], edx

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	addss	xmm5, xmm1

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	mulss	xmm4, xmm7
	mov	DWORD PTR axis$1$[rbp], r12d
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+576
	mulss	xmm1, xmm8
	mov	DWORD PTR tv5766[rbp], r13d
	addss	xmm4, xmm0

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	mulss	xmm3, xmm7
	mov	QWORD PTR tv5293[rbp], rax
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+548
	mulss	xmm0, xmm6
	addss	xmm4, xmm1

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	mulss	xmm2, xmm7
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+580
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+552
	movss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+864
	mulss	xmm1, xmm8
	mulss	xmm0, xmm6
	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+860
	addss	xmm3, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+584
	mulss	xmm1, xmm8
	addss	xmm2, xmm0

; 1257 :       else
; 1258 :       {
; 1259 :          cameraToModelNormalized = Normalized(gContext.mModel.v.position - gContext.mCameraEye);
; 1260 :       }
; 1261 : 
; 1262 :       cameraToModelNormalized.TransformVector(gContext.mModelInverse);
; 1263 : 
; 1264 :       gContext.mRadiusSquareCenter = screenRotateSize * gContext.mHeight;

	movss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416

; 454  :       x = out.x;

	movss	DWORD PTR cameraToModelNormalized$[rbp], xmm5

; 1257 :       else
; 1258 :       {
; 1259 :          cameraToModelNormalized = Normalized(gContext.mModel.v.position - gContext.mCameraEye);
; 1260 :       }
; 1261 : 
; 1262 :       cameraToModelNormalized.TransformVector(gContext.mModelInverse);
; 1263 : 
; 1264 :       gContext.mRadiusSquareCenter = screenRotateSize * gContext.mHeight;

	movaps	xmm5, xmm8
	mulss	xmm5, DWORD PTR __real@3d75c28f

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	addss	xmm2, xmm1

; 455  :       y = out.y;

	movss	DWORD PTR cameraToModelNormalized$[rbp+4], xmm4

; 456  :       z = out.z;

	movss	DWORD PTR cameraToModelNormalized$[rbp+8], xmm3

; 1257 :       else
; 1258 :       {
; 1259 :          cameraToModelNormalized = Normalized(gContext.mModel.v.position - gContext.mCameraEye);
; 1260 :       }
; 1261 : 
; 1262 :       cameraToModelNormalized.TransformVector(gContext.mModelInverse);
; 1263 : 
; 1264 :       gContext.mRadiusSquareCenter = screenRotateSize * gContext.mHeight;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1036, xmm5

; 457  :       w = out.w;

	movss	DWORD PTR cameraToModelNormalized$[rbp+12], xmm2
	npad	10
$LL4@DrawRotati:

; 1268 :       {
; 1269 :          if(!Intersects(op, static_cast<OPERATION>(ROTATE_Z >> axis)))

	mov	eax, 32					; 00000020H
	mov	ecx, r12d
	shr	eax, cl

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	eax, edi

; 1268 :       {
; 1269 :          if(!Intersects(op, static_cast<OPERATION>(ROTATE_Z >> axis)))

	je	$LN2@DrawRotati

; 1270 :          {
; 1271 :             continue;
; 1272 :          }
; 1273 :          const bool usingAxis = (gContext.mbUsing && type == MT_ROTATE_Z - axis);

	test	bl, bl
	je	SHORT $LN23@DrawRotati
	lea	eax, DWORD PTR [r13+6]
	cmp	esi, eax
	jne	SHORT $LN23@DrawRotati
	mov	sil, 1
	jmp	SHORT $LN24@DrawRotati
$LN23@DrawRotati:
	xor	sil, sil
$LN24@DrawRotati:

; 1274 :          const int circleMul = (hasRSC && !usingAxis ) ? 1 : 2;

	test	dl, dl
	je	SHORT $LN25@DrawRotati
	mov	ebx, 1
	test	sil, sil
	je	SHORT $LN26@DrawRotati
$LN25@DrawRotati:
	mov	ebx, 2
$LN26@DrawRotati:

; 1275 : 
; 1276 :          ImVec2* circlePos = (ImVec2*)alloca(sizeof(ImVec2) * (circleMul * halfCircleSegmentCount + 1));

	mov	eax, ebx
	shl	eax, 6
	mov	edi, eax
	lea	r14d, DWORD PTR [rax+1]
	lea	rax, QWORD PTR [rax*8+8]
	lea	rcx, QWORD PTR [rax+15]
	cmp	rcx, rax
	ja	SHORT $LN468@DrawRotati
	mov	rcx, r8
$LN468@DrawRotati:
	and	rcx, -16
	mov	rax, rcx
	call	__chkstk
	sub	rsp, rcx

; 1277 : 
; 1278 :          float angleStart = atan2f(cameraToModelNormalized[(4 - axis) % 3], cameraToModelNormalized[(3 - axis) % 3]) + ZPI * 0.5f;

	mov	ecx, r13d
	lea	rax, QWORD PTR [rsp+80]
	mov	QWORD PTR circlePos$1$[rbp], rax
	mov	eax, -1431655765			; aaaaaaabH
	mul	r13d
	shr	edx, 1
	lea	eax, DWORD PTR [rdx+rdx*2]
	sub	ecx, eax
	mov	eax, 1431655766				; 55555556H
	movsxd	r8, ecx
	lea	ecx, DWORD PTR [r13-1]
	imul	ecx
	movss	xmm0, DWORD PTR cameraToModelNormalized$[rbp+r8*4]
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	lea	eax, DWORD PTR [rdx+rdx*2]
	sub	ecx, eax
	movsxd	rax, ecx
	movss	xmm1, DWORD PTR cameraToModelNormalized$[rbp+rax*4]
	call	atan2f
	mov	r13, QWORD PTR tv5302[rbp]
	lea	r8d, DWORD PTR [r12+2]
	lea	ecx, DWORD PTR [r8-1]
	movd	xmm13, ebx
	mov	rbx, QWORD PTR circlePos$1$[rbp]
	mov	eax, 1431655766				; 55555556H
	imul	ecx
	movd	xmm14, edi
	movaps	xmm12, xmm0
	addss	xmm12, DWORD PTR __real@3fc90fdb
	cvtdq2ps xmm13, xmm13
	xor	r15d, r15d
	mov	eax, edx

; 1283 :             vec_t axisPos = makeVect(cosf(ng), sinf(ng), 0.f);

	mov	QWORD PTR axisPos$12[rbp+8], r15
	shr	eax, 31
	add	edx, eax
	mulss	xmm13, DWORD PTR __real@40490fdb
	cvtdq2ps xmm14, xmm14
	lea	eax, DWORD PTR [rdx+rdx*2]
	sub	ecx, eax
	movsxd	rax, ecx
	mov	QWORD PTR tv5789[rbp], rax
	mov	eax, 1431655766				; 55555556H
	mov	rdi, QWORD PTR tv5789[rbp]
	imul	r8d
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	lea	eax, DWORD PTR [rdx+rdx*2]
	sub	r8d, eax
	movsxd	r12, r8d
	npad	9
$LL7@DrawRotati:

; 1281 :          {
; 1282 :             float ng = angleStart + (float)circleMul * ZPI * ((float)i / (float)(circleMul * halfCircleSegmentCount));

	xorps	xmm6, xmm6
	cvtsi2ss xmm6, r15d
	divss	xmm6, xmm14
	mulss	xmm6, xmm13
	addss	xmm6, xmm12

; 1283 :             vec_t axisPos = makeVect(cosf(ng), sinf(ng), 0.f);

	movaps	xmm0, xmm6
	call	cosf
	movss	DWORD PTR axisPos$12[rbp], xmm0
	movaps	xmm0, xmm6
	call	sinf

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm3, xmm15

; 1283 :             vec_t axisPos = makeVect(cosf(ng), sinf(ng), 0.f);

	movss	DWORD PTR axisPos$12[rbp+4], xmm0

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movaps	xmm7, xmm6
	mulss	xmm7, DWORD PTR [r13]
	movaps	xmm5, xmm6

; 1279 : 
; 1280 :          for (int i = 0; i < circleMul * halfCircleSegmentCount + 1; i++)

	inc	r15d

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm5, DWORD PTR axisPos$12[rbp+rdi*4]
	movss	xmm0, DWORD PTR __real@3f99999a
	mulss	xmm6, DWORD PTR axisPos$12[rbp+r12*4]
	mulss	xmm7, xmm0

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm6, xmm0
	mulss	xmm5, xmm0

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movaps	xmm2, xmm7
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+744
	movaps	xmm4, xmm7
	mulss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+732
	movaps	xmm1, xmm6
	mulss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+736
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+760
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+776
	addss	xmm2, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+748
	mulss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+752
	addss	xmm4, xmm0

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm0, DWORD PTR __real@3f800000

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm1
	movaps	xmm1, xmm6
	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+768
	addss	xmm7, xmm5
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+764
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+792
	addss	xmm7, xmm6
	addss	xmm4, xmm1

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+780

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+784

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm4, xmm3
	mulss	xmm7, xmm3

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm4, xmm15

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm7, xmm15

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm4, xmm9
	subss	xmm0, xmm7

; 808  :       trans.y *= size.y;

	addss	xmm4, xmm11
	mulss	xmm0, xmm8

; 1285 :             circlePos[i] = worldToPos(pos, gContext.mMVP);

	movss	DWORD PTR [rbx], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1285 :             circlePos[i] = worldToPos(pos, gContext.mMVP);

	movss	DWORD PTR [rbx+4], xmm0
	add	rbx, 8
	cmp	r15d, r14d
	jge	SHORT $LN478@DrawRotati

; 1279 : 
; 1280 :          for (int i = 0; i < circleMul * halfCircleSegmentCount + 1; i++)

	movss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416
	movss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412
	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
	movss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404
	jmp	$LL7@DrawRotati
$LN478@DrawRotati:

; 1286 :          }
; 1287 :          if (!gContext.mbUsing || usingAxis)

	movzx	ebx, BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084
	mov	r15, QWORD PTR drawList$1$[rbp]
	mov	r13d, DWORD PTR tv5766[rbp]
	mov	rdi, QWORD PTR circlePos$1$[rbp]
	test	bl, bl
	je	SHORT $LN16@DrawRotati
	test	sil, sil
	je	SHORT $LN15@DrawRotati
$LN16@DrawRotati:

; 1288 :          {
; 1289 :             drawList->AddPolyline(circlePos, circleMul* halfCircleSegmentCount + 1, colors[3 - axis], false, gContext.mStyle.RotationLineThickness);

	mov	r9, QWORD PTR tv5293[rbp]
	mov	r8d, r14d
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+16
	mov	rdx, rdi
	movss	DWORD PTR [rsp+40], xmm0
	mov	rcx, r15
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, DWORD PTR [r9]
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
	movzx	ebx, BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084
$LN15@DrawRotati:

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm14, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm3, xmm15

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464
	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468
	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+872
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+888
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+904

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+860

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+864

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movaps	xmm4, xmm6

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 807  :       trans.x *= size.x;

	movss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416

; 808  :       trans.y *= size.y;

	movss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm1, xmm12
	mulss	xmm2, xmm14

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	mulss	xmm4, xmm14

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm0, xmm13
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+876
	mulss	xmm0, xmm13
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+892
	addss	xmm4, xmm0
	mulss	xmm1, xmm12
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+880
	mulss	xmm0, xmm13
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+920
	addss	xmm4, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+896
	mulss	xmm1, xmm12

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+908
	movaps	xmm2, xmm7
	mulss	xmm2, xmm14

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm4, xmm3

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm0
	xorps	xmm0, xmm0

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm4, xmm15

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm1

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm4, xmm9

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+912

; 808  :       trans.y *= size.y;

	addss	xmm4, xmm11

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm4, DWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm2, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	mulss	xmm4, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm1, xmm2

; 807  :       trans.x *= size.x;

	mulss	xmm1, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm1, xmm10

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm1, DWORD PTR [rdi+4]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	addss	xmm1, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1292 :          float radiusAxis = sqrtf((ImLengthSqr(worldToPos(gContext.mModel.v.position, gContext.mViewProjection) - circlePos[0])));

	ucomiss	xmm0, xmm1
	ja	SHORT $LN466@DrawRotati
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	jmp	SHORT $LN467@DrawRotati
$LN466@DrawRotati:
	movaps	xmm0, xmm1
	call	sqrtf
$LN467@DrawRotati:

; 1293 :          if (radiusAxis > gContext.mRadiusSquareCenter)

	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1036
	mov	r8, 1152921504606846960			; 0ffffffffffffff0H
	comiss	xmm0, xmm5
	mov	esi, DWORD PTR type$1$[rbp]
	mov	r12d, DWORD PTR axis$1$[rbp]
	mov	edx, DWORD PTR tv5596[rbp]
	mov	edi, DWORD PTR op$1$[rbp]
	jbe	SHORT $LN2@DrawRotati

; 1294 :          {
; 1295 :             gContext.mRadiusSquareCenter = radiusAxis;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1036, xmm0
	movaps	xmm5, xmm0
$LN2@DrawRotati:

; 1265 : 
; 1266 :       bool hasRSC = Intersects(op, ROTATE_SCREEN);
; 1267 :       for (int axis = 0; axis < 3; axis++)

	add	QWORD PTR tv5302[rbp], 4
	inc	r12d
	sub	QWORD PTR tv5293[rbp], 4
	dec	r13d
	mov	DWORD PTR axis$1$[rbp], r12d
	mov	DWORD PTR tv5766[rbp], r13d
	cmp	r13d, 1
	jg	$LL4@DrawRotati

; 1296 :          }
; 1297 :       }
; 1298 :       if(hasRSC && (!gContext.mbUsing || type == MT_ROTATE_SCREEN))

	mov	r12d, DWORD PTR colors$1$[rbp]
	test	dl, dl
	je	$LN480@DrawRotati
	test	bl, bl
	je	SHORT $LN19@DrawRotati
	cmp	esi, 11
	jne	$LN480@DrawRotati
$LN19@DrawRotati:

; 1299 :       {
; 1300 :          drawList->AddCircle(worldToPos(gContext.mModel.v.position, gContext.mViewProjection), gContext.mRadiusSquareCenter, colors[0], 64, gContext.mStyle.RotationOuterLineThickness);

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+20

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movaps	xmm3, xmm6

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+872

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm4, xmm15

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+904

; 1299 :       {
; 1300 :          drawList->AddCircle(worldToPos(gContext.mModel.v.position, gContext.mViewProjection), gContext.mRadiusSquareCenter, colors[0], 64, gContext.mStyle.RotationOuterLineThickness);

	movss	DWORD PTR $T6[rbp], xmm0

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+888
	mulss	xmm2, xmm14
	mulss	xmm0, xmm13

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	mulss	xmm3, xmm14

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm1, xmm12
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+876
	mulss	xmm0, xmm13
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+892
	mulss	xmm1, xmm12
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+880
	mulss	xmm0, xmm13
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+920
	addss	xmm3, xmm1

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm4, xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movaps	xmm2, xmm7
	mulss	xmm2, xmm14
	addss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+908

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm0

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm0, DWORD PTR __real@3f800000

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm3, xmm4

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm3, xmm15

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm3, xmm9

; 808  :       trans.y *= size.y;

	addss	xmm3, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T9[rbp], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+896
	movaps	xmm1, xmm3
	mulss	xmm1, xmm12
	addss	xmm2, xmm1
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+912

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm4

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm2, xmm15

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm0, xmm2

; 807  :       trans.x *= size.x;

	mulss	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, xmm10
	movss	DWORD PTR $T9[rbp+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1484 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	test	r12d, -16777216				; ff000000H
	je	$LN482@DrawRotati
	comiss	xmm15, xmm5
	ja	$LN482@DrawRotati

; 1485 :         return;
; 1486 : 
; 1487 :     if (num_segments <= 0)
; 1488 :     {
; 1489 :         // Use arc with automatic segment count
; 1490 :         _PathArcToFastEx(center, radius - 0.5f, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);
; 1491 :         _Path.Size--;
; 1492 :     }
; 1493 :     else
; 1494 :     {
; 1495 :         // Explicit segment count (still clamp to avoid drawing insanely tessellated shapes)
; 1496 :         num_segments = ImClamp(num_segments, 3, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX);
; 1497 : 
; 1498 :         // Because we are filling a closed shape we remove 1 from the count of segments/points
; 1499 :         const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
; 1500 :         PathArcTo(center, radius - 0.5f, 0.0f, a_max, num_segments - 1);

	subss	xmm5, xmm15

; 1178 :     if (radius < 0.5f)

	lea	rdx, QWORD PTR $T9[rbp]
	comiss	xmm15, xmm5
	jbe	SHORT $LN224@DrawRotati

; 1179 :     {
; 1180 :         _Path.push_back(center);

	lea	rbx, QWORD PTR [r15+120]
	mov	rcx, rbx
	call	?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 1181 :         return;

	jmp	SHORT $LN227@DrawRotati
$LN224@DrawRotati:

; 1182 :     }
; 1183 : 
; 1184 :     if (num_segments > 0)
; 1185 :     {
; 1186 :         _PathArcToN(center, radius, a_min, a_max, num_segments);

	movss	xmm0, DWORD PTR __real@40c5eb9c
	xorps	xmm3, xmm3
	mov	DWORD PTR [rsp+40], 63			; 0000003fH
	movaps	xmm2, xmm5
	mov	rcx, r15
	movss	DWORD PTR [rsp+32], xmm0
	call	?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::_PathArcToN
	lea	rbx, QWORD PTR [r15+120]
$LN227@DrawRotati:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	movss	xmm0, DWORD PTR $T6[rbp]
	mov	r9d, r12d
	mov	r8d, DWORD PTR [rbx]
	mov	rcx, r15
	mov	rdx, QWORD PTR [r15+128]
	movss	DWORD PTR [rsp+40], xmm0
	mov	DWORD PTR [rsp+32], 1
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
	xor	r14d, r14d
	mov	DWORD PTR [rbx], r14d
	movss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416
	movss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412
	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
	movss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404
	movzx	ebx, BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084
	movss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+864
	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+860
	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468
	movss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464
	movss	xmm14, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460
$LN480@DrawRotati:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1303 :       if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID) && IsRotateType(type))

	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+896
$LN482@DrawRotati:
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+872
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+904
	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+892
	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+888
	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+880
	test	bl, bl
	je	$LN133@DrawRotati
	mov	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	cmp	eax, -1
	je	SHORT $LN21@DrawRotati
	cmp	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440
	jne	$LN133@DrawRotati
$LN21@DrawRotati:

; 628  :      return type >= MT_ROTATE_X && type <= MT_ROTATE_SCREEN;

	lea	eax, DWORD PTR [rsi-8]

; 1303 :       if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID) && IsRotateType(type))

	cmp	eax, 3
	ja	$LN133@DrawRotati

; 1304 :       {
; 1305 :          ImVec2 circlePos[halfCircleSegmentCount + 1];

	lea	rax, QWORD PTR circlePos$15[rbp]
	mov	ecx, 65					; 00000041H
	npad	8
$LL436@DrawRotati:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 269  :     constexpr ImVec2()                      : x(0.0f), y(0.0f) { }

	mov	QWORD PTR [rax], 0
	lea	rax, QWORD PTR [rax+8]
	sub	rcx, 1
	jne	SHORT $LL436@DrawRotati
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm0, xmm12
	lea	rdi, QWORD PTR circlePos$15[rbp+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	ebx, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	mulss	xmm6, xmm14

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm1, xmm14
	mulss	xmm7, xmm14

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm4, xmm13
	mulss	xmm2, xmm12
	addss	xmm1, xmm4
	mulss	xmm5, xmm13
	mulss	xmm3, xmm12
	addss	xmm7, xmm5
	addss	xmm1, xmm0

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm0, xmm15

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm7, xmm3

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+920
	addss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+912

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm0, xmm1

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+876

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm0

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	mulss	xmm1, xmm13

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm7, xmm15

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm6, xmm1
	addss	xmm6, xmm2
	addss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+908

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm6, xmm0

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm6, xmm15

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm6, xmm9

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm9, DWORD PTR __real@427c0000

; 808  :       trans.y *= size.y;

	addss	xmm6, xmm11
	movss	xmm11, DWORD PTR __real@3f800000
	movaps	xmm0, xmm11
	subss	xmm0, xmm7

; 1306 : 
; 1307 :          circlePos[0] = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);

	movss	DWORD PTR circlePos$15[rbp], xmm6

; 807  :       trans.x *= size.x;

	mulss	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm10, DWORD PTR __real@3f99999a

; 1306 : 
; 1307 :          circlePos[0] = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);

	movss	DWORD PTR circlePos$15[rbp+4], xmm0
$LL10@DrawRotati:

; 1309 :          {
; 1310 :             float ng = gContext.mRotationAngle * ((float)(i - 1) / (float)(halfCircleSegmentCount - 1));

	xorps	xmm2, xmm2
	lea	ecx, DWORD PTR [rbx-1]
	cvtsi2ss xmm2, rcx

; 1311 :             matrix_t rotateVectorMatrix;
; 1312 :             rotateVectorMatrix.RotationAxis(gContext.mTranslationPlan, ng);

	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+1088
	lea	rcx, QWORD PTR rotateVectorMatrix$13[rbp]
	divss	xmm2, xmm9
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1168
	call	?RotationAxis@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@M@Z ; ImGuizmo::matrix_t::RotationAxis

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1156

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1152
	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1160
	movss	xmm0, DWORD PTR rotateVectorMatrix$13[rbp]
	movss	xmm1, DWORD PTR rotateVectorMatrix$13[rbp+32]

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movss	xmm8, DWORD PTR rotateVectorMatrix$13[rbp+16]

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm7, DWORD PTR rotateVectorMatrix$13[rbp+20]

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm6, DWORD PTR rotateVectorMatrix$13[rbp+24]

; 1313 :             vec_t pos;
; 1314 :             pos.TransformPoint(gContext.mRotationVectorSource, rotateVectorMatrix);
; 1315 :             pos *= gContext.mScreenFactor * rotationDisplayFactor;

	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	mulss	xmm1, xmm2

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	mulss	xmm8, xmm4

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	mulss	xmm7, xmm4

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm6, xmm4

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+860

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	mulss	xmm0, xmm3

; 1313 :             vec_t pos;
; 1314 :             pos.TransformPoint(gContext.mRotationVectorSource, rotateVectorMatrix);
; 1315 :             pos *= gContext.mScreenFactor * rotationDisplayFactor;

	mulss	xmm5, xmm10

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm8, xmm0

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm0, DWORD PTR rotateVectorMatrix$13[rbp+4]
	mulss	xmm0, xmm3
	addss	xmm8, xmm1
	movss	xmm1, DWORD PTR rotateVectorMatrix$13[rbp+36]
	mulss	xmm1, xmm2
	addss	xmm7, xmm0

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	movss	xmm0, DWORD PTR rotateVectorMatrix$13[rbp+8]
	mulss	xmm0, xmm3

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm3, xmm15

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm8, DWORD PTR rotateVectorMatrix$13[rbp+48]

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm7, xmm1

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	movss	xmm1, DWORD PTR rotateVectorMatrix$13[rbp+40]
	mulss	xmm1, xmm2
	addss	xmm6, xmm0

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+872

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+888

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm7, DWORD PTR rotateVectorMatrix$13[rbp+52]

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	addss	xmm6, xmm1

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm8, xmm5

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+904
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	addss	xmm6, DWORD PTR rotateVectorMatrix$13[rbp+56]

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm5

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm2, xmm8

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	addss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	mulss	xmm4, xmm8

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm6, xmm5

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm0, xmm7

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	addss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+876
	mulss	xmm0, xmm7
	mulss	xmm1, xmm6
	addss	xmm4, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+880
	mulss	xmm0, xmm7
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+892
	mulss	xmm1, xmm6
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+920
	addss	xmm4, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+896
	mulss	xmm1, xmm6

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+908
	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+864
	mulss	xmm2, xmm8

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm4, xmm3

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm0

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm4, xmm15

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm1

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+912

; 808  :       trans.y *= size.y;

	addss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm3

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm2, xmm15

; 806  :       trans.y = 1.f - trans.y;

	movaps	xmm0, xmm11

; 1316 :             circlePos[i] = worldToPos(pos + gContext.mModel.v.position, gContext.mViewProjection);

	movss	DWORD PTR [rdi], xmm4

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm0, xmm2

; 1308 :          for (unsigned int i = 1; i < halfCircleSegmentCount + 1; i++)

	inc	ebx

; 807  :       trans.x *= size.x;

	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1316 :             circlePos[i] = worldToPos(pos + gContext.mModel.v.position, gContext.mViewProjection);

	movss	DWORD PTR [rdi+4], xmm0
	add	rdi, 8
	cmp	ebx, 65					; 00000041H
	jb	$LL10@DrawRotati

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+216
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r9d, eax

; 1317 :          }
; 1318 :          drawList->AddConvexPolyFilled(circlePos, halfCircleSegmentCount + 1, GetColorU32(ROTATION_USING_FILL));

	lea	rdx, QWORD PTR circlePos$15[rbp]
	mov	r8d, 65					; 00000041H
	mov	rcx, r15
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+200
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1319 :          drawList->AddPolyline(circlePos, halfCircleSegmentCount + 1, GetColorU32(ROTATION_USING_BORDER), true, gContext.mStyle.RotationLineThickness);

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+16
	lea	rdx, QWORD PTR circlePos$15[rbp]
	movss	DWORD PTR [rsp+40], xmm0

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	mov	r9d, eax

; 1319 :          drawList->AddPolyline(circlePos, halfCircleSegmentCount + 1, GetColorU32(ROTATION_USING_BORDER), true, gContext.mStyle.RotationLineThickness);

	mov	r8d, 65					; 00000041H
	mov	DWORD PTR [rsp+32], 1
	mov	rcx, r15
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline

; 1320 : 
; 1321 :          ImVec2 destinationPosOnScreen = circlePos[1];
; 1322 :          char tmps[512];
; 1323 :          ImFormatString(tmps, sizeof(tmps), rotationInfoMask[type - MT_ROTATE_X], (gContext.mRotationAngle / ZPI) * 180.f, gContext.mRotationAngle);

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1168
	lea	rax, OFFSET FLAT:?rotationInfoMask@ImGuizmo@@3PAPEBDA
	movss	xmm6, DWORD PTR circlePos$15[rbp+8]
	lea	rcx, QWORD PTR tmps$16[rbp]
	movss	xmm7, DWORD PTR circlePos$15[rbp+12]
	mov	edx, 512				; 00000200H
	cvtps2pd xmm1, xmm0
	movsxd	r8, esi
	mov	r8, QWORD PTR [rax+r8*8-64]
	divss	xmm0, DWORD PTR __real@40490fdb
	movsd	QWORD PTR [rsp+32], xmm1
	mulss	xmm0, DWORD PTR __real@43340000
	cvtps2pd xmm3, xmm0
	movq	r9, xmm3
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+264
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1324 :          drawList->AddText(ImVec2(destinationPosOnScreen.x + 15, destinationPosOnScreen.y + 15), GetColorU32(TEXT_SHADOW), tmps);

	movaps	xmm0, xmm6

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	mov	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	rbx, -1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1324 :          drawList->AddText(ImVec2(destinationPosOnScreen.x + 15, destinationPosOnScreen.y + 15), GetColorU32(TEXT_SHADOW), tmps);

	addss	xmm0, DWORD PTR __real@41700000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T8[rbp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1324 :          drawList->AddText(ImVec2(destinationPosOnScreen.x + 15, destinationPosOnScreen.y + 15), GetColorU32(TEXT_SHADOW), tmps);

	movaps	xmm0, xmm7
	addss	xmm0, DWORD PTR __real@41700000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T8[rbp+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	test	eax, -16777216				; ff000000H
	je	SHORT $LN484@DrawRotati

; 1579 :         return;
; 1580 : 
; 1581 :     if (text_end == NULL)
; 1582 :         text_end = text_begin + strlen(text_begin);

	lea	rcx, QWORD PTR tmps$16[rbp]
	mov	rax, rbx
$LL465@DrawRotati:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL465@DrawRotati
	lea	rcx, QWORD PTR tmps$16[rbp]

; 1583 :     if (text_begin == text_end)

	xorps	xmm8, xmm8
	add	rcx, rax
	lea	rax, QWORD PTR tmps$16[rbp]
	cmp	rax, rcx
	je	SHORT $LN103@DrawRotati

; 1584 :         return;
; 1585 : 
; 1586 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1587 :     if (font == NULL)
; 1588 :         font = _Data->Font;

	mov	rax, QWORD PTR [r15+56]

; 1589 :     if (font_size == 0.0f)
; 1590 :         font_size = _Data->FontSize;
; 1591 : 
; 1592 :     IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
; 1593 : 
; 1594 :     ImVec4 clip_rect = _CmdHeader.ClipRect;
; 1595 :     if (cpu_fine_clip_rect)
; 1596 :     {
; 1597 :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
; 1598 :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
; 1599 :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
; 1600 :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
; 1601 :     }
; 1602 :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

	lea	r9, QWORD PTR $T8[rbp]
	movups	xmm0, XMMWORD PTR [r15+136]
	mov	BYTE PTR [rsp+72], 0
	mov	rdx, r15
	movss	DWORD PTR [rsp+64], xmm8
	movss	xmm2, DWORD PTR [rax+16]
	mov	QWORD PTR [rsp+56], rcx
	lea	rcx, QWORD PTR tmps$16[rbp]
	mov	QWORD PTR [rsp+48], rcx
	lea	rcx, QWORD PTR clip_rect$11[rbp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR clip_rect$11[rbp], xmm0
	mov	DWORD PTR [rsp+32], r8d
	call	?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
	jmp	SHORT $LN103@DrawRotati
$LN484@DrawRotati:
	xorps	xmm8, xmm8
$LN103@DrawRotati:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+248
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r8d, eax

; 1325 :          drawList->AddText(ImVec2(destinationPosOnScreen.x + 14, destinationPosOnScreen.y + 14), GetColorU32(TEXT), tmps);

	addss	xmm6, DWORD PTR __real@41600000
	addss	xmm7, DWORD PTR __real@41600000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T7[rbp], xmm6
	movss	DWORD PTR $T7[rbp+4], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	test	eax, -16777216				; ff000000H
	je	SHORT $LN133@DrawRotati

; 1579 :         return;
; 1580 : 
; 1581 :     if (text_end == NULL)
; 1582 :         text_end = text_begin + strlen(text_begin);

	lea	rax, QWORD PTR tmps$16[rbp]
$LL464@DrawRotati:
	inc	rbx
	cmp	BYTE PTR [rax+rbx], 0
	jne	SHORT $LL464@DrawRotati
	lea	rcx, QWORD PTR tmps$16[rbp]
	add	rcx, rbx

; 1583 :     if (text_begin == text_end)

	lea	rax, QWORD PTR tmps$16[rbp]
	cmp	rax, rcx
	je	SHORT $LN133@DrawRotati

; 1584 :         return;
; 1585 : 
; 1586 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1587 :     if (font == NULL)
; 1588 :         font = _Data->Font;

	mov	rax, QWORD PTR [r15+56]

; 1589 :     if (font_size == 0.0f)
; 1590 :         font_size = _Data->FontSize;
; 1591 : 
; 1592 :     IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
; 1593 : 
; 1594 :     ImVec4 clip_rect = _CmdHeader.ClipRect;
; 1595 :     if (cpu_fine_clip_rect)
; 1596 :     {
; 1597 :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
; 1598 :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
; 1599 :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
; 1600 :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
; 1601 :     }
; 1602 :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

	lea	r9, QWORD PTR $T7[rbp]
	movups	xmm0, XMMWORD PTR [r15+136]
	mov	BYTE PTR [rsp+72], 0
	mov	rdx, r15
	movss	DWORD PTR [rsp+64], xmm8
	movss	xmm2, DWORD PTR [rax+16]
	mov	QWORD PTR [rsp+56], rcx
	lea	rcx, QWORD PTR tmps$16[rbp]
	mov	QWORD PTR [rsp+48], rcx
	lea	rcx, QWORD PTR clip_rect$10[rbp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR clip_rect$10[rbp], xmm0
	mov	DWORD PTR [rsp+32], r8d
	call	?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
$LN133@DrawRotati:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1327 :    }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rbp+1472]
	mov	rsi, QWORD PTR [rbp+1480]
	mov	rdi, QWORD PTR [rbp+1488]
	movaps	xmm6, XMMWORD PTR [rbp+1408]
	movaps	xmm7, XMMWORD PTR [rbp+1392]
	movaps	xmm8, XMMWORD PTR [rbp+1376]
	movaps	xmm9, XMMWORD PTR [rbp+1360]
	movaps	xmm10, XMMWORD PTR [rbp+1344]
	movaps	xmm11, XMMWORD PTR [rbp+1328]
	movaps	xmm12, XMMWORD PTR [rbp+1312]
	movaps	xmm13, XMMWORD PTR [rbp+1296]
	movaps	xmm14, XMMWORD PTR [rbp+1280]
	movaps	xmm15, XMMWORD PTR [rbp+1264]
	lea	rsp, QWORD PTR [rbp+1424]
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
?DrawRotationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z ENDP	; ImGuizmo::DrawRotationGizmo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z
_TEXT	SEGMENT
worldDirSSpace2$1 = 48
baseSSpace2$2 = 56
axis$ = 240
tv2549 = 248
tv2555 = 256
tv2536 = 264
?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z PROC	; ImGuizmo::DrawHatchedAxis, COMDAT

; 1330 :    {

	mov	rax, rsp
	push	rdi
	sub	rsp, 224				; 000000e0H
	xorps	xmm0, xmm0
	mov	rdi, rcx

; 1331 :       if (gContext.mStyle.HatchedAxisLineThickness <= 0.0f)

	comiss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+32
	jae	$LN125@DrawHatche
	mov	QWORD PTR [rax+8], rbx

; 1332 :       {
; 1333 :          return;
; 1334 :       }
; 1335 : 
; 1336 :       for (int j = 1; j < 10; j++)

	mov	ebx, 2
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	movss	xmm8, DWORD PTR __real@3f000000
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
$LN139@DrawHatche:

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm0, DWORD PTR __real@3d4ccccd

; 1339 :          ImVec2 worldDirSSpace2 = worldToPos(axis * 0.05f * (float)(j * 2 + 1) * gContext.mScreenFactor, gContext.mMVP);

	lea	eax, DWORD PTR [rbx+1]

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm7, DWORD PTR [rdi+4]
	xorps	xmm6, xmm6
	movss	xmm5, DWORD PTR [rdi]

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm4, xmm8

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm1, DWORD PTR [rdi+8]

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+760
	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+768

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm7, xmm0
	mulss	xmm1, xmm0
	mulss	xmm5, xmm0

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	DWORD PTR tv2549[rsp], xmm7
	movss	DWORD PTR tv2536[rsp], xmm1

; 1337 :       {
; 1338 :          ImVec2 baseSSpace2 = worldToPos(axis * 0.05f * (float)(j * 2) * gContext.mScreenFactor, gContext.mMVP);

	cvtsi2ss xmm6, ebx

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	DWORD PTR tv2555[rsp], xmm5

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm7, xmm6

; 1337 :       {
; 1338 :          ImVec2 baseSSpace2 = worldToPos(axis * 0.05f * (float)(j * 2) * gContext.mScreenFactor, gContext.mMVP);

	mulss	xmm5, xmm6

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm7, xmm0
	mulss	xmm5, xmm0

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm2, xmm7
	movaps	xmm3, xmm7
	mulss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+748
	mulss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+752

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm6, xmm1

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+776

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm6, xmm0

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+744
	mulss	xmm0, xmm5

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];
; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm1, xmm6
	addss	xmm2, xmm0

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+732

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	mulss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+736
	addss	xmm3, xmm0

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movaps	xmm0, xmm12

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];
; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm1
	mulss	xmm0, xmm6
	addss	xmm7, xmm5
	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+764
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+792
	addss	xmm7, xmm0

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm0, DWORD PTR __real@3f800000

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm3, xmm1

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+760

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm4, xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+780

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+784

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movss	xmm2, DWORD PTR tv2549[rsp]

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm3, xmm4
	mulss	xmm7, xmm4
	xorps	xmm4, xmm4

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm3, xmm8

; 1339 :          ImVec2 worldDirSSpace2 = worldToPos(axis * 0.05f * (float)(j * 2 + 1) * gContext.mScreenFactor, gContext.mMVP);

	cvtsi2ss xmm4, eax

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm2, xmm4

; 808  :       trans.y *= size.y;

	addss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR baseSSpace2$2[rsp], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	movss	xmm3, DWORD PTR __real@3f000000
	addss	xmm7, xmm3

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm0, xmm7

; 1339 :          ImVec2 worldDirSSpace2 = worldToPos(axis * 0.05f * (float)(j * 2 + 1) * gContext.mScreenFactor, gContext.mMVP);

	movss	xmm7, DWORD PTR tv2555[rsp]
	mulss	xmm7, xmm4

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm4, DWORD PTR tv2536[rsp]

; 807  :       trans.x *= size.x;

	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
	movss	DWORD PTR baseSSpace2$2[rsp+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064
	mulss	xmm2, xmm0
	mulss	xmm7, xmm0
	mulss	xmm4, xmm0

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+744
	mulss	xmm0, xmm7

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];
; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm1, xmm2

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movss	DWORD PTR tv2549[rsp], xmm2

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+776
	mulss	xmm0, xmm4
	addss	xmm1, xmm0
	addss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+792
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+748

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+232

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	movss	xmm8, DWORD PTR __real@3f000000

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+732

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	mulss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+736

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm1

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm2, xmm0

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm12, xmm4

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm0, DWORD PTR __real@3f800000

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+764
	addss	xmm2, xmm1

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm1, DWORD PTR tv2549[rsp]
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+752
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+780
	addss	xmm1, xmm7

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm3

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm1, xmm12

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm2, DWORD PTR __real@3f000000

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+784

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm1, xmm3

; 808  :       trans.y *= size.y;

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm1, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR worldDirSSpace2$1[rsp], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm0, xmm1

; 807  :       trans.x *= size.x;

	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
	movss	DWORD PTR worldDirSSpace2$1[rsp+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1340 :          gContext.mDrawList->AddLine(baseSSpace2, worldDirSSpace2, GetColorU32(HATCHED_AXIS_LINES), gContext.mStyle.HatchedAxisLineThickness);

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+32
	lea	r8, QWORD PTR worldDirSSpace2$1[rsp]
	mov	rcx, QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A
	lea	rdx, QWORD PTR baseSSpace2$2[rsp]

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	mov	r9d, eax

; 1340 :          gContext.mDrawList->AddLine(baseSSpace2, worldDirSSpace2, GetColorU32(HATCHED_AXIS_LINES), gContext.mStyle.HatchedAxisLineThickness);

	movss	DWORD PTR [rsp+32], xmm0
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	add	ebx, 2
	cmp	ebx, 20
	jl	$LN139@DrawHatche
	movaps	xmm14, XMMWORD PTR [rsp+80]
	movaps	xmm13, XMMWORD PTR [rsp+96]
	movaps	xmm12, XMMWORD PTR [rsp+112]
	movaps	xmm11, XMMWORD PTR [rsp+128]
	movaps	xmm10, XMMWORD PTR [rsp+144]
	movaps	xmm9, XMMWORD PTR [rsp+160]
	movaps	xmm8, XMMWORD PTR [rsp+176]
	movaps	xmm7, XMMWORD PTR [rsp+192]
	movaps	xmm6, XMMWORD PTR [rsp+208]
	mov	rbx, QWORD PTR [rsp+240]
	movaps	xmm15, XMMWORD PTR [rsp+64]
$LN125@DrawHatche:

; 1341 :       }
; 1342 :    }

	add	rsp, 224				; 000000e0H
	pop	rdi
	ret	0
?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z ENDP	; ImGuizmo::DrawHatchedAxis
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
_TEXT	SEGMENT
belowAxisLimit$4 = 80
i1$1$ = 84
markerScale$1$ = 84
$T5 = 88
$T6 = 88
$T7 = 88
belowPlaneLimit$8 = 96
i$1$ = 100
$T9 = 104
col_trans$1$ = 108
vtx_count$1$ = 108
vtx_outer_idx$1$ = 112
col_trans$1$ = 112
vtx_count$1$ = 116
vtx_outer_idx$1$ = 116
i1$1$ = 120
tv10208 = 120
type$GSCopy$1$ = 124
op$1$ = 128
colors$1$ = 132
dirAxis$10 = 136
clip_rect$11 = 152
clip_rect$12 = 152
$T13 = 152
$T14 = 168
worldDirSSpaceNoScale$15 = 176
baseSSpace$16 = 184
worldDirSSpace$17 = 192
dirPlaneY$18 = 200
dirPlaneX$19 = 216
scaleDisplay$ = 232
colors$ = 248
tmps$20 = 288
__$ArrayPad$ = 800
op$ = 1024
type$ = 1032
?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z PROC	; ImGuizmo::DrawScaleGizmo, COMDAT

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	ecx, 896				; 00000380H

; 1347 : 
; 1348 :       if(!Intersects(op, SCALE))

	je	$LN842@DrawScaleG
	mov	r11, rsp
	push	rbp
	push	rbx
	push	rsi
	push	r14
	lea	rbp, QWORD PTR [r11-760]
	sub	rsp, 984				; 000003d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 1100 :       if (gContext.mbEnable)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1085, 0

; 1345 :    {

	mov	r14d, edx

; 1346 :       ImDrawList* drawList = gContext.mDrawList;

	mov	rbx, QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A
	mov	esi, ecx

; 1347 : 
; 1348 :       if(!Intersects(op, SCALE))

	mov	QWORD PTR [r11+8], rdi
	mov	QWORD PTR [r11+24], r12
	mov	QWORD PTR [r11+32], r13
	mov	QWORD PTR [r11-40], r15
	movaps	XMMWORD PTR [r11-72], xmm7
	movaps	XMMWORD PTR [r11-120], xmm10
	mov	DWORD PTR type$GSCopy$1$[rsp], edx
	mov	DWORD PTR op$1$[rbp-256], ecx

; 1100 :       if (gContext.mbEnable)

	je	SHORT $LN133@DrawScaleG

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+136
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r8d, eax

; 1124 :             colors[0] = (type == MT_SCALE_XYZ) ? selectionColor : IM_COL32_WHITE;

	cmp	r14d, 15
	mov	eax, -1					; ffffffffH
	cmove	eax, r8d
	mov	DWORD PTR colors$1$[rbp-256], eax
	mov	DWORD PTR colors$[rbp-256], eax

; 1125 :             for (int i = 0; i < 3; i++)
; 1126 :             {
; 1127 :                colors[i + 1] = (type == (int)(MT_SCALE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	cmp	r14d, 12
	jne	SHORT $LN149@DrawScaleG
	mov	DWORD PTR colors$[rbp-252], r8d
$LN526@DrawScaleG:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+56
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	DWORD PTR colors$[rbp-248], eax

; 1127 :                colors[i + 1] = (type == (int)(MT_SCALE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	cmp	r14d, 14
	je	SHORT $LN530@DrawScaleG
$LN529@DrawScaleG:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+72
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r8d, eax
$LN530@DrawScaleG:

; 1127 :                colors[i + 1] = (type == (int)(MT_SCALE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	mov	DWORD PTR colors$[rbp-244], r8d

; 1128 :             }
; 1129 :             break;
; 1130 :          // note: this internal function is only called with three possible values for operation
; 1131 :          default:
; 1132 :             break;
; 1133 :          }
; 1134 :       }

	jmp	SHORT $LL131@DrawScaleG
$LN149@DrawScaleG:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+40
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	DWORD PTR colors$[rbp-252], eax

; 1127 :                colors[i + 1] = (type == (int)(MT_SCALE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	cmp	r14d, 13
	jne	SHORT $LN526@DrawScaleG
	mov	DWORD PTR colors$[rbp-248], r8d
	jmp	SHORT $LN529@DrawScaleG
$LN133@DrawScaleG:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+152
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	DWORD PTR colors$1$[rbp-256], eax

; 1140 :             colors[i] = inactiveColor;

	mov	DWORD PTR colors$[rbp-256], eax
	mov	DWORD PTR colors$[rbp-252], eax
	mov	DWORD PTR colors$[rbp-248], eax
	mov	DWORD PTR colors$[rbp-244], eax
	mov	DWORD PTR colors$[rbp-240], eax
	mov	DWORD PTR colors$[rbp-236], eax
	mov	DWORD PTR colors$[rbp-232], eax
	npad	2
$LL131@DrawScaleG:

; 1349 :       {
; 1350 :         return;
; 1351 :       }
; 1352 : 
; 1353 :       // colors
; 1354 :       ImU32 colors[7];
; 1355 :       ComputeColors(colors, type, SCALE);
; 1356 : 
; 1357 :       // draw
; 1358 :       vec_t scaleDisplay = { 1.f, 1.f, 1.f, 1.f };
; 1359 : 
; 1360 :       if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID))

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
	movups	XMMWORD PTR scaleDisplay$[rbp-256], xmm0
	je	SHORT $LN6@DrawScaleG
	mov	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	cmp	eax, -1
	je	SHORT $LN7@DrawScaleG
	cmp	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440
	jne	SHORT $LN6@DrawScaleG
$LN7@DrawScaleG:

; 1361 :       {
; 1362 :          scaleDisplay = gContext.mScale;

	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1176
	movups	XMMWORD PTR scaleDisplay$[rbp-256], xmm0
$LN6@DrawScaleG:

; 1365 :       for (int i = 0; i < 3; i++)

	movss	xmm10, DWORD PTR __real@3f800000
	lea	r15, OFFSET FLAT:__ImageBase
	movaps	XMMWORD PTR [rsp+960], xmm6
	xor	edi, edi
	movaps	XMMWORD PTR [rsp+928], xmm8
	xor	r13d, r13d
	movaps	XMMWORD PTR [rsp+912], xmm9
	mov	r12d, 1
	movaps	XMMWORD PTR [rsp+880], xmm11
	movaps	XMMWORD PTR [rsp+864], xmm12
	movaps	XMMWORD PTR [rsp+848], xmm13
	movaps	XMMWORD PTR [rsp+832], xmm14
	movaps	XMMWORD PTR [rsp+816], xmm15
	mov	DWORD PTR i$1$[rsp], edi
	mov	QWORD PTR $T5[rsp], r13
	mov	DWORD PTR $T9[rsp], r12d
	npad	14
$LL744@DrawScaleG:

; 1366 :       {
; 1367 :          if(!Intersects(op, static_cast<OPERATION>(SCALE_X << i)))

	movss	xmm7, DWORD PTR __real@3dcccccd
	mov	ecx, edi
	mov	eax, 128				; 00000080H
	shl	eax, cl

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	eax, esi

; 1366 :       {
; 1367 :          if(!Intersects(op, static_cast<OPERATION>(SCALE_X << i)))

	je	$LN741@DrawScaleG

; 1368 :          {
; 1369 :             continue;
; 1370 :          }
; 1371 :          const bool usingAxis = (gContext.mbUsing && type == MT_SCALE_X + i);

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	je	SHORT $LN20@DrawScaleG
	lea	eax, DWORD PTR [rdi+12]
	cmp	r14d, eax
	jne	SHORT $LN20@DrawScaleG
	mov	al, 1
	jmp	SHORT $LN21@DrawScaleG
$LN20@DrawScaleG:
	xor	al, al
$LN21@DrawScaleG:

; 1372 :          if (!gContext.mbUsing || usingAxis)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	je	SHORT $LN10@DrawScaleG
	test	al, al
	je	$LN741@DrawScaleG
$LN10@DrawScaleG:

; 1373 :          {
; 1374 :             vec_t dirPlaneX, dirPlaneY, dirAxis;
; 1375 :             bool belowAxisLimit, belowPlaneLimit;
; 1376 :             ComputeTripodAxisAndVisibility(i, dirAxis, dirPlaneX, dirPlaneY, belowAxisLimit, belowPlaneLimit, true);

	lea	rax, QWORD PTR belowPlaneLimit$8[rsp]
	mov	BYTE PTR [rsp+48], 1
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR dirPlaneY$18[rbp-256]
	lea	rax, QWORD PTR belowAxisLimit$4[rsp]
	lea	r8, QWORD PTR dirPlaneX$19[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR dirAxis$10[rbp-256]
	call	?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z ; ImGuizmo::ComputeTripodAxisAndVisibility

; 1377 : 
; 1378 :             // draw axis
; 1379 :             if (belowAxisLimit)

	cmp	BYTE PTR belowAxisLimit$4[rsp], 0
	je	$LN741@DrawScaleG

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	mov	r15d, r12d
	and	r15d, esi
	mov	DWORD PTR tv10208[rsp], r15d

; 1380 :             {
; 1381 :                bool hasTranslateOnAxis = Contains(op, static_cast<OPERATION>(TRANSLATE_X << i));
; 1382 :                float markerScale = hasTranslateOnAxis ? 1.4f : 1.0f;

	cmp	r15d, r12d
	jne	SHORT $LN22@DrawScaleG
	movss	xmm10, DWORD PTR __real@3fb33333
$LN22@DrawScaleG:

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm8, DWORD PTR dirAxis$10[rbp-256]
	movss	xmm9, DWORD PTR dirAxis$10[rbp-252]
	movaps	xmm6, xmm8
	movss	xmm4, DWORD PTR dirAxis$10[rbp-248]
	movaps	xmm5, xmm9

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm15, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+768
	movss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+784

; 807  :       trans.x *= size.x;

	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 808  :       trans.y *= size.y;

	movss	xmm14, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm6, xmm7
	mulss	xmm5, xmm7

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm6, xmm0
	mulss	xmm5, xmm0

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movaps	xmm1, xmm6

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm4, xmm7

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+744

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movaps	xmm2, xmm6
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+732

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+736

; 804  :       trans *= 0.5f / trans.w;

	movss	xmm7, DWORD PTR __real@3f000000

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm4, xmm0

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm3, xmm7

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movaps	xmm0, xmm5

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm8, xmm10

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+760

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm9, xmm10

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm1, xmm0

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	DWORD PTR markerScale$1$[rsp], xmm10

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+776

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm10, DWORD PTR dirAxis$10[rbp-248]
	mulss	xmm10, DWORD PTR markerScale$1$[rsp]

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm0, xmm4
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+748
	mulss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+752
	addss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+792
	addss	xmm2, xmm0
	movaps	xmm0, xmm15
	mulss	xmm0, xmm4
	addss	xmm6, xmm5

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movaps	xmm5, xmm9

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm1

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm6, xmm0
	movaps	xmm1, xmm4

; 804  :       trans *= 0.5f / trans.w;

	movss	xmm4, DWORD PTR __real@3f000000

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+764

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm0, DWORD PTR __real@3f800000

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm6, xmm13
	addss	xmm2, xmm1

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+776

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm6, xmm3

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+780

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm6, xmm7

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm3

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm0, xmm6

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movaps	xmm6, xmm10

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm2, xmm7

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movaps	xmm7, xmm8

; 807  :       trans.x *= size.x;

	mulss	xmm0, xmm12
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 808  :       trans.y *= size.y;

	addss	xmm2, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR baseSSpace$16[rbp-252], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR baseSSpace$16[rbp-256], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+760

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm5, xmm0
	mulss	xmm6, xmm0

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm2, xmm5
	movaps	xmm3, xmm5

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm7, xmm0

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+744

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm1, xmm6
	mulss	xmm0, xmm7
	addss	xmm2, xmm0
	addss	xmm2, xmm1
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+792

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm4, xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	mulss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+748
	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+764

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+732

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+752
	mulss	xmm2, xmm5

; 1383 :                ImVec2 baseSSpace = worldToPos(dirAxis * 0.1f * gContext.mScreenFactor, gContext.mMVP);
; 1384 :                ImVec2 worldDirSSpaceNoScale = worldToPos(dirAxis * markerScale * gContext.mScreenFactor, gContext.mMVP);
; 1385 :                ImVec2 worldDirSSpace = worldToPos((dirAxis * markerScale * scaleDisplay[i]) * gContext.mScreenFactor, gContext.mMVP);

	movss	xmm5, DWORD PTR scaleDisplay$[rbp+r13*4-256]

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+736
	mulss	xmm0, xmm7

; 1383 :                ImVec2 baseSSpace = worldToPos(dirAxis * 0.1f * gContext.mScreenFactor, gContext.mMVP);
; 1384 :                ImVec2 worldDirSSpaceNoScale = worldToPos(dirAxis * markerScale * gContext.mScreenFactor, gContext.mMVP);
; 1385 :                ImVec2 worldDirSSpace = worldToPos((dirAxis * markerScale * scaleDisplay[i]) * gContext.mScreenFactor, gContext.mMVP);

	movss	DWORD PTR $T14[rbp-256], xmm5

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm3, xmm1

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movaps	xmm1, xmm15
	addss	xmm2, xmm0
	mulss	xmm1, xmm6

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm0, DWORD PTR __real@3f800000

; 1383 :                ImVec2 baseSSpace = worldToPos(dirAxis * 0.1f * gContext.mScreenFactor, gContext.mMVP);
; 1384 :                ImVec2 worldDirSSpaceNoScale = worldToPos(dirAxis * markerScale * gContext.mScreenFactor, gContext.mMVP);
; 1385 :                ImVec2 worldDirSSpace = worldToPos((dirAxis * markerScale * scaleDisplay[i]) * gContext.mScreenFactor, gContext.mMVP);

	movaps	xmm6, xmm5
	mulss	xmm6, xmm8

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+780

; 804  :       trans *= 0.5f / trans.w;

	movss	xmm8, DWORD PTR __real@3f000000

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm1

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+760

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm3, xmm4

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm13

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm3, DWORD PTR __real@3f000000

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm4

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movaps	xmm4, xmm5

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm2, DWORD PTR __real@3f000000

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm5, xmm10

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm10, DWORD PTR __real@3f800000

; 808  :       trans.y *= size.y;

	addss	xmm3, xmm14

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm4, xmm9

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR worldDirSSpaceNoScale$15[rbp-256], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm3, xmm8

; 807  :       trans.x *= size.x;

	mulss	xmm0, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, xmm11
	movss	DWORD PTR worldDirSSpaceNoScale$15[rbp-252], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064
	mulss	xmm4, xmm0
	mulss	xmm5, xmm0
	mulss	xmm6, xmm0

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movaps	xmm2, xmm4
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+748

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+744

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm1, xmm4
	mulss	xmm0, xmm6
	mulss	xmm15, xmm5
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+776
	mulss	xmm0, xmm5
	addss	xmm1, xmm0

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+732

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+792
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+736
	mulss	xmm0, xmm6

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm1

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+764
	addss	xmm2, xmm1

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+752
	mulss	xmm1, xmm4
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+780
	addss	xmm1, xmm0

; 806  :       trans.y = 1.f - trans.y;

	movaps	xmm0, xmm10

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm3

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm1, xmm15

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm2, xmm8

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm1, xmm13

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm1, xmm3

; 808  :       trans.y *= size.y;

	addss	xmm2, xmm14

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm1, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR worldDirSSpace$17[rbp-256], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm0, xmm1

; 807  :       trans.x *= size.x;

	mulss	xmm0, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1387 :                if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID))

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR worldDirSSpace$17[rbp-252], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1387 :                if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID))

	je	$LN737@DrawScaleG
	mov	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	cmp	eax, -1
	je	SHORT $LN13@DrawScaleG
	cmp	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440
	jne	$LN737@DrawScaleG
$LN13@DrawScaleG:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+184
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1388 :                {
; 1389 :                   ImU32 scaleLineColor = GetColorU32(SCALE_LINE);
; 1390 :                   drawList->AddLine(baseSSpace, worldDirSSpaceNoScale, scaleLineColor, gContext.mStyle.ScaleLineThickness);

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+24
	lea	r8, QWORD PTR worldDirSSpaceNoScale$15[rbp-256]
	mov	r9d, eax
	movss	DWORD PTR [rsp+32], xmm0
	lea	rdx, QWORD PTR baseSSpace$16[rbp-256]
	mov	rcx, rbx

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	mov	r14d, eax

; 1388 :                {
; 1389 :                   ImU32 scaleLineColor = GetColorU32(SCALE_LINE);
; 1390 :                   drawList->AddLine(baseSSpace, worldDirSSpaceNoScale, scaleLineColor, gContext.mStyle.ScaleLineThickness);

	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	test	r14d, -16777216				; ff000000H
	je	$LN737@DrawScaleG
	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+28
	comiss	xmm8, xmm2
	ja	$LN737@DrawScaleG

; 1509 :         return;
; 1510 : 
; 1511 :     if (num_segments <= 0)
; 1512 :     {
; 1513 :         // Use arc with automatic segment count
; 1514 :         _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], 48			; 00000030H
	lea	rdx, QWORD PTR worldDirSSpaceNoScale$15[rbp-256]
	mov	rcx, rbx
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx

; 1515 :         _Path.Size--;

	mov	edi, DWORD PTR [rbx+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	rsi, QWORD PTR [rbx+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1515 :         _Path.Size--;

	dec	edi
	mov	DWORD PTR [rbx+120], edi

; 975  :     if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)

	cmp	edi, 3
	jl	$LN423@DrawScaleG

; 976  :         return;
; 977  : 
; 978  :     const ImVec2 uv = _Data->TexUvWhitePixel;
; 979  : 
; 980  :     if (Flags & ImDrawListFlags_AntiAliasedFill)

	test	BYTE PTR [rbx+48], 4
	mov	rcx, rbx
	mov	rax, QWORD PTR [rbx+56]
	movss	xmm6, DWORD PTR [rax]
	movss	xmm7, DWORD PTR [rax+4]
	je	$LN424@DrawScaleG

; 981  :     {
; 982  :         // Anti-aliased Fill
; 983  :         const float AA_SIZE = _FringeScale;

	movss	xmm9, DWORD PTR [rbx+192]

; 984  :         const ImU32 col_trans = col & ~IM_COL32_A_MASK;
; 985  :         const int idx_count = (points_count - 2)*3 + points_count * 6;

	lea	edx, DWORD PTR [rdi*8-6]
	mov	eax, r14d
	add	edx, edi
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR col_trans$1$[rsp], eax

; 986  :         const int vtx_count = (points_count * 2);

	lea	eax, DWORD PTR [rdi+rdi]

; 987  :         PrimReserve(idx_count, vtx_count);

	mov	r8d, eax
	mov	DWORD PTR vtx_count$1$[rsp], eax
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 988  : 
; 989  :         // Add indexes for fill
; 990  :         unsigned int vtx_inner_idx = _VtxCurrentIdx;

	mov	r13d, DWORD PTR [rbx+52]
	mov	r8d, 2

; 991  :         unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;

	lea	eax, DWORD PTR [r13+1]
	mov	DWORD PTR vtx_outer_idx$1$[rsp], eax
	npad	1
$LL409@DrawScaleG:

; 992  :         for (int i = 2; i < points_count; i++)
; 993  :         {
; 994  :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));

	mov	rax, QWORD PTR [rbx+80]
	movzx	edx, r8w
	add	dx, dx
	inc	r8d
	add	dx, r13w
	mov	WORD PTR [rax], r13w
	mov	rax, QWORD PTR [rbx+80]
	lea	ecx, DWORD PTR [rdx-2]
	mov	WORD PTR [rax+2], cx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+4], dx

; 995  :             _IdxWritePtr += 3;

	add	QWORD PTR [rbx+80], 6
	cmp	r8d, edi
	jl	SHORT $LL409@DrawScaleG

; 996  :         }
; 997  : 
; 998  :         // Compute normals
; 999  :         _Data->TempBuffer.reserve_discard(points_count);

	mov	r15, QWORD PTR [rbx+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	cmp	edi, DWORD PTR [r15+52]
	jle	SHORT $LN430@DrawScaleG
	mov	rcx, QWORD PTR [r15+56]
	test	rcx, rcx
	je	SHORT $LN438@DrawScaleG
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN436@DrawScaleG

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN436@DrawScaleG:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN438@DrawScaleG:

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN443@DrawScaleG

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN443@DrawScaleG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	movsxd	rcx, edi
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	mov	QWORD PTR [r15+56], rax
	mov	DWORD PTR [r15+52], edi
$LN430@DrawScaleG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1000 :         ImVec2* temp_normals = _Data->TempBuffer.Data;

	mov	rax, QWORD PTR [rbx+56]

; 1001 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	lea	r9d, DWORD PTR [rdi-1]
	movss	xmm5, DWORD PTR __xmm@80000000800000008000000080000000
	xor	r8d, r8d
	xor	r10d, r10d
	xorps	xmm4, xmm4
	mov	r11, QWORD PTR [rax+56]
	movsxd	rax, r9d
	cmp	edi, 4
	jl	$LN710@DrawScaleG
	lea	r8, QWORD PTR [rax*8]
	mov	rdx, r11
	lea	eax, DWORD PTR [rdi-4]
	mov	r12d, 12
	shr	eax, 2
	lea	rcx, QWORD PTR [rsi+12]
	sub	rdx, rsi
	sub	r12, rsi
	inc	eax
	mov	r15d, eax
	lea	eax, DWORD PTR [rax*4]
	mov	DWORD PTR i1$1$[rsp], eax
	npad	1
$LL614@DrawScaleG:

; 1005 :             float dx = p1.x - p0.x;

	movss	xmm2, DWORD PTR [rcx-12]

; 1006 :             float dy = p1.y - p0.y;

	movss	xmm3, DWORD PTR [rcx-8]
	subss	xmm2, DWORD PTR [r8+rsi]
	subss	xmm3, DWORD PTR [r8+rsi+4]

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm4
	jbe	SHORT $LN610@DrawScaleG
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN610@DrawScaleG:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [r8+r11], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm5
	movss	DWORD PTR [r8+r11+4], xmm2
	movss	xmm2, DWORD PTR [rcx-4]
	movss	xmm3, DWORD PTR [rcx]
	subss	xmm2, DWORD PTR [rcx-12]
	subss	xmm3, DWORD PTR [rcx-8]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm4
	jbe	SHORT $LN611@DrawScaleG
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN611@DrawScaleG:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rdx+rcx-12], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm5
	movss	DWORD PTR [rdx+rcx-8], xmm2
	movss	xmm2, DWORD PTR [rcx+4]
	movss	xmm3, DWORD PTR [rcx+8]
	subss	xmm2, DWORD PTR [rcx-4]
	subss	xmm3, DWORD PTR [rcx]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm4
	jbe	SHORT $LN612@DrawScaleG
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN612@DrawScaleG:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rdx+rcx-4], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm5
	movss	DWORD PTR [rdx+rcx], xmm2
	movss	xmm2, DWORD PTR [rcx+12]
	movss	xmm3, DWORD PTR [rcx+16]
	subss	xmm2, DWORD PTR [rcx+4]
	subss	xmm3, DWORD PTR [rcx+8]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm4
	jbe	SHORT $LN613@DrawScaleG
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN613@DrawScaleG:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rdx+rcx+4], xmm3
	lea	rax, QWORD PTR [r10+3]

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm5
	lea	r8, QWORD PTR [r12+rcx]
	movss	DWORD PTR [rdx+rcx+8], xmm2
	add	r10, 4
	add	rcx, 32					; 00000020H
	sub	r15, 1
	jne	$LL614@DrawScaleG

; 1001 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	mov	r8d, DWORD PTR i1$1$[rsp]
	cmp	r8d, edi
	jge	SHORT $LN843@DrawScaleG
$LN710@DrawScaleG:
	lea	rcx, QWORD PTR [rax*8]
	mov	eax, edi
	sub	eax, r8d
	lea	rdx, QWORD PTR [rsi+r10*8]
	mov	r8d, eax
$LC691@DrawScaleG:

; 1005 :             float dx = p1.x - p0.x;

	movss	xmm2, DWORD PTR [rdx]

; 1006 :             float dy = p1.y - p0.y;

	movss	xmm3, DWORD PTR [rdx+4]
	subss	xmm2, DWORD PTR [rcx+rsi]
	subss	xmm3, DWORD PTR [rcx+rsi+4]

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm4
	jbe	SHORT $LN426@DrawScaleG
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN426@DrawScaleG:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rcx+r11], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm5
	movss	DWORD PTR [rcx+r11+4], xmm2
	mov	rcx, rdx
	sub	rcx, rsi
	add	rdx, 8
	sub	r8, 1
	jne	SHORT $LC691@DrawScaleG
$LN843@DrawScaleG:

; 1010 :         }
; 1011 : 
; 1012 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	xor	r15d, r15d
	mulss	xmm9, xmm8
	mov	r12, r11
	lea	r10, QWORD PTR [rsi+4]
	sub	r12, rsi
	mov	esi, DWORD PTR col_trans$1$[rsp]
	npad	3
$LL415@DrawScaleG:

; 1013 :         {
; 1014 :             // Average normals
; 1015 :             const ImVec2& n0 = temp_normals[i0];
; 1016 :             const ImVec2& n1 = temp_normals[i1];
; 1017 :             float dm_x = (n0.x + n1.x) * 0.5f;

	movss	xmm2, DWORD PTR [r10+r12-4]

; 1018 :             float dm_y = (n0.y + n1.y) * 0.5f;

	movss	xmm3, DWORD PTR [r10+r12]
	movsxd	rax, r9d
	addss	xmm2, DWORD PTR [r11+rax*8]
	addss	xmm3, DWORD PTR [r11+rax*8+4]
	mulss	xmm2, xmm8
	mulss	xmm3, xmm8

; 1019 :             IM_FIXNORMAL2F(dm_x, dm_y);

	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, DWORD PTR __real@358637bd
	jbe	SHORT $LN427@DrawScaleG
	movaps	xmm0, xmm10
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@42c80000
	minss	xmm1, xmm0
	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN427@DrawScaleG:

; 1020 :             dm_x *= AA_SIZE * 0.5f;
; 1021 :             dm_y *= AA_SIZE * 0.5f;
; 1022 : 
; 1023 :             // Add vertices
; 1024 :             _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner

	movss	xmm0, DWORD PTR [r10-4]

; 1025 :             _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
; 1026 :             _VtxWritePtr += 2;
; 1027 : 
; 1028 :             // Add indexes for fringes
; 1029 :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));

	add	r9w, r9w
	mov	rax, QWORD PTR [rbx+72]
	movzx	r8d, r15w
	mulss	xmm2, xmm9
	add	r8w, r8w
	lea	ecx, DWORD PTR [r9+r13]
	mulss	xmm3, xmm9
	subss	xmm0, xmm2
	lea	edx, DWORD PTR [r8+r13]
	movss	DWORD PTR [rax], xmm0
	movss	xmm1, DWORD PTR [r10]
	mov	rax, QWORD PTR [rbx+72]
	subss	xmm1, xmm3
	movss	DWORD PTR [rax+4], xmm1
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r14d
	addss	xmm2, DWORD PTR [r10-4]
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+20], xmm2
	addss	xmm3, DWORD PTR [r10]
	mov	rax, QWORD PTR [rbx+72]
	add	r10, 8
	movss	DWORD PTR [rax+24], xmm3
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+28], xmm6
	movss	DWORD PTR [rax+32], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+36], esi
	mov	rax, QWORD PTR [rbx+80]
	add	QWORD PTR [rbx+72], 40			; 00000028H
	mov	WORD PTR [rax], dx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+2], cx
	mov	rax, QWORD PTR [rbx+80]
	mov	ecx, DWORD PTR vtx_outer_idx$1$[rsp]
	add	r9w, cx

; 1030 :             _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));

	add	r8w, cx
	mov	WORD PTR [rax+4], r9w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+6], r9w
	mov	r9d, r15d
	mov	rax, QWORD PTR [rbx+80]
	inc	r15d
	mov	WORD PTR [rax+8], r8w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+10], dx

; 1031 :             _IdxWritePtr += 6;

	add	QWORD PTR [rbx+80], 12
	cmp	r15d, edi
	jl	$LL415@DrawScaleG

; 1032 :         }
; 1033 :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, WORD PTR vtx_count$1$[rsp]

; 1034 :     }

	mov	r15d, DWORD PTR tv10208[rsp]
	mov	r12d, DWORD PTR $T9[rsp]
	mov	r13, QWORD PTR $T5[rsp]
	jmp	$LN844@DrawScaleG
$LN424@DrawScaleG:

; 1035 :     else
; 1036 :     {
; 1037 :         // Non Anti-aliased Fill
; 1038 :         const int idx_count = (points_count - 2)*3;

	lea	eax, DWORD PTR [rdi-2]

; 1039 :         const int vtx_count = points_count;
; 1040 :         PrimReserve(idx_count, vtx_count);

	mov	r8d, edi
	lea	edx, DWORD PTR [rax+rax*2]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve
	xor	r8d, r8d
	xor	r9d, r9d

; 1041 :         for (int i = 0; i < vtx_count; i++)

	cmp	edi, 4
	jl	$LN724@DrawScaleG

; 1039 :         const int vtx_count = points_count;
; 1040 :         PrimReserve(idx_count, vtx_count);

	lea	eax, DWORD PTR [rdi-4]
	shr	eax, 2
	lea	rcx, QWORD PTR [rsi+16]
	inc	eax
	mov	edx, eax
	lea	r8d, DWORD PTR [rax*4]
	lea	r9, QWORD PTR [rax*4]
	npad	9

; 1041 :         for (int i = 0; i < vtx_count; i++)

$LL617@DrawScaleG:

; 1042 :         {
; 1043 :             _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	movsd	xmm0, QWORD PTR [rcx-16]

; 1044 :             _VtxWritePtr++;

	lea	rcx, QWORD PTR [rcx+32]
	mov	rax, QWORD PTR [rbx+72]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r14d
	add	QWORD PTR [rbx+72], 20
	movsd	xmm0, QWORD PTR [rcx-40]
	mov	rax, QWORD PTR [rbx+72]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r14d
	add	QWORD PTR [rbx+72], 20
	movsd	xmm0, QWORD PTR [rcx-32]
	mov	rax, QWORD PTR [rbx+72]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r14d
	add	QWORD PTR [rbx+72], 20
	mov	rax, QWORD PTR [rbx+72]
	movsd	xmm0, QWORD PTR [rcx-24]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r14d
	add	QWORD PTR [rbx+72], 20
	sub	rdx, 1
	jne	$LL617@DrawScaleG
$LN724@DrawScaleG:

; 1041 :         for (int i = 0; i < vtx_count; i++)

	cmp	r8d, edi
	jge	SHORT $LN615@DrawScaleG
	mov	edx, edi
	lea	rcx, QWORD PTR [rsi+r9*8]
	sub	edx, r8d
$LC418@DrawScaleG:

; 1042 :         {
; 1043 :             _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	mov	rax, QWORD PTR [rbx+72]
	movsd	xmm0, QWORD PTR [rcx]
	lea	rcx, QWORD PTR [rcx+8]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r14d

; 1044 :             _VtxWritePtr++;

	add	QWORD PTR [rbx+72], 20
	sub	rdx, 1
	jne	SHORT $LC418@DrawScaleG
$LN615@DrawScaleG:

; 1045 :         }
; 1046 :         for (int i = 2; i < points_count; i++)
; 1047 :         {
; 1048 :             _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);

	mov	edx, 2
$LL732@DrawScaleG:
	mov	rcx, QWORD PTR [rbx+80]
	movzx	eax, WORD PTR [rbx+52]
	mov	WORD PTR [rcx], ax
	lea	ecx, DWORD PTR [rdx-1]
	add	cx, WORD PTR [rbx+52]
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+2], cx
	movzx	ecx, dx
	mov	rax, QWORD PTR [rbx+80]
	inc	edx
	add	cx, WORD PTR [rbx+52]
	mov	WORD PTR [rax+4], cx

; 1049 :             _IdxWritePtr += 3;

	add	QWORD PTR [rbx+80], 6
	cmp	edx, edi
	jl	SHORT $LL732@DrawScaleG

; 1050 :         }
; 1051 :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, di
$LN844@DrawScaleG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	add	DWORD PTR [rbx+52], eax
$LN423@DrawScaleG:
	mov	DWORD PTR [rbx+120], 0
$LN737@DrawScaleG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1394 :                if (!hasTranslateOnAxis || gContext.mbUsing)

	cmp	r15d, r12d
	jne	SHORT $LN15@DrawScaleG
	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	je	SHORT $LN642@DrawScaleG
$LN15@DrawScaleG:

; 1396 :                   drawList->AddLine(baseSSpace, worldDirSSpace, colors[i + 1], gContext.mStyle.ScaleLineThickness);

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+24
	lea	r8, QWORD PTR worldDirSSpace$17[rbp-256]
	mov	r9d, DWORD PTR colors$[rbp+r13*4-252]
	lea	rdx, QWORD PTR baseSSpace$16[rbp-256]
	mov	rcx, rbx
	movss	DWORD PTR [rsp+32], xmm0
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
$LN642@DrawScaleG:

; 1397 :                }
; 1398 :                drawList->AddCircleFilled(worldDirSSpace, gContext.mStyle.ScaleLineCircleSize, colors[i + 1]);

	mov	r14d, DWORD PTR colors$[rbp+r13*4-252]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	test	r14d, -16777216				; ff000000H
	je	$LN247@DrawScaleG
	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+28
	comiss	xmm8, xmm2
	ja	$LN247@DrawScaleG

; 1509 :         return;
; 1510 : 
; 1511 :     if (num_segments <= 0)
; 1512 :     {
; 1513 :         // Use arc with automatic segment count
; 1514 :         _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], 48			; 00000030H
	lea	rdx, QWORD PTR worldDirSSpace$17[rbp-256]
	mov	rcx, rbx
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx

; 1515 :         _Path.Size--;

	mov	edi, DWORD PTR [rbx+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	rsi, QWORD PTR [rbx+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1515 :         _Path.Size--;

	dec	edi
	mov	DWORD PTR [rbx+120], edi

; 975  :     if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)

	cmp	edi, 3
	jl	$LN274@DrawScaleG

; 976  :         return;
; 977  : 
; 978  :     const ImVec2 uv = _Data->TexUvWhitePixel;
; 979  : 
; 980  :     if (Flags & ImDrawListFlags_AntiAliasedFill)

	test	BYTE PTR [rbx+48], 4
	mov	rcx, rbx
	mov	rax, QWORD PTR [rbx+56]
	movss	xmm6, DWORD PTR [rax]
	movss	xmm7, DWORD PTR [rax+4]
	je	$LN275@DrawScaleG

; 981  :     {
; 982  :         // Anti-aliased Fill
; 983  :         const float AA_SIZE = _FringeScale;

	movss	xmm9, DWORD PTR [rbx+192]

; 984  :         const ImU32 col_trans = col & ~IM_COL32_A_MASK;
; 985  :         const int idx_count = (points_count - 2)*3 + points_count * 6;

	lea	edx, DWORD PTR [rdi*8-6]
	mov	eax, r14d
	add	edx, edi
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR col_trans$1$[rsp], eax

; 986  :         const int vtx_count = (points_count * 2);

	lea	eax, DWORD PTR [rdi+rdi]

; 987  :         PrimReserve(idx_count, vtx_count);

	mov	r8d, eax
	mov	DWORD PTR vtx_count$1$[rsp], eax
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 988  : 
; 989  :         // Add indexes for fill
; 990  :         unsigned int vtx_inner_idx = _VtxCurrentIdx;

	mov	r13d, DWORD PTR [rbx+52]
	mov	r8d, 2

; 991  :         unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;

	lea	eax, DWORD PTR [r13+1]
	mov	DWORD PTR vtx_outer_idx$1$[rsp], eax
$LL260@DrawScaleG:

; 992  :         for (int i = 2; i < points_count; i++)
; 993  :         {
; 994  :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));

	mov	rax, QWORD PTR [rbx+80]
	movzx	edx, r8w
	add	dx, dx
	inc	r8d
	add	dx, r13w
	mov	WORD PTR [rax], r13w
	mov	rax, QWORD PTR [rbx+80]
	lea	ecx, DWORD PTR [rdx-2]
	mov	WORD PTR [rax+2], cx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+4], dx

; 995  :             _IdxWritePtr += 3;

	add	QWORD PTR [rbx+80], 6
	cmp	r8d, edi
	jl	SHORT $LL260@DrawScaleG

; 996  :         }
; 997  : 
; 998  :         // Compute normals
; 999  :         _Data->TempBuffer.reserve_discard(points_count);

	mov	r15, QWORD PTR [rbx+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	cmp	edi, DWORD PTR [r15+52]
	jle	SHORT $LN281@DrawScaleG
	mov	rcx, QWORD PTR [r15+56]
	test	rcx, rcx
	je	SHORT $LN289@DrawScaleG
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN287@DrawScaleG

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN287@DrawScaleG:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN289@DrawScaleG:

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN294@DrawScaleG

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN294@DrawScaleG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	movsxd	rcx, edi
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	mov	QWORD PTR [r15+56], rax
	mov	DWORD PTR [r15+52], edi
$LN281@DrawScaleG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1000 :         ImVec2* temp_normals = _Data->TempBuffer.Data;

	mov	rax, QWORD PTR [rbx+56]

; 1001 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	lea	r11d, DWORD PTR [rdi-1]
	movss	xmm5, DWORD PTR __xmm@80000000800000008000000080000000
	xor	r8d, r8d
	xor	r9d, r9d
	xorps	xmm4, xmm4
	mov	r10, QWORD PTR [rax+56]
	movsxd	rax, r11d
	cmp	edi, 4
	jl	$LN717@DrawScaleG
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1396 :                   drawList->AddLine(baseSSpace, worldDirSSpace, colors[i + 1], gContext.mStyle.ScaleLineThickness);

	lea	r8, QWORD PTR [rax*8]
	mov	rdx, r10
	lea	eax, DWORD PTR [rdi-4]
	mov	r12d, 12
	shr	eax, 2
	lea	rcx, QWORD PTR [rsi+12]
	sub	rdx, rsi
	sub	r12, rsi
	inc	eax
	mov	r15d, eax
	lea	eax, DWORD PTR [rax*4]
	mov	DWORD PTR i1$1$[rsp], eax
	npad	1
$LL624@DrawScaleG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1005 :             float dx = p1.x - p0.x;

	movss	xmm2, DWORD PTR [rcx-12]

; 1006 :             float dy = p1.y - p0.y;

	movss	xmm3, DWORD PTR [rcx-8]
	subss	xmm2, DWORD PTR [rsi+r8]
	subss	xmm3, DWORD PTR [rsi+r8+4]

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm4
	jbe	SHORT $LN620@DrawScaleG
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN620@DrawScaleG:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [r10+r8], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm5
	movss	DWORD PTR [r10+r8+4], xmm2
	movss	xmm2, DWORD PTR [rcx-4]
	movss	xmm3, DWORD PTR [rcx]
	subss	xmm2, DWORD PTR [rcx-12]
	subss	xmm3, DWORD PTR [rcx-8]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm4
	jbe	SHORT $LN621@DrawScaleG
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN621@DrawScaleG:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rdx+rcx-12], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm5
	movss	DWORD PTR [rdx+rcx-8], xmm2
	movss	xmm2, DWORD PTR [rcx+4]
	movss	xmm3, DWORD PTR [rcx+8]
	subss	xmm2, DWORD PTR [rcx-4]
	subss	xmm3, DWORD PTR [rcx]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm4
	jbe	SHORT $LN622@DrawScaleG
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN622@DrawScaleG:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rdx+rcx-4], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm5
	movss	DWORD PTR [rcx+rdx], xmm2
	movss	xmm2, DWORD PTR [rcx+12]
	movss	xmm3, DWORD PTR [rcx+16]
	subss	xmm2, DWORD PTR [rcx+4]
	subss	xmm3, DWORD PTR [rcx+8]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm4
	jbe	SHORT $LN623@DrawScaleG
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN623@DrawScaleG:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rdx+rcx+4], xmm3
	lea	rax, QWORD PTR [r9+3]

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm5
	lea	r8, QWORD PTR [rcx+r12]
	movss	DWORD PTR [rdx+rcx+8], xmm2
	add	r9, 4
	add	rcx, 32					; 00000020H
	sub	r15, 1
	jne	$LL624@DrawScaleG

; 1001 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	mov	r8d, DWORD PTR i1$1$[rsp]
	cmp	r8d, edi
	jge	SHORT $LN845@DrawScaleG
$LN717@DrawScaleG:
	lea	rcx, QWORD PTR [rax*8]
	mov	eax, edi
	sub	eax, r8d
	lea	rdx, QWORD PTR [rsi+r9*8]
	mov	r8d, eax
$LC698@DrawScaleG:

; 1005 :             float dx = p1.x - p0.x;

	movss	xmm2, DWORD PTR [rdx]

; 1006 :             float dy = p1.y - p0.y;

	movss	xmm3, DWORD PTR [rdx+4]
	subss	xmm2, DWORD PTR [rsi+rcx]
	subss	xmm3, DWORD PTR [rsi+rcx+4]

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm4
	jbe	SHORT $LN277@DrawScaleG
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN277@DrawScaleG:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [r10+rcx], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm5
	movss	DWORD PTR [r10+rcx+4], xmm2
	mov	rcx, rdx
	sub	rcx, rsi
	add	rdx, 8
	sub	r8, 1
	jne	SHORT $LC698@DrawScaleG
$LN845@DrawScaleG:

; 1010 :         }
; 1011 : 
; 1012 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	xor	r15d, r15d
	mulss	xmm9, xmm8
	mov	r12, r10
	lea	r9, QWORD PTR [rsi+4]
	sub	r12, rsi
	mov	esi, DWORD PTR vtx_outer_idx$1$[rsp]
	npad	3
$LL266@DrawScaleG:

; 1013 :         {
; 1014 :             // Average normals
; 1015 :             const ImVec2& n0 = temp_normals[i0];
; 1016 :             const ImVec2& n1 = temp_normals[i1];
; 1017 :             float dm_x = (n0.x + n1.x) * 0.5f;

	movss	xmm2, DWORD PTR [r12+r9-4]

; 1018 :             float dm_y = (n0.y + n1.y) * 0.5f;

	movss	xmm3, DWORD PTR [r12+r9]
	movsxd	rax, r11d
	addss	xmm2, DWORD PTR [r10+rax*8]
	addss	xmm3, DWORD PTR [r10+rax*8+4]
	mulss	xmm2, xmm8
	mulss	xmm3, xmm8

; 1019 :             IM_FIXNORMAL2F(dm_x, dm_y);

	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, DWORD PTR __real@358637bd
	jbe	SHORT $LN278@DrawScaleG
	movaps	xmm0, xmm10
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@42c80000
	minss	xmm1, xmm0
	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN278@DrawScaleG:

; 1020 :             dm_x *= AA_SIZE * 0.5f;
; 1021 :             dm_y *= AA_SIZE * 0.5f;
; 1022 : 
; 1023 :             // Add vertices
; 1024 :             _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner

	movss	xmm0, DWORD PTR [r9-4]

; 1025 :             _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
; 1026 :             _VtxWritePtr += 2;
; 1027 : 
; 1028 :             // Add indexes for fringes
; 1029 :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));

	movzx	edx, r15w
	mov	rax, QWORD PTR [rbx+72]
	add	r11w, r11w
	mov	ecx, DWORD PTR col_trans$1$[rsp]
	add	dx, dx
	mulss	xmm2, xmm9
	mulss	xmm3, xmm9
	lea	r8d, DWORD PTR [rdx+r13]
	subss	xmm0, xmm2
	movss	DWORD PTR [rax], xmm0
	movss	xmm1, DWORD PTR [r9]
	mov	rax, QWORD PTR [rbx+72]
	subss	xmm1, xmm3
	movss	DWORD PTR [rax+4], xmm1
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r14d
	addss	xmm2, DWORD PTR [r9-4]
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+20], xmm2
	addss	xmm3, DWORD PTR [r9]
	mov	rax, QWORD PTR [rbx+72]
	add	r9, 8
	movss	DWORD PTR [rax+24], xmm3
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+28], xmm6
	movss	DWORD PTR [rax+32], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+36], ecx
	lea	ecx, DWORD PTR [r11+r13]
	mov	rax, QWORD PTR [rbx+80]
	add	QWORD PTR [rbx+72], 40			; 00000028H
	mov	WORD PTR [rax], r8w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+2], cx
	lea	ecx, DWORD PTR [r11+rsi]
	mov	rax, QWORD PTR [rbx+80]
	mov	r11d, r15d
	inc	r15d
	mov	WORD PTR [rax+4], cx

; 1030 :             _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));

	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+6], cx
	lea	ecx, DWORD PTR [rdx+rsi]
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+8], cx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+10], r8w

; 1031 :             _IdxWritePtr += 6;

	add	QWORD PTR [rbx+80], 12
	cmp	r15d, edi
	jl	$LL266@DrawScaleG

; 1032 :         }
; 1033 :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, WORD PTR vtx_count$1$[rsp]

; 1034 :     }

	mov	r12d, DWORD PTR $T9[rsp]
	mov	r13, QWORD PTR $T5[rsp]
	jmp	$LN846@DrawScaleG
$LN275@DrawScaleG:

; 1035 :     else
; 1036 :     {
; 1037 :         // Non Anti-aliased Fill
; 1038 :         const int idx_count = (points_count - 2)*3;

	lea	eax, DWORD PTR [rdi-2]

; 1039 :         const int vtx_count = points_count;
; 1040 :         PrimReserve(idx_count, vtx_count);

	mov	r8d, edi
	lea	edx, DWORD PTR [rax+rax*2]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve
	xor	r8d, r8d
	xor	r9d, r9d

; 1041 :         for (int i = 0; i < vtx_count; i++)

	cmp	edi, 4
	jl	$LN728@DrawScaleG

; 1039 :         const int vtx_count = points_count;
; 1040 :         PrimReserve(idx_count, vtx_count);

	lea	eax, DWORD PTR [rdi-4]
	shr	eax, 2
	lea	rcx, QWORD PTR [rsi+16]
	inc	eax
	mov	edx, eax
	lea	r8d, DWORD PTR [rax*4]
	lea	r9, QWORD PTR [rax*4]
	npad	1

; 1041 :         for (int i = 0; i < vtx_count; i++)

$LL627@DrawScaleG:

; 1042 :         {
; 1043 :             _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	movsd	xmm0, QWORD PTR [rcx-16]

; 1044 :             _VtxWritePtr++;

	lea	rcx, QWORD PTR [rcx+32]
	mov	rax, QWORD PTR [rbx+72]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r14d
	add	QWORD PTR [rbx+72], 20
	movsd	xmm0, QWORD PTR [rcx-40]
	mov	rax, QWORD PTR [rbx+72]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r14d
	add	QWORD PTR [rbx+72], 20
	movsd	xmm0, QWORD PTR [rcx-32]
	mov	rax, QWORD PTR [rbx+72]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r14d
	add	QWORD PTR [rbx+72], 20
	mov	rax, QWORD PTR [rbx+72]
	movsd	xmm0, QWORD PTR [rcx-24]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r14d
	add	QWORD PTR [rbx+72], 20
	sub	rdx, 1
	jne	$LL627@DrawScaleG
$LN728@DrawScaleG:

; 1041 :         for (int i = 0; i < vtx_count; i++)

	cmp	r8d, edi
	jge	SHORT $LN625@DrawScaleG
	mov	edx, edi
	lea	rcx, QWORD PTR [rsi+r9*8]
	sub	edx, r8d
$LC269@DrawScaleG:

; 1042 :         {
; 1043 :             _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	mov	rax, QWORD PTR [rbx+72]
	movsd	xmm0, QWORD PTR [rcx]
	lea	rcx, QWORD PTR [rcx+8]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r14d

; 1044 :             _VtxWritePtr++;

	add	QWORD PTR [rbx+72], 20
	sub	rdx, 1
	jne	SHORT $LC269@DrawScaleG
$LN625@DrawScaleG:

; 1045 :         }
; 1046 :         for (int i = 2; i < points_count; i++)
; 1047 :         {
; 1048 :             _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);

	mov	edx, 2
$LL730@DrawScaleG:
	mov	rcx, QWORD PTR [rbx+80]
	movzx	eax, WORD PTR [rbx+52]
	mov	WORD PTR [rcx], ax
	lea	ecx, DWORD PTR [rdx-1]
	add	cx, WORD PTR [rbx+52]
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+2], cx
	movzx	ecx, dx
	mov	rax, QWORD PTR [rbx+80]
	inc	edx
	add	cx, WORD PTR [rbx+52]
	mov	WORD PTR [rax+4], cx

; 1049 :             _IdxWritePtr += 3;

	add	QWORD PTR [rbx+80], 6
	cmp	edx, edi
	jl	SHORT $LL730@DrawScaleG

; 1050 :         }
; 1051 :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, di
$LN846@DrawScaleG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	add	DWORD PTR [rbx+52], eax
$LN274@DrawScaleG:
	mov	DWORD PTR [rbx+120], 0
$LN247@DrawScaleG:
	xorps	xmm7, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1400 :                if (gContext.mAxisFactor[i] < 0.f)

	lea	r15, OFFSET FLAT:__ImageBase
	comiss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A[r15+r13*4+1236]
	jbe	SHORT $LN745@DrawScaleG

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm3, DWORD PTR $T14[rbp-256]

; 1401 :                {
; 1402 :                   DrawHatchedAxis(dirAxis * scaleDisplay[i]);

	lea	rcx, QWORD PTR $T13[rbp-256]

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movups	xmm2, XMMWORD PTR dirAxis$10[rbp-256]
	shufps	xmm3, xmm3, 0
	mulps	xmm2, xmm3
	movups	XMMWORD PTR $T13[rbp-256], xmm2

; 1401 :                {
; 1402 :                   DrawHatchedAxis(dirAxis * scaleDisplay[i]);

	call	?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z ; ImGuizmo::DrawHatchedAxis
$LN745@DrawScaleG:

; 1365 :       for (int i = 0; i < 3; i++)

	mov	esi, DWORD PTR op$1$[rbp-256]
	mov	r14d, DWORD PTR type$GSCopy$1$[rsp]
	mov	edi, DWORD PTR i$1$[rsp]
$LN2@DrawScaleG:
	inc	edi
	rol	r12d, 1
	inc	r13
	mov	DWORD PTR i$1$[rsp], edi
	mov	DWORD PTR $T9[rsp], r12d
	mov	QWORD PTR $T5[rsp], r13
	cmp	edi, 3
	jl	$LL744@DrawScaleG
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	mov	esi, DWORD PTR colors$1$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1365 :       for (int i = 0; i < 3; i++)

	movaps	xmm15, XMMWORD PTR [rsp+816]
	movaps	xmm14, XMMWORD PTR [rsp+832]
	movaps	xmm13, XMMWORD PTR [rsp+848]
	movaps	xmm12, XMMWORD PTR [rsp+864]
	movaps	xmm11, XMMWORD PTR [rsp+880]
	mov	r13, QWORD PTR [rsp+1048]
	mov	r12, QWORD PTR [rsp+1040]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	test	esi, -16777216				; ff000000H
	je	SHORT $LN32@DrawScaleG
	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+36
	comiss	xmm8, xmm2
	ja	SHORT $LN32@DrawScaleG

; 1186 :         _PathArcToN(center, radius, a_min, a_max, num_segments);

	movss	xmm0, DWORD PTR __real@40c2c75c
	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+1040
	mov	DWORD PTR [rsp+40], 31
	xorps	xmm3, xmm3
	mov	rcx, rbx
	movss	DWORD PTR [rsp+32], xmm0
	call	?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::_PathArcToN
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rbx+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1186 :         _PathArcToN(center, radius, a_min, a_max, num_segments);

	lea	rdi, QWORD PTR [rbx+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	rdx, QWORD PTR [rbx+128]
	mov	r9d, esi
	mov	rcx, rbx
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	DWORD PTR [rdi], 0
$LN32@DrawScaleG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1411 :       if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID) && IsScaleType(type))

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	je	$LN841@DrawScaleG
	mov	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	cmp	eax, -1
	je	SHORT $LN18@DrawScaleG
	cmp	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440
	jne	$LN841@DrawScaleG
$LN18@DrawScaleG:

; 633  :      return type >= MT_SCALE_X && type <= MT_SCALE_XYZ;

	lea	eax, DWORD PTR [r14-12]

; 1411 :       if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID) && IsScaleType(type))

	cmp	eax, 3
	ja	$LN841@DrawScaleG

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468

; 1412 :       {
; 1413 :          //ImVec2 sourcePosOnScreen = worldToPos(gContext.mMatrixOrigin, gContext.mViewProjection);
; 1414 :          ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);
; 1415 :          /*vec_t dif(destinationPosOnScreen.x - sourcePosOnScreen.x, destinationPosOnScreen.y - sourcePosOnScreen.y);
; 1416 :          dif.Normalize();
; 1417 :          dif *= 5.f;
; 1418 :          drawList->AddCircle(sourcePosOnScreen, 6.f, translationLineColor);
; 1419 :          drawList->AddCircle(destinationPosOnScreen, 6.f, translationLineColor);
; 1420 :          drawList->AddLine(ImVec2(sourcePosOnScreen.x + dif.x, sourcePosOnScreen.y + dif.y), ImVec2(destinationPosOnScreen.x - dif.x, destinationPosOnScreen.y - dif.y), translationLineColor, 2.f);
; 1421 :          */
; 1422 :          char tmps[512];
; 1423 :          //vec_t deltaInfo = gContext.mModel.v.position - gContext.mMatrixOrigin;
; 1424 :          int componentInfoIndex = (type - MT_SCALE_X) * 3;

	lea	eax, DWORD PTR [rax+rax*2]

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm4, xmm8

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460

; 1425 :          ImFormatString(tmps, sizeof(tmps), scaleInfoMask[type - MT_SCALE_X], scaleDisplay[translationInfoIndex[componentInfoIndex]]);

	mov	edx, 512				; 00000200H

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+888
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+872
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+904
	movss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+876
	mulss	xmm2, xmm6

; 1425 :          ImFormatString(tmps, sizeof(tmps), scaleInfoMask[type - MT_SCALE_X], scaleDisplay[translationInfoIndex[componentInfoIndex]]);

	movsxd	rcx, eax

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm1, xmm3

; 1425 :          ImFormatString(tmps, sizeof(tmps), scaleInfoMask[type - MT_SCALE_X], scaleDisplay[translationInfoIndex[componentInfoIndex]]);

	movsxd	r8, r14d

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	mulss	xmm9, xmm6

; 1425 :          ImFormatString(tmps, sizeof(tmps), scaleInfoMask[type - MT_SCALE_X], scaleDisplay[translationInfoIndex[componentInfoIndex]]);

	movsxd	rax, DWORD PTR ?translationInfoIndex@ImGuizmo@@3QBHB[r15+rcx*4]
	lea	rcx, QWORD PTR tmps$20[rbp-256]

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm0, xmm5

; 1425 :          ImFormatString(tmps, sizeof(tmps), scaleInfoMask[type - MT_SCALE_X], scaleDisplay[translationInfoIndex[componentInfoIndex]]);

	mov	r8, QWORD PTR ?scaleInfoMask@ImGuizmo@@3PAPEBDA[r15+r8*8-96]

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm0

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+860
	mulss	xmm0, xmm5

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+892
	addss	xmm9, xmm0
	mulss	xmm1, xmm3
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+864
	mulss	xmm0, xmm5
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+920
	addss	xmm9, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+896
	mulss	xmm1, xmm3
	movss	xmm3, DWORD PTR scaleDisplay$[rbp+rax*4-256]

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm4, xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+908

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+880
	mulss	xmm2, xmm6

; 1425 :          ImFormatString(tmps, sizeof(tmps), scaleInfoMask[type - MT_SCALE_X], scaleDisplay[translationInfoIndex[componentInfoIndex]]);

	cvtps2pd xmm3, xmm3

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm9, xmm4

; 1425 :          ImFormatString(tmps, sizeof(tmps), scaleInfoMask[type - MT_SCALE_X], scaleDisplay[translationInfoIndex[componentInfoIndex]]);

	movq	r9, xmm3

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm9, xmm8

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm1

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+912

; 808  :       trans.y *= size.y;

	addss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm4

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm2, xmm8

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm10, xmm2

; 807  :       trans.x *= size.x;

	mulss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1425 :          ImFormatString(tmps, sizeof(tmps), scaleInfoMask[type - MT_SCALE_X], scaleDisplay[translationInfoIndex[componentInfoIndex]]);

	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+264
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1426 :          drawList->AddText(ImVec2(destinationPosOnScreen.x + 15, destinationPosOnScreen.y + 15), GetColorU32(TEXT_SHADOW), tmps);

	movaps	xmm0, xmm9

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	mov	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	rdi, -1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1426 :          drawList->AddText(ImVec2(destinationPosOnScreen.x + 15, destinationPosOnScreen.y + 15), GetColorU32(TEXT_SHADOW), tmps);

	addss	xmm0, DWORD PTR __real@41700000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T7[rsp], xmm0
	movaps	xmm0, xmm10
	addss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR $T7[rsp+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	test	eax, -16777216				; ff000000H
	je	SHORT $LN334@DrawScaleG

; 1579 :         return;
; 1580 : 
; 1581 :     if (text_end == NULL)
; 1582 :         text_end = text_begin + strlen(text_begin);

	lea	rcx, QWORD PTR tmps$20[rbp-256]
	mov	rax, rdi
	npad	7
$LL735@DrawScaleG:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL735@DrawScaleG
	lea	rcx, QWORD PTR tmps$20[rbp-256]
	add	rcx, rax

; 1583 :     if (text_begin == text_end)

	lea	rax, QWORD PTR tmps$20[rbp-256]
	cmp	rax, rcx
	je	SHORT $LN334@DrawScaleG

; 1584 :         return;
; 1585 : 
; 1586 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1587 :     if (font == NULL)
; 1588 :         font = _Data->Font;

	mov	rax, QWORD PTR [rbx+56]

; 1589 :     if (font_size == 0.0f)
; 1590 :         font_size = _Data->FontSize;
; 1591 : 
; 1592 :     IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
; 1593 : 
; 1594 :     ImVec4 clip_rect = _CmdHeader.ClipRect;
; 1595 :     if (cpu_fine_clip_rect)
; 1596 :     {
; 1597 :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
; 1598 :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
; 1599 :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
; 1600 :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
; 1601 :     }
; 1602 :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

	lea	r9, QWORD PTR $T7[rsp]
	movups	xmm0, XMMWORD PTR [rbx+136]
	mov	BYTE PTR [rsp+72], 0
	mov	rdx, rbx
	movss	DWORD PTR [rsp+64], xmm7
	movss	xmm2, DWORD PTR [rax+16]
	mov	QWORD PTR [rsp+56], rcx
	lea	rcx, QWORD PTR tmps$20[rbp-256]
	mov	QWORD PTR [rsp+48], rcx
	lea	rcx, QWORD PTR clip_rect$12[rbp-256]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR clip_rect$12[rbp-256], xmm0
	mov	DWORD PTR [rsp+32], r8d
	call	?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
$LN334@DrawScaleG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+248
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r8d, eax

; 1427 :          drawList->AddText(ImVec2(destinationPosOnScreen.x + 14, destinationPosOnScreen.y + 14), GetColorU32(TEXT), tmps);

	addss	xmm9, DWORD PTR __real@41600000
	addss	xmm10, DWORD PTR __real@41600000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T6[rsp], xmm9
	movss	DWORD PTR $T6[rsp+4], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	test	eax, -16777216				; ff000000H
	je	SHORT $LN841@DrawScaleG

; 1579 :         return;
; 1580 : 
; 1581 :     if (text_end == NULL)
; 1582 :         text_end = text_begin + strlen(text_begin);

	lea	rax, QWORD PTR tmps$20[rbp-256]
	npad	1
$LL734@DrawScaleG:
	inc	rdi
	cmp	BYTE PTR [rax+rdi], 0
	jne	SHORT $LL734@DrawScaleG
	lea	rcx, QWORD PTR tmps$20[rbp-256]
	add	rcx, rdi

; 1583 :     if (text_begin == text_end)

	lea	rax, QWORD PTR tmps$20[rbp-256]
	cmp	rax, rcx
	je	SHORT $LN841@DrawScaleG

; 1584 :         return;
; 1585 : 
; 1586 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1587 :     if (font == NULL)
; 1588 :         font = _Data->Font;

	mov	rax, QWORD PTR [rbx+56]

; 1589 :     if (font_size == 0.0f)
; 1590 :         font_size = _Data->FontSize;
; 1591 : 
; 1592 :     IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
; 1593 : 
; 1594 :     ImVec4 clip_rect = _CmdHeader.ClipRect;
; 1595 :     if (cpu_fine_clip_rect)
; 1596 :     {
; 1597 :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
; 1598 :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
; 1599 :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
; 1600 :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
; 1601 :     }
; 1602 :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

	lea	r9, QWORD PTR $T6[rsp]
	movups	xmm0, XMMWORD PTR [rbx+136]
	mov	BYTE PTR [rsp+72], 0
	mov	rdx, rbx
	movss	DWORD PTR [rsp+64], xmm7
	movss	xmm2, DWORD PTR [rax+16]
	mov	QWORD PTR [rsp+56], rcx
	lea	rcx, QWORD PTR tmps$20[rbp-256]
	mov	QWORD PTR [rsp+48], rcx
	lea	rcx, QWORD PTR clip_rect$11[rbp-256]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR clip_rect$11[rbp-256], xmm0
	mov	DWORD PTR [rsp+32], r8d
	call	?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
$LN841@DrawScaleG:
	movaps	xmm9, XMMWORD PTR [rsp+912]
	movaps	xmm8, XMMWORD PTR [rsp+928]
	movaps	xmm6, XMMWORD PTR [rsp+960]
	movaps	xmm7, XMMWORD PTR [rsp+944]
	mov	r15, QWORD PTR [rsp+976]
	mov	rdi, QWORD PTR [rsp+1024]
	movaps	xmm10, XMMWORD PTR [rsp+896]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1429 :    }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 984				; 000003d8H
	pop	r14
	pop	rsi
	pop	rbx
	pop	rbp
$LN842@DrawScaleG:
	ret	0
$LN741@DrawScaleG:

; 1365 :       for (int i = 0; i < 3; i++)

	movss	xmm8, DWORD PTR __real@3f000000
	xorps	xmm7, xmm7
	jmp	$LN2@DrawScaleG
?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z ENDP	; ImGuizmo::DrawScaleGizmo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
_TEXT	SEGMENT
belowAxisLimit$3 = 80
tv5490 = 88
$T4 = 88
$T5 = 88
belowPlaneLimit$6 = 96
vtx_inner_idx$1$ = 100
i$1$ = 104
$T7 = 108
colors$1$ = 112
col$1$ = 116
col_trans$1$ = 120
vtx_count$1$ = 124
type$GSCopy$1$ = 128
op$1$ = 132
clip_rect$8 = 136
clip_rect$9 = 136
dirAxis$10 = 136
worldDirSSpace$11 = 152
drawList$1$ = 160
dirPlaneY$12 = 168
dirPlaneX$13 = 184
scaleDisplay$ = 200
colors$ = 216
tmps$14 = 256
__$ArrayPad$ = 768
op$ = 992
type$ = 1000
?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z PROC ; ImGuizmo::DrawScaleUniveralGizmo, COMDAT

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	ecx, 14336				; 00003800H

; 1435 : 
; 1436 :       if (!Intersects(op, SCALEU))

	je	$LN537@DrawScaleU
	mov	r11, rsp
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	lea	rbp, QWORD PTR [r11-728]
	sub	rsp, 952				; 000003b8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 1100 :       if (gContext.mbEnable)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1085, 0

; 1433 :    {

	mov	esi, edx

; 1434 :       ImDrawList* drawList = gContext.mDrawList;

	mov	rbx, QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A
	mov	edi, ecx

; 1435 : 
; 1436 :       if (!Intersects(op, SCALEU))

	mov	QWORD PTR [r11+8], r12
	mov	QWORD PTR [r11+24], r13
	mov	QWORD PTR [r11+32], r14
	mov	QWORD PTR [r11-40], r15
	movaps	XMMWORD PTR [r11-56], xmm6
	movaps	XMMWORD PTR [r11-72], xmm7
	movaps	XMMWORD PTR [r11-88], xmm8
	movaps	XMMWORD PTR [r11-104], xmm9
	movaps	XMMWORD PTR [r11-120], xmm10
	movaps	XMMWORD PTR [r11-136], xmm11
	movaps	XMMWORD PTR [r11-152], xmm12
	movaps	XMMWORD PTR [r11-168], xmm13
	movaps	XMMWORD PTR [r11-184], xmm14
	movaps	XMMWORD PTR [r11-200], xmm15
	mov	DWORD PTR type$GSCopy$1$[rbp-256], edx
	mov	DWORD PTR op$1$[rbp-256], ecx
	mov	QWORD PTR drawList$1$[rbp-256], rbx

; 1100 :       if (gContext.mbEnable)

	je	SHORT $LN128@DrawScaleU

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+136
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r8d, eax

; 1124 :             colors[0] = (type == MT_SCALE_XYZ) ? selectionColor : IM_COL32_WHITE;

	cmp	esi, 15
	mov	eax, -1					; ffffffffH
	cmove	eax, r8d
	mov	DWORD PTR colors$1$[rsp], eax
	mov	DWORD PTR colors$[rbp-256], eax

; 1125 :             for (int i = 0; i < 3; i++)
; 1126 :             {
; 1127 :                colors[i + 1] = (type == (int)(MT_SCALE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	cmp	esi, 12
	jne	SHORT $LN144@DrawScaleU
	mov	DWORD PTR colors$[rbp-252], r8d
$LN374@DrawScaleU:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+56
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	DWORD PTR colors$[rbp-248], eax

; 1127 :                colors[i + 1] = (type == (int)(MT_SCALE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	cmp	esi, 14
	je	SHORT $LN378@DrawScaleU
$LN377@DrawScaleU:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+72
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r8d, eax
$LN378@DrawScaleU:

; 1127 :                colors[i + 1] = (type == (int)(MT_SCALE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	mov	DWORD PTR colors$[rbp-244], r8d

; 1128 :             }
; 1129 :             break;
; 1130 :          // note: this internal function is only called with three possible values for operation
; 1131 :          default:
; 1132 :             break;
; 1133 :          }
; 1134 :       }

	jmp	SHORT $LL126@DrawScaleU
$LN144@DrawScaleU:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+40
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	DWORD PTR colors$[rbp-252], eax

; 1127 :                colors[i + 1] = (type == (int)(MT_SCALE_X + i)) ? selectionColor : GetColorU32(DIRECTION_X + i);

	cmp	esi, 13
	jne	SHORT $LN374@DrawScaleU
	mov	DWORD PTR colors$[rbp-248], r8d
	jmp	SHORT $LN377@DrawScaleU
$LN128@DrawScaleU:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+152
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	DWORD PTR colors$1$[rsp], eax

; 1140 :             colors[i] = inactiveColor;

	mov	DWORD PTR colors$[rbp-256], eax
	mov	DWORD PTR colors$[rbp-252], eax
	mov	DWORD PTR colors$[rbp-248], eax
	mov	DWORD PTR colors$[rbp-244], eax
	mov	DWORD PTR colors$[rbp-240], eax
	mov	DWORD PTR colors$[rbp-236], eax
	mov	DWORD PTR colors$[rbp-232], eax
	npad	12
$LL126@DrawScaleU:

; 1437 :       {
; 1438 :          return;
; 1439 :       }
; 1440 : 
; 1441 :       // colors
; 1442 :       ImU32 colors[7];
; 1443 :       ComputeColors(colors, type, SCALEU);
; 1444 : 
; 1445 :       // draw
; 1446 :       vec_t scaleDisplay = { 1.f, 1.f, 1.f, 1.f };
; 1447 : 
; 1448 :       if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID))

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
	movups	XMMWORD PTR scaleDisplay$[rbp-256], xmm0
	je	SHORT $LN6@DrawScaleU
	mov	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	cmp	eax, -1
	je	SHORT $LN7@DrawScaleU
	cmp	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440
	jne	SHORT $LN6@DrawScaleU
$LN7@DrawScaleU:

; 1449 :       {
; 1450 :          scaleDisplay = gContext.mScale;

	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1176
	movups	XMMWORD PTR scaleDisplay$[rbp-256], xmm0
$LN6@DrawScaleU:

; 1453 :       for (int i = 0; i < 3; i++)

	movss	xmm8, DWORD PTR __xmm@80000000800000008000000080000000
	xor	r15d, r15d
	movss	xmm15, DWORD PTR __real@3fb33333
	xor	r13d, r13d
	movss	xmm11, DWORD PTR __real@3f800000
	mov	r12d, 1
	movss	xmm10, DWORD PTR __real@3f000000
	xorps	xmm9, xmm9
	movss	xmm14, DWORD PTR __real@358637bd
	movss	xmm13, DWORD PTR __real@42c80000
	mov	QWORD PTR tv5490[rsp], r13
	mov	DWORD PTR i$1$[rsp], r15d
	mov	DWORD PTR $T7[rsp], r12d
	npad	9
$LL4@DrawScaleU:

; 1454 :       {
; 1455 :          if (!Intersects(op, static_cast<OPERATION>(SCALE_XU << i)))

	mov	ecx, r15d
	mov	eax, 2048				; 00000800H
	shl	eax, cl

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	eax, edi

; 1454 :       {
; 1455 :          if (!Intersects(op, static_cast<OPERATION>(SCALE_XU << i)))

	je	$LN2@DrawScaleU

; 1456 :          {
; 1457 :             continue;
; 1458 :          }
; 1459 :          const bool usingAxis = (gContext.mbUsing && type == MT_SCALE_X + i);

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	je	SHORT $LN15@DrawScaleU
	lea	eax, DWORD PTR [r15+12]
	cmp	esi, eax
	jne	SHORT $LN15@DrawScaleU
	mov	al, 1
	jmp	SHORT $LN16@DrawScaleU
$LN15@DrawScaleU:
	xor	al, al
$LN16@DrawScaleU:

; 1460 :          if (!gContext.mbUsing || usingAxis)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	je	SHORT $LN10@DrawScaleU
	test	al, al
	je	$LN2@DrawScaleU
$LN10@DrawScaleU:

; 1461 :          {
; 1462 :             vec_t dirPlaneX, dirPlaneY, dirAxis;
; 1463 :             bool belowAxisLimit, belowPlaneLimit;
; 1464 :             ComputeTripodAxisAndVisibility(i, dirAxis, dirPlaneX, dirPlaneY, belowAxisLimit, belowPlaneLimit, true);

	lea	rax, QWORD PTR belowPlaneLimit$6[rsp]
	mov	BYTE PTR [rsp+48], 1
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR dirPlaneY$12[rbp-256]
	lea	rax, QWORD PTR belowAxisLimit$3[rsp]
	lea	r8, QWORD PTR dirPlaneX$13[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR dirAxis$10[rbp-256]
	call	?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z ; ImGuizmo::ComputeTripodAxisAndVisibility

; 1465 : 
; 1466 :             // draw axis
; 1467 :             if (belowAxisLimit)

	cmp	BYTE PTR belowAxisLimit$3[rsp], 0
	je	$LN2@DrawScaleU

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	mov	eax, r12d
	and	eax, edi

; 74   :      return (lhs & rhs) == rhs;

	cmp	eax, r12d

; 1468 :             {
; 1469 :                bool hasTranslateOnAxis = Contains(op, static_cast<OPERATION>(TRANSLATE_X << i));
; 1470 :                float markerScale = hasTranslateOnAxis ? 1.4f : 1.0f;

	jne	SHORT $LN17@DrawScaleU
	movaps	xmm2, xmm15
	jmp	SHORT $LN18@DrawScaleU
$LN17@DrawScaleU:
	movaps	xmm2, xmm11
$LN18@DrawScaleU:

; 1471 :                //ImVec2 baseSSpace = worldToPos(dirAxis * 0.1f * gContext.mScreenFactor, gContext.mMVPLocal);
; 1472 :                //ImVec2 worldDirSSpaceNoScale = worldToPos(dirAxis * markerScale * gContext.mScreenFactor, gContext.mMVP);
; 1473 :                ImVec2 worldDirSSpace = worldToPos((dirAxis * markerScale * scaleDisplay[i]) * gContext.mScreenFactor, gContext.mMVPLocal);

	movss	xmm1, DWORD PTR scaleDisplay$[rbp+r13-256]

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm4, xmm10

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm6, DWORD PTR dirAxis$10[rbp-256]
	movss	xmm7, DWORD PTR dirAxis$10[rbp-252]
	movss	xmm5, DWORD PTR dirAxis$10[rbp-248]

; 1474 : 
; 1475 : #if 0
; 1476 :                if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID))
; 1477 :                {
; 1478 :                   drawList->AddLine(baseSSpace, worldDirSSpaceNoScale, IM_COL32(0x40, 0x40, 0x40, 0xFF), 3.f);
; 1479 :                   drawList->AddCircleFilled(worldDirSSpaceNoScale, 6.f, IM_COL32(0x40, 0x40, 0x40, 0xFF));
; 1480 :                }
; 1481 :                /*
; 1482 :                if (!hasTranslateOnAxis || gContext.mbUsing)
; 1483 :                {
; 1484 :                   drawList->AddLine(baseSSpace, worldDirSSpace, colors[i + 1], 3.f);
; 1485 :                }
; 1486 :                */
; 1487 : #endif
; 1488 :                drawList->AddCircleFilled(worldDirSSpace, 12.f, colors[i + 1]);

	mov	r14d, DWORD PTR colors$[rbp+r13-252]

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm7, xmm2

; 1474 : 
; 1475 : #if 0
; 1476 :                if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID))
; 1477 :                {
; 1478 :                   drawList->AddLine(baseSSpace, worldDirSSpaceNoScale, IM_COL32(0x40, 0x40, 0x40, 0xFF), 3.f);
; 1479 :                   drawList->AddCircleFilled(worldDirSSpaceNoScale, 6.f, IM_COL32(0x40, 0x40, 0x40, 0xFF));
; 1480 :                }
; 1481 :                /*
; 1482 :                if (!hasTranslateOnAxis || gContext.mbUsing)
; 1483 :                {
; 1484 :                   drawList->AddLine(baseSSpace, worldDirSSpace, colors[i + 1], 3.f);
; 1485 :                }
; 1486 :                */
; 1487 : #endif
; 1488 :                drawList->AddCircleFilled(worldDirSSpace, 12.f, colors[i + 1]);

	mov	DWORD PTR col$1$[rsp], r14d

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm6, xmm2
	mulss	xmm5, xmm2

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm7, xmm1

; 1471 :                //ImVec2 baseSSpace = worldToPos(dirAxis * 0.1f * gContext.mScreenFactor, gContext.mMVPLocal);
; 1472 :                //ImVec2 worldDirSSpaceNoScale = worldToPos(dirAxis * markerScale * gContext.mScreenFactor, gContext.mMVP);
; 1473 :                ImVec2 worldDirSSpace = worldToPos((dirAxis * markerScale * scaleDisplay[i]) * gContext.mScreenFactor, gContext.mMVPLocal);

	mulss	xmm6, xmm1

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm5, xmm1
	mulss	xmm7, xmm0
	mulss	xmm6, xmm0
	mulss	xmm5, xmm0

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movaps	xmm2, xmm7
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+824
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+808
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+840

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movaps	xmm3, xmm6
	mulss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+796

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+812
	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+800
	mulss	xmm0, xmm7
	addss	xmm2, xmm1
	mulss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+816
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+828
	addss	xmm3, xmm0
	mulss	xmm1, xmm5

; 806  :       trans.y = 1.f - trans.y;

	movaps	xmm0, xmm11

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+832
	addss	xmm7, xmm6
	addss	xmm3, xmm1

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];
; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+856
	addss	xmm7, xmm5
	addss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+844

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm4, xmm2

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+848

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm3, xmm4
	mulss	xmm7, xmm4

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm3, xmm10

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm7, xmm10

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412
	subss	xmm0, xmm7

; 807  :       trans.x *= size.x;
; 808  :       trans.y *= size.y;

	addss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR worldDirSSpace$11[rbp-256], xmm3
	addss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
	movss	DWORD PTR worldDirSSpace$11[rbp-252], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	test	r14d, -16777216				; ff000000H
	je	$LN2@DrawScaleU

; 1509 :         return;
; 1510 : 
; 1511 :     if (num_segments <= 0)
; 1512 :     {
; 1513 :         // Use arc with automatic segment count
; 1514 :         _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	movss	xmm2, DWORD PTR __real@41400000
	lea	rdx, QWORD PTR worldDirSSpace$11[rbp-256]
	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], 48			; 00000030H
	mov	rcx, rbx
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx

; 1515 :         _Path.Size--;

	mov	esi, DWORD PTR [rbx+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	rdi, QWORD PTR [rbx+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1515 :         _Path.Size--;

	dec	esi
	mov	DWORD PTR [rbx+120], esi

; 975  :     if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)

	cmp	esi, 3
	jl	$LN223@DrawScaleU

; 976  :         return;
; 977  : 
; 978  :     const ImVec2 uv = _Data->TexUvWhitePixel;
; 979  : 
; 980  :     if (Flags & ImDrawListFlags_AntiAliasedFill)

	test	BYTE PTR [rbx+48], 4
	mov	rcx, rbx
	mov	rax, QWORD PTR [rbx+56]
	movss	xmm6, DWORD PTR [rax]
	movss	xmm7, DWORD PTR [rax+4]
	je	$LN224@DrawScaleU

; 981  :     {
; 982  :         // Anti-aliased Fill
; 983  :         const float AA_SIZE = _FringeScale;

	movss	xmm12, DWORD PTR [rbx+192]

; 984  :         const ImU32 col_trans = col & ~IM_COL32_A_MASK;
; 985  :         const int idx_count = (points_count - 2)*3 + points_count * 6;

	lea	edx, DWORD PTR [rsi*8-6]
	mov	eax, r14d
	add	edx, esi
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR col_trans$1$[rsp], eax

; 986  :         const int vtx_count = (points_count * 2);

	lea	eax, DWORD PTR [rsi+rsi]

; 987  :         PrimReserve(idx_count, vtx_count);

	mov	r8d, eax
	mov	DWORD PTR vtx_count$1$[rsp], eax
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 988  : 
; 989  :         // Add indexes for fill
; 990  :         unsigned int vtx_inner_idx = _VtxCurrentIdx;

	mov	r13d, DWORD PTR [rbx+52]
	lea	r14, QWORD PTR [rbx+80]
	mov	DWORD PTR vtx_inner_idx$1$[rsp], r13d
	mov	r8d, 2
	mov	ebx, r13d
	npad	8
$LL209@DrawScaleU:

; 991  :         unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;
; 992  :         for (int i = 2; i < points_count; i++)
; 993  :         {
; 994  :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));

	mov	rax, QWORD PTR [r14]
	movzx	edx, r8w
	add	dx, dx
	inc	r8d
	add	dx, bx
	mov	WORD PTR [rax], bx
	mov	rax, QWORD PTR [r14]
	lea	ecx, DWORD PTR [rdx-2]
	mov	WORD PTR [rax+2], cx
	mov	rax, QWORD PTR [r14]
	mov	WORD PTR [rax+4], dx

; 995  :             _IdxWritePtr += 3;

	add	QWORD PTR [r14], 6
	cmp	r8d, esi
	jl	SHORT $LL209@DrawScaleU

; 996  :         }
; 997  : 
; 998  :         // Compute normals
; 999  :         _Data->TempBuffer.reserve_discard(points_count);

	mov	rbx, QWORD PTR drawList$1$[rbp-256]
	mov	r15, QWORD PTR [rbx+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	cmp	esi, DWORD PTR [r15+52]
	jle	SHORT $LN230@DrawScaleU
	mov	rcx, QWORD PTR [r15+56]
	test	rcx, rcx
	je	SHORT $LN238@DrawScaleU
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN236@DrawScaleU

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN236@DrawScaleU:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN238@DrawScaleU:

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN243@DrawScaleU

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN243@DrawScaleU:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	movsxd	rcx, esi
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	mov	QWORD PTR [r15+56], rax
	mov	DWORD PTR [r15+52], esi
$LN230@DrawScaleU:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1000 :         ImVec2* temp_normals = _Data->TempBuffer.Data;

	mov	rax, QWORD PTR [rbx+56]

; 1001 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	lea	r12d, DWORD PTR [rsi-1]
	mov	r11, rdi
	xor	r13d, r13d
	xor	r9d, r9d
	neg	r11
	mov	r10, QWORD PTR [rax+56]
	movsxd	rax, r12d
	cmp	esi, 4
	jl	$LN476@DrawScaleU
	lea	r8, QWORD PTR [rax*8]
	mov	rdx, r10
	lea	eax, DWORD PTR [rsi-4]
	sub	rdx, rdi
	shr	eax, 2
	lea	rcx, QWORD PTR [rdi+12]
	inc	eax
	mov	r15d, eax
	lea	r13d, DWORD PTR [rax*4]
	npad	4
$LL437@DrawScaleU:

; 1002 :         {
; 1003 :             const ImVec2& p0 = points[i0];
; 1004 :             const ImVec2& p1 = points[i1];
; 1005 :             float dx = p1.x - p0.x;

	movss	xmm2, DWORD PTR [rcx-12]

; 1006 :             float dy = p1.y - p0.y;

	movss	xmm3, DWORD PTR [rcx-8]
	subss	xmm2, DWORD PTR [rdi+r8]
	subss	xmm3, DWORD PTR [rdi+r8+4]

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm9
	jbe	SHORT $LN433@DrawScaleU
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN433@DrawScaleU:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [r10+r8], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm8
	movss	DWORD PTR [r10+r8+4], xmm2
	movss	xmm2, DWORD PTR [rcx-4]
	movss	xmm3, DWORD PTR [rcx]
	subss	xmm2, DWORD PTR [rcx-12]
	subss	xmm3, DWORD PTR [rcx-8]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm9
	jbe	SHORT $LN434@DrawScaleU
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN434@DrawScaleU:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rdx+rcx-12], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm8
	movss	DWORD PTR [rdx+rcx-8], xmm2
	movss	xmm2, DWORD PTR [rcx+4]
	movss	xmm3, DWORD PTR [rcx+8]
	subss	xmm2, DWORD PTR [rcx-4]
	subss	xmm3, DWORD PTR [rcx]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm9
	jbe	SHORT $LN435@DrawScaleU
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN435@DrawScaleU:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rdx+rcx-4], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm8
	movss	DWORD PTR [rdx+rcx], xmm2
	movss	xmm2, DWORD PTR [rcx+12]
	movss	xmm3, DWORD PTR [rcx+16]
	subss	xmm2, DWORD PTR [rcx+4]
	subss	xmm3, DWORD PTR [rcx+8]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm9
	jbe	SHORT $LN436@DrawScaleU
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN436@DrawScaleU:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rdx+rcx+4], xmm3
	lea	r8, QWORD PTR [rcx+12]

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm8
	lea	rax, QWORD PTR [r9+3]
	movss	DWORD PTR [rdx+rcx+8], xmm2
	add	r8, r11
	add	rcx, 32					; 00000020H
	add	r9, 4
	sub	r15, 1
	jne	$LL437@DrawScaleU

; 1001 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	cmp	r13d, esi
	jge	SHORT $LN538@DrawScaleU
$LN476@DrawScaleU:
	mov	r8d, esi
	lea	rcx, QWORD PTR [rax*8]
	sub	r8d, r13d
	lea	rdx, QWORD PTR [rdi+r9*8]
$LC466@DrawScaleU:

; 1002 :         {
; 1003 :             const ImVec2& p0 = points[i0];
; 1004 :             const ImVec2& p1 = points[i1];
; 1005 :             float dx = p1.x - p0.x;

	movss	xmm2, DWORD PTR [rdx]

; 1006 :             float dy = p1.y - p0.y;

	movss	xmm3, DWORD PTR [rdx+4]
	subss	xmm2, DWORD PTR [rdi+rcx]
	subss	xmm3, DWORD PTR [rdi+rcx+4]

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm9
	jbe	SHORT $LN226@DrawScaleU
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN226@DrawScaleU:

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm8
	movss	DWORD PTR [r10+rcx], xmm3
	movss	DWORD PTR [r10+rcx+4], xmm2
	lea	rcx, QWORD PTR [rdx+r11]
	add	rdx, 8
	sub	r8, 1
	jne	SHORT $LC466@DrawScaleU
	lea	r14, QWORD PTR [rbx+80]
$LN538@DrawScaleU:
	mov	r13d, DWORD PTR vtx_inner_idx$1$[rsp]

; 1010 :         }
; 1011 : 
; 1012 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	lea	r9, QWORD PTR [rdi+4]
	xor	r15d, r15d
	mulss	xmm12, xmm10
	mov	r11, r10
	sub	r11, rdi
	mov	edi, DWORD PTR col$1$[rsp]
	npad	6
$LL215@DrawScaleU:

; 1013 :         {
; 1014 :             // Average normals
; 1015 :             const ImVec2& n0 = temp_normals[i0];
; 1016 :             const ImVec2& n1 = temp_normals[i1];
; 1017 :             float dm_x = (n0.x + n1.x) * 0.5f;

	movss	xmm2, DWORD PTR [r9+r11-4]

; 1018 :             float dm_y = (n0.y + n1.y) * 0.5f;

	movss	xmm3, DWORD PTR [r9+r11]
	movsxd	rax, r12d
	addss	xmm2, DWORD PTR [r10+rax*8]
	addss	xmm3, DWORD PTR [r10+rax*8+4]
	mulss	xmm2, xmm10
	mulss	xmm3, xmm10

; 1019 :             IM_FIXNORMAL2F(dm_x, dm_y);

	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm14
	jbe	SHORT $LN227@DrawScaleU
	movaps	xmm0, xmm11
	divss	xmm0, xmm1
	movaps	xmm1, xmm13
	minss	xmm1, xmm0
	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN227@DrawScaleU:

; 1020 :             dm_x *= AA_SIZE * 0.5f;
; 1021 :             dm_y *= AA_SIZE * 0.5f;
; 1022 : 
; 1023 :             // Add vertices
; 1024 :             _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner

	movss	xmm0, DWORD PTR [r9-4]

; 1025 :             _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
; 1026 :             _VtxWritePtr += 2;
; 1027 : 
; 1028 :             // Add indexes for fringes
; 1029 :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));

	movzx	edx, r15w
	mov	rax, QWORD PTR [rbx+72]
	add	r12w, r12w
	mov	ecx, DWORD PTR col_trans$1$[rsp]
	add	dx, dx
	mulss	xmm2, xmm12
	mulss	xmm3, xmm12
	lea	r8d, DWORD PTR [rdx+r13]
	subss	xmm0, xmm2
	movss	DWORD PTR [rax], xmm0
	movss	xmm1, DWORD PTR [r9]
	mov	rax, QWORD PTR [rbx+72]
	subss	xmm1, xmm3
	movss	DWORD PTR [rax+4], xmm1
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], edi
	addss	xmm2, DWORD PTR [r9-4]
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+20], xmm2
	addss	xmm3, DWORD PTR [r9]
	mov	rax, QWORD PTR [rbx+72]
	add	r9, 8
	movss	DWORD PTR [rax+24], xmm3
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+28], xmm6
	movss	DWORD PTR [rax+32], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+36], ecx
	lea	ecx, DWORD PTR [r12+r13]
	mov	rax, QWORD PTR [r14]
	add	QWORD PTR [rbx+72], 40			; 00000028H
	mov	WORD PTR [rax], r8w
	mov	rax, QWORD PTR [r14]
	mov	WORD PTR [rax+2], cx
	lea	ecx, DWORD PTR [r13+1]
	mov	rax, QWORD PTR [r14]
	add	cx, r12w
	mov	r12d, r15d
	inc	r15d
	mov	WORD PTR [rax+4], cx

; 1030 :             _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));

	mov	rax, QWORD PTR [r14]
	mov	WORD PTR [rax+6], cx
	lea	ecx, DWORD PTR [r13+1]
	mov	rax, QWORD PTR [r14]
	add	ecx, edx
	mov	WORD PTR [rax+8], cx
	mov	rax, QWORD PTR [r14]
	mov	WORD PTR [rax+10], r8w

; 1031 :             _IdxWritePtr += 6;

	add	QWORD PTR [r14], 12
	cmp	r15d, esi
	jl	$LL215@DrawScaleU

; 1032 :         }
; 1033 :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, WORD PTR vtx_count$1$[rsp]

; 1034 :     }

	mov	r15d, DWORD PTR i$1$[rsp]
	mov	r12d, DWORD PTR $T7[rsp]
	mov	r13, QWORD PTR tv5490[rsp]
	jmp	$LN539@DrawScaleU
$LN224@DrawScaleU:

; 1035 :     else
; 1036 :     {
; 1037 :         // Non Anti-aliased Fill
; 1038 :         const int idx_count = (points_count - 2)*3;

	lea	eax, DWORD PTR [rsi-2]

; 1039 :         const int vtx_count = points_count;
; 1040 :         PrimReserve(idx_count, vtx_count);

	mov	r8d, esi
	lea	edx, DWORD PTR [rax+rax*2]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve
	mov	ecx, esi
	npad	15
$LL218@DrawScaleU:

; 1041 :         for (int i = 0; i < vtx_count; i++)
; 1042 :         {
; 1043 :             _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	mov	rax, QWORD PTR [rbx+72]
	movsd	xmm0, QWORD PTR [rdi]
	lea	rdi, QWORD PTR [rdi+8]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r14d

; 1044 :             _VtxWritePtr++;

	add	QWORD PTR [rbx+72], 20
	sub	rcx, 1
	jne	SHORT $LL218@DrawScaleU
	mov	edx, 2
	npad	10
$LL221@DrawScaleU:

; 1045 :         }
; 1046 :         for (int i = 2; i < points_count; i++)
; 1047 :         {
; 1048 :             _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);

	mov	rcx, QWORD PTR [rbx+80]
	movzx	eax, WORD PTR [rbx+52]
	mov	WORD PTR [rcx], ax
	lea	ecx, DWORD PTR [rdx-1]
	add	cx, WORD PTR [rbx+52]
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+2], cx
	movzx	ecx, dx
	mov	rax, QWORD PTR [rbx+80]
	inc	edx
	add	cx, WORD PTR [rbx+52]
	mov	WORD PTR [rax+4], cx

; 1049 :             _IdxWritePtr += 3;

	add	QWORD PTR [rbx+80], 6
	cmp	edx, esi
	jl	SHORT $LL221@DrawScaleU

; 1050 :         }
; 1051 :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, si
$LN539@DrawScaleU:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	add	DWORD PTR [rbx+52], eax
$LN223@DrawScaleU:
	mov	esi, DWORD PTR type$GSCopy$1$[rbp-256]
	mov	edi, DWORD PTR op$1$[rbp-256]
	mov	DWORD PTR [rbx+120], 0
$LN2@DrawScaleU:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1453 :       for (int i = 0; i < 3; i++)

	inc	r15d
	rol	r12d, 1
	add	r13, 4
	mov	DWORD PTR i$1$[rsp], r15d
	mov	DWORD PTR $T7[rsp], r12d
	mov	QWORD PTR tv5490[rsp], r13
	cmp	r15d, 3
	jl	$LL4@DrawScaleU
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1484 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	mov	edi, DWORD PTR colors$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1453 :       for (int i = 0; i < 3; i++)

	movaps	xmm15, XMMWORD PTR [rsp+784]
	movaps	xmm14, XMMWORD PTR [rsp+800]
	movaps	xmm13, XMMWORD PTR [rsp+816]
	movaps	xmm12, XMMWORD PTR [rsp+832]
	movaps	xmm8, XMMWORD PTR [rsp+896]
	mov	r15, QWORD PTR [rsp+944]
	mov	r14, QWORD PTR [rsp+1016]
	mov	r13, QWORD PTR [rsp+1008]
	mov	r12, QWORD PTR [rsp+992]

; 1489 :             }
; 1490 :          }
; 1491 :       }
; 1492 : 
; 1493 :       // draw screen cirle
; 1494 :       drawList->AddCircle(gContext.mScreenSquareCenter, 20.f, colors[0], 32, gContext.mStyle.CenterCircleSize);

	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+36
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1484 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	test	edi, -16777216				; ff000000H
	je	SHORT $LN27@DrawScaleU

; 1186 :         _PathArcToN(center, radius, a_min, a_max, num_segments);

	movss	xmm0, DWORD PTR __real@40c2c75c
	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+1040
	movss	xmm2, DWORD PTR __real@419c0000
	movaps	xmm3, xmm9
	mov	DWORD PTR [rsp+40], 31
	mov	rcx, rbx
	movss	DWORD PTR [rsp+32], xmm0
	call	?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::_PathArcToN
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rbx+120]
	mov	r9d, edi
	mov	rdx, QWORD PTR [rbx+128]
	mov	rcx, rbx
	movss	DWORD PTR [rsp+40], xmm6
	mov	DWORD PTR [rsp+32], 1
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
	mov	DWORD PTR [rbx+120], 0
$LN27@DrawScaleU:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1496 :       if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID) && IsScaleType(type))

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	je	$LN536@DrawScaleU
	mov	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	cmp	eax, -1
	je	SHORT $LN13@DrawScaleU
	cmp	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440
	jne	$LN536@DrawScaleU
$LN13@DrawScaleU:

; 633  :      return type >= MT_SCALE_X && type <= MT_SCALE_XYZ;

	lea	eax, DWORD PTR [rsi-12]

; 1496 :       if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID) && IsScaleType(type))

	cmp	eax, 3
	ja	$LN536@DrawScaleU

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464

; 1497 :       {
; 1498 :          //ImVec2 sourcePosOnScreen = worldToPos(gContext.mMatrixOrigin, gContext.mViewProjection);
; 1499 :          ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);
; 1500 :          /*vec_t dif(destinationPosOnScreen.x - sourcePosOnScreen.x, destinationPosOnScreen.y - sourcePosOnScreen.y);
; 1501 :          dif.Normalize();
; 1502 :          dif *= 5.f;
; 1503 :          drawList->AddCircle(sourcePosOnScreen, 6.f, translationLineColor);
; 1504 :          drawList->AddCircle(destinationPosOnScreen, 6.f, translationLineColor);
; 1505 :          drawList->AddLine(ImVec2(sourcePosOnScreen.x + dif.x, sourcePosOnScreen.y + dif.y), ImVec2(destinationPosOnScreen.x - dif.x, destinationPosOnScreen.y - dif.y), translationLineColor, 2.f);
; 1506 :          */
; 1507 :          char tmps[512];
; 1508 :          //vec_t deltaInfo = gContext.mModel.v.position - gContext.mMatrixOrigin;
; 1509 :          int componentInfoIndex = (type - MT_SCALE_X) * 3;

	lea	eax, DWORD PTR [rax+rax*2]

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460

; 1510 :          ImFormatString(tmps, sizeof(tmps), scaleInfoMask[type - MT_SCALE_X], scaleDisplay[translationInfoIndex[componentInfoIndex]]);

	lea	rdx, OFFSET FLAT:__ImageBase

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468
	movaps	xmm2, xmm6
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+888
	movaps	xmm7, xmm6

; 1510 :          ImFormatString(tmps, sizeof(tmps), scaleInfoMask[type - MT_SCALE_X], scaleDisplay[translationInfoIndex[componentInfoIndex]]);

	movsxd	rcx, eax

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	mulss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+876

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movaps	xmm0, xmm5

; 1510 :          ImFormatString(tmps, sizeof(tmps), scaleInfoMask[type - MT_SCALE_X], scaleDisplay[translationInfoIndex[componentInfoIndex]]);

	movsxd	r8, esi

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+880

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];
; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movaps	xmm1, xmm4

; 1510 :          ImFormatString(tmps, sizeof(tmps), scaleInfoMask[type - MT_SCALE_X], scaleDisplay[translationInfoIndex[componentInfoIndex]]);

	movsxd	rax, DWORD PTR ?translationInfoIndex@ImGuizmo@@3QBHB[rdx+rcx*4]
	lea	rcx, QWORD PTR tmps$14[rbp-256]

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+872

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm3, xmm10

; 1510 :          ImFormatString(tmps, sizeof(tmps), scaleInfoMask[type - MT_SCALE_X], scaleDisplay[translationInfoIndex[componentInfoIndex]]);

	mov	r8, QWORD PTR ?scaleInfoMask@ImGuizmo@@3PAPEBDA[rdx+r8*8-96]
	mov	edx, 512				; 00000200H

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+904
	addss	xmm2, xmm0

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movaps	xmm0, xmm5

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	mulss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+864

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+860

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm6, xmm5

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];
; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm1
	movaps	xmm1, xmm4
	mulss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+896
	addss	xmm7, xmm0
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+892
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+920
	addss	xmm6, xmm4
	addss	xmm7, xmm1

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+908

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+912

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm3
	mulss	xmm6, xmm3
	movss	xmm3, DWORD PTR scaleDisplay$[rbp+rax*4-256]

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm7, xmm10

; 1510 :          ImFormatString(tmps, sizeof(tmps), scaleInfoMask[type - MT_SCALE_X], scaleDisplay[translationInfoIndex[componentInfoIndex]]);

	cvtps2pd xmm3, xmm3

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm6, xmm10

; 1510 :          ImFormatString(tmps, sizeof(tmps), scaleInfoMask[type - MT_SCALE_X], scaleDisplay[translationInfoIndex[componentInfoIndex]]);

	movq	r9, xmm3

; 808  :       trans.y *= size.y;

	addss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404
	subss	xmm11, xmm6
	mulss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1510 :          ImFormatString(tmps, sizeof(tmps), scaleInfoMask[type - MT_SCALE_X], scaleDisplay[translationInfoIndex[componentInfoIndex]]);

	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+264
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1511 :          drawList->AddText(ImVec2(destinationPosOnScreen.x + 15, destinationPosOnScreen.y + 15), GetColorU32(TEXT_SHADOW), tmps);

	movaps	xmm0, xmm7

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	mov	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	rdi, -1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1511 :          drawList->AddText(ImVec2(destinationPosOnScreen.x + 15, destinationPosOnScreen.y + 15), GetColorU32(TEXT_SHADOW), tmps);

	addss	xmm0, DWORD PTR __real@41700000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp], xmm0
	movaps	xmm0, xmm11
	addss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR $T5[rsp+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	test	eax, -16777216				; ff000000H
	je	SHORT $LN277@DrawScaleU

; 1579 :         return;
; 1580 : 
; 1581 :     if (text_end == NULL)
; 1582 :         text_end = text_begin + strlen(text_begin);

	lea	rcx, QWORD PTR tmps$14[rbp-256]
	mov	rax, rdi
	npad	3
$LL485@DrawScaleU:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL485@DrawScaleU
	lea	rcx, QWORD PTR tmps$14[rbp-256]
	add	rcx, rax

; 1583 :     if (text_begin == text_end)

	lea	rax, QWORD PTR tmps$14[rbp-256]
	cmp	rax, rcx
	je	SHORT $LN277@DrawScaleU

; 1584 :         return;
; 1585 : 
; 1586 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1587 :     if (font == NULL)
; 1588 :         font = _Data->Font;

	mov	rax, QWORD PTR [rbx+56]

; 1589 :     if (font_size == 0.0f)
; 1590 :         font_size = _Data->FontSize;
; 1591 : 
; 1592 :     IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
; 1593 : 
; 1594 :     ImVec4 clip_rect = _CmdHeader.ClipRect;
; 1595 :     if (cpu_fine_clip_rect)
; 1596 :     {
; 1597 :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
; 1598 :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
; 1599 :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
; 1600 :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
; 1601 :     }
; 1602 :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

	lea	r9, QWORD PTR $T5[rsp]
	movups	xmm0, XMMWORD PTR [rbx+136]
	mov	BYTE PTR [rsp+72], 0
	mov	rdx, rbx
	movss	DWORD PTR [rsp+64], xmm9
	movss	xmm2, DWORD PTR [rax+16]
	mov	QWORD PTR [rsp+56], rcx
	lea	rcx, QWORD PTR tmps$14[rbp-256]
	mov	QWORD PTR [rsp+48], rcx
	lea	rcx, QWORD PTR clip_rect$9[rbp-256]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR clip_rect$9[rbp-256], xmm0
	mov	DWORD PTR [rsp+32], r8d
	call	?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
$LN277@DrawScaleU:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+248
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r8d, eax

; 1512 :          drawList->AddText(ImVec2(destinationPosOnScreen.x + 14, destinationPosOnScreen.y + 14), GetColorU32(TEXT), tmps);

	addss	xmm7, DWORD PTR __real@41600000
	addss	xmm11, DWORD PTR __real@41600000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T4[rsp], xmm7
	movss	DWORD PTR $T4[rsp+4], xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	test	eax, -16777216				; ff000000H
	je	SHORT $LN536@DrawScaleU

; 1579 :         return;
; 1580 : 
; 1581 :     if (text_end == NULL)
; 1582 :         text_end = text_begin + strlen(text_begin);

	lea	rax, QWORD PTR tmps$14[rbp-256]
	npad	2
$LL484@DrawScaleU:
	inc	rdi
	cmp	BYTE PTR [rax+rdi], 0
	jne	SHORT $LL484@DrawScaleU
	lea	rcx, QWORD PTR tmps$14[rbp-256]
	add	rcx, rdi

; 1583 :     if (text_begin == text_end)

	lea	rax, QWORD PTR tmps$14[rbp-256]
	cmp	rax, rcx
	je	SHORT $LN536@DrawScaleU

; 1584 :         return;
; 1585 : 
; 1586 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1587 :     if (font == NULL)
; 1588 :         font = _Data->Font;

	mov	rax, QWORD PTR [rbx+56]

; 1589 :     if (font_size == 0.0f)
; 1590 :         font_size = _Data->FontSize;
; 1591 : 
; 1592 :     IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
; 1593 : 
; 1594 :     ImVec4 clip_rect = _CmdHeader.ClipRect;
; 1595 :     if (cpu_fine_clip_rect)
; 1596 :     {
; 1597 :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
; 1598 :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
; 1599 :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
; 1600 :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
; 1601 :     }
; 1602 :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

	lea	r9, QWORD PTR $T4[rsp]
	movups	xmm0, XMMWORD PTR [rbx+136]
	mov	BYTE PTR [rsp+72], 0
	mov	rdx, rbx
	movss	DWORD PTR [rsp+64], xmm9
	movss	xmm2, DWORD PTR [rax+16]
	mov	QWORD PTR [rsp+56], rcx
	lea	rcx, QWORD PTR tmps$14[rbp-256]
	mov	QWORD PTR [rsp+48], rcx
	lea	rcx, QWORD PTR clip_rect$8[rbp-256]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR clip_rect$8[rbp-256], xmm0
	mov	DWORD PTR [rsp+32], r8d
	call	?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
$LN536@DrawScaleU:
	movaps	xmm10, XMMWORD PTR [rsp+864]
	movaps	xmm9, XMMWORD PTR [rsp+880]
	movaps	xmm7, XMMWORD PTR [rsp+912]
	movaps	xmm6, XMMWORD PTR [rsp+928]
	movaps	xmm11, XMMWORD PTR [rsp+848]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1514 :    }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 952				; 000003b8H
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
$LN537@DrawScaleU:
	ret	0
?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z ENDP ; ImGuizmo::DrawScaleUniveralGizmo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z
_TEXT	SEGMENT
belowAxisLimit$ = 80
belowPlaneLimit$ = 81
tv5906 = 88
$T3 = 88
$T4 = 88
$T5 = 88
sourcePosOnScreen$6 = 88
op$1$ = 96
$T7 = 104
destinationPosOnScreen$8 = 104
$T9 = 104
dirAxis$2$ = 112
tv6037 = 112
tv6224 = 116
tv5983 = 116
?gContext@ImGuizmo@@3UContext@1@A$27 = 120
tv5968 = 120
?gContext@ImGuizmo@@3UContext@1@A$35 = 124
tv5962 = 124
dirAxis$3$ = 128
type$GSCopy$1$ = 132
clip_rect$10 = 136
clip_rect$11 = 136
dirPlaneY$12 = 136
worldDirSSpace$13 = 152
baseSSpace$14 = 160
$T15 = 168
$T16 = 176
dirPlaneX$17 = 184
deltaInfo$18 = 200
dirAxis$19 = 200
screenQuadPts$20 = 216
colors$ = 248
tmps$21 = 288
__$ArrayPad$ = 800
op$ = 1024
type$ = 1032
?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z PROC ; ImGuizmo::DrawTranslationGizmo, COMDAT

; 1517 :    {

	mov	r11, rsp
	push	rbp
	push	rdi
	push	r13
	lea	rbp, QWORD PTR [r11-760]
	sub	rsp, 992				; 000003e0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 1518 :       ImDrawList* drawList = gContext.mDrawList;

	mov	rdi, QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A
	mov	r13d, edx
	mov	DWORD PTR type$GSCopy$1$[rbp-256], edx
	mov	DWORD PTR op$1$[rsp], ecx
	test	rdi, rdi

; 1519 :       if (!drawList)

	je	$LN232@DrawTransl

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	cl, 7

; 1520 :       {
; 1521 :          return;
; 1522 :       }
; 1523 : 
; 1524 :       if(!Intersects(op, TRANSLATE))

	je	$LN232@DrawTransl
	mov	QWORD PTR [r11+8], rbx

; 1525 :       {
; 1526 :          return;
; 1527 :       }
; 1528 : 
; 1529 :       // colors
; 1530 :       ImU32 colors[7];
; 1531 :       ComputeColors(colors, type, TRANSLATE);

	lea	rcx, QWORD PTR colors$[rbp-256]
	mov	QWORD PTR [r11+24], rsi
	mov	r8d, 7
	mov	QWORD PTR [r11+32], r12
	mov	QWORD PTR [r11-32], r14
	mov	QWORD PTR [r11-40], r15
	movaps	XMMWORD PTR [r11-56], xmm6
	movaps	XMMWORD PTR [r11-72], xmm7
	movaps	XMMWORD PTR [r11-88], xmm8
	movaps	XMMWORD PTR [r11-104], xmm9
	movaps	XMMWORD PTR [r11-120], xmm10
	movaps	XMMWORD PTR [r11-136], xmm11
	movaps	XMMWORD PTR [r11-152], xmm12
	movaps	XMMWORD PTR [r11-168], xmm13
	movaps	XMMWORD PTR [r11-184], xmm14
	movaps	XMMWORD PTR [r11-200], xmm15
	call	?ComputeColors@ImGuizmo@@YAXPEAIHW4OPERATION@1@@Z ; ImGuizmo::ComputeColors

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464

; 1525 :       {
; 1526 :          return;
; 1527 :       }
; 1528 : 
; 1529 :       // colors
; 1530 :       ImU32 colors[7];
; 1531 :       ComputeColors(colors, type, TRANSLATE);

	lea	rbx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+40

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	lea	r15d, QWORD PTR [r8-6]
	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468

; 1525 :       {
; 1526 :          return;
; 1527 :       }
; 1528 : 
; 1529 :       // colors
; 1530 :       ImU32 colors[7];
; 1531 :       ComputeColors(colors, type, TRANSLATE);

	lea	r12d, QWORD PTR [r8+1]

; 804  :       trans *= 0.5f / trans.w;

	movss	xmm8, DWORD PTR __real@3f000000

; 1525 :       {
; 1526 :          return;
; 1527 :       }
; 1528 : 
; 1529 :       // colors
; 1530 :       ImU32 colors[7];
; 1531 :       ComputeColors(colors, type, TRANSLATE);

	xor	esi, esi

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+872

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm3, xmm8

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+888

; 1525 :       {
; 1526 :          return;
; 1527 :       }
; 1528 : 
; 1529 :       // colors
; 1530 :       ImU32 colors[7];
; 1531 :       ComputeColors(colors, type, TRANSLATE);

	xor	r14d, r14d

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+904

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm9, DWORD PTR __real@3f800000

; 1525 :       {
; 1526 :          return;
; 1527 :       }
; 1528 : 
; 1529 :       // colors
; 1530 :       ImU32 colors[7];
; 1531 :       ComputeColors(colors, type, TRANSLATE);

	movss	xmm7, DWORD PTR __real@3dcccccd

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm2, xmm6

; 1532 : 
; 1533 :       const ImVec2 origin = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);
; 1534 : 
; 1535 :       // draw
; 1536 :       bool belowAxisLimit = false;

	mov	BYTE PTR belowAxisLimit$[rsp], 0

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm0, xmm5

; 1537 :       bool belowPlaneLimit = false;

	mov	BYTE PTR belowPlaneLimit$[rsp], 0

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm1, xmm4

; 1525 :       {
; 1526 :          return;
; 1527 :       }
; 1528 : 
; 1529 :       // colors
; 1530 :       ImU32 colors[7];
; 1531 :       ComputeColors(colors, type, TRANSLATE);

	mov	QWORD PTR tv5906[rsp], rbx

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+876
	mulss	xmm0, xmm5
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+892
	mulss	xmm1, xmm4
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+920

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm2

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+860
	mulss	xmm2, xmm6

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm2, xmm0

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+880
	mulss	xmm0, xmm5
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+896
	mulss	xmm1, xmm4
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+908

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm3

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm2, xmm8

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 808  :       trans.y *= size.y;

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404
	movss	DWORD PTR tv5968[rsp], xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+864
	mulss	xmm2, xmm6

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm0

; 806  :       trans.y = 1.f - trans.y;

	movaps	xmm0, xmm9

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm1
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+912

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm3

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm2, xmm8

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm0, xmm2

; 807  :       trans.x *= size.x;

	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
	movss	DWORD PTR tv5962[rsp], xmm0
	npad	4
$LL4@DrawTransl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1541 :          ComputeTripodAxisAndVisibility(i, dirAxis, dirPlaneX, dirPlaneY, belowAxisLimit, belowPlaneLimit);

	lea	rax, QWORD PTR belowPlaneLimit$[rsp]
	mov	BYTE PTR [rsp+48], 0
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR dirPlaneY$12[rbp-256]
	lea	rax, QWORD PTR belowAxisLimit$[rsp]
	mov	ecx, esi
	lea	r8, QWORD PTR dirPlaneX$17[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR dirAxis$19[rbp-256]
	call	?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z ; ImGuizmo::ComputeTripodAxisAndVisibility

; 1542 : 
; 1543 :          if (!gContext.mbUsing || (gContext.mbUsing && type == MT_MOVE_X + i))

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	je	SHORT $LN474@DrawTransl
	lea	eax, DWORD PTR [rsi+1]
	cmp	r13d, eax
	jne	$LN484@DrawTransl
$LN474@DrawTransl:

; 1544 :          {
; 1545 :             // draw axis
; 1546 :             if (belowAxisLimit && Intersects(op, static_cast<OPERATION>(TRANSLATE_X << i)))

	cmp	BYTE PTR belowAxisLimit$[rsp], 0
	mov	edx, DWORD PTR op$1$[rsp]
	je	$LN486@DrawTransl

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	r15d, edx

; 1544 :          {
; 1545 :             // draw axis
; 1546 :             if (belowAxisLimit && Intersects(op, static_cast<OPERATION>(TRANSLATE_X << i)))

	je	$LN486@DrawTransl

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm15, DWORD PTR dirAxis$19[rbp-252]

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm4, xmm8

; 1547 :             {
; 1548 :                ImVec2 baseSSpace = worldToPos(dirAxis * 0.1f * gContext.mScreenFactor, gContext.mMVP);

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm5, DWORD PTR dirAxis$19[rbp-248]
	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+732
	movss	xmm6, DWORD PTR dirAxis$19[rbp-256]
	mulss	xmm15, xmm7
	mulss	xmm5, xmm7

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm15, xmm0
	mulss	xmm5, xmm0

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movaps	xmm2, xmm15

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm6, xmm7

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+760
	movaps	xmm3, xmm15
	mulss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+748
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+776
	mulss	xmm15, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+752
	movss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+736

; 1547 :             {
; 1548 :                ImVec2 baseSSpace = worldToPos(dirAxis * 0.1f * gContext.mScreenFactor, gContext.mMVP);

	mulss	xmm6, xmm0

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+744
	mulss	xmm0, xmm6

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm0

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movaps	xmm0, xmm12
	mulss	xmm0, xmm6

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm3, xmm0
	movaps	xmm0, xmm7

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm1
	mulss	xmm0, xmm6
	movaps	xmm1, xmm5
	mulss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+768
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+764
	addss	xmm15, xmm0
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+792

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm0, DWORD PTR __real@3f800000

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm3, xmm1

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm15, xmm5

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm4, xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+780

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm15, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+784

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm2, DWORD PTR dirAxis$19[rbp-256]
	mulss	xmm2, xmm1

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm3, xmm4

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	DWORD PTR dirAxis$3$[rbp-256], xmm2

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+744

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm3, xmm8

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm15, xmm4

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 808  :       trans.y *= size.y;

	addss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR baseSSpace$14[rbp-256], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	movss	xmm3, DWORD PTR __real@3f000000
	addss	xmm15, xmm3

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm0, xmm15

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm15, DWORD PTR dirAxis$19[rbp-248]
	mulss	xmm15, xmm1

; 807  :       trans.x *= size.x;

	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
	movss	DWORD PTR baseSSpace$14[rbp-252], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm0, DWORD PTR dirAxis$19[rbp-252]
	mulss	xmm0, xmm1

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movaps	xmm1, xmm15
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+776

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	DWORD PTR dirAxis$2$[rsp], xmm0

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+760
	addss	xmm2, xmm0

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm0, DWORD PTR dirAxis$3$[rbp-256]
	mulss	xmm0, xmm12

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm1

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	DWORD PTR tv6224[rsp], xmm0

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm12, DWORD PTR tv6224[rsp]
	movaps	xmm1, xmm15
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+764

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+792

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm2, DWORD PTR dirAxis$2$[rsp]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+748
	addss	xmm12, xmm0
	addss	xmm12, xmm1
	addss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+780
	movss	xmm0, DWORD PTR dirAxis$3$[rbp-256]

; 1551 :                drawList->AddLine(baseSSpace, worldDirSSpace, colors[i + 1], gContext.mStyle.TranslationLineThickness);

	lea	r8, QWORD PTR worldDirSSpace$13[rbp-256]

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+752

; 1551 :                drawList->AddLine(baseSSpace, worldDirSSpace, colors[i + 1], gContext.mStyle.TranslationLineThickness);

	lea	rdx, QWORD PTR baseSSpace$14[rbp-256]
	mov	rcx, rdi
	mov	r13d, DWORD PTR colors$[rbp+r14-252]

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm15, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+768

; 1551 :                drawList->AddLine(baseSSpace, worldDirSSpace, colors[i + 1], gContext.mStyle.TranslationLineThickness);

	mov	r9d, r13d

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm9, DWORD PTR __real@3f800000

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	mulss	xmm0, xmm7

; 806  :       trans.y = 1.f - trans.y;

	movaps	xmm8, xmm9

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm12, xmm3

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm0, xmm2

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm12, DWORD PTR __real@3f000000

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm0, xmm15

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+784

; 808  :       trans.y *= size.y;

	addss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR worldDirSSpace$13[rbp-256], xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm0, DWORD PTR __real@3f000000

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm8, xmm0

; 1551 :                drawList->AddLine(baseSSpace, worldDirSSpace, colors[i + 1], gContext.mStyle.TranslationLineThickness);

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+8
	movss	DWORD PTR [rsp+32], xmm0

; 807  :       trans.x *= size.x;

	mulss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
	movss	DWORD PTR worldDirSSpace$13[rbp-252], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1551 :                drawList->AddLine(baseSSpace, worldDirSSpace, colors[i + 1], gContext.mStyle.TranslationLineThickness);

	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm7, DWORD PTR tv5968[rsp]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm6, DWORD PTR tv5962[rsp]

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm7, xmm12

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm6, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	movaps	xmm0, xmm7
	mulss	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm1, xmm6
	mulss	xmm1, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1556 :                float d = sqrtf(ImLengthSqr(dir));

	ucomiss	xmm0, xmm1
	ja	SHORT $LN480@DrawTransl
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	jmp	SHORT $LN481@DrawTransl
$LN480@DrawTransl:
	movaps	xmm0, xmm1
	call	sqrtf
$LN481@DrawTransl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm2, xmm12
	movaps	xmm3, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1556 :                float d = sqrtf(ImLengthSqr(dir));

	divss	xmm7, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2544 : static inline ImVec2& operator/=(ImVec2& lhs, const float rhs)          { lhs.x /= rhs; lhs.y /= rhs; return lhs; }

	divss	xmm6, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1558 :                dir *= gContext.mStyle.TranslationLineArrowSize;

	mulss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2543 : static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)          { lhs.x *= rhs; lhs.y *= rhs; return lhs; }

	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+12

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm2, xmm7
	movaps	xmm4, xmm7
	xorps	xmm4, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm12, xmm7
	addss	xmm3, xmm6
	subss	xmm8, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1562 :                drawList->AddTriangleFilled(worldDirSSpace - dir, a + ortogonalDir, a - ortogonalDir, colors[i + 1]);

	movaps	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm2, xmm6
	movss	DWORD PTR $T15[rbp-256], xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1562 :                drawList->AddTriangleFilled(worldDirSSpace - dir, a + ortogonalDir, a - ortogonalDir, colors[i + 1]);

	subss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm1, xmm3
	addss	xmm3, xmm4
	movss	DWORD PTR $T15[rbp-252], xmm8
	subss	xmm1, xmm4
	movss	DWORD PTR $T16[rbp-256], xmm2
	movss	DWORD PTR $T9[rsp], xmm0
	movss	DWORD PTR $T16[rbp-252], xmm3
	movss	DWORD PTR $T9[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	test	r13d, -16777216				; ff000000H
	je	$LN475@DrawTransl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rdi+120]
	mov	ecx, DWORD PTR [rdi+124]
	cmp	r8d, ecx
	jne	SHORT $LN396@DrawTransl
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN400@DrawTransl
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN401@DrawTransl
$LN400@DrawTransl:
	mov	eax, r12d
$LN401@DrawTransl:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [rdi+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN396@DrawTransl:
	movsxd	rdx, DWORD PTR [rdi+120]
	mov	rcx, QWORD PTR [rdi+128]
	mov	rax, QWORD PTR $T15[rbp-256]
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rdi+120]
	inc	ecx
	mov	DWORD PTR [rdi+120], ecx
	mov	r8d, DWORD PTR [rdi+124]
	cmp	ecx, r8d
	jne	SHORT $LN405@DrawTransl
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN409@DrawTransl
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN410@DrawTransl
$LN409@DrawTransl:
	mov	eax, r12d
$LN410@DrawTransl:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rdi+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN405@DrawTransl:
	movsxd	rdx, DWORD PTR [rdi+120]
	mov	rcx, QWORD PTR [rdi+128]
	mov	rax, QWORD PTR $T16[rbp-256]
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	r8d, DWORD PTR [rdi+120]
	inc	r8d
	mov	DWORD PTR [rdi+120], r8d
	mov	ecx, DWORD PTR [rdi+124]
	cmp	r8d, ecx
	jne	SHORT $LN414@DrawTransl
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN418@DrawTransl
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN419@DrawTransl
$LN418@DrawTransl:
	mov	eax, r12d
$LN419@DrawTransl:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [rdi+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN414@DrawTransl:
	movsxd	rdx, DWORD PTR [rdi+120]

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r9d, r13d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, QWORD PTR [rdi+128]
	mov	rax, QWORD PTR $T9[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	rcx, rdi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	inc	DWORD PTR [rdi+120]

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rdi+120]
	mov	rdx, QWORD PTR [rdi+128]
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	rbx, QWORD PTR tv5906[rsp]
	mov	DWORD PTR [rdi+120], 0
$LN475@DrawTransl:
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1565 :                if (gContext.mAxisFactor[i] < 0.f)

	lea	r8, OFFSET FLAT:__ImageBase
	comiss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A[r14+r8+1236]
	jbe	$LN483@DrawTransl

; 1566 :                {
; 1567 :                   DrawHatchedAxis(dirAxis);

	lea	rcx, QWORD PTR dirAxis$19[rbp-256]
	call	?DrawHatchedAxis@ImGuizmo@@YAXAEBUvec_t@1@@Z ; ImGuizmo::DrawHatchedAxis
	movss	xmm8, DWORD PTR __real@3f000000
	mov	r13d, DWORD PTR type$GSCopy$1$[rbp-256]
$LN484@DrawTransl:

; 1568 :                }
; 1569 :             }
; 1570 :          }
; 1571 :          // draw plane
; 1572 :          if (!gContext.mbUsing || (gContext.mbUsing && type == MT_MOVE_YZ + i))

	mov	edx, DWORD PTR op$1$[rsp]
$LN486@DrawTransl:
	lea	r8, OFFSET FLAT:__ImageBase
$LN482@DrawTransl:
	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	je	SHORT $LN473@DrawTransl
	lea	eax, DWORD PTR [rsi+4]
	cmp	r13d, eax
	jne	$LN2@DrawTransl
$LN473@DrawTransl:

; 1573 :          {
; 1574 :             if (belowPlaneLimit && Contains(op, TRANSLATE_PLANS[i]))

	cmp	BYTE PTR belowPlaneLimit$[rsp], 0
	je	$LN2@DrawTransl
	mov	ecx, DWORD PTR ?TRANSLATE_PLANS@ImGuizmo@@3QBW4OPERATION@1@B[r14+r8]

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	mov	eax, ecx
	and	eax, edx

; 74   :      return (lhs & rhs) == rhs;

	cmp	eax, ecx

; 1573 :          {
; 1574 :             if (belowPlaneLimit && Contains(op, TRANSLATE_PLANS[i]))

	jne	$LN2@DrawTransl

; 1575 :             {
; 1576 :                ImVec2 screenQuadPts[4];
; 1577 :                for (int j = 0; j < 4; ++j)

	movss	xmm11, DWORD PTR dirPlaneY$12[rbp-248]
	xorps	xmm0, xmm0
	movss	xmm12, DWORD PTR dirPlaneY$12[rbp-252]
	xorps	xmm1, xmm1
	movss	xmm13, DWORD PTR dirPlaneY$12[rbp-256]
	xor	eax, eax
	movss	xmm14, DWORD PTR dirPlaneX$17[rbp-248]
	movss	xmm15, DWORD PTR dirPlaneX$17[rbp-252]
	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 269  :     constexpr ImVec2()                      : x(0.0f), y(0.0f) { }

	movups	XMMWORD PTR screenQuadPts$20[rbp-256], xmm0
	movups	XMMWORD PTR screenQuadPts$20[rbp-240], xmm1
	npad	12
$LL7@DrawTransl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1579 :                   vec_t cornerWorldPos = (dirPlaneX * quadUV[j * 2] + dirPlaneY * quadUV[j * 2 + 1]) * gContext.mScreenFactor;

	movss	xmm7, DWORD PTR ?quadUV@ImGuizmo@@3QBMB[rax+r8]

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm3, xmm8

; 1579 :                   vec_t cornerWorldPos = (dirPlaneX * quadUV[j * 2] + dirPlaneY * quadUV[j * 2 + 1]) * gContext.mScreenFactor;

	movss	xmm1, DWORD PTR ?quadUV@ImGuizmo@@3QBMB[rax+r8+4]

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movaps	xmm5, xmm7
	mulss	xmm5, DWORD PTR dirPlaneX$17[rbp-256]
	movaps	xmm6, xmm7
	mulss	xmm6, xmm15
	movaps	xmm0, xmm1
	mulss	xmm0, xmm13
	mulss	xmm7, xmm14
	addss	xmm5, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm12
	mulss	xmm1, xmm11

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	addss	xmm6, xmm0

; 1579 :                   vec_t cornerWorldPos = (dirPlaneX * quadUV[j * 2] + dirPlaneY * quadUV[j * 2 + 1]) * gContext.mScreenFactor;

	mulss	xmm5, xmm10

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	addss	xmm7, xmm1

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+744

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm6, xmm10
	mulss	xmm7, xmm10

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movaps	xmm2, xmm6
	movaps	xmm4, xmm6
	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+752
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+760
	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+776
	mulss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+748
	addss	xmm2, xmm0
	movaps	xmm0, xmm5
	mulss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+736
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+732
	addss	xmm2, xmm1
	movaps	xmm1, xmm7
	mulss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+768
	addss	xmm6, xmm5
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+764
	addss	xmm4, xmm0
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+792
	addss	xmm6, xmm7

; 806  :       trans.y = 1.f - trans.y;

	movaps	xmm0, xmm9

; 1579 :                   vec_t cornerWorldPos = (dirPlaneX * quadUV[j * 2] + dirPlaneY * quadUV[j * 2 + 1]) * gContext.mScreenFactor;

	movss	xmm7, DWORD PTR ?quadUV@ImGuizmo@@3QBMB[rax+r8+8]

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm4, xmm1

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movaps	xmm5, xmm7

; 1579 :                   vec_t cornerWorldPos = (dirPlaneX * quadUV[j * 2] + dirPlaneY * quadUV[j * 2 + 1]) * gContext.mScreenFactor;

	movss	xmm1, DWORD PTR ?quadUV@ImGuizmo@@3QBMB[rax+r8+12]

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm5, DWORD PTR dirPlaneX$17[rbp-256]

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+784
	addss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+780

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm2

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm6, xmm3
	mulss	xmm4, xmm3

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm6, xmm8

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm4, xmm8

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm0, xmm6

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movaps	xmm6, xmm7
	mulss	xmm6, xmm15

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 807  :       trans.x *= size.x;

	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416

; 808  :       trans.y *= size.y;

	addss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm7, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1580 :                   screenQuadPts[j] = worldToPos(cornerWorldPos, gContext.mMVP);

	movss	DWORD PTR screenQuadPts$20[rbp+rax-256], xmm4
	movss	DWORD PTR screenQuadPts$20[rbp+rax-252], xmm0

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movaps	xmm0, xmm1
	mulss	xmm0, xmm13
	addss	xmm5, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm12
	mulss	xmm1, xmm11

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	addss	xmm6, xmm0

; 1579 :                   vec_t cornerWorldPos = (dirPlaneX * quadUV[j * 2] + dirPlaneY * quadUV[j * 2 + 1]) * gContext.mScreenFactor;

	mulss	xmm5, xmm10

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	addss	xmm7, xmm1

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+744

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm6, xmm10
	mulss	xmm7, xmm10

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movaps	xmm2, xmm6
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+760
	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+776
	addss	xmm2, xmm0
	movaps	xmm4, xmm6
	addss	xmm2, xmm1
	mulss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+748
	movaps	xmm0, xmm5
	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+752
	movaps	xmm1, xmm7
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+732

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm3, xmm8

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+792
	mulss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+736
	mulss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+768
	addss	xmm4, xmm0
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+764
	addss	xmm6, xmm5

; 806  :       trans.y = 1.f - trans.y;

	movaps	xmm0, xmm9
	divss	xmm3, xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm4, xmm1

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm6, xmm7
	addss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+780
	addss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+784

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm4, xmm3
	mulss	xmm6, xmm3

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm4, xmm8

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm6, xmm8

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412
	subss	xmm0, xmm6

; 808  :       trans.y *= size.y;

	addss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416

; 1580 :                   screenQuadPts[j] = worldToPos(cornerWorldPos, gContext.mMVP);

	movss	DWORD PTR screenQuadPts$20[rbp+rax-248], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1580 :                   screenQuadPts[j] = worldToPos(cornerWorldPos, gContext.mMVP);

	movss	DWORD PTR screenQuadPts$20[rbp+rax-244], xmm0
	add	rax, 16
	cmp	rax, 32					; 00000020H
	jl	$LL7@DrawTransl

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	mov	rcx, rbx
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1581 :                }
; 1582 :                drawList->AddPolyline(screenQuadPts, 4, GetColorU32(DIRECTION_X + i), true, 1.0f);

	movss	DWORD PTR [rsp+40], xmm9
	lea	rdx, QWORD PTR screenQuadPts$20[rbp-256]

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	mov	r9d, eax

; 1581 :                }
; 1582 :                drawList->AddPolyline(screenQuadPts, 4, GetColorU32(DIRECTION_X + i), true, 1.0f);

	mov	DWORD PTR [rsp+32], 1
	mov	r8d, 4
	mov	rcx, rdi
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline

; 1583 :                drawList->AddConvexPolyFilled(screenQuadPts, 4, colors[i + 4]);

	mov	r9d, DWORD PTR colors$[rbp+r14-240]
	lea	rdx, QWORD PTR screenQuadPts$20[rbp-256]
	mov	r8d, 4
	mov	rcx, rdi
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
$LN2@DrawTransl:

; 1538 :       for (int i = 0; i < 3; ++i)

	movss	xmm7, DWORD PTR __real@3dcccccd
	add	rbx, 16
	inc	esi
	rol	r15d, 1
	add	r14, 4
	mov	QWORD PTR tv5906[rsp], rbx
	cmp	esi, 3
	jl	$LL4@DrawTransl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	mov	esi, DWORD PTR colors$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1538 :       for (int i = 0; i < 3; ++i)

	mov	r15, QWORD PTR [rsp+976]
	mov	r14, QWORD PTR [rsp+984]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	test	esi, -16777216				; ff000000H
	je	SHORT $LN22@DrawTransl
	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+36
	comiss	xmm8, xmm2
	ja	SHORT $LN22@DrawTransl

; 1186 :         _PathArcToN(center, radius, a_min, a_max, num_segments);

	movss	xmm0, DWORD PTR __real@40c2c75c
	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+1040
	mov	DWORD PTR [rsp+40], 31
	xorps	xmm3, xmm3
	mov	rcx, rdi
	movss	DWORD PTR [rsp+32], xmm0
	call	?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::_PathArcToN
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rdi+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1186 :         _PathArcToN(center, radius, a_min, a_max, num_segments);

	lea	rbx, QWORD PTR [rdi+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	rdx, QWORD PTR [rdi+128]
	mov	r9d, esi
	mov	rcx, rdi
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	DWORD PTR [rbx], 0
$LN22@DrawTransl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1590 :       if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID) && IsTranslateType(type))

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	mov	r12, QWORD PTR [rsp+1048]
	mov	rsi, QWORD PTR [rsp+1040]
	je	$LN532@DrawTransl
	mov	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	cmp	eax, -1
	je	SHORT $LN18@DrawTransl
	cmp	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440
	jne	$LN532@DrawTransl
$LN18@DrawTransl:

; 623  :      return type >= MT_MOVE_X && type <= MT_MOVE_SCREEN;

	lea	eax, DWORD PTR [r13-1]

; 1590 :       if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID) && IsTranslateType(type))

	cmp	eax, 6
	ja	$LN532@DrawTransl

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+168
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1128

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm4, xmm8

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1124

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	mov	ebx, eax

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1120

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm15, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+904
	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+872
	movaps	xmm1, xmm15
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+888
	movss	xmm14, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+876
	movss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+892
	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+880
	mulss	xmm2, xmm6
	mulss	xmm0, xmm5
	mulss	xmm1, xmm3
	addss	xmm2, xmm0

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+860
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A$27[rsp], xmm0
	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A$27[rsp]

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm1
	movaps	xmm1, xmm13
	mulss	xmm1, xmm3
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+920

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm4, xmm2

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movaps	xmm2, xmm0

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movaps	xmm0, xmm14

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	mulss	xmm2, xmm6

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	mulss	xmm0, xmm5
	addss	xmm2, xmm0

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movaps	xmm0, xmm10
	mulss	xmm0, xmm5
	addss	xmm2, xmm1
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+908

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm4

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm2, xmm8

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+896
	movaps	xmm1, xmm8
	mulss	xmm1, xmm3
	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	mulss	xmm12, xmm3

; 808  :       trans.y *= size.y;

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404
	movss	DWORD PTR tv5983[rsp], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR sourcePosOnScreen$6[rsp], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+864
	mulss	xmm2, xmm6

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm0

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm0, DWORD PTR __real@3f800000

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+872
	mulss	xmm1, xmm3
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+912

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm4

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm2, DWORD PTR __real@3f000000

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm0, xmm2

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464
	mulss	xmm14, xmm2

; 807  :       trans.x *= size.x;

	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm12, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
	movss	DWORD PTR tv6037[rsp], xmm0
	movss	DWORD PTR sourcePosOnScreen$6[rsp+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+888
	mulss	xmm0, xmm2
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468
	mulss	xmm15, xmm0
	mulss	xmm13, xmm0
	addss	xmm1, xmm15

; 804  :       trans *= 0.5f / trans.w;

	movss	xmm15, DWORD PTR __real@3f000000

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm12, xmm13

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+920
	addss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+908
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A$35[rsp], xmm1

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm1, xmm15
	divss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A$35[rsp]

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm12, xmm1

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm12, xmm15

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+864

; 808  :       trans.y *= size.y;

	addss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404
	movss	xmm11, DWORD PTR __real@3f800000

; 1596 :          vec_t dif = { destinationPosOnScreen.x - sourcePosOnScreen.x, destinationPosOnScreen.y - sourcePosOnScreen.y, 0.f, 0.f };

	movss	xmm13, DWORD PTR tv6037[rsp]

; 806  :       trans.y = 1.f - trans.y;

	movaps	xmm9, xmm11

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	mulss	xmm7, xmm3

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm8, xmm0

; 1596 :          vec_t dif = { destinationPosOnScreen.x - sourcePosOnScreen.x, destinationPosOnScreen.y - sourcePosOnScreen.y, 0.f, 0.f };

	movaps	xmm6, xmm12

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm10, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR destinationPosOnScreen$8[rsp], xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm7, xmm10

; 1596 :          vec_t dif = { destinationPosOnScreen.x - sourcePosOnScreen.x, destinationPosOnScreen.y - sourcePosOnScreen.y, 0.f, 0.f };

	movss	xmm10, DWORD PTR tv5983[rsp]
	subss	xmm6, xmm10

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm7, xmm8

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm6
	mulss	xmm0, xmm6

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+912

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm1

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm7, xmm15
	xorps	xmm15, xmm15

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm9, xmm7

; 807  :       trans.x *= size.x;

	mulss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1596 :          vec_t dif = { destinationPosOnScreen.x - sourcePosOnScreen.x, destinationPosOnScreen.y - sourcePosOnScreen.y, 0.f, 0.f };

	movaps	xmm14, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR destinationPosOnScreen$8[rsp+4], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1596 :          vec_t dif = { destinationPosOnScreen.x - sourcePosOnScreen.x, destinationPosOnScreen.y - sourcePosOnScreen.y, 0.f, 0.f };

	subss	xmm14, xmm13
	movaps	xmm1, xmm14
	mulss	xmm1, xmm14

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	addss	xmm1, xmm15
	ucomiss	xmm0, xmm1
	ja	SHORT $LN478@DrawTransl
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	jmp	SHORT $LN479@DrawTransl
$LN483@DrawTransl:

; 1565 :                if (gContext.mAxisFactor[i] < 0.f)

	movss	xmm8, DWORD PTR __real@3f000000
	mov	r13d, DWORD PTR type$GSCopy$1$[rbp-256]
	mov	edx, DWORD PTR op$1$[rsp]
	jmp	$LN482@DrawTransl
$LN478@DrawTransl:

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm1
	call	sqrtf
$LN479@DrawTransl:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movaps	xmm7, xmm11
	maxss	xmm0, DWORD PTR __real@34000000
	divss	xmm7, xmm0
	movaps	xmm8, xmm7

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm14

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mulss	xmm8, xmm6

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, DWORD PTR __real@40a00000
	mulss	xmm8, DWORD PTR __real@40a00000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1484 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	test	ebx, -16777216				; ff000000H
	je	$LN174@DrawTransl

; 1490 :         _PathArcToFastEx(center, radius - 0.5f, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	movss	xmm6, DWORD PTR __real@40b00000
	lea	rdx, QWORD PTR sourcePosOnScreen$6[rsp]
	movaps	xmm2, xmm6
	mov	DWORD PTR [rsp+32], 48			; 00000030H
	xor	r9d, r9d
	mov	rcx, rdi
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx

; 1491 :         _Path.Size--;

	mov	r8d, DWORD PTR [rdi+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	r9d, ebx
	mov	rdx, QWORD PTR [rdi+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1491 :         _Path.Size--;

	dec	r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	movss	DWORD PTR [rsp+40], xmm11
	mov	rcx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1491 :         _Path.Size--;

	mov	DWORD PTR [rdi+120], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	DWORD PTR [rsp+32], 1
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1490 :         _PathArcToFastEx(center, radius - 0.5f, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	xor	r9d, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	DWORD PTR [rdi+120], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1490 :         _PathArcToFastEx(center, radius - 0.5f, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	movaps	xmm2, xmm6
	mov	DWORD PTR [rsp+32], 48			; 00000030H
	lea	rdx, QWORD PTR destinationPosOnScreen$8[rsp]
	mov	rcx, rdi
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx

; 1491 :         _Path.Size--;

	dec	DWORD PTR [rdi+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	r9d, ebx
	mov	r8d, DWORD PTR [rdi+120]
	mov	rcx, rdi
	mov	rdx, QWORD PTR [rdi+128]
	movss	DWORD PTR [rsp+40], xmm11
	mov	DWORD PTR [rsp+32], 1
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
	mov	DWORD PTR [rdi+120], 0
$LN174@DrawTransl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1601 :          drawList->AddLine(ImVec2(sourcePosOnScreen.x + dif.x, sourcePosOnScreen.y + dif.y), ImVec2(destinationPosOnScreen.x - dif.x, destinationPosOnScreen.y - dif.y), translationLineColor, 2.f);

	movaps	xmm0, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm13, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1601 :          drawList->AddLine(ImVec2(sourcePosOnScreen.x + dif.x, sourcePosOnScreen.y + dif.y), ImVec2(destinationPosOnScreen.x - dif.x, destinationPosOnScreen.y - dif.y), translationLineColor, 2.f);

	subss	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm1, xmm9
	subss	xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1601 :          drawList->AddLine(ImVec2(sourcePosOnScreen.x + dif.x, sourcePosOnScreen.y + dif.y), ImVec2(destinationPosOnScreen.x - dif.x, destinationPosOnScreen.y - dif.y), translationLineColor, 2.f);

	mov	r9d, ebx
	addss	xmm8, xmm10
	mov	rcx, rdi
	lea	r8, QWORD PTR $T5[rsp]
	lea	rdx, QWORD PTR $T7[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T7[rsp+4], xmm13
	movss	DWORD PTR $T5[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1601 :          drawList->AddLine(ImVec2(sourcePosOnScreen.x + dif.x, sourcePosOnScreen.y + dif.y), ImVec2(destinationPosOnScreen.x - dif.x, destinationPosOnScreen.y - dif.y), translationLineColor, 2.f);

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [rsp+32], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp+4], xmm1
	movss	DWORD PTR $T7[rsp], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1601 :          drawList->AddLine(ImVec2(sourcePosOnScreen.x + dif.x, sourcePosOnScreen.y + dif.y), ImVec2(destinationPosOnScreen.x - dif.x, destinationPosOnScreen.y - dif.y), translationLineColor, 2.f);

	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460

; 1606 :          ImFormatString(tmps, sizeof(tmps), translationInfoMask[type - MT_MOVE_X], deltaInfo[translationInfoIndex[componentInfoIndex]], deltaInfo[translationInfoIndex[componentInfoIndex + 1]], deltaInfo[translationInfoIndex[componentInfoIndex + 2]]);

	lea	r10, OFFSET FLAT:__ImageBase
	movsxd	r8, r13d
	lea	edx, DWORD PTR [r13*2]

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subps	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1120

; 1602 : 
; 1603 :          char tmps[512];
; 1604 :          vec_t deltaInfo = gContext.mModel.v.position - gContext.mMatrixOrigin;
; 1605 :          int componentInfoIndex = (type - MT_MOVE_X) * 3;

	add	edx, r13d

; 1606 :          ImFormatString(tmps, sizeof(tmps), translationInfoMask[type - MT_MOVE_X], deltaInfo[translationInfoIndex[componentInfoIndex]], deltaInfo[translationInfoIndex[componentInfoIndex + 1]], deltaInfo[translationInfoIndex[componentInfoIndex + 2]]);

	mov	r8, QWORD PTR ?translationInfoMask@ImGuizmo@@3PAPEBDA[r10+r8*8-8]

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movups	XMMWORD PTR deltaInfo$18[rbp-256], xmm0

; 1606 :          ImFormatString(tmps, sizeof(tmps), translationInfoMask[type - MT_MOVE_X], deltaInfo[translationInfoIndex[componentInfoIndex]], deltaInfo[translationInfoIndex[componentInfoIndex + 1]], deltaInfo[translationInfoIndex[componentInfoIndex + 2]]);

	lea	eax, DWORD PTR [rdx-1]
	movsxd	rcx, eax
	movsxd	rax, DWORD PTR ?translationInfoIndex@ImGuizmo@@3QBHB[r10+rcx*4]
	movss	xmm1, DWORD PTR deltaInfo$18[rbp+rax*4-256]
	lea	eax, DWORD PTR [rdx-2]
	movsxd	rcx, eax
	cvtps2pd xmm1, xmm1
	movsxd	rax, DWORD PTR ?translationInfoIndex@ImGuizmo@@3QBHB[r10+rcx*4]
	lea	rcx, QWORD PTR tmps$21[rbp-256]
	movss	xmm0, DWORD PTR deltaInfo$18[rbp+rax*4-256]
	movsxd	rax, edx
	mov	edx, 512				; 00000200H
	cvtps2pd xmm0, xmm0
	movsxd	rax, DWORD PTR ?translationInfoIndex@ImGuizmo@@3QBHB[r10+rax*4-12]
	movsd	QWORD PTR [rsp+40], xmm1
	movss	xmm3, DWORD PTR deltaInfo$18[rbp+rax*4-256]
	cvtps2pd xmm3, xmm3
	movsd	QWORD PTR [rsp+32], xmm0
	movq	r9, xmm3
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+264
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1607 :          drawList->AddText(ImVec2(destinationPosOnScreen.x + 15, destinationPosOnScreen.y + 15), GetColorU32(TEXT_SHADOW), tmps);

	movaps	xmm0, xmm12

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	mov	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	rbx, -1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1607 :          drawList->AddText(ImVec2(destinationPosOnScreen.x + 15, destinationPosOnScreen.y + 15), GetColorU32(TEXT_SHADOW), tmps);

	addss	xmm0, DWORD PTR __real@41700000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T4[rsp], xmm0
	movaps	xmm0, xmm9
	addss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR $T4[rsp+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	test	eax, -16777216				; ff000000H
	je	SHORT $LN202@DrawTransl

; 1579 :         return;
; 1580 : 
; 1581 :     if (text_end == NULL)
; 1582 :         text_end = text_begin + strlen(text_begin);

	lea	rcx, QWORD PTR tmps$21[rbp-256]
	mov	rax, rbx
	npad	5
$LL477@DrawTransl:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL477@DrawTransl
	lea	rcx, QWORD PTR tmps$21[rbp-256]
	add	rcx, rax

; 1583 :     if (text_begin == text_end)

	lea	rax, QWORD PTR tmps$21[rbp-256]
	cmp	rax, rcx
	je	SHORT $LN202@DrawTransl

; 1584 :         return;
; 1585 : 
; 1586 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1587 :     if (font == NULL)
; 1588 :         font = _Data->Font;

	mov	rax, QWORD PTR [rdi+56]

; 1589 :     if (font_size == 0.0f)
; 1590 :         font_size = _Data->FontSize;
; 1591 : 
; 1592 :     IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
; 1593 : 
; 1594 :     ImVec4 clip_rect = _CmdHeader.ClipRect;
; 1595 :     if (cpu_fine_clip_rect)
; 1596 :     {
; 1597 :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
; 1598 :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
; 1599 :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
; 1600 :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
; 1601 :     }
; 1602 :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

	lea	r9, QWORD PTR $T4[rsp]
	movups	xmm0, XMMWORD PTR [rdi+136]
	mov	BYTE PTR [rsp+72], 0
	mov	rdx, rdi
	movss	DWORD PTR [rsp+64], xmm15
	movss	xmm2, DWORD PTR [rax+16]
	mov	QWORD PTR [rsp+56], rcx
	lea	rcx, QWORD PTR tmps$21[rbp-256]
	mov	QWORD PTR [rsp+48], rcx
	lea	rcx, QWORD PTR clip_rect$11[rbp-256]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR clip_rect$11[rbp-256], xmm0
	mov	DWORD PTR [rsp+32], r8d
	call	?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
$LN202@DrawTransl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+248
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r8d, eax

; 1608 :          drawList->AddText(ImVec2(destinationPosOnScreen.x + 14, destinationPosOnScreen.y + 14), GetColorU32(TEXT), tmps);

	addss	xmm12, DWORD PTR __real@41600000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm9, DWORD PTR __real@41600000
	movss	DWORD PTR $T3[rsp], xmm12
	movss	DWORD PTR $T3[rsp+4], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	test	eax, -16777216				; ff000000H
	je	SHORT $LN532@DrawTransl

; 1579 :         return;
; 1580 : 
; 1581 :     if (text_end == NULL)
; 1582 :         text_end = text_begin + strlen(text_begin);

	lea	rax, QWORD PTR tmps$21[rbp-256]
$LL476@DrawTransl:
	inc	rbx
	cmp	BYTE PTR [rax+rbx], 0
	jne	SHORT $LL476@DrawTransl
	lea	rcx, QWORD PTR tmps$21[rbp-256]
	add	rcx, rbx

; 1583 :     if (text_begin == text_end)

	lea	rax, QWORD PTR tmps$21[rbp-256]
	cmp	rax, rcx
	je	SHORT $LN532@DrawTransl

; 1584 :         return;
; 1585 : 
; 1586 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1587 :     if (font == NULL)
; 1588 :         font = _Data->Font;

	mov	rax, QWORD PTR [rdi+56]

; 1589 :     if (font_size == 0.0f)
; 1590 :         font_size = _Data->FontSize;
; 1591 : 
; 1592 :     IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
; 1593 : 
; 1594 :     ImVec4 clip_rect = _CmdHeader.ClipRect;
; 1595 :     if (cpu_fine_clip_rect)
; 1596 :     {
; 1597 :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
; 1598 :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
; 1599 :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
; 1600 :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
; 1601 :     }
; 1602 :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

	lea	r9, QWORD PTR $T3[rsp]
	movups	xmm0, XMMWORD PTR [rdi+136]
	mov	BYTE PTR [rsp+72], 0
	mov	rdx, rdi
	movss	DWORD PTR [rsp+64], xmm15
	movss	xmm2, DWORD PTR [rax+16]
	mov	QWORD PTR [rsp+56], rcx
	lea	rcx, QWORD PTR tmps$21[rbp-256]
	mov	QWORD PTR [rsp+48], rcx
	lea	rcx, QWORD PTR clip_rect$10[rbp-256]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR clip_rect$10[rbp-256], xmm0
	mov	DWORD PTR [rsp+32], r8d
	call	?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
$LN532@DrawTransl:
	movaps	xmm14, XMMWORD PTR [rsp+832]
	movaps	xmm13, XMMWORD PTR [rsp+848]
	movaps	xmm12, XMMWORD PTR [rsp+864]
	movaps	xmm11, XMMWORD PTR [rsp+880]
	movaps	xmm10, XMMWORD PTR [rsp+896]
	movaps	xmm9, XMMWORD PTR [rsp+912]
	movaps	xmm8, XMMWORD PTR [rsp+928]
	movaps	xmm7, XMMWORD PTR [rsp+944]
	movaps	xmm6, XMMWORD PTR [rsp+960]
	mov	rbx, QWORD PTR [rsp+1024]
	movaps	xmm15, XMMWORD PTR [rsp+816]
$LN232@DrawTransl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1610 :    }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 992				; 000003e0H
	pop	r13
	pop	rdi
	pop	rbp
	ret	0
?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z ENDP ; ImGuizmo::DrawTranslationGizmo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?CanActivate@ImGuizmo@@YA_NXZ
_TEXT	SEGMENT
?CanActivate@ImGuizmo@@YA_NXZ PROC			; ImGuizmo::CanActivate, COMDAT

; 1613 :    {

	sub	rsp, 40					; 00000028H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8912 :     return IsMouseClicked(button, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	?IsMouseClicked@ImGui@@YA_NHIH@Z	; ImGui::IsMouseClicked
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1614 :       if (ImGui::IsMouseClicked(0) && !ImGui::IsAnyItemHovered() && !ImGui::IsAnyItemActive())

	test	al, al
	je	SHORT $LN2@CanActivat
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5567 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5568 :     return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;

	cmp	DWORD PTR [rax+16484], 0
	jne	SHORT $LN2@CanActivat
	cmp	DWORD PTR [rax+16488], 0
	jne	SHORT $LN2@CanActivat

; 5574 :     return g.ActiveId != 0;

	cmp	DWORD PTR [rax+16504], 0
	sete	al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1619 :    }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@CanActivat:

; 1615 :       {
; 1616 :          return true;
; 1617 :       }
; 1618 :       return false;

	xor	al, al

; 1619 :    }

	add	rsp, 40					; 00000028H
	ret	0
?CanActivate@ImGuizmo@@YA_NXZ ENDP			; ImGuizmo::CanActivate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?HandleAndDrawLocalBounds@ImGuizmo@@YAXPEBMPEAUmatrix_t@1@0W4OPERATION@1@@Z
_TEXT	SEGMENT
anchorAlpha$1$ = 80
tv13204 = 80
operation$1$ = 84
vtx_count$1$ = 88
bigAnchorColor$1$ = 88
tv13205 = 88
vtx_outer_idx$1$ = 92
col_trans$1$ = 92
vtx_outer_idx$1$ = 92
tv13291 = 92
numAxes$1$ = 96
vtx_outer_idx$1$ = 100
vtx_count$1$ = 100
tv13210 = 100
tv14278 = 104
tv13206 = 104
smallAnchorColor$1$ = 108
tv13248 = 108
secondAxis$1$ = 112
tv13177 = 112
axisIndex$1$ = 116
tv13208 = 116
i$1$ = 120
tv13209 = 120
thirdAxis$1$ = 124
tv13207 = 124
bestAxis$2$ = 128
tv13176 = 128
vtx_count$1$ = 132
tv13292 = 132
axes$ = 136
tv14274 = 152
midPoint$2$sroa$7130$1$ = 156
midPoint$2$sroa$7131$1$ = 160
midPoint$2$sroa$7132$1$ = 164
tv13240 = 168
worldBound1$14 = 176
midBound$15 = 184
worldBoundSS1$16 = 192
indices$17 = 200
$T18 = 208
$T19 = 216
$T20 = 224
tv13333 = 232
worldBoundSS2$21 = 240
axesWorldDirections$ = 248
$T22 = 296
tv13519 = 304
tv13201 = 312
$T23 = 320
res$24 = 336
gizmoHitProportion$25 = 400
$T26 = 416
$T27 = 480
clip_rect$28 = 544
clip_rect$29 = 544
bestAxisWorldDirection$ = 544
scale$30 = 560
boundsMVP$31 = 560
preScale$32 = 624
aabb$33 = 624
postScale$34 = 688
tmps$35 = 752
__$ArrayPad$ = 1264
bounds$dead$ = 1488
matrix$dead$ = 1496
snapValues$dead$ = 1504
operation$ = 1512
?HandleAndDrawLocalBounds@ImGuizmo@@YAXPEBMPEAUmatrix_t@1@0W4OPERATION@1@@Z PROC ; ImGuizmo::HandleAndDrawLocalBounds, COMDAT

; 1622 :    {

	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-1224]
	sub	rsp, 1440				; 000005a0H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-104], xmm9
	movaps	XMMWORD PTR [rax-120], xmm10
	movaps	XMMWORD PTR [rax-136], xmm11
	movaps	XMMWORD PTR [rax-152], xmm12
	movaps	XMMWORD PTR [rax-168], xmm13
	movaps	XMMWORD PTR [rax-184], xmm14
	movaps	XMMWORD PTR [rax-200], xmm15
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 1623 :       ImGuiIO& io = ImGui::GetIO();
; 1624 :       ImDrawList* drawList = gContext.mDrawList;
; 1625 : 
; 1626 :       // compute best projection axis
; 1627 :       vec_t axesWorldDirections[3];
; 1628 :       vec_t bestAxisWorldDirection = { 0.0f, 0.0f, 0.0f, 0.0f };
; 1629 :       int axes[3];
; 1630 :       unsigned int numAxes = 1;
; 1631 :       axes[0] = gContext.mBoundsBestAxis;

	mov	r14d, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1320
	xor	r12d, r12d

; 1632 :       int bestAxis = axes[0];
; 1633 :       if (!gContext.mbUsingBounds)

	movzx	esi, BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1332
	xorps	xmm0, xmm0
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r15d, 1
	mov	rbx, QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A
	mov	r13d, r9d
	movss	xmm12, DWORD PTR __real@3f800000
	mov	edi, r14d
	mov	DWORD PTR operation$1$[rsp], r9d
	xorps	xmm13, xmm13
	mov	QWORD PTR tv13333[rbp-256], rax
	mov	DWORD PTR numAxes$1$[rsp], r15d
	mov	DWORD PTR axes$[rbp-256], r14d
	movups	XMMWORD PTR bestAxisWorldDirection$[rbp-256], xmm0
	test	sil, sil
	jne	$LN28@HandleAndD

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	movss	xmm10, DWORD PTR ?directionUnary@ImGuizmo@@3QBUvec_t@1@B+4

; 1634 :       {
; 1635 :          numAxes = 0;

	mov	r15d, r12d

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm7, DWORD PTR ?directionUnary@ImGuizmo@@3QBUvec_t@1@B

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	movaps	xmm6, xmm10
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+604
	movaps	xmm8, xmm7
	movss	xmm11, DWORD PTR ?directionUnary@ImGuizmo@@3QBUvec_t@1@B+8
	xorps	xmm15, xmm15

; 438  : 
; 439  :       x = out.x;
; 440  :       y = out.y;
; 441  :       z = out.z;
; 442  :       w = out.w;
; 443  :    }
; 444  : 
; 445  :    void vec_t::TransformVector(const matrix_t& matrix)
; 446  :    {
; 447  :       vec_t out;
; 448  : 
; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+636

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+628

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+648
	movss	xmm14, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+620
	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+624
	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+608
	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+640
	movss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+612
	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+644
	movss	DWORD PTR tv13248[rsp], xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+632
	movss	DWORD PTR tv13206[rsp], xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+616
	movss	DWORD PTR tv13204[rsp], xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, xmm1

; 1634 :       {
; 1635 :          numAxes = 0;

	mov	DWORD PTR numAxes$1$[rsp], r12d

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	DWORD PTR tv13292[rbp-256], xmm1
	movaps	xmm1, xmm11
	mulss	xmm1, xmm2
	movss	DWORD PTR tv13210[rsp], xmm2

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	mulss	xmm6, xmm14
	mulss	xmm8, xmm5
	addss	xmm6, xmm0
	movss	DWORD PTR tv13176[rbp-256], xmm9
	mulss	xmm9, xmm10
	movaps	xmm0, xmm10
	mulss	xmm0, xmm4
	addss	xmm6, xmm1
	movss	DWORD PTR tv13291[rsp], xmm14
	movaps	xmm1, xmm11
	movss	DWORD PTR tv13207[rsp], xmm3
	addss	xmm8, xmm0
	mulss	xmm1, xmm3
	movaps	xmm0, xmm13
	movss	DWORD PTR tv13209[rsp], xmm4
	mulss	xmm0, xmm7

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm2, xmm6

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	addss	xmm8, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm2, xmm6

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movaps	xmm1, xmm11
	movss	DWORD PTR tv13208[rsp], xmm5
	addss	xmm9, xmm0
	mulss	xmm1, xmm12

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm8

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movss	DWORD PTR tv13205[rsp], xmm12

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm0, xmm8

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	addss	xmm9, xmm1
	movss	DWORD PTR tv13177[rsp], xmm13

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	movaps	xmm1, xmm9
	mulss	xmm1, xmm9
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN1022@HandleAndD
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN1023@HandleAndD
$LN1022@HandleAndD:
	movaps	xmm0, xmm2
	call	sqrtf
$LN1023@HandleAndD:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000
	movss	xmm1, DWORD PTR __real@3f800000

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	mulss	xmm7, DWORD PTR tv13204[rsp]
	mulss	xmm10, DWORD PTR tv13206[rsp]
	mulss	xmm11, DWORD PTR tv13248[rsp]

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+948

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	addss	xmm7, xmm10

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+940
	subss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+652
	subss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+660

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm1, xmm0

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	addss	xmm7, xmm11

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+944

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm6, xmm1

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movaps	xmm2, xmm10
	subss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+656

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm13, xmm1

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	mulss	xmm2, xmm10

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm13, xmm8
	movaps	xmm8, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm11

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm0, xmm11
	movaps	xmm1, xmm12
	mulss	xmm1, xmm12
	addss	xmm2, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm8, xmm9
	xorps	xmm0, xmm0

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN1020@HandleAndD
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN1021@HandleAndD
$LN1020@HandleAndD:
	movaps	xmm0, xmm2
	call	sqrtf
$LN1021@HandleAndD:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000
	movss	xmm2, DWORD PTR __real@3f800000
	movaps	xmm3, xmm10

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm1, xmm12

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm2, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm0, xmm11

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mulss	xmm3, xmm2

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm0, xmm2

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	mulss	xmm3, xmm6

; 1636 :          float bestDot = 0.f;
; 1637 :          for (int i = 0; i < 3; i++)
; 1638 :          {
; 1639 :             vec_t dirPlaneNormalWorld;
; 1640 :             dirPlaneNormalWorld.TransformVector(directionUnary[i], gContext.mModelSource);
; 1641 :             dirPlaneNormalWorld.Normalize();
; 1642 : 
; 1643 :             float dt = fabsf(Dot(Normalized(gContext.mCameraEye - gContext.mModelSource.v.position), dirPlaneNormalWorld));

	mulss	xmm0, xmm13

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm1, xmm2

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	addss	xmm3, xmm0
	mulss	xmm1, xmm8
	addss	xmm3, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm3, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1644 :             if (dt >= bestDot)

	comiss	xmm3, DWORD PTR __real@00000000
	jb	SHORT $LN24@HandleAndD

; 1645 :             {
; 1646 :                bestDot = dt;
; 1647 :                bestAxis = i;
; 1648 :                bestAxisWorldDirection = dirPlaneNormalWorld;

	movss	DWORD PTR bestAxisWorldDirection$[rbp-256], xmm6
	movaps	xmm15, xmm3
	movss	DWORD PTR bestAxisWorldDirection$[rbp-252], xmm13
	mov	edi, r12d
	movss	DWORD PTR bestAxisWorldDirection$[rbp-248], xmm8
	movss	DWORD PTR bestAxisWorldDirection$[rbp-244], xmm7
$LN24@HandleAndD:

; 1649 :             }
; 1650 : 
; 1651 :             if (dt >= 0.1f)

	comiss	xmm3, DWORD PTR __real@3dcccccd
	jb	SHORT $LN2@HandleAndD

; 1655 :                ++numAxes;

	mov	r15d, 1
	movss	DWORD PTR axesWorldDirections$[rbp-256], xmm6
	mov	DWORD PTR numAxes$1$[rsp], r15d
	mov	r14d, r12d
	movss	DWORD PTR axesWorldDirections$[rbp-252], xmm13
	movss	DWORD PTR axesWorldDirections$[rbp-248], xmm8
	movss	DWORD PTR axesWorldDirections$[rbp-244], xmm7
	mov	DWORD PTR axes$[rbp-256], r12d
$LN2@HandleAndD:

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm13, DWORD PTR ?directionUnary@ImGuizmo@@3QBUvec_t@1@B+20
	movss	xmm9, DWORD PTR ?directionUnary@ImGuizmo@@3QBUvec_t@1@B+16
	movaps	xmm6, xmm13

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	movss	xmm8, DWORD PTR tv13176[rbp-256]
	movaps	xmm0, xmm9
	mulss	xmm0, DWORD PTR tv13292[rbp-256]
	movaps	xmm7, xmm9
	mulss	xmm7, DWORD PTR tv13208[rsp]
	mulss	xmm6, xmm14
	movss	xmm14, DWORD PTR ?directionUnary@ImGuizmo@@3QBUvec_t@1@B+24
	mulss	xmm8, xmm13
	movaps	xmm1, xmm14
	mulss	xmm1, DWORD PTR tv13210[rsp]
	addss	xmm6, xmm0
	movaps	xmm0, xmm13
	mulss	xmm0, DWORD PTR tv13209[rsp]
	addss	xmm6, xmm1
	movaps	xmm1, xmm14
	mulss	xmm1, DWORD PTR tv13207[rsp]
	addss	xmm7, xmm0

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movss	xmm0, DWORD PTR tv13177[rsp]
	mulss	xmm0, xmm9
	addss	xmm7, xmm1
	movaps	xmm1, xmm14
	mulss	xmm1, DWORD PTR tv13205[rsp]
	addss	xmm8, xmm0

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm6
	mulss	xmm0, xmm6

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	addss	xmm8, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm2, xmm7
	mulss	xmm2, xmm7
	addss	xmm2, xmm0
	movaps	xmm1, xmm8
	mulss	xmm1, xmm8
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN1018@HandleAndD
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN1019@HandleAndD
$LN1018@HandleAndD:
	movaps	xmm0, xmm2
	call	sqrtf
$LN1019@HandleAndD:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	mulss	xmm9, DWORD PTR tv13204[rsp]

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movaps	xmm2, xmm10

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movss	xmm1, DWORD PTR __real@3f800000

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	mulss	xmm13, DWORD PTR tv13206[rsp]

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	mulss	xmm14, DWORD PTR tv13248[rsp]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm1, xmm0

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	addss	xmm9, xmm13

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	mulss	xmm2, xmm10

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm11

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm6, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm0, xmm11

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm1

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	addss	xmm9, xmm14

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm8, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm2, xmm0
	xorps	xmm0, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm9, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm12
	mulss	xmm1, xmm12
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN1016@HandleAndD
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN1017@HandleAndD
$LN1016@HandleAndD:
	movaps	xmm0, xmm2
	call	sqrtf
$LN1017@HandleAndD:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movaps	xmm2, xmm1

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm0, xmm1

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mulss	xmm2, xmm10

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm0, xmm11

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	mulss	xmm2, xmm6

; 1636 :          float bestDot = 0.f;
; 1637 :          for (int i = 0; i < 3; i++)
; 1638 :          {
; 1639 :             vec_t dirPlaneNormalWorld;
; 1640 :             dirPlaneNormalWorld.TransformVector(directionUnary[i], gContext.mModelSource);
; 1641 :             dirPlaneNormalWorld.Normalize();
; 1642 : 
; 1643 :             float dt = fabsf(Dot(Normalized(gContext.mCameraEye - gContext.mModelSource.v.position), dirPlaneNormalWorld));

	mulss	xmm0, xmm7

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm1, xmm12

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	addss	xmm2, xmm0
	mulss	xmm1, xmm8
	addss	xmm2, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1644 :             if (dt >= bestDot)

	comiss	xmm2, xmm15
	jb	SHORT $LN820@HandleAndD

; 1645 :             {
; 1646 :                bestDot = dt;
; 1647 :                bestAxis = i;
; 1648 :                bestAxisWorldDirection = dirPlaneNormalWorld;

	movss	DWORD PTR bestAxisWorldDirection$[rbp-256], xmm6
	movaps	xmm15, xmm2
	movss	DWORD PTR bestAxisWorldDirection$[rbp-252], xmm7
	mov	edi, 1
	movss	DWORD PTR bestAxisWorldDirection$[rbp-248], xmm8
	movss	DWORD PTR bestAxisWorldDirection$[rbp-244], xmm9
$LN820@HandleAndD:

; 1649 :             }
; 1650 : 
; 1651 :             if (dt >= 0.1f)

	comiss	xmm2, DWORD PTR __real@3dcccccd
	jb	SHORT $LN821@HandleAndD

; 1652 :             {
; 1653 :                axes[numAxes] = i;

	mov	eax, r15d
	mov	DWORD PTR axes$[rbp+rax*4-256], 1

; 1654 :                axesWorldDirections[numAxes] = dirPlaneNormalWorld;

	add	rax, rax

; 1655 :                ++numAxes;

	inc	r15d
	mov	DWORD PTR numAxes$1$[rsp], r15d
	movss	DWORD PTR axesWorldDirections$[rbp+rax*8-256], xmm6
	movss	DWORD PTR axesWorldDirections$[rbp+rax*8-252], xmm7
	movss	DWORD PTR axesWorldDirections$[rbp+rax*8-248], xmm8
	movss	DWORD PTR axesWorldDirections$[rbp+rax*8-244], xmm9
	mov	r14d, DWORD PTR axes$[rbp-256]
$LN821@HandleAndD:

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm9, DWORD PTR ?directionUnary@ImGuizmo@@3QBUvec_t@1@B+32
	movss	xmm13, DWORD PTR ?directionUnary@ImGuizmo@@3QBUvec_t@1@B+36
	movaps	xmm6, xmm9
	mulss	xmm6, DWORD PTR tv13292[rbp-256]
	movaps	xmm0, xmm13
	mulss	xmm0, DWORD PTR tv13291[rsp]

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	movaps	xmm7, xmm9
	movss	xmm14, DWORD PTR ?directionUnary@ImGuizmo@@3QBUvec_t@1@B+40

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movaps	xmm8, xmm9
	mulss	xmm7, DWORD PTR tv13208[rsp]
	movaps	xmm1, xmm14
	mulss	xmm1, DWORD PTR tv13210[rsp]
	addss	xmm6, xmm0
	mulss	xmm8, DWORD PTR tv13177[rsp]
	movaps	xmm0, xmm13
	mulss	xmm0, DWORD PTR tv13209[rsp]
	addss	xmm6, xmm1
	movaps	xmm1, xmm14
	mulss	xmm1, DWORD PTR tv13207[rsp]
	addss	xmm7, xmm0
	movaps	xmm0, xmm13
	mulss	xmm0, DWORD PTR tv13176[rbp-256]
	addss	xmm7, xmm1
	movaps	xmm1, xmm14
	mulss	xmm1, DWORD PTR tv13205[rsp]
	addss	xmm8, xmm0

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm6
	mulss	xmm0, xmm6

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	addss	xmm8, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm2, xmm7
	mulss	xmm2, xmm7
	addss	xmm2, xmm0
	movaps	xmm1, xmm8
	mulss	xmm1, xmm8
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN1014@HandleAndD
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN1015@HandleAndD
$LN1014@HandleAndD:
	movaps	xmm0, xmm2
	call	sqrtf
$LN1015@HandleAndD:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	mulss	xmm9, DWORD PTR tv13204[rsp]

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm2, xmm11

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movss	xmm1, DWORD PTR __real@3f800000

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	mulss	xmm13, DWORD PTR tv13206[rsp]
	mulss	xmm14, DWORD PTR tv13248[rsp]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm1, xmm0

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	addss	xmm9, xmm13

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm2, xmm11

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movaps	xmm0, xmm10

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm6, xmm1

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	mulss	xmm0, xmm10

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm1

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	addss	xmm9, xmm14

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm8, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm2, xmm0
	xorps	xmm0, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm9, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm12
	mulss	xmm1, xmm12
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN1012@HandleAndD
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN1013@HandleAndD
$LN1012@HandleAndD:
	movaps	xmm0, xmm2
	call	sqrtf
$LN1013@HandleAndD:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm2, xmm1

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movaps	xmm0, xmm1

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm11

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mulss	xmm0, xmm10

; 1636 :          float bestDot = 0.f;
; 1637 :          for (int i = 0; i < 3; i++)
; 1638 :          {
; 1639 :             vec_t dirPlaneNormalWorld;
; 1640 :             dirPlaneNormalWorld.TransformVector(directionUnary[i], gContext.mModelSource);
; 1641 :             dirPlaneNormalWorld.Normalize();
; 1642 : 
; 1643 :             float dt = fabsf(Dot(Normalized(gContext.mCameraEye - gContext.mModelSource.v.position), dirPlaneNormalWorld));

	mulss	xmm2, xmm7

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	mulss	xmm0, xmm6

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm1, xmm12

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	addss	xmm2, xmm0
	mulss	xmm1, xmm8
	addss	xmm2, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1644 :             if (dt >= bestDot)

	comiss	xmm2, xmm15
	jb	SHORT $LN823@HandleAndD

; 1645 :             {
; 1646 :                bestDot = dt;
; 1647 :                bestAxis = i;
; 1648 :                bestAxisWorldDirection = dirPlaneNormalWorld;

	movss	DWORD PTR bestAxisWorldDirection$[rbp-256], xmm6
	mov	edi, 2
	movss	DWORD PTR bestAxisWorldDirection$[rbp-252], xmm7
	movss	DWORD PTR bestAxisWorldDirection$[rbp-248], xmm8
	movss	DWORD PTR bestAxisWorldDirection$[rbp-244], xmm9
$LN823@HandleAndD:

; 1649 :             }
; 1650 : 
; 1651 :             if (dt >= 0.1f)

	comiss	xmm2, DWORD PTR __real@3dcccccd
	jb	SHORT $LN824@HandleAndD

; 1652 :             {
; 1653 :                axes[numAxes] = i;

	mov	eax, r15d
	mov	DWORD PTR axes$[rbp+rax*4-256], 2

; 1654 :                axesWorldDirections[numAxes] = dirPlaneNormalWorld;

	add	rax, rax

; 1655 :                ++numAxes;

	inc	r15d
	mov	DWORD PTR numAxes$1$[rsp], r15d
	movss	DWORD PTR axesWorldDirections$[rbp+rax*8-256], xmm6
	movss	DWORD PTR axesWorldDirections$[rbp+rax*8-252], xmm7
	movss	DWORD PTR axesWorldDirections$[rbp+rax*8-248], xmm8
	movss	DWORD PTR axesWorldDirections$[rbp+rax*8-244], xmm9
	mov	r14d, DWORD PTR axes$[rbp-256]
$LN824@HandleAndD:

; 1656 :             }
; 1657 :          }
; 1658 :       }
; 1659 : 
; 1660 :       if (numAxes == 0)

	test	r15d, r15d
	jne	SHORT $LN26@HandleAndD

; 1661 :       {
; 1662 :          axes[0] = bestAxis;
; 1663 :          axesWorldDirections[0] = bestAxisWorldDirection;

	movups	xmm0, XMMWORD PTR bestAxisWorldDirection$[rbp-256]

; 1664 :          numAxes = 1;

	mov	r15d, 1
	mov	DWORD PTR axes$[rbp-256], edi
	mov	DWORD PTR numAxes$1$[rsp], r15d
	movups	XMMWORD PTR axesWorldDirections$[rbp-256], xmm0

; 1665 :       }

	jmp	SHORT $LN1029@HandleAndD
$LN26@HandleAndD:

; 1666 : 
; 1667 :       else if (bestAxis != axes[0])

	cmp	edi, r14d
	je	SHORT $LN1029@HandleAndD

; 1668 :       {
; 1669 :          unsigned int bestIndex = 0;

	mov	edx, r12d

; 1670 :          for (unsigned int i = 0; i < numAxes; i++)

	mov	eax, r12d
	test	r15d, r15d
	je	SHORT $LN6@HandleAndD
	lea	rcx, QWORD PTR axes$[rbp-256]
$LL7@HandleAndD:

; 1671 :          {
; 1672 :             if (axes[i] == bestAxis)

	cmp	DWORD PTR [rcx], edi
	je	SHORT $LN737@HandleAndD

; 1670 :          for (unsigned int i = 0; i < numAxes; i++)

	inc	eax
	add	rcx, 4
	cmp	eax, r15d
	jb	SHORT $LL7@HandleAndD

; 1874 :          }
; 1875 :          if (gContext.mbUsingBounds)

	jmp	SHORT $LN6@HandleAndD
$LN737@HandleAndD:

; 1673 :             {
; 1674 :                bestIndex = i;

	mov	edx, eax
$LN6@HandleAndD:

; 1675 :                break;
; 1676 :             }
; 1677 :          }
; 1678 :          int tempAxis = axes[0];
; 1679 :          axes[0] = axes[bestIndex];
; 1680 :          axes[bestIndex] = tempAxis;
; 1681 :          vec_t tempDirection = axesWorldDirections[0];

	movups	xmm1, XMMWORD PTR axesWorldDirections$[rbp-256]
	mov	ecx, edx
	mov	eax, DWORD PTR axes$[rbp+rcx*4-256]
	mov	DWORD PTR axes$[rbp-256], eax
	mov	DWORD PTR axes$[rbp+rcx*4-256], r14d

; 1682 :          axesWorldDirections[0] = axesWorldDirections[bestIndex];

	add	rcx, rcx
	movups	xmm0, XMMWORD PTR axesWorldDirections$[rbp+rcx*8-256]
	movups	XMMWORD PTR axesWorldDirections$[rbp-256], xmm0

; 1683 :          axesWorldDirections[bestIndex] = tempDirection;

	movups	XMMWORD PTR axesWorldDirections$[rbp+rcx*8-256], xmm1
$LN1029@HandleAndD:

; 1684 :       }
; 1685 : 
; 1686 :       for (unsigned int axisIndex = 0; axisIndex < numAxes; ++axisIndex)

	movss	xmm12, DWORD PTR __real@3f800000
	xorps	xmm13, xmm13
$LN28@HandleAndD:
	mov	eax, r12d
	mov	DWORD PTR axisIndex$1$[rsp], eax
	test	r15d, r15d
	je	$LN1028@HandleAndD
	movss	xmm14, DWORD PTR __xmm@80000000800000008000000080000000
	lea	r15, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A
	movss	xmm15, DWORD PTR __real@3f000000
	mov	edi, -16777216				; ff000000H
	movss	xmm11, DWORD PTR __real@42c80000
	npad	3
$LL10@HandleAndD:

; 1687 :       {
; 1688 :          bestAxis = axes[axisIndex];

	movsxd	rcx, DWORD PTR axes$[rbp+rax*4-256]

; 1689 :          bestAxisWorldDirection = axesWorldDirections[axisIndex];

	add	rax, rax
	mov	DWORD PTR bestAxis$2$[rbp-256], ecx
	movups	xmm0, XMMWORD PTR axesWorldDirections$[rbp+rax*8-256]

; 1690 : 
; 1691 :          // corners
; 1692 :          vec_t aabb[4];
; 1693 : 
; 1694 :          int secondAxis = (bestAxis + 1) % 3;
; 1695 :          int thirdAxis = (bestAxis + 2) % 3;
; 1696 : 
; 1697 :          for (int i = 0; i < 4; i++)
; 1698 :          {
; 1699 :             aabb[i][3] = aabb[i][bestAxis] = 0.f;

	mov	DWORD PTR aabb$33[rbp+rcx*4-256], r12d
	lea	r8d, DWORD PTR [rcx+1]
	mov	DWORD PTR aabb$33[rbp-244], 0
	lea	r9d, DWORD PTR [rcx+2]
	mov	eax, 1431655766				; 55555556H
	imul	r8d
	movups	XMMWORD PTR bestAxisWorldDirection$[rbp-256], xmm0
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	lea	eax, DWORD PTR [rdx+rdx*2]
	sub	r8d, eax
	mov	eax, 1431655766				; 55555556H
	imul	r9d
	movsxd	r10, r8d
	mov	eax, edx
	mov	DWORD PTR secondAxis$1$[rsp], r8d
	shr	eax, 31
	add	edx, eax
	mov	QWORD PTR $T23[rbp-256], r10

; 1700 :             aabb[i][secondAxis] = bounds[secondAxis + 3 * (i >> 1)];

	movss	xmm0, DWORD PTR [r10*4]
	movss	DWORD PTR aabb$33[rbp+r10*4-256], xmm0
	lea	eax, DWORD PTR [rdx+rdx*2]
	sub	r9d, eax

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+860

; 1702 :          }
; 1703 : 
; 1704 :          // draw bounds
; 1705 :          unsigned int anchorAlpha = gContext.mbEnable ? IM_COL32_BLACK : IM_COL32(0, 0, 0, 0x80);

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1085, 0
	movsxd	r11, r9d
	movsxd	rax, r9d
	mov	DWORD PTR thirdAxis$1$[rsp], r9d
	mov	r9d, -2147483648			; 80000000H
	cmovne	r9d, edi
	mov	QWORD PTR $T22[rbp-256], r11
	movss	xmm2, DWORD PTR [r11*4]
	movss	xmm1, DWORD PTR [rax*4+12]
	movss	DWORD PTR aabb$33[rbp+r11*4-256], xmm2
	mov	DWORD PTR aabb$33[rbp+rcx*4-240], r12d
	mov	DWORD PTR aabb$33[rbp-228], 0
	movss	DWORD PTR aabb$33[rbp+r10*4-240], xmm0
	movss	DWORD PTR aabb$33[rbp+r11*4-240], xmm1
	mov	DWORD PTR aabb$33[rbp+rcx*4-224], r12d
	mov	DWORD PTR aabb$33[rbp-212], 0
	movsxd	rax, r8d

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	r8, QWORD PTR boundsMVP$31[rbp-256]

; 1702 :          }
; 1703 : 
; 1704 :          // draw bounds
; 1705 :          unsigned int anchorAlpha = gContext.mbEnable ? IM_COL32_BLACK : IM_COL32(0, 0, 0, 0x80);

	mov	DWORD PTR anchorAlpha$1$[rsp], r9d
	movss	xmm0, DWORD PTR [rax*4+12]
	movss	DWORD PTR aabb$33[rbp+r10*4-224], xmm0
	movss	DWORD PTR aabb$33[rbp+r11*4-224], xmm1
	mov	DWORD PTR aabb$33[rbp+rcx*4-208], r12d

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+604

; 1690 : 
; 1691 :          // corners
; 1692 :          vec_t aabb[4];
; 1693 : 
; 1694 :          int secondAxis = (bestAxis + 1) % 3;
; 1695 :          int thirdAxis = (bestAxis + 2) % 3;
; 1696 : 
; 1697 :          for (int i = 0; i < 4; i++)
; 1698 :          {
; 1699 :             aabb[i][3] = aabb[i][bestAxis] = 0.f;

	mov	DWORD PTR aabb$33[rbp-196], 0

; 1700 :             aabb[i][secondAxis] = bounds[secondAxis + 3 * (i >> 1)];

	movss	DWORD PTR aabb$33[rbp+r10*4-208], xmm0

; 1701 :             aabb[i][thirdAxis] = bounds[thirdAxis + 3 * ((i >> 1) ^ (i & 1))];

	movss	DWORD PTR aabb$33[rbp+r11*4-208], xmm2

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	call	?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z ; ImGuizmo::FPU_MatrixF_x_MatrixF

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm7, DWORD PTR boundsMVP$31[rbp-196]

; 1702 :          }
; 1703 : 
; 1704 :          // draw bounds
; 1705 :          unsigned int anchorAlpha = gContext.mbEnable ? IM_COL32_BLACK : IM_COL32(0, 0, 0, 0x80);

	mov	eax, r12d

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm10, DWORD PTR boundsMVP$31[rbp-212]

; 1702 :          }
; 1703 : 
; 1704 :          // draw bounds
; 1705 :          unsigned int anchorAlpha = gContext.mbEnable ? IM_COL32_BLACK : IM_COL32(0, 0, 0, 0x80);

	mov	r14, r12
	mov	DWORD PTR i$1$[rsp], eax
	mov	QWORD PTR $T18[rbp-256], r12
$LL16@HandleAndD:

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm0, DWORD PTR boundsMVP$31[rbp-228]
	movaps	xmm1, xmm10
	movss	xmm2, DWORD PTR boundsMVP$31[rbp-244]

; 1709 :          {
; 1710 :             ImVec2 worldBound1 = worldToPos(aabb[i], boundsMVP);

	mov	r12, r14
	shl	r12, 4

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm3, xmm15

; 1709 :          {
; 1710 :             ImVec2 worldBound1 = worldToPos(aabb[i], boundsMVP);

	mov	DWORD PTR tv13519[rbp-256], eax

; 806  :       trans.y = 1.f - trans.y;

	movaps	xmm9, xmm12

; 1711 :             ImVec2 worldBound2 = worldToPos(aabb[(i + 1) % 4], boundsMVP);

	inc	eax
	mov	QWORD PTR tv13201[rbp-256], r12
	mov	DWORD PTR tv13240[rbp-256], eax

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movups	xmm6, XMMWORD PTR aabb$33[rbp+r12-256]

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm2, xmm6
	movaps	xmm5, xmm6
	shufps	xmm5, xmm6, 85				; 00000055H
	movaps	xmm4, xmm6
	mulss	xmm0, xmm5
	movaps	xmm8, xmm5
	mulss	xmm8, DWORD PTR boundsMVP$31[rbp-240]
	shufps	xmm4, xmm6, 170				; 000000aaH
	addss	xmm2, xmm0
	mulss	xmm1, xmm4
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR boundsMVP$31[rbp-256]
	mulss	xmm6, DWORD PTR boundsMVP$31[rbp-252]
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR boundsMVP$31[rbp-224]
	addss	xmm8, xmm0
	movss	xmm0, DWORD PTR boundsMVP$31[rbp-220]
	mulss	xmm1, xmm4
	mulss	xmm0, xmm4
	addss	xmm2, xmm7
	addss	xmm8, xmm1
	movss	xmm1, DWORD PTR boundsMVP$31[rbp-236]
	mulss	xmm1, xmm5

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm2

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm1, xmm6
	addss	xmm8, DWORD PTR boundsMVP$31[rbp-208]
	addss	xmm1, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm8, xmm3

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm8, xmm15

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm1, DWORD PTR boundsMVP$31[rbp-204]

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm1, xmm3

; 808  :       trans.y *= size.y;

	addss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm1, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR worldBound1$14[rbp-256], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm9, xmm1

; 807  :       trans.x *= size.x;

	mulss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
	movss	DWORD PTR worldBound1$14[rbp-252], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1711 :             ImVec2 worldBound2 = worldToPos(aabb[(i + 1) % 4], boundsMVP);

	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN1011@HandleAndD
	dec	eax
	or	eax, -4
	inc	eax
$LN1011@HandleAndD:

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm2, DWORD PTR boundsMVP$31[rbp-244]
	movaps	xmm1, xmm10
	movss	xmm0, DWORD PTR boundsMVP$31[rbp-228]

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm3, xmm15

; 808  :       trans.y *= size.y;

	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404

; 1711 :             ImVec2 worldBound2 = worldToPos(aabb[(i + 1) % 4], boundsMVP);

	movsxd	r14, eax
	add	r14, r14

; 1712 :             if (!IsInContextRect(worldBound1) || !IsInContextRect(worldBound2))

	comiss	xmm8, xmm10

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movups	xmm6, XMMWORD PTR aabb$33[rbp+r14*8-256]

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm2, xmm6
	movaps	xmm5, xmm6
	shufps	xmm5, xmm6, 85				; 00000055H
	movaps	xmm4, xmm6
	shufps	xmm4, xmm6, 170				; 000000aaH
	mulss	xmm1, xmm4
	mulss	xmm0, xmm5
	addss	xmm2, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR boundsMVP$31[rbp-240]
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR boundsMVP$31[rbp-224]
	mulss	xmm1, xmm4
	addss	xmm2, xmm7
	movaps	xmm7, xmm6
	mulss	xmm7, DWORD PTR boundsMVP$31[rbp-256]
	mulss	xmm6, DWORD PTR boundsMVP$31[rbp-252]
	addss	xmm7, xmm0
	movss	xmm0, DWORD PTR boundsMVP$31[rbp-220]

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm7, xmm1

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm1, DWORD PTR boundsMVP$31[rbp-236]
	mulss	xmm1, xmm5
	mulss	xmm0, xmm4
	addss	xmm7, DWORD PTR boundsMVP$31[rbp-208]
	addss	xmm1, xmm6

; 806  :       trans.y = 1.f - trans.y;

	movaps	xmm6, xmm12

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm3

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm1, xmm0

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm7, xmm15

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm1, DWORD PTR boundsMVP$31[rbp-204]

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm1, xmm3

; 808  :       trans.y *= size.y;

	addss	xmm7, xmm10

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm1, xmm15

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm6, xmm1

; 807  :       trans.x *= size.x;

	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm6, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 191  :    template <typename T> bool IsWithin(T x, T y, T z) { return (x >= y) && (x <= z); }

	jb	$LN1045@HandleAndD
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1420
	comiss	xmm1, xmm8
	jb	$LN1045@HandleAndD
	comiss	xmm9, xmm2
	jb	$LN1045@HandleAndD
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1424
	comiss	xmm0, xmm9
	jb	$LN1045@HandleAndD

; 1712 :             if (!IsInContextRect(worldBound1) || !IsInContextRect(worldBound2))

	comiss	xmm7, xmm10

; 191  :    template <typename T> bool IsWithin(T x, T y, T z) { return (x >= y) && (x <= z); }

	jb	$LN1045@HandleAndD
	comiss	xmm1, xmm7
	jb	$LN1045@HandleAndD
	comiss	xmm6, xmm2
	jb	$LN1045@HandleAndD
	comiss	xmm0, xmm6
	jb	$LN1045@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movaps	xmm0, xmm9
	movaps	xmm1, xmm8
	subss	xmm1, xmm7
	subss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	mulss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1716 :             float boundDistance = sqrtf(ImLengthSqr(worldBound1 - worldBound2));

	ucomiss	xmm0, xmm1
	ja	SHORT $LN1009@HandleAndD
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	jmp	SHORT $LN1010@HandleAndD
$LN1009@HandleAndD:
	movaps	xmm0, xmm1
	call	sqrtf
	mov	r9d, DWORD PTR anchorAlpha$1$[rsp]
$LN1010@HandleAndD:

; 1717 :             int stepCount = (int)(boundDistance / 10.f);

	divss	xmm0, DWORD PTR __real@41200000

; 190  :    template <typename T> T min(T x, T y) { return (x < y) ? x : y; }

	mov	esi, 1000				; 000003e8H

; 1719 :             for (int j = 0; j < stepCount; j++)

	lea	r15d, DWORD PTR [r9+11184810]
	cvttss2si eax, xmm0

; 190  :    template <typename T> T min(T x, T y) { return (x < y) ? x : y; }

	cmp	eax, esi
	cmovl	esi, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	xor	edi, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1719 :             for (int j = 0; j < stepCount; j++)

	test	esi, esi
	jle	$LN18@HandleAndD
	movss	xmm13, DWORD PTR __real@40000000
	subss	xmm7, xmm8
	movaps	xmm10, xmm12
	movd	xmm0, esi
	cvtdq2ps xmm0, xmm0
	subss	xmm6, xmm9
	divss	xmm10, xmm0
	movaps	xmm11, xmm10
	mulss	xmm11, xmm15
$LL19@HandleAndD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 466  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	movaps	xmm0, xmm7
	movd	xmm2, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1723 :                float t2 = (float)j * stepLength + stepLength * 0.5f;

	movaps	xmm3, xmm11

; 1727 :                drawList->AddLine(worldBoundSS1, worldBoundSS2, IM_COL32(0xAA, 0xAA, 0xAA, 0) + anchorAlpha, 2.f);

	movss	DWORD PTR [rsp+32], xmm13
	cvtdq2ps xmm2, xmm2
	lea	r8, QWORD PTR worldBoundSS2$21[rbp-256]
	mov	r9d, r15d
	lea	rdx, QWORD PTR worldBoundSS1$16[rbp-256]
	mov	rcx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 466  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	movaps	xmm1, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1722 :                float t1 = (float)j * stepLength;

	mulss	xmm2, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 466  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	mulss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1723 :                float t2 = (float)j * stepLength + stepLength * 0.5f;

	addss	xmm3, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 466  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	mulss	xmm1, xmm2
	addss	xmm0, xmm8
	addss	xmm1, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR worldBoundSS1$16[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 466  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	movaps	xmm0, xmm3
	mulss	xmm0, xmm7
	mulss	xmm3, xmm6
	addss	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR worldBoundSS1$16[rbp-252], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 466  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	addss	xmm3, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR worldBoundSS2$21[rbp-256], xmm0
	movss	DWORD PTR worldBoundSS2$21[rbp-252], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1727 :                drawList->AddLine(worldBoundSS1, worldBoundSS2, IM_COL32(0xAA, 0xAA, 0xAA, 0) + anchorAlpha, 2.f);

	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	inc	edi
	cmp	edi, esi
	jl	SHORT $LL19@HandleAndD
	movss	xmm11, DWORD PTR __real@42c80000
	xorps	xmm13, xmm13
$LN18@HandleAndD:

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	movss	xmm10, DWORD PTR aabb$33[rbp+r12-256]

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm3, xmm15

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	movss	xmm5, DWORD PTR aabb$33[rbp+r12-252]
	movss	xmm6, DWORD PTR aabb$33[rbp+r12-248]
	addss	xmm10, DWORD PTR aabb$33[rbp+r14*8-256]
	addss	xmm5, DWORD PTR aabb$33[rbp+r14*8-252]
	addss	xmm6, DWORD PTR aabb$33[rbp+r14*8-248]
	movss	xmm0, DWORD PTR aabb$33[rbp+r12-244]
	addss	xmm0, DWORD PTR aabb$33[rbp+r14*8-244]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	mov	rax, QWORD PTR tv13333[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm5, xmm15
	mulss	xmm6, xmm15
	mulss	xmm0, xmm15

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movaps	xmm2, xmm5
	mulss	xmm2, DWORD PTR boundsMVP$31[rbp-228]
	movaps	xmm4, xmm5
	mulss	xmm4, DWORD PTR boundsMVP$31[rbp-240]
	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR boundsMVP$31[rbp-212]

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movss	DWORD PTR midPoint$2$sroa$7132$1$[rbp-256], xmm0

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	mulss	xmm10, xmm15

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movss	DWORD PTR midPoint$2$sroa$7130$1$[rbp-256], xmm5
	movss	DWORD PTR midPoint$2$sroa$7131$1$[rbp-256], xmm6

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movaps	xmm0, xmm10
	mulss	xmm0, DWORD PTR boundsMVP$31[rbp-244]
	addss	xmm2, xmm0
	movaps	xmm0, xmm10
	mulss	xmm0, DWORD PTR boundsMVP$31[rbp-256]
	addss	xmm2, xmm1
	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR boundsMVP$31[rbp-224]
	addss	xmm4, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR boundsMVP$31[rbp-236]
	addss	xmm2, DWORD PTR boundsMVP$31[rbp-196]
	addss	xmm4, xmm1
	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR boundsMVP$31[rbp-220]

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm4, DWORD PTR boundsMVP$31[rbp-208]

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movaps	xmm2, xmm10
	mulss	xmm2, DWORD PTR boundsMVP$31[rbp-252]

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm4, xmm3

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm0, DWORD PTR [rax+3596]
	subss	xmm9, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm4, xmm15

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm1, DWORD PTR [rax+3592]
	subss	xmm8, xmm1

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm9, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, DWORD PTR boundsMVP$31[rbp-204]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	mulss	xmm8, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 808  :       trans.y *= size.y;

	addss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	addss	xmm9, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 806  :       trans.y = 1.f - trans.y;

	movaps	xmm3, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR midBound$15[rbp-256], xmm4

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm4, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm2, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	mulss	xmm4, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm3, xmm2

; 1728 :             }
; 1729 :             vec_t midPoint = (aabb[i] + aabb[(i + 1) % 4]) * 0.5f;
; 1730 :             ImVec2 midBound = worldToPos(midPoint, boundsMVP);
; 1731 :             static const float AnchorBigRadius = 8.f;
; 1732 :             static const float AnchorSmallRadius = 6.f;
; 1733 :             bool overBigAnchor = ImLengthSqr(worldBound1 - io.MousePos) <= (AnchorBigRadius * AnchorBigRadius);

	movss	xmm2, DWORD PTR __real@42800000
	comiss	xmm2, xmm9

; 807  :       trans.x *= size.x;

	mulss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416

; 1728 :             }
; 1729 :             vec_t midPoint = (aabb[i] + aabb[(i + 1) % 4]) * 0.5f;
; 1730 :             ImVec2 midBound = worldToPos(midPoint, boundsMVP);
; 1731 :             static const float AnchorBigRadius = 8.f;
; 1732 :             static const float AnchorSmallRadius = 6.f;
; 1733 :             bool overBigAnchor = ImLengthSqr(worldBound1 - io.MousePos) <= (AnchorBigRadius * AnchorBigRadius);

	setae	dil
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
	movss	DWORD PTR midBound$15[rbp-252], xmm3

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm3, xmm0

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm3, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	addss	xmm3, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1734 :             bool overSmallAnchor = ImLengthSqr(midBound - io.MousePos) <= (AnchorBigRadius * AnchorBigRadius);

	comiss	xmm2, xmm3
	setae	sil

; 1735 : 
; 1736 :             int type = MT_NONE;

	xor	r12d, r12d
	mov	ecx, r12d

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	r13b, 7

; 1737 :             vec_t gizmoHitProportion;
; 1738 : 
; 1739 :             if(Intersects(operation, TRANSLATE))

	je	SHORT $LN32@HandleAndD

; 1740 :             {
; 1741 :                type = GetMoveType(operation, &gizmoHitProportion);

	lea	rdx, QWORD PTR gizmoHitProportion$25[rbp-256]
	mov	ecx, r13d
	call	?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z ; ImGuizmo::GetMoveType
	mov	ecx, eax
$LN32@HandleAndD:

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	r13b, 120				; 00000078H

; 1742 :             }
; 1743 :             if(Intersects(operation, ROTATE) && type == MT_NONE)

	je	SHORT $LN33@HandleAndD
	test	ecx, ecx
	jne	SHORT $LN33@HandleAndD

; 1744 :             {
; 1745 :                type = GetRotateType(operation);

	mov	ecx, r13d
	call	?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z ; ImGuizmo::GetRotateType
	mov	ecx, eax
$LN33@HandleAndD:

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	r13d, 896				; 00000380H

; 1746 :             }
; 1747 :             if(Intersects(operation, SCALE) && type == MT_NONE)

	je	SHORT $LN34@HandleAndD
	test	ecx, ecx
	jne	SHORT $LN34@HandleAndD

; 1748 :             {
; 1749 :                type = GetScaleType(operation);

	mov	ecx, r13d
	call	?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z ; ImGuizmo::GetScaleType
	mov	ecx, eax
$LN34@HandleAndD:

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	test	ecx, ecx
	movzx	eax, sil
	mov	r9d, r12d
	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+136
	cmove	r9d, eax
	mov	r8d, r12d
	movzx	eax, dil
	cmove	r8d, eax
	mov	DWORD PTR tv14274[rbp-256], r9d
	mov	DWORD PTR tv14278[rsp], r8d
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1514 :         _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	movss	xmm2, DWORD PTR __real@41000000
	lea	rdx, QWORD PTR worldBound1$14[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1760 :             unsigned int bigAnchorColor = overBigAnchor ? selectionColor : (IM_COL32(0xAA, 0xAA, 0xAA, 0) + anchorAlpha);

	test	r8b, r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1514 :         _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	mov	DWORD PTR [rsp+32], 48			; 00000030H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1760 :             unsigned int bigAnchorColor = overBigAnchor ? selectionColor : (IM_COL32(0xAA, 0xAA, 0xAA, 0) + anchorAlpha);

	mov	esi, r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1514 :         _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	mov	rcx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1760 :             unsigned int bigAnchorColor = overBigAnchor ? selectionColor : (IM_COL32(0xAA, 0xAA, 0xAA, 0) + anchorAlpha);

	cmovne	esi, eax

; 1761 :             unsigned int smallAnchorColor = overSmallAnchor ? selectionColor : (IM_COL32(0xAA, 0xAA, 0xAA, 0) + anchorAlpha);

	test	r9b, r9b
	mov	DWORD PTR bigAnchorColor$1$[rsp], esi
	cmovne	r15d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1514 :         _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	xor	r9d, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1761 :             unsigned int smallAnchorColor = overSmallAnchor ? selectionColor : (IM_COL32(0xAA, 0xAA, 0xAA, 0) + anchorAlpha);

	mov	DWORD PTR smallAnchorColor$1$[rsp], r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1514 :         _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx

; 1515 :         _Path.Size--;

	mov	r14d, DWORD PTR [rbx+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	rdi, QWORD PTR [rbx+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1515 :         _Path.Size--;

	dec	r14d
	mov	DWORD PTR [rbx+120], r14d

; 975  :     if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)

	cmp	r14d, 3
	jl	$LN1030@HandleAndD

; 976  :         return;
; 977  : 
; 978  :     const ImVec2 uv = _Data->TexUvWhitePixel;
; 979  : 
; 980  :     if (Flags & ImDrawListFlags_AntiAliasedFill)

	test	BYTE PTR [rbx+48], 4
	mov	rcx, rbx
	mov	rax, QWORD PTR [rbx+56]
	movss	xmm6, DWORD PTR [rax]
	movss	xmm7, DWORD PTR [rax+4]
	je	$LN245@HandleAndD

; 981  :     {
; 982  :         // Anti-aliased Fill
; 983  :         const float AA_SIZE = _FringeScale;

	movss	xmm8, DWORD PTR [rbx+192]

; 986  :         const int vtx_count = (points_count * 2);

	lea	eax, DWORD PTR [r14+r14]
	lea	edx, DWORD PTR [r14*8-6]
	mov	DWORD PTR vtx_count$1$[rsp], eax
	add	edx, r14d

; 987  :         PrimReserve(idx_count, vtx_count);

	mov	r8d, eax
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 988  : 
; 989  :         // Add indexes for fill
; 990  :         unsigned int vtx_inner_idx = _VtxCurrentIdx;

	mov	r13d, DWORD PTR [rbx+52]
	mov	r8d, 2

; 991  :         unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;

	lea	eax, DWORD PTR [r13+1]
	mov	DWORD PTR vtx_outer_idx$1$[rsp], eax
	npad	4
$LL230@HandleAndD:

; 992  :         for (int i = 2; i < points_count; i++)
; 993  :         {
; 994  :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));

	mov	rax, QWORD PTR [rbx+80]
	movzx	edx, r8w
	add	dx, dx
	inc	r8d
	add	dx, r13w
	mov	WORD PTR [rax], r13w
	mov	rax, QWORD PTR [rbx+80]
	lea	ecx, DWORD PTR [rdx-2]
	mov	WORD PTR [rax+2], cx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+4], dx

; 995  :             _IdxWritePtr += 3;

	add	QWORD PTR [rbx+80], 6
	cmp	r8d, r14d
	jl	SHORT $LL230@HandleAndD

; 996  :         }
; 997  : 
; 998  :         // Compute normals
; 999  :         _Data->TempBuffer.reserve_discard(points_count);

	mov	rsi, QWORD PTR [rbx+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	cmp	r14d, DWORD PTR [rsi+52]
	jle	SHORT $LN251@HandleAndD
	mov	rcx, QWORD PTR [rsi+56]
	test	rcx, rcx
	je	SHORT $LN259@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN257@HandleAndD

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN257@HandleAndD:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN259@HandleAndD:

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN264@HandleAndD

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN264@HandleAndD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	movsxd	rcx, r14d
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	mov	QWORD PTR [rsi+56], rax
	mov	DWORD PTR [rsi+52], r14d
$LN251@HandleAndD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1000 :         ImVec2* temp_normals = _Data->TempBuffer.Data;

	mov	rax, QWORD PTR [rbx+56]

; 1001 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	lea	r15d, DWORD PTR [r14-1]
	xor	r9d, r9d
	mov	rsi, QWORD PTR [rax+56]
	movsxd	rax, r15d
	cmp	r14d, 4
	jl	$LC826@HandleAndD
	lea	rdx, QWORD PTR [rax*8]
	mov	r8, rsi
	lea	eax, DWORD PTR [r14-4]
	mov	r11d, 12
	shr	eax, 2
	lea	rcx, QWORD PTR [rdi+12]
	sub	r8, rdi
	sub	r11, rdi
	inc	eax
	mov	r10d, eax
	lea	r12d, DWORD PTR [rax*4]
$LL831@HandleAndD:

; 1002 :         {
; 1003 :             const ImVec2& p0 = points[i0];
; 1004 :             const ImVec2& p1 = points[i1];
; 1005 :             float dx = p1.x - p0.x;

	movss	xmm2, DWORD PTR [rcx-12]

; 1006 :             float dy = p1.y - p0.y;

	movss	xmm3, DWORD PTR [rcx-8]
	subss	xmm2, DWORD PTR [rdi+rdx]
	subss	xmm3, DWORD PTR [rdi+rdx+4]

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm13
	jbe	SHORT $LN827@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN827@HandleAndD:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rsi+rdx], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm14
	movss	DWORD PTR [rsi+rdx+4], xmm2
	movss	xmm2, DWORD PTR [rcx-4]
	movss	xmm3, DWORD PTR [rcx]
	subss	xmm2, DWORD PTR [rcx-12]
	subss	xmm3, DWORD PTR [rcx-8]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm13
	jbe	SHORT $LN828@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN828@HandleAndD:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [r8+rcx-12], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm14
	movss	DWORD PTR [r8+rcx-8], xmm2
	movss	xmm2, DWORD PTR [rcx+4]
	movss	xmm3, DWORD PTR [rcx+8]
	subss	xmm2, DWORD PTR [rcx-4]
	subss	xmm3, DWORD PTR [rcx]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm13
	jbe	SHORT $LN829@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN829@HandleAndD:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [r8+rcx-4], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm14
	movss	DWORD PTR [rcx+r8], xmm2
	movss	xmm2, DWORD PTR [rcx+12]
	movss	xmm3, DWORD PTR [rcx+16]
	subss	xmm2, DWORD PTR [rcx+4]
	subss	xmm3, DWORD PTR [rcx+8]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm13
	jbe	SHORT $LN830@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN830@HandleAndD:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [r8+rcx+4], xmm3
	lea	rax, QWORD PTR [r9+3]

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm14
	lea	rdx, QWORD PTR [r11+rcx]
	movss	DWORD PTR [r8+rcx+8], xmm2
	add	r9, 4
	add	rcx, 32					; 00000020H
	sub	r10, 1
	jne	$LL831@HandleAndD

; 1001 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	cmp	r12d, r14d
	jge	SHORT $LN1181@HandleAndD
$LC826@HandleAndD:
	mov	r8d, r14d
	lea	rcx, QWORD PTR [rax*8]
	sub	r8d, r12d
	lea	rdx, QWORD PTR [rdi+r9*8]
$LC918@HandleAndD:

; 1002 :         {
; 1003 :             const ImVec2& p0 = points[i0];
; 1004 :             const ImVec2& p1 = points[i1];
; 1005 :             float dx = p1.x - p0.x;

	movss	xmm2, DWORD PTR [rdx]

; 1006 :             float dy = p1.y - p0.y;

	movss	xmm3, DWORD PTR [rdx+4]
	subss	xmm2, DWORD PTR [rcx+rdi]
	subss	xmm3, DWORD PTR [rcx+rdi+4]

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm13
	jbe	SHORT $LN247@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN247@HandleAndD:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rcx+rsi], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm14
	movss	DWORD PTR [rcx+rsi+4], xmm2
	mov	rcx, rdx
	sub	rcx, rdi
	add	rdx, 8
	sub	r8, 1
	jne	SHORT $LC918@HandleAndD
$LN1181@HandleAndD:

; 1010 :         }
; 1011 : 
; 1012 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	movss	xmm9, DWORD PTR __real@358637bd
	lea	r9, QWORD PTR [rdi+4]
	xor	r12d, r12d
	mulss	xmm8, xmm15
	mov	r11, rsi
	mov	r10d, r12d
	sub	r11, rdi
	mov	edi, DWORD PTR vtx_outer_idx$1$[rsp]
	npad	4
$LL236@HandleAndD:

; 1013 :         {
; 1014 :             // Average normals
; 1015 :             const ImVec2& n0 = temp_normals[i0];
; 1016 :             const ImVec2& n1 = temp_normals[i1];
; 1017 :             float dm_x = (n0.x + n1.x) * 0.5f;

	movss	xmm2, DWORD PTR [r9+r11-4]

; 1018 :             float dm_y = (n0.y + n1.y) * 0.5f;

	movss	xmm3, DWORD PTR [r9+r11]
	movsxd	rax, r15d
	addss	xmm2, DWORD PTR [rsi+rax*8]
	addss	xmm3, DWORD PTR [rsi+rax*8+4]
	mulss	xmm2, xmm15
	mulss	xmm3, xmm15

; 1019 :             IM_FIXNORMAL2F(dm_x, dm_y);

	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm9
	jbe	SHORT $LN248@HandleAndD
	movaps	xmm0, xmm12
	divss	xmm0, xmm1
	movaps	xmm1, xmm11
	minss	xmm1, xmm0
	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN248@HandleAndD:

; 1020 :             dm_x *= AA_SIZE * 0.5f;
; 1021 :             dm_y *= AA_SIZE * 0.5f;
; 1022 : 
; 1023 :             // Add vertices
; 1024 :             _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner

	movss	xmm0, DWORD PTR [r9-4]

; 1025 :             _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
; 1026 :             _VtxWritePtr += 2;
; 1027 : 
; 1028 :             // Add indexes for fringes
; 1029 :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));

	movzx	edx, r10w
	mov	rax, QWORD PTR [rbx+72]
	add	r15w, r15w
	mulss	xmm2, xmm8
	add	dx, dx
	mulss	xmm3, xmm8
	lea	ecx, DWORD PTR [r15+r13]
	subss	xmm0, xmm2
	lea	r8d, DWORD PTR [rdx+r13]
	movss	DWORD PTR [rax], xmm0
	movss	xmm1, DWORD PTR [r9]
	mov	rax, QWORD PTR [rbx+72]
	subss	xmm1, xmm3
	movss	DWORD PTR [rax+4], xmm1
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], -16777216		; ff000000H
	addss	xmm2, DWORD PTR [r9-4]
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+20], xmm2
	addss	xmm3, DWORD PTR [r9]
	mov	rax, QWORD PTR [rbx+72]
	add	r9, 8
	movss	DWORD PTR [rax+24], xmm3
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+28], xmm6
	movss	DWORD PTR [rax+32], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+36], r12d
	mov	rax, QWORD PTR [rbx+80]
	add	QWORD PTR [rbx+72], 40			; 00000028H
	mov	WORD PTR [rax], r8w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+2], cx
	lea	ecx, DWORD PTR [r15+rdi]
	mov	rax, QWORD PTR [rbx+80]
	mov	r15d, r10d
	inc	r10d
	mov	WORD PTR [rax+4], cx

; 1030 :             _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));

	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+6], cx
	lea	ecx, DWORD PTR [rdx+rdi]
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+8], cx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+10], r8w

; 1031 :             _IdxWritePtr += 6;

	add	QWORD PTR [rbx+80], 12
	cmp	r10d, r14d
	jl	$LL236@HandleAndD

; 1032 :         }
; 1033 :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, WORD PTR vtx_count$1$[rsp]
	add	DWORD PTR [rbx+52], eax

; 1034 :     }

	mov	esi, DWORD PTR bigAnchorColor$1$[rsp]
	jmp	$LN1182@HandleAndD
$LN245@HandleAndD:

; 1035 :     else
; 1036 :     {
; 1037 :         // Non Anti-aliased Fill
; 1038 :         const int idx_count = (points_count - 2)*3;

	lea	eax, DWORD PTR [r14-2]

; 1039 :         const int vtx_count = points_count;
; 1040 :         PrimReserve(idx_count, vtx_count);

	mov	r8d, r14d
	lea	edx, DWORD PTR [rax+rax*2]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve
	mov	ecx, r14d
	mov	r15d, -16777216				; ff000000H
$LL239@HandleAndD:

; 1041 :         for (int i = 0; i < vtx_count; i++)
; 1042 :         {
; 1043 :             _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	mov	rax, QWORD PTR [rbx+72]
	movsd	xmm0, QWORD PTR [rdi]
	lea	rdi, QWORD PTR [rdi+8]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r15d

; 1044 :             _VtxWritePtr++;

	add	QWORD PTR [rbx+72], 20
	sub	rcx, 1
	jne	SHORT $LL239@HandleAndD
	mov	edx, 2
	npad	10
$LL242@HandleAndD:

; 1045 :         }
; 1046 :         for (int i = 2; i < points_count; i++)
; 1047 :         {
; 1048 :             _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);

	mov	rcx, QWORD PTR [rbx+80]
	movzx	eax, WORD PTR [rbx+52]
	mov	WORD PTR [rcx], ax
	lea	ecx, DWORD PTR [rdx-1]
	add	cx, WORD PTR [rbx+52]
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+2], cx
	movzx	ecx, dx
	mov	rax, QWORD PTR [rbx+80]
	inc	edx
	add	cx, WORD PTR [rbx+52]
	mov	WORD PTR [rax+4], cx

; 1049 :             _IdxWritePtr += 3;

	add	QWORD PTR [rbx+80], 6
	cmp	edx, r14d
	jl	SHORT $LL242@HandleAndD

; 1050 :         }
; 1051 :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movss	xmm9, DWORD PTR __real@358637bd
	movzx	eax, r14w
	add	DWORD PTR [rbx+52], eax
	jmp	SHORT $LN244@HandleAndD
$LN1030@HandleAndD:

; 975  :     if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)

	movss	xmm9, DWORD PTR __real@358637bd
$LN1182@HandleAndD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r15d, -16777216				; ff000000H
$LN244@HandleAndD:
	mov	DWORD PTR [rbx+120], r12d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	test	esi, r15d
	je	$LN300@HandleAndD

; 1514 :         _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	movss	xmm2, DWORD PTR __real@40d9999a
	lea	rdx, QWORD PTR worldBound1$14[rbp-256]
	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], 48			; 00000030H
	mov	rcx, rbx
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx

; 1515 :         _Path.Size--;

	dec	DWORD PTR [rbx+120]
	mov	r14d, DWORD PTR [rbx+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	rdi, QWORD PTR [rbx+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 975  :     if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)

	cmp	r14d, 3
	jl	$LN327@HandleAndD

; 976  :         return;
; 977  : 
; 978  :     const ImVec2 uv = _Data->TexUvWhitePixel;
; 979  : 
; 980  :     if (Flags & ImDrawListFlags_AntiAliasedFill)

	test	BYTE PTR [rbx+48], 4
	mov	rcx, rbx
	mov	rax, QWORD PTR [rbx+56]
	movss	xmm6, DWORD PTR [rax]
	movss	xmm7, DWORD PTR [rax+4]
	je	$LN328@HandleAndD

; 981  :     {
; 982  :         // Anti-aliased Fill
; 983  :         const float AA_SIZE = _FringeScale;

	movss	xmm8, DWORD PTR [rbx+192]

; 984  :         const ImU32 col_trans = col & ~IM_COL32_A_MASK;
; 985  :         const int idx_count = (points_count - 2)*3 + points_count * 6;

	lea	edx, DWORD PTR [r14*8-6]
	mov	eax, esi
	add	edx, r14d
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR col_trans$1$[rsp], eax

; 986  :         const int vtx_count = (points_count * 2);

	lea	eax, DWORD PTR [r14+r14]

; 987  :         PrimReserve(idx_count, vtx_count);

	mov	r8d, eax
	mov	DWORD PTR vtx_count$1$[rbp-256], eax
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 988  : 
; 989  :         // Add indexes for fill
; 990  :         unsigned int vtx_inner_idx = _VtxCurrentIdx;

	mov	r13d, DWORD PTR [rbx+52]
	mov	r8d, 2

; 991  :         unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;

	lea	eax, DWORD PTR [r13+1]
	mov	DWORD PTR vtx_outer_idx$1$[rsp], eax
	npad	12
$LL313@HandleAndD:

; 992  :         for (int i = 2; i < points_count; i++)
; 993  :         {
; 994  :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));

	mov	rax, QWORD PTR [rbx+80]
	movzx	edx, r8w
	add	dx, dx
	inc	r8d
	add	dx, r13w
	mov	WORD PTR [rax], r13w
	mov	rax, QWORD PTR [rbx+80]
	lea	ecx, DWORD PTR [rdx-2]
	mov	WORD PTR [rax+2], cx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+4], dx

; 995  :             _IdxWritePtr += 3;

	add	QWORD PTR [rbx+80], 6
	cmp	r8d, r14d
	jl	SHORT $LL313@HandleAndD

; 996  :         }
; 997  : 
; 998  :         // Compute normals
; 999  :         _Data->TempBuffer.reserve_discard(points_count);

	mov	rsi, QWORD PTR [rbx+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	cmp	r14d, DWORD PTR [rsi+52]
	jle	SHORT $LN334@HandleAndD
	mov	rcx, QWORD PTR [rsi+56]
	test	rcx, rcx
	je	SHORT $LN342@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN340@HandleAndD

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN340@HandleAndD:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN342@HandleAndD:

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN347@HandleAndD

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN347@HandleAndD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	movsxd	rcx, r14d
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	mov	QWORD PTR [rsi+56], rax
	mov	DWORD PTR [rsi+52], r14d
$LN334@HandleAndD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1000 :         ImVec2* temp_normals = _Data->TempBuffer.Data;

	mov	rax, QWORD PTR [rbx+56]

; 1001 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	lea	r15d, DWORD PTR [r14-1]
	xor	r9d, r9d
	mov	rsi, QWORD PTR [rax+56]
	movsxd	rax, r15d
	cmp	r14d, 4
	jl	$LC833@HandleAndD
	lea	rdx, QWORD PTR [rax*8]
	mov	r8, rsi
	lea	eax, DWORD PTR [r14-4]
	mov	r11d, 12
	shr	eax, 2
	lea	rcx, QWORD PTR [rdi+12]
	sub	r8, rdi
	sub	r11, rdi
	inc	eax
	mov	r10d, eax
	lea	r12d, DWORD PTR [rax*4]
$LL838@HandleAndD:

; 1002 :         {
; 1003 :             const ImVec2& p0 = points[i0];
; 1004 :             const ImVec2& p1 = points[i1];
; 1005 :             float dx = p1.x - p0.x;

	movss	xmm2, DWORD PTR [rcx-12]

; 1006 :             float dy = p1.y - p0.y;

	movss	xmm3, DWORD PTR [rcx-8]
	subss	xmm2, DWORD PTR [rdx+rdi]
	subss	xmm3, DWORD PTR [rdx+rdi+4]

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm13
	jbe	SHORT $LN834@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN834@HandleAndD:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rdx+rsi], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm14
	movss	DWORD PTR [rdx+rsi+4], xmm2
	movss	xmm2, DWORD PTR [rcx-4]
	movss	xmm3, DWORD PTR [rcx]
	subss	xmm2, DWORD PTR [rcx-12]
	subss	xmm3, DWORD PTR [rcx-8]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm13
	jbe	SHORT $LN835@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN835@HandleAndD:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [r8+rcx-12], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm14
	movss	DWORD PTR [r8+rcx-8], xmm2
	movss	xmm2, DWORD PTR [rcx+4]
	movss	xmm3, DWORD PTR [rcx+8]
	subss	xmm2, DWORD PTR [rcx-4]
	subss	xmm3, DWORD PTR [rcx]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm13
	jbe	SHORT $LN836@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN836@HandleAndD:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [r8+rcx-4], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm14
	movss	DWORD PTR [r8+rcx], xmm2
	movss	xmm2, DWORD PTR [rcx+12]
	movss	xmm3, DWORD PTR [rcx+16]
	subss	xmm2, DWORD PTR [rcx+4]
	subss	xmm3, DWORD PTR [rcx+8]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm13
	jbe	SHORT $LN837@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN837@HandleAndD:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [r8+rcx+4], xmm3
	lea	rax, QWORD PTR [r9+3]

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm14
	lea	rdx, QWORD PTR [r11+rcx]
	movss	DWORD PTR [r8+rcx+8], xmm2
	add	r9, 4
	add	rcx, 32					; 00000020H
	sub	r10, 1
	jne	$LL838@HandleAndD

; 1001 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	cmp	r12d, r14d
	jge	SHORT $LN1183@HandleAndD
$LC833@HandleAndD:
	mov	r8d, r14d
	lea	rcx, QWORD PTR [rax*8]
	sub	r8d, r12d
	lea	rdx, QWORD PTR [rdi+r9*8]
$LC924@HandleAndD:

; 1002 :         {
; 1003 :             const ImVec2& p0 = points[i0];
; 1004 :             const ImVec2& p1 = points[i1];
; 1005 :             float dx = p1.x - p0.x;

	movss	xmm2, DWORD PTR [rdx]

; 1006 :             float dy = p1.y - p0.y;

	movss	xmm3, DWORD PTR [rdx+4]
	subss	xmm2, DWORD PTR [rcx+rdi]
	subss	xmm3, DWORD PTR [rcx+rdi+4]

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm13
	jbe	SHORT $LN330@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN330@HandleAndD:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rcx+rsi], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm14
	movss	DWORD PTR [rcx+rsi+4], xmm2
	mov	rcx, rdx
	sub	rcx, rdi
	add	rdx, 8
	sub	r8, 1
	jne	SHORT $LC924@HandleAndD
$LN1183@HandleAndD:
	mov	r12d, DWORD PTR vtx_outer_idx$1$[rsp]

; 1010 :         }
; 1011 : 
; 1012 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	lea	r9, QWORD PTR [rdi+4]
	xor	r10d, r10d
	mulss	xmm8, xmm15
	mov	r11, rsi
	sub	r11, rdi
	mov	edi, DWORD PTR col_trans$1$[rsp]
	npad	11
$LL319@HandleAndD:

; 1013 :         {
; 1014 :             // Average normals
; 1015 :             const ImVec2& n0 = temp_normals[i0];
; 1016 :             const ImVec2& n1 = temp_normals[i1];
; 1017 :             float dm_x = (n0.x + n1.x) * 0.5f;

	movss	xmm2, DWORD PTR [r9+r11-4]

; 1018 :             float dm_y = (n0.y + n1.y) * 0.5f;

	movss	xmm3, DWORD PTR [r9+r11]
	movsxd	rax, r15d
	addss	xmm2, DWORD PTR [rsi+rax*8]
	addss	xmm3, DWORD PTR [rsi+rax*8+4]
	mulss	xmm2, xmm15
	mulss	xmm3, xmm15

; 1019 :             IM_FIXNORMAL2F(dm_x, dm_y);

	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm9
	jbe	SHORT $LN331@HandleAndD
	movaps	xmm0, xmm12
	divss	xmm0, xmm1
	movaps	xmm1, xmm11
	minss	xmm1, xmm0
	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN331@HandleAndD:

; 1020 :             dm_x *= AA_SIZE * 0.5f;
; 1021 :             dm_y *= AA_SIZE * 0.5f;
; 1022 : 
; 1023 :             // Add vertices
; 1024 :             _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner

	movss	xmm0, DWORD PTR [r9-4]

; 1025 :             _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
; 1026 :             _VtxWritePtr += 2;
; 1027 : 
; 1028 :             // Add indexes for fringes
; 1029 :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));

	movzx	edx, r10w
	mov	rax, QWORD PTR [rbx+72]
	add	r15w, r15w
	mov	ecx, DWORD PTR bigAnchorColor$1$[rsp]
	add	dx, dx
	mulss	xmm2, xmm8
	mulss	xmm3, xmm8
	lea	r8d, DWORD PTR [rdx+r13]
	subss	xmm0, xmm2
	movss	DWORD PTR [rax], xmm0
	movss	xmm1, DWORD PTR [r9]
	mov	rax, QWORD PTR [rbx+72]
	subss	xmm1, xmm3
	movss	DWORD PTR [rax+4], xmm1
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], ecx
	lea	ecx, DWORD PTR [r15+r13]
	addss	xmm2, DWORD PTR [r9-4]
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+20], xmm2
	addss	xmm3, DWORD PTR [r9]
	mov	rax, QWORD PTR [rbx+72]
	add	r9, 8
	movss	DWORD PTR [rax+24], xmm3
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+28], xmm6
	movss	DWORD PTR [rax+32], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+36], edi
	mov	rax, QWORD PTR [rbx+80]
	add	QWORD PTR [rbx+72], 40			; 00000028H
	mov	WORD PTR [rax], r8w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+2], cx
	lea	ecx, DWORD PTR [r15+r12]
	mov	rax, QWORD PTR [rbx+80]
	mov	r15d, r10d
	inc	r10d
	mov	WORD PTR [rax+4], cx

; 1030 :             _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));

	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+6], cx
	lea	ecx, DWORD PTR [rdx+r12]
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+8], cx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+10], r8w

; 1031 :             _IdxWritePtr += 6;

	add	QWORD PTR [rbx+80], 12
	cmp	r10d, r14d
	jl	$LL319@HandleAndD

; 1032 :         }
; 1033 :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, WORD PTR vtx_count$1$[rbp-256]

; 1034 :     }

	mov	r15d, -16777216				; ff000000H
	add	DWORD PTR [rbx+52], eax
	xor	r12d, r12d
	jmp	$LN327@HandleAndD
$LN328@HandleAndD:

; 1035 :     else
; 1036 :     {
; 1037 :         // Non Anti-aliased Fill
; 1038 :         const int idx_count = (points_count - 2)*3;

	lea	eax, DWORD PTR [r14-2]

; 1039 :         const int vtx_count = points_count;
; 1040 :         PrimReserve(idx_count, vtx_count);

	mov	r8d, r14d
	lea	edx, DWORD PTR [rax+rax*2]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve
	mov	rcx, r14
	npad	2
$LL322@HandleAndD:

; 1041 :         for (int i = 0; i < vtx_count; i++)
; 1042 :         {
; 1043 :             _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	mov	rax, QWORD PTR [rbx+72]
	movsd	xmm0, QWORD PTR [rdi]
	lea	rdi, QWORD PTR [rdi+8]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], esi

; 1044 :             _VtxWritePtr++;

	add	QWORD PTR [rbx+72], 20
	sub	rcx, 1
	jne	SHORT $LL322@HandleAndD
	mov	edx, 2
	npad	11
$LL325@HandleAndD:

; 1045 :         }
; 1046 :         for (int i = 2; i < points_count; i++)
; 1047 :         {
; 1048 :             _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);

	mov	rcx, QWORD PTR [rbx+80]
	movzx	eax, WORD PTR [rbx+52]
	mov	WORD PTR [rcx], ax
	lea	ecx, DWORD PTR [rdx-1]
	add	cx, WORD PTR [rbx+52]
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+2], cx
	movzx	ecx, dx
	mov	rax, QWORD PTR [rbx+80]
	inc	edx
	add	cx, WORD PTR [rbx+52]
	mov	WORD PTR [rax+4], cx

; 1049 :             _IdxWritePtr += 3;

	add	QWORD PTR [rbx+80], 6
	cmp	edx, r14d
	jl	SHORT $LL325@HandleAndD

; 1050 :         }
; 1051 :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, r14w
	add	DWORD PTR [rbx+52], eax
$LN327@HandleAndD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	DWORD PTR [rbx+120], r12d
$LN300@HandleAndD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1514 :         _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	movss	xmm2, DWORD PTR __real@40c00000
	lea	rdx, QWORD PTR midBound$15[rbp-256]
	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], 48			; 00000030H
	mov	rcx, rbx
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx

; 1515 :         _Path.Size--;

	dec	DWORD PTR [rbx+120]
	mov	r14d, DWORD PTR [rbx+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	rdi, QWORD PTR [rbx+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 975  :     if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)

	cmp	r14d, 3
	jl	$LN390@HandleAndD

; 976  :         return;
; 977  : 
; 978  :     const ImVec2 uv = _Data->TexUvWhitePixel;
; 979  : 
; 980  :     if (Flags & ImDrawListFlags_AntiAliasedFill)

	test	BYTE PTR [rbx+48], 4
	mov	rcx, rbx
	mov	rax, QWORD PTR [rbx+56]
	movss	xmm6, DWORD PTR [rax]
	movss	xmm7, DWORD PTR [rax+4]
	je	$LN391@HandleAndD

; 981  :     {
; 982  :         // Anti-aliased Fill
; 983  :         const float AA_SIZE = _FringeScale;

	movss	xmm8, DWORD PTR [rbx+192]

; 986  :         const int vtx_count = (points_count * 2);

	lea	eax, DWORD PTR [r14+r14]
	lea	edx, DWORD PTR [r14*8-6]
	mov	DWORD PTR vtx_count$1$[rsp], eax
	add	edx, r14d

; 987  :         PrimReserve(idx_count, vtx_count);

	mov	r8d, eax
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 988  : 
; 989  :         // Add indexes for fill
; 990  :         unsigned int vtx_inner_idx = _VtxCurrentIdx;

	mov	r13d, DWORD PTR [rbx+52]
	mov	r8d, 2

; 991  :         unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;

	lea	eax, DWORD PTR [r13+1]
	mov	DWORD PTR vtx_outer_idx$1$[rsp], eax
	npad	9
$LL376@HandleAndD:

; 992  :         for (int i = 2; i < points_count; i++)
; 993  :         {
; 994  :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));

	mov	rax, QWORD PTR [rbx+80]
	movzx	edx, r8w
	add	dx, dx
	inc	r8d
	add	dx, r13w
	mov	WORD PTR [rax], r13w
	mov	rax, QWORD PTR [rbx+80]
	lea	ecx, DWORD PTR [rdx-2]
	mov	WORD PTR [rax+2], cx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+4], dx

; 995  :             _IdxWritePtr += 3;

	add	QWORD PTR [rbx+80], 6
	cmp	r8d, r14d
	jl	SHORT $LL376@HandleAndD

; 996  :         }
; 997  : 
; 998  :         // Compute normals
; 999  :         _Data->TempBuffer.reserve_discard(points_count);

	mov	rsi, QWORD PTR [rbx+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	cmp	r14d, DWORD PTR [rsi+52]
	jle	SHORT $LN397@HandleAndD
	mov	rcx, QWORD PTR [rsi+56]
	test	rcx, rcx
	je	SHORT $LN405@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN403@HandleAndD

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN403@HandleAndD:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN405@HandleAndD:

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN410@HandleAndD

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN410@HandleAndD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	movsxd	rcx, r14d
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	mov	QWORD PTR [rsi+56], rax
	mov	DWORD PTR [rsi+52], r14d
$LN397@HandleAndD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1000 :         ImVec2* temp_normals = _Data->TempBuffer.Data;

	mov	rax, QWORD PTR [rbx+56]

; 1001 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	lea	r15d, DWORD PTR [r14-1]
	xor	r9d, r9d
	mov	rsi, QWORD PTR [rax+56]
	movsxd	rax, r15d
	cmp	r14d, 4
	jl	$LC840@HandleAndD
	lea	rdx, QWORD PTR [rax*8]
	mov	r8, rsi
	lea	eax, DWORD PTR [r14-4]
	mov	r11d, 12
	shr	eax, 2
	lea	rcx, QWORD PTR [rdi+12]
	sub	r8, rdi
	sub	r11, rdi
	inc	eax
	mov	r10d, eax
	lea	r12d, DWORD PTR [rax*4]
$LL845@HandleAndD:

; 1002 :         {
; 1003 :             const ImVec2& p0 = points[i0];
; 1004 :             const ImVec2& p1 = points[i1];
; 1005 :             float dx = p1.x - p0.x;

	movss	xmm2, DWORD PTR [rcx-12]

; 1006 :             float dy = p1.y - p0.y;

	movss	xmm3, DWORD PTR [rcx-8]
	subss	xmm2, DWORD PTR [rdx+rdi]
	subss	xmm3, DWORD PTR [rdx+rdi+4]

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm13
	jbe	SHORT $LN841@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN841@HandleAndD:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rdx+rsi], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm14
	movss	DWORD PTR [rdx+rsi+4], xmm2
	movss	xmm2, DWORD PTR [rcx-4]
	movss	xmm3, DWORD PTR [rcx]
	subss	xmm2, DWORD PTR [rcx-12]
	subss	xmm3, DWORD PTR [rcx-8]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm13
	jbe	SHORT $LN842@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN842@HandleAndD:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [r8+rcx-12], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm14
	movss	DWORD PTR [r8+rcx-8], xmm2
	movss	xmm2, DWORD PTR [rcx+4]
	movss	xmm3, DWORD PTR [rcx+8]
	subss	xmm2, DWORD PTR [rcx-4]
	subss	xmm3, DWORD PTR [rcx]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm13
	jbe	SHORT $LN843@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN843@HandleAndD:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [r8+rcx-4], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm14
	movss	DWORD PTR [rcx+r8], xmm2
	movss	xmm2, DWORD PTR [rcx+12]
	movss	xmm3, DWORD PTR [rcx+16]
	subss	xmm2, DWORD PTR [rcx+4]
	subss	xmm3, DWORD PTR [rcx+8]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm13
	jbe	SHORT $LN844@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN844@HandleAndD:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [r8+rcx+4], xmm3
	lea	rax, QWORD PTR [r9+3]

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm14
	lea	rdx, QWORD PTR [r11+rcx]
	movss	DWORD PTR [r8+rcx+8], xmm2
	add	r9, 4
	add	rcx, 32					; 00000020H
	sub	r10, 1
	jne	$LL845@HandleAndD

; 1001 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	cmp	r12d, r14d
	jge	SHORT $LN1184@HandleAndD
$LC840@HandleAndD:
	mov	r8d, r14d
	lea	rcx, QWORD PTR [rax*8]
	sub	r8d, r12d
	lea	rdx, QWORD PTR [rdi+r9*8]
$LC930@HandleAndD:

; 1002 :         {
; 1003 :             const ImVec2& p0 = points[i0];
; 1004 :             const ImVec2& p1 = points[i1];
; 1005 :             float dx = p1.x - p0.x;

	movss	xmm2, DWORD PTR [rdx]

; 1006 :             float dy = p1.y - p0.y;

	movss	xmm3, DWORD PTR [rdx+4]
	subss	xmm2, DWORD PTR [rdi+rcx]
	subss	xmm3, DWORD PTR [rdi+rcx+4]

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm13
	jbe	SHORT $LN393@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN393@HandleAndD:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rsi+rcx], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm14
	movss	DWORD PTR [rsi+rcx+4], xmm2
	mov	rcx, rdx
	sub	rcx, rdi
	add	rdx, 8
	sub	r8, 1
	jne	SHORT $LC930@HandleAndD
$LN1184@HandleAndD:

; 1010 :         }
; 1011 : 
; 1012 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	xor	r12d, r12d
	mulss	xmm8, xmm15
	mov	r11, rsi
	lea	r9, QWORD PTR [rdi+4]
	mov	r10d, r12d
	sub	r11, rdi
	npad	1
$LL382@HandleAndD:

; 1013 :         {
; 1014 :             // Average normals
; 1015 :             const ImVec2& n0 = temp_normals[i0];
; 1016 :             const ImVec2& n1 = temp_normals[i1];
; 1017 :             float dm_x = (n0.x + n1.x) * 0.5f;

	movss	xmm2, DWORD PTR [r11+r9-4]

; 1018 :             float dm_y = (n0.y + n1.y) * 0.5f;

	movss	xmm3, DWORD PTR [r11+r9]
	movsxd	rax, r15d
	addss	xmm2, DWORD PTR [rsi+rax*8]
	addss	xmm3, DWORD PTR [rsi+rax*8+4]
	mulss	xmm2, xmm15
	mulss	xmm3, xmm15

; 1019 :             IM_FIXNORMAL2F(dm_x, dm_y);

	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm9
	jbe	SHORT $LN394@HandleAndD
	movaps	xmm0, xmm12
	divss	xmm0, xmm1
	movaps	xmm1, xmm11
	minss	xmm1, xmm0
	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN394@HandleAndD:

; 1020 :             dm_x *= AA_SIZE * 0.5f;
; 1021 :             dm_y *= AA_SIZE * 0.5f;
; 1022 : 
; 1023 :             // Add vertices
; 1024 :             _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner

	movss	xmm0, DWORD PTR [r9-4]

; 1025 :             _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
; 1026 :             _VtxWritePtr += 2;
; 1027 : 
; 1028 :             // Add indexes for fringes
; 1029 :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));

	add	r15w, r15w
	mov	rax, QWORD PTR [rbx+72]
	movzx	r8d, r10w
	mulss	xmm2, xmm8
	add	r8w, r8w
	lea	ecx, DWORD PTR [r15+r13]
	mulss	xmm3, xmm8
	subss	xmm0, xmm2
	lea	edx, DWORD PTR [r8+r13]
	movss	DWORD PTR [rax], xmm0
	movss	xmm1, DWORD PTR [r9]
	mov	rax, QWORD PTR [rbx+72]
	subss	xmm1, xmm3
	movss	DWORD PTR [rax+4], xmm1
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], -16777216		; ff000000H
	addss	xmm2, DWORD PTR [r9-4]
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+20], xmm2
	addss	xmm3, DWORD PTR [r9]
	mov	rax, QWORD PTR [rbx+72]
	add	r9, 8
	movss	DWORD PTR [rax+24], xmm3
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+28], xmm6
	movss	DWORD PTR [rax+32], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+36], r12d
	mov	rax, QWORD PTR [rbx+80]
	add	QWORD PTR [rbx+72], 40			; 00000028H
	mov	WORD PTR [rax], dx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+2], cx
	mov	rax, QWORD PTR [rbx+80]
	mov	ecx, DWORD PTR vtx_outer_idx$1$[rsp]
	add	r15w, cx

; 1030 :             _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));

	add	r8w, cx
	mov	WORD PTR [rax+4], r15w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+6], r15w
	mov	r15d, r10d
	mov	rax, QWORD PTR [rbx+80]
	inc	r10d
	mov	WORD PTR [rax+8], r8w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+10], dx

; 1031 :             _IdxWritePtr += 6;

	add	QWORD PTR [rbx+80], 12
	cmp	r10d, r14d
	jl	$LL382@HandleAndD

; 1032 :         }
; 1033 :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, WORD PTR vtx_count$1$[rsp]

; 1034 :     }

	jmp	$LN1185@HandleAndD
$LN391@HandleAndD:

; 1035 :     else
; 1036 :     {
; 1037 :         // Non Anti-aliased Fill
; 1038 :         const int idx_count = (points_count - 2)*3;

	lea	eax, DWORD PTR [r14-2]

; 1039 :         const int vtx_count = points_count;
; 1040 :         PrimReserve(idx_count, vtx_count);

	mov	r8d, r14d
	lea	edx, DWORD PTR [rax+rax*2]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve
	mov	rcx, r14
	npad	6
$LL385@HandleAndD:

; 1041 :         for (int i = 0; i < vtx_count; i++)
; 1042 :         {
; 1043 :             _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	mov	rax, QWORD PTR [rbx+72]
	movsd	xmm0, QWORD PTR [rdi]
	lea	rdi, QWORD PTR [rdi+8]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r15d

; 1044 :             _VtxWritePtr++;

	add	QWORD PTR [rbx+72], 20
	sub	rcx, 1
	jne	SHORT $LL385@HandleAndD
	mov	edx, 2
	npad	10
$LL388@HandleAndD:

; 1045 :         }
; 1046 :         for (int i = 2; i < points_count; i++)
; 1047 :         {
; 1048 :             _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);

	mov	rcx, QWORD PTR [rbx+80]
	movzx	eax, WORD PTR [rbx+52]
	mov	WORD PTR [rcx], ax
	lea	ecx, DWORD PTR [rdx-1]
	add	cx, WORD PTR [rbx+52]
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+2], cx
	movzx	ecx, dx
	mov	rax, QWORD PTR [rbx+80]
	inc	edx
	add	cx, WORD PTR [rbx+52]
	mov	WORD PTR [rax+4], cx

; 1049 :             _IdxWritePtr += 3;

	add	QWORD PTR [rbx+80], 6
	cmp	edx, r14d
	jl	SHORT $LL388@HandleAndD

; 1050 :         }
; 1051 :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, r14w
$LN1185@HandleAndD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	add	DWORD PTR [rbx+52], eax
$LN390@HandleAndD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	mov	edi, DWORD PTR smallAnchorColor$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	DWORD PTR [rbx+120], r12d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	test	edi, -16777216				; ff000000H
	je	SHORT $LN179@HandleAndD

; 1514 :         _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	movss	xmm2, DWORD PTR __real@4099999a
	lea	rdx, QWORD PTR midBound$15[rbp-256]
	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], 48			; 00000030H
	mov	rcx, rbx
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx

; 1515 :         _Path.Size--;

	dec	DWORD PTR [rbx+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r9d, edi
	mov	r8d, DWORD PTR [rbx+120]
	mov	rcx, rbx
	mov	rdx, QWORD PTR [rbx+128]
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	DWORD PTR [rbx+120], r12d
$LN179@HandleAndD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1768 :             int oppositeIndex = (i + 2) % 4;

	mov	r14d, DWORD PTR i$1$[rsp]
	lea	r11d, DWORD PTR [r14+2]
	and	r11d, -2147483645			; ffffffff80000003H
	jge	SHORT $LN1008@HandleAndD
	dec	r11d
	or	r11d, -4
	inc	r11d
$LN1008@HandleAndD:

; 1769 :             // big anchor on corners
; 1770 :             if (!gContext.mbUsingBounds && gContext.mbEnable && overBigAnchor && CanActivate())

	movzx	esi, BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1332
	test	sil, sil
	jne	$LN1031@HandleAndD
	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1085, sil
	je	$LN1031@HandleAndD
	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	cmp	BYTE PTR tv14278[rsp], sil
	je	$LN938@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8912 :     return IsMouseClicked(button, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	?IsMouseClicked@ImGui@@YA_NHIH@Z	; ImGui::IsMouseClicked
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1614 :       if (ImGui::IsMouseClicked(0) && !ImGui::IsAnyItemHovered() && !ImGui::IsAnyItemActive())

	test	al, al
	je	$LN938@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5568 :     return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;

	cmp	DWORD PTR [rdi+16484], 0
	jne	$LN938@HandleAndD
	cmp	DWORD PTR [rdi+16488], 0
	jne	$LN938@HandleAndD

; 5574 :     return g.ActiveId != 0;

	cmp	DWORD PTR [rdi+16504], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1614 :       if (ImGui::IsMouseClicked(0) && !ImGui::IsAnyItemHovered() && !ImGui::IsAnyItemActive())

	jne	$LN938@HandleAndD

; 1771 :             {
; 1772 :                gContext.mBoundsPivot.TransformPoint(aabb[(i + 2) % 4], gContext.mModelSource);

	movsxd	rdi, r11d

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+604

; 1771 :             {
; 1772 :                gContext.mBoundsPivot.TransformPoint(aabb[(i + 2) % 4], gContext.mModelSource);

	mov	rax, rdi

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+1256

; 1771 :             {
; 1772 :                gContext.mBoundsPivot.TransformPoint(aabb[(i + 2) % 4], gContext.mModelSource);

	add	rax, rax

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movups	xmm0, XMMWORD PTR aabb$33[rbp+rax*8-256]
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1256, xmm0
	call	?TransformPoint@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z ; ImGuizmo::vec_t::TransformPoint
	mov	rax, QWORD PTR tv13201[rbp-256]
	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+604
	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+1272
	movups	xmm0, XMMWORD PTR aabb$33[rbp+rax-256]
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1272, xmm0
	call	?TransformPoint@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z ; ImGuizmo::vec_t::TransformPoint

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm10, DWORD PTR bestAxisWorldDirection$[rbp-252]

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm8, DWORD PTR bestAxisWorldDirection$[rbp-256]

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movaps	xmm2, xmm10

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm7, DWORD PTR bestAxisWorldDirection$[rbp-248]
	movaps	xmm0, xmm8

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	mulss	xmm2, xmm10

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm7
	mulss	xmm0, xmm8
	mulss	xmm1, xmm7
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN1006@HandleAndD
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN1007@HandleAndD
$LN1006@HandleAndD:
	movaps	xmm0, xmm2
	call	sqrtf
$LN1007@HandleAndD:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000

; 1775 :                gContext.mBoundsBestAxis = bestAxis;

	mov	eax, DWORD PTR bestAxis$2$[rbp-256]

; 1778 : 
; 1779 :                gContext.mBoundsLocalPivot.Set(0.f);
; 1780 :                gContext.mBoundsLocalPivot[secondAxis] = aabb[oppositeIndex][secondAxis];

	lea	r15, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A

; 267  :       float& operator [] (size_t index) { return ((float*)&x)[index]; }

	mov	rcx, QWORD PTR $T23[rbp-256]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movaps	xmm6, xmm12

; 1775 :                gContext.mBoundsBestAxis = bestAxis;

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1320, eax

; 1776 :                gContext.mBoundsAxis[0] = secondAxis;

	mov	eax, DWORD PTR secondAxis$1$[rsp]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm6, xmm0

; 1776 :                gContext.mBoundsAxis[0] = secondAxis;

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1324, eax

; 1777 :                gContext.mBoundsAxis[1] = thirdAxis;

	mov	eax, DWORD PTR thirdAxis$1$[rsp]
	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1328, eax

; 267  :       float& operator [] (size_t index) { return ((float*)&x)[index]; }

	lea	rax, QWORD PTR [rcx+rdi*4]

; 1778 : 
; 1779 :                gContext.mBoundsLocalPivot.Set(0.f);
; 1780 :                gContext.mBoundsLocalPivot[secondAxis] = aabb[oppositeIndex][secondAxis];

	mov	eax, DWORD PTR aabb$33[rbp+rax*4-256]

; 207  :       void Set(float v) { x = y = z = w = v; }

	mov	QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1312, 0
	mov	QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1304, 0

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movaps	xmm5, xmm6

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm4, xmm6
	movaps	xmm3, xmm6

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mulss	xmm5, xmm8

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm6, DWORD PTR bestAxisWorldDirection$[rbp-244]
	mulss	xmm4, xmm10

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1272
	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1284

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm2, xmm4
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1276
	mulss	xmm3, xmm7

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	addss	xmm2, xmm0

; 1773 :                gContext.mBoundsAnchor.TransformPoint(aabb[i], gContext.mModelSource);
; 1774 :                gContext.mBoundsPlan = BuildPlan(gContext.mBoundsAnchor, bestAxisWorldDirection);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1288, xmm5
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1292, xmm4

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm1, xmm3

; 1773 :                gContext.mBoundsAnchor.TransformPoint(aabb[i], gContext.mModelSource);
; 1774 :                gContext.mBoundsPlan = BuildPlan(gContext.mBoundsAnchor, bestAxisWorldDirection);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1296, xmm3

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1280
	addss	xmm2, xmm1
	addss	xmm2, xmm6

; 1773 :                gContext.mBoundsAnchor.TransformPoint(aabb[i], gContext.mModelSource);
; 1774 :                gContext.mBoundsPlan = BuildPlan(gContext.mBoundsAnchor, bestAxisWorldDirection);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1300, xmm2

; 1778 : 
; 1779 :                gContext.mBoundsLocalPivot.Set(0.f);
; 1780 :                gContext.mBoundsLocalPivot[secondAxis] = aabb[oppositeIndex][secondAxis];

	mov	DWORD PTR [r15+rcx*4+1304], eax

; 267  :       float& operator [] (size_t index) { return ((float*)&x)[index]; }

	mov	rcx, QWORD PTR $T22[rbp-256]
	lea	rax, QWORD PTR [rcx+rdi*4]
$LN1188@HandleAndD:

; 1706 : 
; 1707 :          matrix_t boundsMVP = gContext.mModelSource * gContext.mViewProjection;
; 1708 :          for (int i = 0; i < 4; i++)

	mov	eax, DWORD PTR aabb$33[rbp+rax*4-256]
	mov	sil, 1
	mov	r13d, DWORD PTR operation$1$[rsp]
	mov	r9d, DWORD PTR anchorAlpha$1$[rsp]
	mov	DWORD PTR [r15+rcx*4+1304], eax
	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+604
	mov	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	movups	xmm1, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+620
	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1332, sil
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1336, xmm0
	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440, eax
	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+636
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1352, xmm1
	movups	xmm1, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+652
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1368, xmm0
	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1384, xmm1
	jmp	$LN14@HandleAndD
$LN938@HandleAndD:

; 1781 :                gContext.mBoundsLocalPivot[thirdAxis] = aabb[oppositeIndex][thirdAxis];
; 1782 : 
; 1783 :                gContext.mbUsingBounds = true;
; 1784 :                gContext.mEditingID = gContext.mActualID;
; 1785 :                gContext.mBoundsMatrix = gContext.mModelSource;
; 1786 :             }
; 1787 :             // small anchor on middle of segment
; 1788 :             if (!gContext.mbUsingBounds && gContext.mbEnable && overSmallAnchor && CanActivate())

	cmp	BYTE PTR tv14274[rbp-256], 0
	je	$LN1031@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8912 :     return IsMouseClicked(button, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	?IsMouseClicked@ImGui@@YA_NHIH@Z	; ImGui::IsMouseClicked
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1614 :       if (ImGui::IsMouseClicked(0) && !ImGui::IsAnyItemHovered() && !ImGui::IsAnyItemActive())

	test	al, al
	je	$LN1031@HandleAndD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5568 :     return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;

	cmp	DWORD PTR [rdi+16484], 0
	jne	$LN1031@HandleAndD
	cmp	DWORD PTR [rdi+16488], 0
	jne	$LN1031@HandleAndD

; 5574 :     return g.ActiveId != 0;

	cmp	DWORD PTR [rdi+16504], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1614 :       if (ImGui::IsMouseClicked(0) && !ImGui::IsAnyItemHovered() && !ImGui::IsAnyItemActive())

	jne	$LN1031@HandleAndD

; 1789 :             {
; 1790 :                vec_t midPointOpposite = (aabb[(i + 2) % 4] + aabb[(i + 3) % 4]) * 0.5f;

	movsxd	rdi, r11d
	lea	eax, DWORD PTR [r14+3]
	mov	rcx, rdi
	add	rcx, rcx
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN1005@HandleAndD
	dec	eax
	or	eax, -4
	inc	eax
$LN1005@HandleAndD:
	cdqe

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+604

; 1789 :             {
; 1790 :                vec_t midPointOpposite = (aabb[(i + 2) % 4] + aabb[(i + 3) % 4]) * 0.5f;

	add	rax, rax

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	movss	xmm3, DWORD PTR aabb$33[rbp+rax*8-256]
	addss	xmm3, DWORD PTR aabb$33[rbp+rcx*8-256]
	movss	xmm2, DWORD PTR aabb$33[rbp+rax*8-252]
	addss	xmm2, DWORD PTR aabb$33[rbp+rcx*8-252]
	movss	xmm1, DWORD PTR aabb$33[rbp+rax*8-248]
	addss	xmm1, DWORD PTR aabb$33[rbp+rcx*8-248]
	movss	xmm0, DWORD PTR aabb$33[rbp+rax*8-244]
	addss	xmm0, DWORD PTR aabb$33[rbp+rcx*8-244]
	mulss	xmm3, xmm15

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+1256

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm2, xmm15
	mulss	xmm1, xmm15
	mulss	xmm0, xmm15

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1256, xmm3
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1260, xmm2
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1264, xmm1
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1268, xmm0
	call	?TransformPoint@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z ; ImGuizmo::vec_t::TransformPoint
	movss	xmm0, DWORD PTR midPoint$2$sroa$7130$1$[rbp-256]
	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+604
	movss	xmm1, DWORD PTR midPoint$2$sroa$7131$1$[rbp-256]
	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+1272
	movss	xmm2, DWORD PTR midPoint$2$sroa$7132$1$[rbp-256]
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1276, xmm0
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1280, xmm1
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1284, xmm2
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1272, xmm10
	call	?TransformPoint@vec_t@ImGuizmo@@QEAAXAEBUmatrix_t@2@@Z ; ImGuizmo::vec_t::TransformPoint

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm10, DWORD PTR bestAxisWorldDirection$[rbp-252]

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm8, DWORD PTR bestAxisWorldDirection$[rbp-256]

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movaps	xmm2, xmm10

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm7, DWORD PTR bestAxisWorldDirection$[rbp-248]
	movaps	xmm0, xmm8

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	mulss	xmm2, xmm10

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm7
	mulss	xmm0, xmm8
	mulss	xmm1, xmm7
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN1003@HandleAndD
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN1004@HandleAndD
$LN1003@HandleAndD:
	movaps	xmm0, xmm2
	call	sqrtf
$LN1004@HandleAndD:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000

; 1794 :                gContext.mBoundsBestAxis = bestAxis;

	mov	eax, DWORD PTR bestAxis$2$[rbp-256]

; 1798 : 
; 1799 :                gContext.mBoundsLocalPivot.Set(0.f);
; 1800 :                gContext.mBoundsLocalPivot[gContext.mBoundsAxis[0]] = aabb[oppositeIndex][indices[i % 2]];// bounds[gContext.mBoundsAxis[0]] * (((i + 1) & 2) ? 1.f : -1.f);

	lea	r15, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A
	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1320, eax

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movaps	xmm6, xmm12

; 1795 :                int indices[] = { secondAxis , thirdAxis };

	mov	eax, DWORD PTR secondAxis$1$[rsp]
	mov	DWORD PTR indices$17[rbp-256], eax
	mov	eax, DWORD PTR thirdAxis$1$[rsp]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm6, xmm0

; 1795 :                int indices[] = { secondAxis , thirdAxis };

	mov	DWORD PTR indices$17[rbp-252], eax

; 1796 :                gContext.mBoundsAxis[0] = indices[i % 2];

	mov	rax, QWORD PTR tv13519[rbp-256]
	and	eax, 1

; 1797 :                gContext.mBoundsAxis[1] = -1;

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1328, -1

; 207  :       void Set(float v) { x = y = z = w = v; }

	mov	QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1312, 0
	mov	QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1304, 0

; 1796 :                gContext.mBoundsAxis[0] = indices[i % 2];

	movsxd	rax, DWORD PTR indices$17[rbp+rax*4-256]
	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1324, eax

; 1798 : 
; 1799 :                gContext.mBoundsLocalPivot.Set(0.f);
; 1800 :                gContext.mBoundsLocalPivot[gContext.mBoundsAxis[0]] = aabb[oppositeIndex][indices[i % 2]];// bounds[gContext.mBoundsAxis[0]] * (((i + 1) & 2) ? 1.f : -1.f);

	mov	rcx, rax

; 267  :       float& operator [] (size_t index) { return ((float*)&x)[index]; }

	lea	rax, QWORD PTR [rax+rdi*4]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movaps	xmm5, xmm6

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm4, xmm6
	movaps	xmm3, xmm6

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mulss	xmm5, xmm8

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm6, DWORD PTR bestAxisWorldDirection$[rbp-244]
	mulss	xmm4, xmm10

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1272
	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1284

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm2, xmm4
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1276
	mulss	xmm3, xmm7

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	addss	xmm2, xmm0

; 1791 :                gContext.mBoundsPivot.TransformPoint(midPointOpposite, gContext.mModelSource);
; 1792 :                gContext.mBoundsAnchor.TransformPoint(midPoint, gContext.mModelSource);
; 1793 :                gContext.mBoundsPlan = BuildPlan(gContext.mBoundsAnchor, bestAxisWorldDirection);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1288, xmm5
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1292, xmm4

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm1, xmm3

; 1791 :                gContext.mBoundsPivot.TransformPoint(midPointOpposite, gContext.mModelSource);
; 1792 :                gContext.mBoundsAnchor.TransformPoint(midPoint, gContext.mModelSource);
; 1793 :                gContext.mBoundsPlan = BuildPlan(gContext.mBoundsAnchor, bestAxisWorldDirection);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1296, xmm3

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1280
	addss	xmm2, xmm1
	addss	xmm2, xmm6

; 1791 :                gContext.mBoundsPivot.TransformPoint(midPointOpposite, gContext.mModelSource);
; 1792 :                gContext.mBoundsAnchor.TransformPoint(midPoint, gContext.mModelSource);
; 1793 :                gContext.mBoundsPlan = BuildPlan(gContext.mBoundsAnchor, bestAxisWorldDirection);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1300, xmm2
	jmp	$LN1188@HandleAndD
$LN1031@HandleAndD:

; 1706 : 
; 1707 :          matrix_t boundsMVP = gContext.mModelSource * gContext.mViewProjection;
; 1708 :          for (int i = 0; i < 4; i++)

	mov	r13d, DWORD PTR operation$1$[rsp]
	lea	r15, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A
	mov	r9d, DWORD PTR anchorAlpha$1$[rsp]
	jmp	SHORT $LN14@HandleAndD
$LN1045@HandleAndD:
	xor	r12d, r12d
$LN14@HandleAndD:
	mov	r14, QWORD PTR $T18[rbp-256]
	mov	eax, DWORD PTR tv13240[rbp-256]
	inc	r14
	movss	xmm7, DWORD PTR boundsMVP$31[rbp-196]
	movss	xmm10, DWORD PTR boundsMVP$31[rbp-212]
	mov	DWORD PTR i$1$[rsp], eax
	mov	QWORD PTR $T18[rbp-256], r14
	cmp	eax, 4
	jl	$LL16@HandleAndD

; 1801 : 
; 1802 :                gContext.mbUsingBounds = true;
; 1803 :                gContext.mEditingID = gContext.mActualID;
; 1804 :                gContext.mBoundsMatrix = gContext.mModelSource;
; 1805 :             }
; 1806 :          }
; 1807 : 
; 1808 :          if (gContext.mbUsingBounds && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID))

	test	sil, sil
	je	$LN1047@HandleAndD
	mov	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	cmp	eax, -1
	je	SHORT $LN39@HandleAndD
	cmp	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440
	jne	$LN1047@HandleAndD
$LN39@HandleAndD:

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movaps	xmm0, XMMWORD PTR __xmm@0000000000000000000000003f800000
	movaps	xmm1, XMMWORD PTR __xmm@00000000000000003f80000000000000

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1020
	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1024
	movaps	xmm2, xmm9
	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1288
	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1292
	movss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1028
	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1296

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm12, DWORD PTR __real@34000000
	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1012
	movss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1004

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movups	XMMWORD PTR scale$30[rbp-256], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
	movups	XMMWORD PTR scale$30[rbp-224], xmm0

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movaps	xmm0, xmm10

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movups	XMMWORD PTR scale$30[rbp-240], xmm1
	movaps	xmm1, XMMWORD PTR __xmm@3f800000000000000000000000000000

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm0, xmm3
	mulss	xmm2, xmm6

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movups	XMMWORD PTR scale$30[rbp-208], xmm1

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movaps	xmm1, xmm11
	mulss	xmm1, xmm4
	addss	xmm2, xmm0
	addss	xmm2, xmm1

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1008
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm0, xmm2
	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	comiss	xmm12, xmm0
	jbe	SHORT $LN555@HandleAndD

; 911  :       {
; 912  :          return -1.0f;

	movss	xmm6, DWORD PTR __real@bf800000
	jmp	SHORT $LN554@HandleAndD
$LN555@HandleAndD:

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm6, xmm7
	mulss	xmm3, xmm1
	mulss	xmm4, xmm5
	addss	xmm6, xmm3
	addss	xmm6, xmm4

; 907  :       const float numer = plan.Dot3(rOrigin) - plan.w;

	subss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1300

; 913  :       }
; 914  : 
; 915  :       return -(numer / denom);

	divss	xmm6, xmm2
	xorps	xmm6, xmm14
$LN554@HandleAndD:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movss	xmm14, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+1324

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1280

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	lea	r13, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+1332

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1264
	movss	xmm15, DWORD PTR __real@3f800000

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movaps	xmm8, xmm6
	mulss	xmm8, xmm9
	movaps	xmm9, xmm6
	mulss	xmm9, xmm10

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1272

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm8, xmm7

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm6, xmm11
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm12, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1276

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm9, xmm1

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1256
	subss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1256
	subss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1260

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm6, xmm5

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1260
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm10, xmm14
	andps	xmm8, xmm14
	andps	xmm11, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1264
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm9, xmm14
	andps	xmm6, xmm14
$LL22@HandleAndD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1824 :                int axisIndex1 = gContext.mBoundsAxis[i];

	movsxd	rax, DWORD PTR [rcx]

; 1825 :                if (axisIndex1 == -1)

	cmp	eax, -1
	je	$LN20@HandleAndD

; 1826 :                {
; 1827 :                   continue;
; 1828 :                }
; 1829 : 
; 1830 :                float ratioAxis = 1.f;
; 1831 :                vec_t axisDir = gContext.mBoundsMatrix.component[axisIndex1].Abs();

	add	rax, rax
	movaps	xmm2, xmm15
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movss	xmm4, DWORD PTR [r15+rax*8+1336]
	movss	xmm7, DWORD PTR [r15+rax*8+1340]
	andps	xmm4, xmm14
	movss	xmm5, DWORD PTR [r15+rax*8+1344]
	andps	xmm7, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm3, xmm7
	movaps	xmm0, xmm4
	mulss	xmm3, xmm11
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm5, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	mulss	xmm0, xmm10
	movaps	xmm1, xmm5
	mulss	xmm1, xmm12
	addss	xmm3, xmm0
	addss	xmm3, xmm1
	addss	xmm3, xmm13

; 1832 : 
; 1833 :                float dtAxis = axisDir.Dot(referenceVector);
; 1834 :                float boundSize = bounds[axisIndex1 + 3] - bounds[axisIndex1];
; 1835 :                if (dtAxis > FLT_EPSILON)

	comiss	xmm3, DWORD PTR __real@34000000
	jbe	SHORT $LN43@HandleAndD

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm2, xmm7
	mulss	xmm4, xmm8
	mulss	xmm2, xmm9
	mulss	xmm5, xmm6
	addss	xmm2, xmm4
	addss	xmm2, xmm5
	addss	xmm2, xmm13

; 1836 :                {
; 1837 :                   ratioAxis = axisDir.Dot(deltaVector) / dtAxis;

	divss	xmm2, xmm3
$LN43@HandleAndD:

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movups	xmm0, XMMWORD PTR scale$30[rbp+rax*8-256]

; 1838 :                }
; 1839 : 
; 1840 :                if (snapValues)
; 1841 :                {
; 1842 :                   float length = boundSize * ratioAxis;
; 1843 :                   ComputeSnap(&length, snapValues[axisIndex1]);
; 1844 :                   if (boundSize > FLT_EPSILON)
; 1845 :                   {
; 1846 :                      ratioAxis = length / boundSize;
; 1847 :                   }
; 1848 :                }
; 1849 :                scale.component[axisIndex1] *= ratioAxis;

	movaps	xmm1, xmm2
	shufps	xmm1, xmm1, 0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulps	xmm1, xmm0
	movups	XMMWORD PTR scale$30[rbp+rax*8-256], xmm1
$LN20@HandleAndD:

; 1809 :          {
; 1810 :             matrix_t scale;
; 1811 :             scale.SetToIdentity();
; 1812 : 
; 1813 :             // compute projected mouse position on plan
; 1814 :             const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mBoundsPlan);
; 1815 :             vec_t newPos = gContext.mRayOrigin + gContext.mRayVector * len;
; 1816 : 
; 1817 :             // compute a reference and delta vectors base on mouse move
; 1818 :             vec_t deltaVector = (newPos - gContext.mBoundsPivot).Abs();
; 1819 :             vec_t referenceVector = (gContext.mBoundsAnchor - gContext.mBoundsPivot).Abs();
; 1820 : 
; 1821 :             // for 1 or 2 axes, compute a ratio that's used for scale and snap it based on resulting length
; 1822 :             for (int i = 0; i < 2; i++)

	add	rcx, 4
	cmp	rcx, r13
	jl	$LL22@HandleAndD

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movaps	xmm0, XMMWORD PTR __xmm@0000000000000000000000003f800000

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	r8, QWORD PTR $T26[rbp-256]

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movaps	xmm1, XMMWORD PTR __xmm@00000000000000003f80000000000000

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	rdx, QWORD PTR scale$30[rbp-256]

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1304

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	rcx, QWORD PTR preScale$32[rbp-256]

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm14, DWORD PTR __xmm@80000000800000008000000080000000

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1308
	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1312

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm15, DWORD PTR __real@3f000000
	mov	r13d, DWORD PTR operation$1$[rsp]
	movups	XMMWORD PTR preScale$32[rbp-256], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
	movups	XMMWORD PTR preScale$32[rbp-240], xmm1

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movaps	xmm1, xmm4

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movups	XMMWORD PTR preScale$32[rbp-224], xmm0

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	xorps	xmm1, xmm14

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR preScale$32[rbp-208], xmm1

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movaps	xmm0, xmm3
	xorps	xmm0, xmm14

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR postScale$34[rbp-208], xmm4

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movaps	xmm1, xmm2

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR preScale$32[rbp-204], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@0000000000000000000000003f800000

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	xorps	xmm1, xmm14

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movups	XMMWORD PTR postScale$34[rbp-256], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
	movss	DWORD PTR preScale$32[rbp-200], xmm1
	movaps	xmm1, XMMWORD PTR __xmm@00000000000000003f80000000000000
	movups	XMMWORD PTR postScale$34[rbp-224], xmm0
	movss	DWORD PTR postScale$34[rbp-204], xmm3
	movss	DWORD PTR postScale$34[rbp-200], xmm2
	mov	DWORD PTR preScale$32[rbp-196], 1065353216 ; 3f800000H
	movups	XMMWORD PTR postScale$34[rbp-240], xmm1
	mov	DWORD PTR postScale$34[rbp-196], 1065353216 ; 3f800000H

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	call	?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z ; ImGuizmo::FPU_MatrixF_x_MatrixF
	lea	r8, QWORD PTR $T27[rbp-256]
	lea	rdx, QWORD PTR postScale$34[rbp-256]
	lea	rcx, QWORD PTR $T26[rbp-256]
	call	?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z ; ImGuizmo::FPU_MatrixF_x_MatrixF
	lea	r8, QWORD PTR res$24[rbp-256]
	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+1336
	lea	rcx, QWORD PTR $T27[rbp-256]
	call	?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z ; ImGuizmo::FPU_MatrixF_x_MatrixF

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm4, xmm15

; 1850 :             }
; 1851 : 
; 1852 :             // transform matrix
; 1853 :             matrix_t preScale, postScale;
; 1854 :             preScale.Translation(-gContext.mBoundsLocalPivot);
; 1855 :             postScale.Translation(gContext.mBoundsLocalPivot);
; 1856 :             matrix_t res = preScale * scale * postScale * gContext.mBoundsMatrix;
; 1857 :             *matrix = res;

	movups	xmm0, XMMWORD PTR res$24[rbp-256]
	movups	xmm1, XMMWORD PTR res$24[rbp-240]

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+888
	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460
	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468
	movss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+876
	mulss	xmm7, xmm6

; 1850 :             }
; 1851 : 
; 1852 :             // transform matrix
; 1853 :             matrix_t preScale, postScale;
; 1854 :             preScale.Translation(-gContext.mBoundsLocalPivot);
; 1855 :             postScale.Translation(gContext.mBoundsLocalPivot);
; 1856 :             matrix_t res = preScale * scale * postScale * gContext.mBoundsMatrix;
; 1857 :             *matrix = res;

	movups	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA, xmm0
	movups	xmm0, XMMWORD PTR res$24[rbp-224]
	movups	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+16, xmm1
	movups	xmm1, XMMWORD PTR res$24[rbp-208]

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm2, xmm6

; 1850 :             }
; 1851 : 
; 1852 :             // transform matrix
; 1853 :             matrix_t preScale, postScale;
; 1854 :             preScale.Translation(-gContext.mBoundsLocalPivot);
; 1855 :             postScale.Translation(gContext.mBoundsLocalPivot);
; 1856 :             matrix_t res = preScale * scale * postScale * gContext.mBoundsMatrix;
; 1857 :             *matrix = res;

	movups	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+32, xmm0

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+872

; 1850 :             }
; 1851 : 
; 1852 :             // transform matrix
; 1853 :             matrix_t preScale, postScale;
; 1854 :             preScale.Translation(-gContext.mBoundsLocalPivot);
; 1855 :             postScale.Translation(gContext.mBoundsLocalPivot);
; 1856 :             matrix_t res = preScale * scale * postScale * gContext.mBoundsMatrix;
; 1857 :             *matrix = res;

	movups	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+48, xmm1

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+904
	mulss	xmm0, xmm5
	mulss	xmm1, xmm3
	addss	xmm2, xmm0

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+860
	mulss	xmm0, xmm5

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm7, xmm0

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];
; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+892
	mulss	xmm1, xmm3
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+920
	addss	xmm7, xmm1

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm4, xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+908

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+880
	mulss	xmm2, xmm6

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm4

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm7, xmm15

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 808  :       trans.y *= size.y;

	addss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+864

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+896

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm12, DWORD PTR __real@3f800000

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	mulss	xmm0, xmm5

; 806  :       trans.y = 1.f - trans.y;

	movaps	xmm8, xmm12

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm1, xmm3
	addss	xmm2, xmm0

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1372
	mulss	xmm0, xmm0

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1376
	mulss	xmm1, xmm1

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+912

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm4

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm2, xmm15

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm8, xmm2

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1368
	mulss	xmm2, xmm2

; 807  :       trans.x *= size.x;

	mulss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm2, xmm0
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN1001@HandleAndD
	xorps	xmm6, xmm6
	sqrtss	xmm6, xmm2
	jmp	SHORT $LN1002@HandleAndD
$LN1001@HandleAndD:
	movaps	xmm0, xmm2
	call	sqrtf
	movaps	xmm6, xmm0
$LN1002@HandleAndD:

; 1858 : 
; 1859 :             // info text
; 1860 :             char tmps[512];
; 1861 :             ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);
; 1862 :             ImFormatString(tmps, sizeof(tmps), "X: %.2f Y: %.2f Z: %.2f"

	movss	xmm1, DWORD PTR ds:20
	subss	xmm1, DWORD PTR ds:8

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm0, DWORD PTR scale$30[rbp-216]
	movss	xmm2, DWORD PTR scale$30[rbp-220]
	mulss	xmm2, xmm2

; 1858 : 
; 1859 :             // info text
; 1860 :             char tmps[512];
; 1861 :             ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);
; 1862 :             ImFormatString(tmps, sizeof(tmps), "X: %.2f Y: %.2f Z: %.2f"

	mulss	xmm6, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm1, DWORD PTR scale$30[rbp-224]
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm2, xmm1
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	ucomiss	xmm0, xmm2
	ja	SHORT $LN999@HandleAndD
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN1000@HandleAndD
$LN999@HandleAndD:
	movaps	xmm0, xmm2
	call	sqrtf
$LN1000@HandleAndD:
	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1352

; 1858 : 
; 1859 :             // info text
; 1860 :             char tmps[512];
; 1861 :             ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);
; 1862 :             ImFormatString(tmps, sizeof(tmps), "X: %.2f Y: %.2f Z: %.2f"

	xorps	xmm10, xmm10

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1360

; 1858 : 
; 1859 :             // info text
; 1860 :             char tmps[512];
; 1861 :             ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);
; 1862 :             ImFormatString(tmps, sizeof(tmps), "X: %.2f Y: %.2f Z: %.2f"

	mulss	xmm6, xmm0

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1356
	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	addss	xmm2, xmm0
	xorps	xmm0, xmm0

; 1858 : 
; 1859 :             // info text
; 1860 :             char tmps[512];
; 1861 :             ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);
; 1862 :             ImFormatString(tmps, sizeof(tmps), "X: %.2f Y: %.2f Z: %.2f"

	cvtss2sd xmm10, xmm6

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN997@HandleAndD
	xorps	xmm6, xmm6
	sqrtss	xmm6, xmm2
	jmp	SHORT $LN998@HandleAndD
$LN997@HandleAndD:
	movaps	xmm0, xmm2
	call	sqrtf
	movaps	xmm6, xmm0
$LN998@HandleAndD:

; 1858 : 
; 1859 :             // info text
; 1860 :             char tmps[512];
; 1861 :             ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);
; 1862 :             ImFormatString(tmps, sizeof(tmps), "X: %.2f Y: %.2f Z: %.2f"

	movss	xmm1, DWORD PTR ds:16
	subss	xmm1, DWORD PTR ds:4

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm0, DWORD PTR scale$30[rbp-232]
	movss	xmm2, DWORD PTR scale$30[rbp-236]
	mulss	xmm2, xmm2

; 1858 : 
; 1859 :             // info text
; 1860 :             char tmps[512];
; 1861 :             ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);
; 1862 :             ImFormatString(tmps, sizeof(tmps), "X: %.2f Y: %.2f Z: %.2f"

	mulss	xmm6, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm1, DWORD PTR scale$30[rbp-240]
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm2, xmm1
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	ucomiss	xmm0, xmm2
	ja	SHORT $LN995@HandleAndD
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN996@HandleAndD
$LN995@HandleAndD:
	movaps	xmm0, xmm2
	call	sqrtf
$LN996@HandleAndD:
	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1336

; 1858 : 
; 1859 :             // info text
; 1860 :             char tmps[512];
; 1861 :             ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);
; 1862 :             ImFormatString(tmps, sizeof(tmps), "X: %.2f Y: %.2f Z: %.2f"

	xorps	xmm9, xmm9

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1344

; 1858 : 
; 1859 :             // info text
; 1860 :             char tmps[512];
; 1861 :             ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);
; 1862 :             ImFormatString(tmps, sizeof(tmps), "X: %.2f Y: %.2f Z: %.2f"

	mulss	xmm6, xmm0

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1340
	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	addss	xmm2, xmm0
	xorps	xmm0, xmm0

; 1858 : 
; 1859 :             // info text
; 1860 :             char tmps[512];
; 1861 :             ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);
; 1862 :             ImFormatString(tmps, sizeof(tmps), "X: %.2f Y: %.2f Z: %.2f"

	cvtss2sd xmm9, xmm6

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN993@HandleAndD
	xorps	xmm6, xmm6
	sqrtss	xmm6, xmm2
	jmp	SHORT $LN994@HandleAndD
$LN993@HandleAndD:
	movaps	xmm0, xmm2
	call	sqrtf
	movaps	xmm6, xmm0
$LN994@HandleAndD:

; 1858 : 
; 1859 :             // info text
; 1860 :             char tmps[512];
; 1861 :             ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);
; 1862 :             ImFormatString(tmps, sizeof(tmps), "X: %.2f Y: %.2f Z: %.2f"

	movss	xmm1, DWORD PTR ds:12
	subss	xmm1, DWORD PTR [r12]

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm0, DWORD PTR scale$30[rbp-248]
	movss	xmm2, DWORD PTR scale$30[rbp-252]
	mulss	xmm2, xmm2

; 1858 : 
; 1859 :             // info text
; 1860 :             char tmps[512];
; 1861 :             ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);
; 1862 :             ImFormatString(tmps, sizeof(tmps), "X: %.2f Y: %.2f Z: %.2f"

	mulss	xmm6, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm1, DWORD PTR scale$30[rbp-256]
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm2, xmm1
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	ucomiss	xmm0, xmm2
	ja	SHORT $LN991@HandleAndD
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN992@HandleAndD
$LN991@HandleAndD:
	movaps	xmm0, xmm2
	call	sqrtf
$LN992@HandleAndD:

; 1858 : 
; 1859 :             // info text
; 1860 :             char tmps[512];
; 1861 :             ImVec2 destinationPosOnScreen = worldToPos(gContext.mModel.v.position, gContext.mViewProjection);
; 1862 :             ImFormatString(tmps, sizeof(tmps), "X: %.2f Y: %.2f Z: %.2f"

	mulss	xmm6, xmm0
	lea	r8, OFFSET FLAT:??_C@_0BI@LOEGLDAO@X?3?5?$CF?42f?5Y?3?5?$CF?42f?5Z?3?5?$CF?42f@
	mov	edx, 512				; 00000200H
	lea	rcx, QWORD PTR tmps$35[rbp-256]
	xorps	xmm3, xmm3
	movsd	QWORD PTR [rsp+40], xmm10
	movsd	QWORD PTR [rsp+32], xmm9
	cvtss2sd xmm3, xmm6
	movq	r9, xmm3
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+264
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 1867 :             drawList->AddText(ImVec2(destinationPosOnScreen.x + 15, destinationPosOnScreen.y + 15), GetColorU32(TEXT_SHADOW), tmps);

	movaps	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm1, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1867 :             drawList->AddText(ImVec2(destinationPosOnScreen.x + 15, destinationPosOnScreen.y + 15), GetColorU32(TEXT_SHADOW), tmps);

	addss	xmm0, DWORD PTR __real@41700000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm1, DWORD PTR __real@41700000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	edi, -16777216				; ff000000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	mov	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T19[rbp-256], xmm0
	movss	DWORD PTR $T19[rbp-252], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	test	eax, edi
	je	$LN61@HandleAndD

; 1579 :         return;
; 1580 : 
; 1581 :     if (text_end == NULL)
; 1582 :         text_end = text_begin + strlen(text_begin);

	lea	rax, QWORD PTR tmps$35[rbp-256]
	mov	rcx, -1
	npad	3
$LL990@HandleAndD:
	inc	rcx
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL990@HandleAndD
	lea	rdx, QWORD PTR tmps$35[rbp-256]
	add	rdx, rcx

; 1583 :     if (text_begin == text_end)

	lea	rax, QWORD PTR tmps$35[rbp-256]
	cmp	rax, rdx
	je	SHORT $LN61@HandleAndD

; 1584 :         return;
; 1585 : 
; 1586 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1587 :     if (font == NULL)
; 1588 :         font = _Data->Font;

	mov	rax, QWORD PTR [rbx+56]

; 1589 :     if (font_size == 0.0f)
; 1590 :         font_size = _Data->FontSize;
; 1591 : 
; 1592 :     IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
; 1593 : 
; 1594 :     ImVec4 clip_rect = _CmdHeader.ClipRect;
; 1595 :     if (cpu_fine_clip_rect)
; 1596 :     {
; 1597 :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
; 1598 :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
; 1599 :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
; 1600 :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
; 1601 :     }
; 1602 :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

	lea	rcx, QWORD PTR tmps$35[rbp-256]
	movups	xmm0, XMMWORD PTR [rbx+136]
	mov	BYTE PTR [rsp+72], 0
	lea	r9, QWORD PTR $T19[rbp-256]
	movss	DWORD PTR [rsp+64], xmm13
	movss	xmm2, DWORD PTR [rax+16]
	mov	QWORD PTR [rsp+56], rdx
	mov	rdx, rbx
	mov	QWORD PTR [rsp+48], rcx
	lea	rcx, QWORD PTR clip_rect$29[rbp-256]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR clip_rect$29[rbp-256], xmm0
	mov	DWORD PTR [rsp+32], r8d
	call	?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
$LN61@HandleAndD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 797  :       return ImGui::ColorConvertFloat4ToU32(gContext.mStyle.Colors[idx]);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+248
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r8d, eax

; 1868 :             drawList->AddText(ImVec2(destinationPosOnScreen.x + 14, destinationPosOnScreen.y + 14), GetColorU32(TEXT), tmps);

	addss	xmm7, DWORD PTR __real@41600000
	addss	xmm8, DWORD PTR __real@41600000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T20[rbp-256], xmm7
	movss	DWORD PTR $T20[rbp-252], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	test	eax, edi
	je	$LN1027@HandleAndD

; 1579 :         return;
; 1580 : 
; 1581 :     if (text_end == NULL)
; 1582 :         text_end = text_begin + strlen(text_begin);

	lea	rax, QWORD PTR tmps$35[rbp-256]
	mov	rcx, -1
$LL989@HandleAndD:
	inc	rcx
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL989@HandleAndD
	lea	rdx, QWORD PTR tmps$35[rbp-256]
	add	rdx, rcx

; 1583 :     if (text_begin == text_end)

	lea	rax, QWORD PTR tmps$35[rbp-256]
	cmp	rax, rdx
	je	SHORT $LN1027@HandleAndD

; 1584 :         return;
; 1585 : 
; 1586 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1587 :     if (font == NULL)
; 1588 :         font = _Data->Font;

	mov	rax, QWORD PTR [rbx+56]

; 1589 :     if (font_size == 0.0f)
; 1590 :         font_size = _Data->FontSize;
; 1591 : 
; 1592 :     IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
; 1593 : 
; 1594 :     ImVec4 clip_rect = _CmdHeader.ClipRect;
; 1595 :     if (cpu_fine_clip_rect)
; 1596 :     {
; 1597 :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
; 1598 :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
; 1599 :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
; 1600 :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
; 1601 :     }
; 1602 :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

	lea	rcx, QWORD PTR tmps$35[rbp-256]
	movups	xmm0, XMMWORD PTR [rbx+136]
	mov	BYTE PTR [rsp+72], 0
	lea	r9, QWORD PTR $T20[rbp-256]
	movss	DWORD PTR [rsp+64], xmm13
	movss	xmm2, DWORD PTR [rax+16]
	mov	QWORD PTR [rsp+56], rdx
	mov	rdx, rbx
	mov	QWORD PTR [rsp+48], rcx
	lea	rcx, QWORD PTR clip_rect$28[rbp-256]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR clip_rect$28[rbp-256], xmm0
	mov	DWORD PTR [rsp+32], r8d
	call	?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
$LN1027@HandleAndD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1871 :          if (!io.MouseDown[0]) {

	movzx	esi, BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1332
	jmp	SHORT $LN103@HandleAndD
$LN1047@HandleAndD:
	mov	edi, -16777216				; ff000000H
$LN103@HandleAndD:
	mov	rax, QWORD PTR tv13333[rbp-256]
	cmp	BYTE PTR [rax+3600], 0
	jne	SHORT $LN44@HandleAndD

; 1872 :             gContext.mbUsingBounds = false;

	xor	sil, sil

; 1873 :             gContext.mEditingID = -1;

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440, -1
	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1332, sil

; 1874 :          }
; 1875 :          if (gContext.mbUsingBounds)

	jmp	SHORT $LN947@HandleAndD
$LN44@HandleAndD:
	test	sil, sil
	jne	SHORT $LN1028@HandleAndD
$LN947@HandleAndD:

; 1684 :       }
; 1685 : 
; 1686 :       for (unsigned int axisIndex = 0; axisIndex < numAxes; ++axisIndex)

	mov	eax, DWORD PTR axisIndex$1$[rsp]
	movss	xmm11, DWORD PTR __real@42c80000
	inc	eax
	mov	DWORD PTR axisIndex$1$[rsp], eax
	cmp	eax, DWORD PTR numAxes$1$[rsp]
	jb	$LL10@HandleAndD
$LN1028@HandleAndD:

; 1876 :          {
; 1877 :             break;
; 1878 :          }
; 1879 :       }
; 1880 :    }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+1440]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm14, XMMWORD PTR [r11-144]
	movaps	xmm15, XMMWORD PTR [r11-160]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
?HandleAndDrawLocalBounds@ImGuizmo@@YAXPEBMPEAUmatrix_t@1@0W4OPERATION@1@@Z ENDP ; ImGuizmo::HandleAndDrawLocalBounds
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z
_TEXT	SEGMENT
belowAxisLimit$4 = 64
belowPlaneLimit$5 = 64
belowPlaneLimit$6 = 65
belowAxisLimit$7 = 65
out$1$sroa$1269$1$ = 68
out$1$sroa$1272$1$ = 72
out$1$sroa$1255$1$ = 76
out$1$sroa$2069$1$ = 80
endOffset$1$ = 80
startOffset$1$ = 84
dirAxis$8 = 88
$T9 = 88
tv3314 = 104
tv3313 = 108
dirPlaneX$10 = 112
dirPlaneY$11 = 128
$T12 = 144
$T13 = 160
dirPlaneX$14 = 176
$T15 = 176
$T16 = 192
$T17 = 208
dirPlaneY$18 = 224
$T19 = 224
dirAxis$20 = 240
__$ArrayPad$ = 256
op$ = 480
?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z PROC	; ImGuizmo::GetScaleType, COMDAT

; 1886 :    {

	push	rbp
	push	r12
	lea	rbp, QWORD PTR [rsp-200]
	sub	rsp, 456				; 000001c8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 1887 :       if (gContext.mbUsing)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	mov	r12d, ecx
	je	SHORT $LN8@GetScaleTy

; 1888 :       {
; 1889 :          return MT_NONE;

	xor	eax, eax
	jmp	$LN1@GetScaleTy
$LN8@GetScaleTy:
	mov	QWORD PTR [rsp+480], rbx

; 1890 :       }
; 1891 :       ImGuiIO& io = ImGui::GetIO();
; 1892 :       int type = MT_NONE;

	xor	ebx, ebx
	mov	QWORD PTR [rsp+488], rsi
	mov	esi, ebx
	mov	QWORD PTR [rsp+496], rdi
	mov	QWORD PTR [rsp+448], r13
	mov	r13, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 1893 : 
; 1894 :       // screen
; 1895 :       if (io.MousePos.x >= gContext.mScreenSquareMin.x && io.MousePos.x <= gContext.mScreenSquareMax.x &&
; 1896 :          io.MousePos.y >= gContext.mScreenSquareMin.y && io.MousePos.y <= gContext.mScreenSquareMax.y &&

	lea	ecx, QWORD PTR [rbx+15]
	mov	QWORD PTR [rsp+440], r14
	mov	QWORD PTR [rsp+432], r15
	movaps	XMMWORD PTR [rsp+400], xmm7
	movss	xmm1, DWORD PTR [r13+3592]
	comiss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1048
	movaps	XMMWORD PTR [rsp+384], xmm8
	jb	SHORT $LN9@GetScaleTy
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1056
	comiss	xmm0, xmm1
	jb	SHORT $LN9@GetScaleTy
	movss	xmm1, DWORD PTR [r13+3596]
	comiss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1052
	jb	SHORT $LN9@GetScaleTy
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1060
	comiss	xmm0, xmm1
	jb	SHORT $LN9@GetScaleTy

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	mov	eax, r12d
	and	eax, 896				; 00000380H

; 74   :      return (lhs & rhs) == rhs;

	cmp	eax, 896				; 00000380H

; 1893 : 
; 1894 :       // screen
; 1895 :       if (io.MousePos.x >= gContext.mScreenSquareMin.x && io.MousePos.x <= gContext.mScreenSquareMax.x &&
; 1896 :          io.MousePos.y >= gContext.mScreenSquareMin.y && io.MousePos.y <= gContext.mScreenSquareMax.y &&

	cmove	esi, ecx
$LN9@GetScaleTy:

; 1897 :          Contains(op, SCALE))
; 1898 :       {
; 1899 :          type = MT_SCALE_XYZ;
; 1900 :       }
; 1901 : 
; 1902 :       // compute
; 1903 :       for (int i = 0; i < 3 && type == MT_NONE; i++)

	movss	xmm8, DWORD PTR __real@3f000000
	mov	edi, 1
	movaps	XMMWORD PTR [rsp+416], xmm6
	mov	r15d, ebx
	movaps	XMMWORD PTR [rsp+368], xmm9
	mov	r14d, edi
	movaps	XMMWORD PTR [rsp+352], xmm10
	movaps	XMMWORD PTR [rsp+336], xmm11
	movaps	XMMWORD PTR [rsp+320], xmm12
	movaps	XMMWORD PTR [rsp+304], xmm13
	movaps	XMMWORD PTR [rsp+288], xmm14
	movaps	XMMWORD PTR [rsp+272], xmm15
	npad	4
$LL4@GetScaleTy:
	test	esi, esi
	jne	$LN3@GetScaleTy

; 1904 :       {
; 1905 :          if(!Intersects(op, static_cast<OPERATION>(SCALE_X << i)))

	mov	ecx, r15d
	mov	eax, 128				; 00000080H
	shl	eax, cl

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	eax, r12d

; 1904 :       {
; 1905 :          if(!Intersects(op, static_cast<OPERATION>(SCALE_X << i)))

	je	$LN2@GetScaleTy

; 1906 :          {
; 1907 :             continue;
; 1908 :          }
; 1909 :          vec_t dirPlaneX, dirPlaneY, dirAxis;
; 1910 :          bool belowAxisLimit, belowPlaneLimit;
; 1911 :          ComputeTripodAxisAndVisibility(i, dirAxis, dirPlaneX, dirPlaneY, belowAxisLimit, belowPlaneLimit, true);

	lea	rax, QWORD PTR belowPlaneLimit$5[rsp]
	mov	BYTE PTR [rsp+48], dil
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR dirPlaneY$11[rbp-256]
	lea	rax, QWORD PTR belowAxisLimit$7[rsp]
	lea	r8, QWORD PTR dirPlaneX$10[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR dirAxis$20[rbp-256]
	call	?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z ; ImGuizmo::ComputeTripodAxisAndVisibility

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm5, DWORD PTR dirAxis$20[rbp-252]
	movss	xmm3, DWORD PTR dirAxis$20[rbp-256]
	movaps	xmm6, xmm5
	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+492
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+476

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	movaps	xmm7, xmm5
	movss	xmm2, DWORD PTR dirAxis$20[rbp-248]

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movaps	xmm8, xmm5
	mulss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+496
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+508
	addss	xmm6, xmm0
	movss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+480
	movaps	xmm0, xmm3
	movss	xmm15, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+512
	movss	xmm14, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+500
	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+484
	addss	xmm6, xmm1
	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+516
	movaps	xmm1, xmm2

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm4, DWORD PTR dirPlaneX$10[rsp+8]

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	movss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+504
	movss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+520
	mulss	xmm0, xmm13
	mulss	xmm1, xmm15
	addss	xmm7, xmm0
	mulss	xmm8, xmm14
	movaps	xmm0, xmm3
	movss	DWORD PTR out$1$sroa$1255$1$[rsp], xmm6
	mulss	xmm0, xmm10
	addss	xmm7, xmm1

; 453  : 
; 454  :       x = out.x;

	movss	DWORD PTR dirAxis$20[rbp-256], xmm6
	movaps	xmm1, xmm2
	mulss	xmm5, xmm11
	addss	xmm8, xmm0
	mulss	xmm1, xmm12
	mulss	xmm2, xmm9
	movss	DWORD PTR out$1$sroa$1272$1$[rsp], xmm7
	addss	xmm8, xmm1

; 455  :       y = out.y;

	movss	DWORD PTR dirAxis$20[rbp-252], xmm7

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm7, DWORD PTR dirPlaneX$10[rsp]
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+508
	movaps	xmm6, xmm7
	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+476

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movss	DWORD PTR out$1$sroa$1269$1$[rsp], xmm8

; 456  :       z = out.z;

	movss	xmm0, DWORD PTR out$1$sroa$1269$1$[rsp]
	movss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+488
	movss	DWORD PTR dirAxis$20[rbp-248], xmm0
	mulss	xmm3, xmm8
	addss	xmm5, xmm3

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	movaps	xmm3, xmm7
	mulss	xmm3, xmm13

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	addss	xmm5, xmm2

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movaps	xmm2, xmm7
	mulss	xmm2, xmm10

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	movss	DWORD PTR out$1$sroa$2069$1$[rsp], xmm5

; 457  :       w = out.w;

	movss	DWORD PTR dirAxis$20[rbp-244], xmm5

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm5, DWORD PTR dirPlaneX$10[rsp+4]
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+492
	addss	xmm6, xmm0

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+496
	addss	xmm3, xmm0

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movaps	xmm0, xmm5
	addss	xmm6, xmm1
	mulss	xmm0, xmm14
	movaps	xmm1, xmm4
	mulss	xmm1, xmm15
	addss	xmm3, xmm1
	addss	xmm2, xmm0

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	mulss	xmm7, xmm8

; 455  :       y = out.y;

	movss	DWORD PTR dirPlaneX$10[rsp+4], xmm3
	movaps	xmm1, xmm4
	mulss	xmm1, xmm12
	movss	DWORD PTR dirPlaneX$10[rsp], xmm6
	mulss	xmm5, xmm11
	addss	xmm2, xmm1
	mulss	xmm4, xmm9
	addss	xmm7, xmm5

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm5, DWORD PTR dirPlaneY$11[rbp-252]
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+492

; 456  :       z = out.z;

	movss	DWORD PTR dirPlaneX$10[rsp+8], xmm2
	addss	xmm7, xmm4

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm4, DWORD PTR dirPlaneY$11[rbp-248]
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+508

; 457  :       w = out.w;

	movss	DWORD PTR dirPlaneX$10[rsp+12], xmm7

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm7, DWORD PTR dirPlaneY$11[rbp-256]
	movaps	xmm6, xmm7

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	movaps	xmm3, xmm7
	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+476

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movaps	xmm2, xmm7
	mulss	xmm3, xmm13
	addss	xmm6, xmm0

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	mulss	xmm7, xmm8

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm8, DWORD PTR out$1$sroa$1269$1$[rsp]

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+496
	addss	xmm6, xmm1

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	mulss	xmm2, xmm10
	addss	xmm3, xmm0
	movaps	xmm1, xmm4
	mulss	xmm1, xmm15
	movaps	xmm0, xmm5
	mulss	xmm0, xmm14
	addss	xmm3, xmm1

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	mulss	xmm5, xmm11
	movaps	xmm1, xmm4

; 453  : 
; 454  :       x = out.x;

	movss	DWORD PTR dirPlaneY$11[rbp-256], xmm6

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm6, DWORD PTR out$1$sroa$1255$1$[rsp]

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	addss	xmm2, xmm0
	mulss	xmm1, xmm12

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	addss	xmm7, xmm5

; 455  :       y = out.y;

	movss	DWORD PTR dirPlaneY$11[rbp-252], xmm3

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm3, xmm6
	mulss	xmm3, xmm6

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	addss	xmm2, xmm1

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	mulss	xmm4, xmm9

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm8
	mulss	xmm1, xmm8

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	addss	xmm7, xmm4

; 456  :       z = out.z;

	movss	DWORD PTR dirPlaneY$11[rbp-248], xmm2

; 457  :       w = out.w;

	movss	DWORD PTR dirPlaneY$11[rbp-244], xmm7

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm7, DWORD PTR out$1$sroa$1272$1$[rsp]
	movaps	xmm0, xmm7
	mulss	xmm0, xmm7

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm3, xmm0
	xorps	xmm0, xmm0
	addss	xmm3, xmm1
	ucomiss	xmm0, xmm3
	ja	SHORT $LN237@GetScaleTy
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm3
	jmp	SHORT $LN238@GetScaleTy
$LN237@GetScaleTy:
	movaps	xmm0, xmm3
	call	sqrtf
$LN238@GetScaleTy:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movss	xmm14, DWORD PTR __real@34000000
	movss	xmm12, DWORD PTR __real@3f800000
	maxss	xmm0, xmm14

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+532

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movaps	xmm2, xmm12

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1024

; 1912 :          dirAxis.TransformVector(gContext.mModelLocal);
; 1913 :          dirPlaneX.TransformVector(gContext.mModelLocal);
; 1914 :          dirPlaneY.TransformVector(gContext.mModelLocal);
; 1915 : 
; 1916 :          const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, BuildPlan(gContext.mModelLocal.v.position, dirAxis));

	movss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1020

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1028

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1004

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm2, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+528

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movaps	xmm3, xmm2
	mulss	xmm3, xmm6

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm6, xmm2
	mulss	xmm6, xmm7
	movaps	xmm7, xmm2
	mulss	xmm2, DWORD PTR out$1$sroa$2069$1$[rsp]

; 1912 :          dirAxis.TransformVector(gContext.mModelLocal);
; 1913 :          dirPlaneX.TransformVector(gContext.mModelLocal);
; 1914 :          dirPlaneY.TransformVector(gContext.mModelLocal);
; 1915 : 
; 1916 :          const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, BuildPlan(gContext.mModelLocal.v.position, dirAxis));

	movaps	xmm5, xmm3

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm8

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm4, xmm3
	mulss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+524
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+536

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1008

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm0, xmm6

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	mulss	xmm1, xmm7
	addss	xmm4, xmm0

; 1912 :          dirAxis.TransformVector(gContext.mModelLocal);
; 1913 :          dirPlaneX.TransformVector(gContext.mModelLocal);
; 1914 :          dirPlaneY.TransformVector(gContext.mModelLocal);
; 1915 : 
; 1916 :          const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, BuildPlan(gContext.mModelLocal.v.position, dirAxis));

	mulss	xmm5, xmm9

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movaps	xmm0, xmm10
	mulss	xmm0, xmm6

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	addss	xmm4, xmm1

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movaps	xmm1, xmm11
	mulss	xmm1, xmm7
	addss	xmm5, xmm0

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	addss	xmm4, xmm2

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1012

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	addss	xmm5, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm0, xmm5
	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	comiss	xmm14, xmm0
	jbe	SHORT $LN198@GetScaleTy

; 911  :       {
; 912  :          return -1.0f;

	movss	xmm3, DWORD PTR __real@bf800000
	jmp	SHORT $LN197@GetScaleTy
$LN198@GetScaleTy:

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm3, xmm13
	movaps	xmm0, xmm8
	mulss	xmm0, xmm6
	movaps	xmm1, xmm2
	mulss	xmm1, xmm7
	addss	xmm3, xmm0
	addss	xmm3, xmm1

; 907  :       const float numer = plan.Dot3(rOrigin) - plan.w;

	subss	xmm3, xmm4

; 913  :       }
; 914  : 
; 915  :       return -(numer / denom);

	divss	xmm3, xmm5
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
$LN197@GetScaleTy:

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm9, xmm3

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	mov	eax, r14d
	and	eax, r12d

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm10, xmm3
	mulss	xmm11, xmm3
	addss	xmm9, xmm13

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	addss	xmm10, xmm8
	addss	xmm11, xmm2

; 74   :      return (lhs & rhs) == rhs;

	cmp	eax, r14d

; 1917 :          vec_t posOnPlan = gContext.mRayOrigin + gContext.mRayVector * len;
; 1918 : 
; 1919 :          const float startOffset = Contains(op, static_cast<OPERATION>(TRANSLATE_X << i)) ? 1.0f : 0.1f;

	jne	SHORT $LN17@GetScaleTy

; 1920 :          const float endOffset = Contains(op, static_cast<OPERATION>(TRANSLATE_X << i)) ? 1.4f : 1.0f;

	movss	xmm1, DWORD PTR __real@3fb33333
	movss	DWORD PTR endOffset$1$[rsp], xmm1
	movss	DWORD PTR startOffset$1$[rsp], xmm12
	jmp	SHORT $LN20@GetScaleTy
$LN17@GetScaleTy:

; 1917 :          vec_t posOnPlan = gContext.mRayOrigin + gContext.mRayVector * len;
; 1918 : 
; 1919 :          const float startOffset = Contains(op, static_cast<OPERATION>(TRANSLATE_X << i)) ? 1.0f : 0.1f;

	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR startOffset$1$[rsp], xmm0

; 1920 :          const float endOffset = Contains(op, static_cast<OPERATION>(TRANSLATE_X << i)) ? 1.4f : 1.0f;

	movss	DWORD PTR endOffset$1$[rsp], xmm12
$LN20@GetScaleTy:

; 804  :       trans *= 0.5f / trans.w;

	movss	xmm5, DWORD PTR __real@3f000000

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+888

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm3, xmm5

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+872
	movaps	xmm2, xmm8
	movss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+904
	movaps	xmm0, xmm6
	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+920
	movaps	xmm1, xmm7
	movss	xmm15, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+864
	mulss	xmm2, xmm10
	movss	xmm14, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+912

; 807  :       trans.x *= size.x;

	movss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm0, xmm9
	mulss	xmm1, xmm11
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+860
	mulss	xmm0, xmm9
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+892
	mulss	xmm1, xmm11
	addss	xmm2, xmm4

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+876
	mulss	xmm2, xmm10
	addss	xmm2, xmm0

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movaps	xmm0, xmm15
	mulss	xmm0, xmm9
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+896
	mulss	xmm1, xmm11
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+908

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm3

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm2, xmm5

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 808  :       trans.y *= size.y;

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404
	movss	DWORD PTR tv3314[rsp], xmm2

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+880
	mulss	xmm2, xmm10
	addss	xmm2, xmm0

; 806  :       trans.y = 1.f - trans.y;

	movaps	xmm0, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm1

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm1, DWORD PTR out$1$sroa$1272$1$[rsp]

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm14

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm3

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm3, DWORD PTR out$1$sroa$1255$1$[rsp]

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm2, xmm5

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm0, xmm2

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm2, DWORD PTR out$1$sroa$1269$1$[rsp]

; 807  :       trans.x *= size.x;

	mulss	xmm0, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, xmm12
	movss	DWORD PTR tv3313[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064
	mulss	xmm2, xmm0
	mulss	xmm1, xmm0

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movaps	xmm9, xmm2

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	DWORD PTR out$1$sroa$1269$1$[rsp], xmm2
	mulss	xmm3, xmm0
	movss	xmm0, DWORD PTR startOffset$1$[rsp]

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movaps	xmm10, xmm1
	mulss	xmm9, xmm0

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movaps	xmm11, xmm3

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm10, xmm0

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+532

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm11, xmm0

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+528

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	DWORD PTR out$1$sroa$1272$1$[rsp], xmm1

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+524

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movaps	xmm1, xmm9
	mulss	xmm1, xmm7
	movaps	xmm0, xmm10
	movaps	xmm2, xmm11
	mulss	xmm0, xmm8
	mulss	xmm2, xmm6
	addss	xmm2, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm4

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm5, xmm2

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm2, DWORD PTR endOffset$1$[rsp]
	mulss	xmm3, xmm2

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+524

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movss	xmm0, DWORD PTR out$1$sroa$1272$1$[rsp]
	movss	xmm1, DWORD PTR out$1$sroa$1269$1$[rsp]
	mulss	xmm0, xmm2

; 273  :    vec_t makeVect(ImVec2 v) { vec_t res; res.x = v.x; res.y = v.y; res.z = 0.f; res.w = 0.f; return res; }

	mov	QWORD PTR $T12[rbp-248], rbx

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm1, xmm2

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movaps	xmm2, xmm3

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+528

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm2, xmm6

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+532
	movss	DWORD PTR out$1$sroa$1255$1$[rsp], xmm3

; 804  :       trans *= 0.5f / trans.w;

	movss	xmm3, DWORD PTR __real@3f000000

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	movss	DWORD PTR out$1$sroa$1272$1$[rsp], xmm0

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm6, DWORD PTR out$1$sroa$1272$1$[rsp]

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];
; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm0, xmm8

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	movss	xmm8, DWORD PTR __real@3f000000

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	movss	DWORD PTR out$1$sroa$1269$1$[rsp], xmm1

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm0
	mulss	xmm1, xmm7
	movaps	xmm0, xmm6
	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+880
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+876
	addss	xmm2, xmm1
	addss	xmm2, xmm4

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm2

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	movss	xmm2, DWORD PTR out$1$sroa$1255$1$[rsp]
	movaps	xmm4, xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	mulss	xmm2, xmm15

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	mulss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+860

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm6
	addss	xmm4, xmm0
	movss	xmm0, DWORD PTR out$1$sroa$1269$1$[rsp]
	movaps	xmm1, xmm0
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+896
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+892
	addss	xmm2, xmm0

; 1925 :          vec_t closestPointOnAxis = PointOnSegment(makeVect(posOnPlanScreen), makeVect(axisStartOnScreen), makeVect(axisEndOnScreen));

	movups	xmm0, XMMWORD PTR $T12[rbp-256]

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm4, xmm1

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm14
	addss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+908

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm3
	mulss	xmm4, xmm3

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm2, DWORD PTR __real@3f000000

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm3, DWORD PTR __real@3f800000
	addss	xmm4, DWORD PTR __real@3f000000
	movaps	xmm1, xmm3
	subss	xmm1, xmm2

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	movaps	xmm2, xmm11
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+860

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 807  :       trans.x *= size.x;

	mulss	xmm1, xmm13

; 808  :       trans.y *= size.y;

	addss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	mulss	xmm11, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm1, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1925 :          vec_t closestPointOnAxis = PointOnSegment(makeVect(posOnPlanScreen), makeVect(axisStartOnScreen), makeVect(axisEndOnScreen));

	movss	xmm0, xmm4
	shufps	xmm0, xmm0, 225				; 000000e1H
	movss	xmm0, xmm1

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movaps	xmm1, xmm9
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+892

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+896

; 1925 :          vec_t closestPointOnAxis = PointOnSegment(makeVect(posOnPlanScreen), makeVect(axisStartOnScreen), makeVect(axisEndOnScreen));

	shufps	xmm0, xmm0, 225				; 000000e1H
	movups	XMMWORD PTR $T12[rbp-256], xmm0
	movups	XMMWORD PTR $T16[rbp-256], xmm0

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movaps	xmm0, xmm10

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+880
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+876
	addss	xmm11, xmm10
	addss	xmm2, xmm0
	addss	xmm11, xmm9
	addss	xmm2, xmm1

; 806  :       trans.y = 1.f - trans.y;

	movaps	xmm1, xmm3

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm11, xmm14
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+908

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm11, xmm5
	mulss	xmm2, xmm5

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm11, xmm8

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm2, DWORD PTR __real@3f000000

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm1, xmm11
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 807  :       trans.x *= size.x;

	mulss	xmm1, xmm13

; 808  :       trans.y *= size.y;

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404

; 1925 :          vec_t closestPointOnAxis = PointOnSegment(makeVect(posOnPlanScreen), makeVect(axisStartOnScreen), makeVect(axisEndOnScreen));

	movss	xmm7, DWORD PTR tv3314[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm1, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1925 :          vec_t closestPointOnAxis = PointOnSegment(makeVect(posOnPlanScreen), makeVect(axisStartOnScreen), makeVect(axisEndOnScreen));

	movss	xmm6, DWORD PTR tv3313[rsp]
	lea	r9, QWORD PTR $T16[rbp-256]

; 273  :    vec_t makeVect(ImVec2 v) { vec_t res; res.x = v.x; res.y = v.y; res.z = 0.f; res.w = 0.f; return res; }

	mov	QWORD PTR $T13[rbp-248], rbx

; 1925 :          vec_t closestPointOnAxis = PointOnSegment(makeVect(posOnPlanScreen), makeVect(axisStartOnScreen), makeVect(axisEndOnScreen));

	lea	r8, QWORD PTR $T17[rbp-256]
	movups	xmm0, XMMWORD PTR $T13[rbp-256]

; 273  :    vec_t makeVect(ImVec2 v) { vec_t res; res.x = v.x; res.y = v.y; res.z = 0.f; res.w = 0.f; return res; }

	mov	QWORD PTR $T9[rsp+8], rbx

; 1925 :          vec_t closestPointOnAxis = PointOnSegment(makeVect(posOnPlanScreen), makeVect(axisStartOnScreen), makeVect(axisEndOnScreen));

	lea	rdx, QWORD PTR $T15[rbp-256]
	lea	rcx, QWORD PTR $T19[rbp-256]
	movss	xmm0, xmm2
	shufps	xmm0, xmm0, 225				; 000000e1H
	movss	xmm0, xmm1
	shufps	xmm0, xmm0, 225				; 000000e1H
	movups	XMMWORD PTR $T13[rbp-256], xmm0
	movups	XMMWORD PTR $T17[rbp-256], xmm0
	movups	xmm0, XMMWORD PTR $T9[rsp]
	movss	xmm0, xmm7
	shufps	xmm0, xmm0, 225				; 000000e1H
	movss	xmm0, xmm6
	shufps	xmm0, xmm0, 225				; 000000e1H
	movups	XMMWORD PTR $T9[rsp], xmm0
	movups	XMMWORD PTR $T15[rbp-256], xmm0
	call	?PointOnSegment@ImGuizmo@@YA?AUvec_t@1@AEBU21@00@Z ; ImGuizmo::PointOnSegment
	xorps	xmm3, xmm3
	movups	xmm2, XMMWORD PTR [rax]

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movaps	xmm1, xmm2
	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 170				; 000000aaH
	shufps	xmm1, xmm2, 85				; 00000055H
	subss	xmm0, xmm3

; 1926 : 
; 1927 :          if ((closestPointOnAxis - makeVect(posOnPlanScreen)).Length() < 12.f) // pixel size

	subss	xmm2, xmm7

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm1, xmm6

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	addss	xmm2, xmm1
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	ucomiss	xmm0, xmm2
	ja	SHORT $LN235@GetScaleTy
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN236@GetScaleTy
$LN235@GetScaleTy:
	movaps	xmm0, xmm2
	call	sqrtf
$LN236@GetScaleTy:

; 1926 : 
; 1927 :          if ((closestPointOnAxis - makeVect(posOnPlanScreen)).Length() < 12.f) // pixel size

	movss	xmm1, DWORD PTR __real@41400000
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@GetScaleTy

; 1928 :          {
; 1929 :             type = MT_SCALE_X + i;

	lea	esi, DWORD PTR [r15+12]
$LN2@GetScaleTy:

; 1897 :          Contains(op, SCALE))
; 1898 :       {
; 1899 :          type = MT_SCALE_XYZ;
; 1900 :       }
; 1901 : 
; 1902 :       // compute
; 1903 :       for (int i = 0; i < 3 && type == MT_NONE; i++)

	inc	r15d
	rol	r14d, 1
	cmp	r15d, 3
	jl	$LL4@GetScaleTy
$LN3@GetScaleTy:

; 1930 :          }
; 1931 :       }
; 1932 : 
; 1933 :       // universal
; 1934 : 
; 1935 :       vec_t deltaScreen = { io.MousePos.x - gContext.mScreenSquareCenter.x, io.MousePos.y - gContext.mScreenSquareCenter.y, 0.f, 0.f };

	movss	xmm0, DWORD PTR [r13+3592]
	subss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1040
	movss	xmm1, DWORD PTR [r13+3596]
	subss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1044

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm15, XMMWORD PTR [rsp+272]
	movaps	xmm14, XMMWORD PTR [rsp+288]
	movaps	xmm13, XMMWORD PTR [rsp+304]
	movaps	xmm12, XMMWORD PTR [rsp+320]
	movaps	xmm11, XMMWORD PTR [rsp+336]
	movaps	xmm10, XMMWORD PTR [rsp+352]
	movaps	xmm9, XMMWORD PTR [rsp+368]
	mov	r15, QWORD PTR [rsp+432]
	mov	r14, QWORD PTR [rsp+440]

; 1930 :          }
; 1931 :       }
; 1932 : 
; 1933 :       // universal
; 1934 : 
; 1935 :       vec_t deltaScreen = { io.MousePos.x - gContext.mScreenSquareCenter.x, io.MousePos.y - gContext.mScreenSquareCenter.y, 0.f, 0.f };

	mulss	xmm1, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm0, xmm0
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	addss	xmm1, xmm0
	ucomiss	xmm0, xmm1
	ja	SHORT $LN233@GetScaleTy
	xorps	xmm2, xmm2
	sqrtss	xmm2, xmm1
	jmp	SHORT $LN234@GetScaleTy
$LN233@GetScaleTy:
	movaps	xmm0, xmm1
	call	sqrtf
	movaps	xmm2, xmm0
$LN234@GetScaleTy:

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	mov	eax, r12d
	and	eax, 14336				; 00003800H

; 74   :      return (lhs & rhs) == rhs;

	cmp	eax, 14336				; 00003800H

; 1936 :       float dist = deltaScreen.Length();
; 1937 :       if (Contains(op, SCALEU) && dist >= 17.0f && dist < 23.0f)

	jne	SHORT $LN12@GetScaleTy
	comiss	xmm2, DWORD PTR __real@41880000
	jb	SHORT $LN12@GetScaleTy
	movss	xmm0, DWORD PTR __real@41b80000
	mov	eax, 15
	comiss	xmm0, xmm2
	cmova	esi, eax
$LN12@GetScaleTy:

; 1938 :       {
; 1939 :          type = MT_SCALE_XYZ;
; 1940 :       }
; 1941 : 
; 1942 :       for (int i = 0; i < 3 && type == MT_NONE; i++)

	movss	xmm7, DWORD PTR __real@3f800000
	npad	3
$LL7@GetScaleTy:
	test	esi, esi
	jne	$LN6@GetScaleTy

; 1943 :       {
; 1944 :          if (!Intersects(op, static_cast<OPERATION>(SCALE_XU << i)))

	mov	ecx, ebx
	mov	eax, 2048				; 00000800H
	shl	eax, cl

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	eax, r12d

; 1943 :       {
; 1944 :          if (!Intersects(op, static_cast<OPERATION>(SCALE_XU << i)))

	je	$LN5@GetScaleTy

; 1945 :          {
; 1946 :             continue;
; 1947 :          }
; 1948 : 
; 1949 :          vec_t dirPlaneX, dirPlaneY, dirAxis;
; 1950 :          bool belowAxisLimit, belowPlaneLimit;
; 1951 :          ComputeTripodAxisAndVisibility(i, dirAxis, dirPlaneX, dirPlaneY, belowAxisLimit, belowPlaneLimit, true);

	lea	rax, QWORD PTR belowPlaneLimit$6[rsp]
	mov	BYTE PTR [rsp+48], 1
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR dirPlaneY$18[rbp-256]
	lea	rax, QWORD PTR belowAxisLimit$4[rsp]
	lea	r8, QWORD PTR dirPlaneX$14[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR dirAxis$8[rsp]
	call	?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z ; ImGuizmo::ComputeTripodAxisAndVisibility

; 1952 : 
; 1953 :          // draw axis
; 1954 :          if (belowAxisLimit)

	cmp	BYTE PTR belowAxisLimit$4[rsp], sil
	je	$LN5@GetScaleTy

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	mov	eax, edi
	and	eax, r12d

; 74   :      return (lhs & rhs) == rhs;

	cmp	eax, edi

; 1955 :          {
; 1956 :             bool hasTranslateOnAxis = Contains(op, static_cast<OPERATION>(TRANSLATE_X << i));
; 1957 :             float markerScale = hasTranslateOnAxis ? 1.4f : 1.0f;

	jne	SHORT $LN21@GetScaleTy
	movss	xmm6, DWORD PTR __real@3fb33333
	jmp	SHORT $LN22@GetScaleTy
$LN21@GetScaleTy:
	movaps	xmm6, xmm7
$LN22@GetScaleTy:

; 1958 :             //ImVec2 baseSSpace = worldToPos(dirAxis * 0.1f * gContext.mScreenFactor, gContext.mMVPLocal);
; 1959 :             //ImVec2 worldDirSSpaceNoScale = worldToPos(dirAxis * markerScale * gContext.mScreenFactor, gContext.mMVP);
; 1960 :             ImVec2 worldDirSSpace = worldToPos((dirAxis * markerScale) * gContext.mScreenFactor, gContext.mMVPLocal);

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movaps	xmm4, xmm6
	mulss	xmm4, DWORD PTR dirAxis$8[rsp]
	movaps	xmm5, xmm6
	mulss	xmm5, DWORD PTR dirAxis$8[rsp+4]

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm3, xmm8

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm6, DWORD PTR dirAxis$8[rsp+8]

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm5, xmm0
	mulss	xmm6, xmm0

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movaps	xmm2, xmm5

; 1958 :             //ImVec2 baseSSpace = worldToPos(dirAxis * 0.1f * gContext.mScreenFactor, gContext.mMVPLocal);
; 1959 :             //ImVec2 worldDirSSpaceNoScale = worldToPos(dirAxis * markerScale * gContext.mScreenFactor, gContext.mMVP);
; 1960 :             ImVec2 worldDirSSpace = worldToPos((dirAxis * markerScale) * gContext.mScreenFactor, gContext.mMVPLocal);

	mulss	xmm4, xmm0

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+824
	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+840
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+808
	addss	xmm2, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+796
	mulss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+800
	addss	xmm2, xmm1
	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+828
	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+832
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+856

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm2

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movaps	xmm2, xmm5

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+816

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+812

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm5, xmm4
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm5, xmm6
	addss	xmm2, xmm1

; 806  :       trans.y = 1.f - trans.y;

	movaps	xmm1, xmm7

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+848
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+844

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm5, xmm3
	mulss	xmm2, xmm3

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm5, xmm8

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm2, xmm8

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm1, xmm5
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 807  :       trans.x *= size.x;

	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416

; 808  :       trans.y *= size.y;

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm2, DWORD PTR [r13+3592]
	subss	xmm1, DWORD PTR [r13+3596]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	mulss	xmm2, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	addss	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1962 :             float distance = sqrtf(ImLengthSqr(worldDirSSpace - io.MousePos));

	ucomiss	xmm0, xmm1
	ja	SHORT $LN231@GetScaleTy
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	jmp	SHORT $LN232@GetScaleTy
$LN231@GetScaleTy:
	movaps	xmm0, xmm1
	call	sqrtf
$LN232@GetScaleTy:

; 1963 :             if (distance < 12.f)

	movss	xmm1, DWORD PTR __real@41400000
	comiss	xmm1, xmm0
	jbe	SHORT $LN5@GetScaleTy

; 1964 :             {
; 1965 :                type = MT_SCALE_X + i;

	lea	esi, DWORD PTR [rbx+12]
$LN5@GetScaleTy:

; 1938 :       {
; 1939 :          type = MT_SCALE_XYZ;
; 1940 :       }
; 1941 : 
; 1942 :       for (int i = 0; i < 3 && type == MT_NONE; i++)

	inc	ebx
	rol	edi, 1
	cmp	ebx, 3
	jl	$LL7@GetScaleTy
$LN6@GetScaleTy:

; 1966 :             }
; 1967 :          }
; 1968 :       }
; 1969 :       return type;

	movaps	xmm8, XMMWORD PTR [rsp+384]
	mov	eax, esi
	mov	rsi, QWORD PTR [rsp+488]
	movaps	xmm7, XMMWORD PTR [rsp+400]
	movaps	xmm6, XMMWORD PTR [rsp+416]
	mov	r13, QWORD PTR [rsp+448]
	mov	rdi, QWORD PTR [rsp+496]
	mov	rbx, QWORD PTR [rsp+480]
$LN1@GetScaleTy:

; 1970 :    }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 456				; 000001c8H
	pop	r12
	pop	rbp
	ret	0
?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z ENDP	; ImGuizmo::GetScaleType
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z
_TEXT	SEGMENT
planNormals$ = 32
__$ArrayPad$ = 80
op$ = 272
?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z PROC	; ImGuizmo::GetRotateType, COMDAT

; 1973 :    {

	push	rbp
	sub	rsp, 256				; 00000100H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1974 :       if (gContext.mbUsing)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	mov	ebp, ecx
	je	SHORT $LN5@GetRotateT

; 1975 :       {
; 1976 :          return MT_NONE;

	xor	eax, eax
	jmp	$LN1@GetRotateT
$LN5@GetRotateT:
	mov	QWORD PTR [rsp+272], rbx

; 1977 :       }
; 1978 :       ImGuiIO& io = ImGui::GetIO();
; 1979 :       int type = MT_NONE;

	xor	ebx, ebx
	mov	QWORD PTR [rsp+280], rsi
	mov	esi, ebx
	mov	QWORD PTR [rsp+288], rdi
	mov	QWORD PTR [rsp+296], r14
	mov	r14, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movaps	XMMWORD PTR [rsp+240], xmm6
	movaps	XMMWORD PTR [rsp+176], xmm10
	movaps	XMMWORD PTR [rsp+160], xmm11

; 1980 : 
; 1981 :       vec_t deltaScreen = { io.MousePos.x - gContext.mScreenSquareCenter.x, io.MousePos.y - gContext.mScreenSquareCenter.y, 0.f, 0.f };

	movss	xmm0, DWORD PTR [r14+3592]
	subss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1040
	movss	xmm1, DWORD PTR [r14+3596]
	subss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1044
	movaps	XMMWORD PTR [rsp+144], xmm12
	movaps	XMMWORD PTR [rsp+128], xmm13

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm0, xmm0

; 1980 : 
; 1981 :       vec_t deltaScreen = { io.MousePos.x - gContext.mScreenSquareCenter.x, io.MousePos.y - gContext.mScreenSquareCenter.y, 0.f, 0.f };

	mulss	xmm1, xmm1
	movaps	XMMWORD PTR [rsp+112], xmm14
	movaps	XMMWORD PTR [rsp+96], xmm15

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	addss	xmm1, xmm0
	ucomiss	xmm0, xmm1
	ja	SHORT $LN163@GetRotateT
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	jmp	SHORT $LN164@GetRotateT
$LN163@GetRotateT:
	movaps	xmm0, xmm1
	call	sqrtf
$LN164@GetRotateT:

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	mov	eax, ebp
	shr	eax, 6
	test	al, 1

; 1982 :       float dist = deltaScreen.Length();
; 1983 :       if (Intersects(op, ROTATE_SCREEN) && dist >= (gContext.mRadiusSquareCenter - 4.0f) && dist < (gContext.mRadiusSquareCenter + 4.0f))

	je	SHORT $LN6@GetRotateT
	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1036
	movss	xmm3, DWORD PTR __real@40800000
	movaps	xmm1, xmm2
	subss	xmm1, xmm3
	comiss	xmm0, xmm1
	jb	SHORT $LN6@GetRotateT
	addss	xmm2, xmm3
	mov	eax, 11
	comiss	xmm2, xmm0
	cmova	esi, eax
$LN6@GetRotateT:

; 1984 :       {
; 1985 :          type = MT_ROTATE_SCREEN;
; 1986 :       }
; 1987 : 
; 1988 :       const vec_t planNormals[] = { gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir };

	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+412
	lea	rdi, QWORD PTR planNormals$[rsp+8]
	movups	xmm1, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+428

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+292
	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	movss	xmm14, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468

; 1984 :       {
; 1985 :          type = MT_ROTATE_SCREEN;
; 1986 :       }
; 1987 : 
; 1988 :       const vec_t planNormals[] = { gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir };

	movss	xmm15, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1012
	movss	xmm11, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	movss	xmm6, DWORD PTR __real@3f800000
	movups	XMMWORD PTR planNormals$[rsp], xmm0
	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+444

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	mulss	xmm10, xmm12

; 1984 :       {
; 1985 :          type = MT_ROTATE_SCREEN;
; 1986 :       }
; 1987 : 
; 1988 :       const vec_t planNormals[] = { gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir };

	movups	XMMWORD PTR planNormals$[rsp+32], xmm0

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+308

; 1984 :       {
; 1985 :          type = MT_ROTATE_SCREEN;
; 1986 :       }
; 1987 : 
; 1988 :       const vec_t planNormals[] = { gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir };

	movups	XMMWORD PTR planNormals$[rsp+16], xmm1

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+324

; 1984 :       {
; 1985 :          type = MT_ROTATE_SCREEN;
; 1986 :       }
; 1987 : 
; 1988 :       const vec_t planNormals[] = { gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir };

	movaps	XMMWORD PTR [rsp+224], xmm7

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	mulss	xmm0, xmm13

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	mulss	xmm1, xmm14
	addss	xmm10, xmm0

; 1984 :       {
; 1985 :          type = MT_ROTATE_SCREEN;
; 1986 :       }
; 1987 : 
; 1988 :       const vec_t planNormals[] = { gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir };

	movaps	XMMWORD PTR [rsp+208], xmm8
	movaps	XMMWORD PTR [rsp+192], xmm9

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	addss	xmm10, xmm1
	addss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+340
	npad	1
$LL4@GetRotateT:

; 1989 : 
; 1990 :       vec_t modelViewPos;
; 1991 :       modelViewPos.TransformPoint(gContext.mModel.v.position, gContext.mViewMat);
; 1992 : 
; 1993 :       for (int i = 0; i < 3 && type == MT_NONE; i++)

	test	esi, esi
	jne	$LN3@GetRotateT

; 1994 :       {
; 1995 :          if(!Intersects(op, static_cast<OPERATION>(ROTATE_X << i)))

	mov	ecx, ebx
	mov	eax, 8
	shl	eax, cl

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	eax, ebp

; 1994 :       {
; 1995 :          if(!Intersects(op, static_cast<OPERATION>(ROTATE_X << i)))

	je	$LN2@GetRotateT

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm7, DWORD PTR [rdi-8]
	movss	xmm8, DWORD PTR [rdi-4]

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm2, xmm7

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm9, DWORD PTR [rdi]
	movaps	xmm0, xmm8

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm2, xmm7
	movaps	xmm1, xmm9

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	mulss	xmm0, xmm8

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm1, xmm9
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN161@GetRotateT
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN162@GetRotateT
$LN161@GetRotateT:
	movaps	xmm0, xmm2
	call	sqrtf
$LN162@GetRotateT:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000
	movaps	xmm2, xmm6
	divss	xmm2, xmm0
	movaps	xmm6, xmm2

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm3, xmm2

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mulss	xmm6, xmm7

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm7, xmm2
	mulss	xmm2, DWORD PTR [rdi+4]
	mulss	xmm3, xmm8

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm0, xmm6
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+472

; 1996 :          {
; 1997 :             continue;
; 1998 :          }
; 1999 :          // pickup plan
; 2000 :          vec_t pickupPlan = BuildPlan(gContext.mModel.v.position, planNormals[i]);

	movss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1020

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movaps	xmm5, xmm3
	mulss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1024

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm4, xmm3

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	mulss	xmm0, xmm12

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm9

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm9, DWORD PTR __real@34000000

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm4, xmm13

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm1, xmm7
	mulss	xmm1, xmm14
	addss	xmm4, xmm0

; 1996 :          {
; 1997 :             continue;
; 1998 :          }
; 1999 :          // pickup plan
; 2000 :          vec_t pickupPlan = BuildPlan(gContext.mModel.v.position, planNormals[i]);

	movaps	xmm0, xmm6
	mulss	xmm0, xmm8

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	addss	xmm4, xmm1

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movaps	xmm1, xmm7
	addss	xmm5, xmm0

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	addss	xmm4, xmm2

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1028
	mulss	xmm1, xmm2
	addss	xmm5, xmm1

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1004
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm0, xmm5
	andps	xmm0, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	comiss	xmm9, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1008
	jbe	SHORT $LN36@GetRotateT

; 911  :       {
; 912  :          return -1.0f;

	movss	xmm3, DWORD PTR __real@bf800000
	jmp	SHORT $LN35@GetRotateT
$LN36@GetRotateT:

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm3, xmm0
	mulss	xmm6, xmm1
	mulss	xmm7, xmm15
	addss	xmm3, xmm6
	addss	xmm3, xmm7

; 907  :       const float numer = plan.Dot3(rOrigin) - plan.w;

	subss	xmm3, xmm4

; 913  :       }
; 914  : 
; 915  :       return -(numer / denom);

	divss	xmm3, xmm5
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
$LN35@GetRotateT:

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1024
	movaps	xmm7, xmm2
	mulss	xmm6, xmm3
	mulss	xmm8, xmm3
	mulss	xmm7, xmm3

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm6, xmm0
	addss	xmm8, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm3, xmm10
	andps	xmm3, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm7, xmm15

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	movaps	xmm2, xmm6
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+308
	movaps	xmm0, xmm8
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+292
	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+324
	addss	xmm2, xmm0

; 2007 :          if (ImAbs(modelViewPos.z) - ImAbs(intersectViewPos.z) < -FLT_EPSILON)

	movss	xmm0, DWORD PTR __real@b4000000

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	addss	xmm2, xmm1
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+340
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm2, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 2007 :          if (ImAbs(modelViewPos.z) - ImAbs(intersectViewPos.z) < -FLT_EPSILON)

	subss	xmm3, xmm2
	comiss	xmm0, xmm3
	ja	$LN165@GetRotateT

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm8, xmm12
	subss	xmm6, xmm13
	subss	xmm7, xmm14

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movaps	xmm0, xmm8
	mulss	xmm0, xmm8

; 281  :    vec_t Normalized(const vec_t& v) { vec_t res; res = v; res.Normalize(); return res; }

	movaps	xmm2, xmm6
	mulss	xmm2, xmm6

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm7
	mulss	xmm1, xmm7
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN159@GetRotateT
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN160@GetRotateT
$LN159@GetRotateT:
	movaps	xmm0, xmm2
	call	sqrtf
$LN160@GetRotateT:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movss	xmm1, DWORD PTR __real@3f800000
	maxss	xmm0, xmm9

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm9, DWORD PTR __real@3f99999a

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm1, xmm0
	mulss	xmm6, xmm1
	movaps	xmm2, xmm1
	mulss	xmm2, xmm8

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movaps	xmm5, xmm6
	mulss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+556

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	movaps	xmm4, xmm6

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+564
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+540
	mulss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+560

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm1

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	addss	xmm5, xmm0

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	movaps	xmm0, xmm2

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+548
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+544
	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+572
	addss	xmm6, xmm2
	addss	xmm4, xmm0
	addss	xmm5, xmm1
	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+576
	mulss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+580
	addss	xmm4, xmm1

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm5, xmm9

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	addss	xmm6, xmm7

; 804  :       trans *= 0.5f / trans.w;

	movss	xmm7, DWORD PTR __real@3f000000
	movaps	xmm3, xmm7

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm5, xmm8

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm4, xmm9

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movaps	xmm2, xmm5

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm6, xmm9

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+744

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm6, xmm8
	mulss	xmm4, xmm8

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+776
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+760
	addss	xmm2, xmm0

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+748

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+752

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm1
	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+764
	mulss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+768
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+792

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movaps	xmm2, xmm5
	mulss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+736
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+732

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm5, xmm4
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm5, xmm6

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm6, DWORD PTR __real@3f800000

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	addss	xmm2, xmm1

; 806  :       trans.y = 1.f - trans.y;

	movaps	xmm1, xmm6

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+784
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+780

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm5, xmm3
	mulss	xmm2, xmm3

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm5, xmm7

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm2, xmm7

; 806  :       trans.y = 1.f - trans.y;

	subss	xmm1, xmm5
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412

; 807  :       trans.x *= size.x;

	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416

; 808  :       trans.y *= size.y;

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm2, DWORD PTR [r14+3592]
	subss	xmm1, DWORD PTR [r14+3596]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	addss	xmm1, xmm2
	addss	xmm1, xmm0
	ucomiss	xmm0, xmm1
	ja	SHORT $LN157@GetRotateT
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	jmp	SHORT $LN158@GetRotateT
$LN157@GetRotateT:
	movaps	xmm0, xmm1
	call	sqrtf
$LN158@GetRotateT:

; 2008 :          {
; 2009 :             continue;
; 2010 :          }
; 2011 : 
; 2012 :          const vec_t localPos = intersectWorldPos - gContext.mModel.v.position;
; 2013 :          vec_t idealPosOnCircle = Normalized(localPos);
; 2014 :          idealPosOnCircle.TransformVector(gContext.mModelInverse);
; 2015 :          const ImVec2 idealPosOnCircleScreen = worldToPos(idealPosOnCircle * rotationDisplayFactor * gContext.mScreenFactor, gContext.mMVP);
; 2016 : 
; 2017 :          //gContext.mDrawList->AddCircle(idealPosOnCircleScreen, 5.f, IM_COL32_WHITE);
; 2018 :          const ImVec2 distanceOnScreen = idealPosOnCircleScreen - io.MousePos;
; 2019 : 
; 2020 :          const float distance = makeVect(distanceOnScreen).Length();
; 2021 :          if (distance < 8.f) // pixel size

	movss	xmm1, DWORD PTR __real@41000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@GetRotateT

; 2022 :          {
; 2023 :             type = MT_ROTATE_X + i;

	lea	esi, DWORD PTR [rbx+8]
	jmp	SHORT $LN2@GetRotateT
$LN165@GetRotateT:

; 2007 :          if (ImAbs(modelViewPos.z) - ImAbs(intersectViewPos.z) < -FLT_EPSILON)

	movss	xmm6, DWORD PTR __real@3f800000
$LN2@GetRotateT:

; 1989 : 
; 1990 :       vec_t modelViewPos;
; 1991 :       modelViewPos.TransformPoint(gContext.mModel.v.position, gContext.mViewMat);
; 1992 : 
; 1993 :       for (int i = 0; i < 3 && type == MT_NONE; i++)

	inc	ebx
	add	rdi, 16
	cmp	ebx, 3
	jl	$LL4@GetRotateT
$LN3@GetRotateT:

; 2024 :          }
; 2025 :       }
; 2026 : 
; 2027 :       return type;

	movaps	xmm15, XMMWORD PTR [rsp+96]
	mov	eax, esi
	mov	rsi, QWORD PTR [rsp+280]
	movaps	xmm14, XMMWORD PTR [rsp+112]
	movaps	xmm13, XMMWORD PTR [rsp+128]
	movaps	xmm12, XMMWORD PTR [rsp+144]
	movaps	xmm11, XMMWORD PTR [rsp+160]
	movaps	xmm10, XMMWORD PTR [rsp+176]
	movaps	xmm9, XMMWORD PTR [rsp+192]
	movaps	xmm8, XMMWORD PTR [rsp+208]
	movaps	xmm7, XMMWORD PTR [rsp+224]
	movaps	xmm6, XMMWORD PTR [rsp+240]
	mov	r14, QWORD PTR [rsp+296]
	mov	rdi, QWORD PTR [rsp+288]
	mov	rbx, QWORD PTR [rsp+272]
$LN1@GetRotateT:

; 2028 :    }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 256				; 00000100H
	pop	rbp
	ret	0
?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z ENDP	; ImGuizmo::GetRotateType
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z
_TEXT	SEGMENT
belowPlaneLimit$6 = 64
out$1$sroa$924$1$ = 68
$T4$sroa$889$1$ = 68
out$1$sroa$1031$1$ = 72
tv3407 = 72
out$1$sroa$975$1$ = 76
out$1$sroa$963$1$ = 80
$T5$sroa$868$1$ = 80
belowAxisLimit$7 = 84
out$2$sroa$965$1$ = 88
out$2$sroa$960$1$ = 92
tv3413 = 96
tv3291 = 100
tv3290 = 104
?gContext@ImGuizmo@@3UContext@1@A$14 = 108
dy$1$ = 112
?gContext@ImGuizmo@@3UContext@1@A$12 = 116
dx$1$ = 120
out$3$sroa$860$1$ = 124
out$3$sroa$986$1$ = 128
out$3$sroa$869$1$ = 132
dirPlaneX$8 = 136
dirPlaneY$9 = 152
$T10 = 168
$T11 = 184
dirAxis$12 = 200
__$ArrayPad$ = 216
op$ = 432
gizmoHitProportion$ = 440
?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z PROC ; ImGuizmo::GetMoveType, COMDAT

; 2031 :    {

	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+24], rsi
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-128]
	sub	rsp, 384				; 00000180H
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-136], xmm11
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 2032 :       ImGuiIO& io = ImGui::GetIO();
; 2033 :       int type = MT_NONE;

	xor	r12d, r12d
	mov	r15d, ecx
	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rdi, rdx
	mov	esi, r12d

; 2034 : 
; 2035 :       // screen
; 2036 :       if (io.MousePos.x >= gContext.mScreenSquareMin.x && io.MousePos.x <= gContext.mScreenSquareMax.x &&
; 2037 :          io.MousePos.y >= gContext.mScreenSquareMin.y && io.MousePos.y <= gContext.mScreenSquareMax.y &&

	movss	xmm8, DWORD PTR [rcx+3592]
	comiss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1048
	jb	SHORT $LN5@GetMoveTyp
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1056
	comiss	xmm0, xmm8
	jb	SHORT $LN5@GetMoveTyp
	movss	xmm1, DWORD PTR [rcx+3596]
	comiss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1052
	jb	SHORT $LN5@GetMoveTyp
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1060
	comiss	xmm0, xmm1
	jb	SHORT $LN5@GetMoveTyp
	mov	edx, 7

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	movzx	eax, r15b
	and	al, 7

; 74   :      return (lhs & rhs) == rhs;

	cmp	al, dl

; 2034 : 
; 2035 :       // screen
; 2036 :       if (io.MousePos.x >= gContext.mScreenSquareMin.x && io.MousePos.x <= gContext.mScreenSquareMax.x &&
; 2037 :          io.MousePos.y >= gContext.mScreenSquareMin.y && io.MousePos.y <= gContext.mScreenSquareMax.y &&

	cmove	esi, edx
$LN5@GetMoveTyp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm11, DWORD PTR [rcx+3596]
	lea	r14, OFFSET FLAT:?TRANSLATE_PLANS@ImGuizmo@@3QBW4OPERATION@1@B
	subss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
	subss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404
	movaps	XMMWORD PTR [rsp+368], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 2046 :       for (int i = 0; i < 3 && type == MT_NONE; i++)

	mov	ebx, r12d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movaps	XMMWORD PTR [rsp+352], xmm7
	movaps	XMMWORD PTR [rsp+320], xmm9
	movaps	XMMWORD PTR [rsp+304], xmm10
	movaps	XMMWORD PTR [rsp+272], xmm12
	movaps	XMMWORD PTR [rsp+256], xmm13
	movaps	XMMWORD PTR [rsp+240], xmm14
	movss	DWORD PTR tv3291[rsp], xmm11
	movss	DWORD PTR tv3290[rsp], xmm8
	movaps	XMMWORD PTR [rsp+224], xmm15
$LL4@GetMoveTyp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 2046 :       for (int i = 0; i < 3 && type == MT_NONE; i++)

	test	esi, esi
	jne	$LN225@GetMoveTyp

; 2047 :       {
; 2048 :          vec_t dirPlaneX, dirPlaneY, dirAxis;
; 2049 :          bool belowAxisLimit, belowPlaneLimit;
; 2050 :          ComputeTripodAxisAndVisibility(i, dirAxis, dirPlaneX, dirPlaneY, belowAxisLimit, belowPlaneLimit);

	lea	rax, QWORD PTR belowPlaneLimit$6[rsp]
	mov	BYTE PTR [rsp+48], r12b
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR dirPlaneY$9[rbp-256]
	lea	rax, QWORD PTR belowAxisLimit$7[rsp]
	mov	ecx, ebx
	lea	r8, QWORD PTR dirPlaneX$8[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR dirAxis$12[rbp-256]
	call	?ComputeTripodAxisAndVisibility@ImGuizmo@@YAXHAEAUvec_t@1@00AEA_N1_N@Z ; ImGuizmo::ComputeTripodAxisAndVisibility

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm4, DWORD PTR dirAxis$12[rbp-252]
	movss	xmm3, DWORD PTR dirAxis$12[rbp-256]
	movss	xmm2, DWORD PTR dirAxis$12[rbp-248]
	movss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+412
	movss	xmm15, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+428
	movaps	xmm0, xmm13
	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+444

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	movss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+416
	movaps	xmm1, xmm12
	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+432

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+436
	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+448
	movss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+420
	movss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+452

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	movss	xmm14, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+440
	movss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+424
	mulss	xmm1, xmm2
	mulss	xmm0, xmm3
	mulss	xmm15, xmm4
	mulss	xmm5, xmm4
	addss	xmm15, xmm0
	mulss	xmm6, xmm4
	movaps	xmm0, xmm11
	mulss	xmm0, xmm3
	addss	xmm15, xmm1
	movaps	xmm1, xmm10
	mulss	xmm1, xmm2
	addss	xmm5, xmm0
	movaps	xmm0, xmm9
	mulss	xmm0, xmm3
	movss	DWORD PTR out$1$sroa$963$1$[rsp], xmm15

; 453  : 
; 454  :       x = out.x;

	movss	DWORD PTR dirAxis$12[rbp-256], xmm15

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	movss	xmm15, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+432
	addss	xmm5, xmm1

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	addss	xmm6, xmm0
	movaps	xmm1, xmm8
	mulss	xmm1, xmm2

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	movaps	xmm0, xmm7
	mulss	xmm0, xmm3

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm3, DWORD PTR dirPlaneX$8[rbp-248]

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	addss	xmm6, xmm1

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	movaps	xmm1, xmm14
	movss	DWORD PTR out$1$sroa$975$1$[rsp], xmm5
	mulss	xmm1, xmm4

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm4, DWORD PTR dirPlaneX$8[rbp-256]

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movss	DWORD PTR out$1$sroa$924$1$[rsp], xmm6

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+456
	addss	xmm1, xmm0

; 456  :       z = out.z;

	movss	xmm0, DWORD PTR out$1$sroa$924$1$[rsp]
	movss	DWORD PTR dirAxis$12[rbp-248], xmm0

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movaps	xmm0, xmm13
	mulss	xmm0, xmm4

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	movss	DWORD PTR out$1$sroa$1031$1$[rsp], xmm1
	movaps	xmm1, xmm6
	mulss	xmm1, xmm2
	movss	xmm2, DWORD PTR out$1$sroa$1031$1$[rsp]

; 455  :       y = out.y;

	movss	DWORD PTR dirAxis$12[rbp-252], xmm5

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm5, DWORD PTR dirPlaneX$8[rbp-252]

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	addss	xmm2, xmm1

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movaps	xmm1, xmm12

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	mulss	xmm15, xmm5
	mulss	xmm1, xmm3

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	movss	DWORD PTR out$1$sroa$1031$1$[rsp], xmm2

; 457  :       w = out.w;

	movss	DWORD PTR dirAxis$12[rbp-244], xmm2

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+428
	mulss	xmm2, xmm5
	addss	xmm2, xmm0

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	movaps	xmm0, xmm11
	mulss	xmm0, xmm4
	addss	xmm2, xmm1
	movss	DWORD PTR out$2$sroa$965$1$[rsp], xmm2

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+436
	addss	xmm15, xmm0
	mulss	xmm2, xmm5
	movaps	xmm1, xmm10
	mulss	xmm1, xmm3
	movaps	xmm0, xmm9
	mulss	xmm0, xmm4
	addss	xmm15, xmm1
	movaps	xmm1, xmm8
	mulss	xmm1, xmm3
	addss	xmm2, xmm0

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	movaps	xmm0, xmm7
	mulss	xmm0, xmm4

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+432
	movss	DWORD PTR dx$1$[rsp], xmm15

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	addss	xmm2, xmm1

; 455  :       y = out.y;

	movss	DWORD PTR dirPlaneX$8[rbp-252], xmm15
	movaps	xmm1, xmm6
	mulss	xmm1, xmm3

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm3, DWORD PTR dirPlaneY$9[rbp-252]

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movss	DWORD PTR out$2$sroa$960$1$[rsp], xmm2

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	movaps	xmm2, xmm14
	mulss	xmm2, xmm5

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+436
	mulss	xmm4, xmm3

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	addss	xmm2, xmm0

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	mulss	xmm5, xmm3

; 454  :       x = out.x;

	movss	xmm0, DWORD PTR out$2$sroa$965$1$[rsp]
	movss	DWORD PTR dirPlaneX$8[rbp-256], xmm0

; 456  :       z = out.z;

	movss	xmm0, DWORD PTR out$2$sroa$960$1$[rsp]
	addss	xmm2, xmm1
	movss	DWORD PTR dirPlaneX$8[rbp-248], xmm0

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm1, DWORD PTR dirPlaneY$9[rbp-256]
	movss	xmm0, DWORD PTR dirPlaneY$9[rbp-248]
	mulss	xmm12, xmm0

; 457  :       w = out.w;

	movss	DWORD PTR dirPlaneX$8[rbp-244], xmm2

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+428
	mulss	xmm2, xmm3

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	mulss	xmm10, xmm0
	mulss	xmm11, xmm1

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	mulss	xmm8, xmm0

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	mulss	xmm6, xmm0
	addss	xmm4, xmm11

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm11, DWORD PTR out$1$sroa$963$1$[rsp]

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	mulss	xmm13, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm11

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	addss	xmm4, xmm10

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	mulss	xmm9, xmm1

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm10, DWORD PTR out$1$sroa$975$1$[rsp]

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	addss	xmm2, xmm13

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	mulss	xmm7, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm0, xmm11

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	addss	xmm5, xmm9
	addss	xmm2, xmm12

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	mulss	xmm14, xmm3

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm12, DWORD PTR out$1$sroa$924$1$[rsp]

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	addss	xmm5, xmm8
	movss	DWORD PTR out$3$sroa$860$1$[rsp], xmm4

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm12

; 455  :       y = out.y;

	movss	DWORD PTR dirPlaneY$9[rbp-252], xmm4
	movss	DWORD PTR out$3$sroa$986$1$[rbp-256], xmm2
	addss	xmm14, xmm7
	movss	DWORD PTR dirPlaneY$9[rbp-256], xmm2

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movaps	xmm2, xmm10
	mulss	xmm2, xmm10

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm1, xmm12

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	addss	xmm14, xmm6
	movss	DWORD PTR out$3$sroa$869$1$[rbp-256], xmm5

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm2, xmm0

; 456  :       z = out.z;

	movss	DWORD PTR dirPlaneY$9[rbp-248], xmm5
	xorps	xmm0, xmm0

; 457  :       w = out.w;

	movss	DWORD PTR dirPlaneY$9[rbp-244], xmm14

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN223@GetMoveTyp
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN224@GetMoveTyp
$LN223@GetMoveTyp:
	movaps	xmm0, xmm2
	call	sqrtf
$LN224@GetMoveTyp:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, DWORD PTR __real@34000000
	movss	xmm2, DWORD PTR __real@3f800000

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movss	xmm14, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1024
	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1028
	movaps	xmm6, xmm3

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm15, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1012

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm2, xmm0
	movaps	xmm8, xmm2

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm9, xmm2
	movaps	xmm7, xmm2

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mulss	xmm8, xmm11

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, DWORD PTR out$1$sroa$1031$1$[rsp]
	mulss	xmm9, xmm10

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm0, xmm8
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+472
	mulss	xmm0, xmm14

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm5, xmm9
	mulss	xmm5, xmm13

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm6, xmm9

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	addss	xmm5, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm12

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468
	addss	xmm5, xmm1

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movaps	xmm1, xmm4
	mulss	xmm1, xmm7

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	addss	xmm5, xmm2

; 2051 :          dirAxis.TransformVector(gContext.mModel);
; 2052 :          dirPlaneX.TransformVector(gContext.mModel);
; 2053 :          dirPlaneY.TransformVector(gContext.mModel);
; 2054 : 
; 2055 :          const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, BuildPlan(gContext.mModel.v.position, dirAxis));

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1020
	movaps	xmm0, xmm2
	mulss	xmm0, xmm8

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	addss	xmm6, xmm0
	addss	xmm6, xmm1

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm1, DWORD PTR __real@34000000
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm0, xmm6
	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	comiss	xmm1, xmm0
	jbe	SHORT $LN25@GetMoveTyp

; 911  :       {
; 912  :          return -1.0f;

	movss	xmm1, DWORD PTR __real@bf800000
	movss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1004
	jmp	SHORT $LN24@GetMoveTyp
$LN25@GetMoveTyp:

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1008
	mulss	xmm1, xmm9
	movss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1004
	movaps	xmm0, xmm9
	mulss	xmm7, xmm15
	mulss	xmm0, xmm8
	addss	xmm1, xmm0
	addss	xmm1, xmm7

; 907  :       const float numer = plan.Dot3(rOrigin) - plan.w;

	subss	xmm1, xmm5

; 913  :       }
; 914  : 
; 915  :       return -(numer / denom);

	divss	xmm1, xmm6
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
$LN24@GetMoveTyp:

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064

; 804  :       trans *= 0.5f / trans.w;

	movss	xmm8, DWORD PTR __real@3f000000

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm2, xmm1
	mulss	xmm4, xmm1

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm2, xmm9

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm3, xmm1
	mulss	xmm12, xmm0

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm4, xmm15
	addss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1008
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A$14[rsp], xmm2

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm2, DWORD PTR __real@3dcccccd

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movaps	xmm15, xmm12

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm15, xmm2

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm11, xmm0

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm15, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm10, xmm0

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A$12[rsp], xmm4

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movaps	xmm1, xmm11

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm1, xmm2

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movaps	xmm0, xmm10
	mulss	xmm0, xmm2

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm10, xmm13
	addss	xmm1, xmm14
	movss	DWORD PTR dy$1$[rsp], xmm3

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm3, xmm8

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	movss	DWORD PTR out$1$sroa$963$1$[rsp], xmm11
	addss	xmm0, xmm13

; 804  :       trans *= 0.5f / trans.w;

	movaps	xmm14, xmm8

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movaps	xmm2, xmm1

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	movss	DWORD PTR tv3407[rsp], xmm1

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+872

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];
; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movaps	xmm1, xmm15
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+904

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	movss	DWORD PTR tv3413[rsp], xmm0

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+888
	addss	xmm2, xmm0

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	movaps	xmm0, xmm11
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+872

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm1
	movaps	xmm1, xmm12
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+904
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+920

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm14, xmm2

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	movaps	xmm2, xmm10
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+888
	addss	xmm2, xmm0

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	movaps	xmm0, xmm11
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+860

; 808  :       trans.y *= size.y;

	movss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404

; 437  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3] + matrix.m[3][3];

	addss	xmm2, xmm1
	movaps	xmm1, xmm12
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+892
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+920

; 804  :       trans *= 0.5f / trans.w;

	divss	xmm3, xmm2

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movaps	xmm2, xmm10
	movaps	xmm4, xmm2

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+880
	mulss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+876
	addss	xmm4, xmm0
	movss	xmm0, DWORD PTR out$1$sroa$963$1$[rsp]
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+864
	addss	xmm4, xmm1

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm1, DWORD PTR __real@3f800000

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, xmm0
	movaps	xmm0, xmm12
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+896
	addss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+908
	addss	xmm2, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm4, xmm3

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+912

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm4, xmm8

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, xmm3

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm2, xmm8

; 808  :       trans.y *= size.y;

	addss	xmm4, xmm11
	subss	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm4, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 807  :       trans.x *= size.x;

	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm9, DWORD PTR tv3413[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm1, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	movss	xmm0, DWORD PTR tv3407[rsp]

; 805  :       trans += makeVect(0.5f, 0.5f);

	movaps	xmm12, xmm8

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+860

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movaps	xmm8, xmm4

; 2061 :          vec_t closestPointOnAxis = PointOnSegment(screenCoord, makeVect(axisStartOnScreen), makeVect(axisEndOnScreen));

	mov	QWORD PTR $T11[rbp-248], r12

; 806  :       trans.y = 1.f - trans.y;

	movss	xmm10, DWORD PTR __real@3f800000
	xorps	xmm7, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm1, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 2061 :          vec_t closestPointOnAxis = PointOnSegment(screenCoord, makeVect(axisStartOnScreen), makeVect(axisEndOnScreen));

	movss	DWORD PTR $T11[rbp-256], xmm4

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	movss	DWORD PTR $T5$sroa$868$1$[rsp], xmm0

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movaps	xmm0, xmm9
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+876

; 2061 :          vec_t closestPointOnAxis = PointOnSegment(screenCoord, makeVect(axisStartOnScreen), makeVect(axisEndOnScreen));

	mov	QWORD PTR $T10[rbp-248], r12

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+880
	movss	xmm13, DWORD PTR $T5$sroa$868$1$[rsp]
	addss	xmm13, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T4$sroa$889$1$[rsp], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movss	xmm0, DWORD PTR tv3407[rsp]
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+864

; 2061 :          vec_t closestPointOnAxis = PointOnSegment(screenCoord, makeVect(axisStartOnScreen), makeVect(axisEndOnScreen));

	movss	DWORD PTR $T11[rbp-252], xmm1

; 434  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0] + matrix.m[3][0];

	movaps	xmm1, xmm15
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+892

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	mulss	xmm15, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+896
	addss	xmm0, xmm9
	addss	xmm13, xmm1

; 806  :       trans.y = 1.f - trans.y;

	movaps	xmm9, xmm10

; 435  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1] + matrix.m[3][1];

	addss	xmm0, xmm15
	addss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+908
	addss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+912

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm13, xmm14
	mulss	xmm0, xmm14

; 805  :       trans += makeVect(0.5f, 0.5f);

	addss	xmm13, xmm12

; 211  :       vec_t& operator += (const vec_t& v) { x += v.x; y += v.y; z += v.z; w += v.w; return *this; }

	addss	xmm0, xmm12

; 806  :       trans.y = 1.f - trans.y;

	mulss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412
	subss	xmm9, xmm0

; 808  :       trans.y *= size.y;

	addss	xmm13, xmm11
	mulss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm13, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm11, DWORD PTR $T4$sroa$889$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm9, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm8, xmm13

; 2061 :          vec_t closestPointOnAxis = PointOnSegment(screenCoord, makeVect(axisStartOnScreen), makeVect(axisEndOnScreen));

	movss	DWORD PTR $T10[rbp-256], xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm9, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm8
	mulss	xmm0, xmm8

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm11, xmm9

; 2061 :          vec_t closestPointOnAxis = PointOnSegment(screenCoord, makeVect(axisStartOnScreen), makeVect(axisEndOnScreen));

	movss	DWORD PTR $T10[rbp-252], xmm9

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movaps	xmm1, xmm11
	mulss	xmm1, xmm11

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	addss	xmm1, xmm7
	ucomiss	xmm0, xmm1
	ja	SHORT $LN221@GetMoveTyp
	xorps	xmm6, xmm6
	sqrtss	xmm6, xmm1
	jmp	SHORT $LN222@GetMoveTyp
$LN221@GetMoveTyp:
	movaps	xmm0, xmm1
	call	sqrtf
	movaps	xmm6, xmm0
$LN222@GetMoveTyp:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movaps	xmm3, xmm10
	movaps	xmm1, xmm6
	maxss	xmm1, DWORD PTR __real@34000000
	divss	xmm3, xmm1
	movaps	xmm4, xmm3

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm5, xmm3

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mulss	xmm4, xmm8

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm8, DWORD PTR tv3290[rsp]

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm5, xmm11

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movaps	xmm0, xmm8
	movss	xmm11, DWORD PTR tv3291[rsp]
	subss	xmm0, xmm13
	movaps	xmm2, xmm11

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm3, xmm7

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm2, xmm9

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm0, xmm4

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	mulss	xmm2, xmm5

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	addss	xmm2, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm7
	addss	xmm2, xmm0

; 892  :       if (t < 0.f)

	comiss	xmm7, xmm2
	jbe	SHORT $LN140@GetMoveTyp

; 893  :       {
; 894  :          return vertPos1;

	movups	xmm0, XMMWORD PTR $T10[rbp-256]
	movaps	xmm3, xmm0
	movaps	xmm1, xmm0
	shufps	xmm3, xmm0, 170				; 000000aaH
	shufps	xmm1, xmm0, 85				; 00000055H
	jmp	SHORT $LN139@GetMoveTyp
$LN140@GetMoveTyp:

; 895  :       }
; 896  : 
; 897  :       if (t > d)

	comiss	xmm2, xmm6
	jbe	SHORT $LN141@GetMoveTyp

; 898  :       {
; 899  :          return vertPos2;

	movups	xmm2, XMMWORD PTR $T11[rbp-256]
	movaps	xmm3, xmm2
	movaps	xmm1, xmm2
	shufps	xmm3, xmm2, 170				; 000000aaH
	movaps	xmm0, xmm2
	shufps	xmm1, xmm2, 85				; 00000055H
	jmp	SHORT $LN139@GetMoveTyp
$LN141@GetMoveTyp:

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movaps	xmm0, xmm2

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	movaps	xmm1, xmm2
	mulss	xmm2, xmm3

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm0, xmm4

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm2, xmm7

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm1, xmm5

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm0, xmm13
	addss	xmm1, xmm9

; 902  :       return vertPos1 + V * t;

	movaps	xmm3, xmm2
$LN139@GetMoveTyp:

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm1, xmm11
	subss	xmm0, xmm8
	subss	xmm3, xmm7

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	mulss	xmm3, xmm3
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	addss	xmm1, xmm3
	ucomiss	xmm0, xmm1
	ja	SHORT $LN219@GetMoveTyp
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	jmp	SHORT $LN220@GetMoveTyp
$LN219@GetMoveTyp:
	movaps	xmm0, xmm1
	call	sqrtf
$LN220@GetMoveTyp:

; 2062 :          if ((closestPointOnAxis - screenCoord).Length() < 12.f && Intersects(op, static_cast<OPERATION>(TRANSLATE_X << i))) // pixel size

	movss	xmm1, DWORD PTR __real@41400000
	comiss	xmm1, xmm0
	jbe	SHORT $LN6@GetMoveTyp

; 63   :      return static_cast<int>(lhs) != rhs;

	bt	r15d, ebx

; 2062 :          if ((closestPointOnAxis - screenCoord).Length() < 12.f && Intersects(op, static_cast<OPERATION>(TRANSLATE_X << i))) // pixel size

	jae	SHORT $LN6@GetMoveTyp

; 2063 :          {
; 2064 :             type = MT_MOVE_X + i;

	lea	esi, DWORD PTR [rbx+1]
$LN6@GetMoveTyp:

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movaps	xmm0, xmm10
	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A$14[rsp]
	divss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064
	subss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460
	movss	xmm1, DWORD PTR dy$1$[rsp]
	subss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464
	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A$12[rsp]
	subss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movss	xmm2, DWORD PTR dx$1$[rsp]

; 2065 :          }
; 2066 : 
; 2067 :          const float dx = dirPlaneX.Dot3((posOnPlan - gContext.mModel.v.position) * (1.f / gContext.mScreenFactor));

	mulss	xmm3, xmm0

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	mulss	xmm1, xmm0
	mulss	xmm4, xmm0

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR out$2$sroa$965$1$[rsp]
	mulss	xmm3, DWORD PTR out$3$sroa$986$1$[rbp-256]
	mulss	xmm2, xmm1
	mulss	xmm1, DWORD PTR out$3$sroa$860$1$[rsp]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR out$2$sroa$960$1$[rsp]
	mulss	xmm0, xmm4
	addss	xmm1, xmm3
	mulss	xmm4, DWORD PTR out$3$sroa$869$1$[rbp-256]
	addss	xmm2, xmm0
	addss	xmm1, xmm4

; 2068 :          const float dy = dirPlaneY.Dot3((posOnPlan - gContext.mModel.v.position) * (1.f / gContext.mScreenFactor));
; 2069 :          if (belowPlaneLimit && dx >= quadUV[0] && dx <= quadUV[4] && dy >= quadUV[1] && dy <= quadUV[3] && Contains(op, TRANSLATE_PLANS[i]))

	cmp	BYTE PTR belowPlaneLimit$6[rsp], r12b
	je	SHORT $LN7@GetMoveTyp
	comiss	xmm2, xmm12
	jb	SHORT $LN7@GetMoveTyp
	movss	xmm3, DWORD PTR __real@3f4ccccd
	comiss	xmm3, xmm2
	jb	SHORT $LN7@GetMoveTyp
	comiss	xmm1, xmm12
	jb	SHORT $LN7@GetMoveTyp
	comiss	xmm3, xmm1
	jb	SHORT $LN7@GetMoveTyp

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	mov	eax, DWORD PTR [r14]
	and	eax, r15d

; 74   :      return (lhs & rhs) == rhs;

	cmp	eax, DWORD PTR [r14]

; 2068 :          const float dy = dirPlaneY.Dot3((posOnPlan - gContext.mModel.v.position) * (1.f / gContext.mScreenFactor));
; 2069 :          if (belowPlaneLimit && dx >= quadUV[0] && dx <= quadUV[4] && dy >= quadUV[1] && dy <= quadUV[3] && Contains(op, TRANSLATE_PLANS[i]))

	jne	SHORT $LN7@GetMoveTyp

; 2070 :          {
; 2071 :             type = MT_MOVE_YZ + i;

	lea	esi, DWORD PTR [rbx+4]
$LN7@GetMoveTyp:

; 2072 :          }
; 2073 : 
; 2074 :          if (gizmoHitProportion)

	test	rdi, rdi
	je	SHORT $LN2@GetMoveTyp

; 2075 :          {
; 2076 :             *gizmoHitProportion = makeVect(dx, dy, 0.f);

	movss	DWORD PTR [rdi], xmm2
	movss	DWORD PTR [rdi+4], xmm1
	mov	QWORD PTR [rdi+8], r12
$LN2@GetMoveTyp:

; 2046 :       for (int i = 0; i < 3 && type == MT_NONE; i++)

	inc	ebx
	add	r14, 4
	cmp	ebx, 3
	jl	$LL4@GetMoveTyp
$LN225@GetMoveTyp:
	movaps	xmm15, XMMWORD PTR [rsp+224]

; 2077 :          }
; 2078 :       }
; 2079 :       return type;
; 2080 :    }

	mov	eax, esi
	movaps	xmm14, XMMWORD PTR [rsp+240]
	movaps	xmm13, XMMWORD PTR [rsp+256]
	movaps	xmm12, XMMWORD PTR [rsp+272]
	movaps	xmm10, XMMWORD PTR [rsp+304]
	movaps	xmm9, XMMWORD PTR [rsp+320]
	movaps	xmm7, XMMWORD PTR [rsp+352]
	movaps	xmm6, XMMWORD PTR [rsp+368]
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+384]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+64]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm11, XMMWORD PTR [r11-96]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z ENDP ; ImGuizmo::GetMoveType
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
_TEXT	SEGMENT
res$10 = 32
gizmoHitProportion$11 = 96
delta$12 = 96
deltaMatrixTranslation$13 = 112
movePlanNormal$14 = 176
__$ArrayPad$ = 288
matrix$dead$ = 496
deltaMatrix$dead$ = 504
op$ = 512
type$ = 520
snap$dead$ = 528
?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z PROC ; ImGuizmo::HandleTranslation, COMDAT

; 2083 :    {

	mov	QWORD PTR [rsp+24], rsi
	push	rbp
	push	rdi
	push	r15
	lea	rbp, QWORD PTR [rsp-208]
	sub	rsp, 464				; 000001d0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp

; 146  : 	if (WindowHovered)

	cmp	BYTE PTR ?CameraView@UIMapView@@3VCamera@@A+245, 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 2083 :    {

	mov	rsi, r9
	mov	edi, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp

; 146  : 	if (WindowHovered)

	mov	r15d, 1
	je	SHORT $LN5@HandleTran

; 147  : 	{
; 148  : 		return (glfwGetMouseButton(pWindow, GLFW_MOUSE_BUTTON_RIGHT) == GLFW_PRESS && glfwGetMouseButton(pWindow, GLFW_MOUSE_BUTTON_LEFT) != GLFW_PRESS);

	mov	rcx, QWORD PTR ?CameraView@UIMapView@@3VCamera@@A+256
	mov	edx, r15d
	call	glfwGetMouseButton
	cmp	eax, r15d
	jne	SHORT $LN5@HandleTran
	mov	rcx, QWORD PTR ?CameraView@UIMapView@@3VCamera@@A+256
	xor	edx, edx
	call	glfwGetMouseButton
	cmp	eax, r15d
	jne	$LN7@HandleTran
$LN5@HandleTran:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	dil, 7

; 2084 :        if (UIMapView::IsInCameraMovement()) return false;
; 2085 : 
; 2086 :        if (!Intersects(op, TRANSLATE) || type != MT_NONE)

	je	$LN7@HandleTran
	cmp	DWORD PTR [rsi], 0
	jne	$LN7@HandleTran
	mov	QWORD PTR [rsp+496], rbx

; 2089 :        }
; 2090 : 
; 2091 :       const ImGuiIO& io = ImGui::GetIO();

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR [rsp+504], r14

; 2092 :       const bool applyRotationLocaly = gContext.mMode == LOCAL || type == MT_MOVE_SCREEN;
; 2093 :       bool modified = false;

	xor	r14b, r14b

; 2094 : 
; 2095 :       // move
; 2096 :       if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID))

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, r14b
	movaps	XMMWORD PTR [rsp+448], xmm6
	movaps	XMMWORD PTR [rsp+432], xmm7
	movaps	XMMWORD PTR [rsp+416], xmm8
	movaps	XMMWORD PTR [rsp+400], xmm9
	movaps	XMMWORD PTR [rsp+384], xmm10
	movaps	XMMWORD PTR [rsp+368], xmm11
	movaps	XMMWORD PTR [rsp+352], xmm12
	je	$LN8@HandleTran
	mov	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	cmp	eax, -1
	je	SHORT $LN10@HandleTran
	cmp	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440
	jne	$LN8@HandleTran
$LN10@HandleTran:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movss	xmm12, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 2099 :          ImGui::SetNextFrameWantCaptureMouse(true);

	mov	DWORD PTR [rbx+24700], r15d

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1020
	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1024
	movaps	xmm7, xmm3
	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1088
	movaps	xmm0, xmm5
	movss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1092
	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1028
	movss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1096
	movaps	xmm1, xmm6

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1008
	movss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1004

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm7, xmm4
	mulss	xmm0, xmm8
	mulss	xmm1, xmm9
	addss	xmm7, xmm0

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm0, DWORD PTR __real@34000000

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	addss	xmm7, xmm1

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1012
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm2, xmm7
	andps	xmm2, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	comiss	xmm0, xmm2
	jbe	SHORT $LN94@HandleTran

; 911  :       {
; 912  :          return -1.0f;

	movss	xmm4, DWORD PTR __real@bf800000
	jmp	SHORT $LN93@HandleTran
$LN94@HandleTran:

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm4, xmm11
	mulss	xmm8, xmm10
	mulss	xmm9, xmm1
	addss	xmm4, xmm8
	addss	xmm4, xmm9

; 907  :       const float numer = plan.Dot3(rOrigin) - plan.w;

	subss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1100

; 913  :       }
; 914  : 
; 915  :       return -(numer / denom);

	divss	xmm4, xmm7
	xorps	xmm4, DWORD PTR __xmm@80000000800000008000000080000000
$LN93@HandleTran:

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm4, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1068

; 2100 : #else
; 2101 :          ImGui::CaptureMouseFromApp();
; 2102 : #endif
; 2103 :          const float signedLength = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);
; 2104 :          const float len = fabsf(signedLength); // near plan
; 2105 :          const vec_t newPos = gContext.mRayOrigin + gContext.mRayVector * len;
; 2106 : 
; 2107 :          // compute delta
; 2108 :          const vec_t newOrigin = newPos - gContext.mRelativeOrigin * gContext.mScreenFactor;
; 2109 :          vec_t delta = newOrigin - gContext.mModel.v.position;
; 2110 : 
; 2111 :          // 1 axis constraint
; 2112 :          if (gContext.mCurrentOperation >= MT_MOVE_X && gContext.mCurrentOperation <= MT_MOVE_Z)

	mov	r9d, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1400

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm0, xmm2
	mulss	xmm3, xmm4
	mulss	xmm5, xmm4
	mulss	xmm6, xmm4

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm3, xmm11
	addss	xmm5, xmm10
	addss	xmm6, xmm1

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1032
	mulss	xmm1, xmm4

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm3, xmm0

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1072
	mulss	xmm0, xmm2

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1016

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460
	subss	xmm5, xmm0

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1076
	mulss	xmm0, xmm2

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	DWORD PTR delta$12[rsp], xmm3
	movaps	xmm7, xmm3
	subss	xmm6, xmm0

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1080
	mulss	xmm0, xmm2

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464
	subss	xmm1, xmm0
	subss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468
	movss	DWORD PTR delta$12[rsp+4], xmm5
	movaps	xmm8, xmm5
	subss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+472
	movss	DWORD PTR delta$12[rsp+8], xmm6
	movaps	xmm9, xmm6
	movss	DWORD PTR delta$12[rsp+12], xmm1

; 2100 : #else
; 2101 :          ImGui::CaptureMouseFromApp();
; 2102 : #endif
; 2103 :          const float signedLength = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);
; 2104 :          const float len = fabsf(signedLength); // near plan
; 2105 :          const vec_t newPos = gContext.mRayOrigin + gContext.mRayVector * len;
; 2106 : 
; 2107 :          // compute delta
; 2108 :          const vec_t newOrigin = newPos - gContext.mRelativeOrigin * gContext.mScreenFactor;
; 2109 :          vec_t delta = newOrigin - gContext.mModel.v.position;
; 2110 : 
; 2111 :          // 1 axis constraint
; 2112 :          if (gContext.mCurrentOperation >= MT_MOVE_X && gContext.mCurrentOperation <= MT_MOVE_Z)

	cmp	r9d, r15d
	jl	$LN12@HandleTran
	movss	DWORD PTR delta$12[rsp], xmm3
	movss	DWORD PTR delta$12[rsp+4], xmm5
	movss	DWORD PTR delta$12[rsp+8], xmm6
	cmp	r9d, 3
	jg	SHORT $LN12@HandleTran

; 2113 :          {
; 2114 :             const int axisIndex = gContext.mCurrentOperation - MT_MOVE_X;

	lea	eax, DWORD PTR [r9-1]

; 2115 :             const vec_t& axisValue = *(vec_t*)&gContext.mModel.m[axisIndex];

	movsxd	rcx, eax
	lea	rax, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+412
	shl	rcx, 4
	add	rcx, rax

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	movss	xmm8, DWORD PTR [rcx+4]
	movss	xmm7, DWORD PTR [rcx]
	movss	xmm9, DWORD PTR [rcx+8]
	mulss	xmm3, xmm7
	mulss	xmm5, xmm8
	mulss	xmm6, xmm9
	addss	xmm3, xmm5
	addss	xmm3, xmm6

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm7, xmm3
	mulss	xmm8, xmm3
	mulss	xmm9, xmm3
	mulss	xmm3, DWORD PTR [rcx+12]

; 2116 :             const float lengthOnAxis = Dot(axisValue, delta);
; 2117 :             delta = axisValue * lengthOnAxis;

	movss	DWORD PTR delta$12[rsp], xmm7
	movss	DWORD PTR delta$12[rsp+4], xmm8
	movss	DWORD PTR delta$12[rsp+12], xmm3
	movss	DWORD PTR delta$12[rsp+8], xmm9
$LN12@HandleTran:

; 269  :       bool operator!=(const vec_t& other) const { return memcmp(this, &other, sizeof(vec_t)) != 0; }

	mov	rax, QWORD PTR delta$12[rsp]
	sub	rax, QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1136
	jne	SHORT $LN211@HandleTran
	mov	rax, QWORD PTR delta$12[rsp+8]
	sub	rax, QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1144
$LN211@HandleTran:

; 2143 :          {
; 2144 :             modified = true;
; 2145 :          }
; 2146 :          gContext.mTranslationLastDelta = delta;

	movups	xmm0, XMMWORD PTR delta$12[rsp]

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	r8, QWORD PTR res$10[rsp]

; 269  :       bool operator!=(const vec_t& other) const { return memcmp(this, &other, sizeof(vec_t)) != 0; }

	test	rax, rax

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movaps	xmm1, XMMWORD PTR __xmm@0000000000000000000000003f800000

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	rdx, QWORD PTR deltaMatrixTranslation$13[rsp]

; 2143 :          {
; 2144 :             modified = true;
; 2145 :          }
; 2146 :          gContext.mTranslationLastDelta = delta;

	movdqu	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1136, xmm0

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	rcx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+604

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movaps	xmm0, XMMWORD PTR __xmm@00000000000000003f80000000000000
	movups	XMMWORD PTR deltaMatrixTranslation$13[rsp], xmm1
	movaps	xmm1, XMMWORD PTR __xmm@000000003f8000000000000000000000

; 2118 :          }
; 2119 : 
; 2120 :          // snap
; 2121 :          if (snap)
; 2122 :          {
; 2123 :             vec_t cumulativeDelta = gContext.mModel.v.position + delta - gContext.mMatrixOrigin;
; 2124 :             if (applyRotationLocaly)
; 2125 :             {
; 2126 :                matrix_t modelSourceNormalized = gContext.mModelSource;
; 2127 :                modelSourceNormalized.OrthoNormalize();
; 2128 :                matrix_t modelSourceNormalizedInverse;
; 2129 :                modelSourceNormalizedInverse.Inverse(modelSourceNormalized);
; 2130 :                cumulativeDelta.TransformVector(modelSourceNormalizedInverse);
; 2131 :                ComputeSnap(cumulativeDelta, snap);
; 2132 :                cumulativeDelta.TransformVector(modelSourceNormalized);
; 2133 :             }
; 2134 :             else
; 2135 :             {
; 2136 :                ComputeSnap(cumulativeDelta, snap);
; 2137 :             }
; 2138 :             delta = gContext.mMatrixOrigin + cumulativeDelta - gContext.mModel.v.position;
; 2139 : 
; 2140 :          }
; 2141 : 
; 2142 :          if (delta != gContext.mTranslationLastDelta)

	movzx	r14d, r14b

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movups	XMMWORD PTR deltaMatrixTranslation$13[rbp-240], xmm0

; 2118 :          }
; 2119 : 
; 2120 :          // snap
; 2121 :          if (snap)
; 2122 :          {
; 2123 :             vec_t cumulativeDelta = gContext.mModel.v.position + delta - gContext.mMatrixOrigin;
; 2124 :             if (applyRotationLocaly)
; 2125 :             {
; 2126 :                matrix_t modelSourceNormalized = gContext.mModelSource;
; 2127 :                modelSourceNormalized.OrthoNormalize();
; 2128 :                matrix_t modelSourceNormalizedInverse;
; 2129 :                modelSourceNormalizedInverse.Inverse(modelSourceNormalized);
; 2130 :                cumulativeDelta.TransformVector(modelSourceNormalizedInverse);
; 2131 :                ComputeSnap(cumulativeDelta, snap);
; 2132 :                cumulativeDelta.TransformVector(modelSourceNormalized);
; 2133 :             }
; 2134 :             else
; 2135 :             {
; 2136 :                ComputeSnap(cumulativeDelta, snap);
; 2137 :             }
; 2138 :             delta = gContext.mMatrixOrigin + cumulativeDelta - gContext.mModel.v.position;
; 2139 : 
; 2140 :          }
; 2141 : 
; 2142 :          if (delta != gContext.mTranslationLastDelta)

	cmovne	r14d, r15d

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR deltaMatrixTranslation$13[rbp-208], xmm7
	movss	DWORD PTR deltaMatrixTranslation$13[rbp-204], xmm8
	movss	DWORD PTR deltaMatrixTranslation$13[rbp-200], xmm9
	movups	XMMWORD PTR deltaMatrixTranslation$13[rbp-224], xmm1
	mov	DWORD PTR deltaMatrixTranslation$13[rbp-196], 1065353216 ; 3f800000H

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	call	?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z ; ImGuizmo::FPU_MatrixF_x_MatrixF

; 2147 : 
; 2148 :          // compute matrix & delta
; 2149 :          matrix_t deltaMatrixTranslation;
; 2150 :          deltaMatrixTranslation.Translation(delta);
; 2151 :          if (deltaMatrix)
; 2152 :          {
; 2153 :             memcpy(deltaMatrix, deltaMatrixTranslation.m16, sizeof(float) * 16);
; 2154 :          }
; 2155 : 
; 2156 :          const matrix_t res = gContext.mModelSource * deltaMatrixTranslation;
; 2157 :          *(matrix_t*)matrix = res;

	movups	xmm0, XMMWORD PTR res$10[rsp]
	movups	xmm1, XMMWORD PTR res$10[rsp+16]
	movups	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA, xmm0
	movups	xmm0, XMMWORD PTR res$10[rsp+32]
	movups	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+16, xmm1
	movups	xmm1, XMMWORD PTR res$10[rsp+48]
	movups	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+32, xmm0
	movups	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+48, xmm1

; 2158 : 
; 2159 :          if (!io.MouseDown[0])

	cmp	BYTE PTR [rbx+3600], 0
	jne	SHORT $LN17@HandleTran

; 2160 :          {
; 2161 :             gContext.mbUsing = false;

	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
$LN17@HandleTran:

; 2162 :          }
; 2163 : 
; 2164 :          type = gContext.mCurrentOperation;

	mov	DWORD PTR [rsi], r9d

; 2165 :       }

	jmp	$LN19@HandleTran
$LN8@HandleTran:

; 2166 :       else
; 2167 :       {
; 2168 :          // find new possible way to move
; 2169 :          vec_t gizmoHitProportion;
; 2170 :          type = GetMoveType(op, &gizmoHitProportion);

	lea	rdx, QWORD PTR gizmoHitProportion$11[rsp]
	mov	ecx, edi
	call	?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z ; ImGuizmo::GetMoveType
	mov	DWORD PTR [rsi], eax

; 2171 :          if (type != MT_NONE)

	test	eax, eax
	je	SHORT $LN18@HandleTran

; 2172 :          {
; 2173 : #if IMGUI_VERSION_NUM >= 18723
; 2174 :             ImGui::SetNextFrameWantCaptureMouse(true);

	mov	DWORD PTR [rbx+24700], r15d
$LN18@HandleTran:

; 2175 : #else
; 2176 :             ImGui::CaptureMouseFromApp();
; 2177 : #endif
; 2178 :          }
; 2179 :          if (CanActivate() && type != MT_NONE)

	call	?CanActivate@ImGuizmo@@YA_NXZ		; ImGuizmo::CanActivate
	test	al, al
	je	$LN19@HandleTran
	cmp	DWORD PTR [rsi], 0
	je	$LN19@HandleTran

; 2184 :             vec_t movePlanNormal[] = { gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir,

	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+444
	mov	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	movups	xmm2, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+412
	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, r15b
	movups	xmm1, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+428
	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440, eax

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464
	subss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+944
	movss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468
	subss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+948

; 2183 :             gContext.mCurrentOperation = type;

	mov	eax, DWORD PTR [rsi]

; 2184 :             vec_t movePlanNormal[] = { gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir,

	movdqu	XMMWORD PTR movePlanNormal$14[rbp-224], xmm0

; 2185 :                gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir,

	movdqu	XMMWORD PTR movePlanNormal$14[rbp-176], xmm0

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+972

; 2183 :             gContext.mCurrentOperation = type;

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1400, eax

; 2184 :             vec_t movePlanNormal[] = { gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir,

	movdqu	XMMWORD PTR movePlanNormal$14[rbp-256], xmm2

; 2185 :                gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir,

	movdqu	XMMWORD PTR movePlanNormal$14[rbp-208], xmm2

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm2, xmm7

; 2175 : #else
; 2176 :             ImGui::CaptureMouseFromApp();
; 2177 : #endif
; 2178 :          }
; 2179 :          if (CanActivate() && type != MT_NONE)

	movaps	XMMWORD PTR [rsp+336], xmm13
	movaps	XMMWORD PTR [rsp+320], xmm14

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movaps	xmm14, XMMWORD PTR __xmm@80000000800000008000000080000000
	xorps	xmm0, xmm14

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm2, xmm7

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movups	XMMWORD PTR movePlanNormal$14[rbp-160], xmm0

; 2184 :             vec_t movePlanNormal[] = { gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir,

	movdqu	XMMWORD PTR movePlanNormal$14[rbp-240], xmm1

; 2185 :                gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir,

	movdqu	XMMWORD PTR movePlanNormal$14[rbp-192], xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm8

; 2175 : #else
; 2176 :             ImGui::CaptureMouseFromApp();
; 2177 : #endif
; 2178 :          }
; 2179 :          if (CanActivate() && type != MT_NONE)

	movaps	XMMWORD PTR [rsp+304], xmm15

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm15, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460
	movaps	xmm6, xmm15

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm1, xmm8

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+940

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN209@HandleTran
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN210@HandleTran
$LN209@HandleTran:
	movaps	xmm0, xmm2
	call	sqrtf
$LN210@HandleTran:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movss	xmm11, DWORD PTR __real@34000000

; 2180 :          {
; 2181 :             gContext.mbUsing = true;
; 2182 :             gContext.mEditingID = gContext.mActualID;

	lea	rbx, QWORD PTR movePlanNormal$14[rbp-248]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movss	xmm9, DWORD PTR __real@3f800000
	maxss	xmm0, xmm11
	movaps	xmm10, xmm9

; 2180 :          {
; 2181 :             gContext.mbUsing = true;
; 2182 :             gContext.mEditingID = gContext.mActualID;

	mov	edi, 3
	xor	r15d, r15d

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm10, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm12, xmm10
	movaps	xmm13, xmm10
	mulss	xmm12, xmm6
	mulss	xmm13, xmm7
	mulss	xmm10, xmm8
$LL4@HandleTran:

; 285  :       res.x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm5, DWORD PTR [rbx-4]
	movaps	xmm6, xmm10
	movss	xmm4, DWORD PTR [rbx]
	movaps	xmm0, xmm13

; 286  :       res.y = v1.z * v2.x - v1.x * v2.z;

	movss	xmm2, DWORD PTR [rbx-8]
	movaps	xmm7, xmm12
	mulss	xmm0, xmm4

; 287  :       res.z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm1, xmm13
	mulss	xmm7, xmm4
	mulss	xmm6, xmm5
	mulss	xmm1, xmm2
	subss	xmm6, xmm0
	movaps	xmm0, xmm10
	mulss	xmm0, xmm2
	subss	xmm7, xmm0

; 232  :          res.y = z * v.x - x * v.z;

	movaps	xmm8, xmm6
	mulss	xmm8, xmm4

; 287  :       res.z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm0, xmm12
	mulss	xmm0, xmm5

; 233  :          res.z = x * v.y - y * v.x;

	mulss	xmm6, xmm5

; 287  :       res.z = v1.x * v2.y - v1.y * v2.x;

	subss	xmm1, xmm0

; 231  :          res.x = y * v.z - z * v.y;

	movaps	xmm0, xmm7
	mulss	xmm0, xmm4

; 233  :          res.z = x * v.y - y * v.x;

	mulss	xmm7, xmm2
	movaps	xmm3, xmm1
	mulss	xmm1, xmm2
	mulss	xmm3, xmm5
	subss	xmm7, xmm6
	subss	xmm8, xmm1
	subss	xmm3, xmm0
	xorps	xmm0, xmm0

; 234  : 
; 235  :          x = res.x;

	movss	DWORD PTR [rbx-8], xmm3

; 236  :          y = res.y;

	movss	DWORD PTR [rbx-4], xmm8

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm8, xmm8

; 238  :          w = 0.f;

	mov	DWORD PTR [rbx+4], r15d

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm3, xmm3

; 237  :          z = res.z;

	movss	DWORD PTR [rbx], xmm7

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm7, xmm7
	addss	xmm8, xmm3
	addss	xmm8, xmm7
	ucomiss	xmm0, xmm8
	ja	SHORT $LN207@HandleTran
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm8
	jmp	SHORT $LN208@HandleTran
$LN207@HandleTran:
	movaps	xmm0, xmm8
	call	sqrtf
$LN208@HandleTran:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, xmm11
	movaps	xmm2, xmm9
	divss	xmm2, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movups	xmm0, XMMWORD PTR [rbx-8]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	shufps	xmm2, xmm2, 0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulps	xmm2, xmm0
	movups	XMMWORD PTR [rbx-8], xmm2

; 2186 :                -gContext.mCameraDir };
; 2187 : 
; 2188 :             vec_t cameraToModelNormalized = Normalized(gContext.mModel.v.position - gContext.mCameraEye);
; 2189 :             for (unsigned int i = 0; i < 3; i++)

	add	rbx, 16
	sub	rdi, 1
	jne	$LL4@HandleTran

; 2190 :             {
; 2191 :                vec_t orthoVector = Cross(movePlanNormal[i], cameraToModelNormalized);
; 2192 :                movePlanNormal[i].Cross(orthoVector);
; 2193 :                movePlanNormal[i].Normalize();
; 2194 :             }
; 2195 :             // pickup plan
; 2196 :             gContext.mTranslationPlan = BuildPlan(gContext.mModel.v.position, movePlanNormal[type - MT_MOVE_X]);

	movsxd	rbx, DWORD PTR [rsi]
	add	rbx, rbx

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm6, DWORD PTR movePlanNormal$14[rbp+rbx*8-272]
	movss	xmm7, DWORD PTR movePlanNormal$14[rbp+rbx*8-268]

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm6

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm8, DWORD PTR movePlanNormal$14[rbp+rbx*8-264]
	movaps	xmm2, xmm7
	mulss	xmm2, xmm7

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm8
	mulss	xmm0, xmm6
	mulss	xmm1, xmm8
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN205@HandleTran
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN206@HandleTran
$LN205@HandleTran:
	movaps	xmm0, xmm2
	call	sqrtf
$LN206@HandleTran:

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, xmm11

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movaps	xmm2, xmm9

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1024
	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1028

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1008
	movss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1004

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm2, xmm0

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm0, xmm15
	movss	xmm15, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+472

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mulss	xmm6, xmm2

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm7, xmm2
	mulss	xmm8, xmm2

; 2190 :             {
; 2191 :                vec_t orthoVector = Cross(movePlanNormal[i], cameraToModelNormalized);
; 2192 :                movePlanNormal[i].Cross(orthoVector);
; 2193 :                movePlanNormal[i].Normalize();
; 2194 :             }
; 2195 :             // pickup plan
; 2196 :             gContext.mTranslationPlan = BuildPlan(gContext.mModel.v.position, movePlanNormal[type - MT_MOVE_X]);

	movaps	xmm10, xmm6

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, DWORD PTR movePlanNormal$14[rbp+rbx*8-260]

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	mulss	xmm0, xmm6
	mulss	xmm1, xmm8

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm5, xmm7

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	mulss	xmm2, xmm15
	addss	xmm5, xmm0

; 2190 :             {
; 2191 :                vec_t orthoVector = Cross(movePlanNormal[i], cameraToModelNormalized);
; 2192 :                movePlanNormal[i].Cross(orthoVector);
; 2193 :                movePlanNormal[i].Normalize();
; 2194 :             }
; 2195 :             // pickup plan
; 2196 :             gContext.mTranslationPlan = BuildPlan(gContext.mModel.v.position, movePlanNormal[type - MT_MOVE_X]);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1088, xmm6

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movaps	xmm0, xmm7

; 2190 :             {
; 2191 :                vec_t orthoVector = Cross(movePlanNormal[i], cameraToModelNormalized);
; 2192 :                movePlanNormal[i].Cross(orthoVector);
; 2193 :                movePlanNormal[i].Normalize();
; 2194 :             }
; 2195 :             // pickup plan
; 2196 :             gContext.mTranslationPlan = BuildPlan(gContext.mModel.v.position, movePlanNormal[type - MT_MOVE_X]);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1092, xmm7

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm0, xmm3

; 2190 :             {
; 2191 :                vec_t orthoVector = Cross(movePlanNormal[i], cameraToModelNormalized);
; 2192 :                movePlanNormal[i].Cross(orthoVector);
; 2193 :                movePlanNormal[i].Normalize();
; 2194 :             }
; 2195 :             // pickup plan
; 2196 :             gContext.mTranslationPlan = BuildPlan(gContext.mModel.v.position, movePlanNormal[type - MT_MOVE_X]);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1096, xmm8

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	addss	xmm5, xmm1

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movaps	xmm1, xmm8
	mulss	xmm1, xmm4

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	addss	xmm5, xmm2

; 2190 :             {
; 2191 :                vec_t orthoVector = Cross(movePlanNormal[i], cameraToModelNormalized);
; 2192 :                movePlanNormal[i].Cross(orthoVector);
; 2193 :                movePlanNormal[i].Normalize();
; 2194 :             }
; 2195 :             // pickup plan
; 2196 :             gContext.mTranslationPlan = BuildPlan(gContext.mModel.v.position, movePlanNormal[type - MT_MOVE_X]);

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1020
	mulss	xmm10, xmm2

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	addss	xmm10, xmm0

; 2190 :             {
; 2191 :                vec_t orthoVector = Cross(movePlanNormal[i], cameraToModelNormalized);
; 2192 :                movePlanNormal[i].Cross(orthoVector);
; 2193 :                movePlanNormal[i].Normalize();
; 2194 :             }
; 2195 :             // pickup plan
; 2196 :             gContext.mTranslationPlan = BuildPlan(gContext.mModel.v.position, movePlanNormal[type - MT_MOVE_X]);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1100, xmm5

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	addss	xmm10, xmm1

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1012
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm0, xmm10
	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	comiss	xmm11, xmm0
	jbe	SHORT $LN69@HandleTran

; 911  :       {
; 912  :          return -1.0f;

	movss	xmm6, DWORD PTR __real@bf800000
	jmp	SHORT $LN68@HandleTran
$LN69@HandleTran:

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm6, xmm13
	mulss	xmm7, xmm12
	mulss	xmm8, xmm1
	addss	xmm6, xmm7
	addss	xmm6, xmm8

; 907  :       const float numer = plan.Dot3(rOrigin) - plan.w;

	subss	xmm6, xmm5

; 913  :       }
; 914  : 
; 915  :       return -(numer / denom);

	divss	xmm6, xmm10
	xorps	xmm6, xmm14
$LN68@HandleTran:

; 2200 : 
; 2201 :             gContext.mRelativeOrigin = (gContext.mTranslationPlanOrigin - gContext.mModel.v.position) * (1.f / gContext.mScreenFactor);

	divss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064
	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1032

; 2200 : 
; 2201 :             gContext.mRelativeOrigin = (gContext.mTranslationPlanOrigin - gContext.mModel.v.position) * (1.f / gContext.mScreenFactor);

	movaps	xmm14, XMMWORD PTR [rsp+320]

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm2, xmm6
	mulss	xmm3, xmm6
	mulss	xmm4, xmm6

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm2, xmm13

; 2200 : 
; 2201 :             gContext.mRelativeOrigin = (gContext.mTranslationPlanOrigin - gContext.mModel.v.position) * (1.f / gContext.mScreenFactor);

	movaps	xmm13, XMMWORD PTR [rsp+336]

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm3, xmm12

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm0, xmm6

; 2199 :             gContext.mMatrixOrigin = gContext.mModel.v.position;

	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm4, xmm1

; 2199 :             gContext.mMatrixOrigin = gContext.mModel.v.position;

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1016

; 2197 :             const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);
; 2198 :             gContext.mTranslationPlanOrigin = gContext.mRayOrigin + gContext.mRayVector * len;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1104, xmm2

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm2, xmm1

; 2197 :             const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);
; 2198 :             gContext.mTranslationPlanOrigin = gContext.mRayOrigin + gContext.mRayVector * len;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1108, xmm3

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm3, xmm5

; 2197 :             const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);
; 2198 :             gContext.mTranslationPlanOrigin = gContext.mRayOrigin + gContext.mRayVector * len;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1112, xmm4

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm4, xmm6

; 2199 :             gContext.mMatrixOrigin = gContext.mModel.v.position;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1132, xmm15
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1116, xmm0

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm0, xmm15

; 2200 : 
; 2201 :             gContext.mRelativeOrigin = (gContext.mTranslationPlanOrigin - gContext.mModel.v.position) * (1.f / gContext.mScreenFactor);

	movaps	xmm15, XMMWORD PTR [rsp+304]

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm2, xmm9
	mulss	xmm3, xmm9
	mulss	xmm4, xmm9
	mulss	xmm0, xmm9

; 2200 : 
; 2201 :             gContext.mRelativeOrigin = (gContext.mTranslationPlanOrigin - gContext.mModel.v.position) * (1.f / gContext.mScreenFactor);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1068, xmm2
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1072, xmm3
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1076, xmm4
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1080, xmm0
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1120, xmm1
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1124, xmm5
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1128, xmm6
$LN19@HandleTran:

; 2202 :          }
; 2203 :       }
; 2204 :       return modified;

	movaps	xmm12, XMMWORD PTR [rsp+352]
	movzx	eax, r14b
	mov	r14, QWORD PTR [rsp+504]
	movaps	xmm11, XMMWORD PTR [rsp+368]
	movaps	xmm10, XMMWORD PTR [rsp+384]
	movaps	xmm9, XMMWORD PTR [rsp+400]
	movaps	xmm8, XMMWORD PTR [rsp+416]
	movaps	xmm7, XMMWORD PTR [rsp+432]
	movaps	xmm6, XMMWORD PTR [rsp+448]
	mov	rbx, QWORD PTR [rsp+496]
	jmp	SHORT $LN1@HandleTran
$LN7@HandleTran:

; 2087 :        {
; 2088 :            return false;

	xor	al, al
$LN1@HandleTran:

; 2205 :    }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rsi, QWORD PTR [rsp+512]
	add	rsp, 464				; 000001d0H
	pop	r15
	pop	rdi
	pop	rbp
	ret	0
?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z ENDP ; ImGuizmo::HandleTranslation
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
_TEXT	SEGMENT
deltaMatrixScale$7 = 32
res$8 = 96
movePlanNormal$9 = 96
__$ArrayPad$ = 208
matrix$dead$ = 400
deltaMatrix$dead$ = 408
op$ = 416
type$ = 424
snap$dead$ = 432
?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z PROC ; ImGuizmo::HandleScale, COMDAT

; 2208 :    {

	push	rbp
	push	rbx
	push	rdi
	push	r15
	lea	rbp, QWORD PTR [rsp-104]
	sub	rsp, 360				; 00000168H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp

; 146  : 	if (WindowHovered)

	cmp	BYTE PTR ?CameraView@UIMapView@@3VCamera@@A+245, 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 2208 :    {

	mov	rdi, r9
	mov	ebx, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp

; 146  : 	if (WindowHovered)

	mov	r15d, 1
	je	SHORT $LN5@HandleScal

; 147  : 	{
; 148  : 		return (glfwGetMouseButton(pWindow, GLFW_MOUSE_BUTTON_RIGHT) == GLFW_PRESS && glfwGetMouseButton(pWindow, GLFW_MOUSE_BUTTON_LEFT) != GLFW_PRESS);

	mov	rcx, QWORD PTR ?CameraView@UIMapView@@3VCamera@@A+256
	mov	edx, r15d
	call	glfwGetMouseButton
	cmp	eax, r15d
	jne	SHORT $LN5@HandleScal
	mov	rcx, QWORD PTR ?CameraView@UIMapView@@3VCamera@@A+256
	xor	edx, edx
	call	glfwGetMouseButton
	cmp	eax, r15d
	jne	$LN7@HandleScal
$LN5@HandleScal:
	test	ebx, 15232				; 00003b80H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 2211 :       if((!Intersects(op, SCALE) && !Intersects(op, SCALEU)) || type != MT_NONE)

	je	$LN7@HandleScal
	cmp	DWORD PTR [rdi], 0
	jne	$LN7@HandleScal
	mov	QWORD PTR [rsp+400], rsi

; 2214 :       }
; 2215 : 
; 2216 :       ImGuiIO& io = ImGui::GetIO();

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR [rsp+352], r14

; 2217 :       bool modified = false;

	xor	r14b, r14b

; 2218 : 
; 2219 :       if (!gContext.mbUsing)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, r14b
	movaps	XMMWORD PTR [rsp+336], xmm6
	movss	xmm6, DWORD PTR __real@bf800000
	movaps	XMMWORD PTR [rsp+256], xmm11
	movaps	xmm11, XMMWORD PTR __xmm@80000000800000008000000080000000
	movaps	XMMWORD PTR [rsp+240], xmm12
	movss	xmm12, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	movaps	XMMWORD PTR [rsp+224], xmm13
	movss	xmm13, DWORD PTR __real@34000000
	mov	QWORD PTR [rsp+408], r12
	mov	QWORD PTR [rsp+416], r13
	movaps	XMMWORD PTR [rsp+320], xmm7
	movaps	XMMWORD PTR [rsp+304], xmm8
	movaps	XMMWORD PTR [rsp+288], xmm9
	movaps	XMMWORD PTR [rsp+272], xmm10
	jne	$LN229@HandleScal

; 2220 :       {
; 2221 :          // find new possible way to scale
; 2222 :          type = GetScaleType(op);

	mov	ecx, ebx
	call	?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z ; ImGuizmo::GetScaleType
	mov	DWORD PTR [rdi], eax

; 2223 :          if (type != MT_NONE)

	test	eax, eax
	je	SHORT $LN10@HandleScal

; 2224 :          {
; 2225 : #if IMGUI_VERSION_NUM >= 18723
; 2226 :             ImGui::SetNextFrameWantCaptureMouse(true);

	mov	DWORD PTR [rsi+24700], r15d
$LN10@HandleScal:

; 2227 : #else
; 2228 :             ImGui::CaptureMouseFromApp();
; 2229 : #endif
; 2230 :          }
; 2231 :          if (CanActivate() && type != MT_NONE)

	call	?CanActivate@ImGuizmo@@YA_NXZ		; ImGuizmo::CanActivate
	test	al, al
	je	$LN11@HandleScal
	cmp	DWORD PTR [rdi], 0
	je	$LN11@HandleScal

; 2236 :             const vec_t movePlanNormal[] = { gContext.mModel.v.up, gContext.mModel.v.dir, gContext.mModel.v.right, gContext.mModel.v.dir, gContext.mModel.v.up, gContext.mModel.v.right, -gContext.mCameraDir };

	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+444
	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, r15b
	movups	xmm2, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+428
	mov	r15d, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	mov	r12d, r15d
	movups	xmm1, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+412
	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440, r15d
	mov	r13d, DWORD PTR [rdi]
	movdqa	XMMWORD PTR movePlanNormal$9[rsp+16], xmm0
	movdqa	XMMWORD PTR movePlanNormal$9[rbp-208], xmm0

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+972

; 2232 :          {
; 2233 :             gContext.mbUsing = true;
; 2234 :             gContext.mEditingID = gContext.mActualID;
; 2235 :             gContext.mCurrentOperation = type;

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1400, r13d

; 2237 :             // pickup plan
; 2238 : 
; 2239 :             gContext.mTranslationPlan = BuildPlan(gContext.mModel.v.position, movePlanNormal[type - MT_SCALE_X]);

	movsxd	rbx, DWORD PTR [rdi]
	movdqa	XMMWORD PTR movePlanNormal$9[rsp], xmm2

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	xorps	xmm0, xmm11

; 2236 :             const vec_t movePlanNormal[] = { gContext.mModel.v.up, gContext.mModel.v.dir, gContext.mModel.v.right, gContext.mModel.v.dir, gContext.mModel.v.up, gContext.mModel.v.right, -gContext.mCameraDir };

	movdqa	XMMWORD PTR movePlanNormal$9[rbp-192], xmm2

; 2237 :             // pickup plan
; 2238 : 
; 2239 :             gContext.mTranslationPlan = BuildPlan(gContext.mModel.v.position, movePlanNormal[type - MT_SCALE_X]);

	sub	rbx, 12

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movaps	XMMWORD PTR movePlanNormal$9[rbp-160], xmm0

; 2237 :             // pickup plan
; 2238 : 
; 2239 :             gContext.mTranslationPlan = BuildPlan(gContext.mModel.v.position, movePlanNormal[type - MT_SCALE_X]);

	add	rbx, rbx
	movdqa	XMMWORD PTR movePlanNormal$9[rbp-224], xmm1
	movdqa	XMMWORD PTR movePlanNormal$9[rbp-176], xmm1

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm7, DWORD PTR movePlanNormal$9[rsp+rbx*8]
	movss	xmm8, DWORD PTR movePlanNormal$9[rsp+rbx*8+4]

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm7

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm9, DWORD PTR movePlanNormal$9[rsp+rbx*8+8]
	movaps	xmm2, xmm8
	mulss	xmm2, xmm8

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm9
	mulss	xmm0, xmm7
	mulss	xmm1, xmm9
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN227@HandleScal
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN228@HandleScal
$LN227@HandleScal:
	movaps	xmm0, xmm2
	call	sqrtf
$LN228@HandleScal:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	movss	xmm2, DWORD PTR __real@3f800000
	maxss	xmm0, xmm13

; 2237 :             // pickup plan
; 2238 : 
; 2239 :             gContext.mTranslationPlan = BuildPlan(gContext.mModel.v.position, movePlanNormal[type - MT_SCALE_X]);

	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1020

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1024
	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1028

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm2, xmm0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm8, xmm2
	mulss	xmm9, xmm2

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mulss	xmm7, xmm2

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm3, xmm8
	mulss	xmm2, DWORD PTR movePlanNormal$9[rsp+rbx*8+12]

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm1, xmm9
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+472

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464

; 2237 :             // pickup plan
; 2238 : 
; 2239 :             gContext.mTranslationPlan = BuildPlan(gContext.mModel.v.position, movePlanNormal[type - MT_SCALE_X]);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1088, xmm7
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1092, xmm8

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	addss	xmm3, xmm0

; 2237 :             // pickup plan
; 2238 : 
; 2239 :             gContext.mTranslationPlan = BuildPlan(gContext.mModel.v.position, movePlanNormal[type - MT_SCALE_X]);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1096, xmm9

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movaps	xmm0, xmm8
	mulss	xmm0, xmm5

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	addss	xmm3, xmm1

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movaps	xmm1, xmm9
	mulss	xmm1, xmm10

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	addss	xmm3, xmm2

; 2237 :             // pickup plan
; 2238 : 
; 2239 :             gContext.mTranslationPlan = BuildPlan(gContext.mModel.v.position, movePlanNormal[type - MT_SCALE_X]);

	movaps	xmm2, xmm7
	mulss	xmm2, xmm4

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	addss	xmm2, xmm0

; 2237 :             // pickup plan
; 2238 : 
; 2239 :             gContext.mTranslationPlan = BuildPlan(gContext.mModel.v.position, movePlanNormal[type - MT_SCALE_X]);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1100, xmm3

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	addss	xmm2, xmm1

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1012
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm0, xmm2
	andps	xmm0, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	comiss	xmm13, xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1004
	jbe	SHORT $LN154@HandleScal

; 911  :       {
; 912  :          return -1.0f;

	movaps	xmm7, xmm6
	jmp	SHORT $LN153@HandleScal
$LN154@HandleScal:

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1008
	mulss	xmm7, xmm0
	mulss	xmm9, xmm1
	addss	xmm7, xmm8
	addss	xmm7, xmm9

; 907  :       const float numer = plan.Dot3(rOrigin) - plan.w;

	subss	xmm7, xmm3

; 913  :       }
; 914  : 
; 915  :       return -(numer / denom);

	divss	xmm7, xmm2
	xorps	xmm7, xmm11
$LN153@HandleScal:

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+604

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm4, xmm7

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1176, 1065353216 ; 3f800000H

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm10, xmm7

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1180, 1065353216 ; 3f800000H

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm4, xmm0

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm5, xmm7

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	mov	QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1184, 1065353216 ; 3f800000H

; 2242 :             gContext.mMatrixOrigin = gContext.mModel.v.position;

	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm10, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	mulss	xmm2, xmm2

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1008

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1032

; 2242 :             gContext.mMatrixOrigin = gContext.mModel.v.position;

	movdqa	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1120, xmm0

; 2243 :             gContext.mScale.Set(1.f, 1.f, 1.f);
; 2244 :             gContext.mRelativeOrigin = (gContext.mTranslationPlanOrigin - gContext.mModel.v.position) * (1.f / gContext.mScreenFactor);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm1, xmm7

; 2240 :             const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);
; 2241 :             gContext.mTranslationPlanOrigin = gContext.mRayOrigin + gContext.mRayVector * len;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1104, xmm4

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1016

; 2240 :             const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);
; 2241 :             gContext.mTranslationPlanOrigin = gContext.mRayOrigin + gContext.mRayVector * len;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1108, xmm5

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464

; 2240 :             const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);
; 2241 :             gContext.mTranslationPlanOrigin = gContext.mRayOrigin + gContext.mRayVector * len;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1112, xmm10

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468

; 2240 :             const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);
; 2241 :             gContext.mTranslationPlanOrigin = gContext.mRayOrigin + gContext.mRayVector * len;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1116, xmm1

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+472

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm4, xmm0
	mulss	xmm5, xmm0
	mulss	xmm1, xmm0
	mulss	xmm10, xmm0

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+608
	mulss	xmm0, xmm0

; 2243 :             gContext.mScale.Set(1.f, 1.f, 1.f);
; 2244 :             gContext.mRelativeOrigin = (gContext.mTranslationPlanOrigin - gContext.mModel.v.position) * (1.f / gContext.mScreenFactor);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1080, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+612
	addss	xmm2, xmm0
	mulss	xmm1, xmm1
	xorps	xmm0, xmm0

; 2243 :             gContext.mScale.Set(1.f, 1.f, 1.f);
; 2244 :             gContext.mRelativeOrigin = (gContext.mTranslationPlanOrigin - gContext.mModel.v.position) * (1.f / gContext.mScreenFactor);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1068, xmm4
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1072, xmm5
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1076, xmm10

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN225@HandleScal
	xorps	xmm8, xmm8
	sqrtss	xmm8, xmm2
	jmp	SHORT $LN226@HandleScal
$LN225@HandleScal:
	movaps	xmm0, xmm2
	call	sqrtf
	movaps	xmm8, xmm0
$LN226@HandleScal:
	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+620
	xorps	xmm0, xmm0
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+624
	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+628
	mulss	xmm3, xmm3
	mulss	xmm1, xmm1
	mulss	xmm2, xmm2
	addss	xmm3, xmm1
	addss	xmm3, xmm2
	ucomiss	xmm0, xmm3
	ja	SHORT $LN223@HandleScal
	xorps	xmm7, xmm7
	sqrtss	xmm7, xmm3
	jmp	SHORT $LN224@HandleScal
$LN223@HandleScal:
	movaps	xmm0, xmm3
	call	sqrtf
	movaps	xmm7, xmm0
$LN224@HandleScal:
	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+636
	xorps	xmm0, xmm0
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+640
	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+644
	mulss	xmm3, xmm3
	mulss	xmm1, xmm1
	mulss	xmm2, xmm2
	addss	xmm3, xmm1
	addss	xmm3, xmm2
	ucomiss	xmm0, xmm3
	ja	SHORT $LN221@HandleScal
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm3
	jmp	SHORT $LN222@HandleScal
$LN221@HandleScal:
	movaps	xmm0, xmm3
	call	sqrtf
$LN222@HandleScal:

; 2245 :             gContext.mScaleValueOrigin = makeVect(gContext.mModelSource.v.right.Length(), gContext.mModelSource.v.up.Length(), gContext.mModelSource.v.dir.Length());
; 2246 :             gContext.mSaveMousePosx = io.MousePos.x;
; 2247 :          }
; 2248 :       }
; 2249 :       // scale
; 2250 :       if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID) && IsScaleType(gContext.mCurrentOperation))

	movss	xmm12, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1192, xmm8
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1196, xmm7
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1200, xmm0
	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1204, 0
	movss	xmm0, DWORD PTR [rsi+3592]
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1224, xmm0
	jmp	SHORT $LN218@HandleScal
$LN11@HandleScal:
	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, r14b
	je	$LN12@HandleScal
$LN229@HandleScal:

; 2218 : 
; 2219 :       if (!gContext.mbUsing)

	mov	r12d, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440
	mov	r15d, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	mov	r13d, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1400
$LN218@HandleScal:

; 2245 :             gContext.mScaleValueOrigin = makeVect(gContext.mModelSource.v.right.Length(), gContext.mModelSource.v.up.Length(), gContext.mModelSource.v.dir.Length());
; 2246 :             gContext.mSaveMousePosx = io.MousePos.x;
; 2247 :          }
; 2248 :       }
; 2249 :       // scale
; 2250 :       if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID) && IsScaleType(gContext.mCurrentOperation))

	cmp	r15d, -1
	je	SHORT $LN13@HandleScal
	cmp	r15d, r12d
	jne	$LN12@HandleScal
$LN13@HandleScal:

; 633  :      return type >= MT_SCALE_X && type <= MT_SCALE_XYZ;

	lea	eax, DWORD PTR [r13-12]

; 2245 :             gContext.mScaleValueOrigin = makeVect(gContext.mModelSource.v.right.Length(), gContext.mModelSource.v.up.Length(), gContext.mModelSource.v.dir.Length());
; 2246 :             gContext.mSaveMousePosx = io.MousePos.x;
; 2247 :          }
; 2248 :       }
; 2249 :       // scale
; 2250 :       if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID) && IsScaleType(gContext.mCurrentOperation))

	cmp	eax, 3
	ja	$LN12@HandleScal

; 2251 :       {
; 2252 : #if IMGUI_VERSION_NUM >= 18723
; 2253 :          ImGui::SetNextFrameWantCaptureMouse(true);

	mov	edx, 1
	mov	DWORD PTR [rsi+24700], edx

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1020
	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1024
	movaps	xmm2, xmm3
	movss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1088
	movaps	xmm0, xmm5
	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1092
	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1028
	movss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1096
	movaps	xmm1, xmm10

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1012

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	mulss	xmm2, xmm8
	mulss	xmm0, xmm4
	mulss	xmm1, xmm7
	addss	xmm2, xmm0
	addss	xmm2, xmm1

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1004
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm0, xmm2
	andps	xmm0, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1008
	comiss	xmm13, xmm0
	ja	SHORT $LN104@HandleScal

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movaps	xmm6, xmm8
	mulss	xmm4, xmm12
	mulss	xmm6, xmm1
	mulss	xmm7, xmm9
	addss	xmm6, xmm4
	addss	xmm6, xmm7

; 907  :       const float numer = plan.Dot3(rOrigin) - plan.w;

	subss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1100

; 913  :       }
; 914  : 
; 915  :       return -(numer / denom);

	divss	xmm6, xmm2
	xorps	xmm6, xmm11
$LN104@HandleScal:

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1068

; 2254 : #else
; 2255 :          ImGui::CaptureMouseFromApp();
; 2256 : #endif
; 2257 :          const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);
; 2258 :          vec_t newPos = gContext.mRayOrigin + gContext.mRayVector * len;
; 2259 :          vec_t newOrigin = newPos - gContext.mRelativeOrigin * gContext.mScreenFactor;
; 2260 :          vec_t delta = newOrigin - gContext.mModelLocal.v.position;
; 2261 : 
; 2262 :          // 1 axis constraint
; 2263 :          if (gContext.mCurrentOperation >= MT_SCALE_X && gContext.mCurrentOperation <= MT_SCALE_Z)

	lea	r10, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+476
	mov	r9d, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1400

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+524
	movss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+528

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm3, xmm6

; 2254 : #else
; 2255 :          ImGui::CaptureMouseFromApp();
; 2256 : #endif
; 2257 :          const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);
; 2258 :          vec_t newPos = gContext.mRayOrigin + gContext.mRayVector * len;
; 2259 :          vec_t newOrigin = newPos - gContext.mRelativeOrigin * gContext.mScreenFactor;
; 2260 :          vec_t delta = newOrigin - gContext.mModelLocal.v.position;
; 2261 : 
; 2262 :          // 1 axis constraint
; 2263 :          if (gContext.mCurrentOperation >= MT_SCALE_X && gContext.mCurrentOperation <= MT_SCALE_Z)

	lea	eax, DWORD PTR [r9-12]

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm5, xmm6
	mulss	xmm10, xmm6

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm3, xmm1

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1064

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm5, xmm12

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm12, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+532

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm0, xmm1

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm10, xmm9

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm3, xmm0

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1072
	mulss	xmm0, xmm1

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm5, xmm0

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1076
	mulss	xmm0, xmm1

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm3, xmm2
	subss	xmm10, xmm0
	subss	xmm5, xmm11
	subss	xmm10, xmm12

; 2254 : #else
; 2255 :          ImGui::CaptureMouseFromApp();
; 2256 : #endif
; 2257 :          const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);
; 2258 :          vec_t newPos = gContext.mRayOrigin + gContext.mRayVector * len;
; 2259 :          vec_t newOrigin = newPos - gContext.mRelativeOrigin * gContext.mScreenFactor;
; 2260 :          vec_t delta = newOrigin - gContext.mModelLocal.v.position;
; 2261 : 
; 2262 :          // 1 axis constraint
; 2263 :          if (gContext.mCurrentOperation >= MT_SCALE_X && gContext.mCurrentOperation <= MT_SCALE_Z)

	cmp	eax, 2
	ja	$LN14@HandleScal

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1104
	subss	xmm6, xmm2

; 2264 :          {
; 2265 :             int axisIndex = gContext.mCurrentOperation - MT_SCALE_X;
; 2266 :             const vec_t& axisValue = *(vec_t*)&gContext.mModelLocal.m[axisIndex];

	movsxd	rcx, eax

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1108

; 2264 :          {
; 2265 :             int axisIndex = gContext.mCurrentOperation - MT_SCALE_X;
; 2266 :             const vec_t& axisValue = *(vec_t*)&gContext.mModelLocal.m[axisIndex];

	mov	rax, rcx
	add	rax, rax

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm2, xmm11

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	movss	xmm8, DWORD PTR [r10+rax*8+4]
	movss	xmm7, DWORD PTR [r10+rax*8]
	movaps	xmm4, xmm8
	movss	xmm9, DWORD PTR [r10+rax*8+8]
	movaps	xmm0, xmm7
	mulss	xmm4, xmm5

; 267  :       float& operator [] (size_t index) { return ((float*)&x)[index]; }

	lea	rax, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	mulss	xmm0, xmm3
	movaps	xmm1, xmm9

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1112

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movaps	xmm5, xmm7

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	mulss	xmm1, xmm10

; 276  :    vec_t vec_t::operator - (const vec_t& v) const { return makeVect(x - v.x, y - v.y, z - v.z, w - v.w); }

	subss	xmm3, xmm12

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	addss	xmm4, xmm0

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movaps	xmm0, xmm8

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	addss	xmm4, xmm1

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movaps	xmm1, xmm9
	mulss	xmm5, xmm4
	mulss	xmm0, xmm4

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm5, xmm6

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm1, xmm4

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm0, xmm2

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	mulss	xmm6, xmm7

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm1, xmm3

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	mulss	xmm2, xmm8
	mulss	xmm5, xmm7
	mulss	xmm0, xmm8
	addss	xmm6, xmm2
	mulss	xmm1, xmm9
	addss	xmm5, xmm0
	mulss	xmm3, xmm9

; 189  :    template <typename T> T max(T x, T y) { return (x > y) ? x : y; }

	movss	xmm0, DWORD PTR __real@3a83126f

; 294  :       return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);

	addss	xmm6, xmm3
	addss	xmm5, xmm1

; 2267 :             float lengthOnAxis = Dot(axisValue, delta);
; 2268 :             delta = axisValue * lengthOnAxis;
; 2269 : 
; 2270 :             vec_t baseVector = gContext.mTranslationPlanOrigin - gContext.mModelLocal.v.position;
; 2271 :             float ratio = Dot(axisValue, baseVector + delta) / Dot(axisValue, baseVector);

	divss	xmm5, xmm6

; 189  :    template <typename T> T max(T x, T y) { return (x > y) ? x : y; }

	maxss	xmm5, xmm0

; 2272 : 
; 2273 :             gContext.mScale[axisIndex] = max(ratio, 0.001f);

	movss	DWORD PTR [rax+rcx*4+1176], xmm5

; 2274 :          }

	mov	r9d, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1400
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1184
	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1180
	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1176
	jmp	SHORT $LL16@HandleScal
$LN14@HandleScal:

; 2275 :          else
; 2276 :          {
; 2277 :             float scaleDelta = (io.MousePos.x - gContext.mSaveMousePosx) * 0.01f;

	movss	xmm1, DWORD PTR [rsi+3592]
	subss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1224

; 189  :    template <typename T> T max(T x, T y) { return (x > y) ? x : y; }

	movss	xmm0, DWORD PTR __real@3a83126f

; 2275 :          else
; 2276 :          {
; 2277 :             float scaleDelta = (io.MousePos.x - gContext.mSaveMousePosx) * 0.01f;

	mulss	xmm1, DWORD PTR __real@3c23d70a

; 2278 :             gContext.mScale.Set(max(1.f + scaleDelta, 0.001f));

	addss	xmm1, DWORD PTR __real@3f800000

; 189  :    template <typename T> T max(T x, T y) { return (x > y) ? x : y; }

	maxss	xmm1, xmm0

; 207  :       void Set(float v) { x = y = z = w = v; }

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1188, xmm1
	movaps	xmm3, xmm1
	movaps	xmm2, xmm1
	npad	10
$LL16@HandleScal:

; 269  :       bool operator!=(const vec_t& other) const { return memcmp(this, &other, sizeof(vec_t)) != 0; }

	mov	rax, QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1208

; 189  :    template <typename T> T max(T x, T y) { return (x > y) ? x : y; }

	maxss	xmm2, xmm0
	maxss	xmm3, xmm0
	maxss	xmm1, xmm0

; 2279 :          }
; 2280 : 
; 2281 :          // snap
; 2282 :          if (snap)
; 2283 :          {
; 2284 :             float scaleSnap[] = { snap[0], snap[0], snap[0] };
; 2285 :             ComputeSnap(gContext.mScale, scaleSnap);
; 2286 :          }
; 2287 : 
; 2288 :          // no 0 allowed
; 2289 :          for (int i = 0; i < 3; i++)
; 2290 :             gContext.mScale[i] = max(gContext.mScale[i], 0.001f);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1176, xmm2
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1180, xmm3

; 269  :       bool operator!=(const vec_t& other) const { return memcmp(this, &other, sizeof(vec_t)) != 0; }

	sub	rax, QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1176

; 2279 :          }
; 2280 : 
; 2281 :          // snap
; 2282 :          if (snap)
; 2283 :          {
; 2284 :             float scaleSnap[] = { snap[0], snap[0], snap[0] };
; 2285 :             ComputeSnap(gContext.mScale, scaleSnap);
; 2286 :          }
; 2287 : 
; 2288 :          // no 0 allowed
; 2289 :          for (int i = 0; i < 3; i++)
; 2290 :             gContext.mScale[i] = max(gContext.mScale[i], 0.001f);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1184, xmm1

; 269  :       bool operator!=(const vec_t& other) const { return memcmp(this, &other, sizeof(vec_t)) != 0; }

	jne	SHORT $LN220@HandleScal
	mov	rax, QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1216
	sub	rax, QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1184
$LN220@HandleScal:

; 2293 :          {
; 2294 :             modified = true;
; 2295 :          }
; 2296 :          gContext.mScaleLast = gContext.mScale;

	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1176

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	r8, QWORD PTR res$8[rsp]

; 269  :       bool operator!=(const vec_t& other) const { return memcmp(this, &other, sizeof(vec_t)) != 0; }

	test	rax, rax

; 2293 :          {
; 2294 :             modified = true;
; 2295 :          }
; 2296 :          gContext.mScaleLast = gContext.mScale;

	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1192

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	rcx, QWORD PTR deltaMatrixScale$7[rsp]

; 2291 : 
; 2292 :          if (gContext.mScaleLast != gContext.mScale)

	movzx	r14d, r14b

; 2293 :          {
; 2294 :             modified = true;
; 2295 :          }
; 2296 :          gContext.mScaleLast = gContext.mScale;

	movups	XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1208, xmm0
	cmovne	r14d, edx

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	mov	rdx, r10

; 278  :    vec_t vec_t::operator * (const vec_t& v) const { return makeVect(x * v.x, y * v.y, z * v.z, w * v.w); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1196
	mulss	xmm0, xmm3

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	mov	QWORD PTR deltaMatrixScale$7[rsp+4], 0
	movss	DWORD PTR deltaMatrixScale$7[rsp], xmm2
	mov	QWORD PTR deltaMatrixScale$7[rsp+12], 0
	movss	DWORD PTR deltaMatrixScale$7[rsp+20], xmm0

; 278  :    vec_t vec_t::operator * (const vec_t& v) const { return makeVect(x * v.x, y * v.y, z * v.z, w * v.w); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1200
	mulss	xmm0, xmm1

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	mov	QWORD PTR deltaMatrixScale$7[rsp+24], 0
	mov	QWORD PTR deltaMatrixScale$7[rsp+32], 0
	mov	DWORD PTR deltaMatrixScale$7[rsp+44], 0
	movss	DWORD PTR deltaMatrixScale$7[rsp+40], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f800000000000000000000000000000
	movaps	XMMWORD PTR deltaMatrixScale$7[rsp+48], xmm0

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	call	?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z ; ImGuizmo::FPU_MatrixF_x_MatrixF

; 2297 : 
; 2298 :          // compute matrix & delta
; 2299 :          matrix_t deltaMatrixScale;
; 2300 :          deltaMatrixScale.Scale(gContext.mScale * gContext.mScaleValueOrigin);
; 2301 : 
; 2302 :          matrix_t res = deltaMatrixScale * gContext.mModelLocal;
; 2303 :          *(matrix_t*)matrix = res;

	movaps	xmm0, XMMWORD PTR res$8[rsp]
	movaps	xmm1, XMMWORD PTR res$8[rsp+16]
	movaps	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA, xmm0
	movaps	xmm0, XMMWORD PTR res$8[rbp-224]
	movaps	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+16, xmm1
	movaps	xmm1, XMMWORD PTR res$8[rbp-208]
	movaps	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+32, xmm0
	movaps	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+48, xmm1

; 2304 : 
; 2305 :          if (deltaMatrix)
; 2306 :          {
; 2307 :             vec_t deltaScale = gContext.mScale * gContext.mScaleValueOrigin;
; 2308 : 
; 2309 :             vec_t originalScaleDivider;
; 2310 :             originalScaleDivider.x = 1 / gContext.mModelScaleOrigin.x;
; 2311 :             originalScaleDivider.y = 1 / gContext.mModelScaleOrigin.y;
; 2312 :             originalScaleDivider.z = 1 / gContext.mModelScaleOrigin.z;
; 2313 : 
; 2314 :             deltaScale = deltaScale * originalScaleDivider;
; 2315 : 
; 2316 :             deltaMatrixScale.Scale(deltaScale);
; 2317 :             memcpy(deltaMatrix, deltaMatrixScale.m16, sizeof(float) * 16);
; 2318 :          }
; 2319 : 
; 2320 :          if (!io.MouseDown[0])

	cmp	BYTE PTR [rsi+3600], 0
	jne	SHORT $LN19@HandleScal

; 2321 :          {
; 2322 :             gContext.mbUsing = false;

	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1176, 1065353216 ; 3f800000H
	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1180, 1065353216 ; 3f800000H
	mov	QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1184, 1065353216 ; 3f800000H
$LN19@HandleScal:

; 2323 :             gContext.mScale.Set(1.f, 1.f, 1.f);
; 2324 :          }
; 2325 : 
; 2326 :          type = gContext.mCurrentOperation;

	mov	DWORD PTR [rdi], r9d
$LN12@HandleScal:

; 2327 :       }
; 2328 :       return modified;

	movaps	xmm13, XMMWORD PTR [rsp+224]
	movzx	eax, r14b
	mov	r14, QWORD PTR [rsp+352]
	movaps	xmm12, XMMWORD PTR [rsp+240]
	movaps	xmm11, XMMWORD PTR [rsp+256]
	movaps	xmm10, XMMWORD PTR [rsp+272]
	movaps	xmm9, XMMWORD PTR [rsp+288]
	movaps	xmm8, XMMWORD PTR [rsp+304]
	movaps	xmm7, XMMWORD PTR [rsp+320]
	movaps	xmm6, XMMWORD PTR [rsp+336]
	mov	r13, QWORD PTR [rsp+416]
	mov	r12, QWORD PTR [rsp+408]
	mov	rsi, QWORD PTR [rsp+400]
	jmp	SHORT $LN1@HandleScal
$LN7@HandleScal:

; 2212 :       {
; 2213 :           return false;

	xor	al, al
$LN1@HandleScal:

; 2329 :    }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 360				; 00000168H
	pop	r15
	pop	rdi
	pop	rbx
	pop	rbp
	ret	0
?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z ENDP ; ImGuizmo::HandleScale
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z
_TEXT	SEGMENT
modified$1$ = 32
rotationAxisLocalSpace$3 = 40
$T4 = 56
$T5 = 56
$T6 = 120
deltaRotation$7 = 192
res$8 = 256
scaleOrigin$9 = 256
rotatePlanNormal$10 = 256
__$ArrayPad$ = 320
matrix$dead$ = 544
deltaMatrix$dead$ = 552
op$ = 560
type$ = 568
snap$dead$ = 576
?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z PROC ; ImGuizmo::HandleRotation, COMDAT

; 2332 :    {

	push	rbp
	push	rbx
	push	rdi
	push	r14
	lea	rbp, QWORD PTR [rsp-248]
	sub	rsp, 504				; 000001f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp

; 146  : 	if (WindowHovered)

	cmp	BYTE PTR ?CameraView@UIMapView@@3VCamera@@A+245, 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 2332 :    {

	mov	rdi, r9
	mov	ebx, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp

; 146  : 	if (WindowHovered)

	mov	r14d, 1
	je	SHORT $LN2@HandleRota

; 147  : 	{
; 148  : 		return (glfwGetMouseButton(pWindow, GLFW_MOUSE_BUTTON_RIGHT) == GLFW_PRESS && glfwGetMouseButton(pWindow, GLFW_MOUSE_BUTTON_LEFT) != GLFW_PRESS);

	mov	rcx, QWORD PTR ?CameraView@UIMapView@@3VCamera@@A+256
	mov	edx, r14d
	call	glfwGetMouseButton
	cmp	eax, r14d
	jne	SHORT $LN2@HandleRota
	mov	rcx, QWORD PTR ?CameraView@UIMapView@@3VCamera@@A+256
	xor	edx, edx
	call	glfwGetMouseButton
	cmp	eax, r14d
	jne	$LN4@HandleRota
$LN2@HandleRota:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	bl, 120					; 00000078H

; 2333 :        if (UIMapView::IsInCameraMovement()) return false;
; 2334 : 
; 2335 :       if(!Intersects(op, ROTATE) || type != MT_NONE)

	je	$LN4@HandleRota
	cmp	DWORD PTR [rdi], 0
	jne	$LN4@HandleRota

; 2338 :       }
; 2339 :       ImGuiIO& io = ImGui::GetIO();
; 2340 :       bool applyRotationLocaly = gContext.mMode == LOCAL;

	cmp	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+280, 0
	mov	QWORD PTR [rsp+544], rsi
	mov	QWORD PTR [rsp+552], r12
	sete	sil

; 2341 :       bool modified = false;
; 2342 : 
; 2343 :       if (!gContext.mbUsing)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	mov	r12, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movaps	XMMWORD PTR [rsp+384], xmm12
	movss	xmm12, DWORD PTR __real@3f800000
	movaps	XMMWORD PTR [rsp+336], xmm15
	movss	xmm15, DWORD PTR __real@34000000
	mov	QWORD PTR [rsp+560], r13
	mov	QWORD PTR [rsp+496], r15
	movaps	XMMWORD PTR [rsp+480], xmm6
	movaps	XMMWORD PTR [rsp+464], xmm7
	movaps	XMMWORD PTR [rsp+448], xmm8
	movaps	XMMWORD PTR [rsp+432], xmm9
	movaps	XMMWORD PTR [rsp+416], xmm10
	movaps	XMMWORD PTR [rsp+400], xmm11
	movaps	XMMWORD PTR [rsp+368], xmm13
	mov	BYTE PTR modified$1$[rsp], 0
	jne	$LN211@HandleRota

; 2344 :       {
; 2345 :          type = GetRotateType(op);

	mov	ecx, ebx
	call	?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z ; ImGuizmo::GetRotateType
	mov	DWORD PTR [rdi], eax

; 2346 : 
; 2347 :          if (type != MT_NONE)

	test	eax, eax
	je	SHORT $LN6@HandleRota

; 2348 :          {
; 2349 : #if IMGUI_VERSION_NUM >= 18723
; 2350 :             ImGui::SetNextFrameWantCaptureMouse(true);

	mov	DWORD PTR [r12+24700], r14d
$LN6@HandleRota:

; 2351 : #else
; 2352 :             ImGui::CaptureMouseFromApp();
; 2353 : #endif
; 2354 :          }
; 2355 : 
; 2356 :          if (type == MT_ROTATE_SCREEN)

	mov	r11d, DWORD PTR [rdi]
	cmp	r11d, 11
	movzx	esi, sil
	cmove	esi, r14d

; 2357 :          {
; 2358 :             applyRotationLocaly = true;
; 2359 :          }
; 2360 : 
; 2361 :          if (CanActivate() && type != MT_NONE)

	call	?CanActivate@ImGuizmo@@YA_NXZ		; ImGuizmo::CanActivate
	test	al, al
	je	$LN8@HandleRota
	test	r11d, r11d
	je	$LN8@HandleRota

; 2366 :             const vec_t rotatePlanNormal[] = { gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir, -gContext.mCameraDir };

	movups	xmm1, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+428
	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, r14b
	mov	r14d, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	mov	r15d, r14d
	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+412
	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440, r14d
	mov	r13d, DWORD PTR [rdi]
	movdqa	XMMWORD PTR rotatePlanNormal$10[rbp-240], xmm1

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movups	xmm1, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+972

; 2362 :          {
; 2363 :             gContext.mbUsing = true;
; 2364 :             gContext.mEditingID = gContext.mActualID;
; 2365 :             gContext.mCurrentOperation = type;

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1400, r13d

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movsxd	rbx, DWORD PTR [rdi]
	sub	rbx, 8

; 2357 :          {
; 2358 :             applyRotationLocaly = true;
; 2359 :          }
; 2360 : 
; 2361 :          if (CanActivate() && type != MT_NONE)

	movaps	XMMWORD PTR [rsp+352], xmm14

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	movaps	xmm14, XMMWORD PTR __xmm@80000000800000008000000080000000
	add	rbx, rbx

; 2366 :             const vec_t rotatePlanNormal[] = { gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir, -gContext.mCameraDir };

	movdqa	XMMWORD PTR rotatePlanNormal$10[rbp-256], xmm0

; 275  :    vec_t vec_t::operator - () const { return makeVect(-x, -y, -z, -w); }

	xorps	xmm1, xmm14
	movaps	XMMWORD PTR rotatePlanNormal$10[rbp-208], xmm1

; 2366 :             const vec_t rotatePlanNormal[] = { gContext.mModel.v.right, gContext.mModel.v.up, gContext.mModel.v.dir, -gContext.mCameraDir };

	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+444
	movdqa	XMMWORD PTR rotatePlanNormal$10[rbp-224], xmm0

; 2367 :             // pickup plan
; 2368 :             if (applyRotationLocaly)

	test	sil, sil
	je	$LN9@HandleRota

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm7, DWORD PTR rotatePlanNormal$10[rbp+rbx*8-256]
	movss	xmm8, DWORD PTR rotatePlanNormal$10[rbp+rbx*8-252]

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm7

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm9, DWORD PTR rotatePlanNormal$10[rbp+rbx*8-248]
	movaps	xmm2, xmm8
	mulss	xmm2, xmm8

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm9
	mulss	xmm0, xmm7
	mulss	xmm1, xmm9
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN209@HandleRota
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN210@HandleRota
$LN209@HandleRota:
	movaps	xmm0, xmm2
	call	sqrtf
$LN210@HandleRota:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, xmm15
	movaps	xmm2, xmm12
	divss	xmm2, xmm0
	mulss	xmm7, xmm2

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm8, xmm2
	mulss	xmm9, xmm2

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm0, xmm7

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, DWORD PTR rotatePlanNormal$10[rbp+rbx*8-244]
	movaps	xmm3, xmm8
	mulss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm1, xmm9
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+472

; 2369 :             {
; 2370 :                gContext.mTranslationPlan = BuildPlan(gContext.mModel.v.position, rotatePlanNormal[type - MT_ROTATE_X]);
; 2371 :             }

	jmp	$LN231@HandleRota
$LN9@HandleRota:

; 2372 :             else
; 2373 :             {
; 2374 :                gContext.mTranslationPlan = BuildPlan(gContext.mModelSource.v.position, directionUnary[type - MT_ROTATE_X]);

	lea	rax, OFFSET FLAT:?directionUnary@ImGuizmo@@3QBUvec_t@1@B

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm7, DWORD PTR [rax+rbx*8]
	movss	xmm8, DWORD PTR [rax+rbx*8+4]

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm7

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm9, DWORD PTR [rax+rbx*8+8]
	movaps	xmm2, xmm8
	mulss	xmm2, xmm8

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm9
	mulss	xmm0, xmm7
	mulss	xmm1, xmm9
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN207@HandleRota
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN208@HandleRota
$LN207@HandleRota:
	movaps	xmm0, xmm2
	call	sqrtf
	lea	rax, OFFSET FLAT:?directionUnary@ImGuizmo@@3QBUvec_t@1@B
$LN208@HandleRota:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, xmm15
	movaps	xmm2, xmm12
	divss	xmm2, xmm0
	mulss	xmm7, xmm2

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm8, xmm2
	mulss	xmm9, xmm2

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm0, xmm7

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm2, DWORD PTR [rax+rbx*8+12]
	movaps	xmm3, xmm8
	mulss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+656

; 251  :          return (x * v.x) + (y * v.y) + (z * v.z) + (w * v.w);

	movaps	xmm1, xmm9
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+652
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+660
	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+664
$LN231@HandleRota:

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1020
	addss	xmm3, xmm0
	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1024
	movss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1028
	movaps	xmm0, xmm10

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm4, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1012
	movss	xmm5, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1008

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	addss	xmm3, xmm1
	mulss	xmm0, xmm8
	movaps	xmm1, xmm11
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1096, xmm9
	mulss	xmm1, xmm9
	addss	xmm3, xmm2
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1092, xmm8
	movaps	xmm2, xmm13
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1088, xmm7
	mulss	xmm2, xmm7
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1100, xmm3
	addss	xmm2, xmm0
	addss	xmm2, xmm1

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1004
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movaps	xmm0, xmm2
	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 910  :       if (fabsf(denom) < FLT_EPSILON)  // normal is orthogonal to vector, cant intersect

	comiss	xmm15, xmm0
	jbe	SHORT $LN70@HandleRota

; 911  :       {
; 912  :          return -1.0f;

	movss	xmm6, DWORD PTR __real@bf800000
	jmp	SHORT $LN69@HandleRota
$LN70@HandleRota:

; 256  :          return (x * v.x) + (y * v.y) + (z * v.z);

	movaps	xmm6, xmm1
	movaps	xmm0, xmm5
	mulss	xmm6, xmm7
	movaps	xmm1, xmm4
	mulss	xmm1, xmm9
	mulss	xmm0, xmm8
	addss	xmm6, xmm0
	addss	xmm6, xmm1

; 915  :       return -(numer / denom);

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1004
	subss	xmm6, xmm3
	divss	xmm6, xmm2
	xorps	xmm6, xmm14
$LN69@HandleRota:

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm14, XMMWORD PTR [rsp+352]

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm13, xmm6
	mulss	xmm10, xmm6

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm13, xmm1

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	mulss	xmm11, xmm6

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm10, xmm5
	addss	xmm11, xmm4

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	subss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+460
	subss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+464
	subss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+468
	movaps	xmm0, xmm13
	mulss	xmm0, xmm13

; 281  :    vec_t Normalized(const vec_t& v) { vec_t res; res = v; res.Normalize(); return res; }

	movaps	xmm2, xmm10
	mulss	xmm2, xmm10

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm11
	mulss	xmm1, xmm11
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN205@HandleRota
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN206@HandleRota
$LN205@HandleRota:
	movaps	xmm0, xmm2
	call	sqrtf
$LN206@HandleRota:

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, xmm15
	movaps	xmm1, xmm12
	divss	xmm1, xmm0
	movaps	xmm0, xmm1

; 2375 :             }
; 2376 : 
; 2377 :             const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);
; 2378 :             vec_t localPos = gContext.mRayOrigin + gContext.mRayVector * len - gContext.mModel.v.position;
; 2379 :             gContext.mRotationVectorSource = Normalized(localPos);

	mulss	xmm10, xmm1

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	mulss	xmm0, xmm13

; 2375 :             }
; 2376 : 
; 2377 :             const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);
; 2378 :             vec_t localPos = gContext.mRayOrigin + gContext.mRayVector * len - gContext.mModel.v.position;
; 2379 :             gContext.mRotationVectorSource = Normalized(localPos);

	mulss	xmm11, xmm1
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1152, xmm0

; 274  :    vec_t vec_t::operator * (float f) const { return makeVect(x * f, y * f, z * f, w * f); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1032
	mulss	xmm0, xmm6

; 2375 :             }
; 2376 : 
; 2377 :             const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);
; 2378 :             vec_t localPos = gContext.mRayOrigin + gContext.mRayVector * len - gContext.mModel.v.position;
; 2379 :             gContext.mRotationVectorSource = Normalized(localPos);

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1156, xmm10
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1160, xmm11

; 277  :    vec_t vec_t::operator + (const vec_t& v) const { return makeVect(x + v.x, y + v.y, z + v.z, w + v.w); }

	addss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1016

; 272  :    vec_t makeVect(float _x, float _y, float _z = 0.f, float _w = 0.f) { vec_t res; res.x = _x; res.y = _y; res.z = _z; res.w = _w; return res; }

	subss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+472

; 2375 :             }
; 2376 : 
; 2377 :             const float len = IntersectRayPlane(gContext.mRayOrigin, gContext.mRayVector, gContext.mTranslationPlan);
; 2378 :             vec_t localPos = gContext.mRayOrigin + gContext.mRayVector * len - gContext.mModel.v.position;
; 2379 :             gContext.mRotationVectorSource = Normalized(localPos);

	mulss	xmm0, xmm1
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1164, xmm0

; 2380 :             gContext.mRotationAngleOrigin = ComputeAngleOnPlan();

	call	?ComputeAngleOnPlan@ImGuizmo@@YAMXZ	; ImGuizmo::ComputeAngleOnPlan
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1172, xmm0

; 2381 :          }
; 2382 :       }
; 2383 : 
; 2384 :       // rotation
; 2385 :       if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID) && IsRotateType(gContext.mCurrentOperation))

	jmp	SHORT $LN200@HandleRota
$LN8@HandleRota:
	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	je	$LN11@HandleRota
$LN211@HandleRota:

; 2341 :       bool modified = false;
; 2342 : 
; 2343 :       if (!gContext.mbUsing)

	mov	r15d, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440
	mov	r14d, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	mov	r13d, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1400
$LN200@HandleRota:

; 2381 :          }
; 2382 :       }
; 2383 : 
; 2384 :       // rotation
; 2385 :       if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID) && IsRotateType(gContext.mCurrentOperation))

	cmp	r14d, -1
	je	SHORT $LN12@HandleRota
	cmp	r14d, r15d
	jne	$LN11@HandleRota
$LN12@HandleRota:

; 628  :      return type >= MT_ROTATE_X && type <= MT_ROTATE_SCREEN;

	lea	eax, DWORD PTR [r13-8]

; 2381 :          }
; 2382 :       }
; 2383 : 
; 2384 :       // rotation
; 2385 :       if (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID) && IsRotateType(gContext.mCurrentOperation))

	cmp	eax, 3
	ja	$LN11@HandleRota

; 2386 :       {
; 2387 : #if IMGUI_VERSION_NUM >= 18723
; 2388 :          ImGui::SetNextFrameWantCaptureMouse(true);

	mov	DWORD PTR [r12+24700], 1

; 2389 : #else
; 2390 :          ImGui::CaptureMouseFromApp();
; 2391 : #endif
; 2392 :          gContext.mRotationAngle = ComputeAngleOnPlan();

	call	?ComputeAngleOnPlan@ImGuizmo@@YAMXZ	; ImGuizmo::ComputeAngleOnPlan

; 264  :       void TransformVector(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformVector(matrix); }

	movss	xmm10, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1088

; 2389 : #else
; 2390 :          ImGui::CaptureMouseFromApp();
; 2391 : #endif
; 2392 :          gContext.mRotationAngle = ComputeAngleOnPlan();

	movaps	xmm9, xmm0

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm11, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1092
	movss	xmm13, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1096
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+556

; 264  :       void TransformVector(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformVector(matrix); }

	movss	xmm6, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+540

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+572
	movss	xmm7, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+544

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	movss	xmm8, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+548
	mulss	xmm0, xmm11
	mulss	xmm1, xmm13

; 264  :       void TransformVector(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformVector(matrix); }

	mulss	xmm6, xmm10

; 449  :       out.x = x * matrix.m[0][0] + y * matrix.m[1][0] + z * matrix.m[2][0];

	mulss	xmm7, xmm10
	addss	xmm6, xmm0

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	mulss	xmm8, xmm10
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+560
	mulss	xmm0, xmm11
	addss	xmm6, xmm1

; 2389 : #else
; 2390 :          ImGui::CaptureMouseFromApp();
; 2391 : #endif
; 2392 :          gContext.mRotationAngle = ComputeAngleOnPlan();

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1168, xmm9

; 450  :       out.y = x * matrix.m[0][1] + y * matrix.m[1][1] + z * matrix.m[2][1];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+576
	addss	xmm7, xmm0
	mulss	xmm1, xmm13

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+564
	mulss	xmm0, xmm11
	addss	xmm7, xmm1
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+580
	mulss	xmm1, xmm13
	addss	xmm8, xmm0

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	movaps	xmm2, xmm7
	mulss	xmm2, xmm7

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	addss	xmm8, xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	movaps	xmm1, xmm8
	mulss	xmm1, xmm8
	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN203@HandleRota
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN204@HandleRota
$LN203@HandleRota:
	movaps	xmm0, xmm2
	call	sqrtf
$LN204@HandleRota:

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	movss	xmm3, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+552

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	maxss	xmm0, xmm15

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+584

; 2393 :          if (snap)
; 2394 :          {
; 2395 :             float snapInRadian = snap[0] * DEG2RAD;
; 2396 :             ComputeSnap(&gContext.mRotationAngle, snapInRadian);
; 2397 :          }
; 2398 :          vec_t rotationAxisLocalSpace;
; 2399 : 
; 2400 :          rotationAxisLocalSpace.TransformVector(makeVect(gContext.mTranslationPlan.x, gContext.mTranslationPlan.y, gContext.mTranslationPlan.z, 0.f), gContext.mModelInverse);
; 2401 :          rotationAxisLocalSpace.Normalize();
; 2402 : 
; 2403 :          matrix_t deltaRotation;
; 2404 :          deltaRotation.RotationAxis(rotationAxisLocalSpace, gContext.mRotationAngle - gContext.mRotationAngleOrigin);

	lea	rdx, QWORD PTR rotationAxisLocalSpace$3[rsp]

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	subss	xmm9, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1172

; 451  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2];

	mulss	xmm3, xmm10

; 2393 :          if (snap)
; 2394 :          {
; 2395 :             float snapInRadian = snap[0] * DEG2RAD;
; 2396 :             ComputeSnap(&gContext.mRotationAngle, snapInRadian);
; 2397 :          }
; 2398 :          vec_t rotationAxisLocalSpace;
; 2399 : 
; 2400 :          rotationAxisLocalSpace.TransformVector(makeVect(gContext.mTranslationPlan.x, gContext.mTranslationPlan.y, gContext.mTranslationPlan.z, 0.f), gContext.mModelInverse);
; 2401 :          rotationAxisLocalSpace.Normalize();
; 2402 : 
; 2403 :          matrix_t deltaRotation;
; 2404 :          deltaRotation.RotationAxis(rotationAxisLocalSpace, gContext.mRotationAngle - gContext.mRotationAngleOrigin);

	lea	rcx, QWORD PTR deltaRotation$7[rbp-256]

; 224  :       vec_t Normalize() { (*this) *= (1.f / ( Length() > FLT_EPSILON ? Length() : FLT_EPSILON ) ); return (*this); }

	divss	xmm12, xmm0

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	mulss	xmm1, xmm13

; 2393 :          if (snap)
; 2394 :          {
; 2395 :             float snapInRadian = snap[0] * DEG2RAD;
; 2396 :             ComputeSnap(&gContext.mRotationAngle, snapInRadian);
; 2397 :          }
; 2398 :          vec_t rotationAxisLocalSpace;
; 2399 : 
; 2400 :          rotationAxisLocalSpace.TransformVector(makeVect(gContext.mTranslationPlan.x, gContext.mTranslationPlan.y, gContext.mTranslationPlan.z, 0.f), gContext.mModelInverse);
; 2401 :          rotationAxisLocalSpace.Normalize();
; 2402 : 
; 2403 :          matrix_t deltaRotation;
; 2404 :          deltaRotation.RotationAxis(rotationAxisLocalSpace, gContext.mRotationAngle - gContext.mRotationAngleOrigin);

	movaps	xmm2, xmm9

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movaps	xmm0, xmm12
	mulss	xmm6, xmm12
	mulss	xmm0, xmm8
	mulss	xmm7, xmm12
	movss	DWORD PTR rotationAxisLocalSpace$3[rsp+8], xmm0

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+568
	mulss	xmm0, xmm11

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	movss	DWORD PTR rotationAxisLocalSpace$3[rsp], xmm6
	movss	DWORD PTR rotationAxisLocalSpace$3[rsp+4], xmm7

; 452  :       out.w = x * matrix.m[0][3] + y * matrix.m[1][3] + z * matrix.m[2][3];

	addss	xmm3, xmm0
	addss	xmm3, xmm1

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulss	xmm3, xmm12
	movss	DWORD PTR rotationAxisLocalSpace$3[rsp+12], xmm3

; 2393 :          if (snap)
; 2394 :          {
; 2395 :             float snapInRadian = snap[0] * DEG2RAD;
; 2396 :             ComputeSnap(&gContext.mRotationAngle, snapInRadian);
; 2397 :          }
; 2398 :          vec_t rotationAxisLocalSpace;
; 2399 : 
; 2400 :          rotationAxisLocalSpace.TransformVector(makeVect(gContext.mTranslationPlan.x, gContext.mTranslationPlan.y, gContext.mTranslationPlan.z, 0.f), gContext.mModelInverse);
; 2401 :          rotationAxisLocalSpace.Normalize();
; 2402 : 
; 2403 :          matrix_t deltaRotation;
; 2404 :          deltaRotation.RotationAxis(rotationAxisLocalSpace, gContext.mRotationAngle - gContext.mRotationAngleOrigin);

	call	?RotationAxis@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@M@Z ; ImGuizmo::matrix_t::RotationAxis

; 2405 :          if (gContext.mRotationAngle != gContext.mRotationAngleOrigin)

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1168
	ucomiss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1172
	jp	SHORT $LN202@HandleRota
	je	SHORT $LN14@HandleRota
$LN202@HandleRota:

; 2406 :          {
; 2407 :             modified = true;

	mov	BYTE PTR modified$1$[rsp], 1
$LN14@HandleRota:

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movaps	xmm1, XMMWORD PTR __xmm@3f800000000000000000000000000000

; 2408 :          }
; 2409 :          gContext.mRotationAngleOrigin = gContext.mRotationAngle;
; 2410 : 
; 2411 :          matrix_t scaleOrigin;
; 2412 :          scaleOrigin.Scale(gContext.mModelScaleOrigin);
; 2413 : 
; 2414 :          if (applyRotationLocaly)

	lea	rdx, QWORD PTR deltaRotation$7[rbp-256]
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1172, xmm0
	lea	rcx, QWORD PTR scaleOrigin$9[rbp-256]

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+924
	movss	DWORD PTR scaleOrigin$9[rbp-256], xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+928
	movss	DWORD PTR scaleOrigin$9[rbp-236], xmm0
	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+932
	movss	DWORD PTR scaleOrigin$9[rbp-216], xmm0
	mov	QWORD PTR scaleOrigin$9[rbp-252], 0
	mov	QWORD PTR scaleOrigin$9[rbp-244], 0
	mov	QWORD PTR scaleOrigin$9[rbp-232], 0
	mov	QWORD PTR scaleOrigin$9[rbp-224], 0
	mov	DWORD PTR scaleOrigin$9[rbp-212], 0
	movaps	XMMWORD PTR scaleOrigin$9[rbp-208], xmm1

; 2408 :          }
; 2409 :          gContext.mRotationAngleOrigin = gContext.mRotationAngle;
; 2410 : 
; 2411 :          matrix_t scaleOrigin;
; 2412 :          scaleOrigin.Scale(gContext.mModelScaleOrigin);
; 2413 : 
; 2414 :          if (applyRotationLocaly)

	test	sil, sil
	je	SHORT $LN15@HandleRota

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	r8, QWORD PTR $T6[rsp]
	call	?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z ; ImGuizmo::FPU_MatrixF_x_MatrixF
	lea	r8, QWORD PTR $T5[rsp]
	lea	rdx, OFFSET FLAT:?gContext@ImGuizmo@@3UContext@1@A+476
	lea	rcx, QWORD PTR $T6[rsp]
	call	?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z ; ImGuizmo::FPU_MatrixF_x_MatrixF

; 2415 :          {
; 2416 :             *(matrix_t*)matrix = scaleOrigin * deltaRotation * gContext.mModelLocal;

	movups	xmm1, XMMWORD PTR $T5[rsp+16]
	movaps	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+16, xmm1
	movups	xmm1, XMMWORD PTR $T5[rsp+48]
	movaps	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+48, xmm1

; 2417 :          }

	jmp	SHORT $LN232@HandleRota
$LN15@HandleRota:

; 2418 :          else
; 2419 :          {
; 2420 :             matrix_t res = gContext.mModelSource;

	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+604

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	r8, QWORD PTR $T4[rsp]

; 2418 :          else
; 2419 :          {
; 2420 :             matrix_t res = gContext.mModelSource;

	movups	xmm1, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+620
	movups	xmm6, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+652
	movaps	XMMWORD PTR res$8[rbp-256], xmm0
	movups	xmm0, XMMWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+636
	movaps	XMMWORD PTR res$8[rbp-208], xmm6
	movaps	XMMWORD PTR res$8[rbp-224], xmm0
	movaps	XMMWORD PTR res$8[rbp-240], xmm1

; 207  :       void Set(float v) { x = y = z = w = v; }

	mov	QWORD PTR res$8[rbp-200], 0
	mov	QWORD PTR res$8[rbp-208], 0

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	call	?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z ; ImGuizmo::FPU_MatrixF_x_MatrixF

; 2421 :             res.v.position.Set(0.f);
; 2422 : 
; 2423 :             *(matrix_t*)matrix = res * deltaRotation;

	movups	xmm1, XMMWORD PTR $T4[rsp+16]

; 2424 :             ((matrix_t*)matrix)->v.position = gContext.mModelSource.v.position;

	movdqa	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+48, xmm6
	movaps	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+16, xmm1
$LN232@HandleRota:

; 2425 :          }
; 2426 : 
; 2427 :          if (deltaMatrix)
; 2428 :          {
; 2429 :             *(matrix_t*)deltaMatrix = gContext.mModelInverse * deltaRotation * gContext.mModel;
; 2430 :          }
; 2431 : 
; 2432 :          if (!io.MouseDown[0])

	movups	xmm0, XMMWORD PTR $T4[rsp]
	movaps	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA, xmm0
	movups	xmm0, XMMWORD PTR $T4[rsp+32]
	movaps	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+32, xmm0
	cmp	BYTE PTR [r12+3600], 0
	jne	SHORT $LN18@HandleRota

; 2433 :          {
; 2434 :             gContext.mbUsing = false;

	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0

; 2435 :             gContext.mEditingID = -1;

	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440, -1
$LN18@HandleRota:

; 2436 :          }
; 2437 :          type = gContext.mCurrentOperation;

	mov	ecx, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1400
	mov	DWORD PTR [rdi], ecx
$LN11@HandleRota:

; 2438 :       }
; 2439 :       return modified;

	movzx	eax, BYTE PTR modified$1$[rsp]
	movaps	xmm15, XMMWORD PTR [rsp+336]
	movaps	xmm13, XMMWORD PTR [rsp+368]
	movaps	xmm12, XMMWORD PTR [rsp+384]
	movaps	xmm11, XMMWORD PTR [rsp+400]
	movaps	xmm10, XMMWORD PTR [rsp+416]
	movaps	xmm9, XMMWORD PTR [rsp+432]
	movaps	xmm8, XMMWORD PTR [rsp+448]
	movaps	xmm7, XMMWORD PTR [rsp+464]
	movaps	xmm6, XMMWORD PTR [rsp+480]
	mov	r15, QWORD PTR [rsp+496]
	mov	r13, QWORD PTR [rsp+560]
	mov	r12, QWORD PTR [rsp+552]
	mov	rsi, QWORD PTR [rsp+544]
	jmp	SHORT $LN1@HandleRota
$LN4@HandleRota:

; 2336 :       {
; 2337 :         return false;

	xor	al, al
$LN1@HandleRota:

; 2440 :    }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 504				; 000001f8H
	pop	r14
	pop	rdi
	pop	rbx
	pop	rbp
	ret	0
?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z ENDP ; ImGuizmo::HandleRotation
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?DecomposeMatrixToComponents@ImGuizmo@@YAXPEBMPEAM11@Z
_TEXT	SEGMENT
mat$ = 32
__$ArrayPad$ = 96
matrix$dead$ = 192
translation$ = 200
rotation$ = 208
scale$ = 216
?DecomposeMatrixToComponents@ImGuizmo@@YAXPEBMPEAM11@Z PROC ; ImGuizmo::DecomposeMatrixToComponents, COMDAT

; 2443 :    {

$LN22:
	mov	rax, rsp
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 160				; 000000a0H
	movaps	XMMWORD PTR [rax-40], xmm6
	movaps	XMMWORD PTR [rax-56], xmm7
	movaps	XMMWORD PTR [rax-72], xmm9
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2444 :       matrix_t mat = *(matrix_t*)matrix;

	movaps	xmm1, XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA
	mov	rsi, r9
	movaps	xmm0, XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+48

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm2, xmm1

; 2444 :       matrix_t mat = *(matrix_t*)matrix;

	movaps	xmm7, XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+16
	mov	rdi, r8
	movaps	xmm6, XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+32
	mov	rbx, rdx
	movaps	XMMWORD PTR mat$[rsp+48], xmm0

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm0, xmm1
	shufps	xmm0, xmm1, 85				; 00000055H
	mulss	xmm2, xmm1
	mulss	xmm0, xmm0

; 2444 :       matrix_t mat = *(matrix_t*)matrix;

	movaps	XMMWORD PTR mat$[rsp], xmm1

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	shufps	xmm1, xmm1, 170				; 000000aaH
	addss	xmm2, xmm0
	mulss	xmm1, xmm1
	xorps	xmm0, xmm0

; 2444 :       matrix_t mat = *(matrix_t*)matrix;

	movaps	XMMWORD PTR mat$[rsp+16], xmm7
	movaps	XMMWORD PTR mat$[rsp+32], xmm6

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	addss	xmm2, xmm1
	ucomiss	xmm0, xmm2
	ja	SHORT $LN15@DecomposeM
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN16@DecomposeM
$LN15@DecomposeM:
	movaps	xmm0, xmm2
	call	sqrtf
$LN16@DecomposeM:

; 2445 : 
; 2446 :       scale[0] = mat.v.right.Length();

	movss	DWORD PTR [rsi], xmm0

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm7
	mulss	xmm1, xmm7
	movaps	xmm0, xmm7
	shufps	xmm0, xmm7, 85				; 00000055H
	mulss	xmm0, xmm0
	shufps	xmm7, xmm7, 170				; 000000aaH
	mulss	xmm7, xmm7
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	addss	xmm1, xmm7
	ucomiss	xmm0, xmm1
	ja	SHORT $LN13@DecomposeM
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	jmp	SHORT $LN14@DecomposeM
$LN13@DecomposeM:
	movaps	xmm0, xmm1
	call	sqrtf
$LN14@DecomposeM:

; 2447 :       scale[1] = mat.v.up.Length();

	movss	DWORD PTR [rsi+4], xmm0

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm6
	mulss	xmm1, xmm6
	movaps	xmm0, xmm6
	shufps	xmm0, xmm6, 85				; 00000055H
	mulss	xmm0, xmm0
	shufps	xmm6, xmm6, 170				; 000000aaH
	mulss	xmm6, xmm6
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	addss	xmm1, xmm6
	ucomiss	xmm0, xmm1
	ja	SHORT $LN11@DecomposeM
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	jmp	SHORT $LN12@DecomposeM
$LN11@DecomposeM:
	movaps	xmm0, xmm1
	call	sqrtf
$LN12@DecomposeM:

; 2448 :       scale[2] = mat.v.dir.Length();
; 2449 : 
; 2450 :       mat.OrthoNormalize();

	lea	rcx, QWORD PTR mat$[rsp]
	movss	DWORD PTR [rsi+8], xmm0
	call	?OrthoNormalize@matrix_t@ImGuizmo@@QEAAXXZ ; ImGuizmo::matrix_t::OrthoNormalize

; 2451 : 
; 2452 :       rotation[0] = RAD2DEG * atan2f(mat.m[1][2], mat.m[2][2]);

	movss	xmm7, DWORD PTR mat$[rsp+40]
	movss	xmm6, DWORD PTR mat$[rsp+24]
	movaps	xmm1, xmm7
	movaps	xmm0, xmm6
	call	atan2f
	mulss	xmm0, DWORD PTR __real@42652ee0

; 2453 :       rotation[1] = RAD2DEG * atan2f(-mat.m[0][2], sqrtf(mat.m[1][2] * mat.m[1][2] + mat.m[2][2] * mat.m[2][2]));

	movss	xmm9, DWORD PTR mat$[rsp+8]
	xorps	xmm9, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm7, xmm7
	mulss	xmm6, xmm6
	movss	DWORD PTR [rdi], xmm0
	xorps	xmm0, xmm0
	addss	xmm7, xmm6
	ucomiss	xmm0, xmm7
	ja	SHORT $LN9@DecomposeM
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm7
	jmp	SHORT $LN10@DecomposeM
$LN9@DecomposeM:
	movaps	xmm0, xmm7
	call	sqrtf
$LN10@DecomposeM:
	movaps	xmm1, xmm0
	movaps	xmm0, xmm9
	call	atan2f
	mulss	xmm0, DWORD PTR __real@42652ee0

; 2454 :       rotation[2] = RAD2DEG * atan2f(mat.m[0][1], mat.m[0][0]);

	movss	xmm1, DWORD PTR mat$[rsp]
	movss	DWORD PTR [rdi+4], xmm0
	movss	xmm0, DWORD PTR mat$[rsp+4]
	call	atan2f
	mulss	xmm0, DWORD PTR __real@42652ee0

; 2455 : 
; 2456 :       translation[0] = mat.v.position.x;
; 2457 :       translation[1] = mat.v.position.y;

	movss	xmm1, DWORD PTR mat$[rsp+52]
	movss	DWORD PTR [rdi+8], xmm0
	movss	xmm0, DWORD PTR mat$[rsp+48]
	movss	DWORD PTR [rbx], xmm0

; 2458 :       translation[2] = mat.v.position.z;

	movss	xmm0, DWORD PTR mat$[rsp+56]
	movss	DWORD PTR [rbx+8], xmm0
	movss	DWORD PTR [rbx+4], xmm1

; 2459 :    }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	movaps	xmm6, XMMWORD PTR [rsp+144]
	movaps	xmm7, XMMWORD PTR [rsp+128]
	movaps	xmm9, XMMWORD PTR [rsp+112]
	add	rsp, 160				; 000000a0H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?DecomposeMatrixToComponents@ImGuizmo@@YAXPEBMPEAM11@Z ENDP ; ImGuizmo::DecomposeMatrixToComponents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?RecomposeMatrixFromComponents@ImGuizmo@@YAXPEBM00PEAM@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 96
rot$ = 160
__$ArrayPad$ = 352
translation$ = 464
rotation$ = 472
scale$ = 480
matrix$dead$ = 488
?RecomposeMatrixFromComponents@ImGuizmo@@YAXPEBM00PEAM@Z PROC ; ImGuizmo::RecomposeMatrixFromComponents, COMDAT

; 2462 :    {

$LN89:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 432				; 000001b0H
	movaps	XMMWORD PTR [rax-40], xmm6
	movaps	XMMWORD PTR [rax-56], xmm7
	movaps	XMMWORD PTR [rax-72], xmm8
	movaps	XMMWORD PTR [rax-88], xmm9
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	movss	xmm6, DWORD PTR __real@3c8efa35
	lea	rdi, QWORD PTR rot$[rsp]
	mov	r14, r8
	lea	rsi, OFFSET FLAT:?directionUnary@ImGuizmo@@3QBUvec_t@1@B
	mov	rbx, rdx
	mov	r15, rcx
	mov	ebp, 3
	npad	12
$LL4@RecomposeM:

; 2463 :       matrix_t& mat = *(matrix_t*)matrix;
; 2464 : 
; 2465 :       matrix_t rot[3];
; 2466 :       for (int i = 0; i < 3; i++)
; 2467 :       {
; 2468 :          rot[i].RotationAxis(directionUnary[i], rotation[i] * DEG2RAD);

	movss	xmm2, DWORD PTR [rbx]
	mov	rdx, rsi
	mulss	xmm2, xmm6
	mov	rcx, rdi
	call	?RotationAxis@matrix_t@ImGuizmo@@QEAAXAEBUvec_t@2@M@Z ; ImGuizmo::matrix_t::RotationAxis
	add	rsi, 16
	lea	rbx, QWORD PTR [rbx+4]
	add	rdi, 64					; 00000040H
	sub	rbp, 1
	jne	SHORT $LL4@RecomposeM

; 369  :          FPU_MatrixF_x_MatrixF((float*)&m1, (float*)&m2, (float*)this);

	lea	r8, QWORD PTR $T2[rsp]
	lea	rdx, QWORD PTR rot$[rsp+64]
	lea	rcx, QWORD PTR rot$[rsp]
	call	?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z ; ImGuizmo::FPU_MatrixF_x_MatrixF
	lea	r8, QWORD PTR $T1[rsp]
	lea	rdx, QWORD PTR rot$[rsp+128]
	lea	rcx, QWORD PTR $T2[rsp]
	call	?FPU_MatrixF_x_MatrixF@ImGuizmo@@YAXPEBM0PEAM@Z ; ImGuizmo::FPU_MatrixF_x_MatrixF

; 2469 :       }
; 2470 : 
; 2471 :       mat = rot[0] * rot[1] * rot[2];

	movups	xmm0, XMMWORD PTR $T1[rsp+48]
	movups	xmm9, XMMWORD PTR $T1[rsp]
	movups	xmm7, XMMWORD PTR $T1[rsp+16]
	movups	xmm8, XMMWORD PTR $T1[rsp+32]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movss	xmm4, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 2476 :          if (fabsf(scale[i]) < FLT_EPSILON)

	movss	xmm5, DWORD PTR __real@34000000
	movss	xmm2, DWORD PTR __real@3a83126f
	movups	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+48, xmm0
	movups	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA, xmm9
	movups	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+16, xmm7
	movups	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+32, xmm8
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movss	xmm6, DWORD PTR [r14]
	movaps	xmm1, xmm6
	andps	xmm1, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 2476 :          if (fabsf(scale[i]) < FLT_EPSILON)

	comiss	xmm5, xmm1
	jbe	SHORT $LN5@RecomposeM

; 2477 :          {
; 2478 :             validScale[i] = 0.001f;

	movaps	xmm6, xmm2
$LN5@RecomposeM:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movss	xmm1, DWORD PTR [r14+4]
	movaps	xmm0, xmm1
	andps	xmm0, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 2476 :          if (fabsf(scale[i]) < FLT_EPSILON)

	comiss	xmm5, xmm0
	jbe	SHORT $LN51@RecomposeM

; 2477 :          {
; 2478 :             validScale[i] = 0.001f;

	movaps	xmm1, xmm2
$LN51@RecomposeM:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movss	xmm3, DWORD PTR [r14+8]
	movaps	xmm0, xmm3
	andps	xmm0, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 2476 :          if (fabsf(scale[i]) < FLT_EPSILON)

	comiss	xmm5, xmm0
	ja	SHORT $LN55@RecomposeM

; 2479 :          }
; 2480 :          else
; 2481 :          {
; 2482 :             validScale[i] = scale[i];

	movaps	xmm2, xmm3
$LN55@RecomposeM:

; 2483 :          }
; 2484 :       }
; 2485 :       mat.v.right *= validScale[0];

	movaps	xmm0, xmm6
	shufps	xmm0, xmm0, 0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulps	xmm0, xmm9
	movups	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA, xmm0

; 2486 :       mat.v.up *= validScale[1];

	movaps	xmm0, xmm1
	shufps	xmm0, xmm0, 0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulps	xmm7, xmm0

; 2487 :       mat.v.dir *= validScale[2];

	movaps	xmm0, xmm2
	shufps	xmm0, xmm0, 0

; 213  :       vec_t& operator *= (float v) { x *= v;    y *= v;    z *= v;    w *= v;    return *this; }

	mulps	xmm8, xmm0
	movups	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+16, xmm7
	movups	XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+32, xmm8

; 2488 :       mat.v.position.Set(translation[0], translation[1], translation[2], 1.f);

	movss	xmm2, DWORD PTR [r15+8]
	movss	xmm1, DWORD PTR [r15+4]

; 208  :       void Set(float _x, float _y, float _z = 0.f, float _w = 0.f) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm0, DWORD PTR [r15]
	movss	DWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+48, xmm0
	movss	DWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+52, xmm1
	movss	DWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+56, xmm2
	mov	DWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+60, 1065353216 ; 3f800000H

; 2489 :    }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+432]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?RecomposeMatrixFromComponents@ImGuizmo@@YAXPEBM00PEAM@Z ENDP ; ImGuizmo::RecomposeMatrixFromComponents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?Manipulate@ImGuizmo@@YA_NPEBM0W4OPERATION@1@W4MODE@1@PEAM3000@Z
_TEXT	SEGMENT
view$ = 64
projection$ = 72
type$ = 80
operation$ = 80
mode$ = 88
matrix$dead$ = 96
deltaMatrix$dead$ = 104
snap$dead$ = 112
localBounds$dead$ = 120
boundsSnap$dead$ = 128
?Manipulate@ImGuizmo@@YA_NPEBM0W4OPERATION@1@W4MODE@1@PEAM3000@Z PROC ; ImGuizmo::Manipulate, COMDAT

; 2512 :    {

$LN49:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	r8d, 896				; 00000380H

; 2513 :       // Scale is always local or matrix will be skewed when applying world scale or oriented matrix
; 2514 :       ComputeContext(view, projection, matrix, (operation & SCALE) ? LOCAL : mode);

	mov	edi, 0
	mov	ebx, r8d
	cmovne	r9d, edi
	call	?ComputeContext@ImGuizmo@@YAXPEBM0PEAMW4MODE@1@@Z ; ImGuizmo::ComputeContext

; 2515 : 
; 2516 :       // set delta to identity
; 2517 :       if (deltaMatrix)
; 2518 :       {
; 2519 :          ((matrix_t*)deltaMatrix)->SetToIdentity();
; 2520 :       }
; 2521 : 
; 2522 :       // behind camera
; 2523 :       vec_t camSpacePosition;
; 2524 :       camSpacePosition.TransformPoint(makeVect(0.f, 0.f, 0.f), gContext.mMVP);
; 2525 :       if (!gContext.mIsOrthographic && camSpacePosition.z < 0.001f && !gContext.mbUsing)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1432, dil
	xorps	xmm2, xmm2
	jne	SHORT $LN3@Manipulate

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	mulss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+772
	xorps	xmm1, xmm1
	mulss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+756
	xorps	xmm0, xmm0
	mulss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+740
	addss	xmm1, xmm0

; 2515 : 
; 2516 :       // set delta to identity
; 2517 :       if (deltaMatrix)
; 2518 :       {
; 2519 :          ((matrix_t*)deltaMatrix)->SetToIdentity();
; 2520 :       }
; 2521 : 
; 2522 :       // behind camera
; 2523 :       vec_t camSpacePosition;
; 2524 :       camSpacePosition.TransformPoint(makeVect(0.f, 0.f, 0.f), gContext.mMVP);
; 2525 :       if (!gContext.mIsOrthographic && camSpacePosition.z < 0.001f && !gContext.mbUsing)

	movss	xmm0, DWORD PTR __real@3a83126f

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	addss	xmm1, xmm2
	addss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+788

; 2515 : 
; 2516 :       // set delta to identity
; 2517 :       if (deltaMatrix)
; 2518 :       {
; 2519 :          ((matrix_t*)deltaMatrix)->SetToIdentity();
; 2520 :       }
; 2521 : 
; 2522 :       // behind camera
; 2523 :       vec_t camSpacePosition;
; 2524 :       camSpacePosition.TransformPoint(makeVect(0.f, 0.f, 0.f), gContext.mMVP);
; 2525 :       if (!gContext.mIsOrthographic && camSpacePosition.z < 0.001f && !gContext.mbUsing)

	comiss	xmm0, xmm1
	jbe	SHORT $LN3@Manipulate
	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, dil
	jne	SHORT $LN3@Manipulate

; 2526 :       {
; 2527 :          return false;

	xor	al, al

; 2555 :       }
; 2556 :       return manipulated;
; 2557 :    }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN3@Manipulate:
	mov	QWORD PTR [rsp+64], rsi

; 2528 :       }
; 2529 : 
; 2530 :       // --
; 2531 :       int type = MT_NONE;
; 2532 :       bool manipulated = false;

	xor	sil, sil

; 2533 :       if (gContext.mbEnable)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1085, sil
	mov	DWORD PTR type$[rsp], edi
	je	SHORT $LN37@Manipulate

; 2534 :       {
; 2535 :          if (!gContext.mbUsingBounds)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1332, sil
	jne	SHORT $LN37@Manipulate

; 2536 :          {
; 2537 :             manipulated = HandleTranslation(matrix, deltaMatrix, operation, type, snap) ||

	lea	r9, QWORD PTR type$[rsp]
	mov	r8d, ebx
	call	?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z ; ImGuizmo::HandleTranslation
	test	al, al
	jne	SHORT $LN9@Manipulate
	lea	r9, QWORD PTR type$[rsp]
	mov	r8d, ebx
	call	?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z ; ImGuizmo::HandleScale
	test	al, al
	jne	SHORT $LN9@Manipulate
	lea	r9, QWORD PTR type$[rsp]
	mov	r8d, ebx
	call	?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z ; ImGuizmo::HandleRotation
	test	al, al
	je	SHORT $LN47@Manipulate
$LN9@Manipulate:
	mov	sil, 1
$LN47@Manipulate:

; 2538 :                           HandleScale(matrix, deltaMatrix, operation, type, snap) ||
; 2539 :                           HandleRotation(matrix, deltaMatrix, operation, type, snap);
; 2540 :          }
; 2541 :       }
; 2542 : 
; 2543 :       if (localBounds && !gContext.mbUsing)
; 2544 :       {
; 2545 :          HandleAndDrawLocalBounds(localBounds, (matrix_t*)matrix, boundsSnap, operation);
; 2546 :       }
; 2547 : 
; 2548 :       gContext.mOperation = operation;

	mov	edi, DWORD PTR type$[rsp]
$LN37@Manipulate:

; 2549 :       if (!gContext.mbUsingBounds)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1332, 0
	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1444, ebx
	jne	SHORT $LN7@Manipulate

; 2550 :       {
; 2551 :          DrawRotationGizmo(operation, type);

	mov	edx, edi
	mov	ecx, ebx
	call	?DrawRotationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z ; ImGuizmo::DrawRotationGizmo

; 2552 :          DrawTranslationGizmo(operation, type);

	mov	edx, edi
	mov	ecx, ebx
	call	?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z ; ImGuizmo::DrawTranslationGizmo

; 2553 :          DrawScaleGizmo(operation, type);

	mov	edx, edi
	mov	ecx, ebx
	call	?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z ; ImGuizmo::DrawScaleGizmo

; 2554 :          DrawScaleUniveralGizmo(operation, type);

	mov	edx, edi
	mov	ecx, ebx
	call	?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z ; ImGuizmo::DrawScaleUniveralGizmo
$LN7@Manipulate:

; 2555 :       }
; 2556 :       return manipulated;
; 2557 :    }

	mov	rbx, QWORD PTR [rsp+72]
	movzx	eax, sil
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?Manipulate@ImGuizmo@@YA_NPEBM0W4OPERATION@1@W4MODE@1@PEAM3000@Z ENDP ; ImGuizmo::Manipulate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??R<lambda_1>@?1??DrawCubes@ImGuizmo@@YAXPEBM00H@Z@QEBA@PEBX1@Z
_TEXT	SEGMENT
this$dead$ = 8
_a$ = 16
_b$ = 24
??R<lambda_1>@?1??DrawCubes@ImGuizmo@@YAXPEBM00H@Z@QEBA@PEBX1@Z PROC ; `ImGuizmo::DrawCubes'::`2'::<lambda_1>::operator(), COMDAT

; 2699 :          CubeFace* a = (CubeFace*)_a;
; 2700 :          CubeFace* b = (CubeFace*)_b;
; 2701 :          if (a->z < b->z)

	movss	xmm0, DWORD PTR [r8]
	mov	eax, -1
	comiss	xmm0, DWORD PTR [rdx]
	mov	ecx, 1
	cmova	eax, ecx

; 2702 :          {
; 2703 :             return 1;
; 2704 :          }
; 2705 :          return -1;
; 2706 :          });

	ret	0
??R<lambda_1>@?1??DrawCubes@ImGuizmo@@YAXPEBM00H@Z@QEBA@PEBX1@Z ENDP ; `ImGuizmo::DrawCubes'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ?<lambda_invoker_cdecl>@<lambda_1>@?1??DrawCubes@ImGuizmo@@YAXPEBM00H@Z@SA@PEBX1@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 16
?<lambda_invoker_cdecl>@<lambda_1>@?1??DrawCubes@ImGuizmo@@YAXPEBM00H@Z@SA@PEBX1@Z PROC ; `ImGuizmo::DrawCubes'::`2'::<lambda_1>::<lambda_invoker_cdecl>, COMDAT

; 2701 :          if (a->z < b->z)

	movss	xmm0, DWORD PTR [rdx]
	mov	eax, -1
	comiss	xmm0, DWORD PTR [rcx]
	mov	r8d, 1
	cmova	eax, r8d

; 2706 :          });

	ret	0
?<lambda_invoker_cdecl>@<lambda_1>@?1??DrawCubes@ImGuizmo@@YAXPEBM00H@Z@SA@PEBX1@Z ENDP ; `ImGuizmo::DrawCubes'::`2'::<lambda_1>::<lambda_invoker_cdecl>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??$IsWithin@M@ImGuizmo@@YA_NMMM@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
z$ = 24
??$IsWithin@M@ImGuizmo@@YA_NMMM@Z PROC			; ImGuizmo::IsWithin<float>, COMDAT

; 191  :    template <typename T> bool IsWithin(T x, T y, T z) { return (x >= y) && (x <= z); }

	comiss	xmm0, xmm1
	jb	SHORT $LN3@IsWithin
	comiss	xmm2, xmm0
	jb	SHORT $LN3@IsWithin
	mov	al, 1
	ret	0
$LN3@IsWithin:
	xor	al, al
	ret	0
??$IsWithin@M@ImGuizmo@@YA_NMMM@Z ENDP			; ImGuizmo::IsWithin<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??$Clamp@M@ImGuizmo@@YAMMMM@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
z$ = 24
??$Clamp@M@ImGuizmo@@YAMMMM@Z PROC			; ImGuizmo::Clamp<float>, COMDAT

; 188  :    template <typename T> T Clamp(T x, T y, T z) { return ((x < y) ? y : ((x > z) ? z : x)); }

	comiss	xmm1, xmm0
	jbe	SHORT $LN5@Clamp
	movaps	xmm0, xmm1
	ret	0
$LN5@Clamp:
	minss	xmm2, xmm0
	movaps	xmm0, xmm2
	ret	0
??$Clamp@M@ImGuizmo@@YAMMMM@Z ENDP			; ImGuizmo::Clamp<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??$min@H@ImGuizmo@@YAHHH@Z
_TEXT	SEGMENT
x$ = 8
y$dead$ = 16
??$min@H@ImGuizmo@@YAHHH@Z PROC				; ImGuizmo::min<int>, COMDAT

; 190  :    template <typename T> T min(T x, T y) { return (x < y) ? x : y; }

	mov	eax, 1000				; 000003e8H
	cmp	ecx, eax
	cmovl	eax, ecx
	ret	0
??$min@H@ImGuizmo@@YAHHH@Z ENDP				; ImGuizmo::min<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
;	COMDAT ??$max@M@ImGuizmo@@YAMMM@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
??$max@M@ImGuizmo@@YAMMM@Z PROC				; ImGuizmo::max<float>, COMDAT

; 189  :    template <typename T> T max(T x, T y) { return (x > y) ? x : y; }

	maxss	xmm0, xmm1
	ret	0
??$max@M@ImGuizmo@@YAMMM@Z ENDP				; ImGuizmo::max<float>
_TEXT	ENDS
END
