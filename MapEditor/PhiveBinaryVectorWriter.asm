; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??$construct_at@UPhiveWrapperItem@PhiveWrapper@@U12@$0A@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@$$QEAU12@@Z ; std::construct_at<PhiveWrapper::PhiveWrapperItem,PhiveWrapper::PhiveWrapperItem,0>
PUBLIC	??$construct_at@UPhiveWrapperItem@PhiveWrapper@@$$V$0A@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@@Z ; std::construct_at<PhiveWrapper::PhiveWrapperItem,0>
PUBLIC	??$construct@UPhiveWrapperItem@PhiveWrapper@@U12@@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@1@QEAUPhiveWrapperItem@PhiveWrapper@@$$QEAU34@@Z ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperItem> >::construct<PhiveWrapper::PhiveWrapperItem,PhiveWrapper::PhiveWrapperItem>
PUBLIC	??$forward@UPhiveWrapperItem@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperItem@PhiveWrapper@@AEAU12@@Z ; std::forward<PhiveWrapper::PhiveWrapperItem>
PUBLIC	??$to_address@UPhiveWrapperItem@PhiveWrapper@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@@Z ; std::to_address<PhiveWrapper::PhiveWrapperItem>
PUBLIC	??$construct@UPhiveWrapperItem@PhiveWrapper@@$$V@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@1@QEAUPhiveWrapperItem@PhiveWrapper@@@Z ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperItem> >::construct<PhiveWrapper::PhiveWrapperItem>
PUBLIC	??$_Emplace_back@UPhiveWrapperItem@PhiveWrapper@@@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX$$QEAUPhiveWrapperItem@PhiveWrapper@@@Z ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Emplace_back<PhiveWrapper::PhiveWrapperItem>
PUBLIC	??$_To_address@PEAUPhiveWrapperItem@PhiveWrapper@@@std@@YA?A_PAEBQEAUPhiveWrapperItem@PhiveWrapper@@@Z ; std::_To_address<PhiveWrapper::PhiveWrapperItem *>
PUBLIC	??$_Copy_memmove@PEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@00@Z ; std::_Copy_memmove<PhiveWrapper::PhiveWrapperItem *,PhiveWrapper::PhiveWrapperItem *>
PUBLIC	??$_Unfancy@UPhiveWrapperItem@PhiveWrapper@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@@Z ; std::_Unfancy<PhiveWrapper::PhiveWrapperItem>
PUBLIC	??$move@AEAUPhiveWrapperItem@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperItem@PhiveWrapper@@AEAU12@@Z ; std::move<PhiveWrapper::PhiveWrapperItem &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAUPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z ; std::_Uninitialized_move<PhiveWrapper::PhiveWrapperItem *,std::allocator<PhiveWrapper::PhiveWrapperItem> >
PUBLIC	??$_Get_unwrapped@AEBQEAUPhiveWrapperItem@PhiveWrapper@@@std@@YA?A_TAEBQEAUPhiveWrapperItem@PhiveWrapper@@@Z ; std::_Get_unwrapped<PhiveWrapper::PhiveWrapperItem * const &>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperItem@PhiveWrapper@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@XZ ; std::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperItem>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperItem> >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@SA_KAEBV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@@Z ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperItem> >::max_size
PUBLIC	?capacity@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEBA_KXZ ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::capacity
PUBLIC	?_Getal@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEBAAEBV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@XZ ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Getal
PUBLIC	?allocate@?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperItem@PhiveWrapper@@_K@Z ; std::allocator<PhiveWrapper::PhiveWrapperItem>::allocate
PUBLIC	?max_size@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEBA_KXZ ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::max_size
PUBLIC	?_Calculate_growth@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEBA_K_K@Z ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperItem@PhiveWrapper@@_K1@Z ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Change_array
PUBLIC	?_Xlength@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@CAXXZ ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Xlength
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAA@PEAUPhiveWrapperItem@PhiveWrapper@@AEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >::~_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperItem@PhiveWrapper@@XZ ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >::__autoclassinit2
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperItem> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	?_Orphan_range@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEBAXPEAUPhiveWrapperItem@PhiveWrapper@@0@Z ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Orphan_range
PUBLIC	??$_Destroy_range@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAXPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@AEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z ; std::_Destroy_range<std::allocator<PhiveWrapper::PhiveWrapperItem> >
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Resize<std::_Value_init_tag>
PUBLIC	??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAH@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned int>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned int><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,int,0>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperItem@PhiveWrapper@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@XZ ; std::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperItem>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperItem> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@QEAAXQEAUPhiveWrapperItem@PhiveWrapper@@_K@Z ; std::allocator<PhiveWrapper::PhiveWrapperItem>::deallocate
PUBLIC	?_Getal@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@XZ ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Getal
PUBLIC	?resize@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::resize
PUBLIC	??0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z ; PhiveBinaryVectorWriter::PhiveBinaryVectorWriter
PUBLIC	?QueryHkPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; PhiveBinaryVectorWriter::QueryHkPointerWrite
PUBLIC	?QueryHkArrayToItemPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; PhiveBinaryVectorWriter::QueryHkArrayToItemPointerWrite
PUBLIC	?QueryHkArrayWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; PhiveBinaryVectorWriter::QueryHkArrayWrite
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z DD imagerel $LN27
	DD	imagerel $LN27+78
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperItem@PhiveWrapper@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+116
	DD	imagerel $unwind$?allocate@?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperItem@PhiveWrapper@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperItem@PhiveWrapper@@_K1@Z DD imagerel $LN30
	DD	imagerel $LN30+168
	DD	imagerel $unwind$?_Change_array@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperItem@PhiveWrapper@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z DD imagerel $LN26
	DD	imagerel $LN26+14
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z DD imagerel $LN26+14
	DD	imagerel $LN26+52
	DD	imagerel $chain$0$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z DD imagerel $LN26+52
	DD	imagerel $LN26+61
	DD	imagerel $chain$1$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN67
	DD	imagerel $LN67+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN67+33
	DD	imagerel $LN67+143
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN67+143
	DD	imagerel $LN67+208
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN67+208
	DD	imagerel $LN67+214
	DD	imagerel $chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN33
	DD	imagerel $LN33+117
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN33+117
	DD	imagerel $LN33+151
	DD	imagerel $chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN33+151
	DD	imagerel $LN33+166
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAH@Z DD imagerel $LN6
	DD	imagerel $LN6+40
	DD	imagerel $unwind$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@QEAAXQEAUPhiveWrapperItem@PhiveWrapper@@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+67
	DD	imagerel $unwind$?deallocate@?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@QEAAXQEAUPhiveWrapperItem@PhiveWrapper@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z DD imagerel $LN35
	DD	imagerel $LN35+117
	DD	imagerel $unwind$?resize@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?resize@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z DD imagerel $LN35+117
	DD	imagerel $LN35+151
	DD	imagerel $chain$0$?resize@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z DD imagerel $LN35+151
	DD	imagerel $LN35+166
	DD	imagerel $chain$1$?resize@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z DD imagerel $LN112
	DD	imagerel $LN112+167
	DD	imagerel $unwind$??0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?QueryHkPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN49
	DD	imagerel $LN49+234
	DD	imagerel $unwind$?QueryHkPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?QueryHkArrayToItemPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN49
	DD	imagerel $LN49+234
	DD	imagerel $unwind$?QueryHkArrayToItemPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?QueryHkArrayWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN49
	DD	imagerel $LN49+234
	DD	imagerel $unwind$?QueryHkArrayWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?QueryHkArrayWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 08H
	DB	09aH
	DB	02H
	DB	'\'
	DB	04H
	DB	'('
	DB	02H
	DB	'b'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?QueryHkArrayWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0b0H
	DB	032H
	DD	imagerel ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?QueryHkArrayWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?QueryHkArrayWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?QueryHkArrayWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?QueryHkArrayWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 082119H
	DD	0155412H
	DD	0143412H
	DD	0e00ed212H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?QueryHkArrayWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?QueryHkArrayToItemPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 08H
	DB	09aH
	DB	02H
	DB	'\'
	DB	04H
	DB	'('
	DB	02H
	DB	'b'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?QueryHkArrayToItemPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0b0H
	DB	032H
	DD	imagerel ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?QueryHkArrayToItemPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?QueryHkArrayToItemPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?QueryHkArrayToItemPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?QueryHkArrayToItemPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 082119H
	DD	0155412H
	DD	0143412H
	DD	0e00ed212H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?QueryHkArrayToItemPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?QueryHkPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 08H
	DB	09aH
	DB	02H
	DB	'\'
	DB	04H
	DB	'('
	DB	02H
	DB	'b'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?QueryHkPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0b0H
	DB	032H
	DD	imagerel ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?QueryHkPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?QueryHkPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?QueryHkPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?QueryHkPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 082119H
	DD	0155412H
	DD	0143412H
	DD	0e00ed212H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?QueryHkPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z DB 06H
	DB	't'
	DB	02H
	DB	'X'
	DB	04H
	DB	'V'
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z DB 06H
	DB	0cH
	DD	imagerel ??1BinaryVectorWriter@@QEAA@XZ
	DB	080H
	DB	036H
	DD	imagerel ?dtor$1@?0???0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z
	DD	imagerel $ip2state$??0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z DD 061111H
	DD	093411H
	DD	0700d3211H
	DD	0500b600cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN35
	DD	imagerel $LN35+117
	DD	imagerel $unwind$?resize@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?resize@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z DD 020521H
	DD	083405H
	DD	imagerel $LN35
	DD	imagerel $LN35+117
	DD	imagerel $unwind$?resize@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z DD 040a01H
	DD	09640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@QEAAXQEAUPhiveWrapperItem@PhiveWrapper@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+117
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	083405H
	DD	imagerel $LN33
	DD	imagerel $LN33+117
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a01H
	DD	09640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN67
	DD	imagerel $LN67+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020021H
	DD	0bf400H
	DD	imagerel $LN67
	DD	imagerel $LN67+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 043821H
	DD	0bf438H
	DD	0ae405H
	DD	imagerel $LN67
	DD	imagerel $LN67+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+14
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN26
	DD	imagerel $LN26+14
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperItem@PhiveWrapper@@_K1@Z DD 081501H
	DD	097415H
	DD	086415H
	DD	073415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperItem@PhiveWrapper@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@00@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp
;	COMDAT ?QueryHkArrayWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 72
Name$GSCopy$ = 88
__$ArrayPad$ = 96
this$ = 144
Name$ = 152
?QueryHkArrayWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; PhiveBinaryVectorWriter::QueryHkArrayWrite, COMDAT

; 7    : {

$LN49:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 112				; 00000070H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbp, rdx
	mov	rbx, rcx

; 6    : void PhiveBinaryVectorWriter::QueryHkArrayWrite(std::string Name)

	mov	QWORD PTR Name$GSCopy$[rsp], rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 108  : 	while (GetPosition() % Alignment != 0)

	mov	esi, DWORD PTR [rcx+24]
	test	sil, 7
	je	SHORT $LN46@QueryHkArr
	npad	11
$LL6@QueryHkArr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+8]
	sub	rdx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	mov	rcx, rbx
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR [rbx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	mov	esi, DWORD PTR [rbx+24]
	inc	esi
	mov	DWORD PTR [rbx+24], esi

; 108  : 	while (GetPosition() % Alignment != 0)

	test	sil, 7
	jne	SHORT $LL6@QueryHkArr
$LN46@QueryHkArr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rdx, rbp
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR $T1[rsp+32], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp

; 9    : 	mArrayOffsets.insert({ Name, GetPosition() });

	lea	r8, QWORD PTR $T1[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR [rbx+32]
	call	??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned int> >,0> >::insert<0,0>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T1[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR [rbx+8]
	sub	r8, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	mov	ecx, DWORD PTR [rbx+24]
	lea	eax, DWORD PTR [rcx+16]
	movsxd	rdx, eax
	cmp	rdx, r8
	jb	SHORT $LN30@QueryHkArr

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [rcx+17]
	movsxd	rdx, eax
	mov	rcx, rbx
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN30@QueryHkArr:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	add	DWORD PTR [rbx+24], 16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbp
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp

; 11   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?QueryHkArrayWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; PhiveBinaryVectorWriter::QueryHkArrayWrite
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 72
Name$GSCopy$ = 88
__$ArrayPad$ = 96
this$ = 144
Name$ = 152
?dtor$0@?0??QueryHkArrayWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `PhiveBinaryVectorWriter::QueryHkArrayWrite'::`1'::dtor$0
	mov	rcx, QWORD PTR Name$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??QueryHkArrayWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `PhiveBinaryVectorWriter::QueryHkArrayWrite'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 72
Name$GSCopy$ = 88
__$ArrayPad$ = 96
this$ = 144
Name$ = 152
?dtor$1@?0??QueryHkArrayWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `PhiveBinaryVectorWriter::QueryHkArrayWrite'::`1'::dtor$1
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@QEAA@XZ
?dtor$1@?0??QueryHkArrayWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `PhiveBinaryVectorWriter::QueryHkArrayWrite'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp
;	COMDAT ?QueryHkArrayToItemPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 72
Name$GSCopy$ = 88
__$ArrayPad$ = 96
this$ = 144
Name$ = 152
?QueryHkArrayToItemPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; PhiveBinaryVectorWriter::QueryHkArrayToItemPointerWrite, COMDAT

; 14   : {

$LN49:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 112				; 00000070H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbp, rdx
	mov	rbx, rcx

; 13   : void PhiveBinaryVectorWriter::QueryHkArrayToItemPointerWrite(std::string Name)

	mov	QWORD PTR Name$GSCopy$[rsp], rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 108  : 	while (GetPosition() % Alignment != 0)

	mov	esi, DWORD PTR [rcx+24]
	test	sil, 7
	je	SHORT $LN46@QueryHkArr
	npad	11
$LL6@QueryHkArr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+8]
	sub	rdx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	mov	rcx, rbx
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR [rbx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	mov	esi, DWORD PTR [rbx+24]
	inc	esi
	mov	DWORD PTR [rbx+24], esi

; 108  : 	while (GetPosition() % Alignment != 0)

	test	sil, 7
	jne	SHORT $LL6@QueryHkArr
$LN46@QueryHkArr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rdx, rbp
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR $T1[rsp+32], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp

; 16   : 	mArrayOffsets.insert({ Name, GetPosition() });

	lea	r8, QWORD PTR $T1[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR [rbx+32]
	call	??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned int> >,0> >::insert<0,0>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T1[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR [rbx+8]
	sub	r8, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	mov	ecx, DWORD PTR [rbx+24]
	lea	eax, DWORD PTR [rcx+8]
	movsxd	rdx, eax
	cmp	rdx, r8
	jb	SHORT $LN30@QueryHkArr

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [rcx+9]
	movsxd	rdx, eax
	mov	rcx, rbx
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN30@QueryHkArr:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	add	DWORD PTR [rbx+24], 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbp
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp

; 18   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?QueryHkArrayToItemPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; PhiveBinaryVectorWriter::QueryHkArrayToItemPointerWrite
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 72
Name$GSCopy$ = 88
__$ArrayPad$ = 96
this$ = 144
Name$ = 152
?dtor$0@?0??QueryHkArrayToItemPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `PhiveBinaryVectorWriter::QueryHkArrayToItemPointerWrite'::`1'::dtor$0
	mov	rcx, QWORD PTR Name$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??QueryHkArrayToItemPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `PhiveBinaryVectorWriter::QueryHkArrayToItemPointerWrite'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 72
Name$GSCopy$ = 88
__$ArrayPad$ = 96
this$ = 144
Name$ = 152
?dtor$1@?0??QueryHkArrayToItemPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `PhiveBinaryVectorWriter::QueryHkArrayToItemPointerWrite'::`1'::dtor$1
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@QEAA@XZ
?dtor$1@?0??QueryHkArrayToItemPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `PhiveBinaryVectorWriter::QueryHkArrayToItemPointerWrite'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp
;	COMDAT ?QueryHkPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 72
Name$GSCopy$ = 88
__$ArrayPad$ = 96
this$ = 144
Name$ = 152
?QueryHkPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; PhiveBinaryVectorWriter::QueryHkPointerWrite, COMDAT

; 21   : {

$LN49:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 112				; 00000070H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbp, rdx
	mov	rbx, rcx

; 20   : void PhiveBinaryVectorWriter::QueryHkPointerWrite(std::string Name)

	mov	QWORD PTR Name$GSCopy$[rsp], rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 108  : 	while (GetPosition() % Alignment != 0)

	mov	esi, DWORD PTR [rcx+24]
	test	sil, 7
	je	SHORT $LN46@QueryHkPoi
	npad	11
$LL6@QueryHkPoi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+8]
	sub	rdx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	mov	rcx, rbx
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR [rbx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	mov	esi, DWORD PTR [rbx+24]
	inc	esi
	mov	DWORD PTR [rbx+24], esi

; 108  : 	while (GetPosition() % Alignment != 0)

	test	sil, 7
	jne	SHORT $LL6@QueryHkPoi
$LN46@QueryHkPoi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rdx, rbp
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR $T1[rsp+32], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp

; 23   : 	mPointerOffsets.insert({ Name, GetPosition() });

	lea	r8, QWORD PTR $T1[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR [rbx+48]
	call	??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned int> >,0> >::insert<0,0>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T1[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR [rbx+8]
	sub	r8, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	mov	ecx, DWORD PTR [rbx+24]
	lea	eax, DWORD PTR [rcx+8]
	movsxd	rdx, eax
	cmp	rdx, r8
	jb	SHORT $LN30@QueryHkPoi

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [rcx+9]
	movsxd	rdx, eax
	mov	rcx, rbx
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN30@QueryHkPoi:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	add	DWORD PTR [rbx+24], 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbp
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp

; 25   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?QueryHkPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; PhiveBinaryVectorWriter::QueryHkPointerWrite
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 72
Name$GSCopy$ = 88
__$ArrayPad$ = 96
this$ = 144
Name$ = 152
?dtor$0@?0??QueryHkPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `PhiveBinaryVectorWriter::QueryHkPointerWrite'::`1'::dtor$0
	mov	rcx, QWORD PTR Name$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??QueryHkPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `PhiveBinaryVectorWriter::QueryHkPointerWrite'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 72
Name$GSCopy$ = 88
__$ArrayPad$ = 96
this$ = 144
Name$ = 152
?dtor$1@?0??QueryHkPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `PhiveBinaryVectorWriter::QueryHkPointerWrite'::`1'::dtor$1
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@QEAA@XZ
?dtor$1@?0??QueryHkPointerWrite@PhiveBinaryVectorWriter@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `PhiveBinaryVectorWriter::QueryHkPointerWrite'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp
;	COMDAT ??0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z
_TEXT	SEGMENT
this$ = 64
mWrapper$ = 72
this$ = 80
this$ = 80
??0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z PROC ; PhiveBinaryVectorWriter::PhiveBinaryVectorWriter, COMDAT

; 28   : {

$LN112:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	ebp, ebp
	mov	QWORD PTR [rcx], rbp
	mov	QWORD PTR [rcx+8], rbp
	mov	QWORD PTR [rcx+16], rbp
	mov	DWORD PTR [rcx+24], ebp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp

; 28   : {

	lea	rbx, QWORD PTR [rcx+32]
	mov	QWORD PTR this$[rsp], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	QWORD PTR [rbx], rbp
	mov	QWORD PTR [rbx+8], rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rbp+72]
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 1943 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	QWORD PTR [rbx], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp

; 28   : {

	lea	rbx, QWORD PTR [rsi+48]
	mov	QWORD PTR this$[rsp], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	QWORD PTR [rbx], rbp
	mov	QWORD PTR [rbx+8], rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rbp+72]
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 1943 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	QWORD PTR [rbx], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.h

; 21   : 	uint32_t mItemPointerIndex = 2;

	mov	DWORD PTR [rsi+64], 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveBinaryVectorWriter.cpp

; 27   : PhiveBinaryVectorWriter::PhiveBinaryVectorWriter(PhiveWrapper& mWrapper) : mPhiveWrapper(mWrapper)

	mov	QWORD PTR [rsi+72], rdi

; 29   : 	mPhiveWrapper.mItems.resize(2); //Keep first two elements

	lea	rcx, QWORD PTR [rdi+8]
	lea	edx, QWORD PTR [rbp+2]
	call	?resize@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::resize
	npad	1

; 30   : }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
??0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z ENDP ; PhiveBinaryVectorWriter::PhiveBinaryVectorWriter
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
mWrapper$ = 72
this$ = 80
this$ = 80
?dtor$0@?0???0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z@4HA PROC ; `PhiveBinaryVectorWriter::PhiveBinaryVectorWriter'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1BinaryVectorWriter@@QEAA@XZ
?dtor$0@?0???0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z@4HA ENDP ; `PhiveBinaryVectorWriter::PhiveBinaryVectorWriter'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
mWrapper$ = 72
this$ = 80
this$ = 80
?dtor$1@?0???0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z@4HA PROC ; `PhiveBinaryVectorWriter::PhiveBinaryVectorWriter'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@@2@@std@@QEAA@XZ
?dtor$1@?0???0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z@4HA ENDP ; `PhiveBinaryVectorWriter::PhiveBinaryVectorWriter'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
mWrapper$ = 72
this$ = 80
this$ = 80
?dtor$2@?0???0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z@4HA PROC ; `PhiveBinaryVectorWriter::PhiveBinaryVectorWriter'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 48					; 00000030H
	jmp	??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@@2@@std@@QEAA@XZ
?dtor$2@?0???0PhiveBinaryVectorWriter@@QEAA@AEAVPhiveWrapper@@@Z@4HA ENDP ; `PhiveBinaryVectorWriter::PhiveBinaryVectorWriter'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN35:
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rdi, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	r9, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rcx, rsi
	sub	rcx, r8
	sar	rcx, 2
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN4@resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rdx*2]
	lea	rcx, QWORD PTR [r8+rax*4]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rdi+8], rcx

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, r8
	sar	rax, 2
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rdi

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN11@resize
	mov	QWORD PTR [rsp+64], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	rcx, rsi
	lea	rbx, QWORD PTR [rdx+rdx*2]
	xor	edx, edx
	shl	rbx, 2
	mov	r8, rbx
	call	memset
	add	rsi, rbx
	mov	rbx, QWORD PTR [rsp+64]
$LN11@resize:
	mov	QWORD PTR [rdi+8], rsi
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@XZ PROC ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@XZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@QEAAXQEAUPhiveWrapperItem@PhiveWrapper@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@QEAAXQEAUPhiveWrapperItem@PhiveWrapper@@_K@Z PROC ; std::allocator<PhiveWrapper::PhiveWrapperItem>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8+r8*2]
	shl	rdx, 2

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@QEAAXQEAUPhiveWrapperItem@PhiveWrapper@@_K@Z ENDP ; std::allocator<PhiveWrapper::PhiveWrapperItem>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperItem@PhiveWrapper@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperItem@PhiveWrapper@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperItem>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperItem> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperItem@PhiveWrapper@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperItem>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperItem> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAH@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAH@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned int>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned int><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,int,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rdi, rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR [rbx]

; 243  :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR [rdi+32], eax
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAH@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned int>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned int><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN33:
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]
	mov	rdi, rcx
	mov	r8, QWORD PTR [rcx]
	mov	r9, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rcx, rsi
	sub	rcx, r8
	sar	rcx, 2
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rdx*2]
	lea	rcx, QWORD PTR [r8+rax*4]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rdi+8], rcx

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, r8
	sar	rax, 2
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rdi

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN9@Resize
	mov	QWORD PTR [rsp+64], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	rcx, rsi
	lea	rbx, QWORD PTR [rdx+rdx*2]
	xor	edx, edx
	shl	rbx, 2
	mov	r8, rbx
	call	memset
	add	rsi, rbx
	mov	rbx, QWORD PTR [rsp+64]
$LN9@Resize:
	mov	QWORD PTR [rdi+8], rsi
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAXPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@AEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAXPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@AEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z PROC ; std::_Destroy_range<std::allocator<PhiveWrapper::PhiveWrapperItem> >, COMDAT

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {
; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	ret	0
??$_Destroy_range@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAXPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@AEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<PhiveWrapper::PhiveWrapperItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEBAXPEAUPhiveWrapperItem@PhiveWrapper@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEBAXPEAUPhiveWrapperItem@PhiveWrapper@@0@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEBAXPEAUPhiveWrapperItem@PhiveWrapper@@0@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
_Val$dead$ = 80
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN67:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 1537228672809129301		; 1555555555555555H
	mov	rdi, rdx
	mov	rsi, rcx
	cmp	rdx, rbx
	ja	$LN65@Resize_rea

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	QWORD PTR [rsp+80], r14
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	r14, QWORD PTR [rcx+8]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sub	r14, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rsi]
	sar	rcx, 2
	imul	rcx, rdx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	r14, 2
	imul	r14, rdx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	QWORD PTR [rsp+88], r15
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rdi
	cmovb	rbx, rdi
$LN11@Resize_rea:

; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperItem@PhiveWrapper@@_K@Z ; std::allocator<PhiveWrapper::PhiveWrapperItem>::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	rcx, QWORD PTR [r14+r14*2]
	mov	r15, rax
	lea	rax, QWORD PTR [rax+rcx*4]

; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	rcx, rdi
	sub	rcx, r14
	mov	r14, QWORD PTR [rsp+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN18@Resize_rea
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	lea	r8, QWORD PTR [rcx+rcx*2]
	xor	edx, edx
	shl	r8, 2
	mov	rcx, rax
	call	memset
$LN18@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1931 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	rdx, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1932 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r8, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rdi
	mov	rdx, r15
	mov	rcx, rsi
	mov	r15, QWORD PTR [rsp+88]

; 1548 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx

; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperItem@PhiveWrapper@@_K1@Z ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Change_array
$LN65@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@CAXXZ ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Xlength
	int	3
$LN63@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperItem> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN26:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN22@Uninitiali
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rdx+rdx*2]
	shl	rbx, 2
	xor	edx, edx
	mov	r8, rbx
	call	memset
	lea	rax, QWORD PTR [rbx+rdi]

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();

	mov	rbx, QWORD PTR [rsp+48]

; 2046 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN22@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();

	mov	rax, rdi

; 2046 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperItem@PhiveWrapper@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperItem@PhiveWrapper@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperItem@PhiveWrapper@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >::~_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >, COMDAT

; 1797 :         _Destroy_range(_First, _Last, _Al);
; 1798 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >::~_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAA@PEAUPhiveWrapperItem@PhiveWrapper@@AEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAA@PEAUPhiveWrapperItem@PhiveWrapper@@AEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAA@PEAUPhiveWrapperItem@PhiveWrapper@@AEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@CAXXZ PROC ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@CAXXZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperItem@PhiveWrapper@@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperItem@PhiveWrapper@@_K1@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	r14, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2025 :             _ASAN_VECTOR_REMOVE;
; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR [rbx+16]
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sub	rax, rcx
	sar	rax, 2
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 2

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2029 :         _Myfirst = _Newvec;

	mov	QWORD PTR [rbx], rdi

; 2030 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [r14+r14*2]
	lea	rcx, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR [rbx+8], rcx

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rsi+rsi*2]

; 2033 :     }

	mov	rsi, QWORD PTR [rsp+64]
	lea	rcx, QWORD PTR [rdi+rax*4]
	mov	rdi, QWORD PTR [rsp+72]
	mov	QWORD PTR [rbx+16], rcx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN17@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Change_arr:
?_Change_array@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperItem@PhiveWrapper@@_K1@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sub	r8, QWORD PTR [rcx]
	sar	r8, 2
	imul	r8, rax

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 1537228672809129301		; 1555555555555555H
	mov	r9, r8
	mov	rcx, rax
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEBA_KXZ PROC ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 1537228672809129301		; 1555555555555555H

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperItem@PhiveWrapper@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperItem@PhiveWrapper@@_K@Z PROC ; std::allocator<PhiveWrapper::PhiveWrapperItem>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 1537228672809129301		; 1555555555555555H
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rdx+rdx*2]
	lea	rcx, QWORD PTR [rax*4]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperItem@PhiveWrapper@@_K@Z ENDP ; std::allocator<PhiveWrapper::PhiveWrapperItem>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEBAAEBV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEBAAEBV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@XZ PROC ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@AEBAAEBV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@XZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEBA_KXZ PROC ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sar	rax, 2
	imul	rax, rcx

; 1880 :     }

	ret	0
?capacity@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@SA_KAEBV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@SA_KAEBV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperItem> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 1537228672809129301		; 1555555555555555H

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@SA_KAEBV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperItem@PhiveWrapper@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperItem@PhiveWrapper@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperItem>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperItem> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperItem@PhiveWrapper@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperItem>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperItem> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUPhiveWrapperItem@PhiveWrapper@@@std@@YA?A_TAEBQEAUPhiveWrapperItem@PhiveWrapper@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUPhiveWrapperItem@PhiveWrapper@@@std@@YA?A_TAEBQEAUPhiveWrapperItem@PhiveWrapper@@@Z PROC ; std::_Get_unwrapped<PhiveWrapper::PhiveWrapperItem * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAUPhiveWrapperItem@PhiveWrapper@@@std@@YA?A_TAEBQEAUPhiveWrapperItem@PhiveWrapper@@@Z ENDP ; std::_Get_unwrapped<PhiveWrapper::PhiveWrapperItem * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAUPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z PROC ; std::_Uninitialized_move<PhiveWrapper::PhiveWrapperItem *,std::allocator<PhiveWrapper::PhiveWrapperItem> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN27:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1940 :             return _Dest + (_ULast - _UFirst);

	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	rbx

; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rbx, QWORD PTR [rsp+72]
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
	lea	rax, QWORD PTR [rdx+rdx*2]
	lea	rax, QWORD PTR [rdi+rax*4]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAUPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@0@@Z ENDP ; std::_Uninitialized_move<PhiveWrapper::PhiveWrapperItem *,std::allocator<PhiveWrapper::PhiveWrapperItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	mov	QWORD PTR [rax], rdx
	mov	DWORD PTR [rax+8], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 12

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAUPhiveWrapperItem@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperItem@PhiveWrapper@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUPhiveWrapperItem@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperItem@PhiveWrapper@@AEAU12@@Z PROC ; std::move<PhiveWrapper::PhiveWrapperItem &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAUPhiveWrapperItem@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperItem@PhiveWrapper@@AEAU12@@Z ENDP ; std::move<PhiveWrapper::PhiveWrapperItem &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@UPhiveWrapperItem@PhiveWrapper@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@UPhiveWrapperItem@PhiveWrapper@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@@Z PROC ; std::_Unfancy<PhiveWrapper::PhiveWrapperItem>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@UPhiveWrapperItem@PhiveWrapper@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@@Z ENDP ; std::_Unfancy<PhiveWrapper::PhiveWrapperItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_memmove@PEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@00@Z PROC ; std::_Copy_memmove<PhiveWrapper::PhiveWrapperItem *,PhiveWrapper::PhiveWrapperItem *>, COMDAT

; 4526 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4527 :     auto _FirstPtr              = _To_address(_First);
; 4528 :     auto _LastPtr               = _To_address(_Last);
; 4529 :     auto _DestPtr               = _To_address(_Dest);
; 4530 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4531 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4532 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4537 :     } else {
; 4538 :         return _Dest + (_LastPtr - _FirstPtr);
; 4539 :     }
; 4540 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@00@Z ENDP ; std::_Copy_memmove<PhiveWrapper::PhiveWrapperItem *,PhiveWrapper::PhiveWrapperItem *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_To_address@PEAUPhiveWrapperItem@PhiveWrapper@@@std@@YA?A_PAEBQEAUPhiveWrapperItem@PhiveWrapper@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAUPhiveWrapperItem@PhiveWrapper@@@std@@YA?A_PAEBQEAUPhiveWrapperItem@PhiveWrapper@@@Z PROC ; std::_To_address<PhiveWrapper::PhiveWrapperItem *>, COMDAT

; 4395 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4396 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4397 : }

	ret	0
??$_To_address@PEAUPhiveWrapperItem@PhiveWrapper@@@std@@YA?A_PAEBQEAUPhiveWrapperItem@PhiveWrapper@@@Z ENDP ; std::_To_address<PhiveWrapper::PhiveWrapperItem *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@UPhiveWrapperItem@PhiveWrapper@@@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX$$QEAUPhiveWrapperItem@PhiveWrapper@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@UPhiveWrapperItem@PhiveWrapper@@@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX$$QEAUPhiveWrapperItem@PhiveWrapper@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Emplace_back<PhiveWrapper::PhiveWrapperItem>, COMDAT

; 1802 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [r8+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 12

; 1804 :     }

	ret	0
??$_Emplace_back@UPhiveWrapperItem@PhiveWrapper@@@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX$$QEAUPhiveWrapperItem@PhiveWrapper@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperItem> >::_Emplace_back<PhiveWrapper::PhiveWrapperItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UPhiveWrapperItem@PhiveWrapper@@$$V@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@1@QEAUPhiveWrapperItem@PhiveWrapper@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@UPhiveWrapperItem@PhiveWrapper@@$$V@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@1@QEAUPhiveWrapperItem@PhiveWrapper@@@Z PROC ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperItem> >::construct<PhiveWrapper::PhiveWrapperItem>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UPhiveWrapperItem@PhiveWrapper@@$$V@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@1@QEAUPhiveWrapperItem@PhiveWrapper@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperItem> >::construct<PhiveWrapper::PhiveWrapperItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$to_address@UPhiveWrapperItem@PhiveWrapper@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@UPhiveWrapperItem@PhiveWrapper@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@@Z PROC ; std::to_address<PhiveWrapper::PhiveWrapperItem>, COMDAT

; 328  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 329  :     return _Val;

	mov	rax, rcx

; 330  : }

	ret	0
??$to_address@UPhiveWrapperItem@PhiveWrapper@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@@Z ENDP ; std::to_address<PhiveWrapper::PhiveWrapperItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@UPhiveWrapperItem@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperItem@PhiveWrapper@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UPhiveWrapperItem@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperItem@PhiveWrapper@@AEAU12@@Z PROC ; std::forward<PhiveWrapper::PhiveWrapperItem>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@UPhiveWrapperItem@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperItem@PhiveWrapper@@AEAU12@@Z ENDP ; std::forward<PhiveWrapper::PhiveWrapperItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UPhiveWrapperItem@PhiveWrapper@@U12@@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@1@QEAUPhiveWrapperItem@PhiveWrapper@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UPhiveWrapperItem@PhiveWrapper@@U12@@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@1@QEAUPhiveWrapperItem@PhiveWrapper@@$$QEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperItem> >::construct<PhiveWrapper::PhiveWrapperItem,PhiveWrapper::PhiveWrapperItem>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movsd	xmm0, QWORD PTR [r8]
	movsd	QWORD PTR [rdx], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rdx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UPhiveWrapperItem@PhiveWrapper@@U12@@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperItem@PhiveWrapper@@@1@QEAUPhiveWrapperItem@PhiveWrapper@@$$QEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperItem> >::construct<PhiveWrapper::PhiveWrapperItem,PhiveWrapper::PhiveWrapperItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UPhiveWrapperItem@PhiveWrapper@@$$V$0A@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@UPhiveWrapperItem@PhiveWrapper@@$$V$0A@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@@Z PROC ; std::construct_at<PhiveWrapper::PhiveWrapperItem,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@UPhiveWrapperItem@PhiveWrapper@@$$V$0A@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@@Z ENDP ; std::construct_at<PhiveWrapper::PhiveWrapperItem,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UPhiveWrapperItem@PhiveWrapper@@U12@$0A@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@$$QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@UPhiveWrapperItem@PhiveWrapper@@U12@$0A@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@$$QEAU12@@Z PROC ; std::construct_at<PhiveWrapper::PhiveWrapperItem,PhiveWrapper::PhiveWrapperItem,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@UPhiveWrapperItem@PhiveWrapper@@U12@$0A@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@QEAU12@$$QEAU12@@Z ENDP ; std::construct_at<PhiveWrapper::PhiveWrapperItem,PhiveWrapper::PhiveWrapperItem,0>
_TEXT	ENDS
END
