; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_06LMAGPFNF@Update@			; `string'
PUBLIC	??_C@_05KMBJHHBA@Leave@				; `string'
PUBLIC	??_R2UIAINBNodeSplitTiming@@8			; UIAINBNodeSplitTiming::`RTTI Base Class Array'
PUBLIC	??_R3UIAINBNodeSplitTiming@@8			; UIAINBNodeSplitTiming::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7UIAINBNodeSplitTiming@@6B@			; UIAINBNodeSplitTiming::`vftable'
PUBLIC	??_R1A@?0A@EA@UIAINBNodeSplitTiming@@8		; UIAINBNodeSplitTiming::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4UIAINBNodeSplitTiming@@6B@			; UIAINBNodeSplitTiming::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVUIAINBNodeSplitTiming@@@8		; UIAINBNodeSplitTiming `RTTI Type Descriptor'
;	COMDAT ??_R0?AVUIAINBNodeSplitTiming@@@8
data$rs	SEGMENT
??_R0?AVUIAINBNodeSplitTiming@@@8 DQ FLAT:??_7type_info@@6B@ ; UIAINBNodeSplitTiming `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVUIAINBNodeSplitTiming@@', 00H
data$rs	ENDS
;	COMDAT ??_R4UIAINBNodeSplitTiming@@6B@
rdata$r	SEGMENT
??_R4UIAINBNodeSplitTiming@@6B@ DD 01H			; UIAINBNodeSplitTiming::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVUIAINBNodeSplitTiming@@@8
	DD	imagerel ??_R3UIAINBNodeSplitTiming@@8
	DD	imagerel ??_R4UIAINBNodeSplitTiming@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@UIAINBNodeSplitTiming@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@UIAINBNodeSplitTiming@@8 DD imagerel ??_R0?AVUIAINBNodeSplitTiming@@@8 ; UIAINBNodeSplitTiming::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3UIAINBNodeSplitTiming@@8
rdata$r	ENDS
;	COMDAT ??_7UIAINBNodeSplitTiming@@6B@
CONST	SEGMENT
??_7UIAINBNodeSplitTiming@@6B@ DQ FLAT:??_R4UIAINBNodeSplitTiming@@6B@ ; UIAINBNodeSplitTiming::`vftable'
	DQ	FLAT:?Render@UIAINBNodeSplitTiming@@UEAAXXZ
	DQ	FLAT:?RebuildNode@UIAINBNodeSplitTiming@@UEAAXXZ
	DQ	FLAT:?UpdateVisuals@UIAINBNodeBase@@UEAAXXZ
	DQ	FLAT:?PostProcessLinkedNodeInfo@UIAINBNodeSplitTiming@@UEAAXAEAUPin@UIAINBNodeBase@@AEAULinkedNodeInfo@AINBFile@@@Z
	DQ	FLAT:?PostProcessNode@UIAINBNodeBase@@UEAAXXZ
	DQ	FLAT:?GetNodeType@UIAINBNodeBase@@UEAA?AW4NodeType@1@XZ
	DQ	FLAT:?RenderLinks@UIAINBNodeSplitTiming@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
	DQ	FLAT:?GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ
	DQ	FLAT:?GetHeaderColor@UIAINBNodeSplitTiming@@UEAA?AUImColor@@XZ
CONST	ENDS
;	COMDAT ??_R3UIAINBNodeSplitTiming@@8
rdata$r	SEGMENT
??_R3UIAINBNodeSplitTiming@@8 DD 00H			; UIAINBNodeSplitTiming::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2UIAINBNodeSplitTiming@@8
rdata$r	ENDS
;	COMDAT ??_R2UIAINBNodeSplitTiming@@8
rdata$r	SEGMENT
??_R2UIAINBNodeSplitTiming@@8 DD imagerel ??_R1A@?0A@EA@UIAINBNodeSplitTiming@@8 ; UIAINBNodeSplitTiming::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@UIAINBNodeBase@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_C@_05KMBJHHBA@Leave@
CONST	SEGMENT
??_C@_05KMBJHHBA@Leave@ DB 'Leave', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06LMAGPFNF@Update@
CONST	SEGMENT
??_C@_06LMAGPFNF@Update@ DB 'Update', 00H		; `string'
PUBLIC	?GetHeaderColor@UIAINBNodeSplitTiming@@UEAA?AUImColor@@XZ ; UIAINBNodeSplitTiming::GetHeaderColor
PUBLIC	?RenderLinks@UIAINBNodeSplitTiming@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z ; UIAINBNodeSplitTiming::RenderLinks
PUBLIC	?PostProcessLinkedNodeInfo@UIAINBNodeSplitTiming@@UEAAXAEAUPin@UIAINBNodeBase@@AEAULinkedNodeInfo@AINBFile@@@Z ; UIAINBNodeSplitTiming::PostProcessLinkedNodeInfo
PUBLIC	?Render@UIAINBNodeSplitTiming@@UEAAXXZ		; UIAINBNodeSplitTiming::Render
PUBLIC	?GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ ; UIAINBNodeSplitTiming::GenerateNodeShapeInfo
PUBLIC	?RebuildNode@UIAINBNodeSplitTiming@@UEAAXXZ	; UIAINBNodeSplitTiming::RebuildNode
PUBLIC	??0UIAINBNodeSplitTiming@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z ; UIAINBNodeSplitTiming::UIAINBNodeSplitTiming
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RenderLinks@UIAINBNodeSplitTiming@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z DD imagerel $LN112
	DD	imagerel $LN112+88
	DD	imagerel $unwind$?RenderLinks@UIAINBNodeSplitTiming@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?RenderLinks@UIAINBNodeSplitTiming@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z DD imagerel $LN112+88
	DD	imagerel $LN112+483
	DD	imagerel $chain$2$?RenderLinks@UIAINBNodeSplitTiming@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?RenderLinks@UIAINBNodeSplitTiming@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z DD imagerel $LN112+483
	DD	imagerel $LN112+507
	DD	imagerel $chain$3$?RenderLinks@UIAINBNodeSplitTiming@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Render@UIAINBNodeSplitTiming@@UEAAXXZ DD imagerel $LN1273
	DD	imagerel $LN1273+4844
	DD	imagerel $unwind$?Render@UIAINBNodeSplitTiming@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA DD imagerel ?dtor$2@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA
	DD	imagerel ?dtor$2@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$2@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA DD imagerel ?dtor$3@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA
	DD	imagerel ?dtor$3@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA+41
	DD	imagerel $unwind$?dtor$3@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ DD imagerel $LN1353
	DD	imagerel $LN1353+3528
	DD	imagerel $unwind$?GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA DD imagerel ?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA
	DD	imagerel ?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA DD imagerel ?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA
	DD	imagerel ?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA DD imagerel ?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA
	DD	imagerel ?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA DD imagerel ?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA
	DD	imagerel ?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RebuildNode@UIAINBNodeSplitTiming@@UEAAXXZ DD imagerel $LN109
	DD	imagerel $LN109+326
	DD	imagerel $unwind$?RebuildNode@UIAINBNodeSplitTiming@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0UIAINBNodeSplitTiming@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DD imagerel $LN6
	DD	imagerel $LN6+62
	DD	imagerel $unwind$??0UIAINBNodeSplitTiming@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0UIAINBNodeSplitTiming@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DB 04H
	DB	01aH
	DB	00H
	DB	'D'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0UIAINBNodeSplitTiming@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DB 02H
	DB	0cH
	DD	imagerel ??1UIAINBNodeBase@@QEAA@XZ
	DB	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0UIAINBNodeSplitTiming@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DB 028H
	DD	imagerel $stateUnwindMap$??0UIAINBNodeSplitTiming@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
	DD	imagerel $ip2state$??0UIAINBNodeSplitTiming@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0UIAINBNodeSplitTiming@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DD 020a11H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0UIAINBNodeSplitTiming@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RebuildNode@UIAINBNodeSplitTiming@@UEAAXXZ DD 0a1601H
	DD	0c5416H
	DD	0b3416H
	DD	0f0123216H
	DD	0d00ee010H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ DB 01cH
	DB	0feH
	DB	00H
	DB	0a9H, 07H
	DB	02H
	DB	'=', 03H
	DB	00H
	DB	0bcH
	DB	04H
	DB	'0'
	DB	06H
	DB	0b6H
	DB	08H
	DB	081H, 0cH
	DB	00H
	DB	'%', 08H
	DB	0cH
	DB	'.'
	DB	0eH
	DB	0b4H
	DB	010H
	DB	'm', 0fH
	DB	0cH
	DB	0cH
	DB	00H
	DB	0cH
	DB	04H
	DB	0cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ DB 010H
	DB	0eH
	DD	imagerel ?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	02H
	DB	0ceH
	DD	imagerel ?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ
	DD	imagerel $ip2state$?GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ DD 01d5511H
	DD	017d855H
	DD	018c84dH
	DD	019b845H
	DD	01aa83dH
	DD	01b9838H
	DD	01c8833H
	DD	01d782eH
	DD	01e682aH
	DD	0477426H
	DD	0466426H
	DD	0453426H
	DD	03e0126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Render@UIAINBNodeSplitTiming@@UEAAXXZ DB 01eH
	DB	'!', 02H
	DB	00H
	DB	089H, 06H
	DB	02H
	DB	'.'
	DB	00H
	DB	']', 08H
	DB	04H
	DB	'$'
	DB	00H
	DB	0b6H
	DB	06H
	DB	'.'
	DB	08H
	DB	0baH
	DB	0aH
	DB	'y', 02H
	DB	08H
	DB	'U', 03H
	DB	00H
	DB	'q$'
	DB	02H
	DB	'r'
	DB	00H
	DB	'm', 09H
	DB	06H
	DB	0cH
	DB	00H
	DB	'$'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Render@UIAINBNodeSplitTiming@@UEAAXXZ DB 0aH
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
	DB	03eH
	DD	imagerel ?dtor$2@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?Render@UIAINBNodeSplitTiming@@UEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?Render@UIAINBNodeSplitTiming@@UEAAXXZ
	DD	imagerel $ip2state$?Render@UIAINBNodeSplitTiming@@UEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Render@UIAINBNodeSplitTiming@@UEAAXXZ DD 01d6619H
	DD	019d855H
	DD	01ac84dH
	DD	01bb845H
	DD	01ca83dH
	DD	01d9838H
	DD	01e8833H
	DD	01f782eH
	DD	020682aH
	DD	04b7426H
	DD	04a6426H
	DD	0493426H
	DD	0420126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?Render@UIAINBNodeSplitTiming@@UEAAXXZ
	DD	018aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?RenderLinks@UIAINBNodeSplitTiming@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z DD 021H
	DD	imagerel $LN112
	DD	imagerel $LN112+88
	DD	imagerel $unwind$?RenderLinks@UIAINBNodeSplitTiming@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?RenderLinks@UIAINBNodeSplitTiming@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z DD 061021H
	DD	076810H
	DD	017f40bH
	DD	0167404H
	DD	imagerel $LN112
	DD	imagerel $LN112+88
	DD	imagerel $unwind$?RenderLinks@UIAINBNodeSplitTiming@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RenderLinks@UIAINBNodeSplitTiming@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z DD 081601H
	DD	0183416H
	DD	0e00ff216H
	DD	0c00bd00dH
	DD	050086009H
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
;	COMDAT ??0UIAINBNodeSplitTiming@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
_TEXT	SEGMENT
this$ = 64
Node$ = 72
EditorId$ = 80
HeaderBackground$ = 88
EnableFlow$dead$ = 96
??0UIAINBNodeSplitTiming@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z PROC ; UIAINBNodeSplitTiming::UIAINBNodeSplitTiming, COMDAT

; 5    : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx

; 4    :     : UIAINBNodeBase(&Node, EditorId, HeaderBackground, EnableFlow)

	call	??0UIAINBNodeBase@@QEAA@PEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z ; UIAINBNodeBase::UIAINBNodeBase
	npad	1

; 5    : {

	lea	rax, OFFSET FLAT:??_7UIAINBNodeSplitTiming@@6B@
	mov	QWORD PTR [rbx], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.h

; 17   :     uint32_t mPinIdEnter = 0;

	xor	eax, eax
	mov	QWORD PTR [rbx+272], rax

; 18   :     uint32_t mPinIdUpdate = 0;
; 19   :     uint32_t mPinIdLeave = 0;

	mov	DWORD PTR [rbx+280], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 6    :     GenerateNodeShapeInfo();

	mov	rcx, rbx
	call	?GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ ; UIAINBNodeSplitTiming::GenerateNodeShapeInfo
	npad	1

; 7    : }

	mov	rax, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??0UIAINBNodeSplitTiming@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z ENDP ; UIAINBNodeSplitTiming::UIAINBNodeSplitTiming
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
Node$ = 72
EditorId$ = 80
HeaderBackground$ = 88
EnableFlow$dead$ = 96
?dtor$0@?0???0UIAINBNodeSplitTiming@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA PROC ; `UIAINBNodeSplitTiming::UIAINBNodeSplitTiming'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1UIAINBNodeBase@@QEAA@XZ
?dtor$0@?0???0UIAINBNodeSplitTiming@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA ENDP ; `UIAINBNodeSplitTiming::UIAINBNodeSplitTiming'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
;	COMDAT ?RebuildNode@UIAINBNodeSplitTiming@@UEAAXXZ
_TEXT	SEGMENT
$T1 = 80
this$ = 80
?RebuildNode@UIAINBNodeSplitTiming@@UEAAXXZ PROC	; UIAINBNodeSplitTiming::RebuildNode, COMDAT

; 10   : {

$LN109:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 11   :     mNode->Flags.clear();

	mov	rax, QWORD PTR [rcx+8]
	mov	r13, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rdx, QWORD PTR [rax+8]
	cmp	rdx, QWORD PTR [rax+16]
	je	SHORT $LN9@RebuildNod

; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [rax+16], rdx
$LN9@RebuildNod:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 12   :     mNode->Flags.push_back(AINBFile::FlagsStruct::IsResidentNode);

	mov	rcx, QWORD PTR [rcx+8]
	add	rcx, 8
	mov	BYTE PTR $T1[rsp], 6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN15@RebuildNod

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [rdx], 6

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	inc	QWORD PTR [rcx+8]

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN14@RebuildNod
$LN15@RebuildNod:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T1[rsp]
	call	??$_Emplace_reallocate@W4FlagsStruct@AINBFile@@@?$vector@W4FlagsStruct@AINBFile@@V?$allocator@W4FlagsStruct@AINBFile@@@std@@@std@@AEAAPEAW4FlagsStruct@AINBFile@@QEAW423@$$QEAW423@@Z ; std::vector<enum AINBFile::FlagsStruct,std::allocator<enum AINBFile::FlagsStruct> >::_Emplace_reallocate<enum AINBFile::FlagsStruct>
$LN14@RebuildNod:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 14   :     for (int i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	ebp, ebp
	mov	r14d, ebp
	lea	r15d, QWORD PTR [rbp+6]
	npad	2
$LL4@RebuildNod:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r13+8]
	mov	rsi, QWORD PTR [rax+176]
	add	rsi, r14

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rbx, QWORD PTR [rsi]
	mov	rdi, QWORD PTR [rsi+8]
	cmp	rbx, rdi
	je	SHORT $LN21@RebuildNod
	npad	6
$LL27@RebuildNod:
	mov	rcx, rbx
	call	??1InputEntry@AINBFile@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 240				; 000000f0H
	cmp	rbx, rdi
	jne	SHORT $LL27@RebuildNod
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1776 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rsi]
	mov	QWORD PTR [rsi+8], rax
$LN21@RebuildNod:

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r13+8]
	mov	rsi, QWORD PTR [rax+200]
	add	rsi, r14

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rbx, QWORD PTR [rsi]
	mov	rdi, QWORD PTR [rsi+8]
	cmp	rbx, rdi
	je	SHORT $LN2@RebuildNod
$LL44@RebuildNod:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+40]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 72					; 00000048H
	cmp	rbx, rdi
	jne	SHORT $LL44@RebuildNod
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1776 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rsi]
	mov	QWORD PTR [rsi+8], rax
$LN2@RebuildNod:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 14   :     for (int i = 0; i < AINBFile::ValueTypeCount; i++) {

	add	r14, 24
	sub	r15, 1
	jne	SHORT $LL4@RebuildNod
$LL7@RebuildNod:

; 20   :         mNode->LinkedNodes[i].clear();

	mov	rsi, QWORD PTR [r13+8]
	add	rsi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rbx, QWORD PTR [rsi+392]
	mov	rdi, QWORD PTR [rsi+400]
	cmp	rbx, rdi
	je	SHORT $LN5@RebuildNod
	npad	6
$LL68@RebuildNod:
	mov	rcx, rbx
	call	??1LinkedNodeInfo@AINBFile@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 312				; 00000138H
	cmp	rbx, rdi
	jne	SHORT $LL68@RebuildNod
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1776 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rsi+392]
	mov	QWORD PTR [rsi+400], rax
$LN5@RebuildNod:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 19   :     for (int i = 0; i < 10; i++) {

	add	rbp, 24
	cmp	rbp, 240				; 000000f0H
	jl	SHORT $LL7@RebuildNod

; 21   :     }
; 22   : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	ret	0
?RebuildNode@UIAINBNodeSplitTiming@@UEAAXXZ ENDP	; UIAINBNodeSplitTiming::RebuildNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
;	COMDAT ?GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ
_TEXT	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ PROC ; UIAINBNodeSplitTiming::GenerateNodeShapeInfo, COMDAT

; 25   : {

$LN1353:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-280]
	sub	rsp, 496				; 000001f0H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-104], xmm9
	movaps	XMMWORD PTR [rax-120], xmm10
	movaps	XMMWORD PTR [rax-136], xmm11
	movaps	XMMWORD PTR [rax-152], xmm12
	movaps	XMMWORD PTR [rax-168], xmm13
	mov	rsi, rcx
	mov	QWORD PTR this$GSCopy$1$[rbp-256], rcx
	xor	r14d, r14d
	mov	DWORD PTR $T4[rsp], r14d

; 26   :     mNodeShapeInfo.FrameWidth = 8 * 2 + ImGui::CalcTextSize(mNode->GetName().c_str()).x + 24 + ImGui::GetStyle().ItemSpacing.x;

	mov	rdx, QWORD PTR [rcx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp

; 2908 : 	if (this->Type == (uint16_t)AINBFile::NodeTypes::UserDefined)

	movzx	eax, WORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 25   : {

	mov	ebx, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp

; 2908 : 	if (this->Type == (uint16_t)AINBFile::NodeTypes::UserDefined)

	bts	ebx, 12
	lea	rcx, QWORD PTR $T17[rbp-256]
	test	ax, ax
	jne	SHORT $LN1059@GenerateNo

; 2909 : 		return this->Name;

	add	rdx, 32					; 00000020H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	SHORT $LN1344@GenerateNo
$LN1059@GenerateNo:

; 2910 : 
; 2911 : 	return AINBFile::NodeTypeToString((AINBFile::NodeTypes)this->Type);

	movzx	edx, ax
	call	?NodeTypeToString@AINBFile@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4NodeTypes@1@@Z ; AINBFile::NodeTypeToString
$LN1344@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3085 :     return GImGui->Style;

	mov	DWORD PTR $T4[rsp], ebx
	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4107 :         return _Mypair._Myval2._Myptr();

	lea	rax, QWORD PTR $T17[rbp-256]
	mov	rdx, QWORD PTR $T17[rbp-256]
	mov	r8, QWORD PTR $T17[rbp-232]
	cmp	r8, 16
	cmovae	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5418 :     if (text == text_display_end)

	movss	xmm9, DWORD PTR __real@bf800000
	movss	xmm10, DWORD PTR __real@7f7fffff
	movss	xmm11, DWORD PTR __real@3f7fff58
	xorps	xmm7, xmm7
	test	rax, rax
	jne	SHORT $LN1041@GenerateNo
	xorps	xmm0, xmm0

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN1038@GenerateNo
$LN1041@GenerateNo:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r14
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], rax
	movss	DWORD PTR [rsp+32], xmm9
	movaps	xmm3, xmm10
	movss	xmm2, DWORD PTR [rdi+15696]
	lea	rdx, QWORD PTR text_size$9[rbp-256]
	mov	rcx, QWORD PTR [rdi+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$9[rbp-256]
	addss	xmm0, xmm11
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mov	r8, QWORD PTR $T17[rbp-232]
	mov	rdx, QWORD PTR $T17[rbp-256]
$LN1038@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 26   :     mNodeShapeInfo.FrameWidth = 8 * 2 + ImGui::CalcTextSize(mNode->GetName().c_str()).x + 24 + ImGui::GetStyle().ItemSpacing.x;

	movss	xmm8, DWORD PTR __real@41800000
	addss	xmm0, xmm8
	movss	xmm12, DWORD PTR __real@41c00000
	addss	xmm0, xmm12
	addss	xmm0, DWORD PTR [rdi+14628]
	movss	DWORD PTR [rsi+20], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	r8, 16
	jb	SHORT $LN1067@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1067@GenerateNo:

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T17[rbp-240], xmm0

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T17[rbp-256], r14b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 28   :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	r13b, r13b
	movss	xmm13, DWORD PTR __real@42000000
$LN1350@GenerateNo:

; 29   :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	lea	r9, OFFSET FLAT:__ImageBase
	mov	r11, -1
	lea	r10d, QWORD PTR [r11+23]
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
	mov	rcx, QWORD PTR [rsi+8]
	movzx	eax, r13b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rdx, QWORD PTR [rax+rax*2]
	mov	QWORD PTR tv6748[rbp-256], rdx
	mov	rax, QWORD PTR [rcx+176]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 29   :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	mov	r15, QWORD PTR [rax+rdx*8]
	mov	r12, QWORD PTR [rax+rdx*8+8]
	cmp	r15, r12
	je	$LN1327@GenerateNo
	npad	3
$LL7@GenerateNo:

; 31   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	cmp	r13b, 5
	jne	$LN16@GenerateNo
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T8[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T8[rsp+16], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T8[rbp-232], r14

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [r15+48]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r14, QWORD PTR [r15+32]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+56], 16
	jb	SHORT $LN1005@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r14]
$LN1005@GenerateNo:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, r8
	ja	$LN1108@GenerateNo

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	rsi, 16
	jae	SHORT $LN1011@GenerateNo

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T8[rsp+16], rsi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T8[rbp-232], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T8[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN1027@GenerateNo
$LN1011@GenerateNo:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdi, rsi
	or	rdi, 15
	cmp	rdi, r8

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN1022@GenerateNo

; 4716 :             return _Max;

	mov	rdi, r8
	jmp	SHORT $LN1021@GenerateNo
$LN1022@GenerateNo:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rdi, 22
	cmovb	rdi, r10
$LN1021@GenerateNo:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rdi
	add	rdx, 1
	cmovb	rdx, r11
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T8[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T8[rsp+16], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T8[rbp-232], rdi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
$LN1027@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 31   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	lea	rdi, QWORD PTR $T8[rsp]
	or	ebx, 1
	mov	rsi, QWORD PTR this$GSCopy$1$[rbp-256]
	xor	r14d, r14d
	jmp	$LN1345@GenerateNo
$LN16@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 210  :     switch (ValueType) {

	movzx	eax, r13b
	cmp	eax, 5
	ja	$LN880@GenerateNo
	mov	ecx, DWORD PTR $LN1335@GenerateNo[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN874@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T6[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T6[rsp+16], 3

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T6[rsp+24], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_03DBLNGNIM@Int@
	mov	WORD PTR $T6[rsp], ax
	movzx	eax, BYTE PTR ??_C@_03DBLNGNIM@Int@+2
	mov	BYTE PTR $T6[rsp+2], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T6[rsp+3], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 212  :         return "Int";

	jmp	SHORT $LN1346@GenerateNo
$LN875@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:??_C@_04PCGIEMCI@Bool@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 214  :         return "Bool";

	jmp	SHORT $LN1347@GenerateNo
$LN876@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05KKPNNHNB@Float@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 216  :         return "Float";

	jmp	SHORT $LN1347@GenerateNo
$LN877@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 6
	lea	rdx, OFFSET FLAT:??_C@_06ENNEIMBA@String@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 218  :         return "String";

	jmp	SHORT $LN1347@GenerateNo
$LN878@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05PJCBICIO@Vec3f@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 220  :         return "Vec3f";

	jmp	SHORT $LN1347@GenerateNo
$LN879@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 11
	lea	rdx, OFFSET FLAT:??_C@_0M@EALHFGP@UserDefined@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 222  :         return "UserDefined";

	jmp	SHORT $LN1347@GenerateNo
$LN880@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 7
	lea	rdx, OFFSET FLAT:??_C@_07NBCGADJA@Unknown@
$LN1347@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 31   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	xorps	xmm0, xmm0
	movups	XMMWORD PTR $T6[rsp], xmm0
	mov	QWORD PTR $T6[rsp+16], r14
	mov	QWORD PTR $T6[rsp+24], r14
	lea	rcx, QWORD PTR $T6[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
$LN1346@GenerateNo:
	bts	ebx, 11
	lea	rdi, QWORD PTR $T6[rsp]
	or	ebx, 2
$LN1345@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4938 :     const auto _Left_size  = _Left.size();

	mov	DWORD PTR $T4[rsp], ebx
	mov	rcx, QWORD PTR [r15+16]

; 4939 :     const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	rax, r8
	sub	rax, rcx
	cmp	rax, 2
	jb	$LN1110@GenerateNo

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r9, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+24], 16
	jb	SHORT $LN698@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r15]
$LN698@GenerateNo:

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	QWORD PTR [rsp+48], 2
	lea	rax, OFFSET FLAT:??_C@_02GFKOMOKH@?5?$CI@
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, QWORD PTR $T19[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	ebx, 9
	mov	DWORD PTR $T4[rsp], ebx

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	mov	r9, rdi
	lea	r8, QWORD PTR $T19[rbp-256]
	lea	rcx, QWORD PTR $T12[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	ebx, 10
	mov	DWORD PTR $T4[rsp], ebx

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T12[rbp-240]
	mov	rdx, QWORD PTR $T12[rbp-232]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 1
	jb	SHORT $LN636@GenerateNo

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR $T12[rbp-240], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T12[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rax, QWORD PTR $T12[rbp-256]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	WORD PTR [rax+rcx], 41			; 00000029H

; 3277 :             return *this;

	lea	rax, QWORD PTR $T12[rbp-256]
	jmp	SHORT $LN635@GenerateNo
$LN636@GenerateNo:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 1
	lea	r9, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ@
	mov	edx, 1
	lea	rcx, QWORD PTR $T12[rbp-256]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN635@GenerateNo:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T11[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T11[rbp-240], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T11[rbp-232], r14

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T11[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T11[rbp-240], xmm1

; 4998 :     return _STD move(_Left.append(_Right));

	mov	QWORD PTR [rax+16], r14
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	bts	ebx, 8
	mov	DWORD PTR $T4[rsp], ebx

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r8, QWORD PTR $T11[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	mov	rcx, QWORD PTR $T11[rbp-256]
	mov	rdx, QWORD PTR $T11[rbp-232]
	cmp	rdx, 16
	cmovae	r8, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5418 :     if (text == text_display_end)

	test	r8, r8
	jne	SHORT $LN716@GenerateNo

; 5419 :         return ImVec2(0.0f, font_size);

	movaps	xmm6, xmm7
	jmp	SHORT $LN713@GenerateNo
$LN716@GenerateNo:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r14
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], r8
	movss	DWORD PTR [rsp+32], xmm9
	movaps	xmm3, xmm10
	movss	xmm2, DWORD PTR [rax+15696]
	lea	rdx, QWORD PTR text_size$15[rbp-256]
	mov	rcx, QWORD PTR [rax+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$15[rbp-256]
	addss	xmm0, xmm11
	cvttss2si eax, xmm0
	movd	xmm6, eax
	cvtdq2ps xmm6, xmm6
	movss	DWORD PTR text_size$15[rbp-256], xmm6

; 5428 : 
; 5429 :     return text_size;

	mov	rdx, QWORD PTR $T11[rbp-232]
	mov	rcx, QWORD PTR $T11[rbp-256]
$LN713@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 31   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	addss	xmm6, xmm8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN738@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN750@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN747@GenerateNo
$LN750@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN738@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T11[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T11[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T11[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T12[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN767@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T12[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN779@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN776@GenerateNo
$LN779@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN767@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T12[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T12[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T12[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T19[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN796@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T19[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN808@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN805@GenerateNo
$LN808@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN796@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 31   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	test	bl, 2
	je	SHORT $LN854@GenerateNo
	and	ebx, -3
	mov	DWORD PTR $T4[rsp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T6[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN854@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T6[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN866@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN863@GenerateNo
$LN866@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN854@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 31   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	test	bl, 1
	je	SHORT $LN825@GenerateNo
	and	ebx, -2
	mov	DWORD PTR $T4[rsp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T8[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN825@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T8[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN837@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN834@GenerateNo
$LN837@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN825@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 32   :             Width += ImGui::GetStyle().ItemSpacing.x + 24;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm1, DWORD PTR [rax+14628]

; 33   :             Width += GetParamValueWidth(i);

	movzx	edx, r13b
	mov	rcx, rsi
	call	?GetParamValueWidth@UIAINBNodeBase@@QEAAME@Z ; UIAINBNodeBase::GetParamValueWidth

; 32   :             Width += ImGui::GetStyle().ItemSpacing.x + 24;

	movaps	xmm2, xmm1
	addss	xmm2, xmm12
	addss	xmm2, xmm6

; 33   :             Width += GetParamValueWidth(i);

	addss	xmm0, xmm2

; 34   :             if (i == (int)AINBFile::ValueType::Vec3f) {

	cmp	r13b, 4
	jne	SHORT $LN14@GenerateNo

; 35   :                 Width += ImGui::GetStyle().ItemSpacing.x;

	addss	xmm0, xmm1
$LN14@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 140  :     return _CSTD fmaxf(_Xx, _Yx);

	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR [rsi+20]
	call	QWORD PTR __imp_fmaxf
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 37   :             mNodeShapeInfo.FrameWidth = std::fmax(mNodeShapeInfo.FrameWidth, Width);

	movss	DWORD PTR [rsi+20], xmm0

; 29   :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	add	r15, 240				; 000000f0H
	cmp	r15, r12
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
	lea	r9, OFFSET FLAT:__ImageBase
	mov	r10d, 22
	lea	r11, QWORD PTR [r10-23]
	jne	$LL7@GenerateNo
	mov	rdx, QWORD PTR tv6748[rbp-256]
$LN1327@GenerateNo:

; 40   :         for (AINBFile::OutputEntry& Output : mNode->OutputParameters[i]) {

	mov	rax, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax+200]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 40   :         for (AINBFile::OutputEntry& Output : mNode->OutputParameters[i]) {

	mov	r15, QWORD PTR [rcx+rdx*8]
	mov	r12, QWORD PTR [rcx+rdx*8+8]
	cmp	r15, r12
	je	$LN1341@GenerateNo
$LL10@GenerateNo:

; 42   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	cmp	r13b, 5
	jne	$LN18@GenerateNo
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T7[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T7[rsp+16], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T7[rbp-232], r14

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [r15+56]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r14, QWORD PTR [r15+40]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+64], 16
	jb	SHORT $LN594@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r14]
$LN594@GenerateNo:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, r8
	ja	$LN1112@GenerateNo

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	rsi, 16
	jae	SHORT $LN600@GenerateNo

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T7[rsp+16], rsi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T7[rbp-232], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T7[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN616@GenerateNo
$LN600@GenerateNo:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdi, rsi
	or	rdi, 15
	cmp	rdi, r8

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN611@GenerateNo

; 4716 :             return _Max;

	mov	rdi, r8
	jmp	SHORT $LN610@GenerateNo
$LN611@GenerateNo:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rdi, 22
	cmovb	rdi, r10
$LN610@GenerateNo:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rdi
	add	rdx, 1
	cmovb	rdx, r11
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T7[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T7[rsp+16], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T7[rbp-232], rdi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
$LN616@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 42   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	lea	rdi, QWORD PTR $T7[rsp]
	or	ebx, 4
	mov	rsi, QWORD PTR this$GSCopy$1$[rbp-256]
	xor	r14d, r14d
	jmp	$LN1348@GenerateNo
$LN18@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 210  :     switch (ValueType) {

	movzx	eax, r13b
	cmp	eax, 5
	ja	$LN261@GenerateNo
	mov	ecx, DWORD PTR $LN1334@GenerateNo[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN255@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 3

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_03DBLNGNIM@Int@
	mov	WORD PTR $T5[rsp], ax
	movzx	eax, BYTE PTR ??_C@_03DBLNGNIM@Int@+2
	mov	BYTE PTR $T5[rsp+2], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+3], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 212  :         return "Int";

	jmp	$LN1349@GenerateNo
$LN256@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 4

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	DWORD PTR $T5[rsp], 1819242306		; 6c6f6f42H

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+4], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 214  :         return "Bool";

	jmp	$LN1349@GenerateNo
$LN257@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 5

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_05KKPNNHNB@Float@
	mov	DWORD PTR $T5[rsp], eax
	movzx	eax, BYTE PTR ??_C@_05KKPNNHNB@Float@+4
	mov	BYTE PTR $T5[rsp+4], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+5], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 216  :         return "Float";

	jmp	$LN1349@GenerateNo
$LN258@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 6

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_06ENNEIMBA@String@
	mov	DWORD PTR $T5[rsp], eax
	movzx	eax, WORD PTR ??_C@_06ENNEIMBA@String@+4
	mov	WORD PTR $T5[rsp+4], ax

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+6], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 218  :         return "String";

	jmp	$LN1349@GenerateNo
$LN259@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 5

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_05PJCBICIO@Vec3f@
	mov	DWORD PTR $T5[rsp], eax
	movzx	eax, BYTE PTR ??_C@_05PJCBICIO@Vec3f@+4
	mov	BYTE PTR $T5[rsp+4], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+5], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 220  :         return "Vec3f";

	jmp	SHORT $LN1349@GenerateNo
$LN260@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 11

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movsd	xmm0, QWORD PTR ??_C@_0M@EALHFGP@UserDefined@
	movsd	QWORD PTR $T5[rsp], xmm0
	movzx	eax, WORD PTR ??_C@_0M@EALHFGP@UserDefined@+8
	mov	WORD PTR $T5[rsp+8], ax
	movzx	eax, BYTE PTR ??_C@_0M@EALHFGP@UserDefined@+10
	mov	BYTE PTR $T5[rsp+10], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+11], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 222  :         return "UserDefined";

	jmp	SHORT $LN1349@GenerateNo
$LN261@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 7

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rax, QWORD PTR ??_C@_07NBCGADJA@Unknown@
	mov	DWORD PTR $T5[rsp], eax
	movzx	eax, WORD PTR ??_C@_07NBCGADJA@Unknown@+4
	mov	WORD PTR $T5[rsp+4], ax
	movzx	eax, BYTE PTR ??_C@_07NBCGADJA@Unknown@+6
	mov	BYTE PTR $T5[rsp+6], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+7], 0
$LN1349@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 42   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	mov	QWORD PTR $T5[rsp+24], 15
	bts	ebx, 7
	lea	rdi, QWORD PTR $T5[rsp]
	or	ebx, 8
$LN1348@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4938 :     const auto _Left_size  = _Left.size();

	mov	DWORD PTR $T4[rsp], ebx
	mov	rcx, QWORD PTR [r15+16]

; 4939 :     const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	rax, r8
	sub	rax, rcx
	cmp	rax, 2
	jb	$LN1120@GenerateNo

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r9, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+24], 16
	jb	SHORT $LN244@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r15]
$LN244@GenerateNo:

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	QWORD PTR [rsp+48], 2
	lea	rax, OFFSET FLAT:??_C@_02GFKOMOKH@?5?$CI@
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, QWORD PTR $T18[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	or	ebx, 64					; 00000040H
	mov	DWORD PTR $T4[rsp], ebx

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	mov	r9, rdi
	lea	r8, QWORD PTR $T18[rbp-256]
	lea	rcx, QWORD PTR $T14[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	or	ebx, 32					; 00000020H
	mov	DWORD PTR $T4[rsp], ebx

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T14[rbp-240]
	mov	rdx, QWORD PTR $T14[rbp-232]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 1
	jb	SHORT $LN178@GenerateNo

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR $T14[rbp-240], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T14[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rax, QWORD PTR $T14[rbp-256]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	WORD PTR [rax+rcx], 41			; 00000029H

; 3277 :             return *this;

	lea	rax, QWORD PTR $T14[rbp-256]
	jmp	SHORT $LN177@GenerateNo
$LN178@GenerateNo:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 1
	lea	r9, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ@
	mov	edx, 1
	lea	rcx, QWORD PTR $T14[rbp-256]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN177@GenerateNo:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T13[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T13[rbp-240], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T13[rbp-232], r14

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T13[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T13[rbp-240], xmm1

; 4998 :     return _STD move(_Left.append(_Right));

	mov	QWORD PTR [rax+16], r14
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	or	ebx, 16
	mov	DWORD PTR $T4[rsp], ebx

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r8, QWORD PTR $T13[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	mov	rcx, QWORD PTR $T13[rbp-256]
	mov	rdx, QWORD PTR $T13[rbp-232]
	cmp	rdx, 16
	cmovae	r8, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5418 :     if (text == text_display_end)

	test	r8, r8
	jne	SHORT $LN152@GenerateNo

; 5419 :         return ImVec2(0.0f, font_size);

	movaps	xmm6, xmm7
	jmp	SHORT $LN149@GenerateNo
$LN152@GenerateNo:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r14
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], r8
	movss	DWORD PTR [rsp+32], xmm9
	movaps	xmm3, xmm10
	movss	xmm2, DWORD PTR [rax+15696]
	lea	rdx, QWORD PTR text_size$16[rbp-256]
	mov	rcx, QWORD PTR [rax+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$16[rbp-256]
	addss	xmm0, xmm11
	cvttss2si eax, xmm0
	movd	xmm6, eax
	cvtdq2ps xmm6, xmm6
	movss	DWORD PTR text_size$16[rbp-256], xmm6

; 5428 : 
; 5429 :     return text_size;

	mov	rdx, QWORD PTR $T13[rbp-232]
	mov	rcx, QWORD PTR $T13[rbp-256]
$LN149@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 42   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	addss	xmm6, xmm8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN103@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN115@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN112@GenerateNo
$LN115@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN103@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T13[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T13[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T13[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T14[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN73@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T14[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN85@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN82@GenerateNo
$LN85@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN73@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T14[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T14[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T14[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T18[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN132@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T18[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN144@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN141@GenerateNo
$LN144@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN132@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 42   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	test	bl, 8
	je	SHORT $LN566@GenerateNo
	and	ebx, -9
	mov	DWORD PTR $T4[rsp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T5[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN566@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T5[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN578@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN575@GenerateNo
$LN578@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN566@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 42   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	test	bl, 4
	je	SHORT $LN537@GenerateNo
	and	ebx, -5
	mov	DWORD PTR $T4[rsp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T7[rbp-232]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN537@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T7[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN549@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN546@GenerateNo
$LN549@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN537@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 43   :             Width += 2 * ImGui::GetStyle().ItemSpacing.x + 32;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm1, DWORD PTR [rax+14628]
	addss	xmm1, xmm1
	addss	xmm1, xmm13
	addss	xmm1, xmm6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 140  :     return _CSTD fmaxf(_Xx, _Yx);

	movss	xmm0, DWORD PTR [rsi+20]
	call	QWORD PTR __imp_fmaxf
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 44   :             mNodeShapeInfo.FrameWidth = std::fmax(mNodeShapeInfo.FrameWidth, Width);

	movss	DWORD PTR [rsi+20], xmm0

; 40   :         for (AINBFile::OutputEntry& Output : mNode->OutputParameters[i]) {

	add	r15, 72					; 00000048H
	cmp	r15, r12
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
	lea	r9, OFFSET FLAT:__ImageBase
	mov	r10d, 22
	lea	r11, QWORD PTR [r10-23]
	jne	$LL10@GenerateNo
	mov	rdx, QWORD PTR tv6748[rbp-256]
$LN1341@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rax+152]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 47   :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	mov	r14, QWORD PTR [rcx+rdx*8+8]
	mov	rdi, QWORD PTR [rcx+rdx*8]
	cmp	rdi, r14
	je	$LN2@GenerateNo
	xor	r15d, r15d
	npad	2
$LL13@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN44@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN44@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5418 :     if (text == text_display_end)

	test	rax, rax
	jne	SHORT $LN51@GenerateNo

; 5419 :         return ImVec2(0.0f, font_size);

	movaps	xmm1, xmm7
	jmp	SHORT $LN48@GenerateNo
$LN51@GenerateNo:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r15
	mov	QWORD PTR [rsp+48], r15
	mov	QWORD PTR [rsp+40], rax
	movss	DWORD PTR [rsp+32], xmm9
	movaps	xmm3, xmm10
	movss	xmm2, DWORD PTR [rsi+15696]
	lea	rdx, QWORD PTR text_size$10[rbp-256]
	mov	rcx, QWORD PTR [rsi+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$10[rbp-256]
	addss	xmm0, xmm11
	cvttss2si eax, xmm0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	movss	DWORD PTR text_size$10[rbp-256], xmm1
$LN48@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 51   :             Width += GetParamValueWidth(i);

	movzx	edx, r13b
	mov	rcx, QWORD PTR this$GSCopy$1$[rbp-256]
	call	?GetParamValueWidth@UIAINBNodeBase@@QEAAME@Z ; UIAINBNodeBase::GetParamValueWidth

; 48   :             float Width = 8 * 2;
; 49   :             Width += ImGui::CalcTextSize(Immediate.Name.c_str()).x;

	addss	xmm1, xmm8

; 50   :             Width += ImGui::GetStyle().ItemSpacing.x;

	addss	xmm1, DWORD PTR [rsi+14628]

; 51   :             Width += GetParamValueWidth(i);

	addss	xmm0, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 140  :     return _CSTD fmaxf(_Xx, _Yx);

	movaps	xmm1, xmm0
	mov	rsi, rcx
	movss	xmm0, DWORD PTR [rcx+20]
	call	QWORD PTR __imp_fmaxf
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 52   :             mNodeShapeInfo.FrameWidth = std::fmax(mNodeShapeInfo.FrameWidth, Width);

	movss	DWORD PTR [rsi+20], xmm0

; 47   :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	add	rdi, 200				; 000000c8H
	cmp	rdi, r14
	jne	$LL13@GenerateNo
$LN2@GenerateNo:

; 28   :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	inc	r13b
	cmp	r13b, 6
	jae	SHORT $LN1331@GenerateNo
	xor	r14d, r14d
	jmp	$LN1350@GenerateNo
$LN747@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN776@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN805@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN863@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN834@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN112@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN82@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN141@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN575@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN546@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1331@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 55   : }

	lea	r11, QWORD PTR [rsp+496]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN1120@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4941 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1108@GenerateNo:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1110@GenerateNo:

; 4941 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1112@GenerateNo:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1343@GenerateNo:
	npad	2
$LN1335@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 55   : }

	DD	$LN874@GenerateNo
	DD	$LN875@GenerateNo
	DD	$LN876@GenerateNo
	DD	$LN877@GenerateNo
	DD	$LN878@GenerateNo
	DD	$LN879@GenerateNo
$LN1334@GenerateNo:
	DD	$LN255@GenerateNo
	DD	$LN256@GenerateNo
	DD	$LN257@GenerateNo
	DD	$LN258@GenerateNo
	DD	$LN259@GenerateNo
	DD	$LN260@GenerateNo
?GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ ENDP ; UIAINBNodeSplitTiming::GenerateNodeShapeInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA PROC ; `UIAINBNodeSplitTiming::GenerateNodeShapeInfo'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T4[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN22@dtor$1
	and	DWORD PTR $T4[rbp], -2
	lea	rcx, QWORD PTR $T8[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN22@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSplitTiming::GenerateNodeShapeInfo'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA PROC ; `UIAINBNodeSplitTiming::GenerateNodeShapeInfo'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T4[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN24@dtor$2
	and	DWORD PTR $T4[rbp], -3
	lea	rcx, QWORD PTR $T6[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN24@dtor$2:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSplitTiming::GenerateNodeShapeInfo'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$3@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA PROC ; `UIAINBNodeSplitTiming::GenerateNodeShapeInfo'::`1'::dtor$3
	lea	rcx, QWORD PTR $T19[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSplitTiming::GenerateNodeShapeInfo'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$4@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA PROC ; `UIAINBNodeSplitTiming::GenerateNodeShapeInfo'::`1'::dtor$4
	lea	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSplitTiming::GenerateNodeShapeInfo'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA PROC ; `UIAINBNodeSplitTiming::GenerateNodeShapeInfo'::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T4[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN31@dtor$6
	and	DWORD PTR $T4[rbp], -5
	lea	rcx, QWORD PTR $T7[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN31@dtor$6:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSplitTiming::GenerateNodeShapeInfo'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA PROC ; `UIAINBNodeSplitTiming::GenerateNodeShapeInfo'::`1'::dtor$7
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T4[rbp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN33@dtor$7
	and	DWORD PTR $T4[rbp], -9
	lea	rcx, QWORD PTR $T5[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN33@dtor$7:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSplitTiming::GenerateNodeShapeInfo'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$8@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA PROC ; `UIAINBNodeSplitTiming::GenerateNodeShapeInfo'::`1'::dtor$8
	lea	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSplitTiming::GenerateNodeShapeInfo'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$9@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA PROC ; `UIAINBNodeSplitTiming::GenerateNodeShapeInfo'::`1'::dtor$9
	lea	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$9@?0??GenerateNodeShapeInfo@UIAINBNodeSplitTiming@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSplitTiming::GenerateNodeShapeInfo'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_node_editor\imgui_node_editor_api.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_node_editor\imgui_node_editor_api.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
;	COMDAT ?Render@UIAINBNodeSplitTiming@@UEAAXXZ
_TEXT	SEGMENT
tv6997 = 64
$T9 = 64
i$1$ = 68
HasImmediate$1$ = 69
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 72
_Result$1$ = 104
_Result$1$ = 104
$T18 = 104
tv6734 = 104
tv6687 = 104
$T19 = 104
tv6986 = 112
tv6664 = 112
this$GSCopy$1$ = 120
<end>$L2$1$ = 120
text_size$20 = 120
text_size$21 = 120
text_size$22 = 120
CurrentId$1$ = 128
$T23 = 136
$T24 = 136
HeaderRect$25 = 136
$T26 = 136
$T27 = 152
$T28 = 152
$T29 = 152
$T30 = 152
$T31 = 152
$T32 = 152
$T33 = 192
$T34 = 200
$T35 = 200
$T36 = 200
$T37 = 200
$T38 = 200
$T39 = 200
$T40 = 200
$T41 = 216
$T42 = 248
$T43 = 280
<end>$L0$1$ = 288
$T44 = 288
tv7127 = 304
$T45 = 312
$T46 = 344
_Temp$47 = 360
$T48 = 360
$T49 = 360
$T50 = 360
$T51 = 360
$T52 = 360
__$ArrayPad$ = 392
this$ = 576
?Render@UIAINBNodeSplitTiming@@UEAAXXZ PROC		; UIAINBNodeSplitTiming::Render, COMDAT

; 58   : {

$LN1273:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-312]
	sub	rsp, 528				; 00000210H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-104], xmm9
	movaps	XMMWORD PTR [rax-120], xmm10
	movaps	XMMWORD PTR [rax-136], xmm11
	movaps	XMMWORD PTR [rax-152], xmm12
	movaps	XMMWORD PTR [rax-168], xmm13
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r13, rcx
	mov	QWORD PTR this$GSCopy$1$[rsp], rcx
	xor	r14d, r14d
	mov	DWORD PTR $T9[rsp], r14d

; 59   :     uint32_t CurrentId = mEditorId;

	mov	ebx, DWORD PTR [rcx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm0, XMMWORD PTR __xmm@41000000410000004100000041000000
	movups	XMMWORD PTR $T26[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 62   :     ed::PushStyleVar(ed::StyleVar_NodePadding, ImVec4(8, 8, 8, 8));

	lea	rdx, QWORD PTR $T26[rbp-256]
	call	?PushStyleVar@NodeEditor@ax@@YAXW4StyleVar@12@AEBUImVec4@@@Z ; ax::NodeEditor::PushStyleVar

; 63   :     ed::BeginNode(CurrentId++);

	mov	edx, ebx
	inc	ebx
	mov	DWORD PTR CurrentId$1$[rbp-256], ebx
	mov	esi, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_node_editor\imgui_node_editor_api.cpp

; 148  :     s_Editor->GetNodeBuilder().Begin(id);

	mov	rcx, QWORD PTR ?s_Editor@@3PEAUEditorContext@Detail@NodeEditor@ax@@EA
	add	rcx, 1032				; 00000408H
	call	?Begin@NodeBuilder@Detail@NodeEditor@ax@@QEAAXUNodeId@34@@Z ; ax::NodeEditor::Detail::NodeBuilder::Begin
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 67   :     if (mEnableFlow) {

	mov	rax, QWORD PTR [r13+256]
	movss	xmm13, DWORD PTR __real@41000000
	lea	r15d, QWORD PTR [r14+1]
	lea	r12, QWORD PTR [r14-1]
	movss	xmm12, DWORD PTR __real@437f0000
	cmp	BYTE PTR [rax], r14b
	je	$LN22@Render

; 68   :         float Alpha = ImGui::GetStyle().Alpha;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm6, DWORD PTR [rax+14552]

; 69   :         ImGui::PushStyleVar(ImGuiStyleVar_Alpha, Alpha);

	movaps	xmm1, xmm6
	xor	ecx, ecx
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 70   :         ImRect HeaderRect = DrawPin(CurrentId++, mFlowLinked, Alpha * 255, UIAINBNodeBase::PinType::Flow, ed::PinKind::Input, mNode->GetName());

	mov	rdx, QWORD PTR [r13+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp

; 2908 : 	if (this->Type == (uint16_t)AINBFile::NodeTypes::UserDefined)

	movzx	eax, WORD PTR [rdx]
	lea	rcx, QWORD PTR $T52[rbp-256]
	test	ax, ax
	jne	SHORT $LN1059@Render

; 2909 : 		return this->Name;

	add	rdx, 32					; 00000020H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	SHORT $LN1265@Render
$LN1059@Render:

; 2910 : 
; 2911 : 	return AINBFile::NodeTypeToString((AINBFile::NodeTypes)this->Type);

	movzx	edx, ax
	call	?NodeTypeToString@AINBFile@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4NodeTypes@1@@Z ; AINBFile::NodeTypeToString
$LN1265@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 70   :         ImRect HeaderRect = DrawPin(CurrentId++, mFlowLinked, Alpha * 255, UIAINBNodeBase::PinType::Flow, ed::PinKind::Input, mNode->GetName());

	mov	edi, 64					; 00000040H
	mov	DWORD PTR $T9[rsp], edi
	mov	r8d, ebx
	inc	ebx
	mov	DWORD PTR CurrentId$1$[rbp-256], ebx
	mulss	xmm6, xmm12
	cvttss2si rax, xmm6
	lea	rcx, QWORD PTR $T52[rbp-256]
	mov	QWORD PTR [rsp+56], rcx
	mov	DWORD PTR [rsp+48], r14d
	mov	DWORD PTR [rsp+40], 6
	mov	DWORD PTR [rsp+32], eax
	movzx	r9d, BYTE PTR [r13+264]
	lea	rdx, QWORD PTR HeaderRect$25[rbp-256]
	call	?DrawPin@UIAINBNodeBase@@QEAA?AUImRect@@I_NIW4PinType@1@W4PinKind@NodeEditor@ax@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; UIAINBNodeBase::DrawPin

; 71   :         ImGui::PopStyleVar();

	mov	ecx, r15d
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 72   :         mPins.insert({ CurrentId - 1, Pin { .Kind = ed::PinKind::Input, .Type = UIAINBNodeBase::PinType::Flow, .Node = mNode } });

	lea	rcx, QWORD PTR [r13+120]
	mov	DWORD PTR $T17[rsp], r14d
	mov	DWORD PTR $T17[rsp+4], 6
	mov	rax, QWORD PTR [r13+8]
	mov	QWORD PTR $T17[rsp+8], rax
	mov	QWORD PTR $T17[rsp+16], r14
	mov	DWORD PTR $T17[rsp+24], r12d
	mov	WORD PTR $T17[rsp+28], r15w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	DWORD PTR $T32[rbp-256], esi
	movups	xmm0, XMMWORD PTR $T17[rsp]
	movups	XMMWORD PTR $T32[rbp-248], xmm0
	movups	xmm1, XMMWORD PTR $T17[rsp+16]
	movups	XMMWORD PTR $T32[rbp-232], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T32[rbp-256]
	lea	rdx, QWORD PTR $T44[rbp-256]
	call	??$emplace@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IUPin@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIUPin@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Pin,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 74   :         mNodeShapeInfo.HeaderMin = ImVec2(HeaderRect.GetTL().x - 32 - ImGui::GetStyle().ItemSpacing.x - 1, HeaderRect.GetTL().y - 14);

	movss	xmm0, DWORD PTR HeaderRect$25[rbp-252]
	subss	xmm0, DWORD PTR __real@41600000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3085 :     return GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 74   :         mNodeShapeInfo.HeaderMin = ImVec2(HeaderRect.GetTL().x - 32 - ImGui::GetStyle().ItemSpacing.x - 1, HeaderRect.GetTL().y - 14);

	movss	xmm1, DWORD PTR HeaderRect$25[rbp-256]
	subss	xmm1, DWORD PTR __real@42000000
	subss	xmm1, DWORD PTR [rax+14628]
	subss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR [r13+24], xmm1
	movss	DWORD PTR [r13+28], xmm0

; 75   :         mNodeShapeInfo.HeaderMax = ImVec2(mNodeShapeInfo.HeaderMin.x + mNodeShapeInfo.FrameWidth + 10, HeaderRect.GetBR().y + 12);

	movss	xmm2, DWORD PTR HeaderRect$25[rbp-244]
	addss	xmm2, DWORD PTR __real@41400000
	lea	esi, QWORD PTR [rdi-32]

; 76   :     } else {

	jmp	$LN1266@Render
$LN22@Render:

; 77   :         ImGui::Text(mNode->GetName().c_str());

	mov	rdx, QWORD PTR [r13+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp

; 2908 : 	if (this->Type == (uint16_t)AINBFile::NodeTypes::UserDefined)

	movzx	eax, WORD PTR [rdx]
	lea	rcx, QWORD PTR $T16[rsp]
	test	ax, ax
	jne	SHORT $LN1036@Render

; 2909 : 		return this->Name;

	add	rdx, 32					; 00000020H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	SHORT $LN1267@Render
$LN1036@Render:

; 2910 : 
; 2911 : 	return AINBFile::NodeTypeToString((AINBFile::NodeTypes)this->Type);

	movzx	edx, ax
	call	?NodeTypeToString@AINBFile@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4NodeTypes@1@@Z ; AINBFile::NodeTypeToString
$LN1267@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 77   :         ImGui::Text(mNode->GetName().c_str());

	mov	esi, 32					; 00000020H
	mov	DWORD PTR $T9[rsp], esi
	mov	edi, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T16[rsp]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T16[rsp+24], 16
	cmovae	rcx, QWORD PTR $T16[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 77   :         ImGui::Text(mNode->GetName().c_str());

	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T16[rsp+24]
	cmp	r8, 16
	jb	SHORT $LN1024@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T16[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1024@Render:

; 4839 :         }
; 4840 : 
; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T16[rsp+16], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T16[rsp+24], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T16[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5637 :     return g.LastItemData.Rect.Min;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm0, DWORD PTR [rax+18632]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 78   :         mNodeShapeInfo.HeaderMin = ImVec2(ImGui::GetItemRectMin().x - 1 - ImGui::GetStyle().ItemSpacing.x, ImGui::GetItemRectMin().y - 9);

	subss	xmm0, DWORD PTR __real@41100000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5637 :     return g.LastItemData.Rect.Min;

	movss	xmm1, DWORD PTR [rax+18628]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 78   :         mNodeShapeInfo.HeaderMin = ImVec2(ImGui::GetItemRectMin().x - 1 - ImGui::GetStyle().ItemSpacing.x, ImGui::GetItemRectMin().y - 9);

	subss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR [rax+14628]
	movss	DWORD PTR [r13+24], xmm1
	movss	DWORD PTR [r13+28], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5643 :     return g.LastItemData.Rect.Max;

	movss	xmm2, DWORD PTR [rax+18640]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 79   :         mNodeShapeInfo.HeaderMax = ImVec2(mNodeShapeInfo.HeaderMin.x + mNodeShapeInfo.FrameWidth + 10, ImGui::GetItemRectMax().y + 8);

	addss	xmm2, xmm13
$LN1266@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	r11, r13
	addss	xmm1, DWORD PTR [r13+20]
	mov	rax, r13
	addss	xmm1, DWORD PTR __real@41200000
	movss	DWORD PTR [r13+rsi], xmm1
	movss	DWORD PTR [rax+36], xmm2
	xorps	xmm10, xmm10
	mov	DWORD PTR $T19[rsp], 0
	mov	DWORD PTR $T19[rsp+4], 1090519040	; 41000000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 82   :     ImGui::Dummy(ImVec2(0, 8));

	lea	rcx, QWORD PTR $T19[rsp]
	call	?Dummy@ImGui@@YAXAEBUImVec2@@@Z		; ImGui::Dummy

; 83   : 
; 84   :     mNodeShapeInfo.HeaderMax.x += 8;

	movss	xmm0, DWORD PTR [r13+rsi]
	addss	xmm0, xmm13
	movss	DWORD PTR [r13+rsi], xmm0

; 85   : 
; 86   :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	r12b, r12b
	movss	xmm11, DWORD PTR __real@bf800000
	npad	15
$LL4@Render:

; 87   :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	mov	rcx, QWORD PTR [r13+8]
	movzx	eax, r12b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rdx, QWORD PTR [rax+rax*2]
	mov	QWORD PTR tv7127[rbp-256], rdx
	mov	rax, QWORD PTR [rcx+176]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 87   :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	mov	r14, QWORD PTR [rax+rdx*8]
	mov	rax, QWORD PTR [rax+rdx*8+8]
	mov	QWORD PTR <end>$L0$1$[rbp-256], rax
	cmp	r14, rax
	je	$LN1234@Render
	lea	r15d, DWORD PTR [rbx-1]
	mov	DWORD PTR tv6664[rsp], r15d
	lea	rsi, QWORD PTR [r14+160]
	npad	3
$LL7@Render:

; 88   : 
; 89   :             // Input param (-> Name [Value])
; 90   :             float Alpha = ImGui::GetStyle().Alpha;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm6, DWORD PTR [rbx+14552]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3210 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	lea	rcx, QWORD PTR [rbx+18840]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1033 :     ImGuiStyleMod(ImGuiStyleVar idx, float v)   { VarIdx = idx; BackupFloat[0] = v; }

	mov	DWORD PTR $T23[rbp-256], 0
	movss	DWORD PTR $T23[rbp-252], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3210 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	lea	rdx, QWORD PTR $T23[rbp-256]
	call	?push_back@?$ImVector@UImGuiStyleMod@@@@QEAAXAEBUImGuiStyleMod@@@Z ; ImVector<ImGuiStyleMod>::push_back

; 3211 :         *pvar = val;

	movss	DWORD PTR [rbx+14552], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 92   :             DrawPin(CurrentId++, Input.NodeIndex >= 0 || !Input.Sources.empty(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Input, Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")");

	cmp	r12b, 5
	jne	$LN41@Render
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T15[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T15[rsp+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T15[rsp+24], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r15, QWORD PTR [rsi-112]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR [rsi-128]
	mov	QWORD PTR _Result$1$[rsp], rax

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi-104], 16
	jb	SHORT $LN927@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Result$1$[rsp], rax
$LN927@Render:

; 2620 :         if (_Count > max_size()) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	cmp	r15, rcx
	ja	$LN1091@Render

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r15, 16
	jae	SHORT $LN933@Render

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T15[rsp+16], r15

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T15[rsp+24], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T15[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN949@Render
$LN933@Render:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r15
	or	rbx, 15
	cmp	rbx, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN944@Render

; 4716 :             return _Max;

	mov	rbx, rcx
	jmp	SHORT $LN943@Render
$LN944@Render:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN943@Render:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T15[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T15[rsp+16], r15

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T15[rsp+24], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r15+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, QWORD PTR _Result$1$[rsp]
	mov	rcx, rax
	call	memcpy
$LN949@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 92   :             DrawPin(CurrentId++, Input.NodeIndex >= 0 || !Input.Sources.empty(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Input, Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")");

	lea	rbx, QWORD PTR $T15[rsp]
	or	edi, 1
	mov	r15d, DWORD PTR tv6664[rsp]
	jmp	SHORT $LN1268@Render
$LN41@Render:
	movzx	r8d, r12b
	lea	rdx, QWORD PTR $T51[rbp-256]
	call	?GetValueTypeName@UIAINBNodeBase@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z ; UIAINBNodeBase::GetValueTypeName
	mov	rbx, rax
	or	edi, 2
$LN1268@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4938 :     const auto _Left_size  = _Left.size();

	mov	DWORD PTR $T9[rsp], edi
	mov	rax, QWORD PTR [rsi-144]

; 4939 :     const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	sub	rcx, rax
	cmp	rcx, 2
	jb	$LN1092@Render

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r9, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi-136], 16
	jb	SHORT $LN692@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r14]
$LN692@Render:

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	QWORD PTR [rsp+48], 2
	lea	rcx, OFFSET FLAT:??_C@_02GFKOMOKH@?5?$CI@
	mov	QWORD PTR [rsp+40], rcx
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR $T31[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	or	edi, 4
	mov	DWORD PTR $T9[rsp], edi

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	mov	r9, rbx
	lea	r8, QWORD PTR $T31[rbp-256]
	lea	rcx, QWORD PTR $T41[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	or	edi, 8
	mov	DWORD PTR $T9[rsp], edi

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rdx, QWORD PTR $T41[rbp-240]
	mov	r8, QWORD PTR $T41[rbp-232]
	mov	rax, r8
	sub	rax, rdx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	lea	rcx, QWORD PTR $T41[rbp-256]
	cmp	rax, 1
	jb	SHORT $LN709@Render

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR $T41[rbp-240], rax

; 2227 :         if (_Large_string_engaged()) {

	cmp	r8, 16
	cmovae	rcx, QWORD PTR $T41[rbp-256]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	movzx	eax, WORD PTR ??_C@_01PKGAHCOL@?$CJ@
	mov	BYTE PTR [rcx+rdx], al

; 3276 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rcx+rdx+1], 0

; 3277 :             return *this;

	lea	rax, QWORD PTR $T41[rbp-256]
	jmp	SHORT $LN708@Render
$LN709@Render:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	eax, 1
	mov	QWORD PTR [rsp+32], rax
	lea	r9, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ@
	mov	edx, eax
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN708@Render:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T45[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r10d, r10d
	mov	QWORD PTR $T45[rbp-240], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T45[rbp-232], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T45[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T45[rbp-240], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], r10

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], r10b

; 4998 :     return _STD move(_Left.append(_Right));

	or	edi, 16
	mov	DWORD PTR $T9[rsp], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 92   :             DrawPin(CurrentId++, Input.NodeIndex >= 0 || !Input.Sources.empty(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Input, Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")");

	movzx	edx, r12b
	call	?ValueTypeToPinType@UIAINBNodeBase@@QEAA?AW4PinType@1@E@Z ; UIAINBNodeBase::ValueTypeToPinType
	mov	DWORD PTR tv6734[rsp], eax
	mulss	xmm6, xmm12
	cvttss2si rdx, xmm6
	cmp	WORD PTR [rsi-96], r10w
	jge	SHORT $LN1230@Render
	mov	rcx, QWORD PTR [rsi]
	cmp	QWORD PTR [rsi-8], rcx
	jne	SHORT $LN1230@Render
	xor	r9d, r9d
	jmp	SHORT $LN44@Render
$LN1230@Render:
	mov	r9b, 1
$LN44@Render:
	mov	ebx, DWORD PTR CurrentId$1$[rbp-256]
	mov	r8d, ebx
	inc	ebx
	mov	DWORD PTR CurrentId$1$[rbp-256], ebx
	inc	r15d
	mov	DWORD PTR tv6664[rsp], r15d
	lea	rcx, QWORD PTR $T45[rbp-256]
	mov	QWORD PTR [rsp+56], rcx
	mov	DWORD PTR [rsp+48], r10d
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], edx
	lea	rdx, QWORD PTR $T46[rbp-256]
	call	?DrawPin@UIAINBNodeBase@@QEAA?AUImRect@@I_NIW4PinType@1@W4PinKind@NodeEditor@ax@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; UIAINBNodeBase::DrawPin
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T41[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN782@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T41[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN782@Render:

; 4839 :         }
; 4840 : 
; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T41[rbp-240], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T41[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T41[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T31[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN790@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T31[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1
$LN790@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 92   :             DrawPin(CurrentId++, Input.NodeIndex >= 0 || !Input.Sources.empty(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Input, Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")");

	test	dil, 2
	je	SHORT $LN913@Render
	and	edi, -3
	mov	DWORD PTR $T9[rsp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T51[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN912@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T51[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN912@Render:

; 4839 :         }
; 4840 : 
; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T51[rbp-240], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T51[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T51[rbp-256], 0
$LN913@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 92   :             DrawPin(CurrentId++, Input.NodeIndex >= 0 || !Input.Sources.empty(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Input, Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")");

	test	dil, 1
	je	SHORT $LN962@Render
	and	edi, -2
	mov	DWORD PTR $T9[rsp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T15[rsp+24]
	cmp	r8, 16
	jb	SHORT $LN962@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T15[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN962@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 93   :             ImGui::PopStyleVar();

	mov	ecx, 1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r13+72]
	mov	rcx, QWORD PTR tv7127[rbp-256]
	lea	rcx, QWORD PTR [rax+rcx*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 94   :             mInputParameters[i].push_back(CurrentId - 1);

	mov	DWORD PTR $T33[rbp-256], r15d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN816@Render

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [rdx], r15d

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 4

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN815@Render
$LN816@Render:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T33[rbp-256]
	call	??$_Emplace_reallocate@I@?$vector@IV?$allocator@I@std@@@std@@AEAAPEAIQEAI$$QEAI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Emplace_reallocate<unsigned int>
$LN815@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 95   :             mPins.insert({ CurrentId - 1, Pin { .Kind = ed::PinKind::Input, .Type = ValueTypeToPinType(i), .Node = mNode, .ObjectPtr = &Input } });

	lea	rcx, QWORD PTR [r13+120]
	mov	DWORD PTR $T14[rsp], 0
	mov	eax, DWORD PTR tv6734[rsp]
	mov	DWORD PTR $T14[rsp+4], eax
	mov	rax, QWORD PTR [r13+8]
	mov	QWORD PTR $T14[rsp+8], rax
	mov	QWORD PTR $T14[rsp+16], r14
	mov	rax, -1
	mov	DWORD PTR $T14[rsp+24], eax
	mov	WORD PTR $T14[rsp+28], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	DWORD PTR $T30[rbp-256], r15d
	movups	xmm0, XMMWORD PTR $T14[rsp]
	movups	XMMWORD PTR $T30[rbp-248], xmm0
	movups	xmm1, XMMWORD PTR $T14[rsp+16]
	movups	XMMWORD PTR $T30[rbp-232], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T30[rbp-256]
	lea	rdx, QWORD PTR $T40[rbp-256]
	call	??$emplace@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IUPin@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIUPin@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Pin,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 96   :             ImGui::SameLine();

	movaps	xmm1, xmm11
	movaps	xmm0, xmm10
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 97   :             if (Input.NodeIndex == -1 && Input.Sources.empty()) { // Input param is not linked to any output param, so the value has to be set directly

	cmp	WORD PTR [rsi-96], -1
	jne	$LN24@Render
	mov	rax, QWORD PTR [rsi]
	cmp	QWORD PTR [rsi-8], rax
	jne	$LN24@Render
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T42[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T42[rbp-240], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T42[rbp-232], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r15, QWORD PTR [rsi-144]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, r14
	mov	QWORD PTR _Result$1$[rsp], rax

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi-136], 16
	jb	SHORT $LN981@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [r14]
	mov	QWORD PTR _Result$1$[rsp], rax
$LN981@Render:

; 2620 :         if (_Count > max_size()) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	cmp	r15, rcx
	ja	$LN1093@Render

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T42[rbp-232], 15
	cmp	r15, 16
	jae	SHORT $LN987@Render

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T42[rbp-240], r15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T42[rbp-256], xmm0

; 2647 :             return;

	jmp	SHORT $LN995@Render
$LN987@Render:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;
; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, r15
	lea	rcx, QWORD PTR $T42[rbp-256]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T42[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T42[rbp-240], r15

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T42[rbp-232], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r15+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, QWORD PTR _Result$1$[rsp]
	mov	rcx, rax
	call	memcpy
	mov	ebx, DWORD PTR CurrentId$1$[rbp-256]
$LN995@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 98   :                 DrawParameterValue(static_cast<AINBFile::ValueType>(i), Input.Name, CurrentId, (void*)&Input.Value);

	lea	rax, QWORD PTR [rsi-56]
	movzx	edx, r12b
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, ebx
	lea	r8, QWORD PTR $T42[rbp-256]
	mov	rcx, r13
	call	?DrawParameterValue@UIAINBNodeBase@@QEAAXW4ValueType@AINBFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPEAX@Z ; UIAINBNodeBase::DrawParameterValue

; 99   :             } else {

	mov	r15d, DWORD PTR tv6664[rsp]
	jmp	SHORT $LN5@Render
$LN24@Render:

; 100  :                 if (i == (int)AINBFile::ValueType::UserDefined) {

	cmp	r12b, 5
	jne	SHORT $LN26@Render

; 101  :                     ImGui::NewLine();

	call	?NewLine@ImGui@@YAXXZ			; ImGui::NewLine

; 102  :                 } else {

	jmp	SHORT $LN5@Render
$LN26@Render:

; 103  :                     ImGui::Dummy(ImVec2(GetParamValueWidth(i), 0));

	movzx	edx, r12b
	mov	rcx, r13
	call	?GetParamValueWidth@UIAINBNodeBase@@QEAAME@Z ; UIAINBNodeBase::GetParamValueWidth
	movss	DWORD PTR $T43[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	DWORD PTR $T43[rbp-252], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 103  :                     ImGui::Dummy(ImVec2(GetParamValueWidth(i), 0));

	lea	rcx, QWORD PTR $T43[rbp-256]
	call	?Dummy@ImGui@@YAXAEBUImVec2@@@Z		; ImGui::Dummy
$LN5@Render:

; 87   :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	add	r14, 240				; 000000f0H
	add	rsi, 240				; 000000f0H
	cmp	r14, QWORD PTR <end>$L0$1$[rbp-256]
	jne	$LL7@Render
$LN1234@Render:

; 85   : 
; 86   :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	lea	r15, QWORD PTR [r13+120]
	mov	DWORD PTR $T18[rsp], ebx
	inc	r12b
	cmp	r12b, 6
	jb	$LL4@Render

; 104  :                 }
; 105  :             }
; 106  :         }
; 107  :     }
; 108  : 
; 109  :     bool HasEnterLink = false;

	xor	dil, dil

; 110  :     bool HasUpdateLink = false;

	xor	bl, bl
	mov	DWORD PTR tv6986[rsp], ebx

; 111  :     bool HasLeaveLink = false;

	xor	r11b, r11b
	mov	DWORD PTR tv6997[rsp], r11d

; 112  :     for (AINBFile::LinkedNodeInfo& Info : mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink]) {

	mov	rax, QWORD PTR [r13+8]
	mov	r14, QWORD PTR [rax+448]

; 104  :                 }
; 105  :             }
; 106  :         }
; 107  :     }
; 108  : 
; 109  :     bool HasEnterLink = false;

	mov	rsi, QWORD PTR [rax+440]

; 112  :     for (AINBFile::LinkedNodeInfo& Info : mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink]) {

	lea	rax, OFFSET FLAT:??_C@_05IAOCCJNL@Enter@
	lea	r12, OFFSET FLAT:??_C@_05KMBJHHBA@Leave@
	cmp	rsi, r14
	je	$LN9@Render

; 104  :                 }
; 105  :             }
; 106  :         }
; 107  :     }
; 108  : 
; 109  :     bool HasEnterLink = false;

	lea	rdx, QWORD PTR [rsi+104]
	mov	r13d, 1
	npad	11
$LL10@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	mov	r9, QWORD PTR [rdx+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r8, rdx

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	r10, QWORD PTR [rdx+24]

; 2236 :         if (_Large_string_engaged()) {

	cmp	r10, 16
	jb	SHORT $LN1233@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rdx]
$LN1233@Render:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r9, 5
	jne	SHORT $LN28@Render

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	xor	ecx, ecx
	npad	4
$LL1257@Render:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	lea	r12, OFFSET FLAT:??_C@_05IAOCCJNL@Enter@
	cmp	al, BYTE PTR [r12+rcx-1]
	lea	r12, OFFSET FLAT:??_C@_05KMBJHHBA@Leave@
	jne	SHORT $LN1258@Render
	cmp	rcx, 5
	jne	SHORT $LL1257@Render
	xor	eax, eax
	jmp	SHORT $LN1259@Render
$LN1258@Render:
	sbb	eax, eax
	or	eax, r13d
$LN1259@Render:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	movzx	edi, dil
	test	eax, eax
	cmove	edi, r13d
$LN28@Render:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r8, rdx

; 2236 :         if (_Large_string_engaged()) {

	cmp	r10, 16
	jb	SHORT $LN1231@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rdx]
$LN1231@Render:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r9, 6
	jne	SHORT $LN29@Render

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	xor	ecx, ecx
	npad	6
$LL1253@Render:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	lea	r12, OFFSET FLAT:??_C@_06LMAGPFNF@Update@
	cmp	al, BYTE PTR [r12+rcx-1]
	lea	r12, OFFSET FLAT:??_C@_05KMBJHHBA@Leave@
	jne	SHORT $LN1254@Render
	cmp	rcx, 6
	jne	SHORT $LL1253@Render
	xor	eax, eax
	jmp	SHORT $LN1255@Render
$LN1254@Render:
	sbb	eax, eax
	or	eax, r13d
$LN1255@Render:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	movzx	ebx, bl
	test	eax, eax
	cmove	ebx, r13d
$LN29@Render:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r8, rdx

; 2236 :         if (_Large_string_engaged()) {

	cmp	r10, 16
	jb	SHORT $LN1232@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rdx]
$LN1232@Render:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r9, 5
	jne	SHORT $LN8@Render

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	xor	ecx, ecx
	npad	7
$LL1249@Render:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	cmp	al, BYTE PTR [r12+rcx-1]
	jne	SHORT $LN1250@Render
	cmp	rcx, 5
	jne	SHORT $LL1249@Render
	xor	eax, eax
	jmp	SHORT $LN1251@Render
$LN1250@Render:
	sbb	eax, eax
	or	eax, r13d
$LN1251@Render:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	movzx	r11d, r11b
	test	eax, eax
	cmove	r11d, r13d
$LN8@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 112  :     for (AINBFile::LinkedNodeInfo& Info : mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink]) {

	add	rsi, 312				; 00000138H
	add	rdx, 312				; 00000138H
	cmp	rsi, r14
	jne	$LL10@Render
	mov	DWORD PTR tv6986[rsp], ebx
	mov	DWORD PTR tv6997[rsp], r11d
	mov	r13, QWORD PTR this$GSCopy$1$[rsp]
	lea	rax, OFFSET FLAT:??_C@_05IAOCCJNL@Enter@
$LN9@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3085 :     return GImGui->Style;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	xor	r14d, r14d
	mov	QWORD PTR [rsp+56], r14
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], rax
	movss	DWORD PTR [rsp+32], xmm11
	movss	xmm9, DWORD PTR __real@7f7fffff
	movaps	xmm3, xmm9
	movss	xmm2, DWORD PTR [rbx+15696]
	lea	rdx, QWORD PTR text_size$22[rsp]
	mov	rcx, QWORD PTR [rbx+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 10264:     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rax, QWORD PTR [rbx+16408]

; 10265:     return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;

	movss	xmm2, DWORD PTR [rax+312]
	subss	xmm2, DWORD PTR [rax+80]
	addss	xmm2, DWORD PTR [rax+184]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 121  :     ImGui::SetCursorPosX(ImGui::GetCursorPosX() + mNodeShapeInfo.FrameWidth - (8 + ImGui::CalcTextSize("Enter").x + 18 + ImGui::GetStyle().ItemSpacing.x));

	addss	xmm2, DWORD PTR [r13+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$22[rsp]
	movss	xmm8, DWORD PTR __real@3f7fff58
	addss	xmm0, xmm8
	cvttss2si eax, xmm0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 121  :     ImGui::SetCursorPosX(ImGui::GetCursorPosX() + mNodeShapeInfo.FrameWidth - (8 + ImGui::CalcTextSize("Enter").x + 18 + ImGui::GetStyle().ItemSpacing.x));

	addss	xmm1, xmm13
	movss	xmm7, DWORD PTR __real@41900000
	addss	xmm1, xmm7
	addss	xmm1, DWORD PTR [rbx+14628]
	subss	xmm2, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rbx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10285:     window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;

	movss	xmm0, DWORD PTR [rax+80]
	subss	xmm0, DWORD PTR [rax+184]
	addss	xmm0, xmm2
	movss	DWORD PTR [rax+312], xmm0

; 10286:     //window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
; 10287:     window->DC.IsSetPos = true;

	mov	BYTE PTR [rax+377], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 122  :     float Alpha = ImGui::GetStyle().Alpha;

	movss	xmm6, DWORD PTR [rbx+14552]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3210 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	lea	rcx, QWORD PTR [rbx+18840]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1033 :     ImGuiStyleMod(ImGuiStyleVar idx, float v)   { VarIdx = idx; BackupFloat[0] = v; }

	mov	DWORD PTR $T24[rbp-256], r14d
	movss	DWORD PTR $T24[rbp-252], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3210 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	lea	rdx, QWORD PTR $T24[rbp-256]
	call	?push_back@?$ImVector@UImGuiStyleMod@@@@QEAAXAEBUImGuiStyleMod@@@Z ; ImVector<ImGuiStyleMod>::push_back

; 3211 :         *pvar = val;

	movss	DWORD PTR [rbx+14552], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 124  :     DrawPin(CurrentId++, HasEnterLink, Alpha * 255, UIAINBNodeBase::PinType::Flow, ed::PinKind::Output, "Enter");

	mov	r12d, DWORD PTR CurrentId$1$[rbp-256]
	lea	esi, DWORD PTR [r12+1]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T50[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T50[rbp-240], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T50[rbp-232], r14

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r14+5]
	lea	rdx, OFFSET FLAT:??_C@_05IAOCCJNL@Enter@
	lea	rcx, QWORD PTR $T50[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 124  :     DrawPin(CurrentId++, HasEnterLink, Alpha * 255, UIAINBNodeBase::PinType::Flow, ed::PinKind::Output, "Enter");

	mulss	xmm6, xmm12
	cvttss2si r14, xmm6
	lea	rax, QWORD PTR $T50[rbp-256]
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], 1
	mov	DWORD PTR [rsp+40], 6
	mov	DWORD PTR [rsp+32], r14d
	movzx	r9d, dil
	mov	r8d, r12d
	lea	rdx, QWORD PTR $T39[rbp-256]
	call	?DrawPin@UIAINBNodeBase@@QEAA?AUImRect@@I_NIW4PinType@1@W4PinKind@NodeEditor@ax@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; UIAINBNodeBase::DrawPin

; 125  :     mPins.insert({ CurrentId - 1, UIAINBNodeBase::Pin { .Kind = ed::PinKind::Output, .Type = UIAINBNodeBase::PinType::Flow, .Node = mNode, .ParameterIndex = 0, .AllowMultipleLinks = false, .AlreadyLinked = HasEnterLink } });

	mov	eax, 1
	mov	DWORD PTR $T13[rsp], eax
	mov	DWORD PTR $T13[rsp+4], 6
	mov	rax, QWORD PTR [r13+8]
	mov	QWORD PTR $T13[rsp+8], rax
	xor	eax, eax
	mov	QWORD PTR $T13[rsp+16], rax
	mov	DWORD PTR $T13[rsp+24], eax
	mov	BYTE PTR $T13[rsp+28], al
	mov	BYTE PTR $T13[rsp+29], dil
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	ebx, DWORD PTR $T18[rsp]
	mov	DWORD PTR $T29[rbp-256], ebx
	movups	xmm0, XMMWORD PTR $T13[rsp]
	movups	XMMWORD PTR $T29[rbp-248], xmm0
	movups	xmm1, XMMWORD PTR $T13[rsp+16]
	movups	XMMWORD PTR $T29[rbp-232], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T29[rbp-256]
	lea	rdx, QWORD PTR $T38[rbp-256]
	mov	rcx, r15
	call	??$emplace@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IUPin@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIUPin@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Pin,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 126  :     mPinIdEnter = CurrentId - 1;

	mov	DWORD PTR [r13+272], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10264:     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rbx+16408]

; 10265:     return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;

	movss	xmm6, DWORD PTR [rax+312]
	subss	xmm6, DWORD PTR [rax+80]
	addss	xmm6, DWORD PTR [rax+184]

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	xor	eax, eax
	mov	QWORD PTR [rsp+56], rax
	mov	QWORD PTR [rsp+48], rax
	lea	rax, OFFSET FLAT:??_C@_06LMAGPFNF@Update@
	mov	QWORD PTR [rsp+40], rax
	movss	DWORD PTR [rsp+32], xmm11
	movaps	xmm3, xmm9
	movss	xmm2, DWORD PTR [rbx+15696]
	lea	rdx, QWORD PTR text_size$20[rsp]
	mov	rcx, QWORD PTR [rbx+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 128  :     ImGui::SetCursorPosX(ImGui::GetCursorPosX() + mNodeShapeInfo.FrameWidth - (8 + ImGui::CalcTextSize("Update").x + 18 + ImGui::GetStyle().ItemSpacing.x));

	addss	xmm6, DWORD PTR [r13+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$20[rsp]
	addss	xmm0, xmm8
	cvttss2si eax, xmm0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 128  :     ImGui::SetCursorPosX(ImGui::GetCursorPosX() + mNodeShapeInfo.FrameWidth - (8 + ImGui::CalcTextSize("Update").x + 18 + ImGui::GetStyle().ItemSpacing.x));

	addss	xmm1, xmm13
	addss	xmm1, xmm7
	addss	xmm1, DWORD PTR [rbx+14628]
	subss	xmm6, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rbx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10285:     window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;

	movss	xmm0, DWORD PTR [rax+80]
	subss	xmm0, DWORD PTR [rax+184]
	addss	xmm0, xmm6
	movss	DWORD PTR [rax+312], xmm0

; 10286:     //window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
; 10287:     window->DC.IsSetPos = true;

	mov	BYTE PTR [rax+377], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 129  :     DrawPin(CurrentId++, HasUpdateLink, Alpha * 255, UIAINBNodeBase::PinType::Flow, ed::PinKind::Output, "Update");

	lea	ebx, DWORD PTR [r12+1]
	add	r12d, 2
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T49[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T49[rbp-240], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T49[rbp-232], rax

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rax+6]
	lea	rdx, OFFSET FLAT:??_C@_06LMAGPFNF@Update@
	lea	rcx, QWORD PTR $T49[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 129  :     DrawPin(CurrentId++, HasUpdateLink, Alpha * 255, UIAINBNodeBase::PinType::Flow, ed::PinKind::Output, "Update");

	lea	rax, QWORD PTR $T49[rbp-256]
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], 1
	mov	DWORD PTR [rsp+40], 6
	mov	DWORD PTR [rsp+32], r14d
	movzx	r9d, BYTE PTR tv6986[rsp]
	mov	r8d, ebx
	lea	rdx, QWORD PTR $T37[rbp-256]
	call	?DrawPin@UIAINBNodeBase@@QEAA?AUImRect@@I_NIW4PinType@1@W4PinKind@NodeEditor@ax@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; UIAINBNodeBase::DrawPin

; 130  :     mPins.insert({ CurrentId - 1, UIAINBNodeBase::Pin { .Kind = ed::PinKind::Output, .Type = UIAINBNodeBase::PinType::Flow, .Node = mNode, .ParameterIndex = 1, .AllowMultipleLinks = false, .AlreadyLinked = HasUpdateLink } });

	mov	ecx, 1
	mov	DWORD PTR $T12[rsp], ecx
	mov	DWORD PTR $T12[rsp+4], 6
	mov	rax, QWORD PTR [r13+8]
	mov	QWORD PTR $T12[rsp+8], rax
	mov	QWORD PTR $T12[rsp+16], 0
	mov	DWORD PTR $T12[rsp+24], ecx
	mov	BYTE PTR $T12[rsp+28], 0
	mov	eax, DWORD PTR tv6986[rsp]
	mov	BYTE PTR $T12[rsp+29], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	DWORD PTR $T28[rbp-256], esi
	movups	xmm0, XMMWORD PTR $T12[rsp]
	movups	XMMWORD PTR $T28[rbp-248], xmm0
	movups	xmm1, XMMWORD PTR $T12[rsp+16]
	movups	XMMWORD PTR $T28[rbp-232], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T28[rbp-256]
	lea	rdx, QWORD PTR $T36[rbp-256]
	mov	rcx, r15
	call	??$emplace@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IUPin@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIUPin@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Pin,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 131  :     mPinIdUpdate = CurrentId - 1;

	mov	DWORD PTR [r13+276], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3085 :     return GImGui->Style;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	xor	esi, esi
	mov	QWORD PTR [rsp+56], rsi
	mov	QWORD PTR [rsp+48], rsi
	lea	rax, OFFSET FLAT:??_C@_05KMBJHHBA@Leave@
	mov	QWORD PTR [rsp+40], rax
	movss	DWORD PTR [rsp+32], xmm11
	movaps	xmm3, xmm9
	movss	xmm2, DWORD PTR [rbx+15696]
	lea	rdx, QWORD PTR text_size$21[rsp]
	mov	rcx, QWORD PTR [rbx+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 10264:     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rax, QWORD PTR [rbx+16408]

; 10265:     return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;

	movss	xmm2, DWORD PTR [rax+312]
	subss	xmm2, DWORD PTR [rax+80]
	addss	xmm2, DWORD PTR [rax+184]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 133  :     ImGui::SetCursorPosX(ImGui::GetCursorPosX() + mNodeShapeInfo.FrameWidth - (8 + ImGui::CalcTextSize("Leave").x + 18 + ImGui::GetStyle().ItemSpacing.x));

	addss	xmm2, DWORD PTR [r13+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$21[rsp]
	addss	xmm0, xmm8
	cvttss2si eax, xmm0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 133  :     ImGui::SetCursorPosX(ImGui::GetCursorPosX() + mNodeShapeInfo.FrameWidth - (8 + ImGui::CalcTextSize("Leave").x + 18 + ImGui::GetStyle().ItemSpacing.x));

	addss	xmm1, xmm13
	addss	xmm1, xmm7
	addss	xmm1, DWORD PTR [rbx+14628]
	subss	xmm2, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rbx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10285:     window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;

	movss	xmm0, DWORD PTR [rax+80]
	subss	xmm0, DWORD PTR [rax+184]
	addss	xmm0, xmm2
	movss	DWORD PTR [rax+312], xmm0

; 10286:     //window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
; 10287:     window->DC.IsSetPos = true;

	mov	BYTE PTR [rax+377], 1
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T48[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T48[rbp-240], rsi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T48[rbp-232], rsi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rsi+5]
	lea	rdx, OFFSET FLAT:??_C@_05KMBJHHBA@Leave@
	lea	rcx, QWORD PTR $T48[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 134  :     DrawPin(CurrentId++, HasLeaveLink, Alpha * 255, UIAINBNodeBase::PinType::Flow, ed::PinKind::Output, "Leave");

	lea	rax, QWORD PTR $T48[rbp-256]
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], 1
	mov	DWORD PTR [rsp+40], 6
	mov	DWORD PTR [rsp+32], r14d
	mov	esi, DWORD PTR tv6997[rsp]
	movzx	r9d, sil
	mov	r8d, r12d
	lea	rdx, QWORD PTR $T35[rbp-256]
	call	?DrawPin@UIAINBNodeBase@@QEAA?AUImRect@@I_NIW4PinType@1@W4PinKind@NodeEditor@ax@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; UIAINBNodeBase::DrawPin

; 135  :     ImGui::PopStyleVar();

	mov	ebx, 1
	mov	ecx, ebx
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 136  :     mPins.insert({ CurrentId - 1, UIAINBNodeBase::Pin { .Kind = ed::PinKind::Output, .Type = UIAINBNodeBase::PinType::Flow, .Node = mNode, .ParameterIndex = 2, .AllowMultipleLinks = false, .AlreadyLinked = HasLeaveLink } });

	mov	DWORD PTR $T11[rsp], ebx
	mov	DWORD PTR $T11[rsp+4], 6
	mov	rax, QWORD PTR [r13+8]
	mov	QWORD PTR $T11[rsp+8], rax
	xor	r14d, r14d
	mov	QWORD PTR $T11[rsp+16], r14
	mov	DWORD PTR $T11[rsp+24], 2
	mov	BYTE PTR $T11[rsp+28], r14b
	mov	BYTE PTR $T11[rsp+29], sil
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	DWORD PTR $T27[rbp-256], r12d
	movups	xmm0, XMMWORD PTR $T11[rsp]
	movups	XMMWORD PTR $T27[rbp-248], xmm0
	movups	xmm1, XMMWORD PTR $T11[rsp+16]
	movups	XMMWORD PTR $T27[rbp-232], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T27[rbp-256]
	lea	rdx, QWORD PTR $T34[rbp-256]
	mov	rcx, r15
	call	??$emplace@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IUPin@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIUPin@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Pin,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 137  :     mPinIdLeave = CurrentId - 1;

	mov	DWORD PTR [r13+280], r12d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10258:     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm7, DWORD PTR [rcx+316]
	subss	xmm7, DWORD PTR [rcx+84]
	movss	xmm6, DWORD PTR [rcx+312]
	subss	xmm6, DWORD PTR [rcx+80]

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm7, DWORD PTR [rcx+188]
	addss	xmm6, DWORD PTR [rcx+184]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 140  :     bool HasImmediate = false;

	mov	BYTE PTR HasImmediate$1$[rsp], r14b

; 141  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	dl, dl
	mov	rax, QWORD PTR [r13+8]
	mov	r8, QWORD PTR [rax+152]
$LL13@Render:

; 142  :         if (!mNode->ImmediateParameters[i].empty()) {

	movzx	eax, dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rcx, QWORD PTR [rax+rax*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 142  :         if (!mNode->ImmediateParameters[i].empty()) {

	mov	rax, QWORD PTR [r8+rcx*8+8]
	cmp	QWORD PTR [r8+rcx*8], rax
	jne	SHORT $LN1094@Render

; 141  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	inc	dl
	cmp	dl, 6
	jb	SHORT $LL13@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2620 :         if (_Count > max_size()) {

	jmp	SHORT $LN32@Render
$LN1094@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 143  :             HasImmediate = true;

	mov	BYTE PTR HasImmediate$1$[rsp], bl

; 144  :             break;
; 145  :         }
; 146  :     }
; 147  : 
; 148  :     if (HasImmediate)
; 149  :         ImGui::NewLine();

	call	?NewLine@ImGui@@YAXXZ			; ImGui::NewLine
$LN32@Render:

; 150  : 
; 151  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	r8b, r8b
	mov	BYTE PTR i$1$[rsp], r8b
	lea	r15, OFFSET FLAT:__ImageBase
$LL16@Render:

; 152  :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	mov	rdx, QWORD PTR [r13+8]
	movzx	eax, r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rcx, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR [rdx+152]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 152  :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	mov	rsi, QWORD PTR [rax+rcx*8]
	mov	rax, QWORD PTR [rax+rcx*8+8]
	mov	QWORD PTR <end>$L2$1$[rsp], rax
	cmp	rsi, rax
	je	$LN14@Render
	lea	rbx, QWORD PTR [rsi+64]
	movzx	edi, r8b
	mov	DWORD PTR tv6687[rsp], edi
	npad	7
$LL19@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx-40], 16
	jb	SHORT $LN1236@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rsi]
$LN1236@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 256  :     TextEx(text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);

	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+1]
	call	?TextEx@ImGui@@YAXPEBD0H@Z		; ImGui::TextEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 155  :             ImGui::SameLine();

	movaps	xmm1, xmm11
	movaps	xmm0, xmm10
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rdx, BYTE PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 157  :             bool ValueTypeMismatch = Immediate.ValueType != Immediate.Value.index();

	movsxd	rax, DWORD PTR [rbx+8]

; 158  :             if (ValueTypeMismatch) {

	cmp	rax, rdx
	je	$LN387@Render

; 159  :                 switch (i) {

	mov	ecx, edi
	test	edi, edi
	je	$LN34@Render
	sub	ecx, 1
	je	$LN36@Render
	sub	ecx, 1
	je	$LN35@Render
	sub	ecx, 1
	je	SHORT $LN37@Render
	cmp	ecx, 1
	jne	$LN387@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1031 :         if (index() == _TargetIdx) {

	cmp	dl, 4
	jne	SHORT $LN521@Render

; 1032 :             auto& _Target = _STD _Variant_raw_get<_TargetIdx>(_Storage());
; 1033 :             _Target       = static_cast<_Ty&&>(_Obj);

	movaps	xmm0, xmm10
	unpcklps xmm0, xmm10
	movsd	QWORD PTR [rbx-32], xmm0
	movss	DWORD PTR [rbx-24], xmm10

; 1034 :         } else {

	jmp	$LN387@Render
$LN521@Render:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1247@Render[r15+rdx*4+4]
	add	rax, r15
	jmp	rax
$LN541@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN559@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 391  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movaps	xmm0, xmm10
	unpcklps xmm0, xmm10
	movsd	QWORD PTR [rbx-32], xmm0
	movss	DWORD PTR [rbx-24], xmm10

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 4
	jmp	$LN387@Render
$LN37@Render:

; 1031 :         if (index() == _TargetIdx) {

	cmp	dl, 3
	jne	SHORT $LN118@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3395 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rcx, QWORD PTR [rbx-32]
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1034 :         } else {

	jmp	$LN387@Render
$LN118@Render:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR _Temp$47[rbp-256], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR _Temp$47[rbp-240], r14

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR _Temp$47[rbp-232], 15

; 2631 : 
; 2632 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2633 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2634 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2635 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2636 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR _Temp$47[rbp-256], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1246@Render[r15+rdx*4+4]
	add	rax, r15
	jmp	rax
$LN183@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN201@Render:

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR _Temp$47[rbp-256]
	movups	XMMWORD PTR [rbx-32], xmm0
	movups	xmm1, XMMWORD PTR _Temp$47[rbp-240]
	movups	XMMWORD PTR [rbx-16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 171  :                     break;

	jmp	SHORT $LN387@Render
$LN35@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1031 :         if (index() == _TargetIdx) {

	cmp	dl, 2
	je	SHORT $LN1269@Render

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1245@Render[r15+rdx*4+4]
	add	rax, r15
	jmp	rax
$LN409@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN427@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	DWORD PTR [rbx-32], r14d

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 165  :                     break;

	jmp	SHORT $LN387@Render
$LN36@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1031 :         if (index() == _TargetIdx) {

	cmp	dl, 1
	je	SHORT $LN1270@Render

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1244@Render[r15+rdx*4+4]
	add	rax, r15
	jmp	rax
$LN485@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN503@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 1
$LN1270@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 168  :                     break;

	mov	rcx, -32				; ffffffffffffffe0H
	mov	rax, rbx
	mov	BYTE PTR [rcx+rbx], 0
	jmp	SHORT $LN387@Render
$LN34@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1031 :         if (index() == _TargetIdx) {

	test	dl, dl
	je	SHORT $LN1269@Render

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1243@Render[r15+rdx*4+4]
	add	rax, r15
	jmp	rax
$LN355@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN373@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 0
$LN1269@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	mov	DWORD PTR [rbx-32], r14d
$LN387@Render:
	xorps	xmm0, xmm0
	movups	XMMWORD PTR $T10[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T10[rsp+16], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T10[rsp+24], r14

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rbx-48]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rsi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx-40], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN1235@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rsi]
$LN1235@Render:

; 2620 :         if (_Count > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	r14, rax
	ja	$LN1096@Render

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T10[rsp+24], 15
	cmp	r14, 16
	jae	SHORT $LN89@Render

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T10[rsp+16], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T10[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN105@Render
$LN89@Render:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdi, r14
	or	rdi, 15

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	cmp	rdi, rax
	jbe	SHORT $LN100@Render

; 4716 :             return _Max;

	mov	rdi, rax
	jmp	SHORT $LN99@Render
$LN100@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	cmp	rdi, 22
	mov	eax, 22
	cmovb	rdi, rax
$LN99@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rdi
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T10[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T10[rsp+16], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T10[rsp+24], rdi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	mov	edi, DWORD PTR tv6687[rsp]
$LN105@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 178  :             DrawParameterValue(static_cast<AINBFile::ValueType>(i), Immediate.Name, CurrentId, (void*)&Immediate.Value);

	lea	rax, QWORD PTR [rbx-32]
	mov	QWORD PTR [rsp+32], rax
	lea	r9d, DWORD PTR [r12+1]
	lea	r8, QWORD PTR $T10[rsp]
	mov	edx, edi
	mov	rcx, r13
	call	?DrawParameterValue@UIAINBNodeBase@@QEAAXW4ValueType@AINBFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPEAX@Z ; UIAINBNodeBase::DrawParameterValue

; 152  :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	add	rsi, 200				; 000000c8H
	add	rbx, 200				; 000000c8H
	cmp	rsi, QWORD PTR <end>$L2$1$[rsp]
	mov	r14d, 0
	lea	r15, OFFSET FLAT:__ImageBase
	jne	$LL19@Render
	movzx	r8d, BYTE PTR i$1$[rsp]
$LN14@Render:

; 150  : 
; 151  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	inc	r8b
	mov	BYTE PTR i$1$[rsp], r8b
	cmp	r8b, 6
	jb	$LL16@Render
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_node_editor\imgui_node_editor_api.cpp

; 193  :     s_Editor->GetNodeBuilder().End();

	mov	rcx, QWORD PTR ?s_Editor@@3PEAUEditorContext@Detail@NodeEditor@ax@@EA
	add	rcx, 1032				; 00000408H
	call	?End@NodeBuilder@Detail@NodeEditor@ax@@QEAAXXZ ; ax::NodeEditor::Detail::NodeBuilder::End
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 183  :     ed::PopStyleVar();

	call	?PopStyleVar@NodeEditor@ax@@YAXH@Z	; ax::NodeEditor::PopStyleVar

; 184  : 
; 185  :     DrawNodeHeader();

	mov	rcx, r13
	call	?DrawNodeHeader@UIAINBNodeBase@@QEAAXXZ	; UIAINBNodeBase::DrawNodeHeader

; 186  :     if (HasImmediate)

	cmp	BYTE PTR HasImmediate$1$[rsp], 0
	je	SHORT $LN39@Render

; 187  :         DrawImmediateSeperator(CursorPos);

	movaps	xmm0, xmm6
	unpcklps xmm0, xmm7
	movq	rdx, xmm0
	mov	rcx, r13
	call	?DrawImmediateSeperator@UIAINBNodeBase@@QEAAXUImVec2@@@Z ; UIAINBNodeBase::DrawImmediateSeperator
$LN39@Render:

; 188  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+528]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN554@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN196@Render:
$LN422@Render:
$LN498@Render:
$LN368@Render:
$LN1092@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4941 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1096@Render:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1091@Render:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1093@Render:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1264@Render:
$LN1247@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 188  : }

	DD	$LN559@Render
	DD	$LN559@Render
	DD	$LN559@Render
	DD	$LN559@Render
	DD	$LN541@Render
	DD	$LN559@Render
$LN1246@Render:
	DD	$LN201@Render
	DD	$LN201@Render
	DD	$LN201@Render
	DD	$LN201@Render
	DD	$LN183@Render
	DD	$LN201@Render
$LN1245@Render:
	DD	$LN427@Render
	DD	$LN427@Render
	DD	$LN427@Render
	DD	$LN427@Render
	DD	$LN409@Render
	DD	$LN427@Render
$LN1244@Render:
	DD	$LN503@Render
	DD	$LN503@Render
	DD	$LN503@Render
	DD	$LN503@Render
	DD	$LN485@Render
	DD	$LN503@Render
$LN1243@Render:
	DD	$LN373@Render
	DD	$LN373@Render
	DD	$LN373@Render
	DD	$LN373@Render
	DD	$LN355@Render
	DD	$LN373@Render
?Render@UIAINBNodeSplitTiming@@UEAAXXZ ENDP		; UIAINBNodeSplitTiming::Render
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv6997 = 64
$T9 = 64
i$1$ = 68
HasImmediate$1$ = 69
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 72
_Result$1$ = 104
_Result$1$ = 104
$T18 = 104
tv6734 = 104
tv6687 = 104
$T19 = 104
tv6986 = 112
tv6664 = 112
this$GSCopy$1$ = 120
<end>$L2$1$ = 120
text_size$20 = 120
text_size$21 = 120
text_size$22 = 120
CurrentId$1$ = 128
$T23 = 136
$T24 = 136
HeaderRect$25 = 136
$T26 = 136
$T27 = 152
$T28 = 152
$T29 = 152
$T30 = 152
$T31 = 152
$T32 = 152
$T33 = 192
$T34 = 200
$T35 = 200
$T36 = 200
$T37 = 200
$T38 = 200
$T39 = 200
$T40 = 200
$T41 = 216
$T42 = 248
$T43 = 280
<end>$L0$1$ = 288
$T44 = 288
tv7127 = 304
$T45 = 312
$T46 = 344
_Temp$47 = 360
$T48 = 360
$T49 = 360
$T50 = 360
$T51 = 360
$T52 = 360
__$ArrayPad$ = 392
this$ = 576
?dtor$1@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA PROC ; `UIAINBNodeSplitTiming::Render'::`1'::dtor$1
	lea	rcx, QWORD PTR $T16[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSplitTiming::Render'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv6997 = 64
$T9 = 64
i$1$ = 68
HasImmediate$1$ = 69
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 72
_Result$1$ = 104
_Result$1$ = 104
$T18 = 104
tv6734 = 104
tv6687 = 104
$T19 = 104
tv6986 = 112
tv6664 = 112
this$GSCopy$1$ = 120
<end>$L2$1$ = 120
text_size$20 = 120
text_size$21 = 120
text_size$22 = 120
CurrentId$1$ = 128
$T23 = 136
$T24 = 136
HeaderRect$25 = 136
$T26 = 136
$T27 = 152
$T28 = 152
$T29 = 152
$T30 = 152
$T31 = 152
$T32 = 152
$T33 = 192
$T34 = 200
$T35 = 200
$T36 = 200
$T37 = 200
$T38 = 200
$T39 = 200
$T40 = 200
$T41 = 216
$T42 = 248
$T43 = 280
<end>$L0$1$ = 288
$T44 = 288
tv7127 = 304
$T45 = 312
$T46 = 344
_Temp$47 = 360
$T48 = 360
$T49 = 360
$T50 = 360
$T51 = 360
$T52 = 360
__$ArrayPad$ = 392
this$ = 576
?dtor$2@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA PROC ; `UIAINBNodeSplitTiming::Render'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T9[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN48@dtor$2
	and	DWORD PTR $T9[rbp], -2
	lea	rcx, QWORD PTR $T15[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN48@dtor$2:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSplitTiming::Render'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv6997 = 64
$T9 = 64
i$1$ = 68
HasImmediate$1$ = 69
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 72
_Result$1$ = 104
_Result$1$ = 104
$T18 = 104
tv6734 = 104
tv6687 = 104
$T19 = 104
tv6986 = 112
tv6664 = 112
this$GSCopy$1$ = 120
<end>$L2$1$ = 120
text_size$20 = 120
text_size$21 = 120
text_size$22 = 120
CurrentId$1$ = 128
$T23 = 136
$T24 = 136
HeaderRect$25 = 136
$T26 = 136
$T27 = 152
$T28 = 152
$T29 = 152
$T30 = 152
$T31 = 152
$T32 = 152
$T33 = 192
$T34 = 200
$T35 = 200
$T36 = 200
$T37 = 200
$T38 = 200
$T39 = 200
$T40 = 200
$T41 = 216
$T42 = 248
$T43 = 280
<end>$L0$1$ = 288
$T44 = 288
tv7127 = 304
$T45 = 312
$T46 = 344
_Temp$47 = 360
$T48 = 360
$T49 = 360
$T50 = 360
$T51 = 360
$T52 = 360
__$ArrayPad$ = 392
this$ = 576
?dtor$3@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA PROC ; `UIAINBNodeSplitTiming::Render'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T9[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN50@dtor$3
	and	DWORD PTR $T9[rbp], -3
	lea	rcx, QWORD PTR $T51[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN50@dtor$3:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSplitTiming::Render'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv6997 = 64
$T9 = 64
i$1$ = 68
HasImmediate$1$ = 69
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 72
_Result$1$ = 104
_Result$1$ = 104
$T18 = 104
tv6734 = 104
tv6687 = 104
$T19 = 104
tv6986 = 112
tv6664 = 112
this$GSCopy$1$ = 120
<end>$L2$1$ = 120
text_size$20 = 120
text_size$21 = 120
text_size$22 = 120
CurrentId$1$ = 128
$T23 = 136
$T24 = 136
HeaderRect$25 = 136
$T26 = 136
$T27 = 152
$T28 = 152
$T29 = 152
$T30 = 152
$T31 = 152
$T32 = 152
$T33 = 192
$T34 = 200
$T35 = 200
$T36 = 200
$T37 = 200
$T38 = 200
$T39 = 200
$T40 = 200
$T41 = 216
$T42 = 248
$T43 = 280
<end>$L0$1$ = 288
$T44 = 288
tv7127 = 304
$T45 = 312
$T46 = 344
_Temp$47 = 360
$T48 = 360
$T49 = 360
$T50 = 360
$T51 = 360
$T52 = 360
__$ArrayPad$ = 392
this$ = 576
?dtor$4@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA PROC ; `UIAINBNodeSplitTiming::Render'::`1'::dtor$4
	lea	rcx, QWORD PTR $T31[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSplitTiming::Render'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv6997 = 64
$T9 = 64
i$1$ = 68
HasImmediate$1$ = 69
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 72
_Result$1$ = 104
_Result$1$ = 104
$T18 = 104
tv6734 = 104
tv6687 = 104
$T19 = 104
tv6986 = 112
tv6664 = 112
this$GSCopy$1$ = 120
<end>$L2$1$ = 120
text_size$20 = 120
text_size$21 = 120
text_size$22 = 120
CurrentId$1$ = 128
$T23 = 136
$T24 = 136
HeaderRect$25 = 136
$T26 = 136
$T27 = 152
$T28 = 152
$T29 = 152
$T30 = 152
$T31 = 152
$T32 = 152
$T33 = 192
$T34 = 200
$T35 = 200
$T36 = 200
$T37 = 200
$T38 = 200
$T39 = 200
$T40 = 200
$T41 = 216
$T42 = 248
$T43 = 280
<end>$L0$1$ = 288
$T44 = 288
tv7127 = 304
$T45 = 312
$T46 = 344
_Temp$47 = 360
$T48 = 360
$T49 = 360
$T50 = 360
$T51 = 360
$T52 = 360
__$ArrayPad$ = 392
this$ = 576
?dtor$5@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA PROC ; `UIAINBNodeSplitTiming::Render'::`1'::dtor$5
	lea	rcx, QWORD PTR $T41[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??Render@UIAINBNodeSplitTiming@@UEAAXXZ@4HA ENDP ; `UIAINBNodeSplitTiming::Render'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
;	COMDAT ?PostProcessLinkedNodeInfo@UIAINBNodeSplitTiming@@UEAAXAEAUPin@UIAINBNodeBase@@AEAULinkedNodeInfo@AINBFile@@@Z
_TEXT	SEGMENT
this$ = 8
StartPin$ = 16
Info$ = 24
?PostProcessLinkedNodeInfo@UIAINBNodeSplitTiming@@UEAAXAEAUPin@UIAINBNodeBase@@AEAULinkedNodeInfo@AINBFile@@@Z PROC ; UIAINBNodeSplitTiming::PostProcessLinkedNodeInfo, COMDAT

; 192  :     switch (StartPin.ParameterIndex) {

	mov	ecx, DWORD PTR [rdx+24]
	test	ecx, ecx
	je	SHORT $LN4@PostProces
	sub	ecx, 1
	je	SHORT $LN5@PostProces
	cmp	ecx, 1
	jne	SHORT $LN2@PostProces
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3395 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_05KMBJHHBA@Leave@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 203  : }

	lea	rcx, QWORD PTR [r8+104]
	mov	r8d, 5
	jmp	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN5@PostProces:

; 193  :     case 0:
; 194  :         Info.ConnectionName = "Enter";
; 195  :         break;
; 196  :     case 1:
; 197  :         Info.ConnectionName = "Update";

	lea	rcx, QWORD PTR [r8+104]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3395 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 6
	lea	rdx, OFFSET FLAT:??_C@_06LMAGPFNF@Update@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 203  : }

	jmp	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN4@PostProces:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3395 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_05IAOCCJNL@Enter@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 203  : }

	lea	rcx, QWORD PTR [r8+104]
	mov	r8d, 5
	jmp	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@PostProces:
	ret	0
?PostProcessLinkedNodeInfo@UIAINBNodeSplitTiming@@UEAAXAEAUPin@UIAINBNodeBase@@AEAULinkedNodeInfo@AINBFile@@@Z ENDP ; UIAINBNodeSplitTiming::PostProcessLinkedNodeInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
;	COMDAT ?RenderLinks@UIAINBNodeSplitTiming@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 72
$T4 = 88
this$ = 176
Nodes$ = 184
?RenderLinks@UIAINBNodeSplitTiming@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z PROC ; UIAINBNodeSplitTiming::RenderLinks, COMDAT

; 206  : {

$LN112:
	mov	r11, rsp
	mov	QWORD PTR [r11+24], rbx
	push	rbp
	push	rsi
	push	r12
	push	r13
	push	r14
	sub	rsp, 128				; 00000080H

; 207  :     uint32_t CurrentLinkId = mEditorId + 500; // Link start at +500

	mov	ebp, DWORD PTR [rcx+16]

; 208  :     for (int i = 0; i < mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size(); i++) {

	xor	r13d, r13d
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r12, 8040888442386214807		; 6f96f96f96f96f97H
	mov	rcx, QWORD PTR [rcx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 207  :     uint32_t CurrentLinkId = mEditorId + 500; // Link start at +500

	add	ebp, 500				; 000001f4H
	mov	r14, rdx

; 208  :     for (int i = 0; i < mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size(); i++) {

	mov	esi, r13d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+448]
	sub	rax, QWORD PTR [rcx+440]
	sar	rax, 3
	imul	rax, r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 208  :     for (int i = 0; i < mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size(); i++) {

	test	rax, rax
	je	$LN3@RenderLink
	mov	QWORD PTR [r11+8], rdi
	mov	edx, r13d
	mov	QWORD PTR [r11+16], r15
	movaps	XMMWORD PTR [rsp+112], xmm6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	movss	xmm6, DWORD PTR __real@3f800000
$LL4@RenderLink:

; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rdi, rdx, 312				; 00000138H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 209  :         if (mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex == -1 || mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex >= Nodes.size())

	mov	rdx, QWORD PTR [rcx+440]
	mov	r15d, ebp
	mov	eax, DWORD PTR [rdx+rdi+4]
	cmp	eax, -1					; ffffffffH
	je	$LN2@RenderLink
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [r14+8]
	sub	rcx, QWORD PTR [r14]
	sar	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 209  :         if (mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex == -1 || mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex >= Nodes.size())

	cmp	rax, rcx
	jae	$LN2@RenderLink

; 212  :         uint32_t StartPinId = mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].ConnectionName == "Enter" ? mPinIdEnter : 

	lea	rax, QWORD PTR [rdx+104]
	add	rax, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rax

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	r8, QWORD PTR [rax+24]

; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	mov	rdx, QWORD PTR [rax+16]

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	r8, 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN98@RenderLink

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rax]
$LN98@RenderLink:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdx, 5
	jne	SHORT $LN10@RenderLink

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	cmp	DWORD PTR [rcx], 1702129221		; 65746e45H
	jne	SHORT $LN10@RenderLink
	cmp	BYTE PTR [rcx+4], 114			; 00000072H
	jne	SHORT $LN10@RenderLink
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 212  :         uint32_t StartPinId = mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].ConnectionName == "Enter" ? mPinIdEnter : 

	mov	r9d, DWORD PTR [rbx+272]
	jmp	SHORT $LN9@RenderLink
$LN10@RenderLink:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	r8, 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN80@RenderLink

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rax]
$LN80@RenderLink:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdx, 6
	jne	SHORT $LN8@RenderLink

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	cmp	DWORD PTR [rax], 1633972309		; 61647055H
	jne	SHORT $LN8@RenderLink
	cmp	WORD PTR [rax+4], 25972			; 00006574H
	jne	SHORT $LN8@RenderLink
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 212  :         uint32_t StartPinId = mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].ConnectionName == "Enter" ? mPinIdEnter : 

	mov	r9d, DWORD PTR [rbx+276]
	jmp	SHORT $LN9@RenderLink
$LN8@RenderLink:
	mov	r9d, DWORD PTR [rbx+280]
$LN9@RenderLink:

; 216  :         ed::Link(CurrentLinkId++, StartPinId, Nodes[mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex]->mEditorId + 1, GetValueTypeColor(6));

	mov	r8b, 6
	lea	rdx, QWORD PTR $T3[rsp]
	call	?GetValueTypeColor@UIAINBNodeBase@@QEAA?AUImColor@@E@Z ; UIAINBNodeBase::GetValueTypeColor
	mov	edx, r9d
	lea	r9, QWORD PTR $T2[rsp]
	movss	DWORD PTR [rsp+32], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2591 :     inline operator ImVec4() const                                  { return Value; }

	movups	xmm0, XMMWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 216  :         ed::Link(CurrentLinkId++, StartPinId, Nodes[mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex]->mEditorId + 1, GetValueTypeColor(6));

	mov	rax, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2591 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T2[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 216  :         ed::Link(CurrentLinkId++, StartPinId, Nodes[mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex]->mEditorId + 1, GetValueTypeColor(6));

	mov	rcx, QWORD PTR [rax+440]
	mov	rax, QWORD PTR [r14]
	mov	ecx, DWORD PTR [rcx+rdi+4]
	mov	rcx, QWORD PTR [rax+rcx*8]
	mov	r8d, DWORD PTR [rcx+16]
	mov	ecx, ebp
	inc	r8d
	inc	ebp
	call	?Link@NodeEditor@ax@@YA_NULinkId@12@UPinId@12@1AEBUImVec4@@M@Z ; ax::NodeEditor::Link
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 217  :         mLinks.insert({ CurrentLinkId - 1, Link { .ObjectPtr = mNode, .Type = LinkType::Flow, .ParameterIndex = (uint16_t)i } });

	lea	rcx, QWORD PTR [rbx+184]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T1[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR $T1[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	rdx, QWORD PTR $T4[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	DWORD PTR $T1[rsp], r15d
	mov	DWORD PTR $T1[rsp+16], 1
	mov	WORD PTR $T1[rsp+20], r13w
	mov	WORD PTR $T1[rsp+22], si
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	call	??$emplace@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IULink@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIULink@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Link,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Link> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Link> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 218  :         Nodes[mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex]->mFlowLinked = true;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+440]
	mov	rax, QWORD PTR [r14]
	mov	ecx, DWORD PTR [rcx+rdi+4]
	mov	rcx, QWORD PTR [rax+rcx*8]
	mov	BYTE PTR [rcx+264], 1
$LN2@RenderLink:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 208  :     for (int i = 0; i < mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size(); i++) {

	inc	esi
	movsxd	rdx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+448]
	sub	rax, QWORD PTR [rcx+440]
	sar	rax, 3
	imul	rax, r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 208  :     for (int i = 0; i < mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size(); i++) {

	cmp	rdx, rax
	jb	$LL4@RenderLink
	movaps	xmm6, XMMWORD PTR [rsp+112]
	mov	r15, QWORD PTR [rsp+184]
	mov	rdi, QWORD PTR [rsp+176]
$LN3@RenderLink:

; 219  :     }
; 220  : }

	mov	rbx, QWORD PTR [rsp+192]
	add	rsp, 128				; 00000080H
	pop	r14
	pop	r13
	pop	r12
	pop	rsi
	pop	rbp
	ret	0
?RenderLinks@UIAINBNodeSplitTiming@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z ENDP ; UIAINBNodeSplitTiming::RenderLinks
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp
;	COMDAT ?GetHeaderColor@UIAINBNodeSplitTiming@@UEAA?AUImColor@@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?GetHeaderColor@UIAINBNodeSplitTiming@@UEAA?AUImColor@@XZ PROC ; UIAINBNodeSplitTiming::GetHeaderColor, COMDAT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	mov	DWORD PTR [rdx], 1050714273		; 3ea0a0a1H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 224  :     return ImColor(80, 15, 80);

	mov	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	mov	DWORD PTR [rdx+4], 1030811890		; 3d70f0f2H
	mov	DWORD PTR [rdx+8], 1050714273		; 3ea0a0a1H
	mov	DWORD PTR [rdx+12], 1065353216		; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeSplitTiming.cpp

; 225  : }

	ret	0
?GetHeaderColor@UIAINBNodeSplitTiming@@UEAA?AUImColor@@XZ ENDP ; UIAINBNodeSplitTiming::GetHeaderColor
_TEXT	ENDS
END
