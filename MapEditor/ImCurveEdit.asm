; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

;	COMDAT ?mousePosOrigin@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@2@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@4U4@A
_BSS	SEGMENT
?mousePosOrigin@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@2@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@4U4@A DQ 01H DUP (?) ; `ImCurveEdit::Edit'::`2'::mousePosOrigin
_BSS	ENDS
;	COMDAT ?quadSelection@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@2@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@4U4@A
_BSS	SEGMENT
?quadSelection@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@2@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@4U4@A DQ 01H DUP (?) ; `ImCurveEdit::Edit'::`2'::quadSelection
_BSS	ENDS
;	COMDAT ?originalPoints@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@2@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@4V?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@A
_BSS	SEGMENT
?originalPoints@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@2@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@4V?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@A DB 018H DUP (?) ; `ImCurveEdit::Edit'::`2'::originalPoints
_BSS	ENDS
;	COMDAT ?localOffsets@?1??DrawPoint@ImCurveEdit@@YAHPEAUImDrawList@@UImVec2@@U4@2_N@Z@4QBU4@B
CONST	SEGMENT
?localOffsets@?1??DrawPoint@ImCurveEdit@@YAHPEAUImDrawList@@UImVec2@@U4@2_N@Z@4QBU4@B DD 03f800000r ; 1 ; `ImCurveEdit::DrawPoint'::`2'::localOffsets
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	0bf800000r			; -1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0bf800000r			; -1
PUBLIC	??$destroy_at@UEditPoint@ImCurveEdit@@@std@@YAXQEAUEditPoint@ImCurveEdit@@@Z ; std::destroy_at<ImCurveEdit::EditPoint>
PUBLIC	??$_Destroy_in_place@PEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<ImCurveEdit::EditPoint,void *> *>
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@2@_K@Z ; std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> >::deallocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@2@QEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >::deallocate
PUBLIC	??$destroy@UEditPoint@ImCurveEdit@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@QEAUEditPoint@ImCurveEdit@@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >::destroy<ImCurveEdit::EditPoint>
PUBLIC	??$addressof@UEditPoint@ImCurveEdit@@@std@@YAPEAUEditPoint@ImCurveEdit@@AEAU12@@Z ; std::addressof<ImCurveEdit::EditPoint>
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<ImCurveEdit::EditPoint,void *>::_Freenode0<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >
PUBLIC	??$exchange@PEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@0@AEAPEAU10@0@Z ; std::exchange<std::_Tree_node<ImCurveEdit::EditPoint,void *> *,std::_Tree_node<ImCurveEdit::EditPoint,void *> * &>
PUBLIC	??$_Freenode@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<ImCurveEdit::EditPoint,void *>::_Freenode<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<ImCurveEdit::EditPoint> > >
PUBLIC	??$_Destroy_range@V?$allocator@UImVec2@@@std@@@std@@YAXPEAUImVec2@@QEAU1@AEAV?$allocator@UImVec2@@@0@@Z ; std::_Destroy_range<std::allocator<ImVec2> >
PUBLIC	??$_Erase_head@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<ImCurveEdit::EditPoint> >::_Erase_head<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@PEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<ImCurveEdit::EditPoint> >::_Erase_tree<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UImVec2@@@std@@V?$_Vector_val@U?$_Simple_types@UImVec2@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UImVec2@@@2@XZ ; std::_Compressed_pair<std::allocator<ImVec2>,std::_Vector_val<std::_Simple_types<ImVec2> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> >,std::_Tree_val<std::_Tree_simple_types<ImCurveEdit::EditPoint> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@UImVec2@@@std@@QEAAXQEAUImVec2@@_K@Z ; std::allocator<ImVec2>::deallocate
PUBLIC	?_Getal@?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@AEAAAEAV?$allocator@UImVec2@@@2@XZ ; std::vector<ImVec2,std::allocator<ImVec2> >::_Getal
PUBLIC	?_Getal@?$_Tree@V?$_Tset_traits@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tset_traits<ImCurveEdit::EditPoint,std::less<ImCurveEdit::EditPoint>,std::allocator<ImCurveEdit::EditPoint>,0> >::_Getal
PUBLIC	?_Get_scary@?$_Tree@V?$_Tset_traits@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<ImCurveEdit::EditPoint,std::less<ImCurveEdit::EditPoint>,std::allocator<ImCurveEdit::EditPoint>,0> >::_Get_scary
PUBLIC	?_Tidy@?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@AEAAXXZ ; std::vector<ImVec2,std::allocator<ImVec2> >::_Tidy
PUBLIC	??1?$_Tree@V?$_Tset_traits@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tset_traits<ImCurveEdit::EditPoint,std::less<ImCurveEdit::EditPoint>,std::allocator<ImCurveEdit::EditPoint>,0> >::~_Tree<std::_Tset_traits<ImCurveEdit::EditPoint,std::less<ImCurveEdit::EditPoint>,std::allocator<ImCurveEdit::EditPoint>,0> >
PUBLIC	??1?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@QEAA@XZ ; std::vector<ImVec2,std::allocator<ImVec2> >::~vector<ImVec2,std::allocator<ImVec2> >
PUBLIC	??1?$set@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@@std@@QEAA@XZ ; std::set<ImCurveEdit::EditPoint,std::less<ImCurveEdit::EditPoint>,std::allocator<ImCurveEdit::EditPoint> >::~set<ImCurveEdit::EditPoint,std::less<ImCurveEdit::EditPoint>,std::allocator<ImCurveEdit::EditPoint> >
;	COMDAT ?selection@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@2@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@4V?$set@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@@std@@A
_BSS	SEGMENT
?selection@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@2@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@4V?$set@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@@std@@A DB 010H DUP (?) ; `ImCurveEdit::Edit'::`2'::selection
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Erase_head@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@@Z DD imagerel $LN107
	DD	imagerel $LN107+113
	DD	imagerel $unwind$??$_Erase_head@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Erase_tree@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@PEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@1@@Z DD imagerel $LN61
	DD	imagerel $LN61+77
	DD	imagerel $unwind$??$_Erase_tree@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@PEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@UImVec2@@@std@@QEAAXQEAUImVec2@@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+67
	DD	imagerel $unwind$?deallocate@?$allocator@UImVec2@@@std@@QEAAXQEAUImVec2@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@AEAAXXZ DD imagerel $LN30
	DD	imagerel $LN30+92
	DD	imagerel $unwind$?_Tidy@?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@QEAA@XZ DD imagerel $LN33
	DD	imagerel $LN33+92
	DD	imagerel $unwind$??1?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fselection@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@1@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@YAXXZ DD imagerel ??__Fselection@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@1@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@YAXXZ
	DD	imagerel ??__Fselection@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@1@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@YAXXZ+99
	DD	imagerel $unwind$??__Fselection@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@1@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__ForiginalPoints@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@1@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@YAXXZ DD imagerel ??__ForiginalPoints@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@1@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@YAXXZ
	DD	imagerel ??__ForiginalPoints@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@1@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@YAXXZ+102
	DD	imagerel $unwind$??__ForiginalPoints@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@1@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@YAXXZ
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__ForiginalPoints@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@1@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fselection@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@1@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@YAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@UImVec2@@@std@@QEAAXQEAUImVec2@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Erase_tree@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@PEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@1@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Erase_head@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??__ForiginalPoints@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@1@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@YAXXZ
text$yd	SEGMENT
??__ForiginalPoints@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@1@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@YAXXZ PROC ; `ImCurveEdit::Edit'::`2'::`dynamic atexit destructor for 'originalPoints'', COMDAT
	sub	rsp, 40					; 00000028H

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR ?originalPoints@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@2@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@4V?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@A
	test	rcx, rcx
	je	SHORT $LN6@dynamic

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR ?originalPoints@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@2@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@4V?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@A+16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN24@dynamic

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN24@dynamic
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN24@dynamic:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR ?originalPoints@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@2@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@4V?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@A, 0

; 2050 :             _Mylast  = nullptr;

	movdqu	XMMWORD PTR ?originalPoints@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@2@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@4V?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@A+8, xmm0
$LN6@dynamic:
	add	rsp, 40					; 00000028H
	ret	0
$LN30@dynamic:
??__ForiginalPoints@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@1@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@YAXXZ ENDP ; `ImCurveEdit::Edit'::`2'::`dynamic atexit destructor for 'originalPoints''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??__Fselection@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@1@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@YAXXZ
text$yd	SEGMENT
??__Fselection@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@1@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@YAXXZ PROC ; `ImCurveEdit::Edit'::`2'::`dynamic atexit destructor for 'selection'', COMDAT
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	rcx, QWORD PTR ?selection@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@2@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@4V?$set@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@@std@@A
	mov	rbx, QWORD PTR [rcx+8]

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	jne	SHORT $LN12@dynamic
	npad	9
$LL11@dynamic:

; 746  :             _Erase_tree(_Al, _Rootnode->_Right);

	mov	r8, QWORD PTR [rbx+16]
	lea	rdx, OFFSET FLAT:?selection@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@2@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@4V?$set@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@@std@@A
	lea	rcx, OFFSET FLAT:?selection@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@2@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@4V?$set@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@@std@@A
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@PEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<ImCurveEdit::EditPoint> >::_Erase_tree<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rbx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL11@dynamic
	mov	rcx, QWORD PTR ?selection@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@2@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@4V?$set@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@@std@@A
$LN12@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 40					; 00000028H
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	??3@YAXPEAX_K@Z				; operator delete
??__Fselection@?1??Edit@ImCurveEdit@@YAHAEAUDelegate@1@AEBUImVec2@@IPEBUImRect@@PEAU?$ImVector@UEditPoint@ImCurveEdit@@@@@Z@YAXXZ ENDP ; `ImCurveEdit::Edit'::`2'::`dynamic atexit destructor for 'selection''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??1?$set@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$set@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@@std@@QEAA@XZ PROC ; std::set<ImCurveEdit::EditPoint,std::less<ImCurveEdit::EditPoint>,std::allocator<ImCurveEdit::EditPoint> >::~set<ImCurveEdit::EditPoint,std::less<ImCurveEdit::EditPoint>,std::allocator<ImCurveEdit::EditPoint> >, COMDAT

; 1082 :         _Scary->_Erase_head(_Getal());

	mov	rdx, rcx
	jmp	??$_Erase_head@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<ImCurveEdit::EditPoint> >::_Erase_head<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >
??1?$set@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@@std@@QEAA@XZ ENDP ; std::set<ImCurveEdit::EditPoint,std::less<ImCurveEdit::EditPoint>,std::allocator<ImCurveEdit::EditPoint> >::~set<ImCurveEdit::EditPoint,std::less<ImCurveEdit::EditPoint>,std::allocator<ImCurveEdit::EditPoint> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@QEAA@XZ PROC ; std::vector<ImVec2,std::allocator<ImVec2> >::~vector<ImVec2,std::allocator<ImVec2> >, COMDAT

; 766  :     _CONSTEXPR20 ~vector() noexcept {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN22@vector

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN19@vector

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN22@vector:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 772  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN30@vector:
??1?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@QEAA@XZ ENDP ; std::vector<ImVec2,std::allocator<ImVec2> >::~vector<ImVec2,std::allocator<ImVec2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tset_traits@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tree@V?$_Tset_traits@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Tree<std::_Tset_traits<ImCurveEdit::EditPoint,std::less<ImCurveEdit::EditPoint>,std::allocator<ImCurveEdit::EditPoint>,0> >::~_Tree<std::_Tset_traits<ImCurveEdit::EditPoint,std::less<ImCurveEdit::EditPoint>,std::allocator<ImCurveEdit::EditPoint>,0> >, COMDAT

; 1081 :         const auto _Scary = _Get_scary();
; 1082 :         _Scary->_Erase_head(_Getal());

	mov	rdx, rcx
	jmp	??$_Erase_head@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<ImCurveEdit::EditPoint> >::_Erase_head<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >
??1?$_Tree@V?$_Tset_traits@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Tree<std::_Tset_traits<ImCurveEdit::EditPoint,std::less<ImCurveEdit::EditPoint>,std::allocator<ImCurveEdit::EditPoint>,0> >::~_Tree<std::_Tset_traits<ImCurveEdit::EditPoint,std::less<ImCurveEdit::EditPoint>,std::allocator<ImCurveEdit::EditPoint>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@AEAAXXZ PROC ; std::vector<ImVec2,std::allocator<ImVec2> >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN30:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 2053 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Tidy:
?_Tidy@?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@AEAAXXZ ENDP ; std::vector<ImVec2,std::allocator<ImVec2> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tset_traits@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_scary@?$_Tree@V?$_Tset_traits@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<ImCurveEdit::EditPoint,std::less<ImCurveEdit::EditPoint>,std::allocator<ImCurveEdit::EditPoint>,0> >::_Get_scary, COMDAT

; 1969 :         return _STD addressof(_Mypair._Myval2._Myval2);

	mov	rax, rcx

; 1970 :     }

	ret	0
?_Get_scary@?$_Tree@V?$_Tset_traits@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<ImCurveEdit::EditPoint,std::less<ImCurveEdit::EditPoint>,std::allocator<ImCurveEdit::EditPoint>,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tset_traits@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Tree@V?$_Tset_traits@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<ImCurveEdit::EditPoint,std::less<ImCurveEdit::EditPoint>,std::allocator<ImCurveEdit::EditPoint>,0> >::_Getal, COMDAT

; 1961 :         return _Mypair._Myval2._Get_first();

	mov	rax, rcx

; 1962 :     }

	ret	0
?_Getal@?$_Tree@V?$_Tset_traits@UEditPoint@ImCurveEdit@@U?$less@UEditPoint@ImCurveEdit@@@std@@V?$allocator@UEditPoint@ImCurveEdit@@@4@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<ImCurveEdit::EditPoint,std::less<ImCurveEdit::EditPoint>,std::allocator<ImCurveEdit::EditPoint>,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@AEAAAEAV?$allocator@UImVec2@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@AEAAAEAV?$allocator@UImVec2@@@2@XZ PROC ; std::vector<ImVec2,std::allocator<ImVec2> >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@UImVec2@@V?$allocator@UImVec2@@@std@@@std@@AEAAAEAV?$allocator@UImVec2@@@2@XZ ENDP ; std::vector<ImVec2,std::allocator<ImVec2> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@UImVec2@@@std@@QEAAXQEAUImVec2@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@UImVec2@@@std@@QEAAXQEAUImVec2@@_K@Z PROC ; std::allocator<ImVec2>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@UImVec2@@@std@@QEAAXQEAUImVec2@@_K@Z ENDP ; std::allocator<ImVec2>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> >,std::_Tree_val<std::_Tree_simple_types<ImCurveEdit::EditPoint> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> >,std::_Tree_val<std::_Tree_simple_types<ImCurveEdit::EditPoint> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UImVec2@@@std@@V?$_Vector_val@U?$_Simple_types@UImVec2@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UImVec2@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UImVec2@@@std@@V?$_Vector_val@U?$_Simple_types@UImVec2@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UImVec2@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<ImVec2>,std::_Vector_val<std::_Simple_types<ImVec2> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UImVec2@@@std@@V?$_Vector_val@U?$_Simple_types@UImVec2@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UImVec2@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<ImVec2>,std::_Vector_val<std::_Simple_types<ImVec2> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@PEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@1@@Z
_TEXT	SEGMENT
this$ = 64
_Al$ = 72
_Rootnode$ = 80
??$_Erase_tree@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@PEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<ImCurveEdit::EditPoint> >::_Erase_tree<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >, COMDAT

; 744  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

$LN61:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [r8+25], 0
	mov	rbx, r8
	mov	rsi, rdx
	mov	rdi, rcx
	jne	SHORT $LN3@Erase_tree
	npad	8
$LL2@Erase_tree:

; 746  :             _Erase_tree(_Al, _Rootnode->_Right);

	mov	r8, QWORD PTR [rbx+16]
	mov	rdx, rsi
	mov	rcx, rdi
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@PEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<ImCurveEdit::EditPoint> >::_Erase_tree<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rbx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL2@Erase_tree
$LN3@Erase_tree:

; 747  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));
; 748  :         }
; 749  :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$_Erase_tree@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@PEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<ImCurveEdit::EditPoint> >::_Erase_tree<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$_Erase_head@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al$ = 56
??$_Erase_head@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<ImCurveEdit::EditPoint> >::_Erase_head<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >, COMDAT

; 752  :     void _Erase_head(_Alnode& _Al) noexcept {

$LN107:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 753  :         this->_Orphan_all();
; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	rbx, QWORD PTR [rcx]
	mov	rsi, rdx
	mov	rdi, rcx
	mov	rbx, QWORD PTR [rbx+8]

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	jne	SHORT $LN5@Erase_head
	npad	14
$LL4@Erase_head:

; 746  :             _Erase_tree(_Al, _Rootnode->_Right);

	mov	r8, QWORD PTR [rbx+16]
	mov	rdx, rsi
	mov	rcx, rdi
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@PEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<ImCurveEdit::EditPoint> >::_Erase_tree<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rbx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL4@Erase_head
$LN5@Erase_head:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rdi]
	mov	edx, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 756  :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Erase_head@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<ImCurveEdit::EditPoint> >::_Erase_head<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UImVec2@@@std@@@std@@YAXPEAUImVec2@@QEAU1@AEAV?$allocator@UImVec2@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@UImVec2@@@std@@@std@@YAXPEAUImVec2@@QEAU1@AEAV?$allocator@UImVec2@@@0@@Z PROC ; std::_Destroy_range<std::allocator<ImVec2> >, COMDAT

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {
; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	ret	0
??$_Destroy_range@V?$allocator@UImVec2@@@std@@@std@@YAXPEAUImVec2@@QEAU1@AEAV?$allocator@UImVec2@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<ImVec2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<ImCurveEdit::EditPoint> > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@UEditPoint@ImCurveEdit@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<ImCurveEdit::EditPoint> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$_Freenode@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$_Freenode@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_Tree_node<ImCurveEdit::EditPoint,void *>::_Freenode<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >, COMDAT

; 380  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

	mov	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 40					; 00000028H
	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Freenode@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_Tree_node<ImCurveEdit::EditPoint,void *>::_Freenode<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@0@AEAPEAU10@0@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@0@AEAPEAU10@0@Z PROC ; std::exchange<std::_Tree_node<ImCurveEdit::EditPoint,void *> *,std::_Tree_node<ImCurveEdit::EditPoint,void *> * &>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@0@AEAPEAU10@0@Z ENDP ; std::exchange<std::_Tree_node<ImCurveEdit::EditPoint,void *> *,std::_Tree_node<ImCurveEdit::EditPoint,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$_Freenode0@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_Tree_node<ImCurveEdit::EditPoint,void *>::_Freenode0<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >, COMDAT

; 371  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

	mov	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 40					; 00000028H
	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Freenode0@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_Tree_node<ImCurveEdit::EditPoint,void *>::_Freenode0<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@UEditPoint@ImCurveEdit@@@std@@YAPEAUEditPoint@ImCurveEdit@@AEAU12@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@UEditPoint@ImCurveEdit@@@std@@YAPEAUEditPoint@ImCurveEdit@@AEAU12@@Z PROC ; std::addressof<ImCurveEdit::EditPoint>, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@UEditPoint@ImCurveEdit@@@std@@YAPEAUEditPoint@ImCurveEdit@@AEAU12@@Z ENDP ; std::addressof<ImCurveEdit::EditPoint>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy@UEditPoint@ImCurveEdit@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@QEAUEditPoint@ImCurveEdit@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$dead$ = 16
??$destroy@UEditPoint@ImCurveEdit@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@QEAUEditPoint@ImCurveEdit@@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >::destroy<ImCurveEdit::EditPoint>, COMDAT

; 725  : #if _HAS_CXX20
; 726  :         _STD destroy_at(_Ptr);
; 727  : #else // _HAS_CXX20
; 728  :         _Ptr->~_Uty();
; 729  : #endif // _HAS_CXX20
; 730  :     }

	ret	0
??$destroy@UEditPoint@ImCurveEdit@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@1@QEAUEditPoint@ImCurveEdit@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >::destroy<ImCurveEdit::EditPoint>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@2@QEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@2@QEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >::deallocate, COMDAT

; 701  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

	mov	rcx, rdx

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 40					; 00000028H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@2@QEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@2@_K@Z PROC ; std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> >::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

	mov	rcx, rdx

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 40					; 00000028H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$allocator@U?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@2@_K@Z ENDP ; std::allocator<std::_Tree_node<ImCurveEdit::EditPoint,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$dead$ = 8
??$_Destroy_in_place@PEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<ImCurveEdit::EditPoint,void *> *>, COMDAT

; 305  :     if constexpr (is_array_v<_Ty>) {
; 306  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 307  :     } else {
; 308  :         _Obj.~_Ty();
; 309  :     }
; 310  : }

	ret	0
??$_Destroy_in_place@PEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@UEditPoint@ImCurveEdit@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<ImCurveEdit::EditPoint,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy_at@UEditPoint@ImCurveEdit@@@std@@YAXQEAUEditPoint@ImCurveEdit@@@Z
_TEXT	SEGMENT
_Location$dead$ = 8
??$destroy_at@UEditPoint@ImCurveEdit@@@std@@YAXQEAUEditPoint@ImCurveEdit@@@Z PROC ; std::destroy_at<ImCurveEdit::EditPoint>, COMDAT

; 315  : #if _HAS_CXX20
; 316  :     if constexpr (is_array_v<_Ty>) {
; 317  :         _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 318  :     } else
; 319  : #endif // _HAS_CXX20
; 320  :     {
; 321  :         _Location->~_Ty();
; 322  :     }
; 323  : }

	ret	0
??$destroy_at@UEditPoint@ImCurveEdit@@@std@@YAXQEAUEditPoint@ImCurveEdit@@@Z ENDP ; std::destroy_at<ImCurveEdit::EditPoint>
_TEXT	ENDS
END
